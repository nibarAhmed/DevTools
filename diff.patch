diff --git a/Assembly-CSharp/.gitignore b/Assembly-CSharp/.gitignore
new file mode 100644
index 0000000..17c1c11
--- /dev/null
+++ b/Assembly-CSharp/.gitignore
@@ -0,0 +1,389 @@
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+##
+## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore
+
+# User-specific files
+*.rsuser
+*.suo
+*.user
+*.userosscache
+*.sln.docstates
+
+# User-specific files (MonoDevelop/Xamarin Studio)
+*.userprefs
+
+# Mono auto generated files
+mono_crash.*
+
+# Build results
+[Dd]ebug/
+[Dd]ebugPublic/
+[Rr]elease/
+[Rr]eleases/
+x64/
+x86/
+[Ww][Ii][Nn]32/
+[Aa][Rr][Mm]/
+[Aa][Rr][Mm]64/
+bld/
+[Bb]in/
+[Oo]bj/
+[Ll]og/
+[Ll]ogs/
+
+# Visual Studio 2015/2017 cache/options directory
+.vs/
+# Uncomment if you have tasks that create the project's static files in wwwroot
+#wwwroot/
+
+# Visual Studio 2017 auto generated files
+Generated\ Files/
+
+# MSTest test Results
+[Tt]est[Rr]esult*/
+[Bb]uild[Ll]og.*
+
+# NUnit
+*.VisualState.xml
+TestResult.xml
+nunit-*.xml
+
+# Build Results of an ATL Project
+[Dd]ebugPS/
+[Rr]eleasePS/
+dlldata.c
+
+# Benchmark Results
+BenchmarkDotNet.Artifacts/
+
+# .NET Core
+project.lock.json
+project.fragment.lock.json
+artifacts/
+
+# ASP.NET Scaffolding
+ScaffoldingReadMe.txt
+
+# StyleCop
+StyleCopReport.xml
+
+# Files built by Visual Studio
+*_i.c
+*_p.c
+*_h.h
+*.ilk
+*.meta
+*.obj
+*.iobj
+*.pch
+*.pdb
+*.ipdb
+*.pgc
+*.pgd
+*.rsp
+*.sbr
+*.tlb
+*.tli
+*.tlh
+*.tmp
+*.tmp_proj
+*_wpftmp.csproj
+*.log
+*.tlog
+*.vspscc
+*.vssscc
+.builds
+*.pidb
+*.svclog
+*.scc
+
+# Chutzpah Test files
+_Chutzpah*
+
+# Visual C++ cache files
+ipch/
+*.aps
+*.ncb
+*.opendb
+*.opensdf
+*.sdf
+*.cachefile
+*.VC.db
+*.VC.VC.opendb
+
+# Visual Studio profiler
+*.psess
+*.vsp
+*.vspx
+*.sap
+
+# Visual Studio Trace Files
+*.e2e
+
+# TFS 2012 Local Workspace
+$tf/
+
+# Guidance Automation Toolkit
+*.gpState
+
+# ReSharper is a .NET coding add-in
+_ReSharper*/
+*.[Rr]e[Ss]harper
+*.DotSettings.user
+
+# TeamCity is a build add-in
+_TeamCity*
+
+# DotCover is a Code Coverage Tool
+*.dotCover
+
+# AxoCover is a Code Coverage Tool
+.axoCover/*
+!.axoCover/settings.json
+
+# Coverlet is a free, cross platform Code Coverage Tool
+coverage*.json
+coverage*.xml
+coverage*.info
+
+# Visual Studio code coverage results
+*.coverage
+*.coveragexml
+
+# NCrunch
+_NCrunch_*
+.*crunch*.local.xml
+nCrunchTemp_*
+
+# MightyMoose
+*.mm.*
+AutoTest.Net/
+
+# Web workbench (sass)
+.sass-cache/
+
+# Installshield output folder
+[Ee]xpress/
+
+# DocProject is a documentation generator add-in
+DocProject/buildhelp/
+DocProject/Help/*.HxT
+DocProject/Help/*.HxC
+DocProject/Help/*.hhc
+DocProject/Help/*.hhk
+DocProject/Help/*.hhp
+DocProject/Help/Html2
+DocProject/Help/html
+
+# Click-Once directory
+publish/
+
+# Publish Web Output
+*.[Pp]ublish.xml
+*.azurePubxml
+# Note: Comment the next line if you want to checkin your web deploy settings,
+# but database connection strings (with potential passwords) will be unencrypted
+*.pubxml
+*.publishproj
+
+# Microsoft Azure Web App publish settings. Comment the next line if you want to
+# checkin your Azure Web App publish settings, but sensitive information contained
+# in these scripts will be unencrypted
+PublishScripts/
+
+# NuGet Packages
+*.nupkg
+# NuGet Symbol Packages
+*.snupkg
+# The packages folder can be ignored because of Package Restore
+**/[Pp]ackages/*
+# except build/, which is used as an MSBuild target.
+!**/[Pp]ackages/build/
+# Uncomment if necessary however generally it will be regenerated when needed
+#!**/[Pp]ackages/repositories.config
+# NuGet v3's project.json files produces more ignorable files
+*.nuget.props
+*.nuget.targets
+
+# Nuget personal access tokens and Credentials
+nuget.config
+
+# Microsoft Azure Build Output
+csx/
+*.build.csdef
+
+# Microsoft Azure Emulator
+ecf/
+rcf/
+
+# Windows Store app package directories and files
+AppPackages/
+BundleArtifacts/
+Package.StoreAssociation.xml
+_pkginfo.txt
+*.appx
+*.appxbundle
+*.appxupload
+
+# Visual Studio cache files
+# files ending in .cache can be ignored
+*.[Cc]ache
+# but keep track of directories ending in .cache
+!?*.[Cc]ache/
+
+# Others
+ClientBin/
+~$*
+*~
+*.dbmdl
+*.dbproj.schemaview
+*.jfm
+*.pfx
+*.publishsettings
+orleans.codegen.cs
+
+# Including strong name files can present a security risk
+# (https://github.com/github/gitignore/pull/2483#issue-259490424)
+#*.snk
+
+# Since there are multiple workflows, uncomment next line to ignore bower_components
+# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
+#bower_components/
+
+# RIA/Silverlight projects
+Generated_Code/
+
+# Backup & report files from converting an old project file
+# to a newer Visual Studio version. Backup files are not needed,
+# because we have git ;-)
+_UpgradeReport_Files/
+Backup*/
+UpgradeLog*.XML
+UpgradeLog*.htm
+ServiceFabricBackup/
+*.rptproj.bak
+
+# SQL Server files
+*.mdf
+*.ldf
+*.ndf
+
+# Business Intelligence projects
+*.rdl.data
+*.bim.layout
+*.bim_*.settings
+*.rptproj.rsuser
+*- [Bb]ackup.rdl
+*- [Bb]ackup ([0-9]).rdl
+*- [Bb]ackup ([0-9][0-9]).rdl
+
+# Microsoft Fakes
+FakesAssemblies/
+
+# GhostDoc plugin setting file
+*.GhostDoc.xml
+
+# Node.js Tools for Visual Studio
+.ntvs_analysis.dat
+node_modules/
+
+# Visual Studio 6 build log
+*.plg
+
+# Visual Studio 6 workspace options file
+*.opt
+
+# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
+*.vbw
+
+# Visual Studio LightSwitch build output
+**/*.HTMLClient/GeneratedArtifacts
+**/*.DesktopClient/GeneratedArtifacts
+**/*.DesktopClient/ModelManifest.xml
+**/*.Server/GeneratedArtifacts
+**/*.Server/ModelManifest.xml
+_Pvt_Extensions
+
+# Paket dependency manager
+.paket/paket.exe
+paket-files/
+
+# FAKE - F# Make
+.fake/
+
+# CodeRush personal settings
+.cr/personal
+
+# Python Tools for Visual Studio (PTVS)
+__pycache__/
+*.pyc
+
+# Cake - Uncomment if you are using it
+# tools/**
+# !tools/packages.config
+
+# Tabs Studio
+*.tss
+
+# Telerik's JustMock configuration file
+*.jmconfig
+
+# BizTalk build output
+*.btp.cs
+*.btm.cs
+*.odx.cs
+*.xsd.cs
+
+# OpenCover UI analysis results
+OpenCover/
+
+# Azure Stream Analytics local run output
+ASALocalRun/
+
+# MSBuild Binary and Structured Log
+*.binlog
+
+# NVidia Nsight GPU debugger configuration file
+*.nvuser
+
+# MFractors (Xamarin productivity tool) working folder
+.mfractor/
+
+# Local History for Visual Studio
+.localhistory/
+
+# BeatPulse healthcheck temp database
+healthchecksdb
+
+# Backup folder for Package Reference Convert tool in Visual Studio 2017
+MigrationBackup/
+
+# Ionide (cross platform F# VS Code tools) working folder
+.ionide/
+
+# Fody - auto-generated XML schema
+FodyWeavers.xsd
+
+# VS Code files for those working on multiple tools
+.vscode/*
+!.vscode/settings.json
+!.vscode/tasks.json
+!.vscode/launch.json
+!.vscode/extensions.json
+*.code-workspace
+
+# Local History for Visual Studio Code
+.history/
+
+# Windows Installer files from build outputs
+*.cab
+*.msi
+*.msix
+*.msm
+*.msp
+
+# JetBrains Rider
+.idea/
+*.sln.iml
+.vscode
diff --git a/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs b/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
index 71f0f29..22c8e6f 100644
--- a/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
+++ b/Assembly-CSharp/AbsDeckPickerTrayDisplay.cs
@@ -7,6 +7,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 {
@@ -23,19 +24,9 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 
 	protected class HeroFullDefLoadedCallbackData
 	{
-		[CompilerGenerated]
-		private TAG_PREMIUM <Premium>k__BackingField;
-
 		public HeroPickerButton HeroPickerButton { get; private set; }
 
-		private TAG_PREMIUM Premium
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Premium>k__BackingField = value;
-			}
-		}
+		private TAG_PREMIUM Premium { get; set; }
 
 		public HeroFullDefLoadedCallbackData(HeroPickerButton button, TAG_PREMIUM premium)
 		{
@@ -144,7 +135,7 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 
 	protected SlidingTray m_slidingTray;
 
-	protected PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
 	private AudioSource m_lastPickLine;
 
@@ -255,7 +246,7 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 		}
 		if (((SceneMgr.Get() != null) ? SceneMgr.Get().GetMode() : SceneMgr.Mode.INVALID) == SceneMgr.Mode.FRIENDLY)
 		{
-			BackOutToHub();
+				BackOutToHub();
 			if (FriendChallengeMgr.Get() != null)
 			{
 				FriendChallengeMgr.Get().CancelChallenge();
@@ -429,7 +420,7 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 		}
 	}
 
-	protected virtual void InitForMode(SceneMgr.Mode mode)
+    protected virtual void InitForMode(SceneMgr.Mode mode)
 	{
 		switch (mode)
 		{
@@ -501,22 +492,22 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 	{
 		SceneMgr.Mode mode = SceneMgr.Get().GetMode();
 		if ((mode == SceneMgr.Mode.FRIENDLY || mode == SceneMgr.Mode.TAVERN_BRAWL) && TavernBrawlManager.Get().SelectHeroBeforeMission())
-		{
-			if (m_selectedHeroButton == null)
 			{
-				Debug.LogError("Trying to play Tavern Brawl game with no m_selectedHeroButton!");
-				return;
-			}
+				if (m_selectedHeroButton == null)
+				{
+					Debug.LogError("Trying to play Tavern Brawl game with no m_selectedHeroButton!");
+					return;
+				}
 			int num = GameUtils.TranslateCardIdToDbId(m_selectedHeroButton.GetEntityDef().GetCardId());
-			if (FriendChallengeMgr.Get().IsChallengeTavernBrawl())
-			{
+				if (FriendChallengeMgr.Get().IsChallengeTavernBrawl())
+				{
 				FriendChallengeMgr.Get().SelectHero(num);
-				FriendlyChallengeHelper.Get().StartChallengeOrWaitForOpponent("GLOBAL_FRIEND_CHALLENGE_TAVERN_BRAWL_OPPONENT_WAITING_READY", OnFriendChallengeWaitingForOpponentDialogResponse);
-			}
-			else
-			{
+					FriendlyChallengeHelper.Get().StartChallengeOrWaitForOpponent("GLOBAL_FRIEND_CHALLENGE_TAVERN_BRAWL_OPPONENT_WAITING_READY", OnFriendChallengeWaitingForOpponentDialogResponse);
+				}
+				else
+				{
 				TavernBrawlManager.Get().StartGameWithHero(num);
-			}
+		}
 		}
 		SoundManager.Get().Stop(m_lastPickLine);
 	}
@@ -576,10 +567,12 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 				SoundManager.Get().LoadAndPlay(button.HeroPickerSelectedPrefab, button.gameObject, 1f, OnLastPickLineLoaded);
 			}
 			SetPlayButtonEnabled(flag);
-		}
-	}
 
-	protected virtual void UpdateHeroInfo(HeroPickerButton button)
+            OnChosenHero();
+        }
+    }
+
+    protected virtual void UpdateHeroInfo(HeroPickerButton button)
 	{
 	}
 
@@ -683,8 +676,8 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 	{
 		if (ShouldUseRankedModeLayoutForHero())
 		{
-			return m_Ranked_HeroName_Bone;
-		}
+		return m_Ranked_HeroName_Bone;
+	}
 		return m_HeroName_Bone;
 	}
 
@@ -1222,8 +1215,8 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 		if (componentInChildren != null)
 		{
 			componentInChildren.AlwaysRenderPremiumPortrait = ShouldRenderPremiumPortrait();
-			componentInChildren.UpdateMaterials();
-		}
+		componentInChildren.UpdateMaterials();
+	}
 	}
 
 	protected bool ShouldRenderPremiumPortrait()
@@ -1405,6 +1398,8 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 
 	protected void FireFormatTypePickerClosedEvent()
 	{
+		AccessibleFormatTypePickerPopup.Hide();
+
 		FormatTypePickerClosed[] array = m_FormatTypePickerClosedListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
@@ -1648,4 +1643,30 @@ public abstract class AbsDeckPickerTrayDisplay : MonoBehaviour
 	{
 		StartCoroutine(LoadHeroButtons(buttonsToDisplay));
 	}
+
+	#region Accessibility
+
+	protected virtual void OnChosenHero()
+	{
+
+	}
+
+    protected bool SupportedAdventure()
+    {
+		if (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE)
+		{
+			return false;
+		}
+
+		var selectedAdventure = AdventureConfig.Get().SelectedAdventure;
+
+		return selectedAdventure == AdventureDbId.BOH||selectedAdventure == AdventureDbId.BOM || selectedAdventure==AdventureDbId.ROTLK;
+    }
+
+    protected void PressBackButton()
+    {
+		m_backButton.TriggerRelease();
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/AbsHeroPickerButtons.cs b/Assembly-CSharp/AbsHeroPickerButtons.cs
index 5123aa3..5417378 100644
--- a/Assembly-CSharp/AbsHeroPickerButtons.cs
+++ b/Assembly-CSharp/AbsHeroPickerButtons.cs
@@ -12,19 +12,9 @@ public abstract class AbsHeroPickerButtons : MonoBehaviour
 {
 	protected class HeroFullDefLoadedCallbackData
 	{
-		[CompilerGenerated]
-		private TAG_PREMIUM <Premium>k__BackingField;
-
 		public HeroPickerButton HeroPickerButton { get; private set; }
 
-		private TAG_PREMIUM Premium
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Premium>k__BackingField = value;
-			}
-		}
+		private TAG_PREMIUM Premium { get; set; }
 
 		public HeroFullDefLoadedCallbackData(HeroPickerButton button, TAG_PREMIUM premium)
 		{
@@ -47,7 +37,7 @@ public abstract class AbsHeroPickerButtons : MonoBehaviour
 
 	protected int m_HeroPickerButtonCount;
 
-	protected List<HeroPickerButton> m_heroButtons = new List<HeroPickerButton>();
+	internal List<HeroPickerButton> m_heroButtons = new List<HeroPickerButton>();
 
 	protected HeroPickerButton m_selectedHeroButton;
 
@@ -278,12 +268,12 @@ public abstract class AbsHeroPickerButtons : MonoBehaviour
 		}
 	}
 
-	public void Show()
+	public virtual void Show()
 	{
 		m_rootObject.SetActive(value: true);
 	}
 
-	public void Hide()
+	public virtual void Hide()
 	{
 		m_rootObject.SetActive(value: false);
 	}
diff --git a/Assembly-CSharp/Accessibility/AccessibilityConfig.cs b/Assembly-CSharp/Accessibility/AccessibilityConfig.cs
new file mode 100644
index 0000000..fbe9535
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibilityConfig.cs
@@ -0,0 +1,7 @@
+﻿namespace Accessibility
+{
+    class AccessibilityConfig
+    {
+        internal static bool CAN_HEAR = true; // Could look into doing something like this for deaf-blind support
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibilityMgr.cs b/Assembly-CSharp/Accessibility/AccessibilityMgr.cs
new file mode 100644
index 0000000..60503f8
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibilityMgr.cs
@@ -0,0 +1,652 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using UnityEngine;
+using Hearthstone;
+
+namespace Accessibility
+{
+    static class AccessibilityMgr
+    {
+        private static AccessibleKey s_forcedKey; // Override everything else e.g. sometimes we need to press enter before anything is possible but we don't necessarily want a screen or UI
+        private static Action s_forcedAction;
+
+        private static List<AccessibleUI> s_curUIs = new List<AccessibleUI>();
+
+        private static AccessibleScreen s_curScreen;
+
+        private static PegUIElement s_curNotificationDismissButton;
+
+        private static string s_helpOverride;
+
+        // Our sound game object
+        private static GameObject s_soundGameObject;
+
+        private static bool s_enabled;
+
+        private static bool s_textInputAllowed;
+
+        private static bool s_transitioningUIs;
+
+        internal static void Initialize(GameObject rootGameObject)
+        {
+            try
+            {
+                Log.Accessibility.Print("Accessibility initialized");
+
+                ScreenReader.Load();
+                rootGameObject.AddComponent<AccessibleInputMgr>();
+
+                s_enabled = true;
+
+                // Init sound stuff for narration
+                s_soundGameObject = InitSoundGameObject();
+                s_soundGameObject.transform.parent = rootGameObject.transform;
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void Shutdown()
+        {
+            Log.Accessibility.Print("Accessibility shutdown");
+            ScreenReader.Unload();
+        }
+
+        internal static void SetScreen(AccessibleScreen screen)
+        {
+            Log.Accessibility.Print($"Setting screen {screen}");
+            var prevScreen = s_curScreen;
+            s_curScreen = screen;
+
+            if (s_curScreen != prevScreen && s_curUIs.Count == 0 && DialogManager.Get().GetNumQueuedDialogs() == 0)
+            {
+                NotifyScreenFocused();
+            }
+        }
+
+        private static void NotifyScreenFocused()
+        {
+            try
+            {
+                s_curScreen.OnGainedFocus();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void TransitioningScreens()
+        {
+            Log.Accessibility.Print($"Transitioning screens");
+            s_curScreen = null;
+        }
+
+        internal static void SetNotification(PegUIElement dismissButton)
+        {
+            if (s_curNotificationDismissButton != null)
+            {
+                // Remove any pending listeners
+                s_curNotificationDismissButton.RemoveEventListener(UIEventType.RELEASE, OnNotificationDismissButtonReleased);
+            }
+
+            s_curNotificationDismissButton = dismissButton;
+
+            s_curNotificationDismissButton.AddEventListener(UIEventType.RELEASE, OnNotificationDismissButtonReleased);
+        }
+
+        private static void OnNotificationDismissButtonReleased(UIEvent uiEvent)
+        {
+            s_curNotificationDismissButton = null;
+        }
+
+        public static void ShowUI(AccessibleUI ui)
+        {
+            try
+            {
+                Log.Accessibility.Print($"ShowUI({ui})");
+
+                if (GetFocusedUI() != ui)
+                {
+                    s_curUIs.Add(ui);
+                    s_transitioningUIs = false;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static void HideUI(AccessibleUI ui)
+        {
+            if (ui == null)
+            {
+                return;
+            }
+
+            try
+            {
+				Log.Accessibility.Print($"HideUI({ui})");
+
+				var curUI = GetFocusedUI();
+                var numRemovedUIs = s_curUIs.RemoveAll(obj => obj == ui);
+
+                if (numRemovedUIs > 0)
+                {
+                    OnUIPopped(ui, curUI);
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void OnUIPopped(AccessibleUI ui, AccessibleUI focusedUIWhenPopped)
+        {
+            var curUI = GetFocusedUI();
+
+            if (curUI == null)
+            {
+                if (s_curScreen != null)
+                {
+                    if (focusedUIWhenPopped != ui || DialogManager.Get().GetNumQueuedDialogs() > 0 || s_transitioningUIs)
+					{
+                        return;
+					}
+
+                    NotifyScreenFocused();
+                }
+            }
+        }
+
+        private static AccessibleUI GetFocusedUI()
+        {
+            if (s_curUIs.Count == 0)
+            {
+                return null;
+            }
+
+            return s_curUIs[s_curUIs.Count - 1];
+        }
+
+        internal static void OutputAndWait(string text, Action onStart, Action onEnd)
+        {
+                if(HearthstoneApplication.Get().HasFocus()||Options.Get().GetBool(Option.ACCESSIBILITY_BACKGROUND_SPEECH))             GetSpeechMgr().OutputTextAndWait(text, onStart, onEnd);
+                else {
+                    if(onStart!=null) onStart();
+                    if(onEnd!=null) onEnd();
+                }
+        }
+
+        public static void OutputNotification(string text, bool interrupt=false)
+        {
+            Output(text, interrupt);
+        }
+
+        public static void Output(AccessibleComponent speaker, string text, bool interrupt=false)
+        {
+            try
+            {
+                var curUI = GetFocusedUI();
+
+                if (speaker == null)
+                {
+                    // Something we haven't made accessible yet so read anyways in case it helps
+                    // Note: this is also useful for tests in some places where a UI doesn't necessarily exist
+                    Output(text, interrupt);
+                }
+                else if (curUI != null && speaker == curUI)
+                {
+                    Output(text, interrupt);
+                }
+                else if (curUI == null)
+                {
+                    if (s_curScreen != null && s_curScreen == speaker)
+                    {
+                        Output(text, interrupt);
+                    }
+                }
+                // Ignore text from non-focused screens
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void Output(string text, bool interrupt=false)
+        {
+            try
+            {
+                if(HearthstoneApplication.Get().HasFocus()||Options.Get().GetBool(Option.ACCESSIBILITY_BACKGROUND_SPEECH)) {
+                if (interrupt)
+                {
+                    GetSpeechMgr().OutputTextImmediately(text);
+                }
+                else
+                {
+                    Output(text);
+                }
+            }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void Output(string text)
+        {
+            GetSpeechMgr().OutputText(text);
+        }
+
+        public static void HandleKeyboardInput()
+        {
+            if (IsTextInputAllowed())
+			{
+                return;
+			}
+
+            try
+            {
+                if (Input.anyKeyDown)
+                {
+                    InterruptHelpSpeeches();
+
+                    if (ScreenReader.IsUsingSAPI())
+                    {
+                        InterruptTexts();
+
+                        ScreenReader.Interrupt();
+                    }
+                }
+
+                HandleGlobalInput();
+
+                var curUI = GetFocusedUI();
+
+                if (AccessibleKey.HELP.IsPressed())
+                {
+                    if (s_helpOverride != null)
+                    {
+                        Output(s_helpOverride);
+                    }
+                    else if (s_forcedKey != null)
+                    {
+                        Output(LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, s_forcedKey));
+                    }
+                    else if (s_curNotificationDismissButton != null)
+                    {
+                        Output(AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                    }
+                    else if (curUI != null)
+                    {
+                        Output(curUI.GetAccessibleHelp());
+                    }
+                    else if (s_curScreen != null)
+                    {
+                        Output(s_curScreen.GetHelp());
+                    }
+                    else
+                    {
+                        Output(LocalizedText.GLOBAL_LOADING);
+                        Output(LocalizedText.GLOBAL_PLEASE_WAIT);
+                    }
+
+                    return;
+                }
+
+                if (s_forcedKey != null)
+                {
+                    if (s_forcedKey.IsPressed())
+                    {
+                        s_forcedKey = null;
+                        s_forcedAction();
+                    }
+                }
+                else if (s_curNotificationDismissButton != null)
+                {
+                    if (AccessibleKey.CONFIRM.IsPressed())
+                    {
+                        s_curNotificationDismissButton.TriggerRelease();
+                    }
+                }
+                else if (curUI != null)
+                {
+                    curUI.HandleAccessibleInput();
+                }
+                else if (s_curScreen != null)
+                {
+                    s_curScreen.HandleInput();
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        internal static void AllowTextInput()
+        {
+            s_textInputAllowed = true;
+        }
+
+        internal static void DisallowTextInput()
+        {
+            s_textInputAllowed = false;
+        }
+
+        internal static bool IsTextInputAllowed()
+        {
+            return s_textInputAllowed;
+        }
+
+        private static void InterruptHelpSpeeches()
+        {
+            GetSpeechMgr().InterruptNarrations();
+        }
+
+        private static void InterruptTextSpeeches()
+        {
+            GetSpeechMgr().InterruptNarrations();
+        }
+
+        private static void HandleGlobalInput()
+        {
+            BnetBar bnetBar = BnetBar.Get();
+            BnetBarFriendButton bnetBarFriendButton = BnetBarFriendButton.Get();
+
+            if (bnetBar != null && AccessibleKey.OPEN_GAME_MENU.IsPressed())
+            {
+                if (ChatMgr.Get().IsFriendListShowing())
+                {
+                    bnetBar.HideFriendList();
+                }
+                else if (IsSomeOptionsMenuShown())
+                {
+                    bnetBar.HandleEscapeKey();
+                }
+                else
+				{
+					bnetBar.ToggleGameMenu();
+				}
+			}
+            else if (bnetBarFriendButton != null && AccessibleKey.OPEN_SOCIAL_MENU.IsPressed() && !IsSomeOptionsMenuShown())
+            {
+                bnetBarFriendButton.TriggerRelease();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F5))
+            {
+                CheatMgr.Get().ShowConsole();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F6))
+            {
+                InGameSystemTests.BuildTestCardEffectInterpreter();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F7))
+            {
+                InGameSystemTests.Run();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F3))
+			{
+                var lastChosenDeck = Options.Get().GetLong(Option.LAST_CUSTOM_DECK_CHOSEN);
+                var selectedDeckID = CollectionManager.Get().GetDeck(lastChosenDeck).ID;
+				GameMgr.Get().FindGame(PegasusShared.GameType.GT_VS_AI, PegasusShared.FormatType.FT_WILD, (int)ScenarioDbId.PRACTICE_EXPERT_MAGE, 0, selectedDeckID, null, null, restoreSavedGameState: false, null, null, 0L);
+			}
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.Backslash))
+            {
+                HSADevTools.RunTests();
+            }
+            else if (HearthstoneAccessConstants.DEV_MODE && InputCollection.GetKeyDown(KeyCode.F10))
+            {
+                // Smoke test speeches
+                GetSpeechMgr().Narrate(false, null, AccessibleSpeech.WELCOME_TO_HEARTHSTONE);
+            }
+            else if (AccessibleKey.INCREASE_GAME_SPEED.IsPressed())
+            {
+                GetSpeechMgr().IncreaseSpeechRate();
+            }
+            else if (AccessibleKey.DECREASE_GAME_SPEED.IsPressed())
+            {
+                GetSpeechMgr().DecreaseSpeechRate();
+            }
+        }
+
+        private static bool IsSomeOptionsMenuShown()
+        {
+            if (BnetBar.Get()?.IsGameMenuShown() ?? false)
+            {
+                return true;
+            }
+            else if (OptionsMenu.Get()?.IsShown() ?? false)
+            {
+                return true;
+            }
+            else if (MiscellaneousMenu.Get()?.IsShown() ?? false)
+            {
+                return true;
+            }
+            else if (SoundOptionsMenu.Get()?.IsShown() ?? false)
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        public static void WaitForForcedKey(AccessibleKey key, Action action)
+        {
+            s_forcedKey = key;
+            s_forcedAction = action;
+        }
+
+        public static void BlockAllInput(bool blockGlobalInput=false, bool blockHelpSpeech=false)
+        {
+            foreach (var key in AccessibleKey.GetAllKeys())
+            {
+                key.Enable();
+            }
+
+            foreach (var key in AccessibleKey.GetAllKeys(blockGlobalInput))
+            {
+                key.Disable();
+            }
+
+            if (!blockGlobalInput && blockHelpSpeech)
+            {
+                AccessibleKey.HELP.Disable();
+            }
+        }
+
+        public static void UnblockAllInput()
+        {
+            m_isInWhitelistMode = false;
+
+            foreach (var key in AccessibleKey.GetAllKeys())
+            {
+                key.Enable();
+            }
+
+            s_helpOverride = null;
+        }
+
+        public static void OverrideHelpSpeech(string helpSpeech)
+        {
+            s_helpOverride = helpSpeech;
+            AccessibleKey.HELP.Enable();
+        }
+
+        public static void BlockHelpSpeech()
+        {
+            AccessibleKey.HELP.Disable();
+        }
+
+        public static void ResetHelpSpeech()
+        {
+            s_helpOverride = null;
+            AccessibleKey.HELP.Enable();
+        }
+
+        private static bool m_isInWhitelistMode;
+
+        public static void WhitelistKeys(HSASpeech helpSpeech, params AccessibleKey[] keys)
+        {
+            if (keys == null || keys.Length == 0)
+            {
+                return;
+            }
+
+            foreach (var key in keys)
+            {
+                key.Enable();
+            }
+
+            OverrideHelpSpeech(helpSpeech.GetLocalizedText());
+            m_isInWhitelistMode = true;
+        }
+
+        public static void BlacklistKeys(params AccessibleKey[] keys)
+        {
+            if (!m_isInWhitelistMode)
+            {
+                // e.g. it's useful to be able to disable end turn on Tutorial01, but we don't always want to block input after that
+                return;
+            }
+
+            if (keys == null || keys.Length == 0)
+            {
+                return;
+            }
+
+            foreach (var key in keys)
+            {
+                key.Disable();
+            }
+
+            s_helpOverride = null;
+            AccessibleKey.HELP.Disable();
+        }
+
+        private static GameObject InitSoundGameObject()
+        {
+            var ret = new GameObject();
+
+            ret.AddComponent<AudioSource>();
+            ret.AddComponent<AccessibleSpeechMgr>();
+
+            return ret;
+        }
+
+        public static IEnumerator Narrate(HSASpeech speech)
+        {
+            return GetSpeechMgr().Narrate(speech);
+        }
+
+        public static void NarrateAndWait(HSASpeech speech, Action onFinish=null)
+        {
+            try
+            {
+                NarrateSpeeches(false, onFinish, speech);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static void NarrateSpeeches(bool interruptable, Action onFinish=null, params HSASpeech[] speeches)
+        {
+            try
+            {
+                if (speeches == null || speeches.Length == 0)
+                {
+                    return;
+                }
+
+                GetSpeechMgr().Narrate(interruptable, onFinish, speeches);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private static AccessibleSpeechMgr GetSpeechMgr()
+        {
+            return s_soundGameObject.GetComponent<AccessibleSpeechMgr>();
+        }
+
+        internal static int GetCPS()
+        {
+            return GetSpeechMgr().GetCPS();
+        }
+
+        public static void InterruptTexts()
+        {
+            try
+            {
+                GetSpeechMgr().InterruptTexts();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public static bool IsAccessibilityEnabled()
+        {
+            return s_enabled;
+        }
+
+        internal static void ToggleEnabled()
+        {
+            s_enabled = !s_enabled;
+
+            if (s_enabled)
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.GLOBAL_ACCESSIBILITY_ON));
+            }
+            else
+            {
+                Output(LocalizationUtils.Get(LocalizationKey.GLOBAL_ACCESSIBILITY_OFF));
+            }
+        }
+
+        internal static void SetEnabled() // Enable with no announcement
+        {
+            s_enabled = true;
+        }
+
+        internal static void SetDisabled() // Disable with no announcement
+        {
+            s_enabled = false;
+        }
+
+        internal static bool IsCurrentlyFocused(AccessibleComponent component)
+        {
+            var curUI = GetFocusedUI();
+
+            if (curUI != null && curUI == component)
+            {
+                return true;
+            }
+            else if (curUI == null)
+            {
+                return s_curScreen == component;
+            }
+
+            return false;
+        }
+
+		internal static void TransitioningUIs()
+		{
+            AccessibilityUtils.LogDebug("Transitioning UIs");
+            s_transitioningUIs = true;
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibilityUtils.cs b/Assembly-CSharp/Accessibility/AccessibilityUtils.cs
new file mode 100644
index 0000000..8851cfe
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibilityUtils.cs
@@ -0,0 +1,496 @@
+﻿using Assets;
+using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibilityUtils
+    {
+        private static bool s_logEnabled = HearthstoneAccessConstants.DEV_MODE;
+
+        private static bool s_cheatAllowPvP;
+
+        public static void DisableLogs()
+        {
+            s_logEnabled = false;
+        }
+
+        public static void LogDebug(string text)
+        {
+            try
+            {
+                if (!s_logEnabled)
+                {
+                    return;
+                }
+
+                Log.Accessibility.Print(text);
+            }
+            catch (Exception e)
+            {
+                LogFatalError(e);
+            }
+        }
+
+        public static void LogDebugText(string text)
+        {
+            try
+            {
+                if (!s_logEnabled)
+                {
+                    return;
+                }
+
+                Log.Accessibility_text.Print(text);
+            }
+            catch (Exception e)
+            {
+                LogFatalError(e);
+            }
+        }
+
+        public static void DebugLoggingToggle() {
+            s_logEnabled=!s_logEnabled;
+        }
+
+        public static bool GetDebugLoggingState() {
+            return s_logEnabled;
+        }
+        
+        public static string CurateText(string text)
+        {
+            if (text == null || text.Length == 0)
+            {
+                return "";
+            }
+
+            try
+            {
+                LogDebugText($"CT Before: {text}");
+                text = text.Trim();
+                text = FixWeirdText(text);
+                text = HandleNewLines(text);
+                text = HandleSequentialBolds(text);
+                text = RemoveHTMLTags(text);
+                text = RemoveLooseFormattingTags(text);
+                text = RemoveReadOnlyCharacters(text);
+                text = RemoveAttackHealthParenthesisText(text);
+                text = FixForwardSlashes(text);
+                text = CapitalizeSentences(text);
+                text = RemoveUnderscores(text);
+                text = CollapsePeriods(text);
+                text = NormalizeSpaces(text);
+                text = text.Trim();
+                //text = ExpandPlusSigns(text); // Not sure due to localization
+                //text = ConvertNumbersToWrittenNumbers(text); // Bad idea as it breaks localization
+
+                if (text.Length == 0)
+                {
+                    return text;
+                }
+
+                text = AddPeriodIfNeeded(text);
+
+                LogDebugText($"CT After: {text}");
+
+                return text;
+            }
+            catch (Exception e)
+            {
+                LogFatalError(e);
+                return "";
+            }
+        }
+
+        internal static bool CanSeeShop()
+        {
+            return ShopUtils.GetVirtualCurrencyMode() != VirtualCurrencyMode.China;
+        }
+
+        internal static bool CanPlayPvP()
+        {
+            // The release of 25.0.0.158725 broke this. No-op untill Death knight is available.
+            return true;
+            /*
+            if (s_cheatAllowPvP)
+            {
+            return true;
+            }
+
+            return AchieveManager.Get().HasUnlockedFeature(Achieve.Unlocks.VANILLA_HEROES);
+            */
+        }
+
+        internal static bool CanPlayTavernBrawl()
+        {
+            return TavernBrawlManager.Get().GetMission(PegasusShared.BrawlType.BRAWL_TYPE_TAVERN_BRAWL)?.brawlMode != PegasusShared.TavernBrawlMode.TB_MODE_HEROIC;
+        }
+
+        public static void PrintStackTrace()
+        {
+            if (s_logEnabled)
+            {
+                LogDebug("Printing stack trace");
+                LogDebug($"Time.frameCount: {Time.frameCount}");
+                LogDebug(Environment.StackTrace);
+            }
+        }
+
+        private static string CapitalizeSentences(string text)
+        {
+            var sb = new StringBuilder(text.Length);
+
+            bool newSentence = true;
+
+            for (int i = 0; i < text.Length; i++)
+            {
+                if (newSentence && char.IsLetterOrDigit(text[i]))
+                {
+                    sb.Append(char.ToUpper(text[i]));
+                    newSentence = false;
+                }
+                else
+                {
+                    sb.Append(text[i]);
+                }
+
+                if (IsSentenceEndingCharacter(text[i]))
+                {
+                    newSentence = true;
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static bool IsSentenceEndingCharacter(char c)
+        {
+            return LocalizationUtils.GetSentenceEndingCharacters().Contains(c);
+        }
+
+        private static string CollapsePeriods(string text)
+        {
+            var period = LocalizationUtils.GetPeriod();
+
+            if (period.Equals(""))
+            {
+                // e.g. thTH doesn't have periods
+                return text;
+            }
+
+            var threePeriods = $"{period}{period}{period}";
+            var twoPeriods = $"{period}{period}"; // Whatever
+
+            return text.Replace(threePeriods, period).Replace(twoPeriods, period); // . reads better than ... (.. reads dot/dot so needs to be removed)
+        }
+
+        private static string RemoveUnderscores(string text)
+        {
+            return text.Replace("_", " ");
+        }
+
+        private static string NormalizeSpaces(string text)
+        {
+            var sb = new StringBuilder();
+            bool ws = false;
+
+            foreach (var c in text)
+            {
+                if (c == ' ')
+                {
+                    if (!ws)
+                    {
+                        sb.Append(c);
+                    }
+
+                    ws = true;
+                }
+                else
+                {
+                    ws = false;
+                    sb.Append(c);
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static string AddPeriodIfNeeded(string text)
+        {
+            if (text.Length == 0)
+            {
+                return text;
+            }
+
+            var sentenceEndingCharacters = LocalizationUtils.GetSentenceEndingCharacters();
+            var lastChar = text[text.Length - 1];
+
+            LogDebug($"AddPeriodIfNeeded({text}) ; lastChar={lastChar}");
+
+            if (sentenceEndingCharacters.Contains(lastChar) || text.EndsWith(".\"") || text.EndsWith(":")) // Edge cases in a lot of languages
+            {
+                return text;
+            }
+
+            return text + LocalizationUtils.GetPeriod();
+        }
+
+        private static Regex s_attackAndHealthParenthesisRegex = new Regex(@"(.*)(\(\+\d Attack\/\+\d Health\))(.*)"); // TODO: Think if we want to bother with this
+
+        private static string RemoveAttackHealthParenthesisText(string text)
+        {
+            var match = s_attackAndHealthParenthesisRegex.Match(text);
+
+            if (match.Success)
+            {
+                return text.Replace(match.Groups[2].Value, "");
+            }
+            else
+            {
+                return text;
+            }
+        }
+
+        private static string FixForwardSlashes(string text)
+        {
+            return text.Replace("/", " ");
+        }
+
+        private static string FixWeirdText(string text)
+        {
+            return text.Replace("HIMSELF", "himself") // Injured Blademaster
+                .Replace("ALL", "all") // Various cards
+                .Replace("LOT", "lot"); // Deck recipe - you're missing a LOT of cards
+        }
+
+        private static Regex s_boldLinesRegex = new Regex("^<b>.*</b>$");
+
+        private static string HandleNewLines(string text)
+        {
+            // e.g. Battlecry on a single line and then something else below / Passive on a single line, etc.
+            var lines = text.Split('\n');
+            var sb = new StringBuilder();
+
+            for (var i = 0; i < lines.Length - 1; i++) // Last line doesn't matter
+            {
+                var line = lines[i];
+
+                if (s_boldLinesRegex.Match(line).Success)
+                {
+                    sb.Append($"{line}{LocalizationUtils.GetPeriod()} ");
+                }
+                else
+                {
+                    sb.Append($"{line} ");
+                }
+            }
+
+            sb.Append(lines[lines.Length - 1]);
+
+            return sb.ToString();
+        }
+
+        private static Regex s_htmlTagsRegex = new Regex("<[^>]*>");
+
+        private static string RemoveHTMLTags(string text)
+        {
+            return s_htmlTagsRegex.Replace(text, "");
+        }
+
+        private static string HandleSequentialBolds(string text)
+        {
+            return text.Replace("</b> <b>", $"</b>{LocalizationUtils.GetPeriod()} <b>");
+        }
+
+        private static string RemoveLooseFormattingTags(string text)
+        {
+            return text.Replace("[X]", "")
+                .Replace("[x]", "");
+        }
+
+        private static string RemoveReadOnlyCharacters(string text)
+        {
+            return text.Replace("*", "");
+        }
+
+        internal static void ReadTooltip(AccessibleComponent reader)
+        {
+            foreach (var tooltip in TooltipPanelManager.Get()?.GetTooltipPanels())
+            {
+                if (tooltip.isActiveAndEnabled)
+                {
+                    AccessibilityMgr.Output(reader, tooltip.m_name.Text);
+                    AccessibilityMgr.Output(reader, tooltip.m_body.Text);
+                }
+            }
+
+            if (TutorialKeywordManager.Get()?.GetPanels() != null)
+            {
+                foreach (var tooltip in TutorialKeywordManager.Get().GetPanels())
+                {
+                    AccessibilityMgr.Output(reader, tooltip.m_name.Text);
+                    AccessibilityMgr.Output(reader, tooltip.m_body.Text);
+                }
+            }
+        }
+
+        internal static void LogFatalError(Exception e)
+        {
+            Log.Accessibility.PrintError("FATAL ERROR - UNCAUGHT EXCEPTION");
+            Log.Accessibility.PrintError(e.ToString());
+        }
+
+        internal static void LogFatalError(String message)
+        {
+            Log.Accessibility.PrintError($"FATAL ERROR - {message}");
+            Log.Accessibility.PrintError(Environment.StackTrace);
+        }
+
+        internal static void GoBackToHub()
+        {
+            Navigation.Clear();
+            SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
+        }
+
+        internal static void CenterScrollbarAroundObject(UIBScrollable scrollbar, GameObject gameObject)
+        {
+            scrollbar.CenterObjectInView(gameObject, 0f, null, iTween.EaseType.linear, 0f);
+        }
+
+        internal static void ProcessQueue(Queue<Action> queuedActions)
+        {
+            while (queuedActions.Count > 0)
+            {
+                queuedActions.Dequeue()();
+            }
+        }
+
+        #region Debugging
+
+        public static void DebugGameObject(GameObject go)
+        {
+            if (!s_logEnabled)
+            {
+                return;
+            }
+            LogDebug($"Debugging GameObject");
+            LogDebug($"name: {GetObjectNameWithComponents(go)}");
+
+            LogDebug($"childCount: {go.transform.childCount}");
+            DebugChildren(go, 1);
+        }
+
+        internal static void DebugGameObjectInHierarchy(GameObject go)
+        {
+            if (!s_logEnabled)
+            {
+                return;
+            }
+            LogDebug($"Debugging GameObject in hierarchy");
+            LogDebug($"name: {GetObjectNameWithComponents(go)}");
+
+            DebugParent(go, 1);
+        }
+
+        internal static bool IsInPvPGame()
+        {
+            if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
+            {
+                return false;
+            }
+
+            var gameType = GameMgr.Get()?.GetGameType();
+
+            switch (gameType)
+            {
+                case PegasusShared.GameType.GT_VS_FRIEND:
+                case PegasusShared.GameType.GT_ARENA:
+                case PegasusShared.GameType.GT_RANKED:
+                case PegasusShared.GameType.GT_CASUAL:
+                case PegasusShared.GameType.GT_TAVERNBRAWL:
+                case PegasusShared.GameType.GT_BATTLEGROUNDS:
+                case PegasusShared.GameType.GT_BATTLEGROUNDS_FRIENDLY:
+                case PegasusShared.GameType.GT_PVPDR:
+                case PegasusShared.GameType.GT_PVPDR_PAID:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        private static string GetObjectNameWithComponents(GameObject go)
+        {
+            var sb = new StringBuilder();
+
+            sb.Append(go.name);
+
+            var components = go.GetComponents(typeof(Component));
+
+            if (components.Length > 0)
+            {
+                sb.Append(" (");
+                for (int i = 0; i < components.Length; i++)
+                {
+                    if (i > 0)
+                    {
+                        sb.Append(", ");
+                    }
+                    sb.Append(components[i].GetType());
+                }
+                sb.Append(")");
+            }
+
+            return sb.ToString();
+        }
+
+        private static void DebugChildren(GameObject go, int depth)
+        {
+            for (int i = 0; i < go.transform.childCount; i++)
+            {
+                var child = go.transform.GetChild(i).gameObject;
+                var indent = new string('-', depth * 3);
+                LogDebug($"{indent} {GetObjectNameWithComponents(child)}");
+
+                DebugChildren(child, depth + 1);
+            }
+        }
+
+        private static void DebugParent(GameObject go, int depth)
+        {
+            if (go.transform.parent == null)
+            {
+                return;
+            }
+
+            var parent = go.transform.parent.gameObject;
+            var indent = new string('+', depth * 3);
+            LogDebug($"{indent} {GetObjectNameWithComponents(parent)}");
+
+            DebugParent(parent, depth + 1);
+        }
+
+        internal static void OutputTimerIfNecessary(int curSeconds, int prevSeconds)
+        {
+            if (curSeconds < prevSeconds && curSeconds == 10) // was 15 and 5 but some players complained
+            {
+                OutputSecondsRemaining(curSeconds);
+            }
+        }
+
+        internal static void OutputSecondsRemaining(int seconds)
+        {
+            AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_N_SECONDS_REMAINING, seconds));
+        }
+
+        internal static void Cheat_SetPvPOverride(bool val)
+        {
+            s_cheatAllowPvP = val;
+        }
+
+        #endregion
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs b/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs
new file mode 100644
index 0000000..a15f41a
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleAdventureScene.cs
@@ -0,0 +1,323 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleAdventureScene : AccessibleScreen
+    {
+        private enum State { LOADING, CHOOSING_ADVENTURE, CHOOSING_ADVENTURE_MODE, CHOOSING_DECK, CHOOSING_OPPONENT }; // Finding game is a loading state as well
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_curMenu;
+
+        private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_chooseDeckMenu;
+
+        private AccessibleHorizontalMenu<AccessiblePracticeAIButton> m_chooseOpponentMenu;
+
+        private AdventureChooserTray m_adventureChooserTray;
+private AdventureData.Adventuresubscene m_curSubScene=AdventureData.Adventuresubscene.INVALID;
+        private List<CustomDeckPage> m_customDeckPages;
+
+        private List<PracticeAIButton> m_practiceAIButtons;
+
+        private bool chosenDeck;
+
+        private static AccessibleAdventureScene s_instance = new AccessibleAdventureScene();
+        private List<AdventureDef> adventures = new List<AdventureDef>();
+        internal static AccessibleAdventureScene Get()
+        {
+            return s_instance;
+        }
+
+public void ClearAdventureButtons() {
+    adventures.Clear();
+}
+    public void AddAdventureButton(AdventureDef def) {
+    if(!adventures.Contains(def)) {
+        adventures.Add(def);
+
+    }
+}
+        public void OnAdventureSceneShown() {
+            try
+            {
+                m_practiceAIButtons = null; // Cleanup in case of unlocked heroes
+                m_curState = State.LOADING;
+
+                GameMgr.Get().RegisterFindGameEvent(OnFindGameEvent);
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnSubSceneLoaded(AdventureData.Adventuresubscene subscene)
+        {
+            AccessibilityUtils.LogDebug($"OnSubSceneLoaded({subscene})");
+            m_curState = State.LOADING;
+m_curSubScene=subscene;
+            try
+            {
+                if (subscene == AdventureData.Adventuresubscene.CHOOSER)
+                {
+                    AccessibilityMgr.SetScreen(this);
+                    SetupAndReadChooseAdventureMenu();
+                }
+                else if (subscene == AdventureData.Adventuresubscene.PRACTICE||subscene == AdventureData.Adventuresubscene.MISSION_DECK_PICKER)
+                {
+                                m_curState = State.CHOOSING_DECK;
+
+                    AccessibilityMgr.SetScreen(this);
+//                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION));
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupAndReadChooseAdventureMenu()
+        {
+            m_curState = State.CHOOSING_ADVENTURE;
+            m_curMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_TITLE), OnGoBackToHub);
+
+            //m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION), OnChoosePracticeAdventure);
+            /*
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_HEROES_OPTION), OnChooseBookOfHeroesAdventure);
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_MERCENARIES_OPTION), OnChooseBookOfMercsAdventure);
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_ASHES_PROLOGUE_OPTION), OnChooseAshesPrologueAdventure);
+            m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_DEATH_KNIGHT_PROLOGUE_OPTION), OnChooseDeathKnightPrologueAdventure);
+*/
+AdventureModeDbId[] modes={AdventureModeDbId.DUNGEON_CRAWL,AdventureModeDbId.LINEAR,AdventureModeDbId.DUNGEON_CRAWL_HEROIC,AdventureModeDbId.EXPERT,AdventureModeDbId.INVALID,AdventureModeDbId.LINEAR_HEROIC,AdventureModeDbId.BONUS_CHALLENGE};
+AdventureDbId[] supportedAdventures={AdventureDbId.BOH, AdventureDbId.BOM, AdventureDbId.PRACTICE, AdventureDbId.ROTLK, AdventureDbId.BTP,AdventureDbId.ICC};
+            foreach(AdventureDef def in adventures) {
+                    bool adventureSupported=Array.Exists(supportedAdventures,d=> d==def.GetAdventureId())||HearthstoneAccessConstants.DEV_MODE;
+                for(int i=0; i<modes.Length; i++) {
+                    AdventureModeDbId mode=modes[i];
+                    if(def.GetSubDef(mode)!=null&&adventureSupported)                     m_curMenu.AddOption(def.GetAdventureName()+": "+def.GetSubDef(mode).GetDescription(),()=> ChooseAdventure(def.GetAdventureId(),def.GetSubDef(mode).GetAdventureModeId()));
+                }
+
+            }
+            m_curMenu.AddOption(LocalizedText.SCREEN_GO_BACK, OnGoBackToHub);
+            m_curMenu.StartReading();
+        }
+
+
+        public void OnAdventureChooserTrayAwake(AdventureChooserTray adventureChooserTray)
+        {
+            AccessibilityUtils.LogDebug($"OnAdventureChooserTrayAwake({adventureChooserTray})");
+            m_adventureChooserTray = adventureChooserTray;
+        }
+
+        private void ChooseAdventure(AdventureDbId adventure, AdventureModeDbId mode)
+        {
+            AdventureConfig.Get().SetSelectedAdventureMode(adventure, mode);
+            if(m_adventureChooserTray.m_ChooseButton.IsEnabled()) {
+            m_adventureChooserTray.m_ChooseButton.TriggerRelease();
+            }
+            else AccessibilityMgr.Output(this,m_adventureChooserTray.m_ChooseButton.m_newPlayButtonText.Text);
+        }
+
+        private void OnGoBackToHub()
+        {
+            m_adventureChooserTray.m_BackButton.TriggerRelease();
+        }
+
+        public void OnPracticePickerTrayDisplayShown(List<PracticeAIButton> practiceAIButtons)
+        {
+            try
+            {
+                m_practiceAIButtons = practiceAIButtons;
+                SetupChooseOpponentMenu();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupChooseOpponentMenu()
+        {
+            m_curState = State.CHOOSING_OPPONENT;
+            var chooseOpponentMenu = new AccessibleHorizontalMenu<AccessiblePracticeAIButton>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_OPPONENT_MENU_TITLE), OnGoBackToChooseDeckMenuFromChooseOpponentMenu);
+
+            foreach (var btn in m_practiceAIButtons)
+            {
+                chooseOpponentMenu.AddOption(new AccessiblePracticeAIButton(this, btn), () => SelectOpponent(btn));
+            }
+
+            m_chooseOpponentMenu = chooseOpponentMenu;
+            m_chooseOpponentMenu.StartReading();
+        }
+
+        private void SetupChooseDeckMenu()
+        {
+            chosenDeck = false;
+            m_curState = State.CHOOSING_DECK;
+            m_chooseDeckMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), OnGoBackToChooseAdventureFromChooseDeckMenu);
+            var deckPickerTrayDisplay = DeckPickerTrayDisplay.Get();
+            var selectedDeckId = deckPickerTrayDisplay.GetLastChosenDeckId();
+            var selectedDeckIdx = 0;
+		if(DeckPickerTrayDisplay.Get().m_collectionButton.IsEnabled()) AccessibilityMgr.Output(this,LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_DECK_COLLECTION_AVAILABLE));
+            for (int i = 0, curIdx = 0; i < m_customDeckPages.Count; i++)
+            {
+                var page = m_customDeckPages[i];
+                var pageDecks = page.m_customDecks;
+
+                for (int j = 0; j < pageDecks.Count; j++, curIdx++)
+                {
+                    var deck = pageDecks[j];
+                    var deckId = deck.GetDeckID();
+
+                    if (deckId == -1L)
+                    {
+                        continue;
+                    }
+                    else if (deckId == selectedDeckId)
+                    {
+                        selectedDeckIdx = curIdx;
+                    }
+
+                    var deckPageIdx = i;
+
+                    var accessibleDeck = new AccessibleCollectionDeckBoxVisual(this, deck);
+
+                    m_chooseDeckMenu.AddOption(accessibleDeck, () => SelectDeck(deck), () => ShowDeckPage(deckPageIdx));
+                }
+            }
+
+            m_chooseDeckMenu.SetIndex(selectedDeckIdx);
+            m_chooseDeckMenu.StartReading();
+        }
+
+        private void OnGoBackToChooseDeckMenuFromChooseOpponentMenu()
+        {
+            PracticePickerTrayDisplay.Get().m_backButton.TriggerRelease();
+            SetupChooseDeckMenu();
+        }
+
+        private void OnGoBackToChooseAdventureFromChooseDeckMenu()
+        {
+            DeckPickerTrayDisplay.Get().m_backButton.TriggerRelease();
+        }
+
+        private void SelectOpponent(PracticeAIButton btn)
+        {
+            btn.TriggerRelease();
+            PracticePickerTrayDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        public void HandleInput()
+        {
+//            		if(AccessibleKey.HUB_JOURNAL.IsPressed()) AccessibilityMgr.Output(null, "state is "+m_curState);
+            if (m_curState == State.CHOOSING_DECK)
+            {
+                m_chooseDeckMenu?.HandleAccessibleInput();
+                if(DeckPickerTrayDisplay.Get().m_collectionButton.IsEnabled()) {
+                    if(AccessibleKey.HUB_MY_COLLECTION.IsPressed()) DeckPickerTrayDisplay.Get().m_collectionButton.TriggerRelease();
+                }
+            }
+            else if (m_curState == State.CHOOSING_OPPONENT)
+            {
+                m_chooseOpponentMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState != State.LOADING)
+            {
+                m_curMenu?.HandleAccessibleInput();
+            }
+        }
+
+        public string GetHelp()
+        {
+            if (m_curState == State.CHOOSING_DECK)
+            {
+                return m_chooseDeckMenu?.GetHelp();
+            }
+            else if (m_curState == State.CHOOSING_OPPONENT)
+            {
+                return m_chooseOpponentMenu?.GetHelp();
+            }
+            else if (m_curState != State.LOADING)
+            {
+                return m_curMenu?.GetHelp();
+            }
+
+            return "";
+        }
+
+        public void OnDeckPickerTrayDisplayReady(List<CustomDeckPage> pages)
+        {
+            try
+            {
+                                AccessibilityMgr.SetScreen(this);
+                m_customDeckPages = pages;
+                m_practiceAIButtons = null; // Cleanup in case we go out of adventure and in again
+                SetupChooseDeckMenu();
+                m_curState=State.CHOOSING_DECK;
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SelectDeck(CollectionDeckBoxVisual deck)
+        {
+            chosenDeck = true;
+            deck.TriggerRelease();
+           if(m_curSubScene==AdventureData.Adventuresubscene.MISSION_DECK_PICKER) DeckPickerTrayDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        public void OnSelectedDeck(CollectionDeckBoxVisual deck)
+        {
+            if (AccessibilityMgr.IsAccessibilityEnabled() && chosenDeck)
+            {
+                DeckPickerTrayDisplay.Get().m_playButton.TriggerRelease();
+            }
+        }
+
+        private void ShowDeckPage(int pageIndex)
+        {
+            var deckPickerTrayDisplay = DeckPickerTrayDisplay.Get();
+
+            if (deckPickerTrayDisplay.GetCurrentPageIndex() != pageIndex)
+            {
+                deckPickerTrayDisplay.ShowPage(pageIndex);
+            }
+        }
+
+        private bool OnFindGameEvent(FindGameEventData eventData, object userData)
+        {
+            m_curState = State.LOADING;
+
+            return false;
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.LOADING)
+            {
+                return;
+            }
+
+            if (m_curState == State.CHOOSING_DECK)
+            {
+                m_chooseDeckMenu?.StartReading();
+            }
+            else if (m_curState == State.CHOOSING_OPPONENT)
+            {
+                m_chooseOpponentMenu?.StartReading();
+            }
+            else
+            {
+                m_curMenu?.StartReading();
+            }
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs b/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs
new file mode 100644
index 0000000..75b068e
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleAttackSpellController.cs
@@ -0,0 +1,38 @@
+﻿using System;
+
+namespace Accessibility
+{
+    public class AccessibleAttackSpellController
+    {
+        private PowerTaskList m_taskList;
+
+        public AccessibleAttackSpellController(PowerTaskList taskList)
+        {
+            m_taskList = taskList;
+        }
+
+        public void OnLaunchAttack()
+        {
+            try
+            {
+                AccessiblePlayDescriber.Get().OnAttack(m_taskList);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+		internal void OnBattlegroundsFinisherFinished()
+		{
+            try
+            {
+                AccessiblePlayDescriber.Get().BattlegroundsOnAttack(m_taskList);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleCard.cs b/Assembly-CSharp/Accessibility/AccessibleCard.cs
new file mode 100644
index 0000000..80c91f5
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleCard.cs
@@ -0,0 +1,292 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public abstract class AccessibleCard : AccessibleItem
+    {
+        protected readonly Card m_card;
+
+        internal AccessibleCard(AccessibleComponent parent, Card card) : base(parent)
+        {
+            m_card = card;
+        }
+
+        internal Card GetCard()
+        {
+            return m_card;
+        }
+
+        public static AccessibleCard CreateCard(AccessibleComponent parent, Card card)
+		{
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+				return new AccessibleBattlegroundsCard(parent, card);
+			}
+            else
+			{
+                // Use traditional for everything else so players can play other unsupported game modes such as Mercenaries with OCR
+                return new AccessibleTraditionalCard(parent, card);
+			}
+		}
+
+        #region Common stuff
+
+        protected List<string> GetHeader()
+		{
+            var ret = new List<string>();
+
+            var name = GetName();
+
+            ret.Add(name);
+            AddTrailingHeader(ret);
+
+            return ret;
+		}
+
+		protected void AddTrailingHeader(List<string> ret)
+		{
+            if (AccessibleCardUtils.IsCursed(m_card.GetEntity()))
+			{
+                ret.Add(LocalizationUtils.Get(LocalizationKey.GLOBAL_CURSED));
+			}
+            if(m_card.GetEntity().HasTag(GAME_TAG.VALEERASHADOW)) {
+                ret.Add(LocalizationUtils.Get(LocalizationKey.GLOBAL_HAUNTED));
+            }
+            if (AccessibleCardUtils.IsReady(m_card))
+			{
+                ret.Add(LocalizationUtils.Get(LocalizationKey.GLOBAL_READY));
+			}
+
+            if (m_card.GetEntity().GetZone() == TAG_ZONE.SECRET && m_card.GetEntity().IsObjective())
+            {
+                ret.Add(m_card.GetEntity().GetCustomObjectiveBannerText());
+            }
+		}
+
+		protected string GetName()
+        {
+            if (m_card.GetEntity().IsHero() && m_card.GetEntity().GetZone() == TAG_ZONE.PLAY)
+            {
+                if (m_card.GetEntity().IsControlledByFriendlySidePlayer())
+                {
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HERO);
+                }
+                else
+                {
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_HERO);
+                }
+            }
+            else if (m_card.GetEntity().IsSecret() && m_card.GetControllerSide() != Player.Side.FRIENDLY)
+            {
+                var secretClass = GameStrings.GetClassName(m_card.GetEntity().GetClass());
+                return LocalizationUtils.Format(LocalizationKey.GLOBAL_SECRET, secretClass);
+            }
+            else
+            {
+                return m_card.GetEntity().GetName();
+            }
+        }
+
+        protected string GetEffects()
+        {
+            // Note: Remember to update GetEffectsNotInEntityDef() as well if this needs updating
+            // Could simply have a flag defaulting instead but that would add significant complexity and I'd rather split the fault domains for now
+
+            List<string> effects = new List<string>();
+
+            var entity = m_card.GetEntity();
+
+            if (AccessibleCardUtils.IsSilencedMinion(entity)) effects.Add(LocalizedText.GLOBAL_SILENCE);
+                        if (entity.HasTag(GAME_TAG.DARKMOON_TICKET)) effects.Add(LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DARKMOON_TICKET));
+            if (entity.HasDivineShield()) effects.Add(LocalizedText.GLOBAL_DIVINE_SHIELD);
+            if (entity.IsFrozen()) effects.Add(LocalizedText.GLOBAL_FROZEN);
+            if (entity.HasLifesteal()) effects.Add(LocalizedText.GLOBAL_LIFESTEAL);
+
+
+            if (entity.HasDeathrattle()) effects.Add(LocalizedText.GLOBAL_DEATHRATTLE);
+            if (entity.IsPoisonous()) effects.Add(LocalizedText.GLOBAL_POISONOUS);
+            if (entity.IsStealthed()) effects.Add(LocalizedText.GLOBAL_STEALTH);
+            if (entity.HasTaunt()) effects.Add(LocalizedText.GLOBAL_TAUNT);
+            if (entity.IsImmune()) effects.Add(LocalizedText.GLOBAL_IMMUNE);
+            if (entity.IsDormant()) effects.Add(LocalizedText.GLOBAL_DORMANT);
+            if (entity.HasReborn()) effects.Add(LocalizedText.GLOBAL_REBORN);
+
+            if (effects.Count == 0)
+            {
+                return "";
+            }
+
+            return AccessibleSpeechUtils.HumanizeList(effects);
+        }
+
+        protected string GetEffectsNotInEntityDef()
+        {
+            // Note: This is only used for Battlegrounds at the moment to reduce the chattiness when narrating the opponent's board at the start of the combat phase
+            List<string> effects = new List<string>();
+
+            var entity = m_card.GetEntity();
+            var entityDef = entity.GetEntityDef();
+
+            if (AccessibleCardUtils.IsSilencedMinion(entity)) effects.Add(LocalizedText.GLOBAL_SILENCE);
+
+            if (entity.HasDivineShield() && !entityDef.HasDivineShield()) effects.Add(LocalizedText.GLOBAL_DIVINE_SHIELD);
+            if (entity.IsFrozen() && !entityDef.IsFrozen()) effects.Add(LocalizedText.GLOBAL_FROZEN);
+            if (entity.HasLifesteal() && !entityDef.HasLifesteal()) effects.Add(LocalizedText.GLOBAL_LIFESTEAL);
+            if (entity.HasDeathrattle() && !entityDef.HasDeathrattle()) effects.Add(LocalizedText.GLOBAL_DEATHRATTLE);
+            if (entity.IsPoisonous() && !entityDef.IsPoisonous()) effects.Add(LocalizedText.GLOBAL_POISONOUS);
+            if (entity.IsStealthed() && !entityDef.IsStealthed()) effects.Add(LocalizedText.GLOBAL_STEALTH);
+            if (entity.HasTaunt() && !entityDef.HasTaunt()) effects.Add(LocalizedText.GLOBAL_TAUNT);
+            if (entity.IsImmune() && !entityDef.IsImmune()) effects.Add(LocalizedText.GLOBAL_IMMUNE);
+            if (entity.IsDormant() && !entityDef.IsDormant()) effects.Add(LocalizedText.GLOBAL_DORMANT);
+            if (entity.HasReborn() && !entityDef.HasReborn()) effects.Add(LocalizedText.GLOBAL_REBORN);
+
+            if (effects.Count == 0)
+            {
+                return "";
+            }
+
+            return AccessibleSpeechUtils.HumanizeList(effects);
+        }
+
+        protected List<string> GetLinesForHeroPower()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            if (!AccessibleCardUtils.IsCostHidden(m_card))
+            {
+                lines.Add(AccessibleCardUtils.GetCost(m_card));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            return lines;
+        }
+
+        protected string GetDescription()
+        {
+            Entity entity = m_card.GetEntity();
+
+            if (AccessibleCardUtils.IsSilencedMinion(entity))
+            {
+                return LocalizedText.GLOBAL_SILENCE;
+            }
+
+            return entity.GetCardTextBuilder().BuildCardTextInHand(entity);
+        }
+
+        protected List<string> GetLinesForOpponentSecret()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+            return lines;
+        }
+
+        protected string GetResources()
+        {
+            if (m_card.GetEntity().IsDormant() || m_card.GetEntity().HasTag(GAME_TAG.DORMANT_VISUAL))
+            {
+                return "";
+            }
+            else if (m_card.GetEntity().GetTag(GAME_TAG.HIDE_STATS) == 1)
+            {
+                // e.g. Divine Bell in BoH Garrosh 7
+                return "";
+            }
+            else if (m_card.GetEntity().IsMinion()) {
+                var atk = m_card.GetEntity().GetATK();
+                var hp = m_card.GetEntity().GetCurrentHealth();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, atk, hp);
+            }
+            else if (m_card.GetEntity().IsWeapon()) {
+                var atk = m_card.GetEntity().GetATK();
+                var durability = m_card.GetEntity().GetCurrentDurability();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_DURABILITY, atk, durability);
+            }
+            else if (m_card.GetEntity().IsLocation()) {
+                // This is internally tracked as health, but most game literature refers to it as durability so we do too
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_DURABILITY, m_card.GetEntity().GetCurrentHealth());
+            }
+            else if (m_card.GetEntity().IsHero())
+            {
+                var atk = m_card.GetEntity().GetATK();
+                var hp = m_card.GetEntity().GetCurrentHealth();
+                var armor = m_card.GetEntity().GetArmor();
+
+                var atkHidden = AccessibleCardUtils.IsAttackHidden(m_card);
+                var hpHidden = AccessibleCardUtils.IsHealthHidden(m_card);
+                var armorHidden = AccessibleCardUtils.IsArmorHidden(m_card);
+
+                var showAtk = !atkHidden && atk > 0;
+                var showHp = !hpHidden;
+                var showArmor = !armorHidden && armor > 0;
+
+                var stats = new List<string>();
+
+                if (showAtk)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ATK, atk));
+                }
+                if (showArmor)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+                }
+                if (showHp)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, hp));
+                }
+
+                return AccessibleSpeechUtils.HumanizeList(stats);
+            }
+            else
+            {
+                return "";
+            }
+        }
+
+        protected string GetCardType()
+        {
+            return AccessibleCardUtils.GetType(m_card.GetEntity().GetCardType());
+        }
+
+        protected string GetRace()
+        {
+            // Note: This handles spell school as well
+            return m_card.GetEntity().GetEntityDef().GetRaceText();
+        }
+
+        protected List<string> GetLinesForQuest()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetQuestProgress(), lines);
+            lines.AddRange(GetQuestReward());
+
+            return lines;
+        }
+
+        protected string GetQuestProgress()
+        {
+            return AccessibleCardUtils.GetQuestProgressLine(m_card.GetEntity());
+        }
+
+        protected List<string> GetQuestReward()
+        {
+            var rewardCardId = AccessibleCardUtils.GetRewardCardIDFromQuestCardID(m_card.GetEntity());
+
+            if (rewardCardId == null)
+            {
+                return new List<string>();
+            }
+
+            return AccessibleCardUtils.GetQuestRewardCardLines(m_card.GetEntity(), rewardCardId);
+        }
+
+		#endregion
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleCardUtils.cs b/Assembly-CSharp/Accessibility/AccessibleCardUtils.cs
new file mode 100644
index 0000000..07c3710
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleCardUtils.cs
@@ -0,0 +1,433 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCardUtils
+    {
+        internal static string GetType(TAG_CARDTYPE type)
+        {
+            return GameStrings.GetCardTypeName(type);
+        }
+
+        internal static string GetRarity(EntityDef entityDef)
+        {
+            if (entityDef.IsElite())
+            {
+                // All elite cards are legendary at the moment. Legendary cards like Cairne Bloodhoof are elite but have their rarity set to invalid for some reason
+                return GameStrings.GetRarityText(TAG_RARITY.LEGENDARY);
+            }
+
+            var rarity = entityDef.GetRarity();
+
+            if (rarity == TAG_RARITY.INVALID || rarity == TAG_RARITY.FREE)
+            {
+                return "";
+            }
+
+            return GameStrings.GetRarityText(rarity);
+        }
+
+        internal static string GetSet(EntityDef entityDef)
+        {
+            return GameStrings.GetCardSetNameShortened(entityDef.GetCardSet());
+        }
+
+        internal static List<string> GetLinesForNormalEntityDef(EntityDef entityDef, TAG_PREMIUM premiumType, string className = null, bool readOwned = false, int numCopies = 0)
+        {
+            var ret = new List<string>();
+
+            ret.Add(GetNameWithPremium(entityDef.GetName(), premiumType)); // Golden/Diamond/Signature edition
+
+            if (readOwned)
+            {
+                AddOwnedLine(ret, numCopies);
+            }
+
+            if (className != null)
+            {
+                ret.Add(className); // We don't always want to show the class name but it's useful sometimes e.g. pack opening
+            }
+
+            ret.Add(GetCardCost(entityDef.GetCost())); // x mana
+            AddLineIfExists(GetRunes(entityDef), ret);
+
+            AddLineIfExists(GetResourcesForEntityDef(entityDef), ret); // Resources
+            AddLineIfExists(entityDef.GetCardTextInHand(), ret); // Description
+            AddLineIfExists(entityDef.GetRaceText(), ret); // Race or spell school
+
+            ret.Add(GetType(entityDef.GetCardType())); // Weapon, spell, etc.
+
+            AddLineIfExists(GetRarity(entityDef), ret); // Legendary, elite, etc.
+
+            return ret;
+        }
+
+        internal static void AddOwnedLine(List<string> lines, int numCopies)
+        {
+            if (numCopies > 0)
+            {
+                lines.Add(GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_OWNED"));
+            }
+            else
+            {
+                lines.Add(GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_MISSING"));
+            }
+        }
+
+        internal static void AddLineIfExists(string line, List<string> lines)
+        {
+            if (line == null || line.Length == 0)
+            {
+                return;
+            }
+
+            lines.Add(line);
+        }
+
+        internal static string GetResourcesForEntityDef(EntityDef entityDef)
+        {
+            if (entityDef.GetCardType() == TAG_CARDTYPE.MINION)
+            {
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, entityDef.GetATK(), entityDef.GetHealth());
+            }
+            else if (entityDef.GetCardType() == TAG_CARDTYPE.WEAPON)
+            {
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_DURABILITY, entityDef.GetATK(), entityDef.GetDurability());
+            }
+            else if (entityDef.GetCardType() == TAG_CARDTYPE.LOCATION)
+            {
+                // This is internally tracked as health, but most game literature refers to it as durability so we do too
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_DURABILITY, entityDef.GetHealth());
+            }
+            else if (entityDef.GetCardType() == TAG_CARDTYPE.HERO)
+            {
+                var atk = entityDef.GetATK();
+                var hp = entityDef.GetHealth();
+                var armor = entityDef.GetArmor();
+
+                var stats = new List<string>();
+
+                if (atk > 0)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ATK, atk));
+                }
+                if (armor > 0)
+                {
+                    stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+                }
+
+                stats.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, hp));
+
+                return AccessibleSpeechUtils.HumanizeList(stats);
+            }
+            else
+            {
+                return "";
+            }
+        }
+
+        public static List<string> GetHeroPowerCardLinesForHeroCard(string heroCardId)
+        {
+            var ret = new List<string>();
+
+            var heroPowerCardId = GameUtils.GetHeroPowerCardIdFromHero(heroCardId);
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(heroPowerCardId);
+            var heroPowerName = entityDef.GetName();
+
+            ret.Add(AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HERO_POWER), heroPowerName));
+
+            AddLineIfExists(GetEntityDefCost(entityDef), ret);
+            AddLineIfExists(entityDef.GetCardTextInHand(), ret);
+
+            return ret;
+        }
+
+        public static List<string> GetHeroBuddyCardLinesForHeroCard(Entity heroCard)
+        {
+            var ret = new List<string>();
+
+            var heroBuddyCardId = heroCard.GetHeroBuddyCardId();
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(heroBuddyCardId);
+            var buddyName = entityDef.GetName();
+
+            ret.Add(AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_ZONE_HERO_BUDDY), buddyName));
+
+            ret.Add($"{entityDef.GetATK()} {entityDef.GetHealth()}");
+
+            AddLineIfExists(entityDef.GetCardTextInHand(), ret);
+
+            AddLineIfExists(entityDef.GetRaceText(), ret);
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER, entityDef.GetTag(GAME_TAG.TECH_LEVEL)));
+
+            return ret;
+        }
+
+        private static string GetEntityDefCost(EntityDef entityDef)
+        {
+            if (entityDef.HasTag(GAME_TAG.HIDE_STATS) || entityDef.HasTag(GAME_TAG.HIDE_COST))
+            {
+                return null;
+            }
+
+            // TODO: Refactor once we get to BG collection as well
+            var cost = entityDef.GetCost();
+
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+            {
+                return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_COST, cost);
+            }
+            else
+            {
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, cost);
+            }
+        }
+
+        public static string GetRunes(EntityDef entityDef)
+        {
+            return AccessibleRuneUtils.StringifyRunePattern(entityDef.GetRuneCost());
+        }
+
+        public static List<string> GetQuestRewardCardLines(Entity questEnt, string cardId)
+        {
+            var ret = new List<string>();
+
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+            var cardName = entityDef.GetName();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_DESCRIPTION, cardName));
+
+            if (!entityDef.HasTag(GAME_TAG.HIDE_STATS) && !entityDef.HasTag(GAME_TAG.HIDE_COST))
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, entityDef.GetCost()));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetResources(entityDef), ret);
+
+            var formattedText = Actor.FormatDynamicQuestRewardText(questEnt, entityDef);
+            var text = formattedText != null ? formattedText : entityDef.GetCardTextInHand();
+            AccessibleCardUtils.AddLineIfExists(text, ret);
+
+            AccessibleCardUtils.AddLineIfExists(entityDef.GetRaceText(), ret);
+
+            ret.Add(GetType(entityDef.GetCardType()));
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(entityDef), ret);
+
+            return ret;
+        }
+
+        private static string GetResources(EntityDef entityDef)
+        {
+            if (entityDef.IsMinion())
+            {
+                var atk = entityDef.GetATK();
+                var hp = entityDef.GetHealth();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, atk, hp);
+            }
+            else if (entityDef.IsWeapon())
+            {
+                var atk = entityDef.GetATK();
+                var durability = entityDef.GetDurability();
+                return LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_DURABILITY, atk, durability);
+            }
+            // TODO: Hero cards
+            else
+            {
+                return "";
+            }
+        }
+
+        internal static string GetQuestProgressLine(Entity entity)
+        {
+            var curProgress = entity.GetTag(GAME_TAG.QUEST_PROGRESS);
+            var questProgressTotal = entity.GetTag(GAME_TAG.QUEST_PROGRESS_TOTAL);
+
+            return LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, curProgress, questProgressTotal);
+        }
+
+        internal static string GetInGameCardNameWithPremium(Card card)
+        {
+            return GetInGameEntityNameWithPremium(card.GetEntity());
+        }
+
+        internal static string GetInGameEntityNameWithPremium(Entity entity)
+        {
+            var entityName = entity.GetName();
+            var premiumType = entity.GetPremiumType();
+
+            if (premiumType == TAG_PREMIUM.GOLDEN)
+            {
+                return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_PREMIUM_GOLDEN, entityName);
+            }
+            else
+            {
+                return entityName;
+            }
+        }
+
+        internal static string GetRewardCardIDFromQuestCardID(Entity entity)
+        {
+            return QuestController.GetRewardCardIDFromQuestCardID(entity);
+        }
+
+        internal static string GetNameWithPremium(string name, TAG_PREMIUM premiumType)
+        {
+            switch (premiumType)
+            {
+                case TAG_PREMIUM.GOLDEN:
+                    return LocalizationUtils.Format(LocalizationKey.READ_COLLECTION_CARD_NAME_GOLDEN, name);
+                case TAG_PREMIUM.DIAMOND:
+                    return LocalizationUtils.Format(LocalizationKey.READ_COLLECTION_CARD_NAME_DIAMOND, name);
+                case TAG_PREMIUM.SIGNATURE:
+                    return LocalizationUtils.Format(LocalizationKey.READ_COLLECTION_CARD_NAME_SIGNATURE, name);
+                default:
+                    return name;
+            }
+        }
+
+        internal static string GetCardCost(int cost)
+        {
+            return LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, cost);
+        }
+
+        internal static string GetCardPackName(int packId)
+        {
+            BoosterDbfRecord record = GameDbf.Booster.GetRecord(packId);
+
+            if (record == null)
+            {
+                return null;
+            }
+
+            var name = record.Name?.GetString();
+
+            if (name == null || name.Length == 0)
+            {
+                if (record.NoteDesc != null && record.NoteDesc.Length > 0)
+                {
+                    // e.g. standard warrior pack from BoH Garrosh
+                    return record.NoteDesc;
+                }
+
+                return null;
+            }
+
+            return name;
+        }
+
+        internal static bool ShouldShowFavoriteHeroText(EntityDef entityDef)
+        {
+            if (entityDef == null)
+            {
+                return false;
+            }
+
+            TAG_CLASS @class = entityDef.GetClass();
+            string cardId = entityDef.GetCardId();
+
+            return CollectionManager.Get().GetCountOfOwnedHeroesForClass(@class) > 1 && CollectionManager.Get().IsFavoriteHero(cardId);
+        }
+
+        internal static bool HasHiddenStats(Entity card)
+        {
+            return card.HasTag(GAME_TAG.HIDE_STATS);
+        }
+
+        internal static bool IsCursed(Entity entity)
+        {
+            if (entity == null)
+            {
+                return false;
+            }
+
+            return entity.HasTag(GAME_TAG.EVIL_GLOW);
+        }
+
+        internal static bool IsReady(Card card)
+        {
+            if (card.GetEntity().IsLocation())
+            {
+                return (card.GetEntity().GetZone() == TAG_ZONE.PLAY) && (!card.GetEntity().IsExhausted());
+            }
+
+            var actorStateType = card?.GetActor()?.GetActorStateType();
+
+            return actorStateType == ActorStateType.CARD_POWERED_UP || actorStateType == ActorStateType.CARD_COMBO;
+        }
+
+        internal static bool IsSilencedMinion(Entity entity)
+        {
+            if (entity == null)
+            {
+                return false;
+            }
+
+            if (entity.GetCardType() != TAG_CARDTYPE.MINION || entity.GetZone() != TAG_ZONE.PLAY)
+            {
+                return false;
+            }
+
+            return entity.IsSilenced();
+        }
+
+        internal static string GetCost(Card card)
+        {
+            int cost = card.GetEntity().GetCost();
+
+            if (IsCostHidden(card))
+            {
+                cost = 0;
+            }
+
+            if (card.GetEntity().HasTag(GAME_TAG.CARD_COSTS_HEALTH))
+            {
+                // Stealer of souls changes cost to health instead of mana
+                return LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, cost);
+            }
+            else
+            {
+                if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+                {
+                    return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_COST, cost);
+                }
+                else
+                {
+                    return LocalizationUtils.Format(LocalizationKey.READ_CARD_COST, cost);
+                }
+            }
+        }
+
+        internal static bool IsCostHidden(Card card)
+        {
+            return AreStatsHidden(card) || card.GetEntity().HasTag(GAME_TAG.HIDE_COST);
+        }
+
+        internal static bool AreStatsHidden(Card card)
+        {
+            return card.GetEntity().HasTag(GAME_TAG.HIDE_STATS);
+        }
+
+        internal static bool IsAttackHidden(Card card)
+        {
+            return AreStatsHidden(card) || card.GetEntity().HasTag(GAME_TAG.HIDE_ATTACK);
+        }
+
+        internal static bool IsHealthHidden(Card card)
+        {
+            return AreStatsHidden(card) || card.GetEntity().HasTag(GAME_TAG.HIDE_HEALTH);
+        }
+
+        internal static bool IsArmorHidden(Card card)
+        {
+            return AreStatsHidden(card);
+        }
+
+        internal static string GetAnomalyText(int anomalyId)
+        {
+            var entityDef = DefLoader.Get().GetEntityDef(anomalyId);
+            return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_ANOMALY, entityDef.GetName(), entityDef.GetCardTextInHand());
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleChapterButton.cs b/Assembly-CSharp/Accessibility/AccessibleChapterButton.cs
new file mode 100644
index 0000000..c49eb37
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleChapterButton.cs
@@ -0,0 +1,24 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleChapterButton : AccessibleItem
+    {
+        private string Name;
+        private string Description;
+        internal AccessibleChapterButton(AccessibleComponent parent, string Name, string description) : base(parent)
+        {
+            this.Name=Name;
+            this.Description=description;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret=new List<string>();
+            ret.Add(Name);
+            ret.Add(Description);
+            return ret;
+        }
+
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleCheckBox.cs b/Assembly-CSharp/Accessibility/AccessibleCheckBox.cs
new file mode 100644
index 0000000..38de124
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleCheckBox.cs
@@ -0,0 +1,81 @@
+﻿using System;
+
+namespace Accessibility
+{
+    class AccessibleCheckBox : AccessibleElement
+    {
+        public bool state
+        {
+            get
+            {
+                if (m_checkBox != null)
+                {
+                    return m_checkBox.IsChecked();
+                }
+                else
+                {
+                    return m_getState();
+                }
+            }
+        }
+
+        private readonly CheckBox m_checkBox;
+
+        private Action m_onToggle;
+
+        internal delegate bool GetState();
+
+        private GetState m_getState;
+
+        private string m_label;
+
+        internal AccessibleCheckBox(AccessibleComponent parent, string label, CheckBox checkBox) : base(parent)
+        {
+            m_checkBox = checkBox;
+            m_label = label;
+        }
+
+        internal AccessibleCheckBox(AccessibleComponent parent, string label, Action onToggle, GetState getState) : base(parent)
+        {
+            m_onToggle = onToggle;
+            m_getState = getState;
+            m_label = label;
+        }
+
+        public void Toggle()
+        {
+            if (m_checkBox != null)
+            {
+                m_checkBox.TriggerRelease();
+            }
+            else
+            {
+                m_onToggle();
+            }
+            ReadState();
+        }
+
+        private string GetStateString()
+        {
+            if (state)
+            {
+                return LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_CHECKED);
+            }
+            else
+            {
+                return LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_NOT_CHECKED);
+            }
+        }
+
+        private void ReadState()
+        {
+            Output(GetStateString());
+        }
+
+        internal string GetText()
+        {
+            var baseText = LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, m_label);
+            return $"{baseText} {GetStateString()}";
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs b/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs
new file mode 100644
index 0000000..62b1a19
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleCollectibleCard.cs
@@ -0,0 +1,353 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectibleCard : AccessibleCollectible
+    {
+        private readonly CollectibleCard m_card;
+
+        private readonly CollectionCardActors m_actors;
+
+        private bool m_readCount;
+
+        private bool m_readClass;
+
+        private bool m_countOverride;
+        private int m_count;
+
+        private bool m_readOwned; // Used to read missing vs owned when e.g. crafting cards or seeing hero skins
+
+        private bool m_readFavorites; // Used to read things like "favorite rogue" when reading hero skins or "favorite" when reading card backs
+
+        internal AccessibleCollectibleCard(AccessibleComponent parent, CollectibleCard card, bool readCount=true, bool readClass=false, bool readOwned=false, bool readFavorites=false, CollectionCardActors actors = null) : base(parent)
+        {
+            m_card = card;
+            m_readCount = readCount;
+            m_readClass = readClass;
+            m_readOwned = readOwned;
+            m_readFavorites = readFavorites;
+
+            m_actors = actors;
+        }
+
+        // Used for listing cards in e.g. deck building where the card count is not necessarily the owned count
+        internal AccessibleCollectibleCard(AccessibleComponent parent,CollectibleCard card, int count) : base(parent)
+        {
+            m_card = card;
+            m_countOverride = true;
+            m_count = count;
+            m_readCount = true;
+            m_readClass = false;
+            m_readOwned = false;
+            m_readFavorites = false;
+        }
+
+        internal override List<string> GetLines()
+        {
+            switch (m_card.CardType)
+            {
+                case TAG_CARDTYPE.HERO:
+                    return GetLinesForHero();
+                case TAG_CARDTYPE.HERO_POWER:
+                    return GetLinesForHeroPower();
+                case TAG_CARDTYPE.WEAPON:
+                case TAG_CARDTYPE.ENCHANTMENT:
+                case TAG_CARDTYPE.MINION:
+                case TAG_CARDTYPE.SPELL:
+                    return GetLinesForNormalCard();
+                default:
+                    Log.Accessibility.PrintError($"AccessibleCollectibleCard: Found unhandled CardType {m_card.CardType}");
+                    return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            if (m_card.IsHeroSkin)
+            {
+                if (m_card.GetEntityDef().HasTag(GAME_TAG.BACON_SKIN))
+                {
+                    return GetLinesForBattlegroundsHeroSkin();
+                }
+                else if (m_card.GetEntityDef().HasTag(GAME_TAG.BACON_BOB_SKIN))
+                {
+                    return GetLinesForBattlegroundsGuideSkin();
+                }
+                else
+                {
+                    return GetLinesForTraditionalHeroSkin();
+                }
+            }
+            else if (m_card.GetEntityDef().GetArmor() > 0) // TODO: Figure out how we can differentiate this as this is a wild guess
+            {
+                return GetLinesForHeroCard();
+            }
+            else
+            {
+                // Generic default just in case we're missing something
+                var lines = new List<string>();
+                lines.Add(GetName());
+
+                AccessibleCardUtils.AddLineIfExists(GetResources(), lines);
+
+                return lines;
+            }
+        }
+
+        private List<string> GetLinesForHeroCard()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (m_readClass)
+            {
+                lines.Add(GetClassName());
+            }
+
+            AddOwnedIfNeeded(lines);
+
+            lines.Add(GetCost());
+            lines.Add(GetCardType());
+
+            var armor = m_card.GetEntityDef().GetArmor();
+
+            lines.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            try
+            {
+                lines.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(m_card.GetEntityDef().GetCardId()));
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetSet(m_card.GetEntityDef()), lines);
+
+            return lines;
+        }
+
+        private string GetClassName()
+        {
+            var entityDef = m_card.GetEntityDef();
+            if (entityDef.IsMultiClass())
+            {
+                return PackOpeningCard.GetFamilyClassNames(entityDef);
+            }
+            return GameStrings.GetClassName(entityDef.GetClass());
+        }
+
+        private List<string> GetLinesForTraditionalHeroSkin()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (m_readFavorites && AccessibleCardUtils.ShouldShowFavoriteHeroText(m_card.GetEntityDef()))
+            {
+                lines.Add(GameStrings.Format("GLUE_COLLECTION_MANAGER_FAVORITE_DEFAULT_TEXT", GameStrings.GetClassName(m_card.GetEntityDef().GetClass())));
+            }
+            else if (m_readClass)
+            {
+                lines.Add(GetClassName());
+            }
+
+            AddOwnedIfNeeded(lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForBattlegroundsHeroSkin()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            if (m_readFavorites && BaconHeroSkinUtils.IsBattlegroundsHeroSkinFavorited(m_card.GetEntityDef()))
+            {
+                lines.Add(GameStrings.Get("GLUE_BACON_COLLECTION_FAVORITE"));
+            }
+
+            AddOwnedIfNeeded(lines);
+            lines.Add(GetRarity());
+            return lines;
+        }
+
+        private List<string> GetLinesForBattlegroundsGuideSkin()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            if (m_readFavorites && BaconHeroSkinUtils.IsBattlegroundsGuideSkinFavorited(m_card.GetEntityDef()))
+            {
+                lines.Add(GameStrings.Get("GLUE_BACON_COLLECTION_FAVORITE_GUIDE"));
+            }
+
+            AddOwnedIfNeeded(lines);
+            lines.Add(GetRarity());
+            return lines;
+        }
+
+        private void AddOwnedIfNeeded(List<string> lines)
+        {
+            if (m_readOwned)
+            {
+                AccessibleCardUtils.AddOwnedLine(lines, GetNumCopies());
+            }
+        }
+
+        private List<string> GetLinesForHeroPower()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            lines.Add(GetCost());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            string className = null;
+            if (m_readClass)
+            {
+                className = GetClassName();
+            }
+
+            var lines = new List<string>();
+
+            if (IsCoin())
+            {
+                AddCoinName(lines);
+                AddFavoriteCoinIfNeeded(lines);
+                AddOwnedIfNeeded(lines);
+
+                lines.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(m_card.GetEntityDef(), m_card.PremiumType));
+            }
+            else
+            {
+                lines.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(m_card.GetEntityDef(), m_card.PremiumType, className, m_readOwned, GetNumCopies()));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetCardCount(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetSet(m_card.GetEntityDef()), lines);
+            return lines;
+        }
+
+        private bool IsCoin()
+        {
+            return CosmeticCoinManager.Get()?.IsCoinCard(m_card.CardId) ?? false;
+        }
+
+        private void AddCoinName(List<string> lines)
+        {
+            var coinRecord = CosmeticCoinManager.Get()?.GetCoinRecord(m_card);
+
+            if (coinRecord != null)
+            {
+                lines.Add(coinRecord.Name);
+            }
+        }
+
+        private void AddFavoriteCoinIfNeeded(List<string> lines)
+        {
+            if (!m_readFavorites)
+            {
+                return;
+            }
+
+            if (CosmeticCoinManager.Get()?.IsFavoriteCoinCard(m_card.CardId) ?? false)
+            {
+                lines.Add(GameStrings.Get("GLUE_COLLECTION_MANAGER_FAVORITE_COIN"));
+            }
+        }
+
+        private string GetDescription()
+        {
+            return m_card.CardInHandText;
+        }
+
+        private string GetCardType()
+        {
+            return AccessibleCardUtils.GetType(m_card.CardType);
+        }
+
+        private string GetRarity()
+        {
+            return AccessibleCardUtils.GetRarity(m_card.GetEntityDef());
+        }
+
+        private string GetCost()
+        {
+            return AccessibleCardUtils.GetCardCost(m_card.ManaCost);
+        }
+
+        private string GetCardCount()
+        {
+            if (!m_readCount)
+            {
+                return "";
+            }
+
+            var numCopies = GetNumCopies();
+
+            if (numCopies <= 1)
+            {
+                return "";
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.READ_CARD_N_COPIES, numCopies);
+        }
+
+        private int GetNumCopies()
+        {
+            if (m_countOverride)
+            {
+                // Used by e.g. deck builder
+                return m_count;
+            }
+            else
+            {
+                return m_card.OwnedCount;
+            }
+        }
+
+        private string GetResources()
+        {
+            return AccessibleCardUtils.GetResourcesForEntityDef(m_card.GetEntityDef());
+        }
+
+        internal override string GetName()
+        {
+            if(IsCoin()) {
+                var coinRecord = CosmeticCoinManager.Get()?.GetCoinRecord(m_card);
+
+                if (coinRecord != null)
+                {
+                    return coinRecord.Name;
+                }
+            }
+        return AccessibleCardUtils.GetNameWithPremium(m_card.Name, m_card.PremiumType);
+        }
+
+        internal override void Activate()
+        {
+            if (AccessibleCollectionManager.Get().IsInEditDeckMode())
+            {
+                AccessibleInputMgr.ClickLeftMouseButton();
+            }
+            else
+            {
+                AccessibleInputMgr.ClickRightMouseButton();
+            }
+        }
+
+        internal override void UpdateMouse()
+        {
+            AccessibleInputMgr.MoveMouseTo(m_actors.GetPreferredActor());
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleCollectionHeroPickerButton.cs b/Assembly-CSharp/Accessibility/AccessibleCollectionHeroPickerButton.cs
new file mode 100644
index 0000000..cee552f
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleCollectionHeroPickerButton.cs
@@ -0,0 +1,49 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectionHeroPickerButton : AccessibleItem
+    {
+        private readonly HeroPickerButton m_button;
+
+        internal AccessibleCollectionHeroPickerButton(AccessibleComponent parent, HeroPickerButton button) : base(parent)
+        {
+            m_button = button;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            var heroClass = m_button.GetEntityDef().GetClass();
+            var className = GameStrings.GetClassName(heroClass);
+
+            if (className != null && className.Length > 0)
+            {
+                ret.Add(className);
+            }
+
+            var numHeroesForClass = GetCountOfHeroesForClass(heroClass);
+			var numHeroesOwnedForClass = CollectionManager.Get().GetCountOfOwnedHeroesForClass(heroClass);
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_UNLOCK_PROGRESS, numHeroesOwnedForClass, numHeroesForClass));
+
+            return ret;
+        }
+
+		private int GetCountOfHeroesForClass(TAG_CLASS heroClass)
+		{
+			List<CollectibleCard> cards = CollectionManager.Get().FindCards(null, null, null, null, minOwned: 0, isHero: true, theseClassTypes: new TAG_CLASS[1] { heroClass }).m_cards;
+            var uniqueHeroes = new HashSet<int>(); // Keep track of IDs so golden skins and similar things don't interfere
+
+            cards.ForEach(c => uniqueHeroes.Add(c.CardDbId));
+
+            return uniqueHeroes.Count;
+		}
+
+		internal HeroPickerButton GetHeroPickerButton()
+        {
+            return m_button;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleComponent.cs b/Assembly-CSharp/Accessibility/AccessibleComponent.cs
new file mode 100644
index 0000000..3523cc1
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleComponent.cs
@@ -0,0 +1,6 @@
+﻿namespace Accessibility
+{
+    public interface AccessibleComponent
+    {
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/AccessibleDropdownControl.cs b/Assembly-CSharp/Accessibility/AccessibleDropdownControl.cs
new file mode 100644
index 0000000..4681c57
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleDropdownControl.cs
@@ -0,0 +1,127 @@
+﻿using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleDropdownControl : AccessibleElement
+    {
+        private readonly DropdownControl m_dropdown;
+
+        private Action m_onDone;
+
+        private AccessibleMenu m_menu;
+
+        private string m_label;
+
+        internal AccessibleDropdownControl(AccessibleComponent parent, string label, DropdownControl dropdown, Action onDone) : base(parent)
+        {
+            m_dropdown = dropdown;
+            m_onDone = onDone;
+            m_label = label;
+
+            SetupMenu();
+        }
+
+        private void SetupMenu()
+        {
+            m_menu = new AccessibleMenu(m_parent, "", OnBackPressed, true);
+
+            foreach(var item in m_dropdown.m_items)
+            {
+                m_menu.AddOption(item.m_text.Text, () => SelectItem(item));
+            }
+        }
+
+        private void OnBackPressed()
+        {
+            m_dropdown.m_cancelCatcher.TriggerRelease();
+            m_onDone();
+        }
+
+        private void SelectItem(DropdownMenuItem item)
+        {
+            item.TriggerRelease();
+            m_onDone();
+        }
+
+        public void HandleInput()
+        {
+            m_menu?.HandleAccessibleInput();
+            /*if (GlobalAccessibleMenuUtils.ReadNextIsPressed())
+            {
+                ReadNextItem(1);
+            }
+            else if (GlobalAccessibleMenuUtils.ReadPrevIsPressed())
+            {
+                ReadNextItem(-1);
+            }
+            else if (GlobalAccessibleMenuUtils.BackIsPressed() || GlobalAccessibleMenuUtils.ConfirmIsPressed())
+            {
+                m_onDone();
+            }*/
+        }
+
+        private void ReadNextItem(int inc)
+        {
+            var selectedItem = GetSelectedItem();
+            var curIndex = FindItemIndex(selectedItem);
+            var targetIndex = curIndex + inc;
+            var numItems = m_dropdown.m_items.Count;
+
+            if (targetIndex >= numItems)
+            {
+                targetIndex = curIndex;
+            }
+            else if (targetIndex < 0)
+            {
+                targetIndex = 0;
+            }
+
+            var newItem = m_dropdown.m_items[targetIndex];
+            newItem.TriggerRelease();
+
+            StartReading();
+        }
+
+        public void StartReading()
+        {
+            /*var selectedItem = GetSelectedItem();
+
+            var curItemName = selectedItem?.m_text?.Text;
+            var curItemNumber = FindItemIndex(selectedItem) + 1;
+            var numItems = m_dropdown.m_items.Count;
+
+            AccessibilityMgr.Output(AccessibleSpeech.MENU_OPTION(curItemName, curItemNumber, numItems));*/
+
+            var selectedItem = GetSelectedItem();
+            var curItemIndex = FindItemIndex(selectedItem);
+            m_menu.SetIndex(curItemIndex);
+            m_menu.StartReading();
+            m_dropdown.m_button.TriggerRelease();
+        }
+
+        private DropdownMenuItem GetSelectedItem()
+        {
+            return m_dropdown.m_selectedItem;
+        }
+
+        private int FindItemIndex(DropdownMenuItem item)
+        {
+            for (int i = 0; i < m_dropdown.m_items.Count; i++)
+            {
+                if (m_dropdown.m_items[i].GetValue().Equals(item.GetValue()))
+                {
+                    return i;
+                }
+            }
+
+            return 0;
+        }
+
+        internal string GetText()
+        {
+            return $"{m_label} {GetSelectedItem().m_text.Text}";
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleElement.cs b/Assembly-CSharp/Accessibility/AccessibleElement.cs
new file mode 100644
index 0000000..cc94417
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleElement.cs
@@ -0,0 +1,17 @@
+﻿namespace Accessibility
+{
+    public class AccessibleElement
+    {
+        protected AccessibleComponent m_parent;
+
+        public AccessibleElement(AccessibleComponent parent)
+        {
+            m_parent = parent;
+        }
+
+        protected void Output(string text)
+        {
+            AccessibilityMgr.Output(m_parent, text);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs b/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs
new file mode 100644
index 0000000..34c93b1
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleEndGameScreen.cs
@@ -0,0 +1,78 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleEndGameScreen : AccessibleScreen
+    {
+        private static AccessibleEndGameScreen s_instance = new AccessibleEndGameScreen();
+
+        private PegUIElement m_continue;
+
+        private AccessibleMultilineText s_curText;
+
+        internal static AccessibleEndGameScreen Get()
+        {
+            return s_instance;
+        }
+
+        internal void OnShow()
+        {
+            s_curText = null;
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        internal void OnShown(PegUIElement hitbox)
+        {
+            m_continue = hitbox;
+
+            AccessibilityMgr.SetScreen(this);
+        }
+
+        public string GetHelp()
+        {
+            return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+
+        public void HandleInput()
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_continue.TriggerRelease();
+            }
+            else
+			{
+                s_curText?.HandleAccessibleInput();
+			}
+        }
+
+		public void OnGainedFocus()
+        {
+        }
+
+		internal void OnDebugEndGameScreen(PegUIElement debugClickCatcher)
+		{
+            OnShown(debugClickCatcher);
+		}
+
+		internal void OnDebugEndGameScreenHide()
+		{
+            m_continue = null;
+
+            AccessibilityMgr.SetScreen(AccessibleHub.Get());
+		}
+
+        public void SetupLines(List<string> lines)
+		{
+            // Allow components to set up accessible lines so players can reread
+            // TODO: Refactor all of this once we start integrating reprompts
+            s_curText = new AccessibleMultilineText(this, lines, lines.Count - 1);
+		}
+
+		public void ClearLines()
+		{
+            s_curText = null;
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleGameModeScene.cs b/Assembly-CSharp/Accessibility/AccessibleGameModeScene.cs
new file mode 100644
index 0000000..f68be9f
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleGameModeScene.cs
@@ -0,0 +1,146 @@
+﻿using Hearthstone.DataModels;
+using Hearthstone.UI;
+using System;
+
+namespace Accessibility
+{
+    class AccessibleGameModeScene : AccessibleScreen
+    {
+        private enum State { LOADING, MAIN_MENU };
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_mainMenu;
+
+        private GameModeSceneDataModel m_gameModeSceneDataModel;
+
+        private static AccessibleGameModeScene s_instance = new AccessibleGameModeScene();
+
+        internal static AccessibleGameModeScene Get()
+        {
+            return s_instance;
+        }
+
+        public void OnDisplayReady(GameModeSceneDataModel gameModeSceneDataModel)
+        {
+            try
+            {
+                m_gameModeSceneDataModel = gameModeSceneDataModel;
+
+                SetupMainMenu();
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_MODE), OnClickBackButton);
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_RECONNECT_GAME_TYPE_ARENA"), OnClickArena);
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_ADVENTURE"), OnClickSoloAdventures);
+            m_mainMenu.AddOption(LocalizedText.SCREEN_GO_BACK, OnClickBackButton);
+
+            m_curState = State.MAIN_MENU;
+        }
+
+        private void OnClickBackButton()
+        {
+            GameModeDisplay.Get().m_backButton.TriggerRelease();
+        }
+
+        private void OnClickSoloAdventures()
+        {
+            var soloAdventuresButton = GetSoloAdventuresButton();
+
+            if (soloAdventuresButton == null)
+            {
+                AccessibilityUtils.LogFatalError(new Exception("Could not find solo adventures button"));
+            }
+
+            GameModeDisplay.Get().SelectMode(soloAdventuresButton);
+            if (!GameModeDisplay.Get().CanEnterMode(out var reason, out var unused))
+            {
+                AccessibilityMgr.Output(this, reason);
+                return;
+            }
+            GameModeDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        private void OnClickArena()
+        {
+            var arenaButton = GetArenaButton();
+
+            if (arenaButton == null)
+            {
+                AccessibilityUtils.LogFatalError(new Exception("Could not find arena button"));
+            }
+
+            GameModeDisplay.Get().SelectMode(arenaButton);
+            if (!GameModeDisplay.Get().CanEnterMode(out var reason, out var unused))
+            {
+                AccessibilityMgr.Output(this, reason);
+                return;
+            }
+            GameModeDisplay.Get().m_playButton.TriggerRelease();
+        }
+
+        private GameModeButtonDataModel GetSoloAdventuresButton()
+        {
+            foreach (var button in m_gameModeSceneDataModel.GameModeButtons)
+            {
+                if (button.GameModeRecordId == 6)
+                {
+                    return button;
+                }
+            }
+
+            return null;
+        }
+
+        private GameModeButtonDataModel GetArenaButton()
+        {
+            foreach (var button in m_gameModeSceneDataModel.GameModeButtons)
+            {
+                if (button.GameModeRecordId == 1)
+                {
+                    return button;
+                }
+            }
+
+            return null;
+        }
+
+        public void HandleInput()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu?.HandleAccessibleInput();
+            }
+        }
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case State.MAIN_MENU:
+                    return m_mainMenu?.GetHelp();
+                default:
+                    break;
+            }
+
+            return "";
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu.StartReading();
+            }
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleGameplay.cs b/Assembly-CSharp/Accessibility/AccessibleGameplay.cs
new file mode 100644
index 0000000..e6ada19
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleGameplay.cs
@@ -0,0 +1,2890 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleGameplay : AccessibleScreen
+    {
+        protected enum AccessibleGamePhase
+        {
+            WAITING_FOR_GAME_TO_START,
+            MULLIGAN,
+            WAITING_FOR_OPPONENT_MULLIGAN,
+            PLAYING,
+            GAME_OVER
+        }
+
+        protected enum AccessibleGameState
+        {
+            UNKNOWN,
+            WAITING,
+            OPPONENT_TURN,
+            MAIN_OPTION_MODE,
+            SUB_OPTION_MODE,
+            TARGET_MODE,
+            CHOICE_MODE,
+            CHOICE_MODE_CHOICES_HIDDEN,
+            SUMMONING_MINION,
+            PLAYING_CARD,
+            TRADING_CARD,
+            CONFIRMING_END_TURN,
+            BROWSING_HISTORY,
+            ALL_MINIONS_TO_FACE,
+            MINION_TO_FACE,
+
+            // Battlegrounds-only
+            BUYING_CARD,
+            SELLING_MINION,
+            MOVING_MINION,
+            READING_LEADERBOARD,
+        }
+
+        private static AccessibleGameplay s_instance;
+
+        protected AccessibleGamePhase m_curPhase;
+
+        protected AccessibleGameState m_curState;
+        private bool IsInBeginningChooseOne = false;//used to allow player to pick options after their mulligan.
+
+        protected AccessibleGameState m_prevState;
+
+        protected GameState.ResponseMode m_curResponseMode;
+        protected GameState.ResponseMode m_prevResponseMode;
+
+        protected Zone m_curZone;
+
+        protected AccessibleCard m_cardBeingRead;
+
+        protected Card m_heldCard;
+
+        protected bool m_playerTurn;
+
+        private bool m_confirmingEndTurn;
+
+        private bool m_sendingAllMinionsToFace;
+        private Card m_curFaceAttacker;
+        private bool m_sendingMinionToFace;
+        private int m_minionAttackState;
+
+        private float m_nextAction = 0; // Needed to circumvent a lot of frame-related issues that would arise otherwise
+
+        // Choice mode
+        protected AccessibleListOfItems<AccessibleCard> m_accessibleChoiceCards;
+
+        // Mulligan
+        protected AccessibleListOfItems<AccessibleCard> m_accessibleMulliganCards;
+        private Dictionary<AccessibleCard, bool> m_mulliganMarkedForReplacement;
+        protected NormalButton m_mulliganConfirmButton;
+        private bool m_waitingForMulliganReplacementCards;
+
+        protected bool m_justReconnected;
+
+        private bool m_tradingCard;
+        private bool m_tradingCardWaitingForHold; // Used to prevent "Summon?" or "Play?" when a card is traded straight from hand but we still need to wait for it to be held
+
+        protected bool m_forceAnnounceChooseTarget; // Needed so that cards with multiple targets can correctly inform the player.
+
+        // New tutorial stuff
+        private bool m_disableManaCounters;
+        private bool m_disableCorpseCounters;
+
+        internal static AccessibleGameplay Get()
+        {
+            if (s_instance == null)
+            {
+                InitInstance();
+            }
+
+            return s_instance;
+        }
+
+        private static void InitInstance()
+        {
+            if (AccessibleGameplayUtils.IsFindingOrPlayingBattlegrounds())
+            {
+                s_instance = new AccessibleBattlegroundsGameplay();
+            }
+            else
+            {
+                s_instance = new AccessibleGameplay();
+            }
+        }
+
+        public void OnTurnStart()
+        {
+            try
+            {
+                AccessiblePowerTaskListDescriber.Get().OnTurnStart(!m_disableManaCounters);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnCoinResult(bool friendlyPlayerGoesFirst)
+        {
+            if (friendlyPlayerGoesFirst)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOU_GO_FIRST));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_OPPONENT_GOES_FIRST));
+            }
+        }
+
+        public void OnStartingHand(List<Card> cards)
+        {
+            try
+            {
+                if (AccessibilityUtils.IsInPvPGame())
+                {
+                    var opponent = GameState.Get().GetOpposingSidePlayer();
+                    var opponentName = opponent.GetName();
+                    var opponentClass = opponent.GetHero().GetClass();
+                    var opponentClassName = GameStrings.GetClassName(opponentClass);
+                    AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_VS_PLAYER_ANNOUNCEMENT, opponentName, opponentClassName));
+                    AccessibleHistoryMgr.Get().AddEntry(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_VS_PLAYER_ANNOUNCEMENT, opponentName, opponentClassName));
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_YOU_START_WITH_N_CARDS, cards.Count));
+        }
+
+        public virtual void EndMulligan()
+        {
+            try
+            {
+                if (m_accessibleMulliganCards != null)
+                {
+                    var originalCards = new HashSet<Card>(m_accessibleMulliganCards.Count);
+                    m_accessibleMulliganCards.Items.ForEach(c => originalCards.Add(c.GetCard()));
+                    var cardsAfterMulligan = GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCards();
+                    var newCards = new List<Card>();
+                    var droppedCards = new List<Card>();
+
+                    foreach (var card in originalCards)
+                    {
+                        if (!cardsAfterMulligan.Contains(card))
+                        {
+                            droppedCards.Add(card);
+                        }
+                    }
+
+                    foreach (var card in cardsAfterMulligan)
+                    {
+                        if (!originalCards.Contains(card) && !IsCoinCard(card.GetEntity()))
+                        {
+                            newCards.Add(card);
+                        }
+                    }
+
+                    if (droppedCards.Count > 0)
+                    {
+                        var droppedNames = AccessibleSpeechUtils.GetNames(droppedCards);
+                        var newNames = AccessibleSpeechUtils.GetNames(newCards);
+AccessibleHistoryMgr.Get().AddEntry(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_DISCARDED_CARDS, droppedNames));
+                        AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARDS, newNames));
+                        AccessibleHistoryMgr.Get().AddEntry(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARDS, newNames));
+                    }
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            TransitionFromMulliganToGame();
+        }
+
+        protected void TransitionFromMulliganToGame()
+        {
+            m_accessibleMulliganCards = null;
+            m_waitingForMulliganReplacementCards = false;
+
+            OnGameStart();
+        }
+
+        private bool IsCoinCard(Entity entity)
+        {
+            return CosmeticCoinManager.Get()?.IsCoinCard(entity.GetCardId()) ?? false;
+        }
+
+        public void OnMulliganCardsDealt(List<Card> cards)
+        {
+        }
+
+        public void OnGameplayScreenStart()
+        {
+            Reset();
+
+            InitInstance();
+            s_instance.Reset();
+
+            AccessibilityMgr.SetScreen(s_instance);
+        }
+
+        protected virtual void Reset()
+        {
+            m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            m_curState = AccessibleGameState.UNKNOWN;
+            m_prevState = AccessibleGameState.UNKNOWN;
+            m_curResponseMode = GameState.ResponseMode.NONE;
+            m_prevResponseMode = GameState.ResponseMode.NONE;
+            m_curZone = null;
+            m_cardBeingRead = null;
+            m_heldCard = null;
+            m_playerTurn = false;
+            m_confirmingEndTurn = false;
+            m_sendingAllMinionsToFace = false;
+            m_curFaceAttacker = null;
+            m_sendingMinionToFace = false;
+            m_minionAttackState = 0;
+            m_nextAction = 0;
+            m_accessibleChoiceCards = null;
+            m_zoneSelectedListeners.Clear();
+            m_cardSelectedListeners.Clear();
+            m_summoningMinionListeners.Clear();
+            m_stopHidingMouse = false;
+            m_waitingForMulliganReplacementCards = false;
+            m_tradingCard = false;
+            m_tradingCardWaitingForHold = false;
+            m_forceAnnounceChooseTarget = false;
+            m_disableManaCounters = false;
+            m_disableCorpseCounters = false;
+            AccessibleHistoryMgr.Get().Reset();
+        }
+
+        public void DisableManaCounters()
+        {
+            m_disableManaCounters = true;
+        }
+
+        public void DisableCorpseCounters()
+        {
+            m_disableCorpseCounters = true;
+        }
+
+        public void OnCoinCard()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOU_GET_THE_COIN));
+        }
+
+        public virtual void WaitingForOpponentToFinishMulligan()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_WAITING_FOR_OPPONENT));
+            m_curPhase = AccessibleGamePhase.WAITING_FOR_OPPONENT_MULLIGAN;
+        }
+
+        public void OnDrawCard(Card card)
+        {
+        }
+
+        private void SetCardBeingRead(Card card, bool forceZoneRead)
+        {
+            m_cardBeingRead = AccessibleCard.CreateCard(this, card);
+            var prevZone = m_curZone;
+            m_curZone = card.GetZone();
+            ReadZoneChangeIfNecessary(card, prevZone, m_curZone, forceZoneRead);
+        }
+
+        protected void ReadZoneChangeIfNecessary(Card card, Zone fromZone, Zone toZone, bool forceZoneRead)
+        {
+            if (fromZone == toZone && !forceZoneRead)
+            {
+                return;
+            }
+
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            if (card.GetEntity() == player.GetHeroPower())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HERO_POWER));
+            }
+            else if (card.GetEntity() == opponent.GetHeroPower())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_HERO_POWER));
+            }
+            else if (card == player.GetWeaponCard())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_WEAPON));
+            }
+            else if (card == opponent.GetWeaponCard())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_WEAPON));
+            }
+            else if (toZone == player.GetHandZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_HAND));
+            }
+            else if (toZone == opponent.GetHandZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_HAND)); // Not needed atm
+            }
+            else if (toZone == player.GetBattlefieldZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_MINIONS));
+            }
+            else if (toZone == opponent.GetBattlefieldZone())
+            {
+                ReadOpponentZoneName();
+            }
+            else if (toZone == player.GetSecretZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_PLAYER_SECRETS));
+            }
+            else if (toZone == opponent.GetSecretZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_SECRETS)); // Not needed atm
+            }
+        }
+
+        protected virtual void ReadOpponentZoneName()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_ZONE_OPPONENT_MINIONS));
+        }
+
+        public virtual void HandleInput()
+        {
+            if (GameState.Get() == null || InputManager.Get() == null)
+            {
+                // Game hasn't even started yet
+                return;
+            }
+
+            if (GameState.Get().IsMulliganPhase() && !IsInBeginningChooseOne)
+            {
+                m_curPhase = AccessibleGamePhase.MULLIGAN;
+            }
+            else if (GameState.Get().IsGameOver())
+            {
+                m_curPhase = AccessibleGamePhase.GAME_OVER;
+            }
+            else if (GameState.Get().IsMulliganPhasePending())
+            {
+                m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            }
+            else if (GameState.Get().IsGameCreated())
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+            }
+            else
+            {
+                m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            }
+
+            if (AccessibleKey.READ_TOOLTIP.IsPressed())
+            {
+                HandleTooltipReading();
+            }
+
+            switch (m_curPhase)
+            {
+                case AccessibleGamePhase.PLAYING:
+                    HandleInGameInput();
+                    break;
+                case AccessibleGamePhase.MULLIGAN:
+                    HandleMulliganInput();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        private void HandleMulliganInput()
+        {
+            if (m_accessibleMulliganCards == null)
+            {
+                return; // yield
+            }
+
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+            }
+
+            HandleReadAnomaliesKey();
+
+            if (AccessibleKey.MULLIGAN_MARK_CARD.IsPressed())
+            {
+                var focusedCard = m_accessibleMulliganCards.GetItemBeingRead();
+                AccessibleInputMgr.MoveMouseTo(focusedCard.GetCard());
+                AccessibleInputMgr.ClickLeftMouseButton();
+                m_mulliganMarkedForReplacement[focusedCard] = !m_mulliganMarkedForReplacement[focusedCard];
+
+                if (m_mulliganMarkedForReplacement[focusedCard])
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_WILL_BE_REPLACED));
+                }
+                else
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_WILL_NOT_BE_REPLACED));
+                }
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_mulliganConfirmButton.TriggerRelease();
+
+                // Prevent flicker while the game starts and new cards are drawn
+                m_waitingForMulliganReplacementCards = true;
+                HideMouse();
+            }
+            else if (!m_waitingForMulliganReplacementCards)
+            {
+                m_accessibleMulliganCards.HandleAccessibleInput();
+                MoveMouseToCard(m_accessibleMulliganCards.GetItemBeingRead().GetCard());
+            }
+        }
+
+        private void HandleInGameInput()
+        {
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+
+                if (GameState.Get().IsFriendlySidePlayerTurn())
+                {
+                    AccessibilityMgr.Output(this, LocalizedText.GAMEPLAY_YOUR_TURN);
+                }
+                else
+                {
+                    AccessibilityMgr.Output(this, LocalizedText.GAMEPLAY_OPPONENT_TURN);
+                }
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+                AccessiblePowerTaskListDescriber.Get().OnReconnected();
+            }
+
+            UpdateState();
+
+            if (m_curState == AccessibleGameState.ALL_MINIONS_TO_FACE)
+            {
+                HandleAllMinionsToFace();
+                return;
+            }
+            else if (m_curState == AccessibleGameState.MINION_TO_FACE)
+            {
+                HandleMinionToFace();
+                return;
+            }
+            else if (m_curState == AccessibleGameState.TRADING_CARD)
+            {
+                HandleTradingCard();
+                return;
+            }
+
+            try
+            {
+                UpdateMousePosition();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            if (m_curState == AccessibleGameState.CONFIRMING_END_TURN)
+            {
+                if (AccessibleKey.CONFIRM.IsPressed() || AccessibleKey.END_TURN.IsPressed())
+                {
+                    EndTurn();
+                    return;
+                }
+                else if (Input.anyKeyDown)
+                {
+                    m_confirmingEndTurn = false;
+                    UpdateState();
+                }
+            }
+
+            if ((m_curState == AccessibleGameState.OPPONENT_TURN || m_curState == AccessibleGameState.MAIN_OPTION_MODE) && HandleEmotes())
+            {
+                return;
+            }
+
+            switch (m_curState)
+            {
+                case AccessibleGameState.WAITING:
+                case AccessibleGameState.UNKNOWN:
+                case AccessibleGameState.OPPONENT_TURN:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleZoneInput();
+                    HandleValidOptionsSelectionInput();
+                    HandleZoneSelection();
+                    HandleHistoryInput();
+                    return;
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleMainOptionMode();
+                    HandleEndTurnInput();
+                    HandleHistoryInput();
+                    return;
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    HandleCheckStatusKeys();
+                    HandleSubOptionMode();
+                    return;
+                case AccessibleGameState.CHOICE_MODE:
+                    HandleCheckStatusKeys();
+                    bool canHandleChoiceMode=HandleChoiceMode();
+                    if(!canHandleChoiceMode) HandleTargetMode();
+                    return;
+                    case AccessibleGameState.CHOICE_MODE_CHOICES_HIDDEN:
+                    HandleCheckStatusKeys();
+                    HandleZoneSelection();
+                    HandleZoneInput();
+                    HandleCardReadingInput();
+                    if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+                    {
+                        ChoiceCardMgr.Get().GetToggleButton().TriggerRelease();
+                    }
+                    return;
+                case AccessibleGameState.TARGET_MODE:
+                    HandleCheckStatusKeys();
+                    HandleTargetMode();
+                    return;
+                case AccessibleGameState.SUMMONING_MINION:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleSummoningMinion();
+                    HandleTradeCardWhenHoldingCardInput();
+                    return;
+                case AccessibleGameState.PLAYING_CARD:
+                    //HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandlePlayingCard();
+                    HandleTradeCardWhenHoldingCardInput();
+                    return;
+                case AccessibleGameState.BROWSING_HISTORY:
+                    HandleHistoryInput();
+                    return;
+                default:
+                    return;
+            }
+        }
+
+        protected void HandleTooltipReading()
+        {
+            AccessibilityUtils.ReadTooltip(this);
+        }
+
+        private void HandleAllMinionsToFace()
+        {
+            if (Time.time < m_nextAction)
+            {
+                return;
+            }
+
+            if (m_curFaceAttacker != null)
+            {
+                ClickCard(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+                m_curFaceAttacker = null;
+                SetNextAction();
+            }
+            else
+            {
+                List<Card> remainingAttackers = GetValidFaceAttackers();
+
+                if (remainingAttackers.Count > 0)
+                {
+                    m_curFaceAttacker = remainingAttackers[0];
+                    ClickCard(m_curFaceAttacker);
+                    SetNextAction();
+                }
+                else
+                {
+                    m_sendingAllMinionsToFace = false;
+                }
+            }
+        }
+
+        private void HandleMinionToFace()
+        {
+            if (Time.time < m_nextAction)
+            {
+                return;
+            }
+
+            if (m_minionAttackState == 0)
+            {
+                ClickCard(m_cardBeingRead.GetCard());
+                m_minionAttackState = 1;
+                SetNextAction(0.1f);
+            }
+            else if (m_minionAttackState == 1)
+            {
+                ClickCard(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+                m_minionAttackState = 2;
+            }
+            else
+            {
+                m_minionAttackState = 0;
+                m_sendingMinionToFace = false;
+            }
+        }
+
+        private void SetNextAction(float delay = 0f)
+        {
+            if(delay==0f) delay=Options.Get().GetFloat(Option.ACCESSIBILITY_AUTO_ATTACK_SPEED);
+            if(delay==0f) delay=1.0f;
+            m_nextAction = Time.time + delay;
+        }
+
+        private void ClickCard(Card card)
+        {
+            MoveMouseToCard(card);
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+        private void UpdateMousePosition()
+        {
+            if (m_heldCard != null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead != null)
+            {
+                MoveMouseToCard(m_cardBeingRead.GetCard());
+            }
+            else
+            {
+                HideMouse();
+            }
+        }
+
+        private void HideMouse()
+        {
+            if (!m_stopHidingMouse)
+            {
+                AccessibleInputMgr.HideMouse();
+            }
+        }
+
+        private void HandleTradeCardWhenHoldingCardInput()
+        {
+            if (AccessibleKey.TRADE_CARD.IsPressed() && CanTradeCard(m_heldCard))
+            {
+                QueryTradeOrForgeCard(m_heldCard);
+            }
+        }
+
+        private void QueryTradeOrForgeCard(Card card)
+        {
+            m_tradingCard = true;
+            var key = card.GetEntity().IsTradeable() ? LocalizationKey.GAMEPLAY_QUERY_TRADE_CARD : LocalizationKey.GAMEPLAY_QUERY_FORGE_CARD;
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(key));
+        }
+
+        private bool CanTradeCard(Card card)
+        {
+            if (card == null || card.GetZone() != GameState.Get().GetFriendlySidePlayer().GetHandZone())
+            {
+                return false;
+            }
+
+            return card.GetEntity().IsTradeable() || card.GetEntity().IsForgeable();
+        }
+
+        private int m_summonPos;
+
+        protected void HandleSummoningMinion()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (playerMinions.GetCardCount() == 0)
+            {
+                if (m_prevState != AccessibleGameState.SUMMONING_MINION)
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION));
+                    OnSummoningMinion(m_heldCard);
+                }
+
+                MoveMouseToZone(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone());
+            }
+            else
+            {
+                if (m_prevState != AccessibleGameState.SUMMONING_MINION)
+                {
+                    m_summonPos = playerMinions.GetLastPos();
+                    QuerySummonPosition(0);
+                }
+
+                HandleSummoningPositionInput();
+
+                if (m_summonPos == playerMinions.GetLastPos())
+                {
+                    MoveMouseToRightOfZone(playerMinions);
+                }
+                else if (m_summonPos == 1)
+                {
+                    MoveMouseToLeftOfZone(playerMinions);
+                }
+                else
+                {
+                    var prevMinion = playerMinions.GetCardAtSlot(m_summonPos - 1);
+                    var nextMinion = playerMinions.GetCardAtSlot(m_summonPos);
+                    var pos = prevMinion.transform.position + (nextMinion.transform.position - prevMinion.transform.position) / 2;
+                    AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+                }
+            }
+
+            HandleConfirmOrCancel();
+        }
+
+        private void HandleSummoningPositionInput()
+        {
+            if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                QuerySummonPosition(-1);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                QuerySummonPosition(1);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+            {
+                m_summonPos = 1;
+                QuerySummonPosition(0);
+            }
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+            {
+                var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+                var lastPos = playerMinions.GetLastPos();
+                m_summonPos = lastPos;
+                QuerySummonPosition(0);
+            }
+            else
+            {
+                int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+                if (numKeyPressed.HasValue)
+                {
+                    var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+                    var lastPos = playerMinions.GetLastPos();
+
+                    m_summonPos = Math.Min(lastPos, numKeyPressed.Value);
+                    QuerySummonPosition(0);
+                }
+            }
+        }
+
+        private void QuerySummonPosition(int inc)
+        {
+            var prevSummonPos = m_summonPos;
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var lastPos = playerMinions.GetLastPos();
+
+            m_summonPos += inc;
+
+            if (m_summonPos > lastPos)
+            {
+                m_summonPos = lastPos;
+            }
+            else if (m_summonPos < 1)
+            {
+                m_summonPos = 1;
+            }
+
+            if (inc != 0 && prevSummonPos == m_summonPos)
+            {
+                return;
+            }
+
+            if (m_summonPos == lastPos)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_RIGHT));
+                OnSummoningMinion(m_heldCard);
+            }
+            else if (m_summonPos == 1)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_LEFT));
+                OnSummoningMinion(m_heldCard);
+            }
+            else
+            {
+                var prevMinion = playerMinions.GetCardAtSlot(m_summonPos - 1);
+                var nextMinion = playerMinions.GetCardAtSlot(m_summonPos);
+                var prevMinionName = GetPreferredCardName(prevMinion);
+                var nextMinionName = GetPreferredCardName(nextMinion);
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_QUERY_SUMMON_MINION_BETWEEN, prevMinionName, nextMinionName));
+                OnSummoningMinion(m_heldCard);
+            }
+        }
+
+        protected virtual string GetPreferredCardName(Card card)
+        {
+            return card.GetEntity().GetName();
+        }
+
+        protected void HandlePlayingCard()
+        {
+            if (AccessibleUnityInput.Get().GetMousePosition().y < AccessibleInputMgr.GetMousePosition(GameState.Get().GetFriendlySidePlayer().GetHeroCard()).y)
+            {
+                MoveMouseToZone(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone());
+            }
+
+            if (GameState.Get().IsInTargetMode())
+            {
+                HandleTargetMode();
+            }
+            else
+            {
+                if (m_prevState != AccessibleGameState.PLAYING_CARD && !RequiresTarget(m_heldCard)) // If a target is required, "choose a target" will already indicate we're using it
+                {
+                    QueryPlayCard();
+                }
+
+                HandleConfirmOrCancel();
+            }
+        }
+
+        private void HandleTradingCard()
+        {
+            Collider collider = Board.Get().GetDeckActionArea();
+            if (collider != null)
+            {
+                var cardBounds = m_heldCard.GetActor().GetMeshRenderer().bounds;
+                Vector3 tradeAreaCenter = collider.bounds.ClosestPoint(m_heldCard.gameObject.transform.position);
+                Vector3 target = tradeAreaCenter;
+                target.x += cardBounds.size.x / 2;
+                AccessibleInputMgr.MoveMouseToWorldPosition(target);
+            }
+
+            HandleConfirmOrCancel();
+        }
+
+        private bool RequiresTarget(Card heldCard)
+        {
+            return GameState.Get().EntityHasTargets(heldCard.GetEntity());
+        }
+
+        private void QueryPlayCard()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_PLAY_CARD));
+        }
+
+        private void HandleConfirmOrCancel(bool targetRequired = false)
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                if (!targetRequired || m_cardBeingRead != null)
+                {
+                    AccessibleInputMgr.ClickLeftMouseButton();
+                }
+            }
+            else if (AccessibleKey.BACK.IsPressed())
+            {
+                CancelOption();
+            }
+        }
+
+        private void HandleEndTurnInput()
+        {
+            if (!GameState.Get().IsInMainOptionMode())
+            {
+                return;
+            }
+
+            if (AccessibleKey.FORCE_END_TURN.IsPressed())
+            {
+                EndTurn();
+            }
+
+            if (AccessibleKey.END_TURN.IsPressed())
+            {
+                if (EndTurnButton.Get().HasNoMorePlays())
+                {
+                    EndTurn();
+                }
+                else
+                {
+                    if (PlayerHasReadyAttackers() || PlayerHeroCanStillAttack())
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_CAN_ATK));
+                    }
+                    else if (PlayerHasReadyLocations())
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_LOCATION));
+                    }
+                    else if (PlayerCanStillUseHeroPower())
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_HERO_POWER));
+                    }
+                    else
+                    {
+                        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_QUERY_END_TURN_WHEN_VALID_PLAYS));
+                    }
+
+                    StopReadingCard();
+                    m_confirmingEndTurn = true;
+                }
+            }
+        }
+
+        private bool PlayerHasReadyAttackers()
+        {
+            List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCards();
+
+            for (int i = 0; i < cards.Count; i++)
+            {
+                if (cards[i].GetEntity().IsMinion() && GameState.Get().HasResponse(cards[i].GetEntity()))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        private bool PlayerHeroCanStillAttack()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+
+            if (GameState.Get().HasResponse(player.GetHero()))
+            {
+                return true;
+            }
+            return false;
+        }
+
+        private bool PlayerHasReadyLocations()
+        {
+            List<Card> cards = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCards();
+
+            for (int i = 0; i < cards.Count; i++)
+            {
+                if (cards[i].GetEntity().IsLocation() && GameState.Get().HasResponse(cards[i].GetEntity()))
+                {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        private bool PlayerCanStillUseHeroPower()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var heroPower = player.GetHeroPower();
+
+            if (heroPower == null)
+            {
+                return false;
+            }
+
+            return GameState.Get().HasResponse(heroPower);
+        }
+
+        private void HandleMainOptionMode()
+        {
+            if (AccessibleKey.SEND_ALL_MINIONS_TO_FACE.IsPressed())
+            {
+                SendAllMinionsToFace();
+                return;
+            }
+            else if (AccessibleKey.SEND_MINION_TO_FACE.IsPressed())
+            {
+                SendMinionToFace();
+                return;
+            }
+
+            HandleZoneInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                ClickCard();
+            }
+            else if (AccessibleKey.TRADE_CARD.IsPressed() && m_cardBeingRead != null && CanTradeCard(m_cardBeingRead.GetCard()))
+            {
+                QueryTradeOrForgeCard(m_cardBeingRead.GetCard());
+                ClickCard(true);
+            }
+        }
+
+        private void SendAllMinionsToFace()
+        {
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_NO_MINIONS));
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeAttacked())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED));
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeTargetedByOpponents())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED));
+                return;
+            }
+
+            List<Card> validAttackers = GetValidFaceAttackers();
+
+            if (validAttackers.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_NO_VALID_ATTACKERS));
+            }
+            else
+            {
+                m_sendingAllMinionsToFace = true;
+            }
+        }
+
+        private void SendMinionToFace()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead.GetCard().GetZone() != GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_NOT_FRIENDLY_MINION));
+                return;
+            }
+
+            if (!m_cardBeingRead.GetCard().GetEntity().IsMinion())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_NOT_MINION));
+                return;
+            }
+
+            if (!IsValidFaceAttacker(m_cardBeingRead.GetCard()))
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_NOT_VALID_ATTACKER));
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeAttacked())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED));
+                return;
+            }
+
+            if (!GameState.Get().GetOpposingSidePlayer().GetHero().CanBeTargetedByOpponents())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED));
+                return;
+            }
+
+            m_sendingMinionToFace = true;
+        }
+
+        public void OnReconnected()
+        {
+            AccessibilityMgr.InterruptTexts();
+            AccessibilityMgr.Output(this, LocalizedText.GLOBAL_RECONNECTED);
+
+            m_justReconnected = true;
+        }
+
+        private List<Card> GetValidFaceAttackers()
+        {
+            List<Card> ret = new List<Card>();
+            List<Entity> faceTargetters = GetOptionsWithTarget(GameState.Get().GetOpposingSidePlayer().GetHero());
+
+            foreach (var entity in faceTargetters)
+            {
+                if (entity.IsMinion() && !entity.HasUsableTitanAbilities() && entity.GetCard()?.GetZone() == GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone())
+                {
+                    ret.Add(entity.GetCard());
+                }
+            }
+
+            return ret;
+        }
+
+        private List<Entity> GetOptionsWithTarget(Entity target)
+        {
+            List<Entity> ret = new List<Entity>();
+            Network.Options optionsPacket = GameState.Get().GetOptionsPacket();
+
+            if (optionsPacket == null)
+            {
+                return ret;
+            }
+
+            for (int i = 0; i < optionsPacket.List.Count; i++)
+            {
+                Network.Options.Option option = optionsPacket.List[i];
+                if (option.Type == Network.Options.Option.OptionType.POWER)
+                {
+                    if (option.Main.IsValidTarget(target.GetEntityId()))
+                    {
+                        ret.Add(GameState.Get().GetEntity(option.Main.ID));
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private bool IsValidFaceAttacker(Card minion)
+        {
+            return GetValidFaceAttackers().Contains(minion);
+        }
+
+        private void EndTurn()
+        {
+            InputManager.Get().DoEndTurnButton();
+            StopReadingCard();
+        }
+
+        protected void HandleSubOptionMode()
+        {
+            HandleChoiceMode();
+        }
+
+        protected bool HandleChoiceMode()
+        {
+            if (IsTargetChoice() || m_accessibleChoiceCards == null || !m_accessibleChoiceCards.IsReading())
+            {
+                return false; // yield
+            }
+            try
+            {
+                m_cardBeingRead = m_accessibleChoiceCards.GetItemBeingRead();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                AccessibleInputMgr.MoveMouseTo(m_cardBeingRead.GetCard());
+                AccessibleInputMgr.ClickLeftMouseButton();
+            }
+            else if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed() && m_curState == AccessibleGameState.CHOICE_MODE)
+            {
+                ChoiceCardMgr.Get().GetToggleButton().TriggerRelease();
+            }
+            else
+            {
+                m_accessibleChoiceCards.HandleAccessibleInput();
+            }
+            return true;
+        }
+
+        protected bool IsTargetChoice()
+        {
+            return GameState.Get().GetFriendlyEntityChoices()?.ChoiceType == CHOICE_TYPE.TARGET;
+        }
+
+        public void OnChoicesHidden()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOICES_HIDDEN));
+            StopReadingCard();
+        }
+
+        protected void HandleTargetMode()
+        {
+            //if (m_prevState != AccessibleGameState.TARGET_MODE) // Was broken due to play
+            if (m_forceAnnounceChooseTarget || (m_prevResponseMode != m_curResponseMode && m_curResponseMode != GameState.ResponseMode.CHOICE))
+            {
+                m_forceAnnounceChooseTarget = false;
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOOSE_TARGET));
+
+                if (m_cardBeingRead != null && m_cardBeingRead.GetCard().GetZone() == GameState.Get().GetFriendlySidePlayer().GetHandZone())
+                {
+                    StopReadingCard(false);
+                }
+            }
+
+            HandleZoneInput();
+                            HandleCardReadingInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection(true);
+            HandleConfirmOrCancel(true);
+        }
+
+        public void ForceAnnounceChooseTarget()
+        {
+            m_forceAnnounceChooseTarget = true;
+        }
+
+        private void UpdateState()
+        {
+            try
+            {
+                UpdateCardBeingReadState();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            m_heldCard = InputManager.Get().GetHeldCard();
+            m_playerTurn = GameState.Get().IsFriendlySidePlayerTurn();
+
+            if (!GameState.Get().IsInMainOptionMode())
+            {
+                m_confirmingEndTurn = false;
+            }
+
+            // TODO: Debug this properly as I think this is the flow causing the tab right after choose one issues
+            ResetChoiceCardsIfNecessary();
+
+            if (m_heldCard == null)
+            {
+                m_tradingCard = false;
+            }
+            else if (m_tradingCardWaitingForHold && CanTradeCard(m_heldCard))
+            {
+                // Additional check via CanTradeCard to prevent potential race conditions around turns ending in-between trades/selections
+                m_tradingCardWaitingForHold = false;
+                m_tradingCard = true;
+            }
+
+            m_prevState = m_curState;
+            m_prevResponseMode = m_curResponseMode;
+            m_curResponseMode = GameState.Get().GetResponseMode();
+
+            // Proper states
+            if (!m_playerTurn)
+            {
+                m_curState = AccessibleGameState.OPPONENT_TURN;
+                m_sendingAllMinionsToFace = false;
+                m_sendingMinionToFace = false;
+            }
+            else if (m_sendingAllMinionsToFace)
+            {
+                m_curState = AccessibleGameState.ALL_MINIONS_TO_FACE;
+            }
+            else if (m_sendingMinionToFace)
+            {
+                m_curState = AccessibleGameState.MINION_TO_FACE;
+            }
+            else if (m_tradingCard)
+            {
+                m_curState = AccessibleGameState.TRADING_CARD;
+            }
+            else if (m_confirmingEndTurn)
+            {
+                m_curState = AccessibleGameState.CONFIRMING_END_TURN;
+            }
+            else if (AccessibleHistoryMgr.Get().IsReadingHistory())
+            {
+                m_curState = AccessibleGameState.BROWSING_HISTORY;
+            }
+            else if (m_heldCard != null)
+            {
+                if (m_heldCard.GetEntity().IsMinion())
+                {
+                    m_curState = AccessibleGameState.SUMMONING_MINION;
+                }
+                else if (GameState.Get().IsInMainOptionMode())
+                {
+                    m_curState = AccessibleGameState.PLAYING_CARD;
+                }
+            }
+            else if (GameState.Get().IsInMainOptionMode())
+            {
+                m_curState = AccessibleGameState.MAIN_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInSubOptionMode())
+            {
+                m_curState = AccessibleGameState.SUB_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                if (IsTargetChoice() || ChoiceCardMgr.Get().IsShowingFriendlyCards())
+                {
+                    m_curState = AccessibleGameState.CHOICE_MODE;
+                }
+                else
+                {
+                    m_curState = AccessibleGameState.CHOICE_MODE_CHOICES_HIDDEN;
+                }
+            }
+            else if (GameState.Get().IsInTargetMode()||m_curResponseMode==GameState.ResponseMode.OPTION_TARGET)
+            {
+                m_curState = AccessibleGameState.TARGET_MODE;
+            }
+            else
+            {
+                // Normally happens in between turns (i.e. after button press but before response) due to network time
+                m_curState = AccessibleGameState.UNKNOWN;
+            }
+
+            if (m_curState != AccessibleGameState.BROWSING_HISTORY)
+            {
+                // Reset history in case turn ends while we're reading history or something
+                AccessibleHistoryMgr.Get().StopReadingHistory();
+            }
+        }
+
+        protected void ResetChoiceCardsIfNecessary()
+        {
+            if (m_prevState != m_curState && (m_prevState == AccessibleGameState.CHOICE_MODE || m_prevState == AccessibleGameState.SUB_OPTION_MODE))
+            {
+                if (!ChoiceCardMgr.Get()?.IsFriendlyShown() ?? false)
+                {
+                    // Potential race condition when multiple choices happen in a game
+                    m_accessibleChoiceCards = null;
+                }
+            }
+        }
+
+        protected void UpdateCardBeingReadState()
+        {
+            if (m_cardBeingRead == null || m_curZone == null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead.GetCard().GetZone() != m_curZone)
+            {
+                StopReadingCard();
+            }
+        }
+
+        protected void StopReadingCard(bool hideMouse = true)
+        {
+            m_cardBeingRead = null;
+            m_curZone = null;
+
+            if (hideMouse)
+            {
+                HideMouse();
+            }
+        }
+
+        protected void HandleZoneSelection(bool minionsAndHeroesOnly = false)
+        {
+            if (AccessibleKey.SEE_PLAYER_HAND.IsPressed() && !minionsAndHeroesOnly)
+            {
+                SeePlayerHand();
+            }
+            else if (IsSeePlayerSecretsPressed() && !minionsAndHeroesOnly)
+            {
+                SeePlayerSecrets();
+            }
+            else if (IsSeeOpponentSecretsPressed() && !minionsAndHeroesOnly)
+            {
+                SeeOpponentSecrets();
+            }
+            else if (AccessibleKey.SEE_PLAYER_MINIONS.IsPressed())
+            {
+                SeePlayerMinions();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_MINIONS.IsPressed())
+            {
+                SeeOpponentMinions();
+            }
+            else if (IsSeeOpponentHeroPressed())
+            {
+                SeeOpponentHero();
+            }
+            else if (AccessibleKey.SEE_PLAYER_HERO.IsPressed())
+            {
+                SeePlayerHero();
+            }
+            else if (IsSeePlayerHeroPowerPressed())
+            {
+                SeePlayerHeroPower();
+            }
+            else if (IsSeeOpponentHeroPowerPressed())
+            {
+                SeeOpponentHeroPower();
+            }
+            else if (AccessibleKey.SEE_PLAYER_WEAPON.IsPressed())
+            {
+                SeePlayerWeapon();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_WEAPON.IsPressed())
+            {
+                SeeOpponentWeapon();
+            }
+        }
+
+        private bool IsSeePlayerSecretsPressed()
+        {
+            return AccessibleKey.SEE_PLAYER_SECRETS.IsPressed();
+        }
+
+        private bool IsSeeOpponentSecretsPressed()
+        {
+            return AccessibleKey.SEE_OPPONENT_SECRETS.IsPressed();
+        }
+
+        protected virtual bool IsSeeOpponentHeroPressed()
+        {
+            return AccessibleKey.SEE_OPPONENT_HERO.IsPressed();
+        }
+
+        protected virtual bool IsSeePlayerHeroPowerPressed()
+        {
+            return AccessibleKey.SEE_PLAYER_HERO_POWER.IsPressed();
+        }
+
+        protected virtual bool IsSeeOpponentHeroPowerPressed()
+        {
+            return AccessibleKey.SEE_OPPONENT_HERO_POWER.IsPressed();
+        }
+
+        private void HandleHistoryInput()
+        {
+            AccessibleHistoryMgr.Get().HandleAccessibleInput();
+        }
+
+        protected virtual void HandleCheckStatusKeys()
+        {
+            if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+            {
+            HandleReadAnomaliesKey();
+            }
+
+            if (AccessibleKey.SEE_PLAYER_MANA.IsPressed() && !m_disableManaCounters)
+            {
+                ReadPlayerResources();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_MANA.IsPressed() && !m_disableManaCounters)
+            {
+                ReadOpponentResources();
+            }
+            else if (AccessibleKey.SEE_PLAYER_DECK.IsPressed())
+            {
+                ReadPlayerDeck();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_DECK.IsPressed())
+            {
+                ReadOpponentDeck();
+            }
+            else if (AccessibleKey.SEE_OPPONENT_HAND.IsPressed())
+            {
+                ReadOpponentHand();
+            }
+        }
+
+        protected void HandleReadAnomaliesKey()
+        {
+            if (AccessibleKey.READ_ANOMALIES.IsPressed())
+            {
+                ReadAnomalies();
+            }
+        }
+
+        protected void HandleCardReadingInput()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+            if (AccessibleKey.READ_ORIGINAL_CARD_STATS.IsPressed() && m_cardBeingRead.GetCard().GetEntity().IsMinion())
+            {
+                ReadBigCard();
+            }
+            else
+            {
+                m_cardBeingRead.HandleAccessibleInput();
+            }
+        }
+
+        private void ReadBigCard()
+        {
+            ReadBigCardStats();
+
+            var bigCard = BigCard.Get();
+            if (bigCard != null && bigCard.GetCard() != null && bigCard.isActiveAndEnabled && bigCard.m_enchantmentBanner.isActiveAndEnabled)
+            {
+                // Banner (e.g. turns until this revives: 2 on BoH valeera 5)
+                var bannerText = bigCard.m_enchantmentBanner?.m_EnchantmentBannerText;
+
+                if (bannerText?.gameObject.activeInHierarchy ?? false)
+                {
+                    AccessibilityMgr.Output(this, bannerText.Text);
+                }
+            }
+            ReadCardEnchantments();
+        }
+
+        private void ReadCardEnchantments()
+        {
+            Dictionary<Tuple<string, string>, uint> enchantmentCounts = new Dictionary<Tuple<string, string>, uint>();
+            List<Tuple<string, string>> enchantmentInfos = new List<Tuple<string, string>>();
+            var enchantments = m_cardBeingRead.GetCard().GetEntity().GetDisplayedEnchantments();
+            foreach (var enchantment in enchantments)
+            {
+                var enchantmentInfo = new Tuple<string, string>(enchantment.GetName(), enchantment.GetCardTextInHand());
+                if (!enchantmentInfos.Contains(enchantmentInfo))
+                {
+                    enchantmentInfos.Add(enchantmentInfo);
+                }
+                uint count = 0;
+                enchantmentCounts.TryGetValue(enchantmentInfo, out count);
+                enchantmentCounts[enchantmentInfo] = (uint)Mathf.Max(enchantment.GetTag(GAME_TAG.SPAWN_TIME_COUNT), 1) + count;
+            }
+
+            foreach (var enchantmentInfo in enchantmentInfos)
+            {
+                AccessibilityMgr.Output(this, LocalizedText.GLOBAL_ENCHANTMENT);
+                var enchantmentCount = enchantmentCounts[enchantmentInfo];
+                var header = enchantmentCount > 1 ? GameStrings.Format("GAMEPLAY_ENCHANTMENT_MULTIPLIER_HEADER", enchantmentCount, enchantmentInfo.Item1) : enchantmentInfo.Item1;
+                AccessibilityMgr.Output(this,  header);
+                AccessibilityMgr.Output(this, enchantmentInfo.Item2);
+            }
+        }
+
+        private void ReadBigCardStats()
+        {
+            var entity = m_cardBeingRead.GetCard().GetEntity();
+
+            if (AccessibleCardUtils.HasHiddenStats(entity))
+            {
+                // e.g. BoH Valeera 06
+                return;
+            }
+
+            var atk = entity.GetEntityDef().GetATK();
+            var hp = entity.GetEntityDef().GetHealth();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.READ_CARD_ATK_HEALTH, atk, hp));
+        }
+
+        protected void SeeOpponentMinions()
+        {
+            var opponentMinions = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+
+            if (opponentMinions.GetCardCount() == 0)
+            {
+                ReadOpponentMinionsEmpty();
+            }
+            else
+            {
+                SeeZone(opponentMinions);
+            }
+        }
+
+        protected virtual void ReadOpponentMinionsEmpty()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_MINIONS_EMPTY));
+        }
+
+        protected void SeePlayerMinions()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (playerMinions.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_MINIONS_EMPTY));
+            }
+            else
+            {
+                SeeZone(playerMinions);
+            }
+        }
+
+        protected void SeePlayerSecrets()
+        {
+            var playerSecrets = GameState.Get().GetFriendlySidePlayer().GetSecretZone();
+
+            if (playerSecrets.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_SECRETS_EMPTY));
+            }
+            else
+            {
+                SeeZone(playerSecrets);
+            }
+        }
+
+        protected void SeeOpponentSecrets()
+        {
+            var opponentSecrets = GameState.Get().GetOpposingSidePlayer().GetSecretZone();
+
+            if (opponentSecrets.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_EMPTY));
+            }
+            else
+            {
+                SeeZone(opponentSecrets);
+            }
+        }
+
+
+        protected void SeeOpponentHero()
+        {
+            FocusOnCard(GameState.Get().GetOpposingSidePlayer().GetHeroCard(), false);
+        }
+
+        protected void SeePlayerHero()
+        {
+            FocusOnCard(GameState.Get().GetFriendlySidePlayer().GetHeroCard(), false);
+        }
+
+        protected void SeePlayerHeroPower()
+        {
+            var heroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard();
+            if (heroPower != null)
+            {
+                FocusOnCard(heroPower, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_HERO_POWER_EMPTY));
+            }
+        }
+
+        protected void SeeOpponentHeroPower()
+        {
+            var heroPower = GameState.Get().GetOpposingSidePlayer().GetHeroPowerCard();
+            if (heroPower != null)
+            {
+                FocusOnCard(heroPower, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_HERO_POWER_EMPTY));
+            }
+        }
+
+        protected virtual void SeePlayerWeapon()
+        {
+            var weapon = GameState.Get().GetFriendlySidePlayer().GetWeaponCard();
+            if (weapon != null)
+            {
+                FocusOnCard(weapon, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_WEAPON_EMPTY));
+            }
+        }
+
+        protected virtual void SeeOpponentWeapon()
+        {
+            var weapon = GameState.Get().GetOpposingSidePlayer().GetWeaponCard();
+            if (weapon != null)
+            {
+                FocusOnCard(weapon, false);
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_OPPONENT_WEAPON_EMPTY));
+            }
+        }
+
+        private void ClickCard(bool tradingCard = false)
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+            if (tradingCard)
+            {
+                m_tradingCardWaitingForHold = true;
+            }
+
+            if(m_cardBeingRead.GetCard()!=InputManager.Get().GetMousedOverCard()) {
+                AccessibilityMgr.Output(null,LocalizationUtils.Get(LocalizationKey.GAMEPLAY_TRY_AGAIN));
+                InputManager.Get().SetMousedOverCard(m_cardBeingRead.GetCard());
+            }
+
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+        internal virtual void ReadPlayerResources()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int availableMana = player.GetNumAvailableResources();
+            int totalMana = player.GetTag(GAME_TAG.RESOURCES);
+
+            if (availableMana != totalMana)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_MANA_CURRENT_AND_TOTAL, availableMana, totalMana));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_MANA, availableMana));
+            }
+
+            // Overloaded crystals this turn
+            var overloadedMana = player.GetTag(GAME_TAG.OVERLOAD_OWED);
+            if (overloadedMana > 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_OVERLOADED_MANA, overloadedMana));
+            }
+
+            // Locked crystals due to overload last turn
+            var lockedMana = player.GetTag(GAME_TAG.OVERLOAD_LOCKED);
+            if (lockedMana > 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_LOCKED_MANA, lockedMana));
+            }
+            // Death knight corpses
+            if (CorpseCounter.ShouldShowCorpseCounter(player) && !m_disableCorpseCounters)
+            {
+                var corpses = player.GetNumAvailableCorpses();
+                if (corpses == 0)
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_READ_CORPSES_EMPTY));
+                }
+                else
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_CORPSES, corpses));
+                }
+            }
+        }
+
+        internal virtual void ReadOpponentResources()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            int availableMana = opponent.GetNumAvailableResources();
+            int totalMana = opponent.GetTag(GAME_TAG.RESOURCES);
+            if (availableMana != totalMana)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_MANA_CURRENT_AND_TOTAL, availableMana, totalMana));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_MANA, availableMana));
+            }
+
+
+            // Overloaded crystals this turn
+            var overloadedMana = opponent.GetTag(GAME_TAG.OVERLOAD_OWED);
+            if (overloadedMana > 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_OVERLOADED_MANA, overloadedMana));
+            }
+            // Death knight corpses
+            if (CorpseCounter.ShouldShowCorpseCounter(opponent) && !m_disableCorpseCounters)
+            {
+                var corpses = opponent.GetNumAvailableCorpses();
+                if (corpses == 0)
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_READ_CORPSES_EMPTY));
+                }
+                else
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_CORPSES, corpses));
+                }
+            }
+        }
+
+        internal void ReadAnomalies(bool addToHistory = false)
+        {
+            var anomalyIds = MulliganManager.GetAnomalies();
+            if (anomalyIds.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_NO_ANOMELIES));
+                return;
+            }
+
+            foreach (var anomalyId in anomalyIds.Select((entityId) => GameUtils.TranslateCardIdToDbId(GameState.Get().GetEntity(entityId).GetCardId())))
+            {
+                string text = AccessibleCardUtils.GetAnomalyText(anomalyId);
+                AccessibilityMgr.Output(this, text);
+                if (addToHistory)
+                {
+                    AccessibleHistoryMgr.Get().AddEntry(text);
+                }
+            }
+        }
+
+        protected void HandleZoneInput()
+        {
+            if (m_curZone == null)
+            {
+                return;
+            }
+
+            int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+            if (numKeyPressed.HasValue)
+            {
+                ReadCardInZone(numKeyPressed.Value);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                int curPos = GetCardBeingReadPosition();
+                ReadCardInZone(curPos + 1);
+            }
+            else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                int curPos = GetCardBeingReadPosition();
+                ReadCardInZone(curPos - 1);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+            {
+                ReadCardInZone(1);
+            }
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+            {
+                ReadCardInZone(m_curZone.GetCardCount());
+            }
+        }
+
+        protected void HandleValidOptionsSelectionInput()
+        {
+            if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                FindNextValidCard();
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                FindNextValidCard(true);
+            }
+        }
+
+        private void FindNextValidCard(bool reverseDirection = false)
+        {
+            List<Card> candidates = GetCandidateOptions();
+            List<Card> validOptions = GetValidOptions(candidates);
+
+            if (validOptions.Count == 0)
+            {
+                OnNoValidPlays();
+                return;
+            }
+            else if (validOptions.Count == 1)
+            {
+                // The old interface read "no more valid options" instead of reading the focused card again when this happened
+                // However, quite a few players found it confusing and often mistakenly ended their turn as "no more valid options" is quite similar to "no valid plays"
+                FocusOnCard(validOptions[0], true);
+            }
+
+            if (GameState.Get().IsInTargetMode() && m_cardBeingRead?.GetCard() == GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard())
+            {
+                m_cardBeingRead = null;
+            }
+
+            if (m_cardBeingRead == null)
+            {
+                if (reverseDirection)
+                {
+                    FocusOnCard(validOptions[validOptions.Count - 1], false);
+                    return;
+                }
+                else
+                {
+                    FocusOnCard(validOptions[0], false);
+                    return;
+                }
+            }
+
+            int curCardIndex = 0;
+            for (int i = 0; i < candidates.Count; i++)
+            {
+                if (candidates[i] == m_cardBeingRead.GetCard())
+                {
+                    curCardIndex = i;
+                }
+            }
+
+            int inc = reverseDirection ? -1 : 1;
+
+            for (int toRead = candidates.Count - 1, i = curCardIndex + inc; toRead > 0; toRead--, i += inc)
+            {
+                if (i < 0)
+                {
+                    i = candidates.Count - 1;
+                }
+                else if (i >= candidates.Count)
+                {
+                    i = 0;
+                }
+
+                var card = candidates[i];
+
+                if (IsValidOption(card))
+                {
+                    FocusOnCard(card, false);
+                    return;
+                }
+            }
+        }
+
+        private List<Card> GetValidOptions(List<Card> candidates)
+        {
+            var ret = new List<Card>();
+
+            foreach (var card in candidates)
+            {
+                if (IsValidOption(card))
+                {
+                    ret.Add(card);
+                }
+            }
+
+            return ret;
+        }
+
+        private List<Card> GetCandidateOptions()
+        {
+            var cycleFriendlyEntitiesFirst = true;
+
+            if (GameState.Get().IsInTargetMode())
+            {
+                var source = GameState.Get().GetSelectedNetworkOption();
+                var sourceEntity = GameState.Get().GetEntity(source.Main.ID);
+
+                if (CardEffectInterpreter.GetEffect(sourceEntity.GetCardId()) == CardEffectInterpreter.CardEffect.UNFRIENDLY)
+                {
+                    cycleFriendlyEntitiesFirst = false;
+                }
+            }
+
+            var ret = new List<Card>();
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var playerWeapon = player.GetWeaponCard();
+            var playerHero = player.GetHeroCard();
+            var playerHeroPower = player.GetHeroPowerCard();
+            var opponentWeapon = opponent.GetWeaponCard();
+            var opponentHero = opponent.GetHeroCard();
+            var opponentHeroPower = opponent.GetHeroPowerCard();
+
+            var playerEntities = new List<Card>();
+            var opponentEntities = new List<Card>();
+
+            playerEntities.AddRange(player.GetHandZone().GetCards());
+            if (playerWeapon != null) playerEntities.Add(playerWeapon);
+            if (playerHero != null) playerEntities.Add(playerHero);
+            if (playerHeroPower != null) playerEntities.Add(playerHeroPower);
+            playerEntities.AddRange(player.GetBattlefieldZone().GetCards());
+
+            opponentEntities.AddRange(opponent.GetBattlefieldZone().GetCards());
+            if (opponentHero != null) opponentEntities.Add(opponentHero);
+            if (opponentWeapon != null) opponentEntities.Add(opponentWeapon);
+            if (opponentHeroPower != null) opponentEntities.Add(opponentHeroPower);
+
+            if (cycleFriendlyEntitiesFirst)
+            {
+                ret.AddRange(playerEntities);
+                ret.AddRange(opponentEntities);
+            }
+            else
+            {
+                ret.AddRange(opponentEntities);
+                ret.AddRange(playerEntities);
+            }
+
+
+            return ret;
+        }
+
+        private bool IsValidOption(Card card)
+        {
+            if (card == null)
+            {
+                return false;
+            }
+
+            Entity entity = card.GetEntity();
+
+            if (GameState.Get().IsInMainOptionMode())
+            {
+                return GameState.Get().IsValidOption(entity);
+            }
+            else if (GameState.Get().IsInSubOptionMode())
+            {
+                return GameState.Get().IsValidSubOption(entity);
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                return GameState.Get().IsChoice(entity);
+            }
+            else if (GameState.Get().IsInTargetMode())
+            {
+                return GameState.Get().IsValidOptionTarget(entity, true);
+            }
+
+            return false;
+        }
+
+        private int GetCardBeingReadPosition()
+        {
+            for (int i = 1; i <= m_curZone.GetCardCount(); i++)
+            {
+                if (m_curZone.GetCardAtSlot(i) == m_cardBeingRead.GetCard())
+                {
+                    return i;
+                }
+            }
+
+            return 0;
+        }
+
+        private void ReadCardInZone(int pos)
+        {
+            Card card = m_curZone.GetCardAtSlot(pos);
+
+            if (card != null)
+            {
+                FocusOnCard(card, false);
+            }
+        }
+
+        protected void FocusOnCard(Card card, bool forceZoneRead)
+        {
+            SetCardBeingRead(card, forceZoneRead);
+
+            var speech = m_cardBeingRead.GetLine(0);
+
+            var zonePos = card.GetZone().FindCardPos(card); // card.GetZonePosition() isn't trustworthy. Wasn't working for secrets
+
+            if (ShouldReadCardAsList(card))
+            {
+                AccessibilityMgr.Output(this, AccessibleSpeech.MENU_OPTION(speech, zonePos, card.GetZone().GetCardCount()));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, speech);
+            }
+            MoveMouseToCard(card);
+            OnCardSelected(card, m_cardBeingRead);
+        }
+
+        protected bool ShouldReadCardAsList(Card card)
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var cardZone = card.GetZone();
+
+            return cardZone == player.GetHandZone() ||
+                cardZone == opponent.GetHandZone() ||
+                cardZone == player.GetBattlefieldZone() ||
+                cardZone == opponent.GetBattlefieldZone() ||
+                cardZone == player.GetSecretZone() ||
+                cardZone == opponent.GetSecretZone();
+        }
+
+        protected virtual void MoveMouseToCard(Card card)
+        {
+            if (card.GetZone()?.GetType() == typeof(ZoneHand))
+            {
+                if (!card.IsMousedOver())
+                {
+                    // Note: All of this code was added to trace a rare edge case some players have fallen into with cards such as shadowstep.
+                    // I haven't been able to reproduce so far but I think the bug has something to do with a NPE somewhere in the actor/manaObject chain
+                    // TODO: Clean all of this up once the bug is detected/fixed
+                    try
+                    {
+                        AccessibleInputMgr.MoveMouseTo(card.GetActor().m_manaObject.transform);
+                    }
+                    catch (Exception e)
+                    {
+                        AccessibilityUtils.LogFatalError(e);
+                        AccessibilityUtils.LogFatalError($"card.GetActor(): {card.GetActor()}");
+                        AccessibilityUtils.LogFatalError($"card.GetActor()?.m_manaObject: {card.GetActor()?.m_manaObject}");
+                        AccessibilityUtils.LogFatalError($"card.GetActor()?.m_manaObject?.transform: {card.GetActor()?.m_manaObject?.transform}");
+                        AccessibilityUtils.LogFatalError($"card.GetEntity()?.GetCardId(): {card.GetEntity()?.GetCardId()}");
+
+                        if (card.GetActor() != null)
+                        {
+                            if (card.GetActor().m_attackObject?.transform != null) AccessibleInputMgr.MoveMouseTo(card.GetActor().m_attackObject.transform);
+                            else if (card.GetActor().m_healthObject?.transform != null) AccessibleInputMgr.MoveMouseTo(card.GetActor().m_healthObject.transform);
+                            else AccessibilityUtils.LogFatalError("Unable to recover - Aborting MoveMouseToCard");
+                        }
+                    }
+                }
+            }
+            else
+            {
+                AccessibleInputMgr.MoveMouseTo(card);
+            }
+        }
+
+        private void MoveMouseToZone(Zone zone)
+        {
+            Vector3 zoneCenter = zone.GetComponent<Collider>().bounds.center;
+            AccessibleInputMgr.MoveMouseToWorldPosition(zoneCenter);
+        }
+
+        protected void MoveMouseToRightOfZone(Zone zone)
+        {
+            var bounds = zone.GetComponent<Collider>().bounds;
+            Vector3 pos = bounds.center;
+            pos.x += bounds.extents.x;
+            AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+        }
+
+        protected void MoveMouseToLeftOfZone(Zone zone)
+        {
+            var bounds = zone.GetComponent<Collider>().bounds;
+            Vector3 pos = bounds.center;
+            pos.x -= bounds.extents.x;
+            AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+        }
+
+        private void CancelOption()
+        {
+            AccessibleInputMgr.ClickRightMouseButton();
+            HideMouse();
+        }
+
+        internal virtual void ReadOpponentHand()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+            int numCards = opponent.GetHandZone().GetCardCount();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_HAND, numCards));
+        }
+
+        internal virtual void ReadPlayerDeck()
+        {
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int numCards = player.GetDeckZone().GetCardCount();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_DECK, numCards));
+        }
+
+        internal virtual void ReadOpponentDeck()
+        {
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+            int numCards = opponent.GetDeckZone().GetCardCount();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_DECK, numCards));
+        }
+
+        internal Card GetSelectedCard()
+        {
+            return m_cardBeingRead?.GetCard();
+        }
+
+        protected void SeePlayerHand()
+        {
+            var playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+            if (playerHand.GetCardCount() == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_SEE_ZONE_PLAYER_HAND_EMPTY));
+            }
+            else
+            {
+                SeeZone(playerHand);
+            }
+        }
+
+        private void SeeZone(Zone zone)
+        {
+            if (zone == null)
+            {
+                return;
+            }
+
+            Card card = zone.GetCardAtSlot(1);
+
+            if (card != null) // Race conditions
+            {
+                FocusOnCard(card, true);
+            }
+        }
+
+        private void OnGameStart()
+        {
+            try
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+                IsInBeginningChooseOne = false;
+                m_curState = AccessibleGameState.WAITING;
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        protected void OnGameOver(TAG_PLAYSTATE playState, object userData)
+        {
+            m_curPhase = AccessibleGamePhase.GAME_OVER;
+
+            AccessibilityMgr.Output(this, GetGameOverMessage(playState));
+            SaveGameHistory();
+        }
+private void SaveGameHistory() {
+                if (AccessibleGameplayUtils.IsFindingOrPlayingBattlegrounds()) return;
+if(Options.Get().GetBool(Option.ACCESSIBILITY_SAVE_BATTLE_LOGS)) {
+    AccessibleHistoryMgr.Get().SaveToFile(DateTime.Now.ToString("yyyy-M-d H_mm")+" "+GameState.Get().GetFriendlySidePlayer().GetName()+" v "+GameState.Get().GetOpposingSidePlayer().GetName()+".txt");
+    }
+}
+        private string GetGameOverMessage(TAG_PLAYSTATE playState)
+        {
+            switch (playState)
+            {
+                case TAG_PLAYSTATE.WON:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_WON);
+                case TAG_PLAYSTATE.LOST:
+                case TAG_PLAYSTATE.CONCEDED:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_LOST);
+                case TAG_PLAYSTATE.TIED:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_TIED);
+                default:
+                    return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_GENERIC);
+            }
+        }
+
+        public void OnRevealDrawnOpponentCard(Card card)
+        {
+        }
+
+        public void OnDrawUnknownOpponentCard(Card card)
+        {
+        }
+
+        public void OnCardToDeck(Card card)
+        {
+        }
+
+        public void OnShowBigCard(HistoryCard card)
+        {
+            try
+            {
+                AccessibilityUtils.LogDebug($"Card played: {card.GetEntity().GetName()} / type = {card.m_historyInfoType}");
+
+                if (card.m_historyInfoType == HistoryInfoType.CARD_PLAYED)
+                {
+                    OnCardPlayed(card.OriginTaskList, card.GetEntity());
+                }
+                else if (card.m_historyInfoType == HistoryInfoType.TRIGGER)
+                {
+                    OnCardTriggered(card.OriginTaskList, card.GetEntity());
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void OnCardTriggered(PowerTaskList taskList, Entity card)
+        {
+            AccessiblePlayDescriber.Get().OnBigCardTriggered(taskList, card);
+        }
+
+        private void OnCardPlayed(PowerTaskList taskList, Entity card)
+        {
+            AccessiblePlayDescriber.Get().OnBigCardPlayed(taskList, card);
+        }
+
+        public void OnChoice(List<Card> cards, Banner choiceBanner, NormalButton confirmChoiceButton)
+        {
+            // Clear up any previous choices
+            m_accessibleChoiceCards = null;
+            StopReadingCard();
+
+            try
+            {
+                var accessibleCards = new List<AccessibleCard>(cards.Count);
+                cards.ForEach(c => accessibleCards.Add(AccessibleCard.CreateCard(this, c)));
+
+                m_accessibleChoiceCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+                AccessibilityMgr.Output(this, choiceBanner.m_headline.Text);
+                m_curPhase = AccessibleGamePhase.PLAYING;
+                IsInBeginningChooseOne = true;
+                m_accessibleChoiceCards.StartReading();
+                AccessibleHistoryMgr.Get().AddEntry(choiceBanner.m_headline.Text+": "+AccessibleSpeechUtils.GetNames(cards));
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnSubOption(List<Card> cards)
+        {
+            // Clear up any previous choices
+            m_accessibleChoiceCards = null;
+            StopReadingCard();
+
+            try
+            {
+                var accessibleCards = new List<AccessibleCard>(cards.Count);
+                cards.ForEach(c => accessibleCards.Add(AccessibleCard.CreateCard(this, c)));
+
+                m_accessibleChoiceCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOOSE_ONE));
+                m_accessibleChoiceCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnMulliganChoiceStart(List<Card> startingCards, NormalButton mulliganConfirmButton)
+        {
+            try
+            {
+                m_mulliganConfirmButton = mulliganConfirmButton;
+
+                var accessibleCards = new List<AccessibleCard>(startingCards.Count);
+                startingCards.ForEach(c => accessibleCards.Add(AccessibleCard.CreateCard(this, c)));
+
+                m_accessibleMulliganCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+                m_mulliganMarkedForReplacement = new Dictionary<AccessibleCard, bool>();
+                accessibleCards.ForEach(c => m_mulliganMarkedForReplacement.Add(c, false));
+
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN));
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_KEEP_OR_REPLACE_CARDS));
+                m_accessibleMulliganCards.StartReading();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        #region Help
+        public virtual string GetHelp()
+        {
+            switch (m_curPhase)
+            {
+                case AccessibleGamePhase.WAITING_FOR_GAME_TO_START:
+                    return GetWaitingForGameToStartHelp();
+                case AccessibleGamePhase.MULLIGAN:
+                    return GetMulliganHelp();
+                case AccessibleGamePhase.WAITING_FOR_OPPONENT_MULLIGAN:
+                    return GetWaitingForOpponentHelp();
+                case AccessibleGamePhase.PLAYING:
+                    return GetPlayingHelp();
+                case AccessibleGamePhase.GAME_OVER:
+                    return GetGameOverHelp();
+                default:
+                    return "";
+            }
+        }
+
+        private string GetGameOverHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_GENERIC);
+        }
+
+        protected virtual string GetPlayingHelp()
+        {
+            if (EmoteHandler.Get()?.AreEmotesActive() ?? false)
+            {
+                return m_accessibleEmotes?.GetHelp();
+            }
+            else if (EnemyEmoteHandler.Get()?.AreEmotesActive() ?? false)
+            {
+                return m_accessibleEnemyEmotes?.GetHelp();
+            }
+
+            switch (m_curState)
+            {
+                case AccessibleGameState.OPPONENT_TURN:
+                    return GetOpponentTurnHelp();
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    return GetMainOptionModeHelp();
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    return GetSubOptionModeHelp();
+                case AccessibleGameState.TARGET_MODE:
+                    return GetTargetModeHelp();
+                case AccessibleGameState.CHOICE_MODE:
+                    return GetChoiceModeHelp();
+                    case AccessibleGameState.CHOICE_MODE_CHOICES_HIDDEN:
+                    return GetHiddenChoiceHelp();
+                case AccessibleGameState.SUMMONING_MINION:
+                    return GetSummoningMinionHelp();
+                case AccessibleGameState.PLAYING_CARD:
+                    return GetPlayingCardHelp();
+                case AccessibleGameState.CONFIRMING_END_TURN:
+                    return GetConfirmingEndTurnHelp();
+                case AccessibleGameState.BROWSING_HISTORY:
+                    return GetBrowsingHistoryHelp();
+                case AccessibleGameState.TRADING_CARD:
+                    return GetTradingCardHelp();
+                default:
+                    return "";
+            }
+        }
+
+        private string GetWaitingForOpponentHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_WAITING_FOR_OPPONENT);
+        }
+
+        protected virtual string GetMulliganHelp()
+        {
+            return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_MULLIGAN_HELP, AccessibleKey.MULLIGAN_MARK_CARD, AccessibleKey.CONFIRM);
+        }
+
+        private string GetWaitingForGameToStartHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_HELP_WAITING_FOR_GAME_TO_START);
+        }
+
+        private string GetBrowsingHistoryHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_READ_HISTORY_HELP);
+        }
+
+        private string GetConfirmingEndTurnHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CONFIRM_END_TURN_HELP);
+        }
+
+        private string GetPlayingCardHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_PLAY_CARD_HELP);
+        }
+
+        private string GetTradingCardHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.TUTORIAL_HOGGER_2_5);
+        }
+
+        private string GetSummoningMinionHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_SUMMON_MINION_HELP);
+        }
+
+        private string GetChoiceModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOICE_MODE_HELP);
+        }
+
+        private string GetHiddenChoiceHelp()
+        {
+            return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_HIDDEN_CHOICE_HELP, AccessibleKey.READ_NEXT_VALID_ITEM);
+        }
+
+        private string GetTargetModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOOSE_TARGET_HELP);
+        }
+
+        private string GetSubOptionModeHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_CHOICE_MODE_HELP);
+        }
+
+        protected virtual string GetMainOptionModeHelp()
+        {
+            if (m_cardBeingRead != null)
+            {
+                return NarrateMainOptionWhenCardBeingRead();
+            }
+            else
+            {
+                return NarrateMainOption();
+            }
+        }
+
+        private string NarrateMainOption()
+        {
+            var speeches = GetMainOptionSpeeches(false);
+
+            return GetOrNarrateHelpSpeeches(speeches);
+        }
+
+        private List<HSASpeech> GetMainOptionSpeeches(bool hasReadEndTurn, bool readManaFirst = false)
+        {
+            var playerHasValidOptions = PlayerHasValidOptions();
+
+            var speeches = new List<HSASpeech>();
+
+            if (!hasReadEndTurn && !playerHasValidOptions)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+            }
+
+            if (readManaFirst)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_MANA_HELP);
+            }
+
+            if (PlayerHasValidOptions())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_VALID_OPTIONS);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetHandZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HAND_HELP);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_MINIONS_HELP);
+            }
+
+            if (GameState.Get().GetFriendlySidePlayer().GetSecretZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_SECRETS_HELP);
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_PLAYER_HERO_HELP);
+
+            if (GameState.Get().GetFriendlySidePlayer().GetHeroPower() != null)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_HERO_POWER_HELP);
+            }
+
+            if (GameState.Get().GetOpposingSidePlayer().GetHeroPower() != null)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP);
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_HERO_HELP);
+
+            if (GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCardCount() > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP);
+            }
+
+            // Counts
+            if (!IsPlayingTutorial())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_PLAYER_DECK_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_DECK_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_HAND_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP);
+            }
+
+            if (!readManaFirst)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_PLAYER_MANA_HELP);
+            }
+
+            if (!IsPlayingTutorial())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_OPPONENT_MANA_HELP);
+                speeches.Add(AccessibleSpeech.GAMEPLAY_OPEN_HISTORY_LOG_HELP);
+            }
+
+            return speeches;
+        }
+
+        private bool IsPlayingTutorial()
+        {
+            var gameEntity = GameState.Get().GetGameEntity();
+
+            return gameEntity.GetType().IsSubclassOf(typeof(TutorialEntity));
+        }
+
+        private bool PlayerHasValidOptions()
+        {
+            var candidates = GetCandidateOptions();
+            return GetValidOptions(candidates).Count > 0;
+        }
+
+        private string NarrateMainOptionWhenCardBeingRead()
+        {
+            var card = m_cardBeingRead.GetCard();
+            var playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+            var playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var playerHero = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+            var playerHeroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPowerCard();
+
+            var speeches = new List<HSASpeech>();
+
+            var hasReadEndTurn = false;
+
+            if (!PlayerHasValidOptions())
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_END_TURN_HELP);
+                hasReadEndTurn = true;
+            }
+
+            speeches.Add(AccessibleSpeech.GAMEPLAY_READ_CARD_HELP);
+
+            if (TooltipPanelManager.Get()?.GetTooltipPanels()?.Count > 0 || TutorialKeywordManager.Get()?.GetPanels()?.Count > 0)
+            {
+                speeches.Add(AccessibleSpeech.GAMEPLAY_READ_CARD_TOOLTIP_HELP);
+            }
+
+            var readManaFirst = false;
+
+            if (IsValidOption(card))
+            {
+                if (card.GetZone() == playerHand)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_PLAY_CARD_HELP);
+
+                    if (card.GetEntity().IsTradeable())
+                    {
+                        speeches.Add(AccessibleSpeech.GAMEPLAY_TRADE_CARD_HELP);
+                    }
+                }
+                else if (card.GetZone() == playerBattlefield)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_ATTACK_WITH_MINION_HELP);
+                }
+                else if (card == playerHero)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_ATTACK_WITH_HERO_HELP);
+                }
+                else if (card == playerHeroPower)
+                {
+                    speeches.Add(AccessibleSpeech.GAMEPLAY_USE_HERO_POWER_HELP);
+                }
+            }
+            else
+            {
+                if (card.GetZone() == playerHand)
+                {
+                    readManaFirst = true;
+                }
+            }
+
+            speeches.AddRange(GetMainOptionSpeeches(hasReadEndTurn, readManaFirst));
+
+            return GetOrNarrateHelpSpeeches(speeches);
+        }
+
+        protected virtual string GetOpponentTurnHelp()
+        {
+            return GetOrNarrateHelpSpeech(AccessibleSpeech.GAMEPLAY_OPPONENT_TURN_VOICE);
+        }
+
+        private string GetOrNarrateHelpSpeech(HSASpeech speech)
+        {
+            return speech.GetLocalizedText();
+        }
+
+        private string GetOrNarrateHelpSpeeches(List<HSASpeech> speeches)
+        {
+            var lines = new List<string>(speeches.Count);
+            speeches.ForEach(s => lines.Add(s.GetLocalizedText()));
+
+            return AccessibleSpeechUtils.CombineLines(lines);
+        }
+
+        #endregion Help
+
+        public void OnGainedFocus()
+        {
+            // TODO: Think about this but we probably don't want to say anything given that no one will forget they're playing a game
+        }
+
+        #region Tutorial stuff
+        private Dictionary<Zone, Action> m_zoneSelectedListeners = new Dictionary<Zone, Action>();
+        private Dictionary<Card, Action<AccessibleCard>> m_cardSelectedListeners = new Dictionary<Card, Action<AccessibleCard>>();
+        private Dictionary<Card, Action> m_summoningMinionListeners = new Dictionary<Card, Action>();
+
+        private void OnZoneSelected(Zone zone)
+        {
+            if (m_zoneSelectedListeners.ContainsKey(zone))
+            {
+                m_zoneSelectedListeners[zone]();
+                m_zoneSelectedListeners.Remove(zone);
+            }
+        }
+
+        private void OnCardSelected(Card card, AccessibleCard accessibleCard)
+        {
+            OnZoneSelected(card.GetZone());
+
+            if (m_cardSelectedListeners.ContainsKey(card))
+            {
+                m_cardSelectedListeners[card](accessibleCard);
+                m_cardSelectedListeners.Remove(card);
+            }
+        }
+
+        private void OnSummoningMinion(Card card)
+        {
+            if (m_summoningMinionListeners.ContainsKey(card))
+            {
+                m_summoningMinionListeners[card]();
+                m_summoningMinionListeners.Remove(card);
+            }
+        }
+
+        internal void RegisterZoneSelectedListener(Zone zone, Action action)
+        {
+            m_zoneSelectedListeners[zone] = action;
+        }
+
+        internal void RegisterCardSelectedListener(Card card, Action<AccessibleCard> action)
+        {
+            m_cardSelectedListeners[card] = action;
+        }
+
+        internal void RegisterSummoningCardListener(Card card, Action action)
+        {
+            m_summoningMinionListeners[card] = action;
+        }
+
+        private Action m_noValidPlaysListener;
+
+        internal void RegisterNoValidPlaysListener(Action action)
+        {
+            m_noValidPlaysListener = action;
+        }
+
+        private void OnNoValidPlays()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_NO_VALID_PLAYS));
+            StopReadingCard();
+
+            if (m_noValidPlaysListener != null)
+            {
+                m_noValidPlaysListener();
+                m_noValidPlaysListener = null;
+            }
+        }
+
+        private bool m_stopHidingMouse;
+
+        // Useful for e.g. pack opening in the tutorial
+        internal void StopHidingMouse()
+        {
+            m_stopHidingMouse = true;
+        }
+
+        internal void StartHidingMouse()
+        {
+            m_stopHidingMouse = true;
+        }
+        #endregion
+
+        #region Emotes
+        private AccessibleMenu m_accessibleEmotes;
+        private AccessibleMenu m_accessibleEnemyEmotes;
+
+        internal void OnEmotesShown(List<EmoteOption> availableEmotes)
+        {
+            m_accessibleEmotes = new AccessibleMenu(this, "", EmoteHandler.Get().HideEmotes, false, true);
+
+            foreach (var emote in availableEmotes)
+            {
+                m_accessibleEmotes.AddOption(emote.m_Text.Text, emote.DoClick);
+            }
+
+            m_accessibleEmotes.StartReading();
+        }
+
+        internal void OnEnemyEmotesShown(string curSquelchText)
+        {
+            m_accessibleEnemyEmotes = new AccessibleMenu(this, "", EnemyEmoteHandler.Get().HideEmotes, false, true);
+
+            m_accessibleEnemyEmotes.AddOption(curSquelchText, () => EnemyEmoteHandler.Get().DoSquelchClick());
+
+            m_accessibleEnemyEmotes.StartReading();
+        }
+
+        private bool HandleEmotes()
+        {
+            if (EmoteHandler.Get()?.AreEmotesActive() ?? false)
+            {
+                m_accessibleEmotes?.HandleAccessibleInput();
+                return true;
+            }
+            else if (EnemyEmoteHandler.Get()?.AreEmotesActive() ?? false)
+            {
+                m_accessibleEnemyEmotes?.HandleAccessibleInput();
+                return true;
+            }
+            else if (AccessibleKey.SPACE.IsPressed())
+            {
+                if (m_cardBeingRead == null)
+                {
+                    return false;
+                }
+
+                if (GameMgr.Get().IsSpectator())
+                {
+                    return false;
+                }
+
+                var entity = m_cardBeingRead.GetCard().GetEntity();
+
+                if (!entity.IsHero() || entity.GetZone() != TAG_ZONE.PLAY)
+                {
+                    return false;
+                }
+
+                if (entity.IsControlledByFriendlySidePlayer())
+                {
+                    EmoteHandler.Get()?.ShowEmotes();
+                    return true;
+                }
+                else
+                {
+                    EnemyEmoteHandler.Get()?.ShowEmotes();
+                    return true;
+                }
+            }
+
+            return false;
+        }
+        #endregion
+
+        #region Battlegrounds-only
+
+        internal virtual void OnBattlegroundsCombatPhasePopupShown()
+        {
+            // No-op
+        }
+
+        internal virtual void OnBattlegroundsShopPhasePopupShown()
+        {
+            // No-op
+        }
+
+        internal virtual void OnFreezeOrUnfreezeEvent()
+        {
+            // No-op
+        }
+
+        internal virtual void OnOpponentHeroChanged()
+        {
+            // No-op
+        }
+
+        internal virtual void OnAnyHeroGainedAtk()
+        {
+            // No-op
+        }
+
+        internal virtual void OnPlayerAvailableResourcesChanged(int before, int after)
+        {
+            // No-op
+        }
+
+        internal virtual void OnTurnEnded()
+        {
+            // No-op
+        }
+
+        internal virtual void OnFirstTaskListStart()
+        {
+            // No-op
+        }
+
+        internal virtual void OnMainStepEnd()
+        {
+            // No-op
+        }
+
+        internal virtual void OnEnterMultiplayerWaitingArea(List<Card> startingCards, string mulliganBannerText, string mulliganBannerSubtitleText, NormalButton confirmButton)
+        {
+            // No-op
+        }
+
+        internal virtual void OnMainActionStep()
+        {
+            // No-op
+        }
+
+        #endregion
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleGameplayUtils.cs b/Assembly-CSharp/Accessibility/AccessibleGameplayUtils.cs
new file mode 100644
index 0000000..ed56a2d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleGameplayUtils.cs
@@ -0,0 +1,79 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleGameplayUtils
+    {
+        internal static bool IsPlayingTutorial()
+        {
+            return GameState.Get().GetGameEntity() is Tutorial_MissionEntity;
+        }
+
+        internal static bool IsPlayingBattlegrounds()
+        {
+            return GameMgr.Get().IsPlayingBattlegrounds();
+        }
+
+        internal static bool IsInBattlegroundsShopPhase()
+		{
+            return IsPlayingBattlegrounds() && IsInBattlegroundsPhase(TB_BaconShop.GAME_PHASE_SHOP);
+		}
+
+        internal static bool IsInBattlegroundsCombatPhase()
+		{
+            return IsPlayingBattlegrounds() && IsInBattlegroundsPhase(TB_BaconShop.GAME_PHASE_COMBAT);
+		}
+
+        private static bool IsInBattlegroundsPhase(int phaseId)
+		{
+            var gameEntity = GameState.Get().GetGameEntity() as TB_BaconShop;
+
+            return gameEntity.GetCurPhase() == phaseId;
+		}
+
+		internal static bool IsFindingOrPlayingBattlegrounds()
+		{
+			if (GameMgr.Get().IsFindingGame())
+			{
+				return GameMgr.Get().IsPlayingBattlegrounds();
+			}
+            else
+			{
+				return IsPlayingBattlegrounds();
+			}
+		}
+
+		private static HashSet<string> s_battlegroundsSpecialCards = new HashSet<string>()
+		{
+			"TB_BaconShopTechUp02_Button", "TB_BaconShopTechUp03_Button", "TB_BaconShopTechUp04_Button", "TB_BaconShopTechUp05_Button", "TB_BaconShopTechUp06_Button",
+			"TB_BaconShopLockAll_Button", "TB_BaconShop_DragBuy", "TB_BaconShop_DragSell",
+			"TB_BaconShop_1p_Reroll_Button", "TB_BaconShop_8p_Reroll_Button", "TB_BaconShop_DragBuy_Spell", // TODO: Check if there's others
+		};
+
+		internal static bool IsBattlegroundsSpecialCard(Entity card)
+		{
+			if (card == null)
+			{
+                return false;
+			}
+
+			return s_battlegroundsSpecialCards.Contains(card.GetCardId());
+		}
+
+		internal static bool ShouldNarrateBattlegroundsAttackPhase()
+		{
+			return Options.Get().GetBool(Option.ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS);
+		}
+
+		internal static bool ToggleBattlegroundsAttackPhaseNarration()
+		{
+			var curState = ShouldNarrateBattlegroundsAttackPhase();
+			var newState = !curState;
+
+			Options.Get().SetBool(Option.ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS, newState);
+
+			return newState;
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs b/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs
new file mode 100644
index 0000000..35f43cf
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleHearthstoneApplication.cs
@@ -0,0 +1,64 @@
+﻿using System;
+using System.Net;
+
+namespace Accessibility
+{
+    static class AccessibleHearthstoneApplication
+    {
+        internal static void OnLoading()
+        {
+            AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_LOADING_GAME));
+
+            Log.Accessibility.Print($"Hearthstone version: {HearthstoneAccessConstants.HEARTHSTONE_VERSION}");
+            Log.Accessibility.Print($"Hearthstone Access version: {HearthstoneAccessConstants.HEARTHSTONE_ACCESS_VERSION}");
+
+            if (HearthstoneAccessUpdateRequired())
+            {
+                AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_NEW_HEARTHSTONE_ACCESS_VERSION_AVAILABLE));
+            }
+        }
+
+        internal static void OnClosing()
+        {
+            AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_CLOSING_GAME));
+        }
+
+        private static bool HearthstoneAccessUpdateRequired()
+        {
+            return false; // inoperable at the moment.
+            
+            try
+            {
+                var fileName = "hsa-version";
+                var hsaRepoUrl = HearthstoneAccessConstants.GetHearthstoneAccessRepoUrl();
+                var url = $"{hsaRepoUrl}/{HearthstoneAccessConstants.HEARTHSTONE_VERSION}/{fileName}";
+
+                ServicePointManager.Expect100Continue = true;
+                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;
+
+                using (WebClient wc = new WebClient())
+                {
+                    var githubToken = HearthstoneAccessConstants.GetGithubToken();
+                    if (githubToken != null)
+                    {
+                        // Dev only
+                        wc.Headers.Add("Authorization", $"token {githubToken}");
+                    }
+
+                    wc.Headers.Add(HttpRequestHeader.UserAgent, "HSA");
+
+                    var hsaVersion = wc.DownloadString(url);
+
+                    return !hsaVersion.Equals(HearthstoneAccessConstants.HEARTHSTONE_ACCESS_VERSION);
+                }
+            }
+            catch (Exception e)
+            {
+                // Not really fatal since we'll just keep going but let's log it as such in case someone runs into issues
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleHeroPickerButton.cs b/Assembly-CSharp/Accessibility/AccessibleHeroPickerButton.cs
new file mode 100644
index 0000000..2709a4d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleHeroPickerButton.cs
@@ -0,0 +1,67 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleHeroPickerButton : AccessibleItem
+    {
+        private readonly HeroPickerButton m_button;
+
+        private bool m_inCreateDeckMode;
+
+        internal AccessibleHeroPickerButton(AccessibleComponent parent, HeroPickerButton button, bool inCreateDeckMode=false) : base(parent)
+        {
+            m_button = button;
+            m_inCreateDeckMode = inCreateDeckMode;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_inCreateDeckMode)
+            {
+                return GetLinesForCreateDeckMode();
+            }
+            else
+            {
+                return GetLinesForAdventureMode();
+            }
+        }
+
+        private List<string> GetLinesForCreateDeckMode()
+        {
+            var ret = new List<string>();
+
+            var heroClass = GameStrings.GetClassName(m_button.GetEntityDef().GetClass());
+
+            if (heroClass != null && heroClass.Length > 0)
+            {
+                ret.Add(heroClass);
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForAdventureMode()
+        {
+            var ret = new List<string>();
+
+            var heroName = m_button.GetEntityDef()?.GetName();
+
+            if (heroName != null && heroName.Length > 0)
+            {
+                ret.Add(heroName);
+            }
+
+            if (m_button.m_crown.activeInHierarchy)
+            {
+                ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE));
+            }
+
+            return ret;
+        }
+
+        internal HeroPickerButton GetHeroPickerButton()
+        {
+            return m_button;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs b/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs
new file mode 100644
index 0000000..bfb9ba6
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleHistoryMgr.cs
@@ -0,0 +1,147 @@
+﻿using System;
+using System.Collections.Generic;
+using System.IO;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleHistoryMgr
+    {
+        private List<string> m_entries = new List<string>();
+
+        private int m_entryBeingReadIndex;
+
+        private bool m_readingHistory;
+
+        private static AccessibleHistoryMgr s_instance;
+
+        internal static AccessibleHistoryMgr Get()
+        {
+            if (s_instance == null)
+            {
+                s_instance = new AccessibleHistoryMgr();
+            }
+
+            return s_instance;
+        }
+
+        internal void AddEntry(string entry)
+        {
+            if (entry == null || entry.Length == 0)
+            {
+                return;
+            }
+entry=entry.Replace("\n"," ");
+            AccessibilityUtils.LogDebug($"HIST add entry: {entry}");
+            AccessibilityUtils.LogDebug(Environment.StackTrace);
+            m_entries.Add(entry);
+        }
+
+        internal void SaveToFile(string filePath) {
+            if(m_entries.Count==0) return;
+            string battleLogsPath=Application.dataPath+"../../battle logs";
+            var entries=new List<string>(m_entries);
+            for(int i=0; i<entries.Count; i++) {
+                entries[i]=AccessibilityUtils.CurateText(entries[i]);
+            }
+            try {
+                if(!(Directory.Exists(battleLogsPath))) {
+Directory.CreateDirectory(battleLogsPath);
+                }
+                File.WriteAllLines(battleLogsPath+"/"+filePath,entries.ToArray());
+            }
+            catch (Exception e) {
+AccessibilityMgr.Output(null,"An error occurred when saving your battle log. "+e.ToString()+" "+e.Message);
+            }
+        }
+
+            internal void Reset()
+        {
+            AccessibilityUtils.LogDebug("HIST Reset");
+            m_entries.Clear();
+            m_entryBeingReadIndex = -1;
+            m_readingHistory = false;
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.SEE_HISTORY.IsPressed() && !m_readingHistory)
+            {
+                StartReadingHistory();
+                return true;
+            }
+            else if (AccessibleKey.BACK.IsPressed() && m_readingHistory)
+            {
+                StopReadingHistory();
+                return true;
+            }
+            else if (m_readingHistory && AccessibleKey.READ_NEXT_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex + 1);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_PREV_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex - 1);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_CUR_LINE.IsPressed())
+            {
+                ReadEntry(m_entryBeingReadIndex);
+            }
+            else if (m_readingHistory && AccessibleKey.READ_TO_END.IsPressed())
+            {
+                ReadToEnd();
+            }
+
+            return false;
+        }
+
+        private void ReadToEnd()
+        {
+            for (int i = m_entryBeingReadIndex; i < m_entries.Count; i++)
+            {
+                ReadEntry(i);
+            }
+        }
+
+        private void StartReadingHistory()
+        {
+            if (m_entries.Count == 0)
+            {
+                AccessibilityMgr.Output(AccessibleGameplay.Get(),LocalizationUtils.Get(LocalizationKey.GAMEPLAY_HISTORY_LOG_EMPTY));
+            }
+            else
+            {
+                m_readingHistory = true;
+                ReadEntry(m_entries.Count - 1);
+            }
+        }
+
+        private void ReadEntry(int index)
+        {
+            if (index < 0 || index >= m_entries.Count)
+            {
+                return;
+            }
+
+            m_entryBeingReadIndex = index;
+
+            var curEntry = m_entries[m_entryBeingReadIndex];
+            AccessibilityMgr.Output(AccessibleGameplay.Get(), LocalizationUtils.Format(LocalizationKey.GAMEPLAY_HISTORY_LOG_ENTRY_FORMAT, m_entryBeingReadIndex + 1, m_entries.Count, curEntry));
+        }
+
+        internal bool IsReadingHistory()
+        {
+            return m_readingHistory;
+        }
+
+        internal void StopReadingHistory()
+        {
+            if (m_readingHistory)
+            {
+                AccessibilityMgr.Output(AccessibleGameplay.Get(),LocalizationUtils.Get(LocalizationKey.GAMEPLAY_HISTORY_LOG_CLOSE));
+                m_entryBeingReadIndex = -1;
+                m_readingHistory = false;
+            }
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleHorizontalMenu.cs b/Assembly-CSharp/Accessibility/AccessibleHorizontalMenu.cs
new file mode 100644
index 0000000..4d6a89d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleHorizontalMenu.cs
@@ -0,0 +1,200 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class AccessibleHorizontalMenu<T> : AccessibleElement where T : AccessibleItem
+    {
+        private class MenuOption
+        {
+            internal T m_option;
+            internal Action m_onClickAction;
+            internal Action m_onReadAction;
+
+            internal MenuOption(T option, Action onClickAction)
+            {
+                m_option = option;
+                m_onClickAction = onClickAction;
+            }
+
+            internal MenuOption(T option, Action onClickAction, Action onReadAction)
+            {
+                m_option = option;
+                m_onClickAction = onClickAction;
+                m_onReadAction = onReadAction;
+            }
+        }
+
+        private string m_menuName;
+
+        private List<MenuOption> m_options;
+
+        private int m_curOptionIdx;
+
+        private Action m_goBackAction;
+
+        private bool m_isReading;
+
+        public AccessibleHorizontalMenu(AccessibleComponent parent, string menuName, Action goBackAction) : base(parent)
+        {
+            m_menuName = menuName;
+            m_options = new List<MenuOption>();
+            m_goBackAction = goBackAction;
+        }
+
+        public void AddOption(T option, Action onClickAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction));
+        }
+
+        public void AddOption(T option, Action onClickAction, Action onReadAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction, onReadAction));
+        }
+
+        public bool HandleAccessibleInput()
+        {
+            try
+            {
+                if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+                {
+                    return ReadNextOption(1);
+                }
+                else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+                {
+                    return ReadNextOption(-1);
+                }
+                else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+				{
+                    return ReadOption(0);
+				}
+                else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+				{
+                    return ReadOption(m_options.Count - 1);
+				}
+                else if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    return SelectOption();
+                }
+                else if (AccessibleKey.BACK.IsPressed())
+                {
+                    return GoBack();
+                }
+                else if (m_isReading)
+                {
+                    m_options[m_curOptionIdx].m_option.HandleAccessibleInput();
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+
+        private bool ReadNextOption(int inc)
+        {
+            return ReadOption(m_curOptionIdx + inc);
+        }
+
+        private bool ReadOption(int optionIdx)
+        {
+            if (optionIdx < 0 || optionIdx >= m_options.Count)
+            {
+                return false;
+            }
+
+            m_curOptionIdx = optionIdx;
+            var curOption = m_options[m_curOptionIdx];
+            curOption.m_option.Reset();
+
+            var firstLine = curOption.m_option.GetLine(0);
+            var speech = AccessibleSpeech.MENU_OPTION(firstLine, m_curOptionIdx + 1, m_options.Count);
+            Output(speech);
+
+            if (curOption.m_onReadAction != null)
+            {
+                try {
+                    curOption.m_onReadAction();
+                } catch(Exception e) {
+                                    AccessibilityUtils.LogFatalError(e);
+                }
+            }
+
+            return true;
+        }
+
+        private bool SelectOption()
+        {
+            if (!m_isReading || m_options.Count == 0)
+            {
+                return false;
+            }
+            m_options[m_curOptionIdx].m_onClickAction();
+
+            return true;
+        }
+
+        private bool GoBack()
+        {
+            if (m_goBackAction == null) {
+                return false;
+            }
+
+            m_goBackAction();
+
+            return true;
+        }
+
+        public void StartReading()
+        {
+            Output(m_menuName);
+
+            if (m_options.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextOption(0);
+                m_isReading = true;
+            }
+        }
+
+        public void SetIndex(int index)
+        {
+            m_curOptionIdx = index;
+        }
+
+        public string GetHelp()
+        {
+            if (m_options.Count == 0)
+            {
+                return AccessibleSpeech.MENU_NO_ITEMS_HELP;
+            }
+            else
+            {
+                return AccessibleSpeech.MENU_HORIZONTAL_HELP(m_goBackAction != null);
+            }
+        }
+
+        public void ReadCurrentOption()
+        {
+            if (m_options.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextOption(0);
+                m_isReading = true;
+            }
+        }
+
+        public int GetNumItems()
+        {
+            return m_options.Count;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleHub.cs b/Assembly-CSharp/Accessibility/AccessibleHub.cs
new file mode 100644
index 0000000..52fc7d5
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleHub.cs
@@ -0,0 +1,296 @@
+﻿using Hearthstone.Progression;
+using PegasusShared;
+using System;
+
+namespace Accessibility
+{
+    class AccessibleHub : AccessibleScreen
+    {
+        private enum State { LOADING, MAIN_MENU, PLAY_RANKED_MENU_CHOOSE_FORMAT };
+
+        private State m_curState = State.LOADING;
+
+        private AccessibleMenu m_mainMenu;
+
+        private static AccessibleHub s_instance = new AccessibleHub();
+
+        internal static AccessibleHub Get()
+        {
+            return s_instance;
+        }
+
+        public void OnHubOpened()
+        {
+            try
+            {
+                SetupMainMenu();
+
+                AccessibilityMgr.SetScreen(this);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(this, LocalizedText.HUB_MAIN_MENU_TITLE, null);
+            var box = Box.Get();
+
+            if (box.m_PlayButton.IsEnabled())
+            {
+                if (!GameUtils.HasCompletedApprentice())
+                {
+                    m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_HEARTHSTONE), PlayCasual);
+                }
+                else
+                {
+                    m_mainMenu.AddOption(AccessibleKey.HUB_RANKED, LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_RANKED), OnPlayRanked);
+                    m_mainMenu.AddOption(AccessibleKey.HUB_CASUAL, LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_CASUAL), PlayCasual);
+                }
+            }
+
+            if (box.m_GameModesButton.IsEnabled())
+                m_mainMenu.AddOption(AccessibleKey.HUB_MODES, LocalizedText.HUB_GAME_MODES_OPTION, OnClickModes);
+            if (box.m_BattleGroundsButton.IsEnabled())
+                m_mainMenu.AddOption(AccessibleKey.HUB_BATTLEGROUNDS, LocalizedText.HUB_BATTLEGROUNDS_OPTION, OnClickBattlegrounds);
+            if (box.m_TavernBrawlButton.IsEnabled())
+                m_mainMenu.AddOption(AccessibleKey.HUB_TAVERN_BRAWL, LocalizedText.HUB_TAVERN_BRAWL_OPTION, OnClickTavernBrawl);
+            if (box.m_CollectionButton.IsEnabled())
+                m_mainMenu.AddOption(AccessibleKey.HUB_MY_COLLECTION, LocalizedText.HUB_MY_COLLECTION_OPTION, OnClickMyCollection);
+            if (box.m_OpenPacksButton.IsEnabled())
+                m_mainMenu.AddOption(AccessibleKey.HUB_OPEN_PACKS, $"{LocalizationUtils.Get(LocalizationKey.GLOBAL_OPEN_PACKS)} {Box.Get().m_OpenPacksButton.m_count.Text}", OnClickOpenPacks);
+			m_mainMenu.AddOption(AccessibleKey.HUB_JOURNAL, LocalizationUtils.Get(LocalizationKey.GLOBAL_JOURNAL), OnClickJournal);
+
+            if (AccessibilityUtils.CanSeeShop() && box.m_StoreButton.IsEnabled())
+			{
+				m_mainMenu.AddOption(AccessibleKey.HUB_SHOP, LocalizationUtils.Get(LocalizationKey.GLOBAL_SHOP), OnClickShop);
+			}
+
+			m_mainMenu.AddOption(LocalizedText.HUB_HELP_OPTION, OnClickHelp);
+            m_mainMenu.AddOption(LocalizedText.GAME_MENU_TITLE, OnClickGameMenu);
+            m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_MENU_NAME), OnClickSocialMenu);
+
+            m_curState = State.MAIN_MENU;
+        }
+
+        private void RereadMainMenu()
+		{
+            m_mainMenu?.StartReading();
+            m_curState = State.MAIN_MENU;
+		}
+
+        private void OnClickGameMenu()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.HUB_MAIN_MENU_OPTION_GAME_MENU, AccessibleKey.OPEN_GAME_MENU));
+        }
+
+        private void OnClickSocialMenu()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.HUB_MAIN_MENU_OPTION_SOCIAL_MENU, AccessibleKey.OPEN_SOCIAL_MENU));
+        }
+
+        private void OnClickHelp()
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.HUB_MAIN_MENU_OPTION_HELP, AccessibleKey.HELP, AccessibleKey.TOGGLE_ACCESSIBILITY));
+        }
+
+        private void ClickPlay()
+        {
+            Box.Get().m_PlayButton.TriggerRelease();
+        }
+
+        private void OnClickModes()
+        {
+            Box.Get().m_GameModesButton.TriggerRelease();
+        }
+
+        private void OnClickBattlegrounds()
+        {
+            Box.Get().m_BattleGroundsButton.TriggerRelease();
+        }
+
+        private void OnClickTavernBrawl()
+        {
+            if (!AccessibilityUtils.CanPlayTavernBrawl())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.HUB_TAVERN_BRAWL_INACCESSIBLE));
+                return;
+            }
+            Box.Get().m_TavernBrawlButton.TriggerRelease();
+        }
+
+        private void OnClickMyCollection()
+        {
+            Box.Get().m_CollectionButton.TriggerRelease();
+        }
+
+        private void OnClickOpenPacks()
+        {
+            var openPacksButton = Box.Get().m_OpenPacksButton;
+            if (openPacksButton.m_numPacks < 1)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_PACK_OPENING_NO_CARD_PACKS));
+            }
+            else
+            {
+                Box.Get().m_OpenPacksButton.TriggerRelease();
+            }
+        }
+
+        private void OnClickJournal()
+        {
+            AccessibleWidgetUtils.TriggerButtonClicked(Box.Get().m_journalButtonWidget);
+        }
+
+        private void OnClickShop()
+        {
+            Box.Get().m_StoreButton.TriggerRelease();
+        }
+
+        #region Ranked and Casual
+        private AccessibleMenu m_playRankedChooseFormatMenu;
+
+        private void PlayCasual()
+		{
+            if (!AccessibleRankedUtils.PlayerHasCasualDecks())
+			{
+                NotifyNeedToBuildDeckFirst();
+                return;
+			}
+
+            Options.SetInRankedPlayMode(false);
+            Options.SetFormatType(FormatType.FT_STANDARD);
+            ClickPlay();
+		}
+
+        private void OnPlayRanked()
+		{
+            if (CollectionManager.Get().ShouldAccountSeeStandardWild())
+			{
+                ReadPlayRankedChooseFormatMenu();
+			}
+            else if (AccessibleRankedUtils.PlayerHasStandardDecks())
+			{
+                PlayRankedStandard();
+			}
+            else
+			{
+                NotifyNeedToBuildDeckFirst();
+			}
+		}
+
+		private void NotifyNeedToBuildDeckFirst()
+		{
+            AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_DECK"));
+		}
+
+		private void NotifyNoStandardDeck()
+		{
+            AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_STANDARD_DECK"));
+		}
+
+		private void NotifyNoTwistDeck()
+		{
+            AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_TWIST_DECK"));
+		}
+
+		private void EnterRankedMode(FormatType format)
+		{
+            Options.SetInRankedPlayMode(true);
+            Options.SetFormatType(format);
+            ClickPlay();
+		}
+
+		private void ReadPlayRankedChooseFormatMenu()
+		{
+            m_playRankedChooseFormatMenu = new AccessibleMenu(this, "", RereadMainMenu);
+
+            m_playRankedChooseFormatMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_STANDARD), PlayRankedStandard);
+			m_playRankedChooseFormatMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_WILD), PlayRankedWild);
+            if (RankMgr.GetCurrentTwistSeason() != null)
+            {
+                m_playRankedChooseFormatMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_TWIST), PlayRankedTwist);
+            }
+
+			m_playRankedChooseFormatMenu.StartReading();
+			m_curState = State.PLAY_RANKED_MENU_CHOOSE_FORMAT;
+		}
+
+		private void PlayRankedStandard()
+		{
+            if (!AccessibleRankedUtils.PlayerHasStandardDecks())
+			{
+                NotifyNoStandardDeck();
+                return;
+			}
+
+            EnterRankedMode(FormatType.FT_STANDARD);
+		}
+
+		private void PlayRankedWild()
+		{
+            if (!AccessibleRankedUtils.PlayerCanPlayWild())
+			{
+                NotifyNeedToBuildDeckFirst();
+                return;
+			}
+
+            EnterRankedMode(FormatType.FT_WILD);
+		}
+
+		private void PlayRankedTwist()
+		{
+            if (!AccessibleRankedUtils.PlayerCanPlayTwist())
+			{
+                NotifyNoTwistDeck();
+                return;
+			}
+
+            EnterRankedMode(FormatType.FT_TWIST);
+		}
+
+		#endregion
+
+        public void HandleInput()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+				m_mainMenu?.HandleAccessibleInput();
+			}
+			else if (m_curState == State.PLAY_RANKED_MENU_CHOOSE_FORMAT)
+			{
+                m_playRankedChooseFormatMenu?.HandleAccessibleInput();
+			}
+        }
+
+		public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case State.MAIN_MENU:
+                    return m_mainMenu?.GetHelp();
+                case State.PLAY_RANKED_MENU_CHOOSE_FORMAT:
+                    return m_playRankedChooseFormatMenu?.GetHelp();
+                default:
+                    break;
+            }
+
+            return "";
+        }
+
+        public void OnGainedFocus()
+        {
+            if (m_curState == State.MAIN_MENU)
+            {
+                SetupMainMenu(); // Incase we're returning from the journal and box railroading was updated.
+                m_mainMenu?.StartReading();
+            }
+            else if (m_curState == State.PLAY_RANKED_MENU_CHOOSE_FORMAT)
+			{
+                m_playRankedChooseFormatMenu?.StartReading();
+			}
+        }
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleInGameState.cs b/Assembly-CSharp/Accessibility/AccessibleInGameState.cs
new file mode 100644
index 0000000..8a6ec1d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleInGameState.cs
@@ -0,0 +1,2332 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessibleInGameState
+    {
+        private class EntitySpeech : IEquatable<EntitySpeech>
+        {
+            public string SingularSpeech { get; private set; }
+            public string PluralSpeech { get; private set; }
+
+            public EntitySpeech(string speech)
+            {
+                SingularSpeech = PluralSpeech = speech;
+            }
+
+            public EntitySpeech(string singularSpeech, string pluralSpeech)
+            {
+                SingularSpeech = singularSpeech;
+                PluralSpeech = pluralSpeech;
+            }
+
+            public bool Equals(EntitySpeech other)
+            {
+                return SingularSpeech.Equals(other.SingularSpeech) && PluralSpeech.Equals(other.PluralSpeech);
+            }
+
+            public override bool Equals(object obj)
+            {
+                return Equals(obj as EntitySpeech);
+            }
+
+            public override int GetHashCode()
+            {
+                return SingularSpeech.GetHashCode() ^ PluralSpeech.GetHashCode();
+            }
+
+            public override string ToString()
+            {
+                return $"Singular={SingularSpeech} ; Plural={PluralSpeech}";
+            }
+        }
+
+		private class EntityDiff
+        {
+            private Entity m_before, m_after;
+
+            private bool m_died;
+            private bool m_transformed;
+            private bool m_revealed;
+            private int m_healedAmt;
+            private int m_healthDiff;
+            private int m_armorDiff;
+            private int m_atkDiff;
+            private bool m_becameInvulnerable;
+            private bool m_becameImmune;
+
+            private string m_descSingular;
+            private string m_descPlural;
+
+            internal EntityDiff(Entity before, Entity after, AccessibleInGameState gameStateBefore, AccessibleInGameState gameStateAfter)
+            {
+                m_before = before;
+                m_after = after;
+
+                m_died = HasDied(before, after);
+                m_transformed = HasTransformed(before, after);
+                m_revealed = HasRevealed(before, after);
+                m_healedAmt = Math.Abs(Math.Min(after.GetDamage() - before.GetDamage(), 0));
+                m_healthDiff = after.GetHealth() - before.GetHealth();
+                m_armorDiff = after.GetArmor() - before.GetArmor();
+                m_atkDiff = after.GetATK() - before.GetATK();
+                m_becameInvulnerable = before.CanBeAttacked() && !after.CanBeAttacked();
+                m_becameImmune = !before.IsImmune() && after.IsImmune();
+
+                InitDiffDescriptions();
+            }
+
+            private int GetDamageTaken()
+            {
+                if (m_after.IsCharacter())
+                {
+                    var afterDmg = m_after.GetDamage();
+                    var beforeDmg = m_before.GetDamage();
+
+                    var dmgTaken = 0;
+
+                    if (afterDmg > beforeDmg)
+                    {
+                        dmgTaken += afterDmg - beforeDmg;
+                    }
+
+                    return dmgTaken;
+                }
+                else if (m_after.IsWeapon())
+                {
+                    var afterDurability = m_after.GetCurrentDurability();
+                    var beforeDurability = m_before.GetCurrentDurability();
+
+                    if (afterDurability < beforeDurability)
+                    {
+                        return beforeDurability - afterDurability;
+                    }
+                }
+
+                return 0;
+            }
+
+            internal List<string> GetRawDiff()
+            {
+                var ret = new List<string>();
+
+                var beforeTags = m_before.GetTags().GetMap();
+                var afterTags = m_after.GetTags().GetMap();
+
+                foreach (var beforeEntry in beforeTags)
+                {
+                    int tag = beforeEntry.Key;
+                    int beforeVal = beforeEntry.Value;
+
+                    if (!afterTags.ContainsKey(tag))
+                    {
+                        ret.Add($"--- {GetTagName(tag)} ({beforeVal})");
+                    }
+                    else
+                    {
+                        int afterVal = afterTags[tag];
+
+                        if (beforeVal != afterVal)
+                        {
+                            ret.Add($"CCC {GetTagName(tag)}: {beforeVal} -> {afterVal}");
+                        }
+                    }
+                }
+
+                foreach (var afterEntry in afterTags)
+                {
+                    int tag = afterEntry.Key;
+                    int afterVal = afterEntry.Value;
+                    if (!beforeTags.ContainsKey(tag))
+                    {
+                        ret.Add($"+++ {GetTagName(tag)}={afterVal}");
+                    }
+                }
+
+                return ret;
+            }
+
+            private string GetTagName(int tag)
+            {
+                var ret = Enum.GetName(typeof(GAME_TAG), tag);
+
+                if (ret == null)
+                {
+                    ret = tag.ToString();
+                }
+
+                return ret;
+            }
+
+            internal int GetEntityId()
+            {
+                return m_before.GetEntityId();
+            }
+
+            internal bool HasDied()
+            {
+                return m_died;
+            }
+
+            private static bool IsInvalid(Entity entity)
+            {
+                return entity.GetCardType() == TAG_CARDTYPE.INVALID;
+            }
+
+            private static bool IsDead(Entity entity)
+            {
+                return IsAbleToLive(entity) && IsDeadZone(entity.GetZone());
+            }
+
+            private static bool IsAlive(Entity entity)
+            {
+                return IsAbleToLive(entity) && IsAliveZone(entity.GetZone());
+            }
+
+            private static bool IsDeadZone(TAG_ZONE zone)
+            {
+                return zone == TAG_ZONE.GRAVEYARD || zone == TAG_ZONE.REMOVEDFROMGAME || zone == TAG_ZONE.SETASIDE;
+            }
+
+            private static bool IsAliveZone(TAG_ZONE zone)
+            {
+                return zone == TAG_ZONE.PLAY || zone == TAG_ZONE.SECRET; //  E.g. in-hand cards are not "alive"
+            }
+
+            private static bool IsAbleToLive(Entity entity)
+            {
+                return entity.IsCharacter() || entity.IsWeapon() || entity.IsObjective();
+            }
+
+            internal EntitySpeech GetDeathSpeech()
+            {
+                if (m_before.IsWeapon())
+                {
+                    if (m_after.GetController().GetWeaponCard() == null)
+                    {
+                        return new EntitySpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_WEAPON_BROKE));
+                    }
+                    else
+                    {
+                        return new EntitySpeech("");
+                    }
+                }
+                else if (m_after.IsObjective())
+                {
+                    return new EntitySpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_AURA_FADED), LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_AURAS_FADED));
+                }
+                else
+                {
+                    return new EntitySpeech(
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_DIED),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_DIED)
+                    );
+                }
+            }
+
+            private static bool HasDied(Entity before, Entity after)
+            {
+                var died = IsAlive(before) && IsDead(after);
+
+                if (!died)
+                {
+                    return false;
+                }
+
+                if (after.IsWeapon() && after.GetController().GetWeaponCard() == null)
+                {
+                    s_heroWeaponBroke.Add(after.GetController().GetHero());
+                }
+
+                if (before.IsHero() && before.GetZone() == TAG_ZONE.PLAY && after.GetZone() == TAG_ZONE.SETASIDE)
+                {
+                    return false; // Hero card
+                }
+
+                return true;
+            }
+
+            internal bool HasChanges()
+            {
+                return !m_died && !m_transformed && GetDiffDescription().SingularSpeech.Length > 0;
+            }
+
+            internal Entity GetBeforeEntity()
+            {
+                return m_before;
+            }
+
+            internal Entity GetAfterEntity()
+            {
+                return m_after;
+            }
+
+            internal EntitySpeech GetTransformedSpeech()
+            {
+                return new EntitySpeech(
+                    LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_TRANSFORMED, GetEntityName(m_after)),
+                    LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TRANSFORMED, GetEntityName(m_after))
+                );
+            }
+
+            internal bool HasTransformed()
+            {
+                return m_transformed;
+            }
+
+            private bool HasTransformed(Entity before, Entity after)
+            {
+                if (m_died || m_before.GetZone() != m_after.GetZone())
+                {
+                    return false;
+                }
+
+                var afterEntityName = GetEntityName(m_after);
+                var beforeEntityName = GetEntityName(m_before);
+
+                return !HasRevealed(before, after) && !afterEntityName.Equals(beforeEntityName);
+            }
+
+            private bool HasRevealed(Entity before, Entity after)
+            {
+                var afterEntityName = GetEntityName(m_after);
+                var beforeEntityName = GetEntityName(m_before);
+
+                return before.GetZone() == TAG_ZONE.SECRET && !MovedZone() && !afterEntityName.Equals(beforeEntityName);
+            }
+
+            internal bool MovedZone()
+            {
+                return !m_died && (m_before.GetZone() != m_after.GetZone()) || (m_before.GetController() != m_after.GetController());
+            }
+
+            internal EntitySpeech GetDiffDescription()
+            {
+                return new EntitySpeech(m_descSingular, m_descPlural);
+            }
+
+            private void InitDiffDescriptions()
+            {
+                if (m_died || m_transformed || m_revealed || IsHeroCardBeingPlayed())
+                {
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                if (IsInvalid(m_before) || IsInvalid(m_after))
+                {
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                if (IsDead(m_before) && IsDead(m_after))
+                {
+                    // Has been dead for a while
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                if (MovedZone() && (m_after.GetZone() != TAG_ZONE.PLAY))
+                {
+                    // We don't want to call out stat changes in things like return to hand
+                    m_descSingular = m_descPlural = "";
+                    return;
+                }
+
+                List<string> sDescriptions = new List<string>();
+                List<string> pDescriptions = new List<string>();
+                List<string> sGainedDescriptions = new List<string>();
+                List<string> pGainedDescriptions = new List<string>();
+                List<string> sLostDescriptions = new List<string>();
+                List<string> pLostDescriptions = new List<string>();
+
+                bool gainedAtk = m_atkDiff > 0;
+                bool lostAtk = m_atkDiff < 0;
+                bool gainedHealth = m_healthDiff > 0;
+                bool lostHealth = m_healthDiff < 0;
+                bool gainedArmor = m_armorDiff > 0;
+                bool lostArmor = m_armorDiff < 0;
+
+                int dmgTaken = GetDamageTaken();
+
+                if (lostArmor && ShouldDescribeStatChanges())
+                {
+                    // Armor first so make sure we say "lost 2 armor and took 3 damage" instead of the other way around with the rest of the stats
+                    var lostArmorDescription = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ARMOR, Math.Abs(m_armorDiff));
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_LOST_STATS, lostArmorDescription));
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS, lostArmorDescription));
+                }
+
+                if (dmgTaken > 0 && !m_after.IsWeapon() && ShouldDescribeStatChanges())
+                {
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_TOOK_N_DAMAGE, dmgTaken));
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TOOK_N_DAMAGE, dmgTaken));
+                }
+
+                if (m_healedAmt > 0 && ShouldDescribeStatChanges())
+                {
+                    if (m_after.IsWeapon())
+                    {
+                        // You can never have more than 1 weapon at once
+                        sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_DURABILITY, m_healedAmt));
+                    }
+                    else
+                    {
+                        sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_RECOVERED_N_HEALTH, m_healedAmt));
+                        pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_RECOVERED_N_HEALTH, m_healedAmt));
+                    }
+                }
+
+                if (m_becameInvulnerable && !AccessibleGameplayUtils.IsPlayingTutorial() && !m_becameImmune) // Heroes and minions become invulnerable randomly in tutorial games for some reason (even though they wouldn't even get hit)
+                {
+                    // Don't call out invulnerable + immune e.g. Divine Bell in Garrosh BoH 7
+                    sDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_INVULNERABLE));
+                    pDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_INVULNERABLE));
+                }
+
+                if (!AccessibleCardUtils.IsCursed(m_before) && AccessibleCardUtils.IsCursed(m_after))
+				{
+                    sDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_WAS_CURSED));
+                    pDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_WERE_CURSED));
+				}
+                if (!m_before.HasTag(GAME_TAG.VALEERASHADOW) && m_after.HasTag(GAME_TAG.VALEERASHADOW))
+                {
+                    sDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_WAS_HAUNTED));
+                    pDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_WERE_HAUNTED));
+                }
+                if (!m_before.IsSilenced() && m_after.IsSilenced())
+                {
+                    sDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_SILENCED));
+                    pDescriptions.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_SILENCED));
+                }
+                else
+                {
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasTaunt(), m_after.HasTaunt(), LocalizedText.GLOBAL_TAUNT);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasDeathrattle(), m_after.HasDeathrattle(), LocalizedText.GLOBAL_DEATHRATTLE);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasBattlecry(), m_after.HasBattlecry(), LocalizedText.GLOBAL_BATTLECRY);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasCharge(), m_after.HasCharge(), LocalizedText.GLOBAL_CHARGE);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasLifesteal(), m_after.HasLifesteal(), LocalizedText.GLOBAL_LIFESTEAL);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasRush(), m_after.HasRush(), LocalizedText.GLOBAL_RUSH);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasWindfury(), m_after.HasWindfury(), LocalizedText.GLOBAL_WINDFURY);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasDivineShield(), m_after.HasDivineShield(), LocalizedText.GLOBAL_DIVINE_SHIELD);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.IsFreeze(), m_after.IsFreeze(), LocalizedText.GLOBAL_FREEZE);
+                    AddGainedOrLostDescriptionIfExists(sGainedDescriptions, pGainedDescriptions, sLostDescriptions, pLostDescriptions, m_before.HasReborn(), m_after.HasReborn(), LocalizedText.GLOBAL_REBORN);
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsDormant(), m_after.IsDormant(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_DORMANT),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_DORMANT),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_DORMANT),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_DORMANT));
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsFrozen(), m_after.IsFrozen(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_FROZEN),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_FROZEN),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_FROZEN),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_FROZEN));
+
+                    if (ShouldReadImmunityChanges())
+                    {
+                        AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsImmune(), m_after.IsImmune(),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_IMMUNE),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_IMMUNE),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_IMMUNE),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_IMMUNE));
+                    }
+
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsMagnet(), m_after.IsMagnet(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_MAGNETIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_MAGNETIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_MAGNETIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_MAGNETIC));
+                    AddGainedOrLostDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsPoisonous(), m_after.IsPoisonous(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_POISONOUS),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_NO_LONGER_POISONOUS),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_POISONOUS));
+                    AddGainedDescriptionIfExists(sDescriptions, pDescriptions, m_before.IsStealthed(), m_after.IsStealthed(),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_STEALTHED),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_STEALTHED));
+                }
+
+                if (ShouldDescribeStatChanges())
+                {
+                    // Handle weapons to prevent spam on sheathe/unsheathe/break
+                    if (lostAtk && s_heroSheathedWeapon.Contains(m_after))
+                    {
+                        lostAtk = false;
+                        s_heroSheathedWeapon.Remove(m_after);
+                        AccessibilityUtils.LogDebug("WEP Ignoring lostAtk due to sheathe");
+                    }
+                    else if (lostAtk && s_heroWeaponBroke.Contains(m_after))
+                    {
+                        lostAtk = false;
+                        s_heroWeaponBroke.Remove(m_after);
+                        AccessibilityUtils.LogDebug("WEP Ignoring lostAtk due to broken weapon");
+                    }
+                    else if (gainedAtk && s_heroUnsheathedWeapon.Contains(m_after))
+                    {
+                        gainedAtk = false;
+                        s_heroUnsheathedWeapon.Remove(m_after);
+                        AccessibilityUtils.LogDebug("WEP Ignoring gainAtk due to unsheathe");
+                    }
+
+                    // Normal stats
+                    if (gainedAtk)
+                    {
+                        sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, m_atkDiff));
+                        pGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, m_atkDiff));
+                    }
+                    else if (lostAtk)
+                    {
+                        sLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, Math.Abs(m_atkDiff)));
+                        pLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, Math.Abs(m_atkDiff)));
+                    }
+
+                    if (gainedHealth)
+                    {
+                        sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, m_healthDiff));
+                        pGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, m_healthDiff));
+                    }
+                    else if (lostHealth)
+                    {
+                        sLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, Math.Abs(m_healthDiff)));
+                        pLostDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, Math.Abs(m_healthDiff)));
+                    }
+
+                    if (gainedArmor)
+                    {
+                        sGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ARMOR, m_armorDiff));
+                        pGainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ARMOR, m_armorDiff));
+                    }
+                }
+
+                var sGroupedGainedDescriptions = AccessibleSpeechUtils.HumanizeList(sGainedDescriptions);
+                var pGroupedGainedDescriptions = AccessibleSpeechUtils.HumanizeList(pGainedDescriptions);
+                var sGroupedLostDescriptions = AccessibleSpeechUtils.HumanizeList(sLostDescriptions);
+                var pGroupedLostDescriptions = AccessibleSpeechUtils.HumanizeList(pLostDescriptions);
+
+                if (sGroupedGainedDescriptions.Length > 0)
+                {
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_GAINED_STATS, sGroupedGainedDescriptions));
+                }
+                if (pGroupedGainedDescriptions.Length > 0)
+                {
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_GAINED_STATS, pGroupedGainedDescriptions));
+                }
+
+                if (sGroupedLostDescriptions.Length > 0)
+                {
+                    sDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_LOST_STATS, sGroupedLostDescriptions));
+                }
+                if (pGroupedLostDescriptions.Length > 0)
+                {
+                    pDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS, pGroupedLostDescriptions));
+                }
+
+                m_descSingular = AccessibleSpeechUtils.HumanizeList(sDescriptions);
+                m_descPlural = AccessibleSpeechUtils.HumanizeList(pDescriptions);
+            }
+
+			private bool ShouldDescribeStatChanges()
+			{
+                if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase() && !m_after.IsControlledByFriendlySidePlayer())
+				{
+                    // Don't call out stat changes for Bob's Minions as that can get annoying very quickly due to hero powers and cards like Nomi etc
+                    return false;
+				}
+
+                return true;
+			}
+
+			private bool IsHeroCardBeingPlayed()
+            {
+                return m_after.IsHero() && m_before.GetZone() == TAG_ZONE.HAND && m_after.GetZone() == TAG_ZONE.PLAY;
+            }
+
+            private bool ShouldReadImmunityChanges()
+            {
+                if (m_after.IsWeapon())
+                {
+                    // e.g. Gorehowl in BoH Garrosh
+                    return false;
+                }
+
+                if (m_after.IsHero() && AccessibleGameplayUtils.IsInBattlegroundsShopPhase() && !m_after.IsControlledByFriendlySidePlayer())
+				{
+                    // Tavern Bob sometimes becomes immune but we don't want to read that as it doesn't matter
+                    return false;
+				}
+
+                return true;
+            }
+
+            private void AddGainedOrLostDescriptionIfExists(List<string> singularGainedDescriptions, List<string> pluralGainedDescriptions, List<string> singularLostDescriptions, List<string> pluralLostDescriptions, bool hadBefore, bool hasAfter, string gainedOrLostEffect)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    singularGainedDescriptions.Add(gainedOrLostEffect);
+                    pluralGainedDescriptions.Add(gainedOrLostEffect);
+                }
+                else if (hadBefore && !hasAfter)
+                {
+                    singularLostDescriptions.Add(gainedOrLostEffect);
+                    pluralLostDescriptions.Add(gainedOrLostEffect);
+                }
+            }
+
+            private void AddGainedOrLostDescriptionIfExists(List<string> singularDescriptions, List<string> pluralDescriptions, bool hadBefore, bool hasAfter, string gainedTextSingular, string gainedTextPlural, string lostTextSingular, string lostTextPlural)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    singularDescriptions.Add(gainedTextSingular);
+                    pluralDescriptions.Add(gainedTextPlural);
+                }
+                else if (hadBefore && !hasAfter)
+                {
+                    singularDescriptions.Add(lostTextSingular);
+                    pluralDescriptions.Add(lostTextPlural);
+                }
+            }
+
+            private void AddGainedDescriptionIfExists(List<string> singularDescriptions, List<string> pluralDescriptions, bool hadBefore, bool hasAfter, string gainedTextSingular, string gainedTextPlural)
+            {
+                if (!hadBefore && hasAfter)
+                {
+                    singularDescriptions.Add(gainedTextSingular);
+                    pluralDescriptions.Add(gainedTextPlural);
+                }
+            }
+        }
+
+		internal List<Entity> GetPlayerMinions()
+		{
+            return m_playerMinions;
+		}
+
+		internal static bool HasPlayerReceivedCards(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            return before.m_playerHand.Count != after.m_playerHand.Count;
+		}
+
+		internal static bool HasAnyHeroGainedAtk(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            var beforePlayerAtk = before.m_playerHero.GetATK();
+            var afterPlayerAtk = after.m_playerHero.GetATK();
+            var beforeOpponentAtk = before.m_opponentHero.GetATK();
+            var afterOpponentAtk = after.m_opponentHero.GetATK();
+
+            return afterPlayerAtk > beforePlayerAtk || afterOpponentAtk > beforeOpponentAtk;
+		}
+
+		internal static bool HasAnyHeroLostAtk(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            var beforePlayerAtk = before.m_playerHero.GetATK();
+            var afterPlayerAtk = after.m_playerHero.GetATK();
+            var beforeOpponentAtk = before.m_opponentHero.GetATK();
+            var afterOpponentAtk = after.m_opponentHero.GetATK();
+
+            return afterPlayerAtk < beforePlayerAtk || afterOpponentAtk < beforeOpponentAtk;
+		}
+
+		internal static bool HasAnyHeroRecoveredHealth(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            var beforePlayerHealth = before.m_playerHero.GetCurrentHealth();
+            var afterPlayerHealth = after.m_playerHero.GetCurrentHealth();
+            var beforeOpponentHealth = before.m_opponentHero.GetCurrentHealth();
+            var afterOpponentHealth = after.m_opponentHero.GetCurrentHealth();
+
+            return afterPlayerHealth > beforePlayerHealth || afterOpponentHealth > beforeOpponentHealth;
+		}
+
+		internal static bool WasAnyPlayerMinionBuffedOrDebuffed(AccessibleInGameState before, AccessibleInGameState after, HashSet<string> filterCardIds=null)
+		{
+            if (before == null || after == null)
+			{
+                return false;
+			}
+
+            var friendlyPlayerDiffs = CreateFriendlyPlayerEntityDiffs(before, after, filterCardIds);
+
+            foreach (var diff in friendlyPlayerDiffs)
+			{
+                if (diff.HasChanges() || diff.HasTransformed())
+				{
+                    return true;
+				}
+			}
+
+            return false;
+		}
+
+        private static List<EntityDiff> CreateFriendlyPlayerEntityDiffs(AccessibleInGameState before, AccessibleInGameState after, HashSet<string> filterCardIds)
+        {
+            // Used in Battlegrounds only for outputting permanent effects
+            // Note: filterCardIds is used for certain cases such as Tarecgosas where we don't care about other minions
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityBefore in before.m_playerMinions)
+            {
+                var entityAfter = after.GetEntity(entityBefore.GetEntityId());
+
+                if (entityAfter != null && (filterCardIds == null || filterCardIds.Contains(entityAfter.GetCardId())))
+                {
+                    ret.Add(new EntityDiff(entityBefore, entityAfter, before, after));
+                }
+            }
+
+            return ret;
+        }
+
+		internal static bool HasOpponentHeroChanged(AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (before == null || before.m_opponentHero == null)
+			{
+                return false;
+			}
+
+            return before.m_opponentHero.GetEntityId() != after.m_opponentHero.GetEntityId();
+		}
+
+		private class EntityGroup
+        {
+            private string m_name;
+            private List<Entity> m_entities;
+
+            internal EntityGroup(string name, List<Entity> entities)
+            {
+                m_name = name;
+                m_entities = entities;
+            }
+
+            internal bool IsSubsetOf(List<Entity> entities)
+            {
+                var entitiesMap = new HashSet<Entity>(entities, new EntityComparer());
+
+                foreach (var entity in m_entities)
+                {
+                    if (!entitiesMap.Contains(entity))
+                    {
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+
+            internal string GetName()
+            {
+                return m_name;
+            }
+
+            internal List<Entity> GetEntities()
+            {
+                return m_entities;
+            }
+        }
+
+        private PowerTaskList m_powerTaskList;
+
+        private bool m_gameCreated;
+
+        private TAG_STEP m_step;
+
+        private Player m_currentPlayer;
+        private int m_playerAvailableResources;
+        private int m_playerResources;
+        private int m_opponentAvailableResources;
+        private int m_opponentResources;
+        private int m_playerNumTurnsInPlay;
+        private int m_playerSpellpower;
+        private int m_opponentSpellpower;
+
+        private Entity m_playerHero, m_opponentHero;
+        private Entity m_playerHeroPower, m_opponentHeroPower;
+        private Entity m_playerWeapon, m_opponentWeapon;
+
+        private List<Entity> m_playerHand, m_opponentHand;
+        private List<Entity> m_playerDeck, m_opponentDeck;
+        private List<Entity> m_playerGraveyard, m_opponentGraveyard;
+        private List<Entity> m_playerMinions, m_opponentMinions;
+        private List<Entity> m_playerSecrets, m_opponentSecrets;
+
+        private List<Entity> m_entities;
+
+        private bool IsGoodCardType(TAG_CARDTYPE cardType)
+        {
+            return cardType == TAG_CARDTYPE.HERO || cardType == TAG_CARDTYPE.SPELL || cardType == TAG_CARDTYPE.MINION || cardType == TAG_CARDTYPE.WEAPON || cardType == TAG_CARDTYPE.LOCATION;
+        }
+
+        private List<Entity> GetSetAsideEntities()
+        {
+            // Note: this is needed because cards destroyed by Patchwerk in the hand go into setaside for some reason.
+            var ret = new List<Entity>();
+            var entityMap = GameState.Get().GetEntityMap();
+            foreach (var entity in entityMap.Values)
+            {
+                if (entity.GetZone() == TAG_ZONE.SETASIDE && IsGoodCardType(entity.GetCardType()))
+                {
+                    ret.Add(entity);
+                }
+            }
+            return ret;
+            }
+
+        private AccessibleInGameState(PowerTaskList powerTaskList)
+        {
+            m_powerTaskList = powerTaskList;
+
+            if (!GameState.Get().IsGameCreated())
+            {
+                return;
+            }
+
+            m_gameCreated = true;
+
+            m_step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            m_currentPlayer = GameState.Get().GetCurrentPlayer();
+
+            Player player = GameState.Get().GetFriendlySidePlayer();
+            Player opponent = GameState.Get().GetOpposingSidePlayer();
+
+            m_playerAvailableResources = player.GetNumAvailableResources();
+            m_opponentAvailableResources = opponent.GetNumAvailableResources();
+            m_playerResources = player.GetTag(GAME_TAG.RESOURCES);
+            m_opponentResources = opponent.GetTag(GAME_TAG.RESOURCES);
+            m_playerSpellpower = player.TotalSpellpower(player);
+            m_opponentSpellpower = opponent.TotalSpellpower(opponent);
+            m_playerNumTurnsInPlay = player.GetNumTurnsInPlay();
+
+            m_playerHero = Clone(player.GetHero());
+            m_opponentHero = Clone(opponent.GetHero());
+            m_playerHeroPower = Clone(player.GetHeroPower());
+            m_opponentHeroPower = Clone(opponent.GetHeroPower());
+            m_playerWeapon = Clone(player.GetWeaponCard()?.GetEntity());
+            m_opponentWeapon = Clone(opponent.GetWeaponCard()?.GetEntity());
+
+            m_playerHand = Clone(GetEntitiesFromZone(player.GetHandZone()));
+            m_opponentHand = Clone(GetEntitiesFromZone(opponent.GetHandZone()));
+            m_playerDeck = Clone(GetEntitiesFromZone(player.GetDeckZone()));
+            m_opponentDeck = Clone(GetEntitiesFromZone(opponent.GetDeckZone()));
+            m_playerGraveyard = Clone(GetEntitiesFromZone(player.GetGraveyardZone()));
+            m_opponentGraveyard = Clone(GetEntitiesFromZone(opponent.GetGraveyardZone()));
+            m_playerMinions = Clone(GetEntitiesFromZone(player.GetBattlefieldZone()));
+            m_opponentMinions = Clone(GetEntitiesFromZone(opponent.GetBattlefieldZone()));
+            m_playerSecrets = Clone(GetEntitiesFromZone(player.GetSecretZone()));
+            m_opponentSecrets = Clone(GetEntitiesFromZone(opponent.GetSecretZone()));
+
+            m_entities = new List<Entity>();
+            m_entities.Add(m_playerHero);
+            m_entities.Add(m_opponentHero);
+            if (m_playerHeroPower != null) m_entities.Add(m_playerHeroPower);
+            if (m_opponentHeroPower != null) m_entities.Add(m_opponentHeroPower);
+            if (m_playerWeapon != null) m_entities.Add(m_playerWeapon);
+            if (m_opponentWeapon != null) m_entities.Add(m_opponentWeapon);
+            m_entities.AddRange(m_playerHand);
+            m_entities.AddRange(m_opponentHand);
+            m_entities.AddRange(m_playerDeck);
+            m_entities.AddRange(m_opponentDeck);
+            m_entities.AddRange(m_playerGraveyard);
+            m_entities.AddRange(m_opponentGraveyard);
+            m_entities.AddRange(m_playerMinions);
+            m_entities.AddRange(m_opponentMinions);
+            m_entities.AddRange(m_playerSecrets);
+            m_entities.AddRange(m_opponentSecrets);
+            if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+            {
+                m_entities.AddRange(Clone(GetSetAsideEntities()));
+            }
+        }
+
+        internal bool HasWeaponEquipped(Entity hero)
+        {
+            return GetWeapon(hero.GetController()) != null;
+        }
+
+        private Entity GetWeapon(Player player)
+        {
+            if (player.IsFriendlySide())
+            {
+                return m_playerWeapon;
+            }
+            else
+            {
+                return m_opponentWeapon;
+            }
+        }
+
+        private Entity GetHero(Player player)
+        {
+            if (player.IsFriendlySide())
+            {
+                return m_playerHero;
+            }
+            else
+            {
+                return m_opponentHero;
+            }
+        }
+
+        internal static AccessibleInGameState GetCurrentState(PowerTaskList powerTaskList)
+        {
+            return new AccessibleInGameState(powerTaskList);
+        }
+
+        internal Entity GetEntity(int entityId)
+        {
+            foreach (var entity in m_entities)
+            {
+                if (entity.GetEntityId() == entityId)
+                {
+                    return entity;
+                }
+            }
+
+            return null;
+        }
+
+        private static List<string> GetDiffSpeech(Entity sourceEntity, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            // Groups
+            var allFriendlyCharacters = ConcatEntities(before.m_playerMinions, before.m_playerHero);
+            var allEnemies = ConcatEntities(before.m_opponentMinions, before.m_opponentHero);
+            var allMinions = ConcatEntities(before.m_playerMinions, before.m_opponentMinions);
+            var everyone = ConcatEntities(allFriendlyCharacters, allEnemies);
+            var bothHeroes = ConcatEntities(before.m_playerHero, before.m_opponentHero);
+
+            var groups = new List<EntityGroup>();
+            if (everyone.Count > 2) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_EVERYONE), everyone));
+            groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_BOTH_HEROES), bothHeroes));
+            if (allMinions.Count > 0 && before.m_playerMinions.Count > 0 && before.m_opponentMinions.Count > 0) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_ALL_MINIONS), allMinions));
+            if (allEnemies.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_ENEMIES), allEnemies));
+            if (allFriendlyCharacters.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_FRIENDLY_CHARACTERS), allFriendlyCharacters));
+            if (before.m_opponentMinions.Count > 1) groups.Add(new EntityGroup(GetOpponentMinionsGroupName(), before.m_opponentMinions));
+            if (before.m_playerMinions.Count > 1) groups.Add(new EntityGroup(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_FRIENDLY_MINIONS), before.m_playerMinions));
+
+            if (sourceEntity != null)
+            {
+                AddOtherThanSourceEntityGroups(sourceEntity, everyone, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_EVERYONE_ELSE));
+                AddOtherThanSourceEntityGroups(sourceEntity, allMinions, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_ALL_OTHER_MINIONS));
+                AddOtherThanSourceEntityGroups(sourceEntity, allEnemies, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_ENEMIES));
+                AddOtherThanSourceEntityGroups(sourceEntity, allFriendlyCharacters, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_CHARACTERS));
+                AddOtherThanSourceEntityGroups(sourceEntity, before.m_opponentMinions, groups, GetOtherOpponentMinionsGroupName());
+                AddOtherThanSourceEntityGroups(sourceEntity, before.m_playerMinions, groups, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_MINIONS));
+            }
+            AddSameNameEntityGroups(before.m_playerMinions, groups, true);
+            AddSameNameEntityGroups(before.m_opponentMinions, groups, false);
+
+            return GetDiffSpeech(sourceEntity, before, after, groups);
+        }
+
+		private static string GetOpponentMinionsGroupName()
+		{
+            var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_MINIONS : LocalizationKey.GAMEPLAY_DIFF_GROUP_OPPONENT_MINIONS;
+            return LocalizationUtils.Get(key);
+		}
+
+		private static string GetOtherOpponentMinionsGroupName()
+		{
+            var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_OTHER_BARTENDER_MINIONS : LocalizationKey.GAMEPLAY_DIFF_GROUP_OTHER_OPPONENT_MINIONS;
+			return LocalizationUtils.Get(key);
+		}
+
+		private static List<string> GetDiffSpeech(Entity sourceEntity, AccessibleInGameState before, AccessibleInGameState after, List<EntityGroup> groups)
+        {
+            // Note: sourceEntity is a duplicate but I think it can be null in some cases
+
+            List<Entity> destroyedEntities = GetDestroyedEntities(before, after);
+            List<Entity> newEntities = GetNewEntities(before, after);
+
+            var newEntitySpeeches = GetNewEntitySpeeches(newEntities);
+
+            List<EntityDiff> entityDiffs = CreateEntityDiffs(before, after);
+            List<EntityDiff> affectedEntities = GetAffectedEntities(entityDiffs);
+            List<EntityDiff> movedEntities = GetMovedEntities(sourceEntity, entityDiffs, after.m_entities);
+            List<EntityDiff> transformedEntities = GetTransformedEntities(entityDiffs); // Technically a change but we want to state these first due to enchantments (e.g. polymorph on a stormwind champion)
+            List<EntityDiff> justDiedEntities = GetJustDiedEntities(entityDiffs);
+
+            DebugEntityDiffs(entityDiffs);
+
+            AccessibilityUtils.LogDebug($"DBG justDiedEntities: {GetEntityNamesDbg(justDiedEntities)}");
+
+            var ret = new List<string>();
+
+            // Testing
+            var affectedEntitySpeeches = GetEntitySpeeches(affectedEntities);
+            var transformedEntitySpeeches = GetTransformedEntitySpeeches(transformedEntities);
+            var deadEntitySpeeches = GetDeadEntitySpeeches(justDiedEntities);
+
+            var groupedMovementSpeeches = GetZoneMovementSpeeches(movedEntities, groups);
+
+            AccessibilityUtils.LogDebug("DBG Groups");
+            foreach (var group in groups)
+            {
+                AccessibilityUtils.LogDebug($"DBG {group.GetName()}: {GetEntityNamesDbg(group.GetEntities())}");
+            }
+
+            AccessibilityUtils.LogDebug("DBG Grouping affectedEntities speeches");
+            var groupedSpeeches = GroupSpeeches(affectedEntities, groups, affectedEntitySpeeches, true);
+
+            AccessibilityUtils.LogDebug("DBG Grouping transformedEntities speeches");
+            var groupedTransformedSpeeches = GroupSpeeches(transformedEntities, groups, transformedEntitySpeeches, true);
+
+            AccessibilityUtils.LogDebug("DBG Grouping justDiedEntities speeches");
+            var groupedDeathSpeeches = GroupSpeeches(justDiedEntities, groups, deadEntitySpeeches, false);
+
+            ret.AddRange(newEntitySpeeches);
+            ret.AddRange(groupedMovementSpeeches);
+            ret.AddRange(groupedTransformedSpeeches);
+            ret.AddRange(groupedDeathSpeeches);
+            ret.AddRange(groupedSpeeches);
+
+            return ret;
+        }
+
+        private static void AddOtherThanSourceEntityGroups(Entity source, List<Entity> entities, List<EntityGroup> groups, string groupName)
+        {
+            var otherEntities = new List<Entity>(entities.Count);
+
+            foreach (var entity in entities)
+            {
+                if (entity.GetEntityId() != source.GetEntityId())
+                {
+                    otherEntities.Add(entity);
+                }
+            }
+
+            if (otherEntities.Count > 1)
+            {
+                groups.Add(new EntityGroup(groupName, otherEntities));
+            }
+        }
+
+        private static void AddSameNameEntityGroups(List<Entity> entities, List<EntityGroup> groups, bool friendlySide)
+        {
+            Dictionary<string, List<Entity>> entitiesByName = new Dictionary<string, List<Entity>>();
+
+            foreach (var entity in entities)
+            {
+                var entityName = GetEntityName(entity);
+                if (!entitiesByName.ContainsKey(entityName))
+                {
+                    var newList = new List<Entity>();
+                    newList.Add(entity);
+                    entitiesByName.Add(entityName, newList);
+                }
+                else
+                {
+                    entitiesByName[entityName].Add(entity);
+                }
+            }
+
+            foreach (var entry in entitiesByName)
+            {
+                if (entry.Value.Count > 1)
+                {
+                    if (friendlySide)
+                    {
+                        groups.Add(new EntityGroup(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_GROUP_FRIENDLY_SAME_NAME_ENTITIES, entry.Value.Count, entry.Key), entry.Value));
+                    }
+                    else
+                    {
+                        var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_SAME_NAME_ENTITIES : LocalizationKey.GAMEPLAY_DIFF_GROUP_OPPONENT_SAME_NAME_ENTITIES;
+                        groups.Add(new EntityGroup(LocalizationUtils.Format(key, entry.Value.Count, entry.Key), entry.Value));
+                    }
+                }
+            }
+        }
+
+		private static List<string> GroupSpeeches(List<EntityDiff> entityDiffs, List<EntityGroup> groups, Dictionary<Entity, EntitySpeech> entitySpeeches, bool useZoneOrder)
+        {
+            var handled = new Dictionary<Entity, bool>(new EntityComparer());
+            var entities = new List<Entity>(entityDiffs.Count);
+
+			// TODO: Refactor this entire thing properly to use EntityDiffs instead of Entities as we don't always want to necessarily use the before entity
+            // e.g. x transformed into y should use before
+            //      x moved from deck to battlefield should use after (since before will still be invalid)
+            //      x died should use before (to differentiate e.g. your 2nd murloc died vs your murloc died or even your tenth murloc died if you already had 9 in GY)
+			var beforeEntityToAfterEntity = new Dictionary<Entity, Entity>(new EntityComparer());
+
+			entityDiffs.ForEach(e =>
+			{
+				entities.Add(e.GetBeforeEntity());
+				handled.Add(e.GetBeforeEntity(), false);
+				beforeEntityToAfterEntity.Add(e.GetBeforeEntity(), e.GetAfterEntity());
+			});
+
+			var groupedSpeeches = new Dictionary<string, EntitySpeech>();
+
+            AccessibilityUtils.LogDebug("DBG Grouping speeches");
+            AccessibilityUtils.LogDebug($"DBG entities: {GetEntityNamesDbg(entities)}");
+            AccessibilityUtils.LogDebug($"DBG speeches:");
+            foreach (var entry in entitySpeeches)
+            {
+                AccessibilityUtils.LogDebug($"DBG {entry.Key.GetName()}: {entry.Value}");
+            }
+
+            foreach (var group in groups)
+            {
+                if (group.GetEntities().Count > 1 && group.IsSubsetOf(entities))
+                {
+                    AccessibilityUtils.LogDebug($"DBG Group with > 1 and subset found: {group.GetName()}");
+                    if (!SpeechesAlreadyHandled(group, handled) && AllEntitiesShareSpeech(group.GetEntities(), entitySpeeches))
+                    {
+                        AccessibilityUtils.LogDebug($"DBG Handling group {group.GetName()}");
+                        var speech = entitySpeeches[group.GetEntities()[0]];
+                        groupedSpeeches[group.GetName()] = speech;
+                        MarkHandled(group, handled);
+                    }
+                }
+            }
+
+            var remainingSpeeches = new Dictionary<string, EntitySpeech>();
+
+            var remainingEntities = GetUnhandledEntities(handled);
+            AccessibilityUtils.LogDebug($"DBG remainingEntities: {GetEntityNamesDbg(remainingEntities)}");
+            remainingEntities.ForEach(e =>
+            {
+                if (entitySpeeches.ContainsKey(e))
+                {
+
+                    // Only add if we have proper changes (e.g. being destroyed does not warrant a speech as it would be covered by death anyways)
+                    if (useZoneOrder)
+                    {
+                        remainingSpeeches.Add(GetFullNameInZone(e), entitySpeeches[e]);
+                    }
+                    else
+                    {
+						// e.g. Death speeches (since we may have more than one in graveyard)
+                        // e.g. move from deck to battlefield speeches
+
+						var afterEntity = beforeEntityToAfterEntity[e]; // TODO: Refactor everything to use EntityDiffs. See above
+
+                        if (e.GetCardType() == TAG_CARDTYPE.INVALID && afterEntity.GetCardType() != TAG_CARDTYPE.INVALID)
+						{
+                            // e.g. deck->battlefield (after is ok / before is still invalid)
+                            // This is a mess but can't fix it properly until all of this is refactored to use EntityDiffs instead of entities
+							remainingSpeeches.Add(GetFullName(afterEntity), entitySpeeches[e]);
+						}
+                        else
+						{
+							remainingSpeeches.Add(GetFullNameInList(e, remainingEntities), entitySpeeches[e]);
+						}
+					}
+                }
+            });
+
+            return CombineSpeeches(groupedSpeeches, remainingSpeeches);
+        }
+
+        private static string GetEntityNamesDbg(List<Entity> entities)
+        {
+            var sb = new StringBuilder();
+            sb.Append("[");
+
+            for (int i = 0; i < entities.Count; i++)
+            {
+                if (i != 0)
+                {
+                    sb.Append(", ");
+                }
+
+                sb.Append(entities[i].GetName());
+            }
+
+            sb.Append("]");
+            return sb.ToString();
+        }
+
+        private static string GetEntityNamesDbg(List<EntityDiff> entityDiffs)
+        {
+            var entities = new List<Entity>(entityDiffs.Count);
+
+            foreach (var diff in entityDiffs)
+            {
+                entities.Add(diff.GetAfterEntity());
+            }
+
+            return GetEntityNamesDbg(entities);
+        }
+
+        private static List<string> CombineSpeeches(Dictionary<string, EntitySpeech> groupedSpeeches, Dictionary<string, EntitySpeech> remainingSpeeches)
+        {
+            var ret = new List<string>();
+            var speechToEntityNames = new Dictionary<EntitySpeech, List<string>>();
+
+            foreach (var entry in groupedSpeeches)
+            {
+                if (speechToEntityNames.ContainsKey(entry.Value))
+                {
+                    speechToEntityNames[entry.Value].Add(entry.Key);
+                }
+                else
+                {
+                    speechToEntityNames.Add(entry.Value, new List<string> { entry.Key });
+                }
+            }
+
+            foreach (var entry in remainingSpeeches)
+            {
+                if (speechToEntityNames.ContainsKey(entry.Value))
+                {
+                    speechToEntityNames[entry.Value].Add(entry.Key);
+                }
+                else
+                {
+                    speechToEntityNames.Add(entry.Value, new List<string> { entry.Key });
+                }
+            }
+
+            foreach (var entry in speechToEntityNames)
+            {
+                var speech = entry.Key;
+                var entities = entry.Value;
+
+                string resultingSpeech = speech.SingularSpeech;
+
+                if (entities.Count > 1)
+                {
+                    // Single remaining entities joined with a group or other remaining entities, forming a group
+                    resultingSpeech = speech.PluralSpeech;
+                }
+
+                if (entities.Count == 1 && groupedSpeeches.ContainsKey(entities[0]))
+                {
+                    // Was already grouped in the first place
+                    resultingSpeech = speech.PluralSpeech;
+                }
+
+                var entitiesAsList = AccessibleSpeechUtils.HumanizeList(entities);
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT, entitiesAsList, resultingSpeech));
+            }
+
+            return ret;
+        }
+
+        private static bool AllEntitiesShareSpeech(List<Entity> entities, Dictionary<Entity, EntitySpeech> speeches)
+        {
+            EntitySpeech speech = null;
+
+            foreach (var entity in entities)
+            {
+                if (!speeches.ContainsKey(entity))
+                {
+                    return false;
+                }
+
+                if (speech == null)
+                {
+                    speech = speeches[entity];
+                }
+                else if (!speeches[entity].Equals(speech))
+                {
+                    return false;
+                }
+            }
+
+            return speech.SingularSpeech.Length > 0; // We're not interested if they're not saying anything
+        }
+
+        private static bool SpeechesAlreadyHandled(EntityGroup group, Dictionary<Entity, bool> handled)
+        {
+            foreach (var entity in group.GetEntities())
+            {
+                if (handled[entity])
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private static void MarkHandled(EntityGroup group, Dictionary<Entity, bool> handled)
+        {
+            foreach (var entity in group.GetEntities())
+            {
+                handled[entity] = true;
+            }
+        }
+
+        private static List<Entity> GetUnhandledEntities(Dictionary<Entity, bool> handled)
+        {
+            var ret = new List<Entity>();
+
+            foreach (var entry in handled)
+            {
+                if (!entry.Value)
+                {
+                    ret.Add(entry.Key);
+                }
+            }
+
+            return ret;
+        }
+
+        private static Dictionary<Entity, EntitySpeech> GetEntitySpeeches(List<EntityDiff> entities)
+        {
+            var ret = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            foreach (var entity in entities)
+            {
+                var desc = entity.GetDiffDescription();
+
+                if (desc.SingularSpeech.Length > 0)
+                {
+                    ret[entity.GetAfterEntity()] = desc;
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetNewEntitySpeeches(List<Entity> entities)
+        {
+            var ret = new List<string>();
+            var addedToPlayerHand = new List<string>();
+            var addedToOpponentHand = new List<string>();
+            var addedToPlayerDeck = new List<string>();
+            var addedToOpponentDeck = new List<string>();
+            var addedToPlayerBattlefield = new List<string>();
+            var addedToOpponentBattlefield = new List<string>();
+            var addedToPlayerSecrets = new List<string>();
+            var addedToOpponentSecrets = new List<string>();
+
+            foreach (var entity in entities)
+            {
+                Zone curZone = entity.GetCard().GetZone();
+
+                string cardName = GetCardNameForZoneMovement(entity);
+
+                Zone playerHand = GameState.Get().GetFriendlySidePlayer().GetHandZone();
+                Zone opponentHand = GameState.Get().GetOpposingSidePlayer().GetHandZone();
+                Zone playerDeck = GameState.Get().GetFriendlySidePlayer().GetDeckZone();
+                Zone opponentDeck = GameState.Get().GetOpposingSidePlayer().GetDeckZone();
+                Zone playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+                Zone opponentBattlefield = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone();
+                Zone playerSecrets = GameState.Get().GetFriendlySidePlayer().GetSecretZone();
+                Zone opponentSecrets = GameState.Get().GetOpposingSidePlayer().GetSecretZone();
+
+                // Spawned card
+                if (curZone == playerHand)
+                {
+                    addedToPlayerHand.Add(cardName);
+                }
+                else if (curZone == opponentHand)
+                {
+                    addedToOpponentHand.Add(cardName);
+                }
+                else if (curZone == playerDeck)
+                {
+                    addedToPlayerDeck.Add(cardName);
+                }
+                else if (curZone == opponentDeck)
+                {
+                    addedToOpponentDeck.Add(cardName);
+                }
+                else if (curZone == playerBattlefield)
+                {
+                    addedToPlayerBattlefield.Add(cardName);
+                }
+                else if (curZone == opponentBattlefield)
+                {
+                    addedToOpponentBattlefield.Add(cardName);
+                }
+                else if (entity.GetCard() == GameState.Get().GetFriendlySidePlayer().GetWeaponCard())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_EQUIPPED_WEAPON, cardName));
+                }
+                else if (entity.GetCard() == GameState.Get().GetOpposingSidePlayer().GetWeaponCard())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_EQUIPPED_WEAPON, cardName));
+                }
+                else if (curZone == playerSecrets)
+                {
+                    if (entity.IsSecret())
+                    {
+                        addedToPlayerSecrets.Add(cardName);
+                    }
+
+                    // TODO: Handle quests, sidequests and questlines differently
+                }
+                else if (curZone == opponentSecrets)
+                {
+                    if (entity.IsSecret())
+                    {
+                        var className = GameStrings.GetClassName(entity.GetClass());
+                        addedToOpponentSecrets.Add(className);
+                    }
+
+                    // TODO: Handle quests, sidequests and questlines differently
+                }
+                else if (entity == GameState.Get().GetFriendlySidePlayer().GetHeroPower())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED, cardName));
+                }
+                else if (entity == GameState.Get().GetOpposingSidePlayer().GetHeroPower())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED, cardName));
+                }
+            }
+
+            InsertZoneMovements(ret, addedToPlayerHand, GetSingularCardAddedToPlayerHandKey(), GetPluralCardAddedToPlayerHandKey());
+            InsertZoneMovements(ret, addedToOpponentHand, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_HAND, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_HAND);
+            InsertZoneMovements(ret, addedToPlayerDeck, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_DECK, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_DECK);
+            InsertZoneMovements(ret, addedToOpponentDeck, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_DECK, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_DECK);
+            InsertZoneMovements(ret, addedToPlayerBattlefield, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_BATTLEFIELD, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_BATTLEFIELD);
+            InsertZoneMovements(ret, addedToOpponentBattlefield, GetSingularCardAddedToOpponentBattlefieldKey(), GetPluralCardAddedToOpponentBattlefieldKey());
+            InsertOpponentSecretMovements(ret, addedToOpponentSecrets);
+
+            return ret;
+        }
+
+		private static LocalizationKey GetSingularCardAddedToOpponentBattlefieldKey()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_TAVERN;
+            }
+            else
+			{
+                return LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_BATTLEFIELD;
+			}
+		}
+
+		private static LocalizationKey GetPluralCardAddedToOpponentBattlefieldKey()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_TAVERN;
+            }
+            else
+			{
+                return LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_BATTLEFIELD;
+			}
+		}
+
+		private static LocalizationKey GetSingularCardAddedToPlayerHandKey()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_HAND;
+            }
+            else
+			{
+                return LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_HAND;
+			}
+		}
+
+        private static LocalizationKey GetPluralCardAddedToPlayerHandKey()
+        {
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+            {
+                return LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_HAND;
+            }
+            else
+            {
+                return LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_HAND;
+            }
+        }
+
+		private static List<string> GetZoneMovementSpeeches(List<EntityDiff> entities, List<EntityGroup> groups)
+        {
+            var ret = new List<string>();
+
+            var drawnPlayerCards = new List<string>();
+            var drawnOpponentCards = new List<string>();
+            var discardedPlayerCards = new List<string>();
+            var discardedOpponentCards = new List<string>();
+            var takenControlByPlayerCards = new List<string>();
+            var takenControlByOpponentCards = new List<string>();
+            var castPlayerSecrets = new List<string>();
+            var castOpponentSecrets = new List<string>();
+
+            var speeches = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            var player = GameState.Get().GetFriendlySidePlayer();
+            var opponent = GameState.Get().GetOpposingSidePlayer();
+
+            var playerHand = player.GetHandZone();
+            var opponentHand = opponent.GetHandZone();
+            var playerMinions = player.GetBattlefieldZone();
+            var opponentMinions = opponent.GetBattlefieldZone();
+            var playerSecrets = player.GetSecretZone();
+            var opponentSecrets = opponent.GetSecretZone();
+            var playerDeck = player.GetDeckZone();
+            var opponentDeck = opponent.GetDeckZone();
+            var playerGraveyard = player.GetGraveyardZone();
+            var opponentGraveyard = opponent.GetGraveyardZone();
+
+            var zoneNames = new Dictionary<Zone, string>();
+            zoneNames.Add(playerHand, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_HAND));
+            zoneNames.Add(opponentHand, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_HAND));
+            zoneNames.Add(playerMinions, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_BATTLEFIELD));
+            zoneNames.Add(opponentMinions, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_BATTLEFIELD));
+            zoneNames.Add(playerSecrets, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_SECRETS));
+            zoneNames.Add(opponentSecrets, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_SECRETS));
+            zoneNames.Add(playerDeck, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_DECK));
+            zoneNames.Add(opponentDeck, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_DECK));
+            zoneNames.Add(playerGraveyard, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_PLAYER_GRAVEYARD));
+            zoneNames.Add(opponentGraveyard, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ZONE_OPPONENT_GRAVEYARD));
+
+            foreach (var entity in entities)
+            {
+                var before = entity.GetBeforeEntity();
+                var after = entity.GetAfterEntity();
+
+                var beforeZoneType = before.GetZone();
+                var afterZoneType = after.GetZone();
+
+                var beforeZone = GetZone(before);
+                var afterZone = GetZone(after);
+
+                // Entities moving from setaside are handled as new.
+                if (beforeZoneType == TAG_ZONE.SETASIDE)
+                {
+                    continue;
+                }
+
+                // Note: play->graveyard movements are currently covered by EntityDiffs themselves (when checking HasMoved)
+                // Other -> graveyard movements aren't though (e.g. secrets being triggered)
+                if (afterZoneType == TAG_ZONE.GRAVEYARD)
+                {
+                    if (beforeZoneType != TAG_ZONE.PLAY && beforeZoneType != TAG_ZONE.SECRET)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+
+                        if (before.IsControlledByFriendlySidePlayer())
+                        {
+                            discardedPlayerCards.Add(cardName);
+                        }
+                        else
+                        {
+                            discardedOpponentCards.Add(cardName);
+                        }
+                    }
+
+                    continue;
+                }
+
+                // Note: this is needed because cards destroyed by Patchwerk in the hand go into setaside for some reason.
+                if (beforeZoneType == TAG_ZONE.HAND && afterZoneType == TAG_ZONE.SETASIDE)
+                {
+                    var name = GetCardNameForZoneMovement(after);
+                    if (before.IsControlledByFriendlySidePlayer())
+                    {
+                        discardedPlayerCards.Add(name);
+                    }
+                    else
+                    {
+                        discardedOpponentCards.Add(name);
+                    }
+                    continue;
+                }
+
+                // Weapons are edge cases since we don't really know if they were equipped before or not
+                if (beforeZoneType == TAG_ZONE.PLAY && before.GetCardType() == TAG_CARDTYPE.WEAPON && before.GetControllerSide() == Player.Side.FRIENDLY)
+                {
+                    if (before.GetControllerSide() == Player.Side.FRIENDLY && afterZone == playerHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else if (before.GetControllerSide() == Player.Side.OPPOSING && afterZone == opponentHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE, afterZone),
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE, afterZone)
+                        );
+                        speeches.Add(after, speech);
+                    }
+
+                    continue;
+                }
+
+                // Fallback zones
+                if (beforeZone == null || afterZone == null)
+                {
+                    if (after.GetZone() == TAG_ZONE.SETASIDE && before.IsHeroPower())
+                    {
+                        // A bit of a weird path but this is how Hero cards seem to be working
+                        var newHeroPower = before.GetController().GetHeroPower();
+
+                        if (newHeroPower != null && newHeroPower.GetEntityId() != before.GetEntityId())
+                        {
+                            var newHeroPowerName = newHeroPower.GetName();
+
+                            if (newHeroPower.IsControlledByFriendlySidePlayer())
+                            {
+                                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED, newHeroPowerName));
+                            }
+                            else
+                            {
+                                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED, newHeroPowerName));
+                            }
+                        }
+                    }
+                    else if (after.GetZone() == TAG_ZONE.SETASIDE)
+                    {
+                        if (after.IsHero() && before.GetZone() == TAG_ZONE.PLAY) // Guard against "Your hero died" messages when playing hero card
+                        {
+                            continue;
+                        }
+                        var cardName = GetCardNameForZoneMovement(after);
+
+                        if (before.IsControlledByFriendlySidePlayer())
+                        {
+                            discardedPlayerCards.Add(cardName);
+                        }
+                        else
+                        {
+                            discardedOpponentCards.Add(cardName);
+                        }
+                    }
+                    else
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC)
+                        );
+                        speeches.Add(after, speech);
+                    }
+
+                    continue;
+                }
+
+                // Normal scenarios
+                if (zoneNames.ContainsKey(beforeZone) && zoneNames.ContainsKey(afterZone))
+                {
+                    if (beforeZone == playerDeck && afterZone == playerHand)
+                    {
+                        var cardName = GetCardNameForZoneMovement(after);
+                        drawnPlayerCards.Add(cardName);
+                    }
+                    else if (beforeZone == opponentDeck && afterZone == opponentHand)
+                    {
+						var cardName = LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+
+                        if (after.IsRevealed())
+						{
+							// Tradeable and shuffled cards reuse the same ID for some reason which means the client knows what the opponent is drawing
+							// This should be handled server-side but until then (if ever), handling any card without a specific REVEALED tag as a
+							// unknown card draw should work
+							cardName = GetCardNameForZoneMovement(after);
+						}
+
+                        drawnOpponentCards.Add(cardName);
+                    }
+                    else if ((beforeZone == playerMinions || beforeZone == playerSecrets) && afterZone == playerHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else if ((beforeZone == opponentMinions || beforeZone == opponentSecrets) && afterZone == opponentHand)
+                    {
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND),
+                            LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                    else if (beforeZone == playerMinions && afterZone == opponentMinions)
+                    {
+                        var cardName = GetName(before);
+                        takenControlByOpponentCards.Add(cardName);
+                    }
+                    else if (beforeZone == opponentMinions && afterZone == playerMinions)
+                    {
+                        var cardName = GetName(before);
+                        takenControlByPlayerCards.Add(cardName);
+                    }
+                    else if (afterZone == opponentSecrets)
+                    {
+                        if (after.IsSecret())
+                        {
+                            var className = GameStrings.GetClassName(after.GetClass());
+                            castOpponentSecrets.Add(className);
+                        }
+
+                        // TODO: Handle quests, sidequests and questlines differently
+                    }
+                    else if (afterZone == playerSecrets)
+                    {
+                        if (after.IsSecret())
+                        {
+                            var cardName = GetName(after);
+                            castPlayerSecrets.Add(cardName);
+                        }
+
+                        // TODO: Handle quests, sidequests and questlines differently
+                    }
+                    else
+                    {
+                        var beforeZoneName = zoneNames[beforeZone];
+                        var afterZoneName = zoneNames[afterZone];
+                        var speech = new EntitySpeech(
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_FROM_ZONE_TO_ZONE, beforeZoneName, afterZoneName),
+                            LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_FROM_ZONE_TO_ZONE, beforeZoneName, afterZoneName)
+                        );
+                        speeches.Add(after, speech);
+                    }
+                }
+                else if (zoneNames.ContainsKey(afterZone))
+                {
+                    var toZoneName = zoneNames[afterZone];
+                    var speech = new EntitySpeech(
+                        LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE, toZoneName),
+                        LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE, toZoneName)
+                    );
+                    speeches.Add(after, speech);
+                }
+                else
+                {
+                    var speech = new EntitySpeech(
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC),
+                        LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC)
+                    );
+                    speeches.Add(after, speech);
+                }
+            }
+
+            var groupedMovementSpeeches = GroupSpeeches(entities, groups, speeches, false);
+
+            InsertPlayerInducedZoneMovements(ret, drawnPlayerCards, LocalizationKey.GAMEPLAY_PLAYER_DREW_CARDS);
+            InsertPlayerInducedZoneMovements(ret, drawnOpponentCards, LocalizationKey.GAMEPLAY_OPPONENT_DREW_CARDS);
+            InsertPlayerInducedZoneMovements(ret, discardedPlayerCards, LocalizationKey.GAMEPLAY_PLAYER_DISCARDED_CARDS);
+            InsertPlayerInducedZoneMovements(ret, discardedOpponentCards, LocalizationKey.GAMEPLAY_OPPONENT_DISCARDED_CARDS);
+            InsertPlayerInducedZoneMovements(ret, takenControlByPlayerCards, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_PLAYER);
+            InsertPlayerInducedZoneMovements(ret, takenControlByOpponentCards, LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_OPPONENT);
+            InsertPlayerInducedZoneMovements(ret, castPlayerSecrets, LocalizationKey.GAMEPLAY_PLAYER_CAST_SECRET);
+            InsertOpponentSecretMovements(ret, castOpponentSecrets);
+
+            ret.AddRange(groupedMovementSpeeches);
+
+            return ret;
+        }
+
+        private static void InsertOpponentSecretMovements(List<string> ret, List<string> castOpponentSecrets)
+        {
+            if (castOpponentSecrets.Count == 1)
+            {
+                InsertZoneMovements(ret, castOpponentSecrets, LocalizationKey.GAMEPLAY_OPPONENT_CAST_SECRET, LocalizationKey.GAMEPLAY_OPPONENT_CAST_N_SECRETS);
+            }
+            else if (castOpponentSecrets.Count > 1)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CAST_N_SECRETS, castOpponentSecrets.Count));
+            }
+        }
+
+        private static Zone GetZone(Entity entity)
+        {
+            var controller = entity.GetController();
+
+            switch(entity.GetZone())
+            {
+                case TAG_ZONE.PLAY:
+                    return controller.GetBattlefieldZone();
+                case TAG_ZONE.DECK:
+                    return controller.GetDeckZone();
+                case TAG_ZONE.HAND:
+                    return controller.GetHandZone();
+                case TAG_ZONE.GRAVEYARD:
+                    return controller.GetGraveyardZone();
+                case TAG_ZONE.SECRET:
+                    return controller.GetSecretZone();
+                default:
+                    return null;
+            }
+        }
+
+        private static void InsertZoneMovements(List<string> ret, List<string> cards, LocalizationKey singularKey, LocalizationKey pluralKey)
+        {
+            if (cards.Count == 0)
+            {
+                return;
+            }
+
+            ret.Add(FormatZoneMovementText(cards, singularKey, pluralKey));
+        }
+
+        private static void InsertPlayerInducedZoneMovements(List<string> ret, List<string> cards, LocalizationKey key)
+        {
+            if (cards.Count == 0)
+            {
+                return;
+            }
+
+            var counts = new Dictionary<string, int>();
+            foreach (var card in cards)
+            {
+                if (!counts.ContainsKey(card))
+                {
+                    counts.Add(card, 1);
+                }
+                else
+                {
+                    counts[card]++;
+                }
+            }
+
+            var cardNames = HumanizeNames(cards, counts);
+
+            ret.Add(LocalizationUtils.Format(key, cardNames));
+        }
+
+        private static string GetCardNameForZoneMovement(Entity entity)
+        {
+            if (entity.GetCardType() != TAG_CARDTYPE.INVALID)
+            {
+                return GetEntityName(entity);
+            }
+            else
+            {
+                return LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+            }
+        }
+
+        private static Dictionary<Entity, EntitySpeech> GetTransformedEntitySpeeches(List<EntityDiff> transformedEntities)
+        {
+            var ret = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            foreach (var entity in transformedEntities)
+            {
+                ret[entity.GetAfterEntity()] = entity.GetTransformedSpeech();
+            }
+
+            return ret;
+        }
+
+        private static Dictionary<Entity, EntitySpeech> GetDeadEntitySpeeches(List<EntityDiff> deadEntities)
+        {
+            var ret = new Dictionary<Entity, EntitySpeech>(new EntityComparer());
+
+            foreach (var entity in deadEntities)
+            {
+                ret[entity.GetAfterEntity()] = entity.GetDeathSpeech();
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(List<Entity> list, Entity entity)
+        {
+            var ret = new List<Entity>(list.Count + 1);
+            ret.AddRange(list);
+            ret.Add(entity);
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(List<Entity> l1, List<Entity> l2)
+        {
+            var ret = new List<Entity>(l1.Count + l2.Count);
+            ret.AddRange(l1);
+            ret.AddRange(l2);
+            return ret;
+        }
+
+        private static List<Entity> ConcatEntities(Entity e1, Entity e2)
+        {
+            var ret = new List<Entity>(2);
+            ret.Add(e1);
+            ret.Add(e2);
+            return ret;
+        }
+
+        private static void DebugEntityDiffs(List<EntityDiff> entityDiffs)
+        {
+            AccessibilityUtils.LogDebug("DebugEntityDiffs start");
+            foreach (var diff in entityDiffs)
+            {
+                var rawDiff = diff.GetRawDiff();
+                if (rawDiff.Count > 0)
+                {
+                    AccessibilityUtils.LogDebug($"DBG {diff.GetAfterEntity().GetName()}:");
+                    foreach (var entry in rawDiff)
+                    {
+                        AccessibilityUtils.LogDebug($"DBG {entry}");
+                    }
+                }
+            }
+        }
+
+        internal static string DescribeDiff(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var lines = new List<string>();
+
+            // Handle starting turn when the game has just been created
+            if (before == null && after != null && after.m_gameCreated)
+            {
+                // TODO: describer already has logic for this as well and Hogger is weird. Need to think
+                return null;
+            }
+
+            if (before == null || after == null || !before.m_gameCreated || !after.m_gameCreated)
+            {
+                return null;
+            }
+
+            var sourceEntity = taskList.GetSourceEntity();
+
+            AccessibilityUtils.LogDebug($"DBG Describing diff. sourceEntity={sourceEntity}");
+            AccessibilityUtils.LogDebug(Environment.StackTrace);
+            AccessibilityUtils.LogDebug("DebugDiff done");
+
+            lines.AddRange(GetQuestProgressChanges(before, after));
+
+            lines.AddRange(GetHeroChanges(before, after));
+
+            lines.AddRange(GetSpeechLines(taskList, before, after));
+
+            // Turn stuff. At the end so we describe any pending triggers before this (done when NEXT_STEP = MAIN_START)
+            if (before.m_step != after.m_step && after.m_step == TAG_STEP.MAIN_START && after.m_currentPlayer == GameState.Get().GetFriendlySidePlayer())
+            {
+                // TODO: Doing this in powerlist describer now to see if it makes more sense to sync up with the animation
+                //lines.Add($"You have {after.m_playerAvailableResources} mana");
+            }
+            else if (after.m_step > TAG_STEP.MAIN_START && after.m_step < TAG_STEP.MAIN_END)
+            {
+                lines.AddRange(GetResourceChanges(before, after));
+            }
+
+            lines.AddRange(GetSpellpowerChanges(before, after));
+
+            return CombineLines(lines);
+        }
+
+        private static List<string> GetSpellpowerChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            if (before.m_playerSpellpower < after.m_playerSpellpower)
+            {
+                var amt = after.m_playerSpellpower - before.m_playerSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_SPELL_DAMAGE, amt));
+            }
+            else if (after.m_playerSpellpower < before.m_playerSpellpower)
+            {
+                var amt = before.m_playerSpellpower - after.m_playerSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_LOST_SPELL_DAMAGE, amt));
+            }
+
+            if (before.m_opponentSpellpower < after.m_opponentSpellpower)
+            {
+                var amt = after.m_opponentSpellpower - before.m_opponentSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_SPELL_DAMAGE, amt));
+            }
+            else if (after.m_opponentSpellpower < before.m_opponentSpellpower)
+            {
+                var amt = before.m_opponentSpellpower - after.m_opponentSpellpower;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_LOST_SPELL_DAMAGE, amt));
+            }
+
+            return ret;
+        }
+
+        private static string CombineLines(List<string> lines)
+        {
+            var sb = new StringBuilder();
+
+            foreach (var line in lines)
+            {
+                if (sb.Length > 0)
+                {
+                    sb.Append(". ");
+                }
+
+                sb.Append(line);
+            }
+
+            return sb.ToString();
+        }
+
+        private static List<string> GetQuestProgressChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            // Note: there can only be 1 progress at once since this is part of a quest trigger
+
+            foreach (var entity in after.m_entities)
+            {
+                if (entity.IsQuest() || entity.IsSideQuest() || entity.IsQuestline())
+                {
+                    var beforeEntity = before.GetEntity(entity.GetEntityId());
+
+                    if (beforeEntity != null)
+                    {
+                        var beforeProgress = AccessibleCardUtils.GetQuestProgressLine(beforeEntity);
+                        var afterProgress = AccessibleCardUtils.GetQuestProgressLine(entity);
+
+                        if (!beforeProgress.Equals(afterProgress))
+                        {
+                            ret.Add(afterProgress);
+                        }
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetHeroChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            AddHeroChangeIfNeeded(ret, before.m_playerHero, after.m_playerHero, true);
+            AddHeroChangeIfNeeded(ret, before.m_opponentHero, after.m_opponentHero, false);
+
+            return ret;
+        }
+
+        private static void AddHeroChangeIfNeeded(List<string> ret, Entity heroBefore, Entity heroAfter, bool isFriendlyHero)
+        {
+            if (heroBefore.GetEntityId() != heroAfter.GetEntityId())
+            {
+                var newHeroName = heroAfter.GetName();
+                var translationKey = isFriendlyHero ? LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_CHANGED : LocalizationKey.GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_CHANGED;
+
+                ret.Add(LocalizationUtils.Format(translationKey, newHeroName));
+            }
+        }
+
+        private static List<string> GetResourceChanges(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<string>();
+
+            var playerAvailableResourcesDiff = after.m_playerAvailableResources - before.m_playerAvailableResources;
+            var playerResourcesDiff = after.m_playerResources - before.m_playerResources;
+            var opponentAvailableResourcesDiff = after.m_opponentAvailableResources - before.m_opponentAvailableResources;
+            var opponentResourcesDiff = after.m_opponentResources - before.m_opponentResources;
+
+            if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+				ret.AddRange(GetResourceChanges(true, playerAvailableResourcesDiff, playerResourcesDiff));
+				ret.AddRange(GetResourceChanges(false, opponentAvailableResourcesDiff, opponentResourcesDiff));
+			}
+
+			if (playerAvailableResourcesDiff != 0)
+			{
+                AccessibleGameplay.Get().OnPlayerAvailableResourcesChanged(before.m_playerAvailableResources, after.m_playerAvailableResources);
+			}
+
+            return ret;
+        }
+
+        private static List<string> GetResourceChanges(bool friendlySidePlayer, int availableResourcesDiff, int resourcesDiff)
+        {
+            var ret = new List<string>();
+
+            if (resourcesDiff > 0)
+            {
+                if (availableResourcesDiff > 0)
+                {
+                    if (availableResourcesDiff >= resourcesDiff)
+                    {
+                        if (friendlySidePlayer)
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_MANA, availableResourcesDiff));
+                        }
+                        else
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_MANA, availableResourcesDiff));
+                        }
+                    }
+                    else
+                    {
+                        var numEmptyManaCrystals = resourcesDiff - availableResourcesDiff;
+
+                        if (friendlySidePlayer)
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS, availableResourcesDiff, numEmptyManaCrystals));
+                        }
+                        else
+                        {
+                            ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS, availableResourcesDiff, numEmptyManaCrystals));
+                        }
+                    }
+                }
+                else
+                {
+                    if (friendlySidePlayer)
+                    {
+                        ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_EMPTY_MANA_CRYSTALS, resourcesDiff));
+                    }
+                    else
+                    {
+                        ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_EMPTY_MANA_CRYSTALS, resourcesDiff));
+                    }
+                }
+            }
+            else if (availableResourcesDiff > 0)
+            {
+                if (friendlySidePlayer)
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_GAINED_MANA, availableResourcesDiff));
+                }
+                else
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_OPPONENT_GAINED_MANA, availableResourcesDiff));
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<string> GetSpeechLines(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+        {
+            return GetDiffSpeech(taskList.GetSourceEntity(), before, after);
+        }
+
+        private static List<EntityDiff> GetAffectedEntities(List<EntityDiff> entityDiffs)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var diff in entityDiffs)
+            {
+                if (diff.HasChanges())
+                {
+                    ret.Add(diff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> CreateEntityDiffs(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityBefore in before.m_entities)
+            {
+                var entityAfter = after.GetEntity(entityBefore.GetEntityId());
+
+                if (entityAfter != null)
+                {
+                    ret.Add(new EntityDiff(entityBefore, entityAfter, before, after));
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetMovedEntities(Entity sourceEntity, List<EntityDiff> entityDiffs, List<Entity> entitiesAfterMovement)
+        {
+            var ret = new List<EntityDiff>();
+
+            // Must iterate through entitiesAfterMovement or they will be out of order. e.g. drawing 2 cards means drawing the last 2 from your deck into your hand in rev order
+            Dictionary<Entity, EntityDiff> entityAfterToEntityDiff = new Dictionary<Entity, EntityDiff>();
+
+            foreach (var diff in entityDiffs)
+            {
+                if (!entityAfterToEntityDiff.ContainsKey(diff.GetAfterEntity()))
+                {
+                    entityAfterToEntityDiff.Add(diff.GetAfterEntity(), diff);
+                }
+                else
+                {
+                    Log.Accessibility.Print($"Ignored duplicate entity in GetMovedEntities: {diff.GetAfterEntity().GetName()}");
+                }
+            }
+
+            var orderedEntityDiffs = new List<EntityDiff>(entityDiffs.Count);
+
+            foreach (var entity in entitiesAfterMovement)
+            {
+                if (entityAfterToEntityDiff.ContainsKey(entity))
+                {
+                    orderedEntityDiffs.Add(entityAfterToEntityDiff[entity]);
+                }
+            }
+
+            foreach (var diff in orderedEntityDiffs)
+            {
+                if (sourceEntity != null && diff.GetEntityId() == sourceEntity.GetEntityId())
+                {
+                    // Ignore source as we handle explicit movement outside (in the powerTaskList describer)
+                    continue;
+                }
+
+                if (diff.MovedZone())
+                {
+                    ret.Add(diff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> GetDestroyedEntities(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            List<Entity> ret = new List<Entity>();
+
+            foreach (var entityBefore in before.m_entities)
+            {
+                if (after.GetEntity(entityBefore.GetEntityId()) == null)
+                {
+                    ret.Add(entityBefore);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> GetNewEntities(AccessibleInGameState before, AccessibleInGameState after)
+        {
+            List<Entity> ret = new List<Entity>();
+
+            foreach (var entityAfter in after.m_entities)
+            {
+                var entityBefore = before.GetEntity(entityAfter.GetEntityId());
+                if (entityBefore == null || entityBefore.GetZone() == TAG_ZONE.SETASIDE && entityBefore.GetZone() != entityAfter.GetZone())
+                {
+                    ret.Add(entityAfter);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<EntityDiff> GetTransformedEntities(List<EntityDiff> affectedEntities)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityDiff in affectedEntities)
+            {
+                if (entityDiff.HasTransformed() && IsInRelevantNarrationZone(entityDiff.GetAfterEntity()))
+                {
+                    ret.Add(entityDiff);
+                }
+            }
+
+            return ret;
+        }
+
+		private static bool IsInRelevantNarrationZone(Entity entity)
+		{
+            // Some zones would be narrated otherwise
+            // e.g. Dredge "transforms" entities in the DECK zone (since the related ID goes from INVALID to a named entity)
+            var zone = entity.GetZone();
+
+            return zone != TAG_ZONE.DECK && zone != TAG_ZONE.SETASIDE && zone != TAG_ZONE.GRAVEYARD && zone != TAG_ZONE.REMOVEDFROMGAME;
+		}
+
+		private static List<EntityDiff> GetJustDiedEntities(List<EntityDiff> affectedEntities)
+        {
+            var ret = new List<EntityDiff>();
+
+            foreach (var entityDiff in affectedEntities)
+            {
+                if (entityDiff.HasDied() && entityDiff.GetDeathSpeech().SingularSpeech.Length > 0) // Length > 0 is because of replacing weapons e.g. equipping 1 wicked knife when 1 already exists
+                {
+                    ret.Add(entityDiff);
+                }
+            }
+
+            return ret;
+        }
+
+        private static List<Entity> Clone(List<Entity> entities)
+        {
+            List<Entity> ret = new List<Entity>(entities.Count);
+
+            foreach (var entity in entities)
+            {
+                ret.Add(entity.CloneForAccessibility());
+            }
+
+            return ret;
+        }
+
+        private static Entity Clone(Entity entity)
+        {
+            if (entity == null)
+            {
+                return null;
+            }
+
+            return entity.CloneForAccessibility();
+        }
+
+        private static List<Entity> GetEntitiesFromZone(Zone zone)
+        {
+            var ret = new List<Entity>();
+            var cards = zone.GetCards();
+
+            if (cards == null)
+            {
+                return ret;
+            }
+
+            foreach (var card in cards)
+            {
+                ret.Add(card.GetEntity());
+            }
+
+            return ret;
+        }
+
+        #region Weapon stuff
+
+        private static HashSet<Entity> s_heroWeaponBroke = new HashSet<Entity>(new EntityComparer());
+        private static HashSet<Entity> s_heroSheathedWeapon = new HashSet<Entity>(new EntityComparer());
+        private static HashSet<Entity> s_heroUnsheathedWeapon = new HashSet<Entity>(new EntityComparer());
+
+        internal static void MarkWeaponUnsheathed(Entity hero)
+        {
+            AccessibilityUtils.LogDebug($"WEP MarkWeaponUnsheathed: {hero}");
+            s_heroUnsheathedWeapon.Add(hero);
+        }
+
+        internal static void MarkWeaponSheathed(Entity hero)
+        {
+            AccessibilityUtils.LogDebug($"WEP MarkWeaponSheathed: {hero}");
+            s_heroSheathedWeapon.Add(hero);
+        }
+
+
+        internal static void Reset()
+        {
+            s_heroWeaponBroke.Clear();
+            s_heroSheathedWeapon.Clear();
+            s_heroUnsheathedWeapon.Clear();
+        }
+
+        #endregion
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs b/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs
new file mode 100644
index 0000000..786a224
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleInputMgr.cs
@@ -0,0 +1,258 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleInputMgr : MonoBehaviour
+    {
+        private static bool[] m_setMouseButtonDown = new bool[3];
+
+        private static Vector3 m_setMousePosition = Vector3.zero;
+
+        private void LateUpdate()
+        {
+            AccessibleUnityInput.Get().SetMousePosition(m_setMousePosition);
+
+            for (int button = 0; button < m_setMouseButtonDown.Length; button++)
+            {
+                AccessibleUnityInput.Get().SetMouseButtonDown(button, m_setMouseButtonDown[button]);
+                m_setMouseButtonDown[button] = false; // TODO: Would have to add a lot more logic if we wanted to hold/drag/etc. but don't think that'll be needed
+            }
+
+            if (AccessibleKey.TOGGLE_ACCESSIBILITY.IsPressed())
+            {
+                ToggleAccessibility();
+            }
+
+            if (AccessibleKey.SILENTLY_ENABLE_ACCESSIBILITY.IsPressed())
+            {
+                SilentlyEnableAccessibility();
+            }
+
+            if (AccessibleKey.SILENTLY_DISABLE_ACCESSIBILITY.IsPressed())
+            {
+                SilentlyDisableAccessibility();
+            }
+
+            // Debug stuff
+            if (HearthstoneAccessConstants.DEV_MODE && Input.GetKeyUp(KeyCode.F6))
+            {
+                Vector3 dbgMousePos = Input.mousePosition;
+                AccessibilityUtils.LogDebug($"[DBG] Mouse position is {dbgMousePos}");
+            }
+        }
+
+        private void ToggleAccessibility()
+        {
+            AccessibleUnityInput.Get().ToggleEnabled();
+            AccessibilityMgr.ToggleEnabled();
+        }
+
+        private void SilentlyEnableAccessibility()
+        {
+            AccessibleUnityInput.Get().SetEnabled();
+            AccessibilityMgr.SetEnabled();
+        }
+
+        private void SilentlyDisableAccessibility()
+        {
+            AccessibleUnityInput.Get().SetDisabled();
+            AccessibilityMgr.SetDisabled();
+        }
+
+        private static void ClickLeftMouseButtonImpl()
+        {
+            AccessibilityUtils.LogDebug($"[DBG] Clicked left mouse at {m_setMousePosition}");
+            m_setMouseButtonDown[0] = true;
+        }
+
+        public static void ClickLeftMouseButton()
+        {
+            ClickLeftMouseButtonImpl();
+        }
+
+        public static void ClickLeftMouseButton(Component component)
+        {
+            MoveMouseTo(component);
+            ClickLeftMouseButtonImpl();
+        }
+
+        private static void ClickRightMouseButtonImpl()
+        {
+            AccessibilityUtils.LogDebug($"[DBG] Clicked right mouse at {m_setMousePosition}");
+            m_setMouseButtonDown[1] = true;
+        }
+
+        internal static void ClickRightMouseButton()
+        {
+            ClickRightMouseButtonImpl();
+        }
+
+        private static void ClickMiddleMouseButton()
+        {
+            m_setMouseButtonDown[2] = true;
+        }
+
+        private static void SetMousePosition(Vector3 pos)
+        {
+            if (pos != m_setMousePosition)
+			{
+				AccessibilityUtils.LogDebug($"SetMousePosition{pos}");
+			}
+			m_setMousePosition = pos;
+        }
+
+        internal static void MoveMouseTo(Component component)
+        {
+            if (component == null)
+            {
+                return;
+            }
+            MoveMouseToTransform(component.transform);
+        }
+
+        internal static Vector3 GetMousePosition(Component component)
+        {
+            return GetMousePosition(component.transform);
+        }
+
+        internal static void MoveMouseToTransform(Transform transform)
+        {
+            if (transform == null)
+            {
+                return;
+            }
+
+            MoveMouseToWorldPosition(transform.position);
+        }
+
+        internal static Vector3 GetMousePosition(Transform transform)
+        {
+            return GetMousePosition(transform.position);
+        }
+
+        public static void ClickCenterOfScreen()
+        {
+            MoveMouseToCenterOfScreen();
+            ClickLeftMouseButton();
+        }
+
+        public static void RightClickCenterOfScreen()
+        {
+            MoveMouseToCenterOfScreen();
+            ClickRightMouseButton();
+        }
+
+        internal static void MoveMouseToCenterOfScreen()
+        {
+            var center = new Vector3(Screen.width / 2, Screen.height / 2);
+            SetMousePosition(center);
+        }
+
+        internal static void MoveMouseToWorldPosition(Vector3 pos)
+        {
+            Vector3 screenPos = Camera.main.WorldToScreenPoint(pos);
+            screenPos.z = 0;
+            SetMousePosition(screenPos);
+        }
+
+        internal static Vector3 GetMousePosition(Vector3 worldPos)
+        {
+            Vector3 screenPos = Camera.main.WorldToScreenPoint(worldPos);
+            screenPos.z = 0;
+            return screenPos;
+        }
+
+        internal static void HideMouse()
+        {
+            SetMousePosition(Vector3.zero);
+        }
+
+        internal static bool IsMouseHidden()
+		{
+            return m_setMousePosition == Vector3.zero;
+		}
+
+        internal static void Click(Component component)
+        {
+            if (component == null)
+            {
+                return;
+            }
+            Click(component.transform);
+        }
+
+        internal static void Click(GameObject gameObject)
+        {
+            if (gameObject == null)
+            {
+                return;
+            }
+            Click(gameObject.transform);
+        }
+
+        internal static void Click(Transform transform)
+        {
+            if (transform == null)
+            {
+                return;
+            }
+            MoveMouseToTransform(transform);
+            ClickLeftMouseButton();
+        }
+
+        internal static void Click(Vector3 worldPosition)
+        {
+            SetMousePosition(worldPosition);
+            ClickLeftMouseButton();
+        }
+
+        private static bool m_holdingAnyKeyDown;
+
+        internal static bool AnyKeyUp()
+        {
+            var ret = false;
+
+            if (Input.anyKey)
+            {
+                m_holdingAnyKeyDown = true;
+            }
+
+            if (!Input.anyKey)
+            {
+                if (m_holdingAnyKeyDown)
+                {
+                    ret = true;
+                }
+
+                m_holdingAnyKeyDown = false;
+            }
+
+            return ret;
+        }
+
+        internal static int? TryGetPressedNumKey()
+        {
+            for (var i = 0; i <= 9; i++)
+            {
+                if (Input.GetKeyUp(KeyCode.Alpha0 + i))
+                {
+                    if (i == 0)
+                    {
+                        return 10;
+                    } else
+                    {
+                        return i;
+                    }
+                }
+            }
+
+            return null;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleItem.cs b/Assembly-CSharp/Accessibility/AccessibleItem.cs
new file mode 100644
index 0000000..d81874c
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleItem.cs
@@ -0,0 +1,187 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public abstract class AccessibleItem : AccessibleElement
+    {
+        // TODO: consider having short vs long descriptions in the future?
+        private string[] m_lines;
+
+        private int m_curLine;
+
+        protected int m_pageTwoIndex; // Used for quickly jumping to related cards (e.g. colossal)
+
+        private Action m_finishReadAction;
+
+        public AccessibleItem(AccessibleComponent parent) : this(parent, 0) { }
+
+        public AccessibleItem(AccessibleComponent parent, int startReadingFromLine) : base(parent)
+        {
+            m_curLine = startReadingFromLine;
+        }
+
+        private void SetupLines()
+        {
+            var lines = GetLines();
+            m_lines = lines.ToArray();
+        }
+
+        internal abstract List<string> GetLines();
+
+        internal void ReadLine()
+        {
+            SetupLines();
+            ReadLineImpl();
+        }
+
+        internal void ReadLine(int line)
+        {
+            SetupLines();
+            ReadLineImpl(line);
+        }
+
+        internal string GetLine(int line)
+        {
+            SetupLines();
+
+            if (line >= m_lines.Length)
+            {
+                return "";
+            }
+
+            return m_lines[line];
+        }
+
+        private void ReadLineImpl()
+        {
+            ReadLineImpl(m_curLine);
+        }
+
+        private void ReadLineImpl(int line)
+        {
+            if (line >= m_lines.Length)
+            {
+                return;
+            }
+
+            Output(m_lines[line]);
+        }
+
+        internal void ReadNextLine()
+        {
+            SetupLines();
+
+            if (IncLine(1))
+            {
+                ReadLineImpl();
+            }
+        }
+
+        internal void ReadPrevLine()
+        {
+            SetupLines();
+            if (IncLine(-1))
+            {
+                ReadLineImpl();
+            }
+        }
+
+        internal void Reset()
+        {
+            m_curLine = 0;
+        }
+
+        private bool IncLine(int inc)
+        {
+            m_curLine += inc;
+
+            if (m_curLine < 0)
+            {
+                m_curLine = 0;
+                return false;
+            }
+            else if (m_curLine >= m_lines.Length)
+            {
+                m_curLine = m_lines.Length - 1;
+                return false;
+            }
+
+            if (m_curLine == m_lines.Length - 1)
+            {
+                OnFinishReading();
+            }
+
+            return true; // new line
+        }
+
+        private void OnFinishReading()
+        {
+            if (m_finishReadAction != null)
+            {
+                m_finishReadAction();
+                m_finishReadAction = null;
+            }
+        }
+
+        internal void RegisterFinishReadListener(Action action)
+        {
+            m_finishReadAction = action;
+        }
+
+        internal void ReadAllLines()
+        {
+            if (m_curLine == 0)
+            {
+                SetupLines();
+            }
+
+            while (m_curLine < m_lines.Length - 1)
+            {
+                ReadLineImpl();
+                IncLine(1); // This has a guard so we need to read after as well
+            }
+
+            ReadLineImpl();
+        }
+
+        internal virtual bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.READ_NEXT_LINE.IsPressed())
+            {
+                ReadNextLine();
+                return true;
+            }
+            else if (AccessibleKey.READ_PREV_LINE.IsPressed())
+            {
+                ReadPrevLine();
+                return true;
+            }
+            else if (AccessibleKey.READ_CUR_LINE.IsPressed())
+            {
+                ReadLineImpl();
+                return true;
+            }
+            else if (AccessibleKey.READ_TO_END.IsPressed())
+            {
+                ReadAllLines();
+                return true;
+            }
+            else if (m_pageTwoIndex > 0)
+			{
+                if (AccessibleKey.READ_NEXT_PAGE.IsPressed())
+				{
+                    m_curLine = m_pageTwoIndex;
+                    ReadLine();
+				}
+                else if (AccessibleKey.READ_PREV_PAGE.IsPressed())
+				{
+                    m_curLine = 0;
+                    ReadLine();
+				}
+			}
+
+            return false;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleJournal.cs b/Assembly-CSharp/Accessibility/AccessibleJournal.cs
new file mode 100644
index 0000000..1de5af8
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleJournal.cs
@@ -0,0 +1,1188 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using UnityEngine;
+using Hearthstone.DataModels;
+using Hearthstone.Progression;
+using Hearthstone.UI;
+
+namespace Accessibility
+{
+    class AccessibleJournal : AccessibleUI
+    {
+        private enum State
+        {
+            LOADING,
+            MAIN_MENU,
+            QUESTS_MENU,
+            READING_DAILY_QUESTS,
+            READING_WEEKLY_QUESTS,
+            REWARDS_TRACK_MENU,
+            CLAIMING_REWARD,
+            CHOOSING_REWARD,
+            BROWSING_CHOOSE_ONE_DECK_REWARD,
+            CONFIRMING_DECK_CHOICE,
+            ACHIEVEMENT_CATEGORY_MENU,
+            ACHIEVEMENT_SUBCATEGORY_MENU,
+            ACHIEVEMENT_LIST,
+            VIEWING_ACHIEVEMENT,
+            CLAIMING_ACHIEVEMENT,
+            VIEWING_EVENT,
+            EVENT_REWARD_TRACK,
+            CHOOSING_EVENT_REWARD_TRACK,
+            EVENT_QUESTS,
+            CLAIMING_EVENT_REWARD
+        };
+        private int prevPage = -1;
+        private State m_curState = State.LOADING;
+        private Widget m_JournalWidget;
+
+        private AccessibleMenu m_mainMenu;
+
+        // Quests
+        private AccessibleMenu m_questsMenu;
+        private AccessibleListOfItems<AccessibleQuest> m_dailyQuests;
+        private AccessibleListOfItems<AccessibleQuest> m_weeklyQuests;
+
+        // Rewards Track
+        private AccessibleMenu m_rewardsTrackMenu;
+        private Assets.Global.RewardTrackType m_rewardTrackType;
+
+        //achievement menus
+        private AccessibleMenu m_achievementTabSelectorMenu;
+        private AccessibleMenu m_achievementSubcategoryMenu;
+        private AccessibleListOfItems<AccessibleMultilineText> m_achievementListMenu;
+        private AccessibleMenu m_achievementViewer;
+
+        //event menus
+        private AccessibleMenu m_eventMenu;
+        private AccessibleHorizontalMenu<AccessibleMultilineText> m_chooseRewardTrackMenu;
+        private AccessibleListOfItems<AccessibleQuest> m_eventQuests;
+
+        private static AccessibleJournal s_instance = new AccessibleJournal();
+
+        internal static AccessibleJournal Get()
+        {
+            return s_instance;
+        }
+
+        public void OnJournalOpened(Widget widget, Assets.Global.RewardTrackType rewardTrackType)
+        {
+            m_rewardTrackType = rewardTrackType;
+
+            Reset();
+
+            m_JournalWidget = widget;
+
+            AccessibilityMgr.ShowUI(this);
+
+            ReadJournal();
+        }
+
+        private void Reset()
+        {
+            m_mainMenu = null;
+            m_questsMenu = null;
+            m_dailyQuests = null;
+            m_weeklyQuests = null;
+            m_curState = State.LOADING;
+        }
+
+        public void OnJournalClosed()
+        {
+            AccessibilityMgr.HideUI(this);
+        }
+
+        internal void ReadJournal()
+        {
+            if (m_rewardTrackType == Assets.Global.RewardTrackType.BATTLEGROUNDS)
+            {
+                ReadBattlegroundsJournal();
+            }
+            else if (m_rewardTrackType == Assets.Global.RewardTrackType.APPRENTICE)
+            {
+                ReadApprenticeJournal();
+            }
+            else
+            {
+                ReadGlobalJournal();
+            }
+        }
+
+        private void ReadBattlegroundsJournal()
+        {
+            return;
+
+            // TODO
+            /*var buttonManager = GetButtonManager();
+            var questButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "QuestButton/BattlegroundsJournalButtonTab/Root");
+            var rewardButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "RewardButton/BattlegroundsJournalButtonTab/Root");
+
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_JOURNAL), CloseJournal);
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_QUESTS_TITLE"), () =>  AccessibleWidgetUtils.ClickButton(questButton));
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_BACON_SEASONREWARDS_TITLE"), ReadRewardsTrack);
+
+            ReadMainMenu();*/
+        }
+
+        private void ReadGlobalJournal()
+        {
+            var buttonManager = GetButtonManager();
+            var questButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "QuestButton/JournalButtonTab/Root");
+            var rewardButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "RewardButton/JournalButtonTab/Root");
+            var achievementButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "AchievementButton/JournalButtonTab/Root");
+            var profileButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "ProfileButton/JournalButtonTab/Root");
+            var eventButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "Events_WaxSeal");
+
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_JOURNAL), CloseJournal);
+            if (SpecialEventManager.Get().GetCurrentSpecialEvent() != null)
+            {
+                m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_EVENT_TAB_TITLE"), () => SwitchToTab(JournalTrayDisplay.JournalTab.Event, eventButton));
+            }
+
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_QUESTS_TITLE"), () => SwitchToTab(JournalTrayDisplay.JournalTab.Quest, questButton));
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_REWARDS_TITLE"), ReadRewardsTrack);
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_ACHIEVEMENTS_TITLE"), () => SwitchToTab(JournalTrayDisplay.JournalTab.Achievment, achievementButton));
+
+            ReadMainMenu();
+        }
+
+        private void ReadApprenticeJournal()
+        {
+            var buttonManager = GetButtonManager();
+            var tavernGuideButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "TavernGuideButton/JournalButtonTab/Root");
+            var questButton = AccessibleWidgetUtils.GetPegUIElement(buttonManager, "QuestButton/JournalButtonTab/Root");
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_JOURNAL), CloseJournal);
+            if (CanSeeTavernGuide())
+            {
+                m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_TAVERN_GUIDE_TITLE"), () => SwitchToTab(JournalTrayDisplay.JournalTab.TavernGuide, tavernGuideButton));
+            }
+            else if (GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.PLAYER_FLAGS, GameSaveKeySubkeyId.PLAYER_FLAGS_HAS_COMPLETED_TAVERN_GUIDE, out long value) && value == 1)
+            {
+                m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_QUESTS_TITLE"), () =>  SwitchToTab(JournalTrayDisplay.JournalTab.Quest, questButton));
+            }
+
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_REWARDS_TITLE"), ReadRewardsTrack);
+            ReadMainMenu();
+        }
+
+        private void SwitchToTab(JournalTrayDisplay.JournalTab target, PegUIElement switchButton)
+        {
+            var currentTab = m_JournalWidget.GetComponentInChildren<JournalTrayDisplay>().GetActiveJournalTab();
+            if (currentTab == target)
+            {
+                m_JournalWidget.StartCoroutine(OnTabChanged(m_JournalWidget.GetDataModel<JournalMetaDataModel>()));
+                return;
+            }
+            AccessibleWidgetUtils.ClickButton(switchButton);
+        }
+
+        private bool CanSeeTavernGuide()
+        {
+            if (RewardTrackManager.Get().GetApprenticeTrackLevel() <= 2)
+            {
+                return !RewardTrackManager.Get().HasAnyUnclaimedApprenticeRewards();
+            }
+            return TavernGuideManager.Get().IsTavernGuideActive();
+        }
+
+        private void ReadMainMenu()
+        {
+            m_mainMenu.StartReading();
+            m_curState = State.MAIN_MENU;
+        }
+
+        internal IEnumerator OnTabChanged(JournalMetaDataModel data)
+        {
+            if (prevPage == data.TabIndex) yield return null;
+            prevPage = data.TabIndex;
+            AccessibilityUtils.LogDebug($"AccessibleJournal.OnTabChanged({data.TabIndex})");
+            if (data.TabIndex == 3) ReadAchievementCats();
+            if (data.TabIndex == 1)
+            {
+                ReadQuestLog();
+            }
+            if (data.TabIndex == 0)
+            {
+                m_curState = State.LOADING;
+                yield return new WaitForSeconds(1.3f);
+                ReadEventTab();
+
+            }
+            if (data.TabIndex == (int)JournalTrayDisplay.JournalTab.TavernGuide)
+            {
+                var tavernGuideDisplay = m_JournalWidget.GetComponentInChildren<TavernGuideTabDisplay>();
+                tavernGuideDisplay?.ReadTavernGuide();
+            }
+        }
+
+        #region Quests
+
+        private void ReadQuestLog()
+        {
+            var journalInnerTrayManager = GetJournalInnerTrayManager();
+            var questLog = AccessibleUnityUtils.GetChildObject(journalInnerTrayManager, "Root/QuestLog/QuestLog");
+
+            var dailySpecific = AccessibleUnityUtils.GetChildObject(questLog.gameObject, "Root/DailySpecific");
+            var weeklySpecific = AccessibleUnityUtils.GetChildObject(questLog.gameObject, "Root/WeeklySpecific");
+
+            var dailyQuestList = AccessibleUnityUtils.GetChildObject(dailySpecific, "DailyQuestList/QuestList");
+            var weeklyQuestList = AccessibleUnityUtils.GetChildObject(weeklySpecific, "WeeklyQuestList/QuestList");
+
+            var dailyTitle = AccessibleUnityUtils.GetChildObject(dailySpecific, "DailyTitle_Text");
+            var weeklyTitle = AccessibleUnityUtils.GetChildObject(weeklySpecific, "WeeklyTitle_Text");
+
+            var dailyQuestTiles = GetQuestTiles(dailyQuestList);
+            var weeklyQuestTiles = GetQuestTiles(weeklyQuestList);
+
+            var dailyQuests = CreateQuestsFromQuestTiles(dailyQuestTiles);
+            var weeklyQuests = CreateQuestsFromQuestTiles(weeklyQuestTiles);
+
+            if (dailyQuests.Count == 0 && weeklyQuests.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_QUEST_LOG_NO_QUESTS));
+                return;
+            }
+
+            if (!dailyTitle.activeInHierarchy)
+            {
+                dailyQuests.AddRange(weeklyQuests);
+                m_dailyQuests = new AccessibleListOfItems<AccessibleQuest>(this, dailyQuests);
+                ReadQuests(m_dailyQuests, State.READING_DAILY_QUESTS);
+            }
+            else
+            {
+                m_dailyQuests = new AccessibleListOfItems<AccessibleQuest>(this, dailyQuests);
+                m_weeklyQuests = new AccessibleListOfItems<AccessibleQuest>(this, weeklyQuests);
+
+                m_questsMenu = new AccessibleMenu(this, "", ReadJournal);
+                m_questsMenu.AddOption(GetQuestPoolName(dailyTitle), () => ReadQuests(m_dailyQuests, State.READING_DAILY_QUESTS));
+                m_questsMenu.AddOption(GetQuestPoolName(weeklyTitle), () => ReadQuests(m_weeklyQuests, State.READING_WEEKLY_QUESTS));
+
+                m_questsMenu.StartReading();
+                m_curState = State.QUESTS_MENU;
+            }
+        }
+
+        internal void OnQuestRerolled(Hearthstone.Progression.QuestTile questTile)
+        {
+            RereadQuestsAfterInteract();
+        }
+
+        private List<AccessibleQuest> CreateQuestsFromQuestTiles(List<Hearthstone.Progression.QuestTile> questTiles)
+        {
+            var ret = new List<AccessibleQuest>();
+
+            foreach (var questTile in questTiles)
+            {
+                ret.Add(new AccessibleQuest(this, questTile.GetQuestDataModel(), questTile));
+            }
+
+            return ret;
+        }
+
+        private void ReadQuests(AccessibleListOfItems<AccessibleQuest> quests, State state)
+        {
+            quests.StartReading();
+            m_curState = state;
+        }
+
+        private string GetQuestPoolName(GameObject titleGO)
+        {
+            var uberText = titleGO.GetComponent<UberText>();
+
+            if (uberText != null)
+            {
+                return GameStrings.Get(uberText.Text);
+            }
+
+            return "";
+        }
+
+        private List<Hearthstone.Progression.QuestTile> GetQuestTiles(GameObject questList)
+        {
+            var ret = new List<Hearthstone.Progression.QuestTile>();
+
+            if (questList == null)
+            {
+                return ret;
+            }
+
+            var root = questList.transform.Find("Root");
+
+            for (int i = 0; i < root.childCount; i++)
+            {
+                var child = root.GetChild(i);
+
+                var questTileGO = child.Find("QuestTile");
+
+                if (questTileGO != null)
+                {
+                    var questTile = questTileGO.GetComponent<Hearthstone.Progression.QuestTile>();
+
+                    if (questTile != null)
+                    {
+                        ret.Add(questTile);
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private void ReadQuestsOrJournal()
+        {
+            if (m_questsMenu != null)
+            {
+                m_questsMenu.StartReading();
+                m_curState = State.QUESTS_MENU;
+            }
+            else
+            {
+                ReadJournal();
+            }
+        }
+
+        internal void OnQuestAbandoned(Hearthstone.Progression.QuestTile questTile)
+        {
+            AccessibilityMgr.ShowUI(this); // Make it so we can output while the alert popup disappears
+            if (RefreshMenuAfterAbandonIfNeeded(m_dailyQuests, questTile) && m_dailyQuests.Count == 0)
+            {
+                ReadJournal();
+                return;
+            }
+            else if (RefreshMenuAfterAbandonIfNeeded(m_weeklyQuests, questTile) && m_weeklyQuests.Count == 0)
+            {
+                ReadJournal();
+                return;
+            }
+
+            RereadQuestsAfterInteract();
+        }
+
+        private bool RefreshMenuAfterAbandonIfNeeded(AccessibleListOfItems<AccessibleQuest> quests, Hearthstone.Progression.QuestTile abandonedQuest)
+        {
+            if (quests == null)
+            {
+                return false;
+            }
+
+            var questsBeforeAbandon = quests.Items;
+
+            var accessibleAbandonedQuest = questsBeforeAbandon.Find(q => q.GetQuestTile() == abandonedQuest);
+
+            if (accessibleAbandonedQuest != null)
+            {
+                quests.RemoveItem(accessibleAbandonedQuest);
+                return true;
+            }
+
+            return false;
+        }
+
+        internal void OnQuestAbandonCancel()
+        {
+            AccessibilityMgr.ShowUI(this); // Make it so we can output while the alert popup disappears
+            RereadQuestsAfterInteract();
+        }
+
+        private void RereadQuestsAfterInteract()
+        {
+            if (m_curState == State.READING_DAILY_QUESTS)
+            {
+                m_dailyQuests.StartReading();
+            }
+            else if (m_curState == State.READING_WEEKLY_QUESTS)
+            {
+                m_weeklyQuests.StartReading();
+            }
+        }
+
+        #endregion
+
+        private GameObject GetJournalInnerTrayManager()
+        {
+            return m_JournalWidget.transform.Find("Root/JournalInnerTrayManager/JournalInnerTrayManager").gameObject;
+        }
+
+        private GameObject GetButtonManager()
+        {
+            return m_JournalWidget.transform.Find("Root/ButtonManager").gameObject;
+        }
+
+        private void CloseJournal()
+        {
+            m_JournalWidget.TriggerEvent("HIDE");
+        }
+
+        #region eventTab
+
+        private void ReadEventTab(bool delay = true)
+        {
+            SpecialEventDataModel dataModel = SpecialEventManager.Get().GetEventDataModelForCurrentEvent();
+            m_curState = State.VIEWING_EVENT;
+            Transform t = OverlayUI.Get().transform.Find("UICanvasHeightScale/Center/ClosedEnvelopeParent Popup Bone/ClosedEnvelopeParent/ClosedEnvelope/ClosedEnvelope/Clickable");
+            if (t == null) eventMainMenu(dataModel);
+            else
+            {
+                PegUIElement letter = t.GetComponent<PegUIElement>();
+                if (letter != null)
+                {
+                    for (int x = 0; x < 6; x++)
+                    { // you have to try to click repeatedly until it works, 6 is usually enough times
+                        letter.TriggerRelease();
+                        letter.TriggerPress();
+                    }
+                    OverlayUI.Get().StartCoroutine(ReadOpenLetter(dataModel, letter));
+                }
+                else
+                {
+                    eventMainMenu(dataModel);
+                }
+            }
+        }
+        private IEnumerator ReadOpenLetter(SpecialEventDataModel dataModel, PegUIElement oldLetter)
+        {
+            yield return new WaitForSeconds(1.1f);
+            GameObject letter = OverlayUI.Get().transform.Find("UICanvasHeightScale/Center/LetterContentsParent Popup Bone/LetterContentsParent/LetterContents/EventLetterContents").gameObject;
+            AccessibleUnityUtils.DebugGameObject(letter);
+            UberText[] texts = letter.GetComponentsInChildren<UberText>();
+            foreach (UberText t in texts)
+            {
+                AccessibilityMgr.Output(null, GameStrings.Format(t.Text));
+            }
+            yield return new WaitForSeconds(0.7f);
+            PegUIElement[] buttons = letter.GetComponentsInChildren<PegUIElement>();
+            foreach (PegUIElement b in buttons)
+            {
+                for (var i = 0; i < 5; i++)
+                {
+                    b.TriggerRelease();
+                    b.TriggerPress();
+                }
+            }
+            eventMainMenu(dataModel);
+
+        }
+        private void eventMainMenu(SpecialEventDataModel dataModel)
+        {
+            m_eventMenu = new AccessibleMenu(this, dataModel.Name, ReadJournal);
+            if (dataModel.ChooseTrackPrompt != "" && dataModel.ActiveTrackId == 0)
+            {
+                m_eventMenu.AddOption(dataModel.ChooseTrackPrompt, () => ChooseEventTrack(dataModel.RewardTracks, dataModel.ChooseTrackPrompt));
+            }
+            else
+            {
+                m_eventMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_QUESTS_TITLE"), () => ReadEventQuests());
+                m_eventMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_REWARDS_TITLE"), ReadRewardsTrack);
+            }
+            m_eventMenu.StartReading();
+
+        }
+        private void ChooseEventTrack(DataModelList<int> trackList, string prompt)
+        {
+            m_curState = State.CHOOSING_EVENT_REWARD_TRACK;
+            List<int> tracks = trackList.ToList<int>();
+            m_chooseRewardTrackMenu = new AccessibleHorizontalMenu<AccessibleMultilineText>(this, prompt, null);
+            foreach (int track in tracks)
+            {
+                List<string> lines = new List<string>();
+                EventRewardTrackDbfRecord eventRewardTrack = GameDbf.EventRewardTrack.GetRecord(track);
+                RewardTrackDbfRecord rewardTrack = GameDbf.RewardTrack.GetRecord(track);
+                if (rewardTrack == null) continue;
+                lines.Add(rewardTrack.Name.GetString());
+                foreach (RewardTrackLevelDbfRecord level in rewardTrack.Levels)
+                {
+                    string rewardDesc = "";
+                    if (level.FreeRewardListRecord != null) rewardDesc = LocalizationUtils.Format(LocalizationKey.ACCESSIBILITY_JOURNAL_EVENT_REWARD_TRACK_DESC, level.FreeRewardListRecord.Description.GetString());
+                    lines.Add(LocalizationUtils.Format(LocalizationKey.ACCESSIBILITY_JOURNAL_EVENT_REWARD_TRACK_PREVIEW, level.Level, level.XpNeeded) + rewardDesc);
+                }
+
+                AccessibleMultilineText item = new AccessibleMultilineText(this, lines);
+                m_chooseRewardTrackMenu.AddOption(item, () => SelectTrack(track));
+
+            }
+            m_chooseRewardTrackMenu.StartReading();
+        }
+
+        public void SelectTrack(int id)
+        {
+            RewardTrackManager rewardTrackManager = RewardTrackManager.Get();
+            if (rewardTrackManager == null)
+            {
+                Debug.LogError("[Journal] Attempting to activate a reward track without a valid RewardTrackManager.");
+                return;
+            }
+            rewardTrackManager.SetActiveEventRewardTrack(id);
+            ReadJournal();
+
+        }
+
+        private void ReadEventQuests()
+        {
+            QuestManager questManager = QuestManager.Get();
+            QuestListDataModel m_questList = questManager.CreateActiveQuestsDataModel(Assets.QuestPool.QuestPoolType.EVENT, (Assets.QuestPool.RewardTrackType)GetRewardTrack().TrackDataModel.RewardTrackType, appendTimeUntilNextQuest: true);
+            m_questList.Quests.Sort(QuestManager.SortChainQuestsToFront); List<QuestDataModel> quests = m_questList.Quests.ToList();
+            List<AccessibleQuest> questList = new List<AccessibleQuest>();
+            foreach (QuestDataModel q in quests)
+            {
+                AccessibleQuest newItem = new AccessibleQuest(this, q);
+                questList.Add(newItem);
+            }
+            m_eventQuests = new AccessibleListOfItems<AccessibleQuest>(null, questList);
+            m_eventQuests.SetGoBackAction(() => ReadEventTab(false));
+            m_curState = State.EVENT_QUESTS;
+            m_eventQuests.StartReading();
+        }
+
+        #endregion
+        public void HandleAccessibleInput()
+        {
+            if ((m_curState == State.READING_DAILY_QUESTS || m_curState == State.READING_WEEKLY_QUESTS) && AccessibleKey.BACK.IsPressed())
+            {
+                // Everything else are menus so they handle their own BACKs
+                {
+                    ReadQuestsOrJournal();
+                    return;
+                }
+            }
+
+            if (m_curState == State.MAIN_MENU)
+            {
+                m_mainMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.EVENT_QUESTS)
+            {
+                m_eventQuests?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.VIEWING_EVENT)
+            {
+                m_eventMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.CHOOSING_EVENT_REWARD_TRACK)
+            {
+                m_chooseRewardTrackMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.READING_DAILY_QUESTS)
+            {
+                m_dailyQuests?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.READING_WEEKLY_QUESTS)
+            {
+                m_weeklyQuests?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.QUESTS_MENU)
+            {
+                m_questsMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.REWARDS_TRACK_MENU || m_curState == State.EVENT_REWARD_TRACK)
+            {
+                m_rewardsTrackMenu?.HandleAccessibleInput();
+            }
+            else if (m_curState == State.ACHIEVEMENT_CATEGORY_MENU)
+            {
+                m_achievementTabSelectorMenu?.HandleAccessibleInput();
+                return;
+            }
+            else if (m_curState == State.ACHIEVEMENT_SUBCATEGORY_MENU)
+            {
+                m_achievementSubcategoryMenu?.HandleAccessibleInput();
+                return;
+            }
+            else if (m_curState == State.ACHIEVEMENT_LIST)
+            {
+                m_achievementListMenu?.HandleAccessibleInput();
+                if (AccessibleKey.READ_NEXT_PAGE.IsPressed())
+                {
+                    m_achievementListMenu?.ReadNextItem(m_achievementListMenu.Count / 10);
+                }
+                else if (AccessibleKey.READ_PREV_PAGE.IsPressed())
+                {
+                    m_achievementListMenu?.ReadNextItem(m_achievementListMenu.Count / -10);
+                }
+                else if (AccessibleKey.CONFIRM.IsPressed() && m_achievementListMenu.GetItemBeingReadIndex() >= 0 && m_achievementListMenu.GetItemBeingReadIndex() < m_achievementListMenu.Count)
+                {
+                    ClaimAchievement(m_currentAchievementList[m_achievementListMenu.GetItemBeingReadIndex()].ID);
+                }
+                return;
+            }
+            else if (m_curState == State.CHOOSING_REWARD)
+            {
+                if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    if (m_chooseOneRewards.GetItemBeingRead().GetDataModel().ItemType == RewardItemType.DECK)
+                    {
+                        SetupDeckRewardForBrowsing(m_chooseOneRewards.GetItemBeingRead());
+                        return;
+                    }
+                    if (m_achievementChooseOne) ClaimAchievementChooseOneReward(m_currentAchievement, m_chooseOneRewards.GetItemBeingRead());
+                    else ClaimChooseOneReward(m_chooseOneRewards.GetItemBeingRead());
+                    return;
+                }
+                m_chooseOneRewards?.HandleAccessibleInput();
+                return;
+            }
+            else if (m_curState == State.BROWSING_CHOOSE_ONE_DECK_REWARD)
+            {
+                if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_REWARDS_TRACK_DECK_CHOICE_CONFIRMATION_PROMPT, AccessibleKey.CONFIRM, AccessibleKey.BACK));
+                    m_curState = State.CONFIRMING_DECK_CHOICE;
+                }
+                else if (AccessibleKey.BACK.IsPressed())
+                {
+                    m_curState = State.CHOOSING_REWARD;
+                    m_chooseOneRewards.StartReading();
+                }
+                else
+                {
+                    m_curDeck?.HandleAccessibleInput();
+                }
+            }
+            else if (m_curState == State.CONFIRMING_DECK_CHOICE)
+            {
+                if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    ClaimChooseOneReward(m_chooseOneRewards.GetItemBeingRead());
+                }
+                else if (AccessibleKey.BACK.IsPressed())
+                {
+                    m_curState = State.BROWSING_CHOOSE_ONE_DECK_REWARD;
+                    m_curDeck.StartReading();
+                }
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+            if (m_curState == State.LOADING)
+            {
+                return LocalizedText.GLOBAL_LOADING;
+            }
+            else if (m_curState == State.MAIN_MENU)
+            {
+                return m_mainMenu?.GetHelp();
+            }
+            else if (m_curState == State.EVENT_QUESTS)
+            {
+                return m_eventQuests?.GetHelp(true);
+            }
+            else if (m_curState == State.VIEWING_EVENT)
+            {
+                return m_eventMenu?.GetHelp();
+            }
+            else if (m_curState == State.CHOOSING_EVENT_REWARD_TRACK)
+            {
+                return m_chooseRewardTrackMenu?.GetHelp();
+            }
+            else if (m_curState == State.READING_DAILY_QUESTS || m_curState == State.READING_WEEKLY_QUESTS)
+            {
+                return LocalizationUtils.Get(LocalizationKey.UI_QUEST_NOTIFICATION_POPUP_HELP);
+            }
+            else if (m_curState == State.READING_WEEKLY_QUESTS)
+            {
+                return m_weeklyQuests?.GetHelp(true);
+            }
+            else if (m_curState == State.QUESTS_MENU)
+            {
+                return m_questsMenu?.GetHelp();
+            }
+            else if (m_curState == State.REWARDS_TRACK_MENU)
+            {
+                return m_rewardsTrackMenu?.GetHelp();
+            }
+            else if (m_curState == State.ACHIEVEMENT_CATEGORY_MENU)
+            {
+                return m_achievementTabSelectorMenu?.GetHelp();
+            }
+            else if (m_curState == State.ACHIEVEMENT_SUBCATEGORY_MENU)
+            {
+                return m_achievementSubcategoryMenu?.GetHelp();
+            }
+            else if (m_curState == State.VIEWING_ACHIEVEMENT)
+            {
+                return m_achievementViewer?.GetHelp();
+            }
+            else if (m_curState == State.ACHIEVEMENT_LIST)
+            {
+                return AccessibleSpeech.MENU_ACHIEVEMENT_HELP;
+            }
+            else if (m_curState == State.CHOOSING_REWARD)
+            {
+                return m_chooseOneRewards.GetHelp(false);
+            }
+            else if (m_curState == State.BROWSING_CHOOSE_ONE_DECK_REWARD)
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_REWARDS_TRACK_BROWSE_DECK_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+            }
+            else if (m_curState == State.CONFIRMING_DECK_CHOICE)
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_REWARDS_TRACK_DECK_CHOICE_CONFIRMATION_PROMPT, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+            }
+
+            return "";
+        }
+
+        #region Rewards Track
+        private void ReadRewardsTrack()
+        {
+            var numRewards = GetUnclaimedRewardsCount();
+
+            m_rewardsTrackMenu = new AccessibleMenu(this, "", ReadJournal);
+
+            m_rewardsTrackMenu.AddOption(LocalizationUtils.Format(LocalizationKey.UI_REWARDS_TRACK_CLAIM_REWARDS, numRewards), ClaimRewardsTrackRewards);
+            m_rewardsTrackMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_REWARDS_TRACK_READ_LEVEL), ReadRewardsTrackLevel);
+
+            m_rewardsTrackMenu.StartReading();
+            if (m_curState == State.VIEWING_EVENT) m_curState = State.EVENT_REWARD_TRACK;
+            else m_curState = State.REWARDS_TRACK_MENU;
+        }
+
+        private int GetCurrentTrackLevel()
+        {
+            if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+            {
+                return AccessibleRewardsTrackTestingUtils.GetCurrentTrackLevel();
+            }
+
+            return GetRewardTrack().TrackDataModel.Level;
+        }
+
+        private int GetCurrentTrackXp()
+        {
+            return GetRewardTrack().TrackDataModel.Xp;
+        }
+
+        private int GetCurrentTrackXpNeeded()
+        {
+            return GetRewardTrack().TrackDataModel.XpNeeded;
+        }
+
+        private int GetCurrentTrackId()
+        {
+            if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+            {
+                return AccessibleRewardsTrackTestingUtils.GetCurrentTrackId();
+            }
+
+            return GetRewardTrack().TrackDataModel.RewardTrackId;
+        }
+
+        private List<RewardTrackLevelDbfRecord> GetUnclaimedRewards()
+        {
+            var ret = new List<RewardTrackLevelDbfRecord>();
+
+            int trackLevel = GetCurrentTrackLevel();
+            int trackId = GetCurrentTrackId();
+            int levelCap = Math.Max(GetRewardTrack().RewardTrackAsset.LevelCapSoft, GetRewardTrack().RewardTrackAsset.Levels.Count());
+            foreach (var record in GetRewardTrack().RewardTrackAsset.Levels)
+            {
+                if (trackId == record.RewardTrackId && record.Level <= trackLevel && record.Level <= levelCap && GetRewardTrack().HasUnclaimedRewardsForLevel(record))
+                {
+                    ret.Add(record);
+                }
+            }
+
+            ret.Sort((a, b) => a.Level - b.Level);
+
+            return ret;
+        }
+
+        #endregion
+        private void ClaimRewardsTrackRewards()
+        {
+            var unclaimedRewards = GetUnclaimedRewards();
+
+            if (unclaimedRewards.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_REWARDS_TRACK_CLAIM_REWARDS_NO_REWARDS));
+            }
+            else
+            {
+                ClaimNextTrackReward();
+            }
+        }
+
+        private void ClaimNextTrackReward()
+        {
+            var unclaimedRewards = GetUnclaimedRewards();
+
+            if (unclaimedRewards.Count == 0)
+            {
+                return;
+            }
+            else
+            {
+                var nextReward = unclaimedRewards[0];
+                var nextRewardLevel = nextReward.Level;
+                var rewardState = GetRewardTrack().GetPlayerRewardTrackLevelState(nextRewardLevel);
+                var forPaidTrack = true;
+
+                if (rewardState.HasFreeRewardStatus && !ProgressUtils.HasClaimedRewardTrackReward((RewardTrack.RewardStatus)rewardState.FreeRewardStatus))
+                {
+                    forPaidTrack = false;
+                }
+
+                if (IsChooseOneReward(nextReward, forPaidTrack))
+                {
+                    ReadChooseOneRewards(nextReward, forPaidTrack);
+                }
+                else
+                {
+                    if (m_curState == State.EVENT_REWARD_TRACK) m_curState = State.CLAIMING_EVENT_REWARD;
+                    else m_curState = State.CLAIMING_REWARD;
+                    GetRewardTrack().ClaimReward(nextReward.RewardTrackId, nextReward.Level, forPaidTrack);
+                }
+            }
+        }
+
+        private AccessibleListOfItems<AccessibleRewardItemDataModel> m_chooseOneRewards;
+        private AccessibleListOfItems<AccessibleEditingDeckCard> m_curDeck;
+
+        private void ReadChooseOneRewards(RewardTrackLevelDbfRecord record, bool forPaidTrack)
+        {
+            var dbfRecord = (forPaidTrack ? record.PaidRewardListRecord : record.FreeRewardListRecord);
+            m_achievementChooseOne = false;
+            if (dbfRecord == null)
+            {
+                AccessibilityUtils.LogFatalError($"ReadChooseOneRewards() reached null dbfRecord: record.RewardTrackId={record.RewardTrackId} record.ID={record.ID} forPaidTrack={forPaidTrack}");
+                return;
+            }
+
+            if (!dbfRecord.ChooseOne)
+            {
+                AccessibilityUtils.LogFatalError($"ReadChooseOneRewards() reached a non-choose one dbfRecord: record.RewardTrackId={record.RewardTrackId} record.ID={record.ID} forPaidTrack={forPaidTrack}");
+                return;
+            }
+            ReadChooseOneRewards(dbfRecord);
+        }
+
+        private void ReadChooseOneRewards(RewardListDbfRecord record)
+        {
+            if (!record.ChooseOne)
+            {
+                return;
+            }
+
+            var choices = record.RewardItems;
+            var isHeroSkinChoice = true;
+            var isDeckChoice = true;
+            foreach (var choice in choices)
+            {
+                if (choice.RewardType != Assets.RewardItem.RewardType.HERO_SKIN)
+                {
+                    isHeroSkinChoice = false;
+                }
+                if (choice.RewardType != Assets.RewardItem.RewardType.DECK)
+                {
+                    isDeckChoice = false;
+                }
+            }
+
+            string menuTitle;
+            if (isHeroSkinChoice)
+            {
+                menuTitle = GameStrings.Get("GLUE_PROGRESSION_REWARD_TRACK_POPUP_SKIN_CHOICE_TITLE");
+            }
+            else if (isDeckChoice)
+            {
+                menuTitle = GameStrings.Get("GLUE_STORE_SELLABLEDECKS_CHOOSE_A_DECK");
+            }
+            else
+            {
+                menuTitle = GameStrings.Get("GAMEPLAY_CHOOSE_ONE");
+            }
+            AccessibilityMgr.Output(this, menuTitle, true);
+
+            var accessibleRewards = new List<AccessibleRewardItemDataModel>();
+
+            foreach (var choice in choices)
+            {
+                // Note: subsets may return more than 1 but this seems very unlikely to ever happen since choose one is just hero skins or decks
+                var rewardsItems = RewardFactory.CreateRewardItemDataModel(choice);
+                var rewardItem = rewardsItems[0];
+                if (isHeroSkinChoice && CollectionManager.Get().IsCardOwned(GameUtils.TranslateDbIdToCardId(GameDbf.RewardItem.GetRecord(rewardItem.AssetId).CardRecord.ID)))
+                {
+                    continue;
+                }
+                accessibleRewards.Add(new AccessibleRewardItemDataModel(this, rewardsItems[0], false));
+            }
+
+            if (accessibleRewards.Count == 0)
+            {
+                return;
+            }
+
+            m_chooseOneRewards = new AccessibleListOfItems<AccessibleRewardItemDataModel>(this, accessibleRewards);
+            m_chooseOneRewards.StartReading();
+            m_curState = State.CHOOSING_REWARD;
+        }
+
+        private void SetupDeckRewardForBrowsing(AccessibleRewardItemDataModel accessibleReward)
+        {
+            var reward = accessibleReward.GetDataModel();
+            if (reward.ItemType != RewardItemType.DECK)
+            {
+                AccessibilityUtils.LogFatalError("SetupDeckRewardForBrowsing was called with a reward that is not a deck!");
+                return;
+            }
+            var templateRecord = GameDbf.DeckTemplate.GetRecord(reward.DeckTemplateId);
+            var deck = CollectionManager.Get().GetTemplateDeck(templateRecord.DeckId);
+            var collectionDeck = new CollectionDeck();
+            collectionDeck.FillFromTemplateDeck(deck);
+            var accessibleCards = collectionDeck.GetSlots().Select((slot) => new AccessibleEditingDeckCard(this, slot, false)).ToList();
+            m_curDeck = new AccessibleListOfItems<AccessibleEditingDeckCard>(this, accessibleCards);
+            m_curState = State.BROWSING_CHOOSE_ONE_DECK_REWARD;
+            m_curDeck.StartReading();
+        }
+
+        private void ClaimChooseOneReward(AccessibleRewardItemDataModel chosen)
+        {
+            var unclaimedRewards = GetUnclaimedRewards();
+
+            if (unclaimedRewards.Count == 0)
+            {
+                AccessibilityUtils.LogFatalError("ClaimChooseOneReward reached invalid state: unclaimedRewards was empty");
+                return;
+            }
+            else
+            {
+                var nextReward = unclaimedRewards[0];
+                var nextRewardLevel = nextReward.Level;
+                var rewardState = GetRewardTrack().GetPlayerRewardTrackLevelState(nextRewardLevel);
+                var forPaidTrack = true;
+
+                if (rewardState.HasFreeRewardStatus && !ProgressUtils.HasClaimedRewardTrackReward((RewardTrack.RewardStatus)rewardState.FreeRewardStatus))
+                {
+                    forPaidTrack = false;
+                }
+
+                if (IsChooseOneReward(nextReward, forPaidTrack))
+                {
+                    m_curState = State.CLAIMING_REWARD;
+                    GetRewardTrack().ClaimReward(nextReward.RewardTrackId, nextReward.Level, forPaidTrack, chosen.GetDataModel().AssetId);
+                }
+                else
+                {
+                    AccessibilityUtils.LogFatalError($"ClaimChooseOneReward reached invalid state: reward was not choose one. trackId={nextReward.RewardTrackId} trackLevel={nextReward.Level} forPaidTrack={forPaidTrack}");
+                    return;
+                }
+            }
+        }
+
+        private bool IsChooseOneReward(RewardTrackLevelDbfRecord record, bool forPaidTrack)
+        {
+            var dbfRecord = (forPaidTrack ? record.PaidRewardListRecord : record.FreeRewardListRecord);
+
+            if (dbfRecord == null)
+            {
+                return false;
+            }
+
+            return dbfRecord.ChooseOne;
+        }
+
+        private int GetUnclaimedRewardsCount()
+        {
+            var ret = 0;
+
+            var unclaimedRewards = GetUnclaimedRewards();
+
+            foreach (var unclaimedReward in unclaimedRewards)
+            {
+                var freeRecord = unclaimedReward.FreeRewardListRecord;
+                var paidRecord = unclaimedReward.PaidRewardListRecord;
+                var playerRewardTrackLevelState = GetRewardTrack().GetPlayerRewardTrackLevelState(unclaimedReward.Level);
+                var premiumRewardsUnlocked = GetRewardTrack().ArePremiumRewardsUnlocked();
+
+                if (freeRecord != null && freeRecord.RewardItems?.Count > 0 && !ProgressUtils.HasClaimedRewardTrackReward((RewardTrack.RewardStatus)playerRewardTrackLevelState.FreeRewardStatus))
+                {
+                    ret++;
+                }
+
+                if (premiumRewardsUnlocked && paidRecord != null && paidRecord.RewardItems?.Count > 0 && !ProgressUtils.HasClaimedRewardTrackReward((RewardTrack.RewardStatus)playerRewardTrackLevelState.PaidRewardStatus))
+                {
+                    ret++;
+                }
+            }
+
+            return ret;
+        }
+
+        internal void OnTrackRewardAckd(int rewardTrackId, int level, bool forPaidTrack)
+        {
+
+            if (m_curState == State.CLAIMING_REWARD)
+            {
+                ReadRewardsTrack();
+            }
+            else if (m_curState == State.CLAIMING_EVENT_REWARD)
+            {
+                m_curState = State.VIEWING_EVENT;
+                ReadRewardsTrack();
+            }
+
+        }
+
+        private void ReadRewardsTrackLevel()
+        {
+            AccessibilityMgr.Output(this, $"{GetCurrentTrackLevel()}");
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_REWARDS_TRACK_XP_PROGRESS, GetCurrentTrackXp(), GetCurrentTrackXpNeeded()));
+        }
+
+        private RewardTrack GetRewardTrack()
+        {
+            if (m_curState == State.VIEWING_EVENT || m_curState == State.EVENT_REWARD_TRACK) return RewardTrackManager.Get().GetCurrentEventRewardTrack();
+            return RewardTrackManager.Get().GetRewardTrack(m_rewardTrackType);
+        }
+
+
+        #region achievements
+        private void ReadAchievementCats()
+        {
+            m_curState = State.ACHIEVEMENT_CATEGORY_MENU;
+            if (m_achievementTabSelectorMenu == null)
+            {
+                m_achievementTabSelectorMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.ACHIEVEMENT_CATEGORY_TITLE), () => ReadJournal());
+                DataModelList<AchievementCategoryDataModel> cats = AchievementManager.Get().Categories.Categories;
+                m_achievementTabSelectorMenu.AddOption(LocalizationUtils.Get(LocalizationKey.ACHIEVEMENT_CATEGORY_RECENT), ReadRecentAchievements);
+                for (int i = 0; i < cats.Count; i++)
+                {
+                    var cat = cats[i];
+                    m_achievementTabSelectorMenu.AddOption(LocalizationUtils.Format(LocalizationKey.ACHIEVEMENT_CATEGORY_ITEM, cats[i].Name, cats[i].Stats.Points, cats[i].Stats.AvailablePoints, cats[i].Stats.CompletionPercentage, cats[i].Stats.CompletedAchievements, cats[i].Stats.TotalAchievements), () => ReadAchievementCategory(cat));
+                }
+                m_achievementTabSelectorMenu.StartReading();
+            }
+            else
+            {
+                m_achievementTabSelectorMenu.StartReading(false);
+            }
+        }
+
+        private void ReadRecentAchievements()
+        {
+            DataModelList<AchievementDataModel> allAchs = AchievementManager.Get().GetRecentlyCompletedAchievements().GetCurrentSortedAchievements()
+                .SortByStatusThenClaimedDate()
+                .Take(5)
+                .ToDataModelList(); ;
+            DataModelList<AchievementDataModel> recentAchieves = new DataModelList<AchievementDataModel>();
+            m_currentCategory = null;
+            m_currentSubcategory = null;
+            for (int x = 0; x < allAchs.Count; x++)
+            {
+                recentAchieves.Add(allAchs[x]);
+            }
+            ReadAchievementList(recentAchieves, ReadAchievementCats);
+        }
+        private AchievementCategoryDataModel m_currentCategory;
+        private AchievementSubcategoryDataModel m_currentSubcategory;
+        private void ReadAchievementCategory(AchievementCategoryDataModel data)
+        {
+            AchievementManager.Get().SelectCategory(data);
+            m_currentCategory = data;
+            m_curState = State.ACHIEVEMENT_SUBCATEGORY_MENU;
+            m_achievementSubcategoryMenu = new AccessibleMenu(this, data.Name, () => ReadAchievementCats());
+            DataModelList<AchievementSubcategoryDataModel> cats = data.Subcategories.Subcategories;
+            for (int i = 0; i < cats.Count; i++)
+            {
+                var cat = cats[i];
+                m_achievementSubcategoryMenu.AddOption(LocalizationUtils.Format(LocalizationKey.ACHIEVEMENT_CATEGORY_ITEM, cats[i].Name, cats[i].Stats.Points, cats[i].Stats.AvailablePoints, cats[i].Stats.CompletionPercentage, cats[i].Stats.CompletedAchievements, cats[i].Stats.TotalAchievements), () => ReadAchievementSubcategory(cat));
+            }
+            m_achievementSubcategoryMenu.StartReading();
+
+        }
+
+        private void ReadAchievementSubcategory(AchievementSubcategoryDataModel data)
+        {
+            AchievementManager.Get().SelectSubcategory(data);
+            DataModelList<AchievementSectionDataModel> sections = data.Sections.Sections;
+            DataModelList<AchievementDataModel> achieves = new DataModelList<AchievementDataModel>();
+            m_currentSubcategory = data;
+            for (int i = 0; i < sections.Count; i++)
+            {
+                for (int j = 0; j < sections[i].Achievements.Achievements.Count; j++)
+                {
+                    achieves.Add(sections[i].Achievements.Achievements[j]);
+                }
+            }
+            ReadAchievementList(achieves, () => ReadAchievementCategory(m_currentCategory));
+        }
+        DataModelList<AchievementDataModel> m_currentAchievementList = null;
+        private void ReadAchievementList(DataModelList<AchievementDataModel> achievements, Action goBackAction, bool onlyIncompleteAchievements = false)
+        {
+            m_curState = State.ACHIEVEMENT_LIST;
+            List<AccessibleMultilineText> items = new List<AccessibleMultilineText>();
+            DataModelList<AchievementDataModel> achievementsCopy = new DataModelList<AchievementDataModel>();
+            if (onlyIncompleteAchievements)
+            {
+                for (int i = 0; i < achievements.Count; i++)
+                {
+                    if (achievements[i].CompletionDate == "")
+                    {
+                        achievementsCopy.Add(achievements[i]);
+                    }
+                }
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.ACHIEVEMENT_SHOWING_INCOMPLETE, achievementsCopy.Count, achievements.Count));
+            }
+            else achievementsCopy = achievements;
+            m_currentAchievementList = achievementsCopy;
+            for (int i = 0; i < achievementsCopy.Count; i++)
+            {
+                List<string> lines = new List<string>();
+                AchievementDataModel ach = achievementsCopy[i];
+                lines.Add(ach.Name);
+                if (!ProgressUtils.IsAchievementClaimed(ach.Status) && ach.CompletionDate != "") lines.Add(LocalizationUtils.Get(LocalizationKey.ACHIEVEMENT_CLAIMABLE));
+                if (ach.MaxTier > 1) lines.Add(LocalizationUtils.Format(LocalizationKey.ACHIEVEMENT_VIEW_TIER, ach.Tier, ach.MaxTier));
+                lines.Add(ach.Description);
+                if (ach.Quota > 1) lines.Add(LocalizationUtils.Format(LocalizationKey.ACHIEVEMENT_VIEW_PROGRESS, ach.Progress, ach.Quota));
+                if (ach.RewardSummary != "") lines.Add(ach.RewardSummary);
+                if (ach.CompletionDate != "") lines.Add(ach.CompletionDate);
+                items.Add(new AccessibleMultilineText(this, lines));
+            }
+            m_achievementListMenu = new AccessibleListOfItems<AccessibleMultilineText>(this, items);
+            m_achievementListMenu.TabAction = () => ReadAchievementList(achievements, goBackAction, !onlyIncompleteAchievements);
+            m_achievementListMenu.SetGoBackAction(goBackAction);
+            m_achievementListMenu.StartReading();
+        }
+
+        private void ViewAchievement(AchievementDataModel ach)
+        {
+        }
+        private bool m_achievementChooseOne = false;
+        private int m_currentAchievement = 0;
+        private void ClaimAchievement(int id)
+        {
+            m_currentAchievement = id;
+            RewardListDbfRecord rewardList = GameDbf.Achievement.GetRecord(id).RewardListRecord;
+            if (AchievementManager.Get().ClaimAchievementReward(id, 0))
+            {
+                if (rewardList != null && rewardList.ChooseOne)
+                {
+                    m_achievementChooseOne = true;
+                    ReadChooseOneRewards(rewardList);
+                }
+                else AchievementManager.Get().ShowNextReward(OnAchievementClaimed);
+            }
+        }
+        private void ClaimAchievementChooseOneReward(int achievementId, AccessibleRewardItemDataModel data)
+        {
+            Network.Get().ClaimAchievementReward(achievementId, data.GetDataModel().AssetId);
+            OnAchievementClaimed();
+        }
+
+        internal void OnAchievementClaimed()
+        {
+            if (m_currentSubcategory == null) ReadRecentAchievements();
+            //else ReadAchievementSubcategory(m_currentSubcategory);
+
+        }
+        private void GoBackToAchievementList()
+        {
+            m_curState = State.ACHIEVEMENT_LIST;
+            m_achievementViewer = null;
+            //m_achievementListMenu.StartReading(false);
+        }
+        #endregion
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleKey.cs b/Assembly-CSharp/Accessibility/AccessibleKey.cs
new file mode 100644
index 0000000..54c003e
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleKey.cs
@@ -0,0 +1,410 @@
+﻿using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleKey
+    {
+        public static AccessibleKey CONFIRM = CreateKey(KeyCode.Return);
+        public static AccessibleKey GLOBAL_CONFIRM = CreateGlobalKey(KeyCode.Return);
+        public static AccessibleKey BACK = CreateKey(KeyCode.Backspace);
+        public static AccessibleKey GLOBAL_BACK = CreateGlobalKey(KeyCode.Backspace);
+        public static AccessibleKey OPEN_GAME_MENU = CreateGlobalKey(KeyCode.Escape);
+        public static AccessibleKey HELP = CreateGlobalKey(KeyCode.F1);
+        public static AccessibleKey OPEN_SOCIAL_MENU = CreateGlobalKey(KeyCode.F4);
+        public static AccessibleKey TOGGLE_ACCESSIBILITY = CreateGlobalKey(KeyCode.F8);
+        public static AccessibleKey SILENTLY_DISABLE_ACCESSIBILITY = CreateGlobalKey(KeyCode.F14, false, false, false, true);
+        public static AccessibleKey SILENTLY_ENABLE_ACCESSIBILITY = CreateGlobalKey(KeyCode.F15, false, false, false, true);
+        public static AccessibleKey READ_NEXT_LINE = CreateKey(KeyCode.DownArrow);
+        public static AccessibleKey READ_PREV_LINE = CreateKey(KeyCode.UpArrow);
+        public static AccessibleKey READ_CUR_LINE = CreateKey(KeyCode.UpArrow, true);
+        public static AccessibleKey READ_TO_END = CreateKey(KeyCode.DownArrow, true);
+        public static AccessibleKey READ_NEXT_ITEM = CreateKey(KeyCode.RightArrow);
+        public static AccessibleKey READ_PREV_ITEM = CreateKey(KeyCode.LeftArrow);
+        public static AccessibleKey READ_NEXT_VALID_ITEM = CreateKey(KeyCode.Tab);
+        public static AccessibleKey READ_PREV_VALID_ITEM = CreateKey(KeyCode.Tab, true);
+        public static AccessibleKey READ_FIRST_ITEM = CreateKey(KeyCode.Home);
+        public static AccessibleKey READ_LAST_ITEM = CreateKey(KeyCode.End);
+        public static AccessibleKey READ_FIRST_ITEM_GLOBAL = CreateKey(KeyCode.Home, true);
+        public static AccessibleKey READ_LAST_ITEM_GLOBAL = CreateKey(KeyCode.End, true);
+        public static AccessibleKey READ_NEXT_PAGE = CreateKey(KeyCode.PageDown);
+        public static AccessibleKey READ_PREV_PAGE = CreateKey(KeyCode.PageUp);
+        public static AccessibleKey SKIP_NOTIFICATION = CreateKey(KeyCode.Space);
+        public static AccessibleKey SPACE = CreateKey(KeyCode.Space);
+        public static AccessibleKey ESC = CreateKey(KeyCode.Escape);
+
+        public static AccessibleKey GLOBAL_FIND = CreateKey(KeyCode.F, false, true);
+
+        public static AccessibleKey DECREASE_GAME_SPEED = CreateKey(KeyCode.F11);
+        public static AccessibleKey INCREASE_GAME_SPEED = CreateKey(KeyCode.F12);
+
+        public static AccessibleKey GLOBAL_LEFT = CreateGlobalKey(KeyCode.LeftArrow);
+        public static AccessibleKey GLOBAL_RIGHT = CreateGlobalKey(KeyCode.RightArrow);
+
+        #region Menu Controls
+        public static AccessibleKey READ_NEXT_MENU_OPTION = CreateKey(KeyCode.DownArrow);
+        public static AccessibleKey READ_PREV_MENU_OPTION = CreateKey(KeyCode.UpArrow);
+        public static AccessibleKey READ_CUR_MENU_OPTION = CreateKey(KeyCode.UpArrow, true);
+        public static AccessibleKey READ_NEXT_VALID_MENU_OPTION = CreateKey(KeyCode.Tab);
+        public static AccessibleKey READ_PREV_VALID_MENU_OPTION = CreateKey(KeyCode.Tab, true);
+        public static AccessibleKey READ_NEXT_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.DownArrow);
+        public static AccessibleKey READ_PREV_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.UpArrow);
+        public static AccessibleKey READ_CUR_GLOBAL_MENU_OPTION = CreateGlobalKey(KeyCode.UpArrow, true);
+        public static AccessibleKey READ_NEXT_GLOBAL_VALID_MENU_OPTION = CreateGlobalKey(KeyCode.Tab);
+        public static AccessibleKey READ_PREV_GLOBAL_VALID_MENU_OPTION = CreateGlobalKey(KeyCode.Tab, true);
+    #endregion
+
+    #region Hub
+        public static AccessibleKey HUB_RANKED = CreateKey(KeyCode.R);
+        public static AccessibleKey HUB_CASUAL = CreateKey(KeyCode.A);
+        public static AccessibleKey HUB_SHOP = CreateKey(KeyCode.S);
+        public static AccessibleKey HUB_MY_COLLECTION = CreateKey(KeyCode.C);
+        public static AccessibleKey HUB_JOURNAL = CreateKey(KeyCode.J);
+        public static AccessibleKey HUB_BATTLEGROUNDS = CreateKey(KeyCode.B);
+        public static AccessibleKey HUB_MODES = CreateKey(KeyCode.M);
+        public static AccessibleKey HUB_OPEN_PACKS = CreateKey(KeyCode.O);
+        public static AccessibleKey HUB_TAVERN_BRAWL = CreateKey(KeyCode.T);
+    #endregion
+
+    #region My Collection
+    public static AccessibleKey SEE_DECKS = CreateKey(KeyCode.D);
+        public static AccessibleKey CREATE_DECK = CreateKey(KeyCode.N);
+        public static AccessibleKey DELETE_DECK = CreateKey(KeyCode.Delete);
+        public static AccessibleKey EDIT_DECK = CreateKey(KeyCode.E);
+        public static AccessibleKey EDIT_DECK_ENTER_CRAFTING_MODE = CreateKey(KeyCode.Return, true);
+        #endregion
+
+        #region Quest Log
+        public static AccessibleKey REROLL_QUEST = CreateKey(KeyCode.R);
+        public static AccessibleKey ABANDON_QUEST = CreateKey(KeyCode.A);
+        #endregion
+
+        #region Pack Opening
+        public static AccessibleKey PACK_OPENING_MASS_OPEN_PACK = CreateKey(KeyCode.Space);
+        #endregion
+
+        #region Game Keys
+        public static AccessibleKey MULLIGAN_MARK_CARD = CreateKey(KeyCode.Space);
+        public static AccessibleKey SEE_PLAYER_HAND = CreateKey(KeyCode.C);
+        public static AccessibleKey SEE_OPPONENT_HAND = CreateKey(KeyCode.C, true);
+        public static AccessibleKey SEE_PLAYER_DECK = CreateKey(KeyCode.D);
+        public static AccessibleKey SEE_OPPONENT_DECK = CreateKey(KeyCode.D, true);
+        public static AccessibleKey SEE_PLAYER_MANA = CreateKey(KeyCode.A);
+        public static AccessibleKey SEE_OPPONENT_MANA = CreateKey(KeyCode.A, true);
+        public static AccessibleKey SEE_PLAYER_SECRETS = CreateKey(KeyCode.S);
+        public static AccessibleKey SEE_OPPONENT_SECRETS = CreateKey(KeyCode.S, true);
+        public static AccessibleKey SEE_PLAYER_MINIONS = CreateKey(KeyCode.B);
+        public static AccessibleKey SEE_OPPONENT_MINIONS = CreateKey(KeyCode.G);
+        public static AccessibleKey SEE_OPPONENT_HERO = CreateKey(KeyCode.F);
+        public static AccessibleKey SEND_ALL_MINIONS_TO_FACE = CreateKey(KeyCode.F, true);
+        public static AccessibleKey SEND_MINION_TO_FACE = CreateKey(KeyCode.F, false, true);
+        public static AccessibleKey SEE_PLAYER_HERO = CreateKey(KeyCode.V);
+        public static AccessibleKey SEE_PLAYER_HERO_POWER = CreateKey(KeyCode.R);
+        public static AccessibleKey SEE_OPPONENT_HERO_POWER = CreateKey(KeyCode.R, true);
+        public static AccessibleKey SEE_PLAYER_WEAPON = CreateKey(KeyCode.W);
+        public static AccessibleKey SEE_OPPONENT_WEAPON = CreateKey(KeyCode.W, true);
+        public static AccessibleKey SEE_HISTORY = CreateKey(KeyCode.Y);
+        public static AccessibleKey END_TURN = CreateKey(KeyCode.E);
+        public static AccessibleKey FORCE_END_TURN = CreateKey(KeyCode.E, true);
+        public static AccessibleKey READ_TOOLTIP = CreateKey(KeyCode.I);
+        public static AccessibleKey READ_ORIGINAL_CARD_STATS = CreateKey(KeyCode.K);
+        public static AccessibleKey TRADE_CARD = CreateKey(KeyCode.T);
+        public static AccessibleKey READ_ANOMALIES = CreateKey(KeyCode.O);
+		#endregion
+
+		#region Battlegrounds-specific Keys
+        public static AccessibleKey SEE_TAVERN = CreateKey(KeyCode.T);
+        public static AccessibleKey UPGRADE_TAVERN = CreateKey(KeyCode.U);
+        public static AccessibleKey FREEZE_TAVERN = CreateKey(KeyCode.F);
+        public static AccessibleKey REFRESH_TAVERN = CreateKey(KeyCode.R);
+
+        public static AccessibleKey FORCE_UPGRADE_TAVERN = CreateKey(KeyCode.U, true);
+        public static AccessibleKey FORCE_FREEZE_TAVERN = CreateKey(KeyCode.F, true);
+        public static AccessibleKey FORCE_REFRESH_TAVERN = CreateKey(KeyCode.R, true);
+
+        public static AccessibleKey BATTLEGROUNDS_SEE_PLAYER_HERO_POWER = CreateKey(KeyCode.P);
+        public static AccessibleKey BATTLEGROUNDS_SEE_OPPONENT_HERO_POWER = CreateKey(KeyCode.P, true);
+
+        public static AccessibleKey BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS = CreateKey(KeyCode.N);
+        public static AccessibleKey BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS_TO_END = CreateKey(KeyCode.N, true);
+        public static AccessibleKey BATTLEGROUNDS_READ_MY_STATS = CreateKey(KeyCode.M);
+        public static AccessibleKey BATTLEGROUNDS_READ_MY_STATS_TO_END = CreateKey(KeyCode.M, true);
+        public static AccessibleKey BATTLEGROUNDS_READ_LEADERBOARD = CreateKey(KeyCode.L);
+        public static AccessibleKey BATTLEGROUNDS_READ_RACES_IN_GAME = CreateKey(KeyCode.O);
+        public static AccessibleKey BATTLEGROUNDS_READ_HERO_BUDDY = CreateKey(KeyCode.D);
+        #endregion
+
+        #region Dev Utils
+        public static AccessibleKey DEV_1 = CreateKey(KeyCode.Alpha1);
+        public static AccessibleKey DEV_2 = CreateKey(KeyCode.Alpha2);
+        #endregion
+
+        #region duels
+        public static AccessibleKey READ_DECK = CreateKey(KeyCode.D);
+        public static AccessibleKey READ_LOOT_FORWARDS = CreateKey(KeyCode.Tab, false);
+        public static AccessibleKey READ_LOOT_BACKWARDS = CreateKey(KeyCode.Tab, true);
+        public static AccessibleKey TAKE_LOOT = CreateKey(KeyCode.Return);
+        public static AccessibleKey TAKE_LOOT_ALT = CreateKey(KeyCode.KeypadEnter);
+        #endregion
+
+        private bool m_requiresShift;
+
+        private bool m_requiresCtrl;
+
+        private bool m_requiresAlt;
+
+        private bool m_ignoreAllModifierKeys; // Takes precedence over the previous 3
+
+        private KeyCode m_keyCode;
+
+        private bool m_enabled;
+
+		private AccessibleKey(KeyCode keyCode, bool requiresShift = false, bool requiresCtrl = false, bool requiresAlt = false, bool ignoreAllModifierKeys = false)
+		{
+			m_keyCode = keyCode;
+            m_requiresShift = requiresShift;
+            m_requiresCtrl = requiresCtrl;
+            m_requiresAlt = requiresAlt;
+            m_ignoreAllModifierKeys = ignoreAllModifierKeys;
+            if (ignoreAllModifierKeys)
+            {
+                m_requiresShift = false;
+                m_requiresCtrl = false;
+                m_requiresAlt = false;
+            }
+            m_enabled = true;
+        }
+
+        public bool IsPressed()
+        {
+            var ret = IsPressedInternal();
+
+            if (ret)
+            {
+                AccessibilityUtils.LogDebug($"Pressed key: {m_keyCode}");
+            }
+
+            return ret;
+        }
+
+        private bool IsPressedInternal()
+        {
+            if (!m_enabled)
+            {
+                if (IsKeyDown(m_keyCode))
+                {
+                    AccessibilityUtils.LogDebug($"ZYY Tried to press {m_keyCode} but it was disabled");
+                }
+                return false;
+            }
+
+            if (m_ignoreAllModifierKeys)
+			{
+                return IsKeyDown(m_keyCode);
+			}
+            else if (m_requiresShift && m_requiresCtrl && m_requiresAlt)
+            {
+                return IsHoldingShift() && IsHoldingCtrl() && IsHoldingAlt() && IsKeyDown(m_keyCode);
+            }
+            else if (m_requiresShift && m_requiresCtrl && !m_requiresAlt)
+            {
+                return IsHoldingShift() && IsHoldingCtrl() && !IsHoldingAlt() && IsKeyDown(m_keyCode);
+            }
+            else if (m_requiresShift && !m_requiresCtrl && m_requiresAlt)
+            {
+                return IsHoldingShift() && !IsHoldingCtrl() && IsHoldingAlt() && IsKeyDown(m_keyCode);
+            }
+            else if (m_requiresShift && !m_requiresCtrl && !m_requiresAlt)
+            {
+                return IsHoldingShift() && !IsHoldingCtrl() && !IsHoldingAlt() && IsKeyDown(m_keyCode);
+            }
+            else if (!m_requiresShift && m_requiresCtrl && m_requiresAlt)
+            {
+                return !IsHoldingShift() && IsHoldingCtrl() && IsHoldingAlt() && IsKeyDown(m_keyCode);
+            }
+            else if (!m_requiresShift && m_requiresCtrl && !m_requiresAlt)
+            {
+                return !IsHoldingShift() && IsHoldingCtrl() && !IsHoldingAlt() && IsKeyDown(m_keyCode);
+            }
+            else if (!m_requiresShift && !m_requiresCtrl && m_requiresAlt)
+            {
+                return !IsHoldingShift() && !IsHoldingCtrl() && IsHoldingAlt() && IsKeyDown(m_keyCode);
+            }
+            else // No modifier keys are being pressed
+            {
+                return !IsHoldingShift() && !IsHoldingCtrl() && !IsHoldingAlt() && IsKeyDown(m_keyCode);
+            }
+        }
+
+        private bool IsKeyDown(KeyCode keyCode)
+        {
+            if (keyCode == KeyCode.Return && Input.GetKeyDown(KeyCode.KeypadEnter))
+            {
+                // Quick fix as some players asked for this
+                return true;
+            }
+
+            return Input.GetKeyDown(keyCode);
+        }
+
+        public bool IsDown()
+        {
+            if (!m_enabled)
+            {
+                return false;
+            }
+
+            if (m_requiresShift)
+            {
+                return IsHoldingShift() && Input.GetKey(m_keyCode);
+            }
+            else
+            {
+                return !IsHoldingShift() && Input.GetKey(m_keyCode);
+            }
+        }
+
+        private static bool IsHoldingShift()
+        {
+            return Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift);
+        }
+
+        private static bool IsHoldingCtrl()
+        {
+            return Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl);
+        }
+
+        private static bool IsHoldingAlt()
+        {
+            return Input.GetKey(KeyCode.LeftAlt) || Input.GetKey(KeyCode.RightAlt);
+        }
+
+        public override string ToString()
+        {
+            if (m_requiresCtrl)
+			{
+                return LocalizationUtils.Format(LocalizationKey.INPUT_COMMAND_WITH_CTRL_FORMAT, ReadKey(m_keyCode));
+			}
+            else if (m_requiresShift)
+            {
+                return LocalizationUtils.Format(LocalizationKey.INPUT_COMMAND_WITH_MODIFIER_FORMAT, ReadKey(m_keyCode));
+            }
+            else
+            {
+                return ReadKey(m_keyCode);
+            }
+        }
+
+        public string ToEnglishString()
+        {
+            // Used for narrations only (a vs. eh)
+            if (m_requiresCtrl)
+			{
+                return $"Ctrl + {ReadKeyInEnglish(m_keyCode)}";
+			}
+            else if (m_requiresShift)
+            {
+                return $"Shift + {ReadKeyInEnglish(m_keyCode)}";
+            }
+            else
+            {
+                return ReadKeyInEnglish(m_keyCode);
+            }
+        }
+
+        private string ReadKeyInEnglish(KeyCode keyCode)
+        {
+            switch (keyCode)
+            {
+                case KeyCode.Return:
+                    return "Enter";
+                case KeyCode.A:
+                    return "eh";
+                case KeyCode.I:
+                    return "eye";
+                default:
+                    return keyCode.ToString();
+            }
+        }
+
+        private string ReadKey(KeyCode keyCode)
+        {
+            if (LocalizationUtils.HasOverrideForKey(keyCode))
+            {
+                return LocalizationUtils.GetOverrideForKey(keyCode);
+            }
+
+            return keyCode.ToString();
+        }
+
+        public void Enable()
+        {
+            m_enabled = true;
+        }
+
+        public void Disable()
+        {
+            m_enabled = false;
+        }
+
+        #region Key Registration
+        private static HashSet<AccessibleKey> s_allKeys;
+        private static HashSet<AccessibleKey> s_nonGlobalKeys;
+        private static HashSet<AccessibleKey> s_globalKeys;
+
+        private static AccessibleKey CreateKey(KeyCode keyCode, bool requiresShift=false, bool requiresCtrl = false, bool requiresAlt = false, bool ignoreAllModifierKeys = false)
+        {
+            InitializeKeySetsIfNeeded();
+
+            var newKey = new AccessibleKey(keyCode, requiresShift, requiresCtrl, requiresAlt, ignoreAllModifierKeys);
+            s_allKeys.Add(newKey);
+            s_nonGlobalKeys.Add(newKey);
+
+            return newKey;
+        }
+
+        private static AccessibleKey CreateGlobalKey(KeyCode keyCode, bool requiresShift=false, bool requiresCtrl = false, bool requiresAlt = false, bool ignoreAllModifierKeys = false)
+        {
+            InitializeKeySetsIfNeeded();
+
+            var newKey = new AccessibleKey(keyCode, requiresShift, requiresCtrl, requiresAlt, ignoreAllModifierKeys);
+            s_allKeys.Add(newKey);
+            s_globalKeys.Add(newKey);
+
+            return newKey;
+        }
+
+        private static void InitializeKeySetsIfNeeded()
+        {
+            if (s_allKeys == null)
+            {
+                s_allKeys = new HashSet<AccessibleKey>();
+            }
+
+            if (s_nonGlobalKeys == null)
+            {
+                s_nonGlobalKeys = new HashSet<AccessibleKey>();
+            }
+
+            if (s_globalKeys == null)
+            {
+                s_globalKeys = new HashSet<AccessibleKey>();
+            }
+        }
+
+        public static HashSet<AccessibleKey> GetAllKeys(bool includeGlobals=true)
+        {
+            if (includeGlobals)
+            {
+                return s_allKeys;
+            }
+            else
+            {
+                return s_nonGlobalKeys;
+            }
+        }
+
+        #endregion
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs b/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs
new file mode 100644
index 0000000..5da0181
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleListOfItems.cs
@@ -0,0 +1,303 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleListOfItems<T> : AccessibleElement where T : AccessibleItem
+    {
+        private List<T> m_items;
+
+        private int m_curItemIdx;
+
+        private T m_curItem;
+
+        private string m_noItemsTextOverride; // Useful for e.g. no results when searching collection where the message may be dynamic
+
+        private int m_countOverride = -1; // For scrolling lists where not all items might be available at a given moment.
+
+        internal int Count => m_countOverride == -1 ? m_items.Count : m_countOverride;
+
+        internal List<T> Items => m_items;
+
+        public Action TabAction;
+
+        public Action ShiftTabAction;
+
+        public Action HomeAction;
+
+        public Action EndAction;
+
+        public delegate void OnReadItemDelegate(T item);
+
+        public OnReadItemDelegate onReadItem;
+
+        public delegate int GetItemIndexDelegate(T item);
+
+        public GetItemIndexDelegate getItemIndex;
+
+        private Action m_goBackAction = null;
+
+        internal AccessibleListOfItems(AccessibleComponent parent, List<T> items, string noItemsTextOverride = null) : base(parent)
+        {
+            m_items = items;
+            m_noItemsTextOverride = noItemsTextOverride;
+        }
+
+        internal void SetGoBackAction(Action a)
+        {
+            m_goBackAction = a;
+        }
+
+        internal void SetCountOverride(int countOverride)
+        {
+            m_countOverride = countOverride;
+        }
+
+        internal bool HandleAccessibleInput()
+        {
+            if (AccessibleKey.BACK.IsPressed() && m_goBackAction != null)
+            {
+                m_goBackAction();
+            }
+            else if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                if (TabAction != null) TabAction();
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                if (ShiftTabAction != null) ShiftTabAction();
+            }
+            if (m_items.Count == 0 && m_noItemsTextOverride != null)
+            {
+                // TODO: Refactor this list to do this properly
+                return HandleAccessibleInputForEmptyList();
+            }
+
+            if (!IsReading())
+            {
+                return false;
+            }
+
+            if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                return ReadNextItem(1);
+            }
+            else if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                return ReadNextItem(-1);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+            {
+                if (HomeAction != null)
+                {
+                    HomeAction();
+                }
+                else
+                {
+                    ReadFromTop();
+                }
+                return true;
+            }
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+            {
+                if (EndAction != null)
+                {
+                    EndAction();
+                }
+                else
+                {
+                    ReadFromBottom();
+                }
+                return true;
+            }
+            else if (m_curItem != null && m_curItem.HandleAccessibleInput())
+            {
+                return true;
+            }
+            else if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                if (TabAction == null) return ReadNextItem(1, true);
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                if (ShiftTabAction == null) return ReadNextItem(-1, true);
+            }
+            return false;
+        }
+
+        private bool HandleAccessibleInputForEmptyList()
+        {
+            if (AccessibleKey.READ_PREV_ITEM.IsPressed() || AccessibleKey.READ_NEXT_ITEM.IsPressed() ||
+                AccessibleKey.READ_PREV_VALID_ITEM.IsPressed() || AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed() ||
+                AccessibleKey.READ_FIRST_ITEM.IsPressed() || AccessibleKey.READ_LAST_ITEM.IsPressed() ||
+                AccessibleKey.READ_PREV_LINE.IsPressed() || AccessibleKey.READ_NEXT_LINE.IsPressed() ||
+                AccessibleKey.READ_CUR_LINE.IsPressed() || AccessibleKey.READ_TO_END.IsPressed())
+            {
+                OutputNoItems();
+            }
+
+            return false;
+        }
+
+        private int GetDisplayIndex()
+        {
+            if (getItemIndex != null)
+            {
+                return getItemIndex(m_curItem);
+            }
+            return m_curItemIdx + 1;
+        }
+
+        internal bool ReadNextItem(int inc, bool wrapAround = false)
+        {
+            int nextItemIdx = m_curItemIdx + inc;
+
+            if (nextItemIdx < 0 || nextItemIdx >= m_items.Count)
+            {
+                if (wrapAround && m_items.Count > 0)
+                {
+                    nextItemIdx = inc < 0 ? m_items.Count - 1 : 0;
+                }
+                else
+                {
+                    return false;
+                }
+            }
+
+            m_curItemIdx = nextItemIdx;
+            m_curItem = m_items[m_curItemIdx];
+            m_curItem.Reset();
+            var line = m_curItem.GetLine(0);
+            if (line.Length > 0)
+            {
+                Output(AccessibleSpeech.MENU_OPTION(line, GetDisplayIndex(), Count));
+            }
+
+            if (onReadItem != null)
+            {
+                onReadItem(m_curItem);
+            }
+
+            return true;
+        }
+
+        internal bool IsReading()
+        {
+            return m_curItem != null;
+        }
+
+        internal void StartReading()
+        {
+            if (m_items.Count == 0)
+            {
+                OutputNoItems();
+            }
+            else
+            {
+                ReadNextItem(0);
+            }
+        }
+
+        private void OutputNoItems()
+        {
+            if (m_noItemsTextOverride != null)
+            {
+                Output(m_noItemsTextOverride);
+            }
+            else
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+        }
+
+        private void ReadFromTop()
+        {
+            m_curItemIdx = 0;
+            StartReading();
+        }
+
+        private void ReadFromBottom()
+        {
+            m_curItemIdx = m_items.Count - 1;
+            StartReading();
+        }
+
+        internal void StartReadingFromIndex(int startingIndex)
+        {
+            m_curItemIdx = startingIndex;
+            StartReading();
+        }
+
+        internal void StartReadingReverse()
+        {
+            ReadNextItem(m_items.Count - 1);
+        }
+
+        internal T GetItemBeingRead()
+        {
+            return m_curItemIdx < m_items.Count ? m_items[m_curItemIdx] : null;
+        }
+
+        internal int GetItemBeingReadIndex()
+        {
+            return m_curItemIdx;
+        }
+
+        internal string GetHelp(bool hasBackButton)
+        {
+            if (m_items.Count == 0)
+            {
+                return AccessibleSpeech.MENU_NO_ITEMS_HELP;
+            }
+            else
+            {
+                return AccessibleSpeech.MENU_HORIZONTAL_HELP(hasBackButton);
+            }
+        }
+
+        internal void UpdateItems(List<T> items, bool preserveFocus = false)
+        {
+            var lastItemBeingRead = m_curItem;
+            m_items = items;
+
+            if (items.Count == 0)
+            {
+                m_curItemIdx = 0;
+                return;
+            }
+            else if (m_curItemIdx >= items.Count)
+            {
+                m_curItemIdx = items.Count - 1;
+            }
+
+            if (preserveFocus && IsReading())
+            {
+                var newIdx = m_items.IndexOf(lastItemBeingRead);
+                if (newIdx != -1)
+                {
+                    m_curItemIdx = newIdx;
+                }
+                else
+                {
+                    m_curItemIdx = 0;
+                    m_curItem = GetItemBeingRead();
+                }
+            }
+        }
+
+        internal void RemoveItem(T item)
+        {
+            var newItems = new List<T>();
+
+            foreach (var i in m_items)
+            {
+                if (i != item)
+                {
+                    newItems.Add(i);
+                }
+            }
+
+            UpdateItems(newItems);
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleLoanerDeck.cs b/Assembly-CSharp/Accessibility/AccessibleLoanerDeck.cs
new file mode 100644
index 0000000..ad2e833
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleLoanerDeck.cs
@@ -0,0 +1,27 @@
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleLoanerDeck : AccessibleItem
+    {
+        public CollectionDeck Deck;
+        public LoanerDeckSelectButton Button;
+        private string m_description;
+
+        internal AccessibleLoanerDeck(LoanerDeckSelectButton button, CollectionDeck deck, string description) : base(null)
+        {
+            Button = button;
+            Deck = deck;
+            m_description = description;
+        }
+
+        internal override List<string> GetLines()
+        {
+            List<string> ret = new List<string>();
+            ret.Add(Deck.Name);
+            ret.Add(GameStrings.GetClassName(Deck.GetClass()));
+            AccessibleCardUtils.AddLineIfExists(m_description, ret);
+            return ret;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs b/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs
new file mode 100644
index 0000000..fd348ca
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleLoginScreen.cs
@@ -0,0 +1,43 @@
+﻿using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleLoginScreen : AccessibleScreen
+    {
+        private static AccessibleLoginScreen s_instance = new AccessibleLoginScreen();
+
+        private PegUIElement m_startButton;
+
+        internal static AccessibleLoginScreen Get() {
+            return s_instance;
+        }
+
+        public void OnGameLoaded(PegUIElement startButton)
+        {
+            AccessibilityMgr.SetScreen(this);
+
+            m_startButton = startButton;
+
+            AccessibilityMgr.Output(this, LocalizedText.GLOBAL_GAME_LOADED);
+            AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_START);
+        }
+
+        public string GetHelp()
+        {
+            return AccessibleSpeech.PRESS_ENTER_TO_START;
+        }
+
+        public void HandleInput()
+        {
+            if (m_startButton != null && AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_startButton.TriggerRelease();
+                AccessibilityMgr.TransitioningScreens();
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleMenu.cs b/Assembly-CSharp/Accessibility/AccessibleMenu.cs
new file mode 100644
index 0000000..856c65b
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleMenu.cs
@@ -0,0 +1,352 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class AccessibleMenu : AccessibleElement
+    {
+            public delegate string GetTextDelegate();
+
+        private class MenuOption
+        {
+            internal string m_text;
+            internal GetTextDelegate m_getText;
+            internal Action m_onClickAction;
+            internal Action m_onReadAction;
+
+            internal MenuOption(string text, Action onClickAction)
+            {
+                m_text = text;
+                m_onClickAction = onClickAction;
+            }
+
+            internal MenuOption(string text, Action onClickAction, Action onReadAction)
+            {
+                m_text = text;
+                m_onClickAction = onClickAction;
+                m_onReadAction = onReadAction;
+            }
+
+            internal MenuOption(GetTextDelegate getText, Action onClickAction)
+            {
+                m_getText = getText;
+                m_onClickAction = onClickAction;
+            }
+        }
+
+        private string m_menuName;
+
+        private List<MenuOption> m_options;
+
+        private int m_curOptionIdx;
+
+        private Action m_goBackAction;
+
+        private bool m_isReading;
+
+        private bool m_isGlobalMenu;
+
+        private bool m_canConfirmWithSpace; // Only for local menus (e.g. emotes)
+
+        private Dictionary<AccessibleKey, MenuOption> m_hotkeys;
+
+        public AccessibleMenu(AccessibleComponent parent, string menuName, Action goBackAction, bool globalMenu=false, bool canConfirmWithSpace=false) : base(parent)
+        {
+            m_menuName = menuName;
+            m_options = new List<MenuOption>();
+            m_goBackAction = goBackAction;
+            m_isGlobalMenu = globalMenu;
+            m_canConfirmWithSpace = canConfirmWithSpace;
+            m_hotkeys = new Dictionary<AccessibleKey, MenuOption>();
+        }
+
+        public void AddOption(AccessibleKey hotkey, string option, Action onClickAction)
+        {
+            var newOption = new MenuOption(option, onClickAction);
+            m_options.Add(newOption);
+            m_hotkeys.Add(hotkey, newOption);
+        }
+
+        public void AddOption(AccessibleKey hotkey, string option, Action onClickAction, Action onReadAction)
+        {
+            var newOption = new MenuOption(option, onClickAction, onReadAction);
+            m_options.Add(newOption);
+            m_hotkeys.Add(hotkey, newOption);
+        }
+
+        public void AddOption(string option, Action onClickAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction));
+        }
+
+        public void AddOption(GetTextDelegate option, Action onClickAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction));
+        }
+
+        public void AddOption(string option, Action onClickAction, Action onReadAction)
+        {
+            m_options.Add(new MenuOption(option, onClickAction, onReadAction));
+        }
+
+        public bool HandleAccessibleInput()
+        {
+            try
+            {
+                if (ReadNextIsPressed())
+                {
+                    return ReadNextOption(1);
+                }
+                else if (ReadPrevIsPressed())
+                {
+                    return ReadNextOption(-1);
+                }
+                else if (ReadCurIsPressed())
+				{
+                    return ReadNextOption(0);
+				}
+                else if (ReadFirstIsPressed())
+				{
+                    return ReadFirstOption();
+				}
+                else if (ReadLastIsPressed())
+				{
+                    return ReadLastOption();
+				}
+                else if (ConfirmIsPressed())
+                {
+                    return SelectOption();
+                }
+                else if (BackIsPressed())
+                {
+                    return GoBack();
+                }
+                else
+				{
+                    return HandleHotkeys();
+				}
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return false;
+        }
+
+		private bool HandleHotkeys()
+		{
+			foreach (var hotkey in m_hotkeys)
+			{
+                if (hotkey.Key.IsPressed())
+				{
+                    hotkey.Value.m_onClickAction();
+                    return true;
+				}
+			}
+
+            return false;
+		}
+
+		private bool BackIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.BackIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.BACK.IsPressed();
+            }
+        }
+
+        private bool ConfirmIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.ConfirmIsPressed();
+            }
+            else
+            {
+                if (m_canConfirmWithSpace && AccessibleKey.SPACE.IsPressed())
+				{
+                    return true;
+				}
+
+                return AccessibleKey.CONFIRM.IsPressed();
+            }
+        }
+
+        private bool ReadPrevIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.ReadPrevIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_PREV_MENU_OPTION.IsPressed() || AccessibleKey.READ_PREV_VALID_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadCurIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.READ_CUR_GLOBAL_MENU_OPTION.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_CUR_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadFirstIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.READ_FIRST_ITEM_GLOBAL.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_FIRST_ITEM.IsPressed();
+            }
+        }
+
+        private bool ReadLastIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return AccessibleKey.READ_LAST_ITEM_GLOBAL.IsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_LAST_ITEM.IsPressed();
+            }
+        }
+
+        private bool ReadNextIsPressed()
+        {
+            if (m_isGlobalMenu)
+            {
+                return GlobalAccessibleMenuUtils.ReadNextIsPressed();
+            }
+            else
+            {
+                return AccessibleKey.READ_NEXT_MENU_OPTION.IsPressed() || AccessibleKey.READ_NEXT_VALID_MENU_OPTION.IsPressed();
+            }
+        }
+
+        private bool ReadFirstOption()
+        {
+            return ReadOption(0);
+        }
+
+        private bool ReadLastOption()
+        {
+            return ReadOption(m_options.Count - 1);
+        }
+
+        private bool ReadNextOption(int inc)
+        {
+            return ReadOption(m_curOptionIdx + inc);
+        }
+
+        private bool ReadOption(int optionIdx)
+		{
+            if (optionIdx < 0 || optionIdx >= m_options.Count)
+            {
+                return false;
+            }
+
+            m_curOptionIdx = optionIdx;
+            var curOption = m_options[m_curOptionIdx];
+
+            var curOptionText = curOption.m_text != null ? curOption.m_text : curOption.m_getText();
+            var speech = AccessibleSpeech.MENU_OPTION(curOptionText, m_curOptionIdx + 1, m_options.Count);
+            Output(speech);
+
+            if (curOption.m_onReadAction != null)
+            {
+                curOption.m_onReadAction();
+            }
+
+            return true;
+		}
+
+        private bool SelectOption()
+        {
+            if (!m_isReading || m_options.Count == 0)
+            {
+                return false;
+            }
+
+            m_options[m_curOptionIdx].m_onClickAction();
+
+            return true;
+        }
+
+        public bool GoBack()
+        {
+            if (m_goBackAction == null)
+            {
+                return false;
+            }
+
+            m_goBackAction();
+
+            return true;
+        }
+
+		public void StartReading(bool readMenuName = true)
+		{
+			if (readMenuName)
+			{
+				Output(m_menuName);
+			}
+
+			ReadCurrentOption();
+        }
+
+        public void ReadCurrentOption()
+        {
+            if (m_options.Count == 0)
+            {
+                Output(LocalizedText.MENU_NO_ITEMS);
+            }
+            else
+            {
+                ReadNextOption(0);
+                m_isReading = true;
+            }
+        }
+
+        public void SetIndex(int index)
+        {
+            m_curOptionIdx = index;
+        }
+
+        internal string GetHelp()
+        {
+            if (m_options.Count == 0)
+            {
+                return AccessibleSpeech.MENU_NO_ITEMS_HELP;
+            }
+            else
+            {
+                return AccessibleSpeech.MENU_HELP(m_goBackAction != null);
+            }
+        }
+
+        public int GetNumItems()
+        {
+            return m_options.Count;
+        }
+
+        public void Clear()
+        {
+            m_options.Clear();
+            m_curOptionIdx = 0;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs b/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs
new file mode 100644
index 0000000..061b95d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleMultilineText.cs
@@ -0,0 +1,31 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleMultilineText : AccessibleItem
+    {
+        private List<string> m_lines;
+
+        internal AccessibleMultilineText(AccessibleComponent parent, List<string> lines) : base(parent)
+        {
+            m_lines = lines;
+        }
+
+        internal AccessibleMultilineText(AccessibleComponent parent, List<string> lines, int startReadingFromLine) : base(parent, startReadingFromLine)
+        {
+            m_lines = lines;
+        }
+
+        internal AccessibleMultilineText(AccessibleComponent parent, params string[] lines) : base(parent)
+        {
+            m_lines = new List<string>();
+            m_lines.AddRange(lines);
+        }
+
+        internal override List<string> GetLines()
+        {
+            return m_lines;
+        }
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs b/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs
new file mode 100644
index 0000000..a2fd21e
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleNotificationMgr.cs
@@ -0,0 +1,26 @@
+﻿using System;
+
+namespace Accessibility
+{
+    static class AccessibleNotificationMgr
+    {
+        public static void OnCreateNotificationWithoutSound(Notification notification)
+        {
+            ReadNotification(notification);
+        }
+
+        public static void OnCreateNotificationWithSound(Notification notification)
+        {
+            if (!AccessibilityConfig.CAN_HEAR)
+            {
+                // Could look into doing something like this for deaf-blind support
+                ReadNotification(notification);
+            }
+        }
+
+        private static void ReadNotification(Notification notification)
+        {
+            AccessibilityMgr.OutputNotification(notification.speechUberText.Text);
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs b/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs
new file mode 100644
index 0000000..1b9911a
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessiblePlayDescriber.cs
@@ -0,0 +1,602 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessiblePlayDescriber
+    {
+        private static AccessiblePlayDescriber s_AccessiblePlayDescriber;
+
+        private HashSet<PowerTaskList> m_describedTaskLists = new HashSet<PowerTaskList>();
+
+        private int m_pendingReadings;
+
+        private AccessiblePlayDescriber() { }
+
+        internal static AccessiblePlayDescriber Get()
+        {
+            if (s_AccessiblePlayDescriber == null)
+            {
+                s_AccessiblePlayDescriber = new AccessiblePlayDescriber();
+            }
+
+            return s_AccessiblePlayDescriber;
+        }
+
+        internal void Reset()
+        {
+            m_describedTaskLists.Clear();
+        }
+
+        private bool ShouldCalloutTrigger(Entity entity)
+        {
+            if (entity == null)
+            {
+                return false;
+            }
+
+            if (entity.IsHero())
+            {
+                return false; // Don't think we need this since it just seems to be mission events
+            }
+
+            if (entity.IsCharacter() || entity.IsWeapon() || entity.IsSecret() || entity.IsQuest() || entity.IsQuestline() || entity.IsSideQuest() || entity.IsHeroPower())
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+		private bool ShouldOutputTrigger(Entity card)
+		{
+            if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+                return true;
+			}
+
+            // Battlegrounds exceptions
+            if (card.IsHeroPower() && AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return false;
+			}
+
+            return true;
+		}
+
+        internal string OnCardTriggered(PowerTaskList taskList)
+        {
+            var card = taskList.GetSourceEntity()?.CloneForAccessibility();
+
+            if (card == null || m_describedTaskLists.Contains(taskList) || card.IsGame()) // Passive treasures in duels are revealed as part of a game entity trigger.
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            // Some triggers (e.g. Battlegrounds Hero Powers in shop phase) are annoying
+            if (!ShouldOutputTrigger(card))
+			{
+                return null;
+			}
+
+            if (ShouldShowTriggeredBigCard(card, taskList))
+            {
+                return GetBigCardTriggeredText(card);
+            }
+
+            if (!ShouldCalloutTrigger(card))
+            {
+                return null;
+            }
+
+            var fullCardName = AccessibleSpeechUtils.GetFullNameInZone(card);
+
+            // Not really a play but the card itself may be useful if the player wants to read it
+            var play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_CARD_IN_ZONE_TRIGGERED, fullCardName);
+            return play;
+        }
+
+		private bool ShouldShowTriggeredBigCard(Entity card, PowerTaskList taskList)
+        {
+            if (PowerProcessor.ShouldShowTriggeredBigCard(card))
+            {
+                return true;
+            }
+
+            if (card.GetController() != null && card.IsControlledByOpposingSidePlayer())
+            {
+                // card.GetController() is needed due to potential NPEs in some triggers
+                // e.g. Baku the Mooneater
+                foreach (var task in taskList.GetTaskList())
+                {
+                    if (task.IsShowStartOfGameCard())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        internal string OnCardPlayed(PowerTaskList taskList)
+        {
+            var card = taskList.GetSourceEntity()?.CloneForAccessibility();
+            var blockStart = taskList.GetBlockStart();
+
+            AccessibilityUtils.LogDebug($"OnCardPlayed taskList ID: {taskList.GetId()}");
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            if (PowerProcessor.ShouldShowPlayedBigCard(card, blockStart))
+            {
+                var text = GetBigCardPlayedText(card, taskList);
+
+                if (text.Length > 0)
+                {
+                    return text; // We ignore some things like hero powers
+                }
+            }
+
+            bool isFriendlySide = card.IsControlledByFriendlySidePlayer();
+            var cardName = GetEntityName(card);
+            string play;
+
+            if (IsBlacklistedCard(card))
+			{
+                // e.g. BG cards such as "Drag to Buy, Refresh, etc"
+                return null;
+			}
+            else if (IsCardTrade(taskList))
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_TRADED_CARD, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_TRADED_CARD, cardName);
+                }
+            }
+            else if (card.IsMinion())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_SUMMONED_MINION, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_SUMMONED_MINION, cardName);
+                }
+            }
+            else if (card.IsWeapon())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_EQUIPPED_WEAPON, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_EQUIPPED_WEAPON, cardName);
+                }
+            }
+            else if (card.IsHeroPower())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_USED_HERO_POWER, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_USED_HERO_POWER, cardName);
+                }
+            }
+            else if (card.IsSecret())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CAST_SECRET, cardName);
+                }
+                else
+                {
+                    var cardClass = GameStrings.GetClassName(card.GetClass());
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CAST_SECRET, cardClass);
+                }
+                // FIXME: not sure if this won't break
+            }
+            else
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_PLAYED_CARD, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_PLAYED_CARD, cardName);
+                }
+            }
+
+            return play;
+        }
+
+		private bool IsBlacklistedCard(Entity card)
+		{
+            return AccessibleGameplayUtils.IsBattlegroundsSpecialCard(card);
+		}
+
+		private bool IsCardTrade(PowerTaskList taskList)
+        {
+            if (taskList == null || !taskList.IsOrigin() || !taskList.IsTradeBlock())
+            {
+                return false;
+            }
+
+            var source = taskList.GetSourceEntity();
+
+            if (source == null)
+            {
+				return false;
+            }
+
+            foreach (var task in taskList.GetTaskList())
+            {
+                if (task.IsCardTrade(source.GetEntityId()))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private string GetBigCardPlayedText(Entity card, PowerTaskList taskList)
+        {
+            var cardName = GetEntityName(card);
+            var cardText = card.GetCardTextBuilder().BuildCardTextInHand(card);
+            var isFriendlySide = card.IsControlledByFriendlySidePlayer();
+            string play;
+
+            if (IsCardTrade(taskList))
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_TRADED_CARD, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_TRADED_CARD, cardName);
+                }
+            }
+            else if (card.IsMinion())
+            {
+                var atk = card.GetATK();
+                var hp = card.GetHealth();
+
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_SUMMONED_MINION_BIG_CARD, cardName, atk, hp, cardText);
+                }
+                else
+                {
+                    if (!AccessibleCardUtils.HasHiddenStats(card))
+					{
+						play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD, cardName, atk, hp, cardText);
+					}
+                    else
+					{
+                        // e.g. BoH Valeera 08 (Silent Shadows)
+						play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD, cardName, "", "", cardText);
+					}
+				}
+            }
+            else if (card.IsSpell())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+            }
+            else if (card.IsHeroPower()) // This is tricky as it would fire after ptldescriber + we probably don't want to repeat this all the time
+            {
+                // Note: This wasn't being read but I think it's a good idea to do so since they're short anyways and can be read in the animation - experimenting
+
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_USED_HERO_POWER_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_USED_HERO_POWER_BIG_CARD, cardName, cardText);
+                }
+            }
+            else if (card.IsWeapon())
+            {
+                var atk = card.GetATK();
+                var durability = card.GetDurability();
+
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_EQUIPPED_WEAPON_BIG_CARD, cardName, atk, durability, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_EQUIPPED_WEAPON_BIG_CARD, cardName, atk, durability, cardText);
+                }
+            }
+            else if (card.IsSecret())
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CAST_SECRET_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    var cardClass = GameStrings.GetClassName(card.GetClass());
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CAST_SECRET, cardClass);
+                }
+            }
+            else if (card.GetCardType() == TAG_CARDTYPE.ENCHANTMENT)
+            {
+                if (isFriendlySide)
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD, cardName, cardText);
+                }
+            }
+            else
+            {
+                Log.Accessibility.Print($"GetBigCardPlayedText unknown type: {card.GetName()} / type = {card.GetCardType()}");
+                return "";
+            }
+
+            return play;
+        }
+
+        private string GetBigCardTriggeredText(Entity card)
+        {
+            var cardName = GetEntityName(card);
+            var cardText = $"{card.GetCardTextBuilder().BuildCardTextInHand(card)}";
+            string play;
+
+            if (card.IsControlledByFriendlySidePlayer())
+            {
+                // This might be the one that shows up for things like random spells and whatnot - confirm this
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CARD_TRIGGERED, cardName);
+            }
+            else
+            {
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_CARD_TRIGGERED_BIG_CARD, cardName, cardText);
+            }
+
+            return RegisterPlay(play);
+        }
+
+        internal void OnBigCardPlayed(PowerTaskList taskList, Entity card)
+        {
+            if (taskList == null)
+            {
+                AccessibilityUtils.LogDebug($"OnBigCardPlayed called with null taskList");
+            }
+
+            // Note: Splendiferous Whizbang shows its deck with a metadata power as part of its own start of game trigger block, Which is marked as handled when we announce the trigger.
+            if (card == null || (m_describedTaskLists.Contains(taskList) && !taskList.IsTriggerBlock()))
+            {
+                return;
+            }
+
+            var text = GetBigCardPlayedText(card, taskList);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            AccessibilityUtils.LogDebug("SPSGP Blocking power processor");
+            m_pendingReadings++;
+
+            AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+            RegisterPlay(text);
+        }
+
+        internal void OnBigCardTriggered(PowerTaskList taskList, Entity card)
+        {
+            if (taskList == null)
+            {
+                AccessibilityUtils.LogDebug($"OnBigCardTriggered called with null curTaskList - dropping");
+            }
+
+            if (card == null || m_describedTaskLists.Contains(taskList))
+            {
+                return;
+            }
+
+            // Some triggers (e.g. Battlegrounds Hero Powers in shop phase) are annoying
+            if (!ShouldOutputTrigger(card))
+			{
+                return;
+			}
+
+            var text = GetBigCardTriggeredText(card);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            AccessibilityUtils.LogDebug("SPSGP Blocking power processor");
+            m_pendingReadings++;
+
+            AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+        }
+
+        internal string OnFatigue(PowerTaskList taskList)
+        {
+            var source = taskList.GetSourceEntity();
+
+            if (source == null)
+            {
+                Log.Accessibility.Print("Fatigue had null source");
+                return null;
+            }
+
+            var side = source.GetControllerSide();
+            string play;
+
+            if (side == Player.Side.FRIENDLY)
+            {
+                play = LocalizationUtils.Get(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARD_FROM_EMPTY_DECK);
+            }
+            else
+            {
+                play = LocalizationUtils.Get(LocalizationKey.GAMEPLAY_OPPONENT_DREW_CARD_FROM_EMPTY_DECK);
+            }
+
+            return play;
+        }
+
+        internal List<string> OnCardsBurned(List<Entity> burnedCards)
+        {
+            var ret = new List<string>();
+
+            foreach(var card in burnedCards)
+            {
+                var cardName = GetEntityName(card);
+                string play;
+
+                if (card.IsControlledByFriendlySidePlayer())
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_DREW_CARD_BUT_BURNED, cardName);
+                }
+                else
+                {
+                    play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_OPPONENT_DREW_CARD_BUT_BURNED, cardName);
+                }
+
+                ret.Add(play);
+            }
+
+            return ret;
+        }
+
+        internal void OnAttack(PowerTaskList taskList)
+        {
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+                BattlegroundsOnAttack(taskList);
+			}
+            else
+			{
+                NormalOnAttack(taskList);
+			}
+        }
+
+		internal void BattlegroundsOnAttack(PowerTaskList taskList)
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                if (taskList.GetAttacker().IsHero())
+				{
+                    AccessiblePowerTaskListDescriber.Get().OnBattlegroundsHeroAttackPhase();
+				}
+                else if (AccessibleGameplayUtils.ShouldNarrateBattlegroundsAttackPhase())
+				{
+                    NormalOnAttack(taskList);
+				}
+			}
+            else
+			{
+                NormalOnAttack(taskList);
+			}
+		}
+
+		private void NormalOnAttack(PowerTaskList taskList)
+		{
+            var text = GetAttackText(taskList);
+
+            if (text != null)
+            {
+                AccessibilityMgr.OutputAndWait(text, null, OnOutputEnd);
+            }
+		}
+
+		internal string GetAttackText(PowerTaskList taskList)
+        {
+            if (m_describedTaskLists.Contains(taskList))
+            {
+                return null;
+            }
+
+            m_describedTaskLists.Add(taskList);
+
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds() &&
+                (taskList.GetAttacker().IsHero() || !AccessibleGameplayUtils.ShouldNarrateBattlegroundsAttackPhase()))
+            {
+                return null;
+            }
+
+            var attacker = taskList.GetAttacker();
+            var defender = taskList.GetDefender();
+            var proposedDefender = taskList.GetProposedDefender();
+
+            string play;
+
+            if (proposedDefender != null && proposedDefender.GetEntityId() != defender.GetEntityId())
+            {
+                var attackerName = GetFullNameInZone(attacker);
+                var proposedDefenderName = GetFullNameInZone(proposedDefender);
+                var defenderName = GetFullNameInZone(defender);
+
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_ENTITY_ATTACKED_OTHER, attackerName, proposedDefenderName, defenderName);
+            }
+            else
+            {
+                var attackerName = GetFullNameInZone(attacker);
+                var defenderName = GetFullNameInZone(defender);
+
+                play = LocalizationUtils.Format(LocalizationKey.GAMEPLAY_ENTITY_ATTACKED, attackerName, defenderName);
+            }
+
+            return RegisterPlay(play);
+        }
+
+        private void OnOutputEnd()
+        {
+            AccessibilityUtils.LogDebug("SPSGP Unblocking power processor");
+            m_pendingReadings--;
+        }
+
+        public bool IsBusy()
+        {
+            return m_pendingReadings > 0;
+        }
+
+        // History stuff
+        private string RegisterPlay(string action)
+        {
+            AccessibleHistoryMgr.Get().AddEntry(action);
+            return action;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessiblePlayMakerUtils.cs b/Assembly-CSharp/Accessibility/AccessiblePlayMakerUtils.cs
new file mode 100644
index 0000000..a1b3698
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessiblePlayMakerUtils.cs
@@ -0,0 +1,30 @@
+﻿using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessiblePlayMakerUtils
+    {
+        #region Debugging
+
+        public static void DebugFSM(string name, PlayMakerFSM fsm)
+        {
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+            AccessibilityUtils.LogDebug($"Debugging FSM {name}");
+            AccessibilityUtils.LogDebug($"States:");
+            foreach (var state in fsm.FsmStates)
+			{
+                AccessibilityUtils.LogDebug($"--- {state.Name} - {state.Description}");
+			}
+        }
+
+        #endregion
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs b/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs
new file mode 100644
index 0000000..8e3869d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessiblePowerTaskListDescriber.cs
@@ -0,0 +1,645 @@
+﻿using PegasusGame;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessiblePowerTaskListDescriber
+    {
+        private AccessibleInGameState m_lastDescribedState;
+
+        private bool m_blocked;
+
+        private bool m_canSnapshot;
+
+        private bool m_waitingForYourTurnBanner;
+
+        private List<string> m_descriptionsWaitingForTurnChange = new List<string>();
+
+        private TAG_STEP m_prevStep;
+
+        private bool m_gameOfficiallyStarted;
+
+        private bool m_turnStarted;
+
+        private int m_numEndTurnAttempts;
+
+        private static AccessiblePowerTaskListDescriber s_instance;
+
+        // Battlegrounds
+        private bool m_inBattlegroundsHeroAttackPhase;
+
+        public static AccessiblePowerTaskListDescriber Get()
+		{
+            if (s_instance == null)
+			{
+                InitInstance();
+			}
+
+            return s_instance;
+		}
+
+		private static void InitInstance()
+		{
+			if (AccessibleGameplayUtils.IsFindingOrPlayingBattlegrounds())
+			{
+                s_instance = new AccessibleBattlegroundsPowerTaskListDescriber();
+			}
+            else
+			{
+                s_instance = new AccessiblePowerTaskListDescriber();
+			}
+		}
+
+		public void OnGameStart()
+        {
+            try
+            {
+                AccessibilityUtils.LogDebug("PTL OnGameStart");
+
+                m_lastDescribedState = null;
+                m_canSnapshot = false;
+                m_waitingForYourTurnBanner = false;
+                m_descriptionsWaitingForTurnChange.Clear();
+                m_prevStep = TAG_STEP.INVALID;
+                m_gameOfficiallyStarted = false;
+                m_turnStarted = false;
+                m_numEndTurnAttempts = 0;
+
+                AccessiblePlayDescriber.Get().Reset();
+                AccessibleInGameState.Reset();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+		public void OnPowerTaskListStart(PowerTaskList taskList)
+        {
+            try
+            {
+                taskList.SetGlobalCompleteCallback(OnPowerTaskListEnd);
+
+                Network.HistBlockStart blockStart = taskList.GetBlockStart();
+                AccessibilityUtils.LogDebug($">>> Starting PowerTaskList.Id: {taskList.GetId()}. BlockType: {blockStart?.BlockType}");
+
+                if (!GameState.Get().IsGameCreated())
+                {
+                    return;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        public void OnPowerTaskListEnd(PowerTaskList taskList)
+        {
+            try
+            {
+                if (!GameState.Get().IsGameCreated())
+                {
+                    return;
+                }
+                AccessibilityUtils.LogDebug($">>> Ending PowerTaskList. Id: {taskList.GetId()}.");
+                AccessibilityUtils.LogDebug("SPS blocking power processor");
+                m_blocked = true;
+
+                var lines = new List<string>();
+
+                var canDescribe = true;
+
+                if (!GameHasOfficiallyStarted())
+                {
+                    canDescribe = false;
+                }
+
+                if (taskList.IsOrigin() && taskList.IsPlayBlock())
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnCardPlayed(taskList));
+                }
+                else if (taskList.IsOrigin() && taskList.IsBlockType(HistoryBlock.Type.FATIGUE))
+                {
+                    AccessibilityUtils.LogDebug("Fatigue");
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnFatigue(taskList));
+                }
+                else if (taskList.IsOrigin() && taskList.IsBlockType(HistoryBlock.Type.ATTACK))
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().GetAttackText(taskList));
+                    canDescribe = false;
+
+                    if ((taskList.GetAttacker()?.IsHero() ?? false) || (taskList.GetDefender()?.IsHero() ?? false))
+                    {
+                        canDescribe = true; // Describe state when a Hero is involved as dmg taken is more important there
+                    }
+                }
+
+                if (taskList.IsOrigin() && taskList.IsTriggerBlock())
+                {
+                    AddIfNotNull(lines, AccessiblePlayDescriber.Get().OnCardTriggered(taskList));
+                }
+
+                var burnedCards = GetBurnedCards(taskList);
+                if (burnedCards.Count > 0)
+                {
+                    lines.AddRange(AccessiblePlayDescriber.Get().OnCardsBurned(burnedCards));
+                }
+
+                // Battlegrounds hack
+                canDescribe = OverrideCanDescribeIfNecessary(canDescribe);
+
+                SnapshotAndDescribeGameState(lines, taskList, canDescribe);
+            }
+            catch (Exception e)
+            {
+                m_blocked = false;
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+		private bool OverrideCanDescribeIfNecessary(bool canDescribe)
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                return true;
+			}
+
+            return canDescribe;
+		}
+
+		private bool GameHasOfficiallyStarted()
+        {
+            if (!GameState.Get().IsGameCreated())
+            {
+                return false;
+            }
+
+            if (m_gameOfficiallyStarted)
+            {
+                return true;
+            }
+
+            // Tutorial games (no mulligan) must all go through one initial MAIN_READY step before they start (or so it seems)
+            var step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            if (step == TAG_STEP.MAIN_READY)
+            {
+                m_gameOfficiallyStarted = true;
+            }
+
+            return m_gameOfficiallyStarted;
+        }
+
+        private static void AddIfNotNull(List<string> lines, string text)
+        {
+            if (text == null || text.Length == 0)
+            {
+                return;
+            }
+
+            lines.Add(text);
+        }
+
+        private static List<Entity> GetBurnedCards(PowerTaskList taskList)
+        {
+            var ret = new List<Entity>();
+
+            List<PowerTask> taskList2 = taskList.GetTaskList();
+            for (int i = 0; i < taskList2.Count; i++)
+            {
+                Network.PowerHistory power = taskList2[i].GetPower();
+                if (power.Type != Network.PowerType.META_DATA)
+                {
+                    continue;
+                }
+                Network.HistMetaData histMetaData = (Network.HistMetaData)power;
+                if (histMetaData.MetaType != HistoryMeta.Type.BURNED_CARD)
+                {
+                    continue;
+                }
+                if (histMetaData.Info.Count == 0)
+                {
+                    continue;
+                }
+
+                foreach (var entityId in histMetaData.Info)
+                {
+                    var entity = GameState.Get().GetEntity(entityId);
+
+                    if (entity != null)
+                    {
+                        ret.Add(entity);
+                    }
+                }
+            }
+
+            return ret;
+        }
+
+        private void SnapshotAndDescribeGameState(List<string> lines, PowerTaskList taskList, bool canDescribe=true)
+        {
+            AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState canDescribe={canDescribe}");
+
+            var nextStep = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.NEXT_STEP);
+            var step = GameState.Get().GetGameEntity().GetTag<TAG_STEP>(GAME_TAG.STEP);
+
+            if (step == TAG_STEP.MAIN_END)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D1");
+
+                if (step != m_prevStep)
+				{
+                    // Battlegrounds-specific stuff to narrate Hero attacks
+					m_inBattlegroundsHeroAttackPhase = false;
+                    AccessibleGameplay.Get().OnMainStepEnd();
+				}
+
+				if (m_prevStep != step && m_turnStarted && IsRealEndTurn()) // IsRealEndTurn is because of Hemet Nesingwary and Illidan who break the game by ending the turn twice
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D2");
+
+                    if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+					{
+						lines.Add(LocalizedText.GAMEPLAY_TURN_ENDED);
+//                        AccessibleHistoryMgr.Get().AddEntry(LocalizedText.GAMEPLAY_TURN_ENDED);
+					}
+
+					OnTurnEnded();
+                    m_canSnapshot = true;
+                }
+            }
+            else if (step == TAG_STEP.MAIN_READY) // Allow trigger effects to be described before turn-related stuff
+            {
+                lines.AddRange(OnTurnChange());
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D3");
+                m_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_START_TRIGGERS)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D4");
+                m_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_START)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D5");
+                m_canSnapshot = true;
+            }
+            else if (step == TAG_STEP.MAIN_ACTION && step != m_prevStep)
+			{
+				AccessibleGameplay.Get().OnMainActionStep();
+			}
+			else if (step == TAG_STEP.BEGIN_MULLIGAN)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D6");
+                m_canSnapshot = true;
+
+                if (GameState.Get().IsFriendlySidePlayerTurn() && !m_turnStarted)
+                {
+                    // Start of game card (e.g. C'Thun) trigger during the mulligan and the banner comes first
+                    m_waitingForYourTurnBanner = true;
+                }
+            }
+            else if (m_prevStep == TAG_STEP.BEGIN_MULLIGAN && step != m_prevStep)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D7");
+                m_canSnapshot = false;
+            }
+
+            m_prevStep = step;
+
+            if (m_lastDescribedState == null)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D8");
+                m_canSnapshot = true; // Start snapshotting after game starts due to tutorial stuff
+
+                // Useful for e.g. handling reconnects in Battlegrounds
+                AccessibleGameplay.Get().OnFirstTaskListStart();
+            }
+
+            if (!m_canSnapshot)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D9");
+
+                if (!m_waitingForYourTurnBanner)
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D10");
+                    Output(lines);
+                }
+                else
+                {
+                    AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D11");
+                    m_descriptionsWaitingForTurnChange.AddRange(lines);
+                    m_blocked = false;
+                }
+                return;
+            }
+
+            var newState = AccessibleInGameState.GetCurrentState(taskList);
+
+            if (canDescribe) // TODO: Rethink this
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D12");
+                var description = AccessibleInGameState.DescribeDiff(taskList, m_lastDescribedState, newState);
+
+                AddIfNotNull(lines, description);
+                //AccessibleHistoryMgr.Get().AddEntry(description);
+            }
+
+            var prevState = m_lastDescribedState;
+            m_lastDescribedState = newState;
+            var canOutputStateDiff = CanOutputStateDiff(taskList, prevState, newState);
+
+            if (canOutputStateDiff)
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D13");
+                Output(lines);
+            }
+            else
+            {
+                AccessibilityUtils.LogDebug($"PTL SnapshotAndDescribeGameState D14");
+                m_descriptionsWaitingForTurnChange.AddRange(lines);
+                m_blocked = false;
+            }
+
+            // Hack for Battlegrounds - see below
+            // Note: needs to be here so we don't read out things like "your opponent Hero became Bartender Bob etc" due to narration order
+            OnNarrationEnd(taskList, prevState, newState, canOutputStateDiff);
+        }
+
+		private void OnNarrationEnd(PowerTaskList taskList, AccessibleInGameState prevState, AccessibleInGameState newState, bool hasOutputtedStateDiff)
+		{
+            // Necessary for Battlegrounds
+            // TODO: Refactor everything once we figure out the final narration interface for Battlegrounds
+            var opponentHeroChanged = AccessibleInGameState.HasOpponentHeroChanged(prevState, newState);
+
+            if (opponentHeroChanged)
+			{
+                AccessibleGameplay.Get().OnOpponentHeroChanged();
+			}
+
+            var anyHeroGainedAtk = AccessibleInGameState.HasAnyHeroGainedAtk(prevState, newState);
+
+            if (anyHeroGainedAtk)
+			{
+                AccessibleGameplay.Get().OnAnyHeroGainedAtk();
+			}
+
+            // Used for narrating permanent effects to Tarecgosa at the moment
+            // TODO: Refactor everything once the interface is settled
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                HandleNarrationEndForBattlegrounds(taskList, prevState, newState, hasOutputtedStateDiff);
+			}
+		}
+
+		private void HandleNarrationEndForBattlegrounds(PowerTaskList taskList, AccessibleInGameState prevState, AccessibleInGameState newState, bool hasOutputtedStateDiff)
+		{
+            // Note: hasOutputtedStateDiff is used to prevent against describing the same state twice in an edge case where
+            // both the source card of a trigger and the target have permanent effects e.g. Tarecgosa gaining poison from a SI:Sefin
+            var battlegroundsGameplay = AccessibleGameplay.Get() as AccessibleBattlegroundsGameplay;
+
+            if (battlegroundsGameplay.IsInCombatPhase() && !hasOutputtedStateDiff)
+			{
+                var lines = BattlegroundsCardEffectInterpreter.GetTarecgosaDiffs(taskList, prevState, newState, battlegroundsGameplay.GetStateAtStartOfCombat());
+
+                if (lines.Count > 0)
+				{
+                    Output(lines);
+				}
+			}
+		}
+
+		private bool CanOutputStateDiff(PowerTaskList taskList, AccessibleInGameState prevState, AccessibleInGameState newState)
+		{
+            // Hack for Battlegrounds while we don't refactor this entire thing
+            // Note: need to figure out how much is going to be narrated before we even consider refactoring
+            // As a starting point, describe everything within shop phase and leave everything out of combat phase until we get feedback from players
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+			{
+                return CanOutputStateDiffDuringBattlegrounds(taskList, prevState, newState);
+			}
+
+            return !m_waitingForYourTurnBanner;
+		}
+
+		private bool CanOutputStateDiffDuringBattlegrounds(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+		{
+            if (GameState.Get().IsMulliganPhase())
+			{
+                // BG games start instantly for taskListDescriber
+                return false;
+			}
+
+			if (AccessibleInGameState.HasOpponentHeroChanged(before, after))
+			{
+				// Bartender Bob became X is sometimes delayed (i.e. after the recruit phase starts)
+				// Need to disable this or else we'll describe the tavern, your battlefield, hero powers, etc.
+				return false;
+			}
+
+			if (m_inBattlegroundsHeroAttackPhase)
+			{
+                if (AccessibleInGameState.HasAnyHeroLostAtk(before, after))
+				{
+                    // Don't narrate attacks lost when the game ends. There's also a few edge cases when playing vs players where this would happen
+                    return false;
+				}
+
+                if (AccessibleInGameState.HasAnyHeroRecoveredHealth(before, after))
+				{
+                    // Kel'Thuzad (i.e. ghost/dead players) causes your opponent's Hero to recover health at the end of the combat phase due to recovering back to 0
+                    return false;
+				}
+
+				// Output state as normal as soon as one Hero attacks to inform about attack, damage and narrate any potential secrets (e.g. ice blocks) etc.
+				return true;
+			}
+
+            if (AccessibleInGameState.HasPlayerReceivedCards(before, after))
+			{
+                // Output any received cards for cases such as Avenge(x): draw something, buddy meters, etc.
+                return true;
+			}
+
+            var battlegroundsGameplay = AccessibleGameplay.Get() as AccessibleBattlegroundsGameplay;
+
+            if (battlegroundsGameplay.IsInShopPhase())
+			{
+                return true;
+			}
+            else if (battlegroundsGameplay.IsInCombatPhase())
+			{
+                return BattlegroundsCardEffectInterpreter.ShouldOutputStateDiff(taskList, before, after);
+			}
+
+            return false;
+		}
+
+		private bool IsRealEndTurn()
+        {
+            m_numEndTurnAttempts++;
+
+            return true;
+        }
+
+        private List<string> OnTurnChange()
+        {
+            var ret = new List<string>();
+
+            if (m_turnStarted)
+            {
+                return ret;
+            }
+
+            m_turnStarted = true;
+
+            if (GameState.Get().IsFriendlySidePlayerTurn())
+            {
+                m_waitingForYourTurnBanner = true;
+            }
+            else
+            {
+                if (!AccessibleGameplayUtils.IsPlayingBattlegrounds())
+				{
+					ret.Add(LocalizedText.GAMEPLAY_OPPONENT_TURN);
+					DescribeInitialBoardStateIfNeeded(ret);
+				}
+			}
+
+            return ret;
+        }
+
+        internal void OnTurnStart(bool readMana)
+        {
+            m_waitingForYourTurnBanner = false;
+            m_turnStarted = true;
+
+            var descriptions = new List<string>();
+            descriptions.Add(LocalizedText.GAMEPLAY_YOUR_TURN);
+            if (readMana)
+            {
+                descriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_TURN_START_READ_MANA, GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources()));
+            }
+            DescribeInitialBoardStateIfNeeded(descriptions);
+            descriptions.AddRange(m_descriptionsWaitingForTurnChange);
+            m_descriptionsWaitingForTurnChange.Clear();
+
+            Output(descriptions);
+        }
+
+        private static void DescribeInitialBoardStateIfNeeded(List<string> descriptions)
+        {
+            if (GameState.Get().GetTurn() != 1)
+            {
+                return;
+            }
+
+            // This is needed for some BoH such as Jaina 6 and Rexxar 3
+            var friendlySideMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCards();
+            if (friendlySideMinions.Count > 0)
+            {
+                var friendlySideMinionNames = AccessibleSpeechUtils.GetNames(friendlySideMinions);
+                descriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_SPECIAL_STARTING_PLAYER_BATTLEFIELD, friendlySideMinionNames));
+            }
+
+            var opposingSideMinions = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCards();
+            if (opposingSideMinions.Count > 0)
+            {
+                var opposingSideMinionNames = AccessibleSpeechUtils.GetNames(opposingSideMinions);
+                descriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_SPECIAL_STARTING_OPPONENT_BATTLEFIELD, opposingSideMinionNames));
+            }
+        }
+
+        private void Output(string text)
+        {
+            if (text == null || text.Length == 0)
+            {
+                AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+                m_blocked = false;
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"SPS Describing blocked task list: {text}");
+            AccessibilityMgr.OutputAndWait(text, OnOutputStart, OnOutputEnd);
+            AccessibleHistoryMgr.Get().AddEntry(text);
+        }
+
+        private void Output(List<string> lines)
+        {
+            if (lines == null || lines.Count == 0)
+            {
+                AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+                m_blocked = false;
+            }
+            else
+            {
+                Output(AccessibleSpeechUtils.CombineLines(lines));
+            }
+        }
+
+		internal void OnBattlegroundsHeroAttackPhase()
+		{
+            m_inBattlegroundsHeroAttackPhase = true;
+		}
+
+		internal void OnBattlegroundsHeroAttackPhaseEnd()
+		{
+            m_inBattlegroundsHeroAttackPhase = false;
+		}
+
+		private void OnOutputStart()
+        {
+        }
+
+        private void OnOutputEnd()
+        {
+            AccessibilityUtils.LogDebug("SPS Unblocking power processor");
+            m_blocked = false;
+        }
+
+        public bool IsBusy()
+        {
+            return m_blocked;
+        }
+
+        #region Weapon stuff
+
+        private void OnTurnEnded()
+        {
+            var curPlayer = GameState.Get().GetCurrentPlayer();
+            var otherPlayer = GameState.Get().GetFirstOpponentPlayer(curPlayer);
+
+            if (curPlayer.HasWeapon())
+            {
+                AccessibleInGameState.MarkWeaponSheathed(curPlayer.GetHero());
+            }
+
+            if (otherPlayer.HasWeapon())
+            {
+                AccessibleInGameState.MarkWeaponUnsheathed(otherPlayer.GetHero());
+            }
+
+            m_turnStarted = false;
+
+            AccessibleGameplay.Get().OnTurnEnded();
+        }
+
+        internal void OnReconnected()
+        {
+            AccessibilityUtils.LogDebug("PTL OnReconnected");
+            m_gameOfficiallyStarted = true;
+            m_turnStarted = true;
+        }
+
+        #endregion
+
+		internal AccessibleInGameState GetLastDescribedState()
+		{
+            return m_lastDescribedState;
+		}
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessiblePracticeAIButton.cs b/Assembly-CSharp/Accessibility/AccessiblePracticeAIButton.cs
new file mode 100644
index 0000000..1112ecd
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessiblePracticeAIButton.cs
@@ -0,0 +1,30 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessiblePracticeAIButton : AccessibleItem
+    {
+        private readonly PracticeAIButton m_button;
+
+        internal AccessiblePracticeAIButton(AccessibleComponent parent, PracticeAIButton button) : base(parent)
+        {
+            m_button = button;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            // Name
+            ret.Add(m_button.m_name.Text);
+
+            // Undefeated label
+            if (m_button.m_questBang.activeInHierarchy)
+            {
+                ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_OPPONENT_MENU_UNDEFEATED_OPPONENT_LABEL));
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleQuest.cs b/Assembly-CSharp/Accessibility/AccessibleQuest.cs
new file mode 100644
index 0000000..9f9cb37
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleQuest.cs
@@ -0,0 +1,188 @@
+﻿using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleQuest : AccessibleItem
+    {
+        private readonly QuestDataModel m_questDataModel;
+
+        private readonly Hearthstone.Progression.QuestTile m_questTile;
+
+        internal AccessibleQuest(AccessibleComponent parent, QuestDataModel questDataModel, Hearthstone.Progression.QuestTile questTile=null) : base(parent)
+        {
+            m_questDataModel = questDataModel;
+            m_questTile = questTile;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_questDataModel.DisplayMode == Hearthstone.Progression.QuestManager.QuestDisplayMode.NextQuestTime)
+			{
+                return GetLinesForNextQuestTime();
+			}
+            else
+			{
+                return GetLinesForNormalQuestTile();
+			}
+        }
+
+		private List<string> GetLinesForNextQuestTime()
+		{
+            var ret = new List<string>();
+            ret.Add(m_questDataModel.TimeUntilNextQuest);
+			return ret;
+		}
+
+		private List<string> GetLinesForNormalQuestTile()
+		{
+            var ret = new List<string>();
+
+            if (m_questDataModel.Name?.Length > 0) // New quests don't have a name. Instead, they have the XP scroll at the top so we use GetRewards as the name
+            {
+                ret.Add(m_questDataModel.Name);
+            }
+
+            var rewards = GetRewards();
+
+            if (rewards.Length > 0)
+            {
+                ret.Add(rewards);
+            }
+
+            ret.Add(m_questDataModel.Description);
+
+            var progress = GetProgress(m_questDataModel);
+
+            if (progress.Length > 0)
+            {
+                ret.Add(progress);
+            }
+
+            if (CanAbandonQuest())
+			{
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_QUEST_LOG_ABANDON_QUEST, AccessibleKey.ABANDON_QUEST));
+			}
+
+            if (CanRerollQuest())
+			{
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_QUEST_LOG_REROLL_QUEST, AccessibleKey.REROLL_QUEST));
+			}
+
+            return ret;
+		}
+
+        internal override bool HandleAccessibleInput()
+		{
+            if (base.HandleAccessibleInput())
+            {
+                return true;
+            }
+            else if (AccessibleKey.REROLL_QUEST.IsPressed() && CanRerollQuest())
+			{
+				AccessibleWidgetUtils.ClickButton(GetRerollQuestButton());
+				return true;
+			}
+			else if (AccessibleKey.ABANDON_QUEST.IsPressed() && CanAbandonQuest())
+			{
+				AccessibleWidgetUtils.ClickButton(GetAbandonQuestButton());
+				return true;
+			}
+
+            return false;
+		}
+
+		private string GetRewards()
+        {
+            if (m_questDataModel.RewardTrackXp > 0) // New quests give XP as rewards instead of anything else
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_QUEST_NO_NAME_XP_ONLY, m_questDataModel.RewardTrackXp);
+            }
+
+            var rewards = m_questDataModel.Rewards; // Non-XP quests give other rewards
+
+            if (rewards == null)
+            {
+                return "";
+            }
+
+            if (rewards.Description?.Length > 0)
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_DESCRIPTION, rewards.Description);
+            }
+
+            var rwds = new List<string>();
+            foreach (var rwd in rewards.Items)
+            {
+                rwds.Add(new AccessibleRewardItemDataModel(m_parent, rwd).GetLine(0));
+            }
+
+            var lst = AccessibleSpeechUtils.HumanizeList(rwds);
+
+            if (rewards.ChooseOne)
+            {
+                return LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_CHOOSE_ONE_DESCRIPTION, lst);
+            }
+
+            return lst;
+        }
+
+        internal static string GetProgress(QuestDataModel questDataModel)
+        {
+            if (questDataModel.Quota == 0)
+            {
+                return "";
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, questDataModel.Progress, questDataModel.Quota);
+        }
+
+        public QuestDataModel GetQuestDataModel()
+		{
+            return m_questDataModel;
+		}
+
+        public Hearthstone.Progression.QuestTile GetQuestTile()
+		{
+            return m_questTile;
+		}
+
+        private bool CanAbandonQuest()
+		{
+            return GetAbandonQuestButton() != null;
+		}
+
+        private bool CanRerollQuest()
+		{
+            return GetRerollQuestButton() != null;
+		}
+
+		private PegUIElement GetAbandonQuestButton()
+		{
+            return GetAbandonOrRerollQuestButton("AbandonButton");
+		}
+
+		private PegUIElement GetRerollQuestButton()
+		{
+            return GetAbandonOrRerollQuestButton("RerollButton");
+		}
+
+        private PegUIElement GetAbandonOrRerollQuestButton(string buttonName)
+		{
+            if (m_questTile == null)
+			{
+                return null;
+			}
+
+            var buttonGO = AccessibleUnityUtils.GetChildObject(m_questTile.gameObject, $"Root/{buttonName}");
+            var button = AccessibleUnityUtils.GetComponent<PegUIElement>(buttonGO);
+
+            if (button == null || !button.isActiveAndEnabled)
+			{
+                return null;
+			}
+
+            return button;
+		}
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs b/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs
new file mode 100644
index 0000000..040d6fc
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleQuestTile.cs
@@ -0,0 +1,82 @@
+﻿using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleQuestTile : AccessibleItem
+    {
+        private readonly QuestTile m_quest;
+
+        internal AccessibleQuestTile(AccessibleComponent parent, QuestTile quest) : base(parent)
+        {
+            m_quest = quest;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(m_quest.m_questName.Text);
+            ret.Add(GetRewards());
+            ret.Add(m_quest.m_requirement.Text);
+
+            var progress = GetProgress();
+            if (progress.Length > 0)
+            {
+                ret.Add(progress);
+            }
+
+            return ret;
+        }
+
+        private string GetRewards()
+        {
+            var rewards = m_quest.m_quest.Rewards;
+
+            var rewardTexts = new List<string>();
+
+            foreach (var reward in rewards)
+            {
+                rewardTexts.Add(StringifyRewardType(reward.RewardType));
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.UI_QUEST_REWARD_DESCRIPTION, AccessibleSpeechUtils.HumanizeList(rewardTexts));
+        }
+
+        private string GetProgress()
+        {
+            var achievement = m_quest.m_quest;
+            if (achievement.MaxProgress > 1)
+            {
+                return LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, achievement.Progress, achievement.MaxProgress);
+            }
+
+            return "";
+        }
+
+        private string StringifyRewardType(Reward.Type rewardType)
+        {
+            switch (rewardType)
+            {
+                case Reward.Type.ARCANE_DUST:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_DUST);
+                case Reward.Type.BOOSTER_PACK:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD_PACK);
+                case Reward.Type.CARD:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD);
+                case Reward.Type.CARD_BACK:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD_BACK);
+                case Reward.Type.GOLD:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_GOLD);
+                case Reward.Type.MOUNT:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MOUNT);
+                case Reward.Type.ARCANE_ORBS:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_ORBS);
+                case Reward.Type.MINI_SET:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MINI_SET);
+                default:
+                    return LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_UNKNOWN);
+            }
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleRewardData.cs b/Assembly-CSharp/Accessibility/AccessibleRewardData.cs
new file mode 100644
index 0000000..0166694
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleRewardData.cs
@@ -0,0 +1,264 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Accessibility
+{
+    class AccessibleRewardData : AccessibleItem
+    {
+        internal RewardData RewardData { get; }
+
+        private List<string> m_cachedLines;
+
+        internal AccessibleRewardData(AccessibleComponent parent, RewardData rewardData) : base(parent)
+        {
+            RewardData = rewardData;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_cachedLines == null)
+            {
+                m_cachedLines = GetLinesImpl();
+            }
+
+            return m_cachedLines;
+        }
+
+        private List<string> GetLinesImpl()
+        {
+            switch (RewardData.RewardType)
+            {
+                case Reward.Type.ARCANE_DUST:
+                    return GetLinesForArcaneDustReward();
+                case Reward.Type.BOOSTER_PACK:
+                    return GetLinesForBoosterPackReward();
+                case Reward.Type.GOLD:
+                    return GetLinesForGoldReward();
+                 case Reward.Type.CARD:
+                    return GetLinesForCardReward();
+                 case Reward.Type.CARD_BACK:
+                    return GetLinesForCardBackReward();
+                 case Reward.Type.MOUNT:
+                    return GetLinesForMountReward();
+                 case Reward.Type.ARCANE_ORBS:
+                    return GetLinesForArcaneOrbsReward();
+                 case Reward.Type.MINI_SET:
+                    return GetLinesForMiniSetReward();
+                 case Reward.Type.FORGE_TICKET:
+                    return GetLinesForForgeTicketReward();
+                    case Reward.Type.DECK:
+                    return GetLinesForDeckReward();
+                 case Reward.Type.CRAFTABLE_CARD:
+                 case Reward.Type.CLASS_CHALLENGE:
+                 case Reward.Type.EVENT:
+                 case Reward.Type.RANDOM_CARD:
+                 case Reward.Type.BONUS_CHALLENGE:
+                 case Reward.Type.ADVENTURE_DECK:
+                 case Reward.Type.ADVENTURE_HERO_POWER:
+                 default:
+                    return GetLinesForUnknownReward();
+            }
+        }
+
+		private List<string> GetLinesForUnknownReward()
+		{
+			var ret = new List<string>();
+			ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_UNKNOWN));
+			return ret;
+		}
+
+		private List<string> GetLinesForForgeTicketReward()
+        {
+            var ret = new List<string>();
+
+            ForgeTicketRewardData reward = (ForgeTicketRewardData)RewardData;
+
+            var numTickets = reward.Quantity;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_TICKETS, numTickets));
+            return ret;
+        }
+
+        private List<string> GetLinesForMiniSetReward()
+        {
+            var ret = new List<string>();
+
+            MiniSetRewardData reward = (MiniSetRewardData)RewardData;
+
+			MiniSetDbfRecord record = GameDbf.MiniSet.GetRecord(reward.MiniSetID);
+			int count = record.DeckRecord.Cards.Count;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_MINI_SET_WITH_N_CARDS, count));
+            return ret;
+        }
+
+        private List<string> GetLinesForArcaneOrbsReward()
+        {
+            var ret = new List<string>();
+
+            SimpleRewardData reward = (SimpleRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_ORBS, reward.Amount));
+            return ret;
+        }
+
+        private List<string> GetLinesForMountReward()
+        {
+            var ret = new List<string>();
+
+            MountRewardData reward = (MountRewardData)RewardData;
+
+            // Localizing this would be pointless
+            /*switch (reward.Mount)
+            {
+                case MountRewardData.MountType.HEROES_MAGIC_CARPET_CARD:
+                    ret.Add($"You got a Magic Carpet mount in Heroes of the Storm");
+                    break;
+                case MountRewardData.MountType.WOW_HEARTHSTEED:
+                    ret.Add($"You got a Hearthsteed mount in World of Warcraft");
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MOUNT));
+                    break;
+                default:
+                    break;
+
+            }*/
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_MOUNT));
+            return ret;
+        }
+
+        private List<string> GetLinesForArcaneDustReward()
+        {
+            var ret = new List<string>();
+
+            ArcaneDustRewardData reward = (ArcaneDustRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_DUST, reward.Amount));
+            return ret;
+        }
+
+        private List<string> GetLinesForBoosterPackReward()
+        {
+            var ret = new List<string>();
+
+            BoosterPackRewardData reward = (BoosterPackRewardData)RewardData;
+
+            var numPacks = reward.Count;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_PACKS, numPacks));
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetCardPackName(reward.Id), ret);
+
+            return ret;
+        }
+
+        private List<string> GetLinesForGoldReward()
+        {
+            var ret = new List<string>();
+
+            GoldRewardData reward = (GoldRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_GOLD, reward.Amount));
+            return ret;
+        }
+
+        private List<string> GetLinesForCardReward()
+        {
+            CardRewardData reward = (CardRewardData)RewardData;
+
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(reward.CardID);
+
+            if (entityDef.GetTag(GAME_TAG.BACON_SKIN) == 1)
+			{
+                // BG Hero skins are marked with RewardType card for some reason (even though a proper RewardType exists for it)
+                return GetLinesForUnknownReward();
+			}
+            else if (entityDef.IsHeroSkin())
+            {
+                return GetLinesForUnlockedHero(reward);
+            }
+            else
+            {
+                var ret = new List<string>();
+                var numCards = reward.Count;
+                var collectibleCard = CollectionManager.Get().GetCard(reward.CardID, reward.Premium);
+                var cardClass = GameStrings.GetClassName(entityDef.GetClass());
+
+                if (entityDef.IsCoreCard())
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CORE_CARD_FROM_CLASS, numCards, cardClass));
+                }
+                else
+                {
+                    ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CARD_FROM_CLASS, numCards, cardClass));
+                }
+
+                ret.AddRange(new AccessibleCollectibleCard(m_parent, collectibleCard, false).GetLines());
+
+                return ret;
+            }
+        }
+
+        private List<string> GetLinesForUnlockedHero(CardRewardData reward)
+        {
+            var ret = new List<string>();
+
+            var collectibleCard = CollectionManager.Get().GetCard(reward.CardID, TAG_PREMIUM.NORMAL);
+            var heroName = collectibleCard.Name;
+            var @class = DefLoader.Get().GetEntityDef(reward.CardID).GetClass();
+            var className = GameStrings.GetClassName(@class);
+
+            if (reward.Premium == TAG_PREMIUM.GOLDEN)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_GOLDEN_HERO, heroName));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_HERO, className));
+                return ret;
+            }
+            else if (GameUtils.IsVanillaHero(reward.CardID))
+            {
+                var numHeroes = GameUtils.DEFAULT_HERO_CLASSES.Length;
+                var numUnlockedHeroes = AchieveManager.Get().NumDefaultHeroesUnlocked();
+                var record = GameDbf.Class.GetRecord((int)@class);
+
+                ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_NEW_CLASS_UNLOCKED));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_HERO, className));
+                ret.Add(record.PreviewDesc.GetString());
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_NEW_CLASS_STRENGTHS, record.StrengthsDesc.GetString()));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_NEW_CLASS_WEAKNESSES, record.WeaknessesDesc.GetString()));
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_UNLOCK_PROGRESS, numUnlockedHeroes, numHeroes));
+                return ret;
+            }
+            else
+            {
+                ret.Add(heroName);
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CLASS_HERO, className));
+                return ret;
+            }
+        }
+
+        private List<string> GetLinesForCardBackReward()
+        {
+            var ret = new List<string>();
+
+            CardBackRewardData reward = (CardBackRewardData)RewardData;
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD_BACK));
+            return ret;
+        }
+
+        private List<string> GetLinesForDeckReward()
+        {
+            var ret = new List<string>();
+            DeckRewardData reward = (DeckRewardData)RewardData;
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_DECK));
+            var record = GameDbf.Deck.GetRecord(reward.DeckId);
+            if (record != null)
+            {
+                ret.Add(record.Name.GetString());
+            }
+            return ret;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs b/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs
new file mode 100644
index 0000000..b381e88
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleRewardItemDataModel.cs
@@ -0,0 +1,196 @@
+﻿using Assets;
+using Hearthstone.DataModels;
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleRewardItemDataModel : AccessibleItem
+    {
+        private RewardItemDataModel m_reward;
+
+        private List<string> m_cachedLines;
+
+        private bool m_includeRewardType; // Used to suppress redundant reward types in certain screens e.g. choosing hero skins in a "choose hero skin" menu
+
+        internal AccessibleRewardItemDataModel(AccessibleComponent parent, RewardItemDataModel reward, bool includeRewardType = true) : base(parent)
+        {
+            m_reward = reward;
+            m_includeRewardType = includeRewardType;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_cachedLines == null)
+            {
+                m_cachedLines = GetLinesImpl();
+            }
+
+            return m_cachedLines;
+        }
+
+        private List<string> GetLinesImpl()
+        {
+            switch (m_reward.ItemType)
+            {
+                case RewardItemType.BOOSTER:
+                    return GetLinesForCardPackReward();
+                case RewardItemType.DUST:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_DUST, m_reward.Quantity));
+                case RewardItemType.HERO_SKIN:
+                    return GetLinesForHeroSkinReward();
+                case RewardItemType.CARD_BACK:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_BACKS, m_reward.Quantity));
+                /*case RewardItemType.ADVENTURE_WING:
+                    return AsList($"{m_reward.Quantity} Adventure Wing{suffix}");*/
+                case RewardItemType.ARENA_TICKET:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARENA_TICKETS, m_reward.Quantity));
+                /*case RewardItemType.RANDOM_CARD:
+                    return AsList($"{m_reward.Quantity} random card{suffix}");*/
+                case RewardItemType.CN_RUNESTONES:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_RUNESTONES, m_reward.Quantity));
+                case RewardItemType.CN_ARCANE_ORBS:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_ORBS, m_reward.Quantity));
+                case RewardItemType.ADVENTURE:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ADVENTURES, m_reward.Quantity));
+                case RewardItemType.CARD:
+                    return GetLinesForCardReward();
+                /*case RewardItemType.BATTLEGROUNDS_BONUS:
+                    return AsList($"{m_reward.Quantity} Battlegrounds bonus{bonusSuffix}");*/
+                case RewardItemType.TAVERN_BRAWL_TICKET:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_TAVERN_BRAWL_TICKETS, m_reward.Quantity));
+                case RewardItemType.GOLD:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_GOLD, m_reward.Quantity));
+                case RewardItemType.CUSTOM_COIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CUSTOM_COINS, m_reward.Quantity));
+                /*case RewardItemType.PROGRESSION_BONUS:
+                    return AsList($"{m_reward.Quantity} progression bonus{bonusSuffix}");*/
+                case RewardItemType.REWARD_TRACK_XP_BOOST:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_XP_BOOST, m_reward.Quantity));
+                case RewardItemType.MINI_SET:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_MINI_SETS, m_reward.Quantity));
+                /*case RewardItemType.CARD_SUBSET:
+                    return AsList($"{m_reward.Quantity} Card subset{suffix}");
+                case RewardItemType.SELLABLE_DECK:
+                    return AsList($"{m_reward.Quantity} Sellable deck{suffix}");*/
+                case RewardItemType.BATTLEGROUNDS_HERO_SKIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_BATTLEGROUNDS_HERO_SKINS, m_reward.Quantity));
+                case RewardItemType.BATTLEGROUNDS_GUIDE_SKIN:
+                    return AsList(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_BATTLEGROUNDS_GUIDE_SKINS, m_reward.Quantity));
+                case RewardItemType.DECK:
+                    return GetLinesForDeckReward();
+                    case RewardItemType.GAME_MODE:
+                    return GetLinesForGameModeReward();
+                    case RewardItemType.LOANER_DECKS:
+                    return AsList(LocalizationUtils.Get(LocalizationKey.UI_REWARD_LOANER_DECKS));
+                // TODO: ROW Runestones
+                default:
+                    var ret = new List<string>();
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_UNKNOWN));
+                    return ret;
+            }
+        }
+
+        private List<string> GetLinesForHeroSkinReward()
+        {
+            var ret = new List<string>();
+
+            if (m_includeRewardType)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_HERO_SKINS, m_reward.Quantity));
+            }
+
+            string skinName;
+            string className = null;
+
+            if (m_reward.Card != null)
+            {
+                EntityDef entityDef = DefLoader.Get().GetEntityDef(m_reward.Card.CardId);
+                skinName = entityDef?.GetName();
+                className = GameStrings.GetClassName((TAG_CLASS)(entityDef?.GetTag(GAME_TAG.CLASS) ?? 0));
+            }
+            else
+            {
+                var record = GameDbf.RewardItem.GetRecord(m_reward.AssetId);
+                skinName = record.CardRecord.Name.GetString();
+                className = GameStrings.GetClassName(GameUtils.GetTagClassFromCardDbId(record.Card));
+            }
+
+            if ((skinName?.Length ?? 0) > 0)
+            {
+                ret.Add(skinName);
+            }
+
+            if ((className?.Length ?? 0) > 0)
+            {
+                ret.Add(className);
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForCardPackReward()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_PACKS, m_reward.Quantity));
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetCardPackName((int)m_reward.Booster.Type), ret);
+
+            return ret;
+        }
+
+        private List<string> GetLinesForCardReward()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_CARD, m_reward.Quantity));
+
+            var card = CollectionManager.Get().GetCard(m_reward.Card.CardId, m_reward.Card.Premium);
+            var accessibleCard = new AccessibleCollectibleCard(m_parent, card, false, true);
+
+            ret.AddRange(accessibleCard.GetLines());
+
+            return ret;
+        }
+
+        private List<string> GetLinesForDeckReward()
+        {
+            var ret = new List<string>();
+            if (m_includeRewardType)
+            {
+                ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_DECK));
+            }
+            var record = GameDbf.DeckTemplate.GetRecord(m_reward.DeckTemplateId);
+            var deckRecord = record.DeckRecord;
+            ret.Add(deckRecord.Name.GetString());
+            ret.Add(GameStrings.GetClassName((TAG_CLASS)record.ClassId));
+            ret.Add(deckRecord.Description.GetString());
+            return ret;
+        }
+
+        private List<string> GetLinesForGameModeReward()
+        {
+            var ret = new List<string>();
+            if (m_includeRewardType)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_GAME_MODE));
+            }
+
+            ret.Add(GameStrings.GetGameModeName((RewardItem.UnlockableGameMode)m_reward.GameModeId));
+            return ret;
+        }
+
+        private List<string> AsList(string str)
+        {
+            var ret = new List<string>();
+            ret.Add(str);
+            return ret;
+        }
+
+        public RewardItemDataModel GetDataModel()
+        {
+            return m_reward;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs b/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs
new file mode 100644
index 0000000..95f52a6
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleRewardPackage.cs
@@ -0,0 +1,35 @@
+﻿using System;
+using System.Collections.Generic;
+using static RewardBoxesDisplay;
+
+namespace Accessibility
+{
+    class AccessibleRewardPackage : AccessibleItem
+    {
+        internal RewardBoxData RewardBoxData { get; }
+
+        internal AccessibleRewardData RewardData { get; }
+
+        internal bool Open { get; set; }
+
+        internal AccessibleRewardPackage(AccessibleComponent parent, RewardBoxData rewardBoxData, RewardData rewardData) : base(parent)
+        {
+            RewardBoxData = rewardBoxData;
+            RewardData = new AccessibleRewardData(parent, rewardData);
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (!Open)
+            {
+                var ret = new List<string>();
+                ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_REWARD_PACKAGE));
+                return ret;
+            }
+            else
+            {
+                return RewardData.GetLines();
+            }
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleRuneUtils.cs b/Assembly-CSharp/Accessibility/AccessibleRuneUtils.cs
new file mode 100644
index 0000000..49e363d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleRuneUtils.cs
@@ -0,0 +1,25 @@
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleRuneUtils
+    {
+        public static string StringifyRunePattern(RunePattern rp)
+        {
+            List<string> runes = new List<string>();
+            if (rp.Blood > 0)
+            {
+                runes.Add(string.Format("{0} {1}", rp.Blood, LocalizationUtils.Get(LocalizationKey.READ_CARD_RUNE_BLOOD)));
+            }
+            if (rp.Frost > 0)
+            {
+                runes.Add(string.Format("{0} {1}", rp.Frost, LocalizationUtils.Get(LocalizationKey.READ_CARD_RUNE_FROST)));
+            }
+            if (rp.Unholy > 0)
+            {
+                runes.Add(string.Format("{0} {1}", rp.Unholy, LocalizationUtils.Get(LocalizationKey.READ_CARD_RUNE_UNHOLY)));
+            }
+            return AccessibleSpeechUtils.HumanizeList(runes);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/AccessibleScreen.cs b/Assembly-CSharp/Accessibility/AccessibleScreen.cs
new file mode 100644
index 0000000..d960e73
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleScreen.cs
@@ -0,0 +1,11 @@
+﻿namespace Accessibility
+{
+    internal interface AccessibleScreen : AccessibleComponent
+    {
+        void HandleInput();
+
+        string GetHelp();
+
+        void OnGainedFocus();
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/AccessibleScrollbarControl.cs b/Assembly-CSharp/Accessibility/AccessibleScrollbarControl.cs
new file mode 100644
index 0000000..08e84ac
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleScrollbarControl.cs
@@ -0,0 +1,57 @@
+﻿using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleScrollbarControl : AccessibleElement
+    {
+        private readonly ScrollbarControl m_scrollbar;
+
+        private Action m_onDone;
+
+        private string m_label;
+
+        internal AccessibleScrollbarControl(AccessibleComponent parent, string label, ScrollbarControl scrollbar, Action onDone) : base(parent)
+        {
+            m_scrollbar = scrollbar;
+            m_onDone = onDone;
+            m_label = label;
+        }
+
+        public void HandleInput()
+        {
+			if (AccessibleKey.GLOBAL_LEFT.IsPressed())
+            {
+				Inc(-1);
+            }
+			else if (AccessibleKey.GLOBAL_RIGHT.IsPressed())
+            {
+				Inc(1);
+            }
+			else if (AccessibleKey.GLOBAL_BACK.IsPressed() || AccessibleKey.GLOBAL_CONFIRM.IsPressed())
+            {
+                m_onDone();
+            }
+        }
+
+        private void Inc(int sign)
+        {
+            float val = sign >= 0 ? 0.1f : -0.1f;
+
+            float target = m_scrollbar.GetValue() + val;
+
+            m_scrollbar.SetValue(target);
+            m_scrollbar.FireUpdateEvent();
+            m_scrollbar.FireFinishEvent();
+
+            Output(AccessibleSpeech.OPTIONS_SCROLLBAR_STATE(m_scrollbar.GetValue()));
+        }
+
+        internal string GetText()
+        {
+            return $"{m_label} {AccessibleSpeech.OPTIONS_SCROLLBAR_STATE(m_scrollbar.GetValue())}";
+        }
+
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleSpeech.cs b/Assembly-CSharp/Accessibility/AccessibleSpeech.cs
new file mode 100644
index 0000000..39f76b9
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleSpeech.cs
@@ -0,0 +1,308 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Runtime.CompilerServices;
+using static Accessibility.HSASpeech;
+
+namespace Accessibility
+{
+    public class AccessibleSpeech
+    {
+        #region Global
+        public static string PRESS_ENTER_TO_START => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_START, AccessibleKey.CONFIRM);
+        public static string PRESS_ENTER_TO_CONTINUE => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM);
+        public static string PRESS_CONFIRM_ONCE_DONE => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_ONCE_DONE, AccessibleKey.CONFIRM);
+        public static string PRESS_BACK_ONCE_DONE => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_ONCE_DONE, AccessibleKey.BACK);
+        public static string PRESS_BACK_TO_GO_BACK => LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_GO_BACK, AccessibleKey.BACK);
+
+        public static HSASpeech PRESS_ENTER_TO_START_VOICE = CreateSpeech(L10N.Of(LocalizationKey.PRESS_KEY_TO_START, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to start");
+        #endregion
+
+        #region Menus
+        private static string MENU_HELP_NO_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HELP_NO_BACK_BUTTON, AccessibleKey.CONFIRM);
+        private static string MENU_HELP_WITH_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HELP_WITH_BACK_BUTTON, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        private static string MENU_HORIZONTAL_HELP_NO_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HORIZONTAL_HELP_NO_BACK_BUTTON, AccessibleKey.CONFIRM);
+        public static string MENU_ACHIEVEMENT_HELP => LocalizationUtils.Format(LocalizationKey.ACHIEVEMENT_LIST_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK, AccessibleKey.READ_NEXT_VALID_MENU_OPTION);
+        private static string MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON => LocalizationUtils.Format(LocalizationKey.MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        public static string MENU_HELP(bool hasBackButton) => hasBackButton ? MENU_HELP_WITH_BACK_BUTTON : MENU_HELP_NO_BACK_BUTTON;
+        public static string MENU_HORIZONTAL_HELP(bool hasBackButton) => hasBackButton ? MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON : MENU_HORIZONTAL_HELP_NO_BACK_BUTTON;
+        public static string MENU_OPTION(string optionName, int optionNumber, int optionsCount) => LocalizationUtils.Format(LocalizationKey.MENU_OPTION_FORMAT, optionName, optionNumber, optionsCount);
+        public static string MENU_NO_ITEMS_HELP => AccessibleSpeechUtils.CombineSentences(LocalizedText.MENU_NO_ITEMS, PRESS_BACK_TO_GO_BACK);
+        public static string OPTIONS_SCROLLBAR_STATE(float val) => $"{(int)Math.Round(val*100)}";
+        #endregion
+
+        #region Tutorial Progress Screen
+        public static HSASpeech TUTORIAL_WELCOME_BACK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_WELCOME_BACK), "Welcome back to the tutorial");
+        #endregion
+
+        #region Gameplay Help Speeches
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_HERO_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_HERO_HELP, AccessibleKey.SEE_PLAYER_HERO), $"Press {AccessibleKey.SEE_PLAYER_HERO.ToEnglishString()} to look at your hero");
+        public static HSASpeech GAMEPLAY_SEE_OPPONENT_HERO_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_OPPONENT_HERO_HELP, AccessibleKey.SEE_OPPONENT_HERO), $"Press {AccessibleKey.SEE_OPPONENT_HERO.ToEnglishString()} to look at your opponent's hero");
+        public static HSASpeech GAMEPLAY_READ_CARDS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_CARDS_HELP), "Use the up and down arrow keys to read cards");
+        public static HSASpeech GAMEPLAY_CONFIRM_TO_ATTACK_TARGET = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CONFIRM_TO_ATTACK_TARGET, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack this target");
+
+        public static HSASpeech GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to summon this minion");
+
+        // General gameplay ones
+        public static HSASpeech GAMEPLAY_OPPONENT_TURN_VOICE = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_OPPONENT_TURN), $"Your opponent is playing");
+        public static HSASpeech GAMEPLAY_CONFIRM_END_TURN_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CONFIRM_END_TURN_HELP, AccessibleKey.CONFIRM, AccessibleKey.END_TURN), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} or {AccessibleKey.END_TURN.ToEnglishString()} to end your turn. Press any other key to cancel");
+        public static HSASpeech GAMEPLAY_SEE_VALID_OPTIONS = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_VALID_OPTIONS, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your valid options");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_HAND_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_HAND_HELP, AccessibleKey.SEE_PLAYER_HAND), $"Press {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} to look at your hand");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_HAND_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_OPPONENT_HAND_HELP, AccessibleKey.SEE_OPPONENT_HAND), $"Press {AccessibleKey.SEE_OPPONENT_HAND.ToEnglishString()} to count the cards in your opponent's hand");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_MINIONS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_MINIONS_HELP, AccessibleKey.SEE_PLAYER_MINIONS), $"Press {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to look at your summoned minions");
+        public static HSASpeech GAMEPLAY_SEE_OPPONENT_MINIONS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_OPPONENT_MINIONS_HELP, AccessibleKey.SEE_OPPONENT_MINIONS), $"Press {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} to look at your opponent's minions");
+        public static HSASpeech GAMEPLAY_SEE_PLAYER_SECRETS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SEE_PLAYER_SECRETS_HELP, AccessibleKey.SEE_PLAYER_SECRETS), $"Press {AccessibleKey.SEE_PLAYER_SECRETS.ToEnglishString()} to look at your secrets");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP, AccessibleKey.SEE_OPPONENT_SECRETS), $"Press {AccessibleKey.SEE_OPPONENT_SECRETS.ToEnglishString()} to count your opponent's secrets");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_WEAPON_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_PLAYER_WEAPON_HELP, AccessibleKey.SEE_PLAYER_WEAPON), $"Press {AccessibleKey.SEE_PLAYER_WEAPON.ToEnglishString()} to read your weapon");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_WEAPON_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_OPPONENT_WEAPON_HELP, AccessibleKey.SEE_OPPONENT_WEAPON), $"Press {AccessibleKey.SEE_OPPONENT_WEAPON.ToEnglishString()} to read your opponent's weapon");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_PLAYER_HERO_POWER_HELP, AccessibleKey.SEE_PLAYER_HERO_POWER), $"Press {AccessibleKey.SEE_PLAYER_HERO_POWER.ToEnglishString()} to read your hero power");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP, AccessibleKey.SEE_OPPONENT_HERO_POWER), $"Press {AccessibleKey.SEE_OPPONENT_HERO_POWER.ToEnglishString()} to read your opponent's hero power");
+        public static HSASpeech GAMEPLAY_COUNT_PLAYER_DECK_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_PLAYER_DECK_HELP, AccessibleKey.SEE_PLAYER_DECK), $"Press {AccessibleKey.SEE_PLAYER_DECK.ToEnglishString()} to count the remaining cards in your deck");
+        public static HSASpeech GAMEPLAY_COUNT_OPPONENT_DECK_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_COUNT_OPPONENT_DECK_HELP, AccessibleKey.SEE_OPPONENT_DECK), $"Press {AccessibleKey.SEE_OPPONENT_DECK.ToEnglishString()} to count the remaining cards in your opponent's deck");
+        public static HSASpeech GAMEPLAY_READ_PLAYER_MANA_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_PLAYER_MANA_HELP, AccessibleKey.SEE_PLAYER_MANA), $"Press {AccessibleKey.SEE_PLAYER_MANA.ToEnglishString()} to read your mana");
+        public static HSASpeech GAMEPLAY_READ_OPPONENT_MANA_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_OPPONENT_MANA_HELP, AccessibleKey.SEE_OPPONENT_MANA), $"Press {AccessibleKey.SEE_OPPONENT_MANA.ToEnglishString()} to read your opponent's mana");
+        public static HSASpeech GAMEPLAY_READ_CARD_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_CARD_HELP), "Use the up and down arrow keys to read this card");
+        public static HSASpeech GAMEPLAY_READ_CARD_TOOLTIP_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_CARD_TOOLTIP_HELP, AccessibleKey.READ_TOOLTIP), $"Press {AccessibleKey.READ_TOOLTIP.ToEnglishString()} to get a description of this card's abilities");
+        public static HSASpeech GAMEPLAY_PLAY_CARD_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_PLAY_CARD_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to play this card");
+        public static HSASpeech GAMEPLAY_TRADE_CARD_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_TRADE_CARD_HELP, AccessibleKey.TRADE_CARD), $"Press {AccessibleKey.TRADE_CARD.ToEnglishString()} to trade this card");
+        public static HSASpeech GAMEPLAY_SUMMON_MINION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SUMMON_MINION_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to summon this minion");
+        public static HSASpeech GAMEPLAY_CHOICE_MODE_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CHOICE_MODE_HELP, AccessibleKey.CONFIRM, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use the arrow keys to go through your options. Press {AccessibleKey.CONFIRM.ToEnglishString()} to choose one");
+        public static HSASpeech GAMEPLAY_CHOOSE_TARGET_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CHOOSE_TARGET_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.CONFIRM, AccessibleKey.BACK), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} or the Zone keys to go through your targets. Press {AccessibleKey.CONFIRM.ToEnglishString()} to choose a target or {AccessibleKey.BACK.ToEnglishString()} to cancel");
+        public static HSASpeech GAMEPLAY_ATTACK_WITH_MINION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_ATTACK_WITH_MINION_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack with this minion");
+        public static HSASpeech GAMEPLAY_ATTACK_WITH_HERO_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_ATTACK_WITH_HERO_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack with your hero");
+        public static HSASpeech GAMEPLAY_USE_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_USE_HERO_POWER_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to use your hero power");
+        public static HSASpeech GAMEPLAY_READ_THROUGH_VALID_TARGETS = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_THROUGH_VALID_TARGETS, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to read through your valid targets");
+        public static HSASpeech GAMEPLAY_ATTACK_THIS_MINION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_ATTACK_THIS_MINION_HELP, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack this minion");
+        public static HSASpeech GAMEPLAY_CANCEL_ATTACK_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CANCEL_ATTACK_HELP, AccessibleKey.BACK), $"Press {AccessibleKey.BACK.ToEnglishString()} to cancel the attack");
+        public static HSASpeech GAMEPLAY_CANCEL_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_CANCEL_HELP, AccessibleKey.BACK), $"Press {AccessibleKey.BACK.ToEnglishString()} to cancel");
+        public static HSASpeech GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP), $"Use the left and right arrow keys to choose a position for this minion");
+        public static HSASpeech GAMEPLAY_OPEN_HISTORY_LOG_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_OPEN_HISTORY_LOG_HELP, AccessibleKey.SEE_HISTORY), $"Press {AccessibleKey.SEE_HISTORY.ToEnglishString()} to open the play history log");
+        public static HSASpeech GAMEPLAY_READ_HISTORY_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_READ_HISTORY_HELP, AccessibleKey.BACK), $"Use the up and down arrow keys to read the play history. Press {AccessibleKey.BACK.ToEnglishString()} to close the history log");
+        public static HSASpeech GAMEPLAY_END_TURN_HELP = CreateSpeech(L10N.Of(LocalizationKey.GAMEPLAY_END_TURN_HELP, AccessibleKey.END_TURN), $"Press {AccessibleKey.END_TURN.ToEnglishString()} to end your turn");
+        #endregion
+
+        #region Tutorials
+        public static HSASpeech WELCOME_TO_HEARTHSTONE = CreateSpeech(L10N.Of(LocalizationKey.WELCOME_TO_HEARTHSTONE), "Welcome to Hearthstone");
+        public static HSASpeech TUTORIAL_NARRATOR_INTRO = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NARRATOR_INTRO), $"I'll be teaching you how to play through a set of six tutorial games");
+        public static HSASpeech TUTORIAL_NARRATOR_HELP_KEYS = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NARRATOR_HELP_KEYS, AccessibleKey.HELP), $"If you ever feel lost, press {AccessibleKey.HELP.ToEnglishString()}. Even after the tutorial or when navigating menus, you can always use {AccessibleKey.HELP.ToEnglishString()} whenever you need help");
+        public static HSASpeech TUTORIAL_NARRATOR_INTRO_END = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NARRATOR_INTRO_END), "Alright, let's get on with it");
+        public static HSASpeech TUTORIAL_FREE_STARTING_PACK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_FREE_STARTING_PACK, AccessibleKey.CONFIRM), $"Here's a basic Mage pack of cards to get you started. Press {AccessibleKey.CONFIRM.ToEnglishString()} to open it");
+
+        public static HSASpeech TUTORIAL_NICE_WORK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NICE_WORK), "Nice work");
+        public static HSASpeech TUTORIAL_NICE_JOB = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NICE_JOB), "Nice job");
+        public static HSASpeech TUTORIAL_NICE_ONE = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NICE_ONE), "Nice one");
+        public static HSASpeech TUTORIAL_GOOD_JOB = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_GOOD_JOB), "Good job");
+        public static HSASpeech TUTORIAL_YOU_GOT_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_YOU_GOT_IT), "You got it!");
+        public static HSASpeech TUTORIAL_REMEMBER_HOW_TO_DO_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_REMEMBER_HOW_TO_DO_IT), "Remember how to do it?");
+        public static HSASpeech TUTORIAL_REMEMBER_HOW_TO_DO_THAT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_REMEMBER_HOW_TO_DO_THAT), "Remember how to do that?");
+        public static HSASpeech TUTORIAL_TRY_IT_OUT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_TRY_IT_OUT), "Try it out!");
+        public static HSASpeech TUTORIAL_ALL_RIGHT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ALL_RIGHT), "All right!");
+        public static HSASpeech TUTORIAL_LETS_LEARN_HOW = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_LETS_LEARN_HOW), "Let's learn how");
+        public static HSASpeech TUTORIAL_CAN_YOU_DO_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_CAN_YOU_DO_IT), "Can you do it?");
+        public static HSASpeech TUTORIAL_THINK_YOU_CAN_DO_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_THINK_YOU_CAN_DO_IT), "Think you can do it?");
+        public static HSASpeech TUTORIAL_GOT_IT = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_GOT_IT), "Got it");
+
+        // General tutorial notifications
+        public static HSASpeech TUTORIAL_NO_ENDTURN_ATK = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NO_ENDTURN_ATK), "Not yet! You can still attack");
+        public static HSASpeech TUTORIAL_NO_ENDTURN = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NO_ENDTURN), "Not yet! You have more cards to play!");
+        public static HSASpeech TUTORIAL_NO_ENDTURN_HP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_NO_ENDTURN_HP, AccessibleKey.SEE_PLAYER_HERO_POWER), $"Not yet! Use your Hero Power. Press {AccessibleKey.SEE_PLAYER_HERO_POWER.ToEnglishString()} to select it");
+
+        #region Hogger
+        public static HSASpeech TUTORIAL_HOGGER_START = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_START), $"Your first opponent is a gnoll named Hogger. You will be playing as the powerful mage Jaina Proudmoore");
+
+        // Notifications
+        public static HSASpeech TUTORIAL01_HELP_07 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL01_HELP_07), "Save that for the enemy!");
+        public static HSASpeech TUTORIAL01_HELP_08 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL01_HELP_08), "Ignore the puny gnoll and finish off Hogger");
+        public static HSASpeech TUTORIAL_HOGGER_FORCE_CARD_READ = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_FORCE_CARD_READ), $"Use the up and down arrow keys to read this card first");
+        public static HSASpeech TUTORIAL_HOGGER_SUMMON_MINION_FIRST = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_SUMMON_MINION_FIRST), $"Summon the minion you just got first");
+        public static HSASpeech TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST, AccessibleKey.SEE_OPPONENT_MINIONS), $"Use {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} and the arrow keys to read your opponent's minions first");
+
+        // Turn 2
+        public static HSASpeech TUTORIAL_HOGGER_2_0 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_0), $"When a turn starts, you always begin by drawing a card from your deck. Let's see the one we just drew");
+        public static HSASpeech TUTORIAL_HOGGER_2_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_1, AccessibleKey.SEE_PLAYER_HAND), $"Press  {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} to look at the cards in your hand");
+        // Use the arrow keys to read this card
+        public static HSASpeech TUTORIAL_HOGGER_2_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_2), $"Ok, so... This card is a minion named Murloc Raider");
+        public static HSASpeech TUTORIAL_HOGGER_2_2B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_2B), $"Minions are creatures that you can summon onto the battlefield to fight for your Hero");
+        public static HSASpeech TUTORIAL_HOGGER_2_2D = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_2D), $"This one costs 1 mana to summon and has 2 attack and 1 health");
+        public static HSASpeech TUTORIAL_HOGGER_2_3 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_3), $"Let's start by summoning this minion");
+        public static HSASpeech TUTORIAL_HOGGER_2_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_4, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to do so");
+        public static HSASpeech TUTORIAL_HOGGER_2_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_5, AccessibleKey.CONFIRM, AccessibleKey.BACK), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to confirm or {AccessibleKey.BACK.ToEnglishString()} to cancel");
+        public static HSASpeech TUTORIAL_HOGGER_2_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_2_6), $"Minions must wait a turn to attack once they're summoned, so we have nothing left to do");
+        // Press E to end your turn
+
+        // Turn 3
+        public static HSASpeech TUTORIAL_HOGGER_3_0 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_0), "Your opponent's minion attacked your Hero so you took some damage");
+        public static HSASpeech TUTORIAL_HOGGER_3_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_1), "Let's see how much health we have left");
+        // Press V to look at your Hero
+        public static HSASpeech TUTORIAL_HOGGER_3_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_2), $"Use the up and down arrow keys to read your hero card");
+        public static HSASpeech TUTORIAL_HOGGER_3_2_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_2_HELP, AccessibleKey.SEE_PLAYER_HERO), $"Use {AccessibleKey.SEE_PLAYER_HERO.ToEnglishString()} and the arrow keys to find out how much health your Hero has");
+        public static HSASpeech TUTORIAL_HOGGER_3_3 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_3), $"If your Hero runs out of health, you lose. 28 health is still plenty though");
+        public static HSASpeech TUTORIAL_HOGGER_3_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_4, AccessibleKey.SEE_OPPONENT_HERO), $"Let's look at your opponent's hero now. Press {AccessibleKey.SEE_OPPONENT_HERO.ToEnglishString()}");
+        public static HSASpeech TUTORIAL_HOGGER_3_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_5), $"Can you find how much health he has?");
+        public static HSASpeech TUTORIAL_HOGGER_3_5_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_5_HELP), $"Use the up and down arrow keys to read your opponent's hero card");
+        // Ues the arrow keys to read cards
+        // Nice job
+        public static HSASpeech TUTORIAL_HOGGER_3_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_6), $"Once your opponent's Hero runs out of health, you win");
+        public static HSASpeech TUTORIAL_HOGGER_3_7 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_3_7), $"Let's carry on");
+
+        // Turn 4
+        public static HSASpeech TUTORIAL_HOGGER_4_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_1), $"Looks like you got another minion. Can you summon this one yourself?");
+        public static HSASpeech TUTORIAL_HOGGER_4_1_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_1_HELP, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.CONFIRM), $"Use {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to summon your minion");
+        public static HSASpeech TUTORIAL_HOGGER_4_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_2), $"When you already have minions on the battlefield, you can use the left and right arrow keys to select where the new minion will be placed");
+        // Try it out
+        public static HSASpeech TUTORIAL_HOGGER_4_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_4), $"You now have two minions on the battlefield. This one was just summoned so it must wait a turn to attack");
+        public static HSASpeech TUTORIAL_HOGGER_4_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_5), "Let's learn how to navigate the battlefield");
+        // Press B to look at your summoned minions
+        public static HSASpeech TUTORIAL_HOGGER_4_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_6), $"Use the left and right arrow keys to navigate your minions");
+        public static HSASpeech TUTORIAL_HOGGER_4_6_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_6_HELP, AccessibleKey.SEE_PLAYER_MINIONS), $"Use {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} and the arrow keys to navigate your summoned minions");
+        public static HSASpeech TUTORIAL_HOGGER_4_8 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_8, AccessibleKey.SEE_OPPONENT_MINIONS), $"Let's look at your opponent's minions now. Press {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} to do so");
+        public static HSASpeech TUTORIAL_HOGGER_4_9 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_9), $"Can you read this minion by yourself?");
+        public static HSASpeech TUTORIAL_HOGGER_4_9_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_9_HELP), $"Use the up and down arrow keys to read your opponent's minions");
+        // You got it
+        public static HSASpeech TUTORIAL_HOGGER_4_10 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_10), $"Let's try to attack this minion now");
+        public static HSASpeech TUTORIAL_HOGGER_4_11 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_11), $"Select the Murloc Raider you summoned last turn");
+        public static HSASpeech TUTORIAL_HOGGER_4_11_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_11_HELP, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM), $"Use {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to get to your minion and {AccessibleKey.CONFIRM.ToEnglishString()} to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_4_12 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_12, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} to attack with this minion");
+        public static HSASpeech TUTORIAL_HOGGER_4_13 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_13), $"Can you attack your opponent's minion?");
+        public static HSASpeech TUTORIAL_HOGGER_4_13_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_13_HELP, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM), $"Use {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to attack your opponent's minion");
+        // Press G to look at your opponent's minions and enter to attack
+        // Nice one
+        public static HSASpeech TUTORIAL_HOGGER_4_16 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_16), $"Both minions had 2 attack and 1 health so they killed each other");
+        public static HSASpeech TUTORIAL_HOGGER_4_17 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_4_17), $"Your other minion is still exhausted so there's nothing left to do. Remember how to end your turn?");
+
+        // Turn 6
+        public static HSASpeech TUTORIAL_HOGGER_6_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_1), $"Looks like you got another minion");
+        public static HSASpeech TUTORIAL_HOGGER_6_2 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_2), $"This means you have two possible options right now");
+        public static HSASpeech TUTORIAL_HOGGER_6_3 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_3), $"You can either summon the minion you just got, or use the one you summoned last turn to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_4 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_4, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.SEE_PLAYER_MINIONS), $"One way to do this would be using keys such as {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} to look at your hand or {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to look at your summoned minions");
+        public static HSASpeech TUTORIAL_HOGGER_6_5 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_5), $"However, there's an easier way to do it");
+        // Let's learn how
+        public static HSASpeech TUTORIAL_HOGGER_6_6 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_6, AccessibleKey.READ_NEXT_VALID_ITEM), $"Press {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()}");
+        public static HSASpeech TUTORIAL_HOGGER_6_7 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_7), $"You're now looking at your first option, which would be to summon the minion you just got");
+        public static HSASpeech TUTORIAL_HOGGER_6_8 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_8, AccessibleKey.READ_NEXT_VALID_ITEM), $"Try pressing {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} again");
+        public static HSASpeech TUTORIAL_HOGGER_6_9 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_9), $"You're now looking at your second option, which would be to attack with the minion you summoned last turn");
+        public static HSASpeech TUTORIAL_HOGGER_6_10 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_10, AccessibleKey.READ_NEXT_VALID_ITEM), $"You can always use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your valid options, so make sure to remember this key!");
+        public static HSASpeech TUTORIAL_HOGGER_6_12 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_12), $"Alright. Let's begin by summoning the minion we just got");
+        // Can you do it?
+        public static HSASpeech TUTORIAL_HOGGER_6_12_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_12_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.CONFIRM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} or {AccessibleKey.SEE_PLAYER_HAND.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to summon your minion");
+        // Nice job
+        public static HSASpeech TUTORIAL_HOGGER_6_13 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_13), $"Let's try to attack with our other minion now");
+        // Think you can do it?
+        public static HSASpeech TUTORIAL_HOGGER_6_13_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_13_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} or {AccessibleKey.SEE_PLAYER_MINIONS.ToEnglishString()} to find your minion and {AccessibleKey.CONFIRM.ToEnglishString()} to launch an attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_14 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_14), $"You now have another choice to make. You can either attack one of your opponent's minions, or your opponent's hero himself");
+        public static HSASpeech TUTORIAL_HOGGER_6_15 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_15, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.SEE_OPPONENT_HERO), $"You can either use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your valid targets or select your target directly using {AccessibleKey.SEE_OPPONENT_MINIONS.ToEnglishString()} or {AccessibleKey.SEE_OPPONENT_HERO.ToEnglishString()}");
+        public static HSASpeech TUTORIAL_HOGGER_6_16 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_16), $"Go ahead and choose a target to attack");
+        public static HSASpeech TUTORIAL_HOGGER_6_16_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_16_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.CONFIRM), $"Use {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} and {AccessibleKey.CONFIRM.ToEnglishString()} to launch an attack");
+        // Nice work
+        public static HSASpeech TUTORIAL_HOGGER_6_21 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_6_21), $"We're ready to end our turn!");
+
+        // Turn 8
+        public static HSASpeech TUTORIAL_HOGGER_8_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HOGGER_8_1), $"I'll let you continue playing by yourself. Just let me know if you need anything");
+
+        #endregion
+
+        #region Millhouse
+        public static HSASpeech TUTORIAL_02_HELP_01 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_01), "You gain a Mana Crystal every turn");
+        public static HSASpeech TUTORIAL02_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_03), "Your used Mana Crystals refill each turn");
+        public static HSASpeech TUTORIAL02_HELP_06 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_06), "Get Millhouse!");
+        public static HSASpeech TUTORIAL02_HELP_07 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL02_HELP_07), "Expend your Mana each turn to crush this annoying gnome!");
+
+        public static HSASpeech TUTORIAL_RAID_LEADER_DESCRIPTION = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_RAID_LEADER_DESCRIPTION), "This minion has a power that lasts until he dies");
+        public static HSASpeech TUTORIAL_ARCANE_INTELLECT_DESCRIPTION = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ARCANE_INTELLECT_DESCRIPTION), "You can have 10 cards in your hand");
+
+        // Turn 1
+        public static HSASpeech TUTORIAL_MILLHOUSE_SEE_MANA_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MILLHOUSE_SEE_MANA_HELP, AccessibleKey.SEE_PLAYER_MANA), $"Press {AccessibleKey.SEE_PLAYER_MANA.ToEnglishString()} at any time to see how much mana you have");
+        #endregion
+
+        #region Lorewalker Cho
+        public static HSASpeech TUTORIAL06_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL06_HELP_03), "Minions with Battlecry do something special when you summon them");
+        public static HSASpeech TUTORIAL_CHO_1 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_CHO_1), "This Voodoo Doctor healed your opponent's Hero");
+        public static HSASpeech TUTORIAL06_HELP_02 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL06_HELP_02), "When minions fight each other, they both take damage");
+        public static HSASpeech TUTORIAL06_HELP_04 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL06_HELP_04), "Kill enemy minions before they become a problem!");
+        #endregion
+
+        #region King Mukla
+        public static HSASpeech TUTORIAL_MUKLA_START = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_START), "In this game, you'll see some cards with abilities you haven't seen before");
+        public static HSASpeech TUTORIAL_MUKLA_START_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_START_B, AccessibleKey.READ_TOOLTIP), $"If you run into something you don't understand when reading a card such as Charge or Taunt, press {AccessibleKey.READ_TOOLTIP.ToEnglishString()} to get more information");
+        public static HSASpeech TUTORIAL_MUKLA_START_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_START_C, AccessibleKey.CONFIRM), $"Press {AccessibleKey.CONFIRM.ToEnglishString()} whenever you're ready to start");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP), $"This gorilla your opponent just summoned has an ability named Taunt");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP_B), $"Minions with Taunt must always be killed before you can attack anyone else");
+        public static HSASpeech TUTORIAL_MUKLA_TAUNT_HELP_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP_C), $"Taunt is an important ability as it can be used to protect your Hero");
+        #endregion
+
+        #region Nesingwary
+        public static HSASpeech TUTORIAL04_HELP_14 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_14), $"Welcome to the Jungle");
+        public static HSASpeech TUTORIAL04_HELP_15 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_15), $"Kill his minions or he'll overwhelm you!");
+        public static HSASpeech TUTORIAL04_HELP_16 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_16), $"Subdue minions with your hero power and spells!");
+        public static HSASpeech TUTORIAL04_HELP_02 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_02), $"Sheep it!");
+        public static HSASpeech TUTORIAL04_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL04_HELP_03), $"Save that for the Fen Creeper!");
+
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP), $"From now on, your Hero and your opponent's Hero will normally have a Hero Power");
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP_B), $"Every Hero has its own Hero Power and you can use it once per turn");
+        public static HSASpeech TUTORIAL_HEMET_HERO_POWER_HELP_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP_C, AccessibleKey.SEE_PLAYER_HERO_POWER, AccessibleKey.SEE_OPPONENT_HERO_POWER), $"You can always press {AccessibleKey.SEE_PLAYER_HERO_POWER.ToEnglishString()} to see your Hero Power and {AccessibleKey.SEE_OPPONENT_HERO_POWER.ToEnglishString()} to see your opponent's Hero Power");
+        // Try it out!
+        #endregion
+
+        #region Illidan
+        public static HSASpeech TUTORIAL05_HELP_03 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL05_HELP_03), $"This fight is totally not fair. Blame the terrible game designers");
+        public static HSASpeech TUTORIAL05_HELP_04 = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL05_HELP_04), $"Your Taunt minions can protect you from attacks!");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP), $"It looks like your opponent equipped a weapon");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B), $"Weapons are special cards which can be equipped by heroes");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C), $"Each weapon has some attack and some durability");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D), $"Once equipped, heroes can attack other characters during their turn");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E), $"Your opponent equipped Warglaive of Azzinoth: a weapon with 2 attack and 2 durability");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F), $"This means your opponent's Hero will have 2 attack during his turn, and will be able to attack any of your characters");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G), $"Mages don't often use weapons, but you'll be able to play with some later on once you've unlocked other classes");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H, AccessibleKey.SEE_PLAYER_WEAPON, AccessibleKey.SEE_OPPONENT_WEAPON), $"You can press {AccessibleKey.SEE_PLAYER_WEAPON.ToEnglishString()} at any time to see your weapon or {AccessibleKey.SEE_OPPONENT_WEAPON.ToEnglishString()} to see your opponent's one");
+
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP), $"Hear that sound? Weapons lose durability every time their Hero attacks");
+        public static HSASpeech TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B = CreateSpeech(L10N.Of(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B), $"Once they reach 0 durability, they break and the Hero can no longer attack");
+        #endregion
+
+        #endregion
+
+        #region In-game "Tutorials"
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME), $"Every normal game starts with the mulligan phase");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B), $"In this phase, both players can replace cards in their starting hand with random ones from their deck");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C, AccessibleKey.READ_NEXT_VALID_ITEM), $"Use the arrow keys or {AccessibleKey.READ_NEXT_VALID_ITEM.ToEnglishString()} to go through your starting hand");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D, AccessibleKey.MULLIGAN_MARK_CARD), $"If you see a card you don't like, press {AccessibleKey.MULLIGAN_MARK_CARD.ToEnglishString()} to mark it for replacement");
+        public static HSASpeech IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E = CreateSpeech(L10N.Of(LocalizationKey.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E, AccessibleKey.CONFIRM), $"Once you've marked all cards you'd like to replace, press {AccessibleKey.CONFIRM.ToEnglishString()} to draw new ones and start the game");
+        #endregion
+
+        private static List<HSASpeech> s_speeches;
+        private static Dictionary<string, HSASpeech> s_speechDict;
+
+        private static HSASpeech CreateSpeech(L10N l10n, string value, [CallerMemberName] string key=null)
+        {
+            if (key == null)
+            {
+                throw new ArgumentException($"Invoked CreateSpeech in an invalid context");
+            }
+
+            var newSpeech = new HSASpeech(key, value, l10n);
+            if (s_speeches == null)
+            {
+                s_speeches = new List<HSASpeech>();
+            }
+
+            if (s_speechDict == null)
+            {
+                s_speechDict = new Dictionary<string, HSASpeech>();
+            }
+
+            if (s_speechDict.ContainsKey(key))
+            {
+                throw new ArgumentException($"Fatal error initializing accessible speeches. Found duplicate speech: {key}");
+            }
+
+            s_speeches.Add(newSpeech);
+            s_speechDict.Add(key, newSpeech);
+
+            return newSpeech;
+        }
+
+        public static List<HSASpeech> GetAllSpeeches()
+        {
+            return s_speeches;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs b/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs
new file mode 100644
index 0000000..82cc575
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleSpeechMgr.cs
@@ -0,0 +1,453 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+using UnityEngine.Networking;
+
+namespace Accessibility
+{
+    class AccessibleSpeechMgr : MonoBehaviour
+    {
+        private static int MAX_GAME_SPEED_WPM = 10000;
+
+        class QueuedHSASpeech
+        {
+            internal HSASpeech Speech;
+            internal bool Interruptable;
+            internal Action OnFinishListener;
+
+            internal void OnFinish()
+            {
+                if (OnFinishListener != null)
+                {
+                    OnFinishListener();
+                }
+            }
+        }
+
+        private Queue<QueuedHSASpeech> m_queuedNarrations = new Queue<QueuedHSASpeech>();
+        private QueuedHSASpeech m_curNarration;
+
+        private Queue<QueuedText> m_queuedTexts = new Queue<QueuedText>();
+        private QueuedText m_curText;
+        private List<QueuedText> m_prevTexts = new List<QueuedText>();
+
+        private List<int> m_WPMSpeeds = new List<int>() { 100, 125, 150, 175, 200, 225, 250, 275, 300, MAX_GAME_SPEED_WPM };
+        private int m_curGameSpeed = 3; // Index based i.e. 150WPM
+        private int m_curCPS = CalcCPS(150);
+        private bool m_gameSpeedOptionLoaded;
+
+        private static int MAX_GAME_SPEED_CPS = CalcCPS(MAX_GAME_SPEED_WPM);
+
+        private void Update()
+        {
+            if (Input.anyKeyDown && m_curText != null)
+            {
+                InterruptTexts();
+            }
+
+            if (m_curText == null && m_curNarration == null)
+            {
+                if (m_queuedTexts.Count > 0)
+                {
+                    var nextText = m_queuedTexts.Dequeue();
+                    AccessibleSpeechOptimizer.OptimizeText(nextText, m_prevTexts);
+                    StartCoroutine(OutputText(nextText));
+                }
+                else if (m_queuedNarrations.Count > 0)
+                {
+                    StartCoroutine(Play(m_queuedNarrations.Dequeue()));
+                }
+            }
+        }
+
+        internal void InterruptTexts()
+        {
+            m_curText?.Interrupt();
+
+            while (m_queuedTexts.Count > 0)
+            {
+                var queuedText = m_queuedTexts.Dequeue();
+
+                if (queuedText != null && queuedText.IsNarration())
+                {
+                    return;
+                }
+                queuedText?.Interrupt();
+            }
+        }
+
+        internal void Narrate(bool interruptable, Action onFinish, params HSASpeech[] speeches)
+        {
+            if (IsSpeechAudioAvailable())
+            {
+                foreach (var speech in speeches)
+                {
+                    m_queuedNarrations.Enqueue(new QueuedHSASpeech()
+                    {
+                        Speech = speech,
+                        Interruptable = interruptable,
+                        OnFinishListener = onFinish,
+                    });
+                }
+            }
+            else
+            {
+                foreach (var speech in speeches)
+                {
+                    OutputNarrationAsText(speech.GetLocalizedText());
+                }
+            }
+        }
+
+        internal void InterruptNarrations()
+        {
+            var source = GetAudioSource();
+
+            if (m_curNarration != null)
+            {
+                if (m_curNarration.Interruptable)
+                {
+                    source?.Stop();
+                }
+                else
+                {
+                    return;
+                }
+            }
+
+            while (m_queuedNarrations.Count > 0 && m_queuedNarrations.Peek().Interruptable)
+            {
+                var s = m_queuedNarrations.Dequeue();
+                s?.OnFinish();
+            }
+        }
+
+        internal void InterruptTextSpeeches()
+        {
+            InterruptTexts();
+        }
+
+        private AudioSource GetAudioSource()
+        {
+            return GetComponent<AudioSource>();
+        }
+
+        internal IEnumerator Narrate(HSASpeech speech)
+        {
+            if (!IsSpeechAudioAvailable())
+            {
+                OutputNarrationAsText(speech.GetLocalizedText());
+                yield break;
+            }
+
+            InterruptNarrations();
+
+            var newSpeech = new QueuedHSASpeech
+            {
+                Interruptable = false,
+                Speech = speech
+            };
+
+            m_queuedNarrations.Enqueue(newSpeech);
+
+            while (m_curNarration != newSpeech)
+            {
+                yield return null;
+            }
+
+            while (m_curNarration == newSpeech)
+            {
+                yield return null;
+            }
+        }
+
+        private IEnumerator Play(QueuedHSASpeech speech)
+        {
+            if (speech == null)
+            {
+                yield break;
+            }
+
+            m_curNarration = speech;
+
+            var hsDir = Directory.GetCurrentDirectory();
+            AccessibilityUtils.LogDebug($"CurrentWorkDir: {hsDir}");
+            var speechFileName = speech.Speech.GetFileName();
+            AccessibilityUtils.LogDebug($"Play: {speechFileName}");
+            var speechPath = Path.Combine(hsDir, "Accessibility", "Speeches", speechFileName);
+
+            var uri = new Uri(speechPath);
+            string url = uri.AbsoluteUri;
+
+            var www = UnityWebRequestMultimedia.GetAudioClip(url, AudioType.OGGVORBIS);
+            yield return www.SendWebRequest();
+
+            var source = GetAudioSource();
+            source.clip = DownloadHandlerAudioClip.GetContent(www);
+            if(source!=null) {source.Play();
+
+            while (source.isPlaying)
+            {
+                yield return null;
+            }
+            }
+            speech.OnFinish();
+            m_curNarration = null;
+        }
+
+		internal void CalibrateScreenReaderSpeed(KeyCode key)
+        {
+            StartCoroutine(Calibrate(key));
+        }
+
+        private IEnumerator Calibrate(KeyCode key)
+        {
+            var text1 = "Your turn.";
+            var text2 = "You draw Firelands.";
+            var text3 = "You draw Shadow Word: Death.";
+            var text4 = "Your River Crocolisk attacks your opponent's Gurubashi Berserker.";
+
+            yield return RunCalibrationTest(text1, key);
+            yield return RunCalibrationTest(text2, key);
+            yield return RunCalibrationTest(text3, key);
+            yield return RunCalibrationTest(text4, key);
+        }
+
+        private IEnumerator RunCalibrationTest(string text, KeyCode key)
+        {
+            ScreenReader.Output("Ready?");
+
+            while (!InputCollection.GetKeyDown(key))
+            {
+                yield return null;
+            }
+
+            var stopwatch = new Stopwatch();
+            stopwatch.Start();
+            ScreenReader.Output(text);
+
+            while (!InputCollection.GetKeyUp(key))
+            {
+                yield return null;
+            }
+
+            while (!InputCollection.GetKeyDown(key))
+            {
+                yield return null;
+            }
+
+            stopwatch.Stop();
+
+            LogCalibrationTime(text, stopwatch.ElapsedMilliseconds);
+
+            while (!InputCollection.GetKeyUp(key))
+            {
+                yield return null;
+            }
+        }
+
+        private void LogCalibrationTime(string text, float elapsedMillis)
+        {
+            var cps = (1000 * text.Length) / elapsedMillis;
+            var numWords = NumWords(text);
+            var wpm = (1000*60 * numWords) / elapsedMillis;
+
+            AccessibilityUtils.LogDebug($"CPS: {cps} / WPM: {wpm} ({numWords} words in {elapsedMillis}ms) text: {text}");
+        }
+
+        private int NumWords(string text)
+        {
+            var ret = 1;
+
+            foreach (var c in text)
+            {
+                if (c == ' ')
+                {
+                    ret++;
+                }
+            }
+
+            return ret;
+        }
+
+        #region TTS
+
+        private IEnumerator OutputText(QueuedText text)
+        {
+            m_curText = text;
+
+            text.Play();
+
+            while (text.IsPlaying())
+            {
+                yield return null;
+            }
+
+            m_prevTexts.Add(m_curText);
+            m_curText = null;
+        }
+
+        internal void OutputTextAndWait(string text, Action onStart=null, Action onEnd=null)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            if (text.Length == 0)
+            {
+                if (onStart != null) onStart();
+                if (onEnd != null) onEnd();
+                return;
+            }
+
+            m_queuedTexts.Enqueue(new QueuedText(text, onStart, onEnd));
+        }
+
+        internal void OutputNarrationAsText(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            if (text.Length == 0)
+            {
+                return;
+            }
+
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, false, true, true));
+        }
+
+        internal void OutputText(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, false, false));
+        }
+
+        internal void OutputTextImmediately(string text)
+        {
+            text = AccessibilityUtils.CurateText(text);
+
+            InterruptTexts();
+            m_queuedTexts.Enqueue(new QueuedText(text, null, null, true, false));
+        }
+
+        internal void IncreaseSpeechRate()
+        {
+            IncWPM(1);
+        }
+
+        internal void DecreaseSpeechRate()
+        {
+            IncWPM(-1);
+        }
+
+        private void IncWPM(int inc)
+        {
+            if (!CanAdjustGameSpeed())
+			{
+                AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_SPEED_CANNOT_ADJUST_VS_PLAYERS));
+                return;
+			}
+
+            LoadGameSpeedOptionIfNecessary();
+
+            var curIndex = m_curGameSpeed - 1;
+            var targetIndex = curIndex + inc;
+
+            if (targetIndex < 0 || targetIndex >= m_WPMSpeeds.Count)
+            {
+                return;
+            }
+            else
+            {
+                m_curGameSpeed = targetIndex + 1;
+                UpdateCPS();
+                SaveGameSpeed();
+                var gameSpeedAdjustText = AccessibilityUtils.CurateText(LocalizationUtils.Format(LocalizationKey.GLOBAL_GAME_SPEED, m_curGameSpeed));
+                ScreenReader.Output(gameSpeedAdjustText);
+
+                foreach(var text in m_queuedTexts)
+                {
+                    text.UpdateSpeed();
+                }
+            }
+        }
+
+		private bool CanAdjustGameSpeed()
+		{
+            return !AccessibilityUtils.IsInPvPGame() && !AccessibleGameplayUtils.IsPlayingBattlegrounds();
+		}
+
+		private void SaveGameSpeed()
+        {
+            Options.Get().SetInt(Option.ACCESSIBILITY_GAME_SPEED, m_curGameSpeed);
+        }
+
+        private void UpdateCPS()
+        {
+            var wpm = m_WPMSpeeds[m_curGameSpeed - 1];
+            m_curCPS = CalcCPS(wpm);
+        }
+
+        private static int CalcCPS(int wpm)
+        {
+            return wpm * 6 / 60;
+        }
+
+        internal int GetCPS()
+        {
+            if (!CanAdjustGameSpeed())
+			{
+                return MAX_GAME_SPEED_CPS;
+			}
+
+            LoadGameSpeedOptionIfNecessary();
+
+            return m_curCPS;
+        }
+
+        private void LoadGameSpeedOptionIfNecessary()
+        {
+            if (!m_gameSpeedOptionLoaded)
+            {
+                m_gameSpeedOptionLoaded = true;
+
+                int gameSpeed = Options.Get().GetInt(Option.ACCESSIBILITY_GAME_SPEED, m_curGameSpeed);
+
+                int wpmIndex = gameSpeed - 1;
+                if (wpmIndex < 0 || wpmIndex >= m_WPMSpeeds.Count)
+                {
+                    SaveGameSpeed();
+                    return;
+                }
+
+                m_curGameSpeed = gameSpeed;
+                UpdateCPS();
+            }
+        }
+
+        #endregion
+
+        private bool IsSpeechAudioAvailable()
+        {
+            return false; // Prerecorded speech is no longer being used as of 27.6. Removal should be considered.
+
+            var locale = Localization.GetLocale();
+
+            if (locale == Locale.enUS || locale == Locale.enGB)
+            {
+                return true;
+            }
+
+            if (LocalizationUtils.HasKey(LocalizationKey.TUTORIAL_NARRATOR_INTRO))
+            {
+                return false; // Heuristic: if the narrator intro has been localized, we're distributing a version of HSA with the tutorial translated
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs b/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs
new file mode 100644
index 0000000..d7d60b6
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleSpeechOptimizer.cs
@@ -0,0 +1,265 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleSpeechOptimizer
+    {
+        // TODO: Think about this whole thing re: localization
+
+        public static void OptimizeText(QueuedText text, List<QueuedText> prevTexts)
+        {
+            try
+            {
+                if (text == null)
+                {
+                    return;
+                }
+
+                if (OptimizeAttackAndDiedText(text, prevTexts))
+                {
+                    return;
+                }
+
+                if (OptimizeAttackAndTookDamageText(text, prevTexts))
+                {
+                    return;
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+        }
+
+        #region Attack and Died
+
+        private static bool OptimizeAttackAndDiedText(QueuedText queuedText, List<QueuedText> prevTexts)
+        {
+            if (prevTexts.Count == 0)
+            {
+                return false;
+            }
+
+            var text = queuedText.GetText();
+            var prevText = prevTexts[prevTexts.Count - 1].GetText();
+
+            if (!SomeoneDied(text))
+            {
+                return false;
+            }
+
+            var xAttackedYMatch = Regex.Match(prevText, @"(.*) attacked (.*).");
+
+            if (!xAttackedYMatch.Success)
+            {
+                return false;
+            }
+
+            var attacker = xAttackedYMatch.Groups[1].Value;
+            var defender = xAttackedYMatch.Groups[2].Value;
+
+            attacker = CleanUpOrderIfNeeded(attacker);
+            defender = CleanUpOrderIfNeeded(defender);
+
+            if (EqualsIgnoreCase(text, $"{attacker} and {defender} died.") ||
+                EqualsIgnoreCase(text, $"{defender} and {attacker} died.") ||
+                EqualsIgnoreCase(text, "All minions died."))
+            {
+                var entityTypes = "minions";
+
+                if (IsHero(attacker) || IsHero(defender))
+                {
+                    entityTypes = "characters";
+                }
+
+                queuedText.UpdateText($"Both {entityTypes} died.");
+
+                return true;
+            }
+            else if (EqualsIgnoreCase(text, $"{attacker} died."))
+            {
+                var simplifiedText = SimplifyEntityDiedText(attacker);
+                queuedText.UpdateText(simplifiedText);
+
+                return true;
+            }
+            else if (EqualsIgnoreCase(text, $"{defender} died."))
+            {
+                var simplifiedText = SimplifyEntityDiedText(defender);
+                queuedText.UpdateText(simplifiedText);
+
+                return true;
+            }
+
+            return false;
+        }
+        private static bool OptimizeAttackAndTookDamageText(QueuedText queuedText, List<QueuedText> prevTexts)
+        {
+            if (prevTexts.Count == 0)
+            {
+                return false;
+            }
+
+            var text = queuedText.GetText();
+            var prevText = prevTexts[prevTexts.Count - 1].GetText();
+
+            if (!SomeoneTookDamage(text))
+            {
+                return false;
+            }
+
+            var xAttackedYMatch = Regex.Match(prevText, @"(.*) attacked (.*).");
+
+            if (!xAttackedYMatch.Success)
+            {
+                return false;
+            }
+
+            var attacker = xAttackedYMatch.Groups[1].Value;
+            var defender = xAttackedYMatch.Groups[2].Value;
+
+            var aAndBTookNDamageMatch = Regex.Match(text, $@"{attacker} and {defender} took (.*) damage.");
+            string dmgTaken;
+
+            if (aAndBTookNDamageMatch.Success)
+            {
+                dmgTaken = aAndBTookNDamageMatch.Groups[1].Value;
+            }
+            else
+            {
+                var bAndATookNDamageMatch = Regex.Match(text, $@"{defender} and {attacker} took (.*) damage.");
+
+                if (!bAndATookNDamageMatch.Success)
+                {
+                    return false;
+                }
+                else
+                {
+                    dmgTaken = bAndATookNDamageMatch.Groups[1].Value;
+                }
+            }
+
+            var entityTypes = "minions";
+
+            if (IsHero(attacker) || IsHero(defender))
+            {
+                entityTypes = "characters";
+            }
+            queuedText.UpdateText($"Both {entityTypes} took {dmgTaken} damage.");
+
+            return true;
+        }
+
+        private static string CleanUpOrderIfNeeded(string fullEntityName)
+        {
+            var parts = fullEntityName.Split(' ');
+
+            if (parts.Length == 0)
+            {
+                return fullEntityName;
+            }
+
+            if (EqualsIgnoreCase(parts[0], "your"))
+            {
+                if (parts.Length >= 2 && EqualsIgnoreCase(parts[1], "opponent's"))
+                {
+
+                    if (parts.Length >= 3 && LocalizationUtils.IsOrdinalNumber(parts[2]))
+                    {
+                        return CreateNameWithoutOrder(parts, 2);
+                    }
+                }
+                else if (parts.Length >= 2 && LocalizationUtils.IsOrdinalNumber(parts[1]))
+                {
+                    return CreateNameWithoutOrder(parts, 1);
+                }
+            }
+
+            return fullEntityName;
+        }
+
+        private static string CreateNameWithoutOrder(string[] parts, int orderIndex)
+        {
+            var sb = new StringBuilder();
+
+            for (int i = 0; i < parts.Length; i++)
+            {
+                if (i != orderIndex)
+                {
+                    if (i > 0)
+                    {
+                        sb.Append(' ');
+                    }
+
+                    sb.Append(parts[i]);
+                }
+            }
+
+            return sb.ToString();
+        }
+
+        private static string SimplifyEntityDiedText(string entity)
+        {
+            if (IsHero(entity))
+            {
+                return $"{entity} died.";
+            }
+            else if (IsOpponentEntity(entity))
+            {
+                return "Your opponent's minion died.";
+            }
+            else if (IsPlayerEntity(entity))
+            {
+                return "Your minion died.";
+            }
+
+            Log.Accessibility.PrintWarning($"Failed to simplify entity died text: {entity}");
+            return entity;
+        }
+
+        private static bool SomeoneDied(string text)
+        {
+            return Regex.Match(text, @"(.*) died.").Success;
+        }
+
+        private static bool SomeoneTookDamage(string text)
+        {
+            return Regex.Match(text, @"(.*) took .* damage.").Success;
+        }
+
+        #endregion
+
+        private static bool IsOpponentEntity(string entity)
+        {
+            return StartsWithIgnoreCase(entity, "Your opponent's ");
+        }
+
+        private static bool IsPlayerEntity(string entity)
+        {
+            return StartsWithIgnoreCase(entity, "Your ");
+        }
+
+        private static bool StartsWithIgnoreCase(string s1, string s2)
+        {
+            return s1.ToLowerInvariant().StartsWith(s2.ToLowerInvariant());
+        }
+
+        private static bool IsHero(string entity)
+        {
+            return EqualsIgnoreCase(entity, "Your hero") || EqualsIgnoreCase(entity, "Your opponent's hero");
+        }
+
+        private static bool EqualsIgnoreCase(string a, string b)
+        {
+            return a.Equals(b, StringComparison.InvariantCultureIgnoreCase);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs b/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs
new file mode 100644
index 0000000..5fb7c29
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleSpeechUtils.cs
@@ -0,0 +1,344 @@
+﻿using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    class AccessibleSpeechUtils
+    {
+        internal static string GetFullName(Entity entity)
+        {
+            if (entity.IsControlledByFriendlySidePlayer())
+            {
+                return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME, GetName(entity));
+            }
+            else
+            {
+                return GetFullNameForOpponent(entity);
+            }
+        }
+
+		private static string GetFullNameForOpponent(Entity entity)
+		{
+            var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME : LocalizationKey.GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME;
+			return LocalizationUtils.Format(key, GetName(entity));
+		}
+
+		internal static string GetFullNameInZone(Entity entity)
+        {
+            if (entity.GetZone() == TAG_ZONE.GRAVEYARD ||
+                entity.GetZone() == TAG_ZONE.INVALID ||
+                entity.GetZone() == TAG_ZONE.REMOVEDFROMGAME ||
+                entity.GetZone() == TAG_ZONE.SETASIDE)
+            {
+                return GetFullName(entity);
+            }
+
+            var entitiesInZone = new List<Entity>();
+
+            foreach (var card in entity.GetCard().GetZone()?.GetCards())
+            {
+                entitiesInZone.Add(card.GetEntity());
+            }
+
+            return GetFullNameInList(entity, entitiesInZone);
+        }
+
+        internal static string GetFullNameInList(Entity entity, List<Entity> entitiesInZone)
+        {
+            // TODO: entities are not necessarily in the same zone so there may be cases where this is confusing.. e.g. your X (in your hand) and your X (in your battlefield) did Y
+            // Haven't really run into anything yet so keeping it like this for now
+
+            int entityNum = 0;
+            int entityCount = 0;
+
+            foreach(var ent in entitiesInZone)
+            {
+                if (GetFullName(ent).Equals(GetFullName(entity)))
+                {
+                    entityCount++;
+                }
+
+                if (ent.GetEntityId() == entity.GetEntityId())
+                {
+                    entityNum = entityCount;
+                }
+            }
+
+            if (entityCount <= 1)
+            {
+                return GetFullName(entity);
+            }
+            else
+            {
+                var order = LocalizationUtils.GetOrdinalNumber(entityNum);
+                var entityName = GetName(entity);
+
+                if (entity.IsControlledByFriendlySidePlayer())
+                {
+                    return LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME_IN_LIST, order, entityName);
+                }
+                else
+                {
+                    return GetFullNameInListForOpponent(order, entityName);
+                }
+            }
+        }
+
+		private static string GetFullNameInListForOpponent(string order, string entityName)
+		{
+            var key = AccessibleGameplayUtils.IsInBattlegroundsShopPhase() ? LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME_IN_LIST : LocalizationKey.GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME_IN_LIST;
+			return LocalizationUtils.Format(key, order, entityName);
+		}
+
+		internal static string GetName(Entity entity)
+        {
+            if (entity.IsHero())
+            {
+                return GameStrings.GetCardTypeName(entity.GetCardType());
+            }
+            else if (entity.IsHeroPower())
+            {
+                return GameStrings.GetCardTypeName(entity.GetCardType());
+            }
+            else if (entity.GetCardType() == TAG_CARDTYPE.INVALID)
+            {
+                return LocalizedText.GLOBAL_CARD;
+            }
+            else
+			{
+                return GetEntityName(entity);
+			}
+        }
+
+		internal static string GetEntityName(Entity entity)
+		{
+            if (AccessibleGameplayUtils.IsPlayingBattlegrounds())
+            {
+                return AccessibleCardUtils.GetInGameEntityNameWithPremium(entity);
+            }
+            else
+            {
+                return entity.GetName();
+            }
+		}
+
+		internal static string GetNames(List<Card> cards)
+        {
+            // Mostly used for mulligan (cards only i.e. no heroes)
+            var nameCounts = new Dictionary<string, int>();
+            var orderedCardNames = new List<string>(); // Could just create an insertion-order dictionary but whatever
+
+            foreach (var card in cards)
+            {
+                // Note: Have to clone the entity here because of dropped mulligan cards which are hidden by the time this is called.
+                var cardName = GetEntityName(card.GetEntity().CloneForAccessibility());
+
+                if (nameCounts.ContainsKey(cardName))
+                {
+                    nameCounts[cardName]++;
+                }
+                else
+                {
+                    nameCounts.Add(cardName, 1);
+                    orderedCardNames.Add(cardName);
+                }
+            }
+
+            return HumanizeNames(orderedCardNames, nameCounts);
+        }
+
+        internal static string FormatZoneMovementText(List<string> cards, LocalizationKey singularKey, LocalizationKey pluralKey)
+		{
+            if (cards.Count == 0)
+			{
+                return null;
+			}
+
+            if (cards.Count == 1)
+            {
+                return LocalizationUtils.Format(singularKey, cards[0]);
+            }
+            else
+            {
+                var counts = new Dictionary<string, int>();
+                foreach (var card in cards)
+                {
+                    if (!counts.ContainsKey(card))
+                    {
+                        counts.Add(card, 1);
+                    }
+                    else
+                    {
+                        counts[card]++;
+                    }
+                }
+
+                var cardNames = HumanizeNames(cards, counts);
+
+                return LocalizationUtils.Format(pluralKey, cardNames);
+            }
+		}
+
+        internal static string HumanizeNames(List<string> orderedNames, Dictionary<string, int> nameCounts)
+        {
+            var separator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_SEPARATOR);
+            var finalSeparator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_FINAL_SEPARATOR);
+            var cardString = LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+            var cardStringPlural = LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD_PLURAL);
+
+            var sb = new StringBuilder();
+            int idx = 0;
+
+            orderedNames = GetDistinct(orderedNames);
+
+            foreach(var name in orderedNames)
+            {
+                if (idx > 0)
+                {
+                    if (idx < orderedNames.Count - 1)
+                    {
+                        sb.Append($"{separator} ");
+                    }
+                    else
+                    {
+						sb.Append($" {finalSeparator} ");
+					}
+				}
+
+                var curNameCount = nameCounts[name];
+
+                if (curNameCount > 1)
+                {
+                    if(name.Equals(cardString)) sb.Append(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES, curNameCount, cardStringPlural));
+                    else sb.Append(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES, curNameCount, name));
+                }
+                else
+                {
+                    if( name.Equals(cardString))                    sb.Append(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES, curNameCount,  name));
+                    else sb.Append(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_MULTIPLE_ENTITIES, "",  name));
+                }
+
+                idx++;
+            }
+
+            return sb.ToString();
+        }
+
+        private static List<string> GetDistinct(List<string> elems)
+        {
+            var ret = new List<string>();
+            var handled = new HashSet<string>();
+
+            foreach(var elem in elems)
+            {
+                if (!handled.Contains(elem))
+                {
+                    ret.Add(elem);
+                    handled.Add(elem);
+                }
+            }
+
+            return ret;
+        }
+
+        public static string HumanizeList(List<string> list)
+        {
+            var separator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_SEPARATOR);
+            var finalSeparator = LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_FINAL_SEPARATOR);
+
+            if (list.Count == 0)
+            {
+                return "";
+            }
+
+            if (list.Count == 1)
+            {
+                return list[0];
+            }
+            else
+            {
+                var sb = new StringBuilder();
+
+                for (int i = 0; i < list.Count - 1; i++)
+                {
+                    if (i != 0)
+                    {
+                        sb.Append($"{separator} ");
+                    }
+
+                    sb.Append(list[i]);
+                }
+
+                sb.Append($" {finalSeparator} ");
+                sb.Append(list[list.Count - 1]);
+
+                return sb.ToString();
+            }
+        }
+
+        internal static string CombineLines(List<string> lines)
+        {
+            var sentenceEndingChars = LocalizationUtils.Get(LocalizationKey.FORMATTING_SENTENCE_ENDING_CHARACTERS);
+            var period = LocalizationUtils.Get(LocalizationKey.FORMATTING_PERIOD);
+            var sb = new StringBuilder();
+
+            foreach (var line in lines)
+            {
+                if (line.Length == 0)
+                {
+                    continue;
+                }
+
+                if (sb.Length > 0)
+                {
+                    if (!sentenceEndingChars.Contains(sb[sb.Length - 1]))
+                    {
+                        sb.Append(period);
+                    }
+
+                    sb.Append(" ");
+                }
+
+                sb.Append(line);
+            }
+
+            return sb.ToString();
+        }
+
+        internal static string CombineSentences(string a, string b)
+        {
+            var sentenceEndingChars = LocalizationUtils.Get(LocalizationKey.FORMATTING_SENTENCE_ENDING_CHARACTERS);
+            var period = LocalizationUtils.Get(LocalizationKey.FORMATTING_PERIOD);
+
+            if (a.Length == 0)
+            {
+                return b;
+            }
+            else if (b.Length == 0)
+            {
+                return a;
+            }
+
+            var lastAChar = a[a.Length - 1];
+            if (sentenceEndingChars.Contains(lastAChar))
+            {
+                return $"{a} {b}";
+            }
+            else
+            {
+                return $"{a}{period} {b}";
+            }
+        }
+
+        internal static string CombineWordsWithComma(string a, string b)
+        {
+            return $"{a} ; {b}";
+        }
+
+        internal static string CombineWordsWithColon(string a, string b)
+        {
+            return $"{a}: {b}";
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleTavernGuideQuest.cs b/Assembly-CSharp/Accessibility/AccessibleTavernGuideQuest.cs
new file mode 100644
index 0000000..77efef0
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleTavernGuideQuest.cs
@@ -0,0 +1,44 @@
+using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+using Hearthstone.Progression;
+
+namespace Accessibility
+{
+    class AccessibleTavernGuideQuest : AccessibleItem
+    {
+        private TavernGuideQuestDataModel m_dataModel;
+
+        internal AccessibleTavernGuideQuest(AccessibleComponent parent, TavernGuideQuestDataModel dataModel) : base(parent)
+        {
+            m_dataModel = dataModel;
+        }
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+            ret.Add(m_dataModel.Title);
+            if (m_dataModel.Status == TavernGuideManager.TavernGuideQuestStatus.LOCKED)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.TAVERN_GUIDE_QUEST_UNLOCK_REQUIREMENT, m_dataModel.UnlockRequirementsDescription));
+                return ret;
+            }
+            if (m_dataModel.Status == TavernGuideManager.TavernGuideQuestStatus.COMPLETED)
+            {
+                ret.Add(LocalizationUtils.Get(LocalizationKey.TAVERN_GUIDE_QUEST_COMPLETED));
+            }
+            var questDataModel = m_dataModel.Quest;
+            ret.Add(questDataModel.Description);
+            var progress = AccessibleQuest.GetProgress(questDataModel);
+            if (!string.IsNullOrEmpty(progress) && m_dataModel.Status != TavernGuideManager.TavernGuideQuestStatus.COMPLETED)
+            {
+                ret.Add(progress);
+            }
+            ret.Add(m_dataModel.SelectedDescription);
+            if (!string.IsNullOrEmpty(m_dataModel.RecommendedClasses))
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.TAVERN_GUIDE_QUEST_RECOMMENDED_CLASSES, m_dataModel.RecommendedClasses));
+            }
+            return ret;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleTraditionalCard.cs b/Assembly-CSharp/Accessibility/AccessibleTraditionalCard.cs
new file mode 100644
index 0000000..a8b8819
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleTraditionalCard.cs
@@ -0,0 +1,375 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleTraditionalCard : AccessibleCard
+    {
+        internal AccessibleTraditionalCard(AccessibleComponent parent, Card card) : base(parent, card)
+        {
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_card.GetEntity().IsHero())
+            {
+                return GetLinesForHero();
+            }
+            else if (m_card.GetEntity().IsHeroPower())
+            {
+                return GetLinesForHeroPower();
+            }
+            else if (m_card.GetEntity().IsWeapon())
+            {
+                return GetLinesForWeapon();
+            }
+            else if (m_card.GetEntity().IsQuest())
+            {
+                return GetLinesForQuest();
+            }
+            else if (m_card.GetEntity().IsSideQuest())
+            {
+                return GetLinesForSideQuest();
+            }
+            else if (m_card.GetEntity().IsQuestline())
+            {
+                return GetLinesForQuestline();
+            }
+            else if (m_card.GetEntity().IsSecret() && !m_card.GetEntity().IsControlledByFriendlySidePlayer())
+            {
+                return GetLinesForOpponentSecret();
+            }
+            else
+            {
+                return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            var zone = m_card.GetEntity().GetZone();
+
+            if (zone == TAG_ZONE.PLAY)
+            {
+                if (IsTurnBasedHero())
+                {
+                    // e.g. Some BoH missions which use x turns to hold out instead of attack/health
+                    return GetLinesForTurnBasedHeroInPlayZone();
+                }
+                else
+                {
+                    return GetLinesForHeroInPlayZone();
+                }
+            }
+            else
+            {
+                return GetLinesForHeroCard();
+            }
+        }
+
+        private bool IsTurnBasedHero()
+        {
+            if (!GameState.Get().GetGameEntity().IsTurnCounterBasedMission())
+            {
+                return false;
+            }
+
+            return m_card.GetEntity().IsControlledByOpposingSidePlayer();
+        }
+
+        private List<string> GetLinesForTurnBasedHeroInPlayZone()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            var missionEntity = GameState.Get().GetGameEntity() as MissionEntity;
+            lines.Add(missionEntity.GetTurnCounterText());
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroInPlayZone()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    resources = $"{resources} {effects}";
+                }
+
+                lines.Add(resources);
+            }
+            else
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            try
+			{
+				if (AccessibilityUtils.IsInPvPGame())
+				{
+					lines.Add(m_card.GetController().GetName());
+					lines.Add(GameStrings.GetClassName(m_card.GetEntity().GetClass()));
+				}
+			}
+            catch (Exception e)
+			{
+                AccessibilityUtils.LogFatalError(e);
+			}
+
+
+			return lines;
+        }
+
+		private List<string> GetLinesForHeroCard()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+            lines.Add(AccessibleCardUtils.GetCost(m_card));
+            lines.Add(GetCardType());
+
+            var armor = m_card.GetEntity().GetArmor();
+
+            lines.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            try
+            {
+                lines.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(m_card.GetEntity().GetCardId()));
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForWeapon()
+        {
+            var isWielded = m_card.GetZone()?.GetType() == typeof(ZoneWeapon);
+
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            if (!isWielded)
+            {
+                lines.Add(AccessibleCardUtils.GetCost(m_card));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetResources(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            if (!isWielded)
+            {
+                lines.Add(GetCardType());
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            var zone = m_card.GetEntity().GetZone();
+            var isInPlayZone = zone == TAG_ZONE.PLAY;
+            var isInSecretZone = zone == TAG_ZONE.SECRET;
+            var shouldReadCost = !isInPlayZone && !isInSecretZone;
+
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            if (shouldReadCost)
+            {
+                lines.Add(AccessibleCardUtils.GetCost(m_card));
+            }
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                if (isInPlayZone)
+                {
+                    var effects = GetEffects();
+                    if (effects.Length > 0)
+                    {
+                        resources = $"{resources} {effects}";
+                    }
+                }
+
+                lines.Add(resources);
+            }
+            else if (isInPlayZone)
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetRace(), lines); // Handles spell school as well
+
+            if (!isInPlayZone)
+            {
+                lines.Add(GetCardType());
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            // e.g. Colossal cards (token)
+            if (m_card.GetEntity().GetZone() == TAG_ZONE.HAND && m_card.GetEntity().HasTag(GAME_TAG.DISPLAY_CARD_ON_MOUSEOVER))
+			{
+                m_pageTwoIndex = lines.Count;
+                var tokenEntityDef = DefLoader.Get().GetEntityDef(m_card.GetEntity().GetTag(GAME_TAG.DISPLAY_CARD_ON_MOUSEOVER));
+
+                lines.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(tokenEntityDef, TAG_PREMIUM.NORMAL));
+			}
+
+            return lines;
+        }
+
+        private List<string> GetLinesForSideQuest()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetQuestProgress(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForQuestline()
+        {
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(GetQuestProgress(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetQuestlinePart(), lines);
+            lines.AddRange(GetQuestlineProgress());
+            lines.AddRange(GetQuestReward());
+            AccessibleCardUtils.AddLineIfExists(GetNextQuestlinePart(), lines);
+
+            return lines;
+        }
+
+        private string GetQuestlinePart()
+        {
+            var questlineController = m_card.GetActor().GetComponent<QuestlineController>();
+
+            if (questlineController == null)
+            {
+                return "";
+            }
+
+            var questlineProgressUI = questlineController.m_QuestlineProgressUI;
+
+            if (questlineProgressUI == null)
+            {
+                return "";
+            }
+
+            if (questlineProgressUI.m_QuestDetailTextLeft.gameObject.activeSelf)
+            {
+                return questlineProgressUI.m_QuestDetailTextLeft.Text;
+            }
+
+            return "";
+        }
+
+        private string GetNextQuestlinePart()
+        {
+            var questlineController = m_card.GetActor().GetComponent<QuestlineController>();
+
+            if (questlineController == null)
+            {
+                return "";
+            }
+
+            var questlineProgressUI = questlineController.m_QuestlineProgressUI;
+
+            if (questlineProgressUI == null)
+            {
+                return "";
+            }
+
+            if (questlineProgressUI.m_QuestDetailTextRight.gameObject.activeSelf)
+            {
+                return questlineProgressUI.m_QuestDetailTextRight.Text;
+            }
+
+            return "";
+        }
+
+        private List<string> GetQuestlineProgress()
+        {
+            var ret = new List<string>();
+
+            var questlineController = m_card.GetActor().GetComponent<QuestlineController>();
+
+            if (questlineController == null)
+            {
+                return ret;
+            }
+
+            var questlineProgressUI = questlineController.m_QuestlineProgressUI;
+
+            if (questlineProgressUI == null)
+            {
+                return ret;
+            }
+
+            var req1Text = questlineProgressUI.m_QuestRequirementText1.Text;
+            var req2Text = questlineProgressUI.m_QuestRequirementText2.Text;
+            var req3Text = questlineProgressUI.m_QuestRequirementText3.Text;
+
+            if (questlineProgressUI.m_QuestRequirementText1.gameObject.activeSelf && req1Text != null && req1Text.Length > 0)
+            {
+                ret.Add(FormatQuestlineRequirementText(req1Text, questlineProgressUI.m_RequirementCheckmark1));
+            }
+
+            if (questlineProgressUI.m_QuestRequirementText2.gameObject.activeSelf && req2Text != null && req2Text.Length > 0)
+            {
+                ret.Add(FormatQuestlineRequirementText(req2Text, questlineProgressUI.m_RequirementCheckmark2));
+            }
+
+            if (questlineProgressUI.m_QuestRequirementText3.gameObject.activeSelf && req3Text != null && req3Text.Length > 0)
+            {
+                ret.Add(FormatQuestlineRequirementText(req3Text, questlineProgressUI.m_RequirementCheckmark3));
+            }
+
+            return ret;
+        }
+
+        private string FormatQuestlineRequirementText(string reqText, GameObject reqCheckmark)
+        {
+            if (reqCheckmark.activeInHierarchy)
+            {
+                return $"{reqText} {LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_CHECKED)}";
+            }
+            else
+            {
+                return $"{reqText} {LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_NOT_CHECKED)}";
+            }
+        }
+
+        private string GetRarity()
+        {
+            return AccessibleCardUtils.GetRarity(m_card.GetEntity().GetEntityDef());
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs b/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs
new file mode 100644
index 0000000..4725c51
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleTutorialProgressScreen.cs
@@ -0,0 +1,89 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleTutorialProgressScreen : AccessibleScreen
+    {
+        private static AccessibleTutorialProgressScreen s_instance = new AccessibleTutorialProgressScreen();
+
+        internal static AccessibleTutorialProgressScreen Get()
+        {
+            return s_instance;
+        }
+
+        private enum AccessibleTutorialProgressScreenState {
+            READY_TO_START,
+            WAITING_FOR_ANIMATIONS,
+            REWARD_CHEST_SHOWN
+        }
+
+        private AccessibleTutorialProgressScreenState m_curState;
+
+        private (string, string) GetProgressMessage(TutorialProgress progress)
+        {
+            switch (progress)
+            {
+                case TutorialProgress.NOTHING_COMPLETE:
+                return ("", LocalizationUtils.Get(LocalizationKey.NEW_TUTORIAL_NEXT_REXXAR));
+                case TutorialProgress.REXXAR_COMPLETE:
+                return (LocalizationUtils.Get(LocalizationKey.NEW_TUTORIAL_DEFEATED_REXXAR), LocalizationUtils.Get(LocalizationKey.NEW_TUTORIAL_NEXT_GARROSH));
+                case TutorialProgress.GARROSH_COMPLETE:
+                return (LocalizationUtils.Get(LocalizationKey.NEW_TUTORIAL_DEFEATED_GARROSH), LocalizationUtils.Get(LocalizationKey.NEW_TUTORIAL_NEXT_LICH_KING));
+                case TutorialProgress.LICH_KING_COMPLETE:
+                return (LocalizationUtils.Get(LocalizationKey.NEW_TUTORIAL_DEFEATED_LICH_KING), "");
+                default:
+                AccessibilityUtils.LogFatalError("Tutorial progress screen encountered an unknown tutorial progress state: " + Enum.GetName(typeof(TutorialProgress), progress));
+                return ("", "");
+            }
+        }
+
+        public void OnStartTutorial()
+        {
+            AccessibilityMgr.SetScreen(this);
+            AccessibilityMgr.Output(this, LocalizedText.TUTORIAL_LOADING_TUTORIAL);
+            AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+            AccessibilityMgr.TransitioningScreens();
+        }
+
+        public void OnUpdateProgress(TutorialProgress progress)
+        {
+            AccessibilityMgr.SetScreen(this);
+            var msg = GetProgressMessage(progress);
+            AccessibilityMgr.Output(this, msg.Item1);
+            AccessibilityMgr.Output(this, msg.Item2);
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM));
+            m_curState = (progress == TutorialProgress.LICH_KING_COMPLETE) ? AccessibleTutorialProgressScreenState.REWARD_CHEST_SHOWN : AccessibleTutorialProgressScreenState.READY_TO_START;
+        }
+
+        public void HandleInput()
+        {
+            if (AccessibleKey.CONFIRM.IsPressed() && m_curState == AccessibleTutorialProgressScreenState.READY_TO_START)
+            {
+                TutorialProgressScreen.Get().OnPlayButton(null);
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed() && m_curState == AccessibleTutorialProgressScreenState.REWARD_CHEST_SHOWN)
+            {
+                TutorialProgressScreen.Get().OnRewardChest(null);
+            }
+        }
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case AccessibleTutorialProgressScreenState.READY_TO_START:
+                    return AccessibleSpeech.PRESS_ENTER_TO_START;
+                case AccessibleTutorialProgressScreenState.REWARD_CHEST_SHOWN:
+                return LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM);
+                default:
+                    return "";
+            }
+        }
+
+        public void OnGainedFocus()
+        {
+        }
+
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleUI.cs b/Assembly-CSharp/Accessibility/AccessibleUI.cs
new file mode 100644
index 0000000..b2f7644
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleUI.cs
@@ -0,0 +1,9 @@
+﻿namespace Accessibility
+{
+    internal interface AccessibleUI : AccessibleComponent
+    {
+        void HandleAccessibleInput();
+
+        string GetAccessibleHelp();
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs b/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs
new file mode 100644
index 0000000..d20d1e6
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleUnityInput.cs
@@ -0,0 +1,147 @@
+﻿using UnityEngine;
+
+public class AccessibleUnityInput : IInput
+{
+	private Vector3 m_mousePosition;
+	private bool[] m_buttonIsDown = new bool[3];
+	private bool[] m_buttonWasDown = new bool[3];
+
+	private static AccessibleUnityInput s_instance;
+
+	private static bool m_enabled = true;
+
+	private AccessibleUnityInput() { }
+
+	public static AccessibleUnityInput Get()
+    {
+		if (s_instance == null)
+        {
+			s_instance = new AccessibleUnityInput();
+        }
+
+		return s_instance;
+    }
+
+	public bool GetMousePosition(out Vector3 position)
+	{
+		position = m_mousePosition;
+		return m_enabled;
+	}
+
+	public Vector3 GetMousePosition()
+	{
+		return m_mousePosition;
+	}
+
+	public bool GetAnyKey(out bool value)
+	{
+		value = Input.anyKey;
+		return m_enabled;
+	}
+
+	public bool GetAnyKeyDown(out bool value)
+	{
+		value = Input.anyKeyDown;
+		return m_enabled;
+	}
+
+	public bool GetKey(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKey(keycode);
+		return m_enabled;
+	}
+
+	public bool GetKeyDown(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKeyDown(keycode);
+		return m_enabled;
+	}
+
+	public bool GetKeyUp(KeyCode keycode, out bool value)
+	{
+		value = Input.GetKeyUp(keycode);
+		return m_enabled;
+	}
+
+	public bool GetMouseButton(int button, out bool value)
+	{
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButton on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	public bool GetMouseButtonDown(int button, out bool value)
+	{
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButtonDown on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = !m_buttonWasDown[button] && m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	public bool GetMouseButtonUp(int button, out bool value)
+	{
+        if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to GetMouseButtonUp on invalid button {button}");
+			value = false;
+			return value;
+        }
+
+		value = m_buttonWasDown[button] && !m_buttonIsDown[button];
+		return m_enabled;
+	}
+
+	internal void SetMousePosition(Vector3 pos)
+    {
+		m_mousePosition = pos;
+    }
+
+	// Must only be called once per frame per button!
+	internal void SetMouseButtonDown(int button, bool isDown)
+    {
+		if (!IsValidButton(button))
+        {
+			Log.Accessibility.PrintWarning($"Attempted to SetMouseButtonDown on invalid button {button}");
+			return;
+        }
+
+		m_buttonWasDown[button] = m_buttonIsDown[button];
+		m_buttonIsDown[button] = isDown;
+    }
+
+	internal void ToggleEnabled()
+    {
+		m_enabled = !m_enabled;
+    }
+
+	internal void SetEnabled()
+	{
+		m_enabled = true;
+	}
+
+	internal void SetDisabled()
+	{
+		m_enabled = false;
+	}
+
+	private bool IsValidButton(int button)
+    {
+		return button >= 0 && button <= 2;
+    }
+
+	internal bool Enabled
+    {
+		get { return m_enabled;  }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleUnityUtils.cs b/Assembly-CSharp/Accessibility/AccessibleUnityUtils.cs
new file mode 100644
index 0000000..2c0b3c8
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleUnityUtils.cs
@@ -0,0 +1,109 @@
+﻿using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleUnityUtils
+    {
+        public static GameObject GetChildObject(GameObject go, string childObjectName)
+        {
+            if (go == null)
+            {
+                AccessibilityUtils.LogFatalError($"AccessibleUnityUtils.GetChildObject(null, {childObjectName})");
+                return null;
+            }
+            var childObjectTransform = go.transform.Find(childObjectName);
+
+            if (childObjectTransform == null)
+            {
+                AccessibilityUtils.LogFatalError($"AccessibleUnityUtils.GetChildObject({go.name}, {childObjectName}) returned null transform");
+                return null;
+            }
+
+            return childObjectTransform.gameObject;
+        }
+
+        #region Debugging
+
+        public static void DebugGameObject(GameObject go)
+        {
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+            AccessibilityUtils.LogDebug($"Debugging GameObject");
+            AccessibilityUtils.LogDebug($"name: {GetObjectNameWithComponents(go)}");
+
+            AccessibilityUtils.LogDebug($"childCount: {go.transform.childCount}");
+            DebugChildren(go, 1);
+        }
+
+        private static string GetObjectNameWithComponents(GameObject go)
+        {
+            var sb = new StringBuilder();
+
+            sb.Append(go.name);
+
+            var components = go.GetComponents(typeof(Component));
+
+            if (components.Length > 0)
+            {
+                sb.Append(" (");
+                for (int i = 0; i < components.Length; i++)
+                {
+                    if (i > 0)
+                    {
+                        sb.Append(", ");
+                    }
+                    sb.Append(components[i].GetType());
+                }
+                sb.Append(")");
+            }
+
+            return sb.ToString();
+        }
+
+        private static void DebugChildren(GameObject go, int depth)
+        {
+            for (int i = 0; i < go.transform.childCount; i++)
+            {
+                var child = go.transform.GetChild(i).gameObject;
+                var indent = new string('-', depth*3);
+                AccessibilityUtils.LogDebug($"{indent} {GetObjectNameWithComponents(child)}");
+
+                DebugChildren(child, depth + 1);
+            }
+        }
+
+        internal static T GetComponent<T>(GameObject go)
+        {
+            var component = go.GetComponent<T>();
+
+            if (component == null)
+            {
+                AccessibilityUtils.LogFatalError($"AccessibleUnityUtils.GetComponent<T>({go.name}) was null");
+                return default;
+            }
+
+            return component;
+        }
+
+        internal static List<GameObject> GetChildren(GameObject go)
+        {
+            var ret = new List<GameObject>();
+
+            for (int i = 0; i < go.transform.childCount; i++)
+            {
+                ret.Add(go.transform.GetChild(i).gameObject);
+            }
+
+            return ret;
+        }
+
+        #endregion
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/AccessibleWidgetUtils.cs b/Assembly-CSharp/Accessibility/AccessibleWidgetUtils.cs
new file mode 100644
index 0000000..2189930
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/AccessibleWidgetUtils.cs
@@ -0,0 +1,164 @@
+﻿using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Text.RegularExpressions;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class AccessibleWidgetUtils
+    {
+        public static PegUIElement GetPegUIElement(GameObject go, string childObjectName)
+        {
+            if (go == null)
+			{
+                return null;
+			}
+
+            var childObject = AccessibleUnityUtils.GetChildObject(go, childObjectName);
+            if (childObject == null)
+            {
+                return null;
+            }
+
+            var ret = childObject.GetComponent<PegUIElement>();
+            if (ret == null)
+            {
+                AccessibilityUtils.LogFatalError($"GetPegUIElement({go.name}, {childObjectName}): object exists but doesn't have an attachedPegUIElement");
+            }
+
+            return ret;
+        }
+
+        public static PegUIElement GetPegUIElement(Widget widget, string childObjectName)
+        {
+            return GetPegUIElement(GetGameObject(widget), childObjectName);
+        }
+
+		public static GameObject GetChildObject(Widget widget, string childObjectName)
+		{
+            return AccessibleUnityUtils.GetChildObject(GetGameObject(widget), childObjectName);
+		}
+
+		public static WidgetInstance GetWidgetInstance(GameObject go, string childObjectName)
+        {
+            return AccessibleUnityUtils.GetChildObject(go, childObjectName).GetComponent<WidgetInstance>();
+        }
+
+        public static void ClickButton(PegUIElement button)
+        {
+            if (button == null)
+            {
+                AccessibilityUtils.LogFatalError("AccessibleWidgetUtils.ClickButton(null)");
+                return;
+            }
+
+            button.TriggerPress();
+            button.TriggerRelease();
+        }
+
+        public static void TriggerButtonClicked(Widget widget)
+        {
+            widget.TriggerEvent("BUTTON_CLICKED");
+        }
+
+        internal static UberText GetUberText(GameObject go, string childObjectName)
+        {
+            return AccessibleUnityUtils.GetChildObject(go, childObjectName).GetComponent<UberText>();
+        }
+
+        internal static UberText GetUberText(PegUIElement element, string childObjectName)
+        {
+            return GetUberText(element.gameObject, childObjectName);
+        }
+
+        internal static void DebugWidgetEventListener(string eventName)
+        {
+            AccessibilityUtils.LogDebug($"DebugWidgetEventListener({eventName})");
+            AccessibilityUtils.LogDebug(Environment.StackTrace);
+        }
+
+        public static void DebugWidget(string friendlyName, Widget widget)
+        {
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+
+            var widgetType = widget.GetType();
+
+            AccessibilityUtils.LogDebug($"Debugging widget: {friendlyName}");
+            AccessibilityUtils.LogDebug($"Widget type: {widgetType}");
+
+            if (widgetType == typeof(WidgetInstance))
+            {
+                DebugWidgetInstance(widget as WidgetInstance);
+            }
+            else if (widgetType == typeof(WidgetTemplate))
+            {
+                DebugWidgetTemplate(widget as WidgetTemplate);
+            }
+        }
+
+        private static void DebugWidgetInstance(WidgetInstance widget)
+        {
+            AccessibilityUtils.LogDebug($"m_prefabInstance: {widget.m_prefabInstance}");
+            AccessibilityUtils.LogDebug($"Widget: {widget.Widget}");
+            AccessibilityUtils.LogDebug($"m_prefabInstance.Instance: {widget.m_prefabInstance.Instance}");
+            AccessibilityUtils.LogDebug($"m_prefabInstance.Owner: {widget.m_prefabInstance.Owner}");
+            AccessibilityUtils.LogDebug($"m_prefabInstance.Prefab: {widget.m_prefabInstance.Prefab}");
+
+            DebugWidgetTemplate(widget.Widget);
+
+            AccessibilityUtils.DebugGameObject(GetGameObject(widget));
+        }
+
+        private static void DebugWidgetTemplate(WidgetTemplate widgetTemplate)
+        {
+            AccessibilityUtils.LogDebug("Debugging WidgetTemplate");
+            AccessibilityUtils.LogDebug($"name: {widgetTemplate.name}");
+
+            DebugDataContext(widgetTemplate.DataContext);
+
+            AccessibilityUtils.DebugGameObject(GetGameObject(widgetTemplate));
+        }
+
+        private static GameObject GetGameObject(Widget widget)
+		{
+            var widgetType = widget.GetType();
+
+            if (widgetType == typeof(WidgetInstance))
+            {
+                return (widget as WidgetInstance).m_prefabInstance.Instance;
+            }
+            else if (widgetType == typeof(WidgetTemplate))
+            {
+				return widget.gameObject;
+            }
+
+            AccessibilityUtils.LogFatalError($"AccessibleWidgetUtils.GetGameObject - Unknown widget type: {widgetType}");
+            return widget.gameObject;
+		}
+
+        private static void DebugDataContext(DataContext dataContext)
+        {
+            AccessibilityUtils.LogDebug($"Debugging DataContext");
+
+            var dataModels = dataContext.GetDataModels();
+
+            foreach(var dataModel in dataModels)
+            {
+                DebugDataModel(dataModel);
+            }
+        }
+
+        private static void DebugDataModel(IDataModel dataModel)
+        {
+            AccessibilityUtils.LogDebug("Debugging Data Model");
+            AccessibilityUtils.LogDebug($"DisplayName: {dataModel.DataModelDisplayName}");
+            AccessibilityUtils.LogDebug($"DataModelId: {dataModel.DataModelId}");
+            AccessibilityUtils.LogDebug($"Properties.Length: {dataModel.Properties.Length}");
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsCard.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsCard.cs
new file mode 100644
index 0000000..bf77060
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsCard.cs
@@ -0,0 +1,336 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsCard : AccessibleCard
+    {
+        internal AccessibleBattlegroundsCard(AccessibleComponent parent, Card card) : base(parent, card)
+        {
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_card.GetEntity().IsHero())
+            {
+                return GetLinesForHero();
+            }
+            else if (m_card.GetEntity().IsHeroPower())
+            {
+                return GetLinesForHeroPower();
+            }
+            else if (m_card.GetEntity().IsQuest())
+            {
+                return GetLinesForQuest();
+            }
+            else if (m_card.GetEntity().IsSecret())
+            {
+                if (m_card.GetEntity().IsControlledByFriendlySidePlayer())
+                {
+                    return GetLinesForSpell();
+                }
+                else
+                {
+                    return GetLinesForOpponentSecret();
+                }
+            }
+            else if (m_card.GetEntity().IsSpell() || m_card.GetEntity().GetCardType() == TAG_CARDTYPE.BATTLEGROUND_SPELL)
+            {
+                return GetLinesForSpell();
+            }
+            else if (m_card.GetEntity().IsBattlegroundQuestReward())
+            {
+                return GetLinesForBattlegroundsQuestReward();
+            }
+            else
+            {
+                return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForBuddyMeter()
+        {
+            var ret = new List<string>();
+
+            var heroCard = GameState.Get().GetFriendlySidePlayer().GetHero();
+
+            var progress = heroCard.GetTag(GAME_TAG.BACON_HERO_BUDDY_PROGRESS);
+            ret.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_BUDDY_METER, progress));
+
+            ret.AddRange(AccessibleCardUtils.GetHeroBuddyCardLinesForHeroCard(heroCard));
+
+            return ret;
+        }
+
+        private List<string> GetLinesForSpell()
+        {
+            // Recruitment Map -> Spell -> 3 gold -> description
+            // Note: Handles player secrets as well
+
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            if (!AccessibleCardUtils.IsCostHidden(m_card))
+            {
+                var cost = AccessibleCardUtils.GetCost(m_card);
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    cost += $" {effects}";
+                }
+                lines.Add(cost);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(GetCardType(), lines);
+            AccessibleCardUtils.AddLineIfExists(GetRace(), lines); // Handles spell school as well
+            lines.Add(GetTier());
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            // (Golden) Tarecgosa -> x atk x health -> description -> Dragon -> Tier 3 -> Minion (handles buddy as well if necessary)
+
+            var zone = m_card.GetEntity().GetZone();
+            var isInPlayZone = zone == TAG_ZONE.PLAY;
+
+            var lines = new List<string>();
+            lines.AddRange(GetHeaderWithRarity());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                if (isInPlayZone)
+                {
+                    var effects = GetEffects();
+                    if (effects.Length > 0)
+                    {
+                        resources = $"{resources} {effects}";
+                    }
+                }
+
+                lines.Add(resources);
+            }
+            else if (isInPlayZone)
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(GetRace(), lines); // Handles spell school as well
+
+            lines.Add(GetTier());
+
+            AccessibleCardUtils.AddLineIfExists(GetCardType(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            if (IsControlledByTavernBob())
+            {
+                return GetLinesForTavernBob();
+            }
+
+            return GetLinesForHeroInPlayZone();
+        }
+
+        private List<string> GetLinesForChooseHero()
+        {
+            var lines = new List<string>();
+
+            var entity = m_card.GetEntity();
+
+            lines.Add(entity.GetName());
+
+            var armor = entity.GetArmor();
+
+            if (armor > 0)
+            {
+                lines.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+            }
+
+            try
+            {
+                var cardId = entity.GetCardId();
+                lines.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(cardId));
+                if (GameState.Get().BattlegroundAllowBuddies())
+                {
+                    lines.AddRange(AccessibleCardUtils.GetHeroBuddyCardLinesForHeroCard(entity));
+                }
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroInPlayZone()
+        {
+            if (m_card.GetEntity().IsControlledByFriendlySidePlayer())
+            {
+                return GetLinesForPlayerHero();
+            }
+            else
+            {
+                return GetLinesForOpponentHero();
+            }
+        }
+
+        private List<string> GetLinesForOpponentHero()
+        {
+            // Opponent's Hero -> AFK -> Tier 3 -> x health -> <player name>
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            lines.Add(FormatTier(m_card.GetEntity().GetTag(GAME_TAG.PLAYER_TECH_LEVEL)));
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    resources = $"{resources} {effects}";
+                }
+
+                lines.Add(resources);
+            }
+            else
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            if (AccessibilityUtils.IsInPvPGame())
+            {
+                lines.Add(m_card.GetController().GetName());
+            }
+
+            return lines;
+        }
+
+        private List<string> GetLinesForPlayerHero()
+        {
+            // Your Hero -> Tier 3 -> x health -> AFK -> <player name>
+            var lines = new List<string>();
+            lines.AddRange(GetHeader());
+
+            lines.Add(GetControllerTier());
+
+            var resources = GetResources();
+            if (resources.Length > 0)
+            {
+                var effects = GetEffects();
+                if (effects.Length > 0)
+                {
+                    resources = $"{resources} {effects}";
+                }
+
+                lines.Add(resources);
+            }
+            else
+            {
+                AccessibleCardUtils.AddLineIfExists(GetEffects(), lines);
+            }
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            if (AccessibilityUtils.IsInPvPGame())
+            {
+                lines.Add(m_card.GetController().GetName());
+            }
+
+            return lines;
+        }
+
+        private List<string> GetLinesForTavernBob()
+        {
+            var lines = new List<string>();
+
+            lines.Add(GetFriendlySidePlayerTier());
+
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            return lines;
+        }
+
+        private string GetControllerTier()
+        {
+            return GetPlayerTier(m_card.GetController());
+        }
+
+        private string GetFriendlySidePlayerTier()
+        {
+            return GetPlayerTier(GameState.Get().GetFriendlySidePlayer());
+
+        }
+
+        private string GetPlayerTier(Player player)
+        {
+            return FormatTier(player.GetTag(GAME_TAG.PLAYER_TECH_LEVEL));
+        }
+
+        private string GetTier()
+        {
+            return FormatTier(m_card.GetEntity().GetTag(GAME_TAG.TECH_LEVEL));
+        }
+
+        private string FormatTier(int tier)
+        {
+            return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER, tier);
+        }
+
+        private bool IsControlledByTavernBob()
+        {
+            return AccessibleGameplayUtils.IsInBattlegroundsShopPhase() && !m_card.GetEntity().IsControlledByFriendlySidePlayer();
+        }
+
+        private List<string> GetHeaderWithRarity()
+        {
+            if (!m_card.GetEntity().IsMinion())
+            {
+                return GetHeader();
+            }
+
+            var ret = new List<string>();
+
+            ret.Add(AccessibleCardUtils.GetInGameCardNameWithPremium(m_card));
+
+            AddTrailingHeader(ret);
+
+            return ret;
+        }
+
+        // Used for quickly describing the opponent's board when combat phase starts
+        public string GetMinionSummary()
+        {
+            var name = AccessibleCardUtils.GetInGameCardNameWithPremium(m_card);
+
+            var effects = GetEffectsNotInEntityDef();
+            var resources = GetResources();
+
+            return $"{name} {resources} {effects}";
+        }
+
+        protected List<string> GetLinesForBattlegroundsQuestReward()
+        {
+            var lines = new List<string>();
+            lines.Add(m_card.GetEntity().GetEntityDef().GetName());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            return lines;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsChooseHeroCard.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsChooseHeroCard.cs
new file mode 100644
index 0000000..20d9067
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsChooseHeroCard.cs
@@ -0,0 +1,46 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsChooseHeroCard : AccessibleBattlegroundsCard
+    {
+		internal AccessibleBattlegroundsChooseHeroCard(AccessibleComponent parent, Card card) : base(parent, card)
+        {
+        }
+
+		internal override List<string> GetLines()
+		{
+            var ret = new List<string>();
+
+            var entity = m_card.GetEntity();
+
+            ret.Add(entity.GetName());
+
+            var armor = entity.GetArmor();
+
+            if (armor > 0)
+			{
+                ret.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+			}
+
+            try
+			{
+                var cardId = entity.GetCardId();
+                ret.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(cardId));
+                if (GameState.Get().BattlegroundAllowBuddies())
+                {
+                    ret.AddRange(AccessibleCardUtils.GetHeroBuddyCardLinesForHeroCard(entity));
+                }
+			}
+            catch (Exception e)
+			{
+                AccessibilityUtils.LogFatalError(e);
+			}
+
+            return ret;
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsGameplay.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsGameplay.cs
new file mode 100644
index 0000000..68f943a
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsGameplay.cs
@@ -0,0 +1,1611 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    // TODO: See all players list (start with mine inc. ranking)
+    // TODO: Chenvaala hero power meter
+
+    class AccessibleBattlegroundsGameplay : AccessibleGameplay
+    {
+        private bool m_refreshingTavern;
+
+        private bool m_freezingTavern;
+        private bool m_unfreezingTavern;
+
+        private bool m_tavernFrozen;
+
+        private bool m_upgradingTavern;
+
+        private bool m_movingMinion;
+        private bool m_movingMinionWaitingForHold; // Used to prevent "Sell?" while we wait for the minion to be held
+
+        private bool m_buyingCard;
+        private bool m_sellingMinion;
+
+        private bool m_isShopPhase;
+        private bool m_isCombatPhase;
+
+        private bool m_hasAnyPlayerWonThisPhase; // Used to output ties when no player won a combat phase
+
+        private bool m_wasShopPhasePopupShown; // Used for reconnects
+
+        private AccessibleInGameState m_lastDescribedState; // Used for storing the state of the board (i.e. Entity clones) at the start of a combat phase
+
+        private int m_numTeamsAlive; // Used for saying x players died at the start of recruit phase
+
+		internal override void OnBattlegroundsCombatPhasePopupShown()
+		{
+            ResetStateBetweenPhases();
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE));
+            StopReadingCard();
+		}
+
+		private void OnBattlegroundsCombatPhaseStart()
+		{
+            if (m_isCombatPhase)
+			{
+                // Kel'Thuzad would read twice as Bob transforms into the real Hero first and into Kel'Thuzad afterwards
+                return;
+			}
+
+            m_isCombatPhase = true;
+            m_hasAnyPlayerWonThisPhase = false;
+            m_lastDescribedState = AccessiblePowerTaskListDescriber.Get().GetLastDescribedState();
+
+			var opponent = GameState.Get().GetOpposingSidePlayer();
+
+			var opponentHero = opponent.GetHero();
+            var opponentTier = GetOpponentTavernTier(opponent);
+            var opponentHealth = GetOpponentHealth(opponent);
+            var opponentArmor = GetOpponentArmor(opponent);
+            var opponentBattlefield = opponent.GetBattlefieldZone();
+            var opponentMinions = opponentBattlefield.GetCards();
+            var numOpponentMinions = opponentBattlefield.GetCardCount();
+
+			var opponentHeroName = opponentHero.GetName();
+
+            if (IsOpponentDead(opponent))
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_AGAINST_DEAD_PLAYER,
+                    opponentHeroName
+				));
+			}
+            else if (opponentArmor > 0)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_INCLUDE_ARMOR,
+                    opponentTier, opponentHeroName, opponentHealth, numOpponentMinions, opponentArmor
+				));
+			}
+			else
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE,
+                    opponentTier, opponentHeroName, opponentHealth, numOpponentMinions
+			    ));
+			}
+
+            ReadOpponentMinions(opponentMinions);
+		}
+
+		private int GetOpponentHealth(Player opponent)
+		{
+            // Edge cases around Tutorial vs PVP
+
+            var nextOpponentTile = PlayerLeaderboardManager.Get().GetNextOpponentTile();
+
+            if (nextOpponentTile == null)
+			{
+                return opponent.GetHero().GetCurrentHealth();
+			}
+            else
+			{
+                return nextOpponentTile.m_playerHeroEntity.GetCurrentHealth();
+			}
+		}
+
+		private int GetOpponentArmor(Player opponent)
+		{
+            // Edge cases around Tutorial vs PVP
+
+            var nextOpponentTile = PlayerLeaderboardManager.Get().GetNextOpponentTile();
+
+            if (nextOpponentTile == null)
+			{
+                return opponent.GetHero().GetArmor();
+			}
+            else
+			{
+                return nextOpponentTile.m_playerHeroEntity.GetArmor();
+			}
+		}
+
+		private int GetOpponentTavernTier(Player opponent)
+		{
+            // Edge cases around Tutorial vs PVP
+
+            var nextOpponentTile = PlayerLeaderboardManager.Get().GetNextOpponentTile();
+
+            if (nextOpponentTile == null)
+			{
+                return opponent.GetHero().GetRealTimePlayerTechLevel();
+			}
+            else
+			{
+                return nextOpponentTile.m_playerHeroEntity.GetRealTimePlayerTechLevel();
+			}
+		}
+
+		private bool IsOpponentDead(Player opponent)
+		{
+            // Edge cases around Tutorial vs PVP
+
+            var nextOpponentTile = PlayerLeaderboardManager.Get().GetNextOpponentTile();
+
+            if (nextOpponentTile == null)
+			{
+                return opponent.GetHero().GetCurrentHealth() <= 0;
+			}
+            else
+			{
+                return nextOpponentTile.m_playerHeroEntity.GetCurrentHealth() <= 0;
+			}
+		}
+
+		private void ReadOpponentMinions(List<Card> opponentMinions)
+		{
+            var minionSummaries = new List<string>();
+
+			foreach (var card in opponentMinions)
+			{
+                var accessibleCard = new AccessibleBattlegroundsCard(this, card);
+
+                minionSummaries.Add(accessibleCard.GetMinionSummary());
+			}
+
+            AccessibilityMgr.Output(this, AccessibleSpeechUtils.HumanizeList(minionSummaries));
+		}
+
+		internal override void OnBattlegroundsShopPhasePopupShown()
+		{
+            m_isCombatPhase = false;
+            m_isShopPhase = false;
+            m_tavernFrozen = false;
+
+            // Prevent your opponent's hero became Bob speeches
+            AccessiblePowerTaskListDescriber.Get().OnBattlegroundsHeroAttackPhaseEnd();
+
+            if (!m_wasShopPhasePopupShown)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE));
+
+                var numTeamsAlive = AccessibleBattlegroundsLeaderboardMgr.Get().GetNumTeamsAlive();
+
+                if (numTeamsAlive < m_numTeamsAlive)
+				{
+                    var numTeamsDied = m_numTeamsAlive - numTeamsAlive;
+					AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_DIED, numTeamsDied));
+					AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_REMAINING, numTeamsAlive));
+				}
+
+                m_numTeamsAlive = numTeamsAlive;
+			}
+
+			m_wasShopPhasePopupShown = true;
+            StopReadingCard();
+		}
+
+		private void OnBattlegroundsShopPhaseStart()
+		{
+            m_isShopPhase = true;
+			var player = GameState.Get().GetFriendlySidePlayer();
+
+            if (player != null)
+			{
+                // Reconnects start before the player is set
+				var gold = player.GetNumAvailableResources();
+                var tavernTier = GetTavernTier(player);
+
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE_START_DESCRIBE, tavernTier, gold));
+			}
+
+            // Read Bob's minions
+			var bob = GameState.Get().GetOpposingSidePlayer();
+            var minionsForSale = bob.GetBattlefieldZone().GetCards();
+
+            if (minionsForSale.Count > 0)
+            {
+                var minionNames = new List<string>();
+
+                foreach (var minion in minionsForSale)
+				{
+                    minionNames.Add(AccessibleSpeechUtils.GetEntityName(minion.GetEntity()));
+				}
+
+                var newMinionsInShopMessage = AccessibleSpeechUtils.FormatZoneMovementText(minionNames,
+                    LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_TAVERN,
+                    LocalizationKey.BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_TAVERN
+				);
+
+                AccessibilityMgr.Output(this, newMinionsInShopMessage);
+            }
+		}
+
+        private void ResetState()
+		{
+            m_freezingTavern = false;
+            m_unfreezingTavern = false;
+            m_refreshingTavern = false;
+            m_upgradingTavern = false;
+            m_movingMinion = false;
+            m_movingMinionWaitingForHold = false;
+            m_buyingCard = false;
+            m_sellingMinion = false;
+		}
+
+		internal override void ReadPlayerResources()
+		{
+            var player = GameState.Get().GetFriendlySidePlayer();
+            int availableGold = player.GetNumAvailableResources();
+            int totalGold = player.GetTag(GAME_TAG.RESOURCES);
+
+            if (availableGold != totalGold)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_CURRENT_AND_TOTAL, availableGold, totalGold));
+            }
+            else
+            {
+                ReadAvailablePlayerResources();
+            }
+		}
+
+		private void ReadAvailablePlayerResources()
+		{
+            int curGold = GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources();
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD, curGold));
+		}
+
+		private void ReadRemainingPlayerResources()
+		{
+            int curGold = GameState.Get().GetFriendlySidePlayer().GetNumAvailableResources();
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_REMAINING_GOLD, curGold));
+		}
+
+		public override void HandleInput()
+        {
+            if (GameState.Get() == null || InputManager.Get() == null)
+            {
+                // Game hasn't even started yet
+                return;
+            }
+
+            if (GameState.Get().IsMulliganPhase())
+			{
+                m_curPhase = AccessibleGamePhase.MULLIGAN;
+			}
+            else if (GameState.Get().IsGameOver())
+            {
+                m_curPhase = AccessibleGamePhase.GAME_OVER;
+            }
+            else if (GameState.Get().IsGameCreated())
+            {
+                m_curPhase = AccessibleGamePhase.PLAYING;
+            }
+            else
+            {
+                m_curPhase = AccessibleGamePhase.WAITING_FOR_GAME_TO_START;
+            }
+
+            if (AccessibleKey.READ_TOOLTIP.IsPressed())
+            {
+                HandleTooltipReading();
+            }
+
+            if (m_curPhase == AccessibleGamePhase.PLAYING)
+			{
+                HandleInGameInput();
+			}
+            else if (m_curPhase == AccessibleGamePhase.MULLIGAN)
+			{
+                HandleChooseHeroInput();
+			}
+        }
+
+        private void HandleInGameInput()
+        {
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+
+                if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+				{
+                    OnBattlegroundsShopPhaseStart();
+				}
+                else if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+				{
+                    OnBattlegroundsCombatPhaseStart();
+				}
+
+                GameState.Get().RegisterGameOverListener(OnGameOver);
+                AccessiblePowerTaskListDescriber.Get().OnReconnected();
+            }
+
+            UpdateState();
+
+            try
+            {
+                UpdateMousePosition();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+                HandleShopPhaseInput();
+			}
+            else if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                HandleCombatPhaseInput();
+			}
+        }
+
+		private void UpdateMousePosition()
+		{
+            if (m_heldCard != null)
+            {
+                return;
+            }
+
+            if (m_cardBeingRead != null)
+            {
+                MoveMouseToCard(m_cardBeingRead.GetCard());
+            }
+
+            // Note: We can't hide the mouse ever or refreshes etc will stop working
+		}
+
+		private void HandleShopPhaseInput()
+		{
+            HandleGeneralShopPhaseInput();
+
+            // Handle virtual queries first so we can smoothly click a different key to cancel by reading something else simultaneously
+            if (m_upgradingTavern && HandleUpgradingTavern())
+			{
+                return;
+			}
+            else if (m_freezingTavern && HandleFreezingTavern())
+			{
+                return;
+			}
+            else if (m_unfreezingTavern && HandleUnfreezingTavern())
+			{
+                return;
+			}
+            else if (m_refreshingTavern && HandleRefreshTavern())
+			{
+                return;
+			}
+
+            switch(m_curState)
+            {
+                case AccessibleGameState.MAIN_OPTION_MODE:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleMainOptionMode();
+                    return;
+                case AccessibleGameState.SUB_OPTION_MODE:
+                    HandleCheckStatusKeys();
+                    HandleSubOptionMode();
+                    return;
+                case AccessibleGameState.CHOICE_MODE:
+                    HandleCheckStatusKeys();
+                    HandleChoiceMode();
+                    return;
+                                        case AccessibleGameState.CHOICE_MODE_CHOICES_HIDDEN:
+                    HandleCheckStatusKeys();
+                    HandleZoneSelection();
+                    HandleZoneInput();
+                    HandleCardReadingInput();
+                    if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+                    {
+                        ChoiceCardMgr.Get().GetToggleButton().TriggerRelease();
+                    }
+                    return;
+                case AccessibleGameState.TARGET_MODE:
+                    HandleCheckStatusKeys();
+                    HandleTargetMode();
+                    return;
+                case AccessibleGameState.SUMMONING_MINION:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandleSummoningMinion();
+                    // TODO: Check base file to see what this is HandleTradeCardWhenHoldingCardInput();
+                    return;
+                case AccessibleGameState.BUYING_CARD:
+                    HandleCheckStatusKeys();
+                    HandleBuyingCard();
+                    return;
+                case AccessibleGameState.SELLING_MINION:
+                    HandleCheckStatusKeys();
+                    HandleSellingMinion();
+                    return;
+                case AccessibleGameState.MOVING_MINION:
+                    HandleCheckStatusKeys();
+                    HandleMovingMinion();
+                    return;
+                case AccessibleGameState.PLAYING_CARD:
+                    HandleCardReadingInput();
+                    HandleCheckStatusKeys();
+                    HandlePlayingCard();
+                    return;
+                case AccessibleGameState.READING_LEADERBOARD:
+                    HandleReadLeaderboardInput();
+                    return;
+                default:
+                    return;
+            }
+		}
+
+        protected override void HandleCheckStatusKeys()
+        {
+            base.HandleCheckStatusKeys();
+
+            if (AccessibleKey.BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS.IsPressed())
+            {
+                AccessibleBattlegroundsLeaderboardMgr.Get().ReadNextOpponent();
+            }
+            else if (AccessibleKey.BATTLEGROUNDS_READ_MY_STATS.IsPressed())
+			{
+                AccessibleBattlegroundsLeaderboardMgr.Get().ReadMyself();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS_TO_END.IsPressed())
+            {
+                AccessibleBattlegroundsLeaderboardMgr.Get().ReadNextOpponentToEnd();
+            }
+            else if (AccessibleKey.BATTLEGROUNDS_READ_MY_STATS_TO_END.IsPressed())
+			{
+                AccessibleBattlegroundsLeaderboardMgr.Get().ReadMyselfToEnd();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_LEADERBOARD.IsPressed())
+			{
+                AccessibleBattlegroundsLeaderboardMgr.Get().StartReadingLeaderboard();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_RACES_IN_GAME.IsPressed())
+			{
+                ReadRacesAndAnomaly();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_HERO_BUDDY.IsPressed())
+			{
+                ReadHeroBuddy();
+			}
+        }
+
+		internal AccessibleInGameState GetStateAtStartOfCombat()
+		{
+            return m_lastDescribedState;
+		}
+
+		private void ReadHeroBuddy()
+		{
+            if (!GameState.Get().BattlegroundAllowBuddies())
+            {
+                return;
+            }
+            var heroBuddyCard = TB_BaconShop.GetHeroBuddyCard(Player.Side.FRIENDLY);
+
+            if (heroBuddyCard == null)
+			{
+                return;
+			}
+
+            m_cardBeingRead = new AccessibleBattlegroundsHeroBuddyCard(this, heroBuddyCard);
+            m_curZone = heroBuddyCard.GetZone();
+            m_cardBeingRead.ReadLine();
+		}
+
+		private void ReadRacesAndAnomaly()
+		{
+            var racesInGame = TB_BaconShop.GetAvailableRacesText();
+            if (racesInGame != null)   AccessibilityMgr.Output(this, racesInGame);
+            var anomalyText = GetAnomalyText();
+            if (anomalyText != null)   AccessibilityMgr.Output(this, anomalyText);
+		}
+
+        private string GetAnomalyText()
+        {
+            var anomalyId = GameState.Get().GetGameEntity().GetAnomalyId();
+            if (anomalyId == 0)
+            {
+                return null;
+            }
+
+            if (GameState.Get().IsMulliganManagerActive())
+            {
+                return AccessibleCardUtils.GetAnomalyText(anomalyId);
+            }
+
+            var anomalyCard = ZoneMgr.Get().FindZoneOfType<ZoneBattlegroundAnomaly>(Player.Side.NEUTRAL)?.GetFirstCard();
+            if (anomalyCard == null)
+            {
+                return null;
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_ANOMALY, anomalyCard.GetEntity().GetName(), anomalyCard.GetEntity().GetCardTextInHand());
+        }
+
+		private void HandleGeneralShopPhaseInput()
+		{
+            if (AccessibleKey.END_TURN.IsPressed())
+			{
+                var secondsRemaining = TurnTimer.Get().GetSecondsRemaining();
+
+                if (secondsRemaining > 0)
+				{
+					AccessibilityUtils.OutputSecondsRemaining(secondsRemaining);
+				}
+			}
+		}
+
+		private void HandleBuyingCard()
+		{
+            AccessibleInputMgr.MoveMouseTo(GameState.Get().GetFriendlySidePlayer().GetHeroCard());
+
+            HandleForcedConfirmOrCancel(ConfirmActionByClicking, CancelActionWithHeldCard);
+		}
+
+		private void HandleSellingMinion()
+		{
+            AccessibleInputMgr.MoveMouseTo(GameState.Get().GetOpposingSidePlayer().GetHeroCard());
+
+            HandleForcedConfirmOrCancel(ConfirmActionByClicking, CancelActionWithHeldCard);
+		}
+
+		private bool HandleFreezingTavern()
+		{
+            return HandleSmoothConfirmOrCancel(ForceFreezeOrUnfreezeTavern, ResetState, AccessibleKey.FREEZE_TAVERN);
+		}
+
+		private bool HandleUnfreezingTavern()
+		{
+            return HandleSmoothConfirmOrCancel(ForceFreezeOrUnfreezeTavern, ResetState, AccessibleKey.FREEZE_TAVERN);
+		}
+
+		private bool HandleUpgradingTavern()
+		{
+            return HandleSmoothConfirmOrCancel(ForceUpgradeTavern, ResetState, AccessibleKey.UPGRADE_TAVERN);
+		}
+
+		internal bool IsInShopPhase()
+		{
+            return m_isShopPhase;
+		}
+
+		internal bool IsInCombatPhase()
+		{
+            return m_isCombatPhase;
+		}
+
+		private bool HandleRefreshTavern()
+		{
+			return HandleSmoothConfirmOrCancel(ForceRefreshTavern, ResetState, AccessibleKey.REFRESH_TAVERN);
+		}
+
+		private bool HandleReadLeaderboardInput()
+		{
+            return AccessibleBattlegroundsLeaderboardMgr.Get().HandleAccessibleInput();
+		}
+
+        private void ConfirmActionByClicking()
+		{
+			ResetState();
+			AccessibleInputMgr.ClickLeftMouseButton();
+		}
+
+        private void CancelActionWithHeldCard()
+		{
+            ResetState();
+            AccessibleInputMgr.ClickRightMouseButton();
+		}
+
+		private void HandleForcedConfirmOrCancel(Action confirmAction, Action cancelAction, bool includeSpaceAsWell=false)
+        {
+            if (AccessibleKey.CONFIRM.IsPressed() ||
+                (includeSpaceAsWell && AccessibleKey.SPACE.IsPressed()))
+            {
+                confirmAction();
+			}
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+                cancelAction();
+            }
+        }
+
+		private bool HandleSmoothConfirmOrCancel(Action confirmAction, Action cancelAction, AccessibleKey originalKey)
+        {
+            // Note: OriginalKey is used to make it so e.g. pressing U twice forces a tavern upgrade the same way that U+Enter would as players
+            // are used to this due to the end turn behaviour
+            if (AccessibleKey.CONFIRM.IsPressed() || originalKey.IsPressed())
+            {
+                confirmAction();
+                return true;
+			}
+			else if (Input.anyKeyDown)
+            {
+                cancelAction();
+            }
+
+            return false;
+        }
+
+		private void HandleCombatPhaseInput()
+		{
+			HandleCardReadingInput();
+			HandleCheckStatusKeys();
+			HandleZoneInput();
+			HandleValidOptionsSelectionInput();
+			HandleZoneSelection();
+		}
+
+		private void UpdateState()
+		{
+            try
+            {
+                UpdateCardBeingReadState();
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                StopReadingCard();
+            }
+
+            m_heldCard = InputManager.Get().GetHeldCard();
+            m_playerTurn = GameState.Get().IsFriendlySidePlayerTurn();
+
+            ResetChoiceCardsIfNecessary();
+            ReadStateAfterClosingLeaderboardIfNecessary();
+
+            if (m_heldCard == null)
+            {
+                m_movingMinion = false;
+            }
+            else if (m_movingMinionWaitingForHold)
+			{
+                m_movingMinionWaitingForHold = false;
+                m_movingMinion = true;
+			}
+
+            m_prevState = m_curState;
+            m_prevResponseMode = m_curResponseMode;
+            m_curResponseMode = GameState.Get().GetResponseMode();
+
+            // Proper states
+            if (!m_playerTurn)
+            {
+                m_curState = AccessibleGameState.WAITING;
+            }
+            else if (AccessibleBattlegroundsLeaderboardMgr.Get().IsReadingLeaderboard())
+            {
+                m_curState = AccessibleGameState.READING_LEADERBOARD;
+            }
+            else if (m_heldCard != null)
+            {
+                if (m_heldCard.GetEntity().GetCardType() == TAG_CARDTYPE.BATTLEGROUND_SPELL && m_heldCard.GetEntity().GetZone() == TAG_ZONE.PLAY && m_heldCard.GetEntity().IsControlledByOpposingSidePlayer())
+                {
+                    m_curState = AccessibleGameState.BUYING_CARD;
+                    if (m_curState != m_prevState)
+                    {
+                        var spellName = AccessibleSpeechUtils.GetEntityName(m_heldCard.GetEntity());
+                        AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_BUY_MINION, spellName));
+                    }
+                }
+                else if (m_heldCard.GetEntity().IsMinion())
+                {
+                    var entity = m_heldCard.GetEntity();
+                    var zone = entity.GetZone();
+
+                    if (zone == TAG_ZONE.PLAY)
+					{
+                        if (entity.IsControlledByFriendlySidePlayer() && m_movingMinion)
+						{
+                            m_curState = AccessibleGameState.MOVING_MINION;
+						}
+                        else if (entity.IsControlledByFriendlySidePlayer() && m_sellingMinion)
+						{
+							m_curState = AccessibleGameState.SELLING_MINION;
+
+                            if (m_curState != m_prevState)
+							{
+                                var minionName = AccessibleSpeechUtils.GetEntityName(entity);
+								AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_SELL_MINION, minionName));
+							}
+						}
+                        else if (m_buyingCard)
+						{
+							m_curState = AccessibleGameState.BUYING_CARD;
+
+                            if (m_curState != m_prevState)
+							{
+                                var minionName = AccessibleSpeechUtils.GetEntityName(entity);
+								AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_BUY_MINION, minionName));
+							}
+						}
+					}
+                    else
+					{
+						m_curState = AccessibleGameState.SUMMONING_MINION;
+					}
+                }
+                else if (GameState.Get().IsInMainOptionMode())
+                {
+                    m_curState = AccessibleGameState.PLAYING_CARD;
+                }
+            }
+            else if (GameState.Get().IsInMainOptionMode())
+            {
+				m_curState = AccessibleGameState.MAIN_OPTION_MODE;
+			}
+			else if (GameState.Get().IsInSubOptionMode())
+            {
+                m_curState = AccessibleGameState.SUB_OPTION_MODE;
+            }
+            else if (GameState.Get().IsInChoiceMode())
+            {
+                if (IsTargetChoice() || ChoiceCardMgr.Get().IsShowingFriendlyCards())
+                {
+                    m_curState = AccessibleGameState.CHOICE_MODE;
+                }
+                else
+                {
+                    m_curState = AccessibleGameState.CHOICE_MODE_CHOICES_HIDDEN;
+                }
+            }
+            else if (GameState.Get().IsInTargetMode())
+            {
+                m_curState = AccessibleGameState.TARGET_MODE;
+            }
+            else
+            {
+                // Normally happens in between turns (i.e. after button press but before response) due to network time
+                m_curState = AccessibleGameState.UNKNOWN;
+            }
+		}
+
+		private void ReadStateAfterClosingLeaderboardIfNecessary()
+		{
+            if (m_prevState == m_curState || m_prevState != AccessibleGameState.READING_LEADERBOARD)
+			{
+                return;
+			}
+
+            if (m_cardBeingRead != null)
+			{
+                // Reread zone regardless
+                var card = m_cardBeingRead.GetCard();
+				ReadZoneChangeIfNecessary(card, null, card.GetZone(), true);
+				m_cardBeingRead.Reset();
+                var speech = m_cardBeingRead.GetLine(0);
+
+				if (ShouldReadCardAsList(card))
+				{
+					var zonePos = card.GetZone().FindCardPos(card); // card.GetZonePosition() isn't trustworthy. Wasn't working for secrets
+					AccessibilityMgr.Output(this, AccessibleSpeech.MENU_OPTION(speech, zonePos, card.GetZone().GetCardCount()));
+				}
+                else
+				{
+                    AccessibilityMgr.Output(this, speech);
+				}
+			}
+		}
+
+		private void OnCombatPhaseCombatEnded()
+		{
+            if (m_hasAnyPlayerWonThisPhase)
+			{
+                // Heroes gain atk twice (one for tavern tier and one for all minions)
+                return;
+			}
+
+			m_hasAnyPlayerWonThisPhase = true;
+
+			var numPlayerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetCardCount();
+            var numOpponentMinions = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone().GetCardCount();
+
+            if (numPlayerMinions > numOpponentMinions)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_PLAYER_WON, numPlayerMinions));
+			}
+            else if (numOpponentMinions > numPlayerMinions)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_OPPONENT_WON, numOpponentMinions));
+			}
+
+            // Note: ties are narrated in OnMainStepEnd as we have no proper way of knowing before then i.e. OnCombatPhaseCombatEnded is not invoked if no Hero launches
+            // an attack
+		}
+
+		protected override void ReadOpponentZoneName()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_ZONE_MINIONS_FOR_SALE));
+			}
+			else
+			{
+                base.ReadOpponentZoneName();
+			}
+		}
+
+		protected override void ReadOpponentMinionsEmpty()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsShopPhase())
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_SEE_ZONE_MINIONS_FOR_SALE_EMPTY));
+			}
+            else
+			{
+                base.ReadOpponentMinionsEmpty();
+			}
+		}
+
+        protected override void SeePlayerWeapon()
+        {
+            var bgQuestReward = GameState.Get().GetFriendlySidePlayer().GetQuestRewardCard();
+
+            if (bgQuestReward != null)
+			{
+                FocusOnCard(bgQuestReward, false);
+			}
+
+            // TODO: Buddy meter
+        }
+
+        protected override void SeeOpponentWeapon()
+        {
+            var bgQuestReward = GameState.Get().GetOpposingSidePlayer().GetQuestRewardCard();
+
+            if (bgQuestReward != null)
+			{
+                FocusOnCard(bgQuestReward, false);
+			}
+
+            // TODO: Buddy meter
+        }
+
+        private void HandleMainOptionMode()
+        {
+            HandleZoneInput();
+            HandleValidOptionsSelectionInput();
+            HandleZoneSelection();
+
+            if (AccessibleKey.FREEZE_TAVERN.IsPressed())
+			{
+                QueryFreezeOrUnfreezeTavern();
+			}
+            else if (AccessibleKey.FORCE_FREEZE_TAVERN.IsPressed())
+			{
+                ForceFreezeOrUnfreezeTavern();
+			}
+            else if (AccessibleKey.UPGRADE_TAVERN.IsPressed())
+			{
+                QueryUpgradeTavern();
+			}
+            else if (AccessibleKey.FORCE_UPGRADE_TAVERN.IsPressed())
+			{
+                ForceUpgradeTavern();
+			}
+            else if (AccessibleKey.REFRESH_TAVERN.IsPressed())
+			{
+                QueryRefreshTavern();
+			}
+            else if (AccessibleKey.FORCE_REFRESH_TAVERN.IsPressed())
+			{
+                ForceRefreshTavern();
+			}
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                ClickCard();
+            }
+            else if (AccessibleKey.SPACE.IsPressed())
+			{
+                ClickCardForMoving();
+			}
+        }
+
+        private void ClickCard()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+			ResetState();
+
+            var entity = m_cardBeingRead.GetCard().GetEntity();
+
+            if (entity.GetZone() == TAG_ZONE.PLAY)
+			{
+				if (entity.IsControlledByFriendlySidePlayer())
+				{
+					m_sellingMinion = true;
+				}
+                else
+				{
+					m_buyingCard = true;
+				}
+			}
+
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+		private void ClickButtonCard(Card card)
+		{
+            StopReadingCard();
+            AccessibleInputMgr.Click(card);
+		}
+
+        private void ClickCardForMoving()
+        {
+            if (m_cardBeingRead == null)
+            {
+                return;
+            }
+
+			var card = m_cardBeingRead.GetCard();
+
+            var playerBattlefield = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+            if (card.GetZone() != playerBattlefield || playerBattlefield.GetCardCount() <= 1)
+			{
+                return;
+			}
+
+			ResetState();
+
+            m_movingMinionWaitingForHold = true;
+
+            AccessibleInputMgr.ClickLeftMouseButton();
+        }
+
+		private void QueryRefreshTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var refreshButtonCard = GetGameState().GetRefreshButtonCard();
+
+            if (!refreshButtonCard.IsInputEnabled())
+            {
+                return;
+            }
+
+            m_refreshingTavern = true;
+            var refreshCost = refreshButtonCard.GetEntity().GetCost();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_REFRESH_TAVERN_FOR_N_GOLD, refreshCost));
+		}
+
+		private void ForceRefreshTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var refreshButtonCard = GetGameState().GetRefreshButtonCard();
+            ClickButtonCard(refreshButtonCard);
+		}
+
+		private void QueryFreezeOrUnfreezeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            if (IsTavernFrozen())
+			{
+                QueryUnfreezeTavern();
+			}
+            else
+			{
+                QueryFreezeTavern();
+			}
+		}
+
+		private bool IsTavernFrozen()
+		{
+            return m_tavernFrozen;
+		}
+
+		private void ForceFreezeOrUnfreezeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var freezeButton = GetGameState().GetFreezeButtonCard();
+
+            ClickButtonCard(freezeButton);
+		}
+
+		private void QueryUnfreezeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var freezeButtonCard = GetGameState().GetFreezeButtonCard();
+
+            if (!freezeButtonCard.IsInputEnabled())
+            {
+                return;
+            }
+
+            m_unfreezingTavern = true;
+
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_UNFREEZE_TAVERN));
+		}
+
+		private void QueryFreezeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var freezeButtonCard = GetGameState().GetFreezeButtonCard();
+
+            if (!freezeButtonCard.IsInputEnabled())
+            {
+                return;
+            }
+
+            m_freezingTavern = true;
+            var freezeCost = freezeButtonCard.GetEntity().GetCost();
+
+            if (freezeCost == 0)
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN));
+			}
+            else
+			{
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN_FOR_N_GOLD, freezeCost));
+			}
+		}
+
+		private void QueryUpgradeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var upgradeButtonCard = GetGameState().GetTavernUpgradeButtonCard();
+
+            if (!upgradeButtonCard.IsInputEnabled())
+            {
+                return;
+            }
+
+            m_upgradingTavern = true;
+            var upgradeCost = upgradeButtonCard.GetEntity().GetCost();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_UPGRADE_TAVERN_FOR_N_GOLD, upgradeCost));
+		}
+
+		private void ForceUpgradeTavern()
+		{
+            ResetState();
+            StopReadingCard();
+
+            var upgradeButtonCard = GetGameState().GetTavernUpgradeButtonCard();
+            ClickButtonCard(upgradeButtonCard);
+		}
+
+		private TB_BaconShop GetGameState()
+		{
+            return GameState.Get().GetGameEntity() as TB_BaconShop;
+		}
+
+		protected override void Reset()
+		{
+            base.Reset();
+
+            ResetState();
+		}
+
+		protected override bool IsSeeOpponentHeroPressed()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+				return AccessibleKey.SEE_OPPONENT_HERO.IsPressed();
+			}
+            else
+			{
+                return AccessibleKey.SEE_TAVERN.IsPressed();
+			}
+		}
+
+		protected override bool IsSeePlayerHeroPowerPressed()
+		{
+            return AccessibleKey.BATTLEGROUNDS_SEE_PLAYER_HERO_POWER.IsPressed();
+		}
+
+		protected override bool IsSeeOpponentHeroPowerPressed()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                return AccessibleKey.BATTLEGROUNDS_SEE_OPPONENT_HERO_POWER.IsPressed();
+			}
+
+            // No-op in shop phase
+            return false;
+		}
+
+		internal override void OnFreezeOrUnfreezeEvent()
+		{
+            // TODO: Figure out a better way of handling this
+            m_tavernFrozen = !m_tavernFrozen;
+		}
+
+        #region Moving Minions
+
+        private int m_movePos;
+
+        private void HandleMovingMinion()
+        {
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+
+			// TODO: Disable key if only 1 minion -> don't allow shortcuts either
+
+			if (m_prevState != AccessibleGameState.MOVING_MINION)
+			{
+                m_movePos = 0;
+                var startPos = m_heldCard.GetZonePosition();
+				QueryMovingPosition(startPos);
+			}
+
+			HandleMovingPositionInput();
+
+			if (m_movePos == playerMinions.GetLastPos())
+			{
+				MoveMouseToRightOfZone(playerMinions);
+			}
+			else if (m_movePos == 1)
+			{
+				MoveMouseToLeftOfZone(playerMinions);
+			}
+			else
+			{
+				var prevMinion = playerMinions.GetCardAtSlot(m_movePos - 1);
+				var nextMinion = playerMinions.GetCardAtSlot(m_movePos);
+				var pos = prevMinion.transform.position + (nextMinion.transform.position - prevMinion.transform.position) / 2;
+				AccessibleInputMgr.MoveMouseToWorldPosition(pos);
+			}
+
+			HandleForcedConfirmOrCancel(ConfirmActionByClicking, CancelActionWithHeldCard, true);
+        }
+
+        private void HandleMovingPositionInput()
+        {
+            if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+            {
+                QueryMovingPosition(-1);
+            }
+            else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+            {
+                QueryMovingPosition(1);
+            }
+            else if (AccessibleKey.READ_FIRST_ITEM.IsPressed())
+			{
+                m_movePos = 1;
+                QueryMovingPosition(0);
+			}
+            else if (AccessibleKey.READ_LAST_ITEM.IsPressed())
+			{
+				var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+				var lastPos = playerMinions.GetLastPos();
+                m_movePos = lastPos;
+                QueryMovingPosition(0);
+			}
+            else
+			{
+				int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+                if (numKeyPressed.HasValue)
+				{
+					var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+					var lastPos = playerMinions.GetLastPos();
+
+                    m_movePos = Math.Min(lastPos, numKeyPressed.Value);
+                    QueryMovingPosition(0);
+				}
+			}
+		}
+
+        private void QueryMovingPosition(int inc)
+        {
+            var prevMovePos = m_movePos;
+            var playerMinions = GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone();
+            var lastPos = playerMinions.GetLastPos();
+
+            m_movePos += inc;
+
+            if (m_movePos > lastPos)
+            {
+                m_movePos = lastPos;
+            }
+            else if (m_movePos < 1)
+            {
+                m_movePos = 1;
+            }
+
+            if (inc != 0 && prevMovePos == m_movePos)
+            {
+                return;
+            }
+
+            if (m_movePos == lastPos)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_LAST_POSITION));
+            }
+            else if (m_movePos == 1)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_FIRST_POSITION));
+            }
+            else
+            {
+                var prevMinion = playerMinions.GetCardAtSlot(m_movePos - 1);
+                var nextMinion = playerMinions.GetCardAtSlot(m_movePos);
+                var prevMinionName = GetPreferredCardName(prevMinion);
+                var nextMinionName = GetPreferredCardName(nextMinion);
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_BETWEEN, prevMinionName, nextMinionName));
+            }
+        }
+        #endregion
+
+        protected override string GetPreferredCardName(Card card)
+		{
+            return AccessibleCardUtils.GetInGameCardNameWithPremium(card);
+		}
+
+        protected override void MoveMouseToCard(Card card)
+        {
+            if (card.GetZone()?.GetType() == typeof(ZoneHand))
+            {
+				// Note: Unlike in a game of traditional Hearthstone, we can't trust mousedOver as when Bob is speaking or highlighting certain
+				// buttons (e.g. in the tutorial) the cards will have their input disabled which messes with mouse over state
+				// Bit of a mess but not a whole lot we can do about it
+				if (!IsMousedOver(card))
+                {
+                    // Note: All of this code was added to trace a rare edge case some players have fallen into with cards such as shadowstep.
+                    // I haven't been able to reproduce so far but I think the bug has something to do with a NPE somewhere in the actor/manaObject chain
+                    // TODO: Clean all of this up once the bug is detected/fixed
+                    try
+					{
+                        var mousedOverCard = GetMousedOverCardRegardlessOfInput();
+
+                        if (mousedOverCard != null && mousedOverCard.GetZone() is ZonePlay)
+						{
+                            // In Battlegrounds, lists of effects can get large enough to the point that it covers cards in hand so we need to hide the tooltip
+                            // or we won't be able to hover the card in hand
+                            mousedOverCard.HideTooltip();
+						}
+
+						AccessibleInputMgr.MoveMouseTo(card.GetActor().m_manaObject.transform);
+					}
+					catch (Exception e)
+					{
+                        AccessibilityUtils.LogFatalError(e);
+                        AccessibilityUtils.LogFatalError($"card.GetActor(): {card.GetActor()}");
+                        AccessibilityUtils.LogFatalError($"card.GetActor()?.m_manaObject: {card.GetActor()?.m_manaObject}");
+                        AccessibilityUtils.LogFatalError($"card.GetActor()?.m_manaObject?.transform: {card.GetActor()?.m_manaObject?.transform}");
+                        AccessibilityUtils.LogFatalError($"card.GetEntity()?.GetCardId(): {card.GetEntity()?.GetCardId()}");
+
+                        if (card.GetActor() != null)
+						{
+                            if (card.GetActor().m_attackObject?.transform != null) AccessibleInputMgr.MoveMouseTo(card.GetActor().m_attackObject.transform);
+                            else if (card.GetActor().m_healthObject?.transform != null) AccessibleInputMgr.MoveMouseTo(card.GetActor().m_healthObject.transform);
+                            else AccessibilityUtils.LogFatalError("Unable to recover - Aborting MoveMouseToCard");
+						}
+                    }
+				}
+            }
+            else
+            {
+                AccessibleInputMgr.MoveMouseTo(card);
+            }
+        }
+
+		private bool IsMousedOver(Card card)
+		{
+            return GetMousedOverCardRegardlessOfInput() == card;
+		}
+
+        private Card GetMousedOverCardRegardlessOfInput()
+		{
+            return InputManager.Get().m_mousedOverCardRegardlessOfInput;
+		}
+
+		private int GetTavernTier(Player player)
+		{
+            return player.GetTag(GAME_TAG.PLAYER_TECH_LEVEL);
+		}
+
+		private int GetHeroTavernTier(Entity hero)
+		{
+            // Opponent sets this in Hero
+            return hero.GetTag(GAME_TAG.PLAYER_TECH_LEVEL);
+		}
+
+		internal override void OnOpponentHeroChanged()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+				OnBattlegroundsCombatPhaseStart();
+			}
+		}
+
+		internal override void OnAnyHeroGainedAtk()
+		{
+            if (AccessibleGameplayUtils.IsInBattlegroundsCombatPhase())
+			{
+                OnCombatPhaseCombatEnded();
+			}
+		}
+
+		internal override void OnPlayerAvailableResourcesChanged(int before, int after)
+		{
+            if (m_isShopPhase)
+			{
+                if (after > before)
+				{
+					ReadAvailablePlayerResources();
+				}
+                else
+				{
+					ReadRemainingPlayerResources();
+				}
+			}
+		}
+
+		private void ResetStateBetweenPhases()
+		{
+            m_wasShopPhasePopupShown = false;
+            m_isShopPhase = false;
+            m_isCombatPhase = false;
+            AccessibleBattlegroundsLeaderboardMgr.Get().StopReadingLeaderboard();
+		}
+
+		internal override void OnFirstTaskListStart()
+		{
+            OnBattlegroundsShopPhasePopupShown(); // Not really shown for reconnects, but..
+		}
+
+		internal override void OnMainActionStep()
+		{
+            // We're guaranteed to have gold etc. refreshed when MAIN_ACTION starts
+            if (!m_isShopPhase && m_wasShopPhasePopupShown)
+			{
+                OnBattlegroundsShopPhaseStart();
+			}
+		}
+
+		internal override void OnMainStepEnd()
+		{
+            if (m_isCombatPhase)
+			{
+                if (!m_hasAnyPlayerWonThisPhase)
+				{
+					AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GAMEPLAY_GAME_OVER_TIED));
+				}
+			}
+
+            m_isCombatPhase = false;
+		}
+
+        #region Mulligan i.e. Choose Hero
+
+        private bool m_confirmingHero;
+
+        private bool m_waitingForOpponentsToChooseHero;
+
+        private string m_prevWaitingText; // Used for reading x players ready whenever a new player becomes ready
+
+		private void HandleChooseHeroInput()
+        {
+            if (m_accessibleMulliganCards == null)
+            {
+                return; // yield
+            }
+
+            if (m_justReconnected)
+            {
+                m_justReconnected = false;
+            }
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                if (m_waitingForOpponentsToChooseHero)
+				{
+                    ReadNumberOfReadyPlayers(true);
+				}
+                else if (m_confirmingHero)
+                {
+                    MulliganManager.Get().OnMulliganButtonReleased(null);
+                }
+                else
+                {
+                    var focusedCard = m_accessibleMulliganCards.GetItemBeingRead();
+                    AccessibleInputMgr.MoveMouseTo(focusedCard.GetCard());
+                    AccessibleInputMgr.ClickLeftMouseButton();
+
+                    m_confirmingHero = true;
+                    AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PRESS_ENTER_TO_CONFIRM_OR_BACKSPACE_TO_CANCEL);
+                }
+            }
+            else if (AccessibleKey.BACK.IsPressed() && m_confirmingHero)
+			{
+                m_confirmingHero = false;
+                m_accessibleMulliganCards.StartReading();
+			}
+            else if (AccessibleKey.BATTLEGROUNDS_READ_RACES_IN_GAME.IsPressed())
+			{
+                ReadRacesAndAnomaly();
+			}
+            else if (AccessibleKey.END_TURN.IsPressed())
+			{
+                MulliganManager.Get().m_mulliganTimer?.OutputSecondsRemaining();
+			}
+            else if (!m_confirmingHero && !m_waitingForOpponentsToChooseHero)
+            {
+                m_accessibleMulliganCards.HandleAccessibleInput();
+                AccessibleInputMgr.MoveMouseTo(m_accessibleMulliganCards.GetItemBeingRead().GetCard());
+            }
+
+            // Re-read banner everytime a new player becomes ready while waiting for the game to start
+            if (m_waitingForOpponentsToChooseHero)
+			{
+                ReadNumberOfReadyPlayers();
+			}
+        }
+
+		internal override void OnEnterMultiplayerWaitingArea(List<Card> startingCards, string mulliganBannerText, string mulliganBannerSubtitleText, NormalButton confirmButton)
+		{
+            ReadRacesAndAnomaly();
+
+            if (mulliganBannerText != null) AccessibilityMgr.Output(this, mulliganBannerText);
+            if (mulliganBannerSubtitleText != null) AccessibilityMgr.Output(this, mulliganBannerSubtitleText);
+
+            try
+            {
+                m_mulliganConfirmButton = confirmButton;
+
+                var accessibleCards = new List<AccessibleCard>(startingCards.Count);
+                startingCards.ForEach(c => accessibleCards.Add(new AccessibleBattlegroundsChooseHeroCard(this, c)));
+
+                m_accessibleMulliganCards = new AccessibleListOfItems<AccessibleCard>(this, accessibleCards);
+                m_accessibleMulliganCards.StartReading();
+                m_prevWaitingText = null;
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+		}
+
+		public override void EndMulligan()
+		{
+            m_waitingForOpponentsToChooseHero = false;
+            m_confirmingHero = false;
+            m_accessibleMulliganCards = null;
+            m_mulliganConfirmButton = null;
+
+            TransitionFromMulliganToGame();
+		}
+
+        public override void WaitingForOpponentToFinishMulligan()
+        {
+            ReadNumberOfReadyPlayers();
+
+            m_confirmingHero = false;
+            m_waitingForOpponentsToChooseHero = true;
+        }
+
+		private void ReadNumberOfReadyPlayers(bool forceRead=false)
+		{
+            var tbBaconShop = GetGameState();
+            var playersReady = tbBaconShop.CountPlayersFinishedMulligan();
+            var playersInGame = tbBaconShop.CountPlayersInGame();
+            var waitingText = LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_MULLIGAN_PLAYERS_READY, playersReady, playersInGame);
+
+            if (m_prevWaitingText != waitingText || forceRead)
+			{
+				AccessibilityMgr.Output(this, waitingText);
+			}
+
+            m_prevWaitingText = waitingText;
+		}
+
+        #endregion
+
+        #region Help
+
+        protected override string GetMulliganHelp()
+        {
+            return m_accessibleMulliganCards?.GetHelp(false);
+        }
+
+        protected override string GetMainOptionModeHelp()
+        {
+            if (!m_isShopPhase)
+			{
+                // Don't think this can even happen to be honest
+                return "";
+			}
+
+            // Keep it simple since most players would rather look at the commands online anyways. Contextual help as in traditional Hearthstone is not worth
+            // the complexity
+
+            var lines = new List<string>();
+
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_HELP, AccessibleKey.SEE_PLAYER_MANA));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_TAVERN_INFORMATION_HELP, AccessibleKey.SEE_TAVERN));
+            if (GameState.Get().BattlegroundAllowBuddies())
+            {
+                lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_HERO_BUDDY_HELP, AccessibleKey.BATTLEGROUNDS_READ_HERO_BUDDY));
+            }
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_NEXT_OPPONENT_STATS_HELP, AccessibleKey.BATTLEGROUNDS_READ_NEXT_OPPONENT_STATS));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_MY_STATS_HELP, AccessibleKey.BATTLEGROUNDS_READ_MY_STATS));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_LEADERBOARD_HELP, AccessibleKey.BATTLEGROUNDS_READ_LEADERBOARD));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_RACES_IN_GAME_HELP, AccessibleKey.BATTLEGROUNDS_READ_RACES_IN_GAME));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_HERO_POWER_HELP, AccessibleKey.BATTLEGROUNDS_SEE_PLAYER_HERO_POWER));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_READ_TIME_REMAINING, AccessibleKey.END_TURN));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_MINION_UPGRADE_TAVERN_TUTORIAL_OVERRIDE, AccessibleKey.UPGRADE_TAVERN, AccessibleKey.CONFIRM));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_REFRESH_TUTORIAL_OVERRIDE, AccessibleKey.FREEZE_TAVERN, AccessibleKey.CONFIRM));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN, AccessibleKey.FREEZE_TAVERN, AccessibleKey.CONFIRM));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_MINION_MOVE_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.SPACE));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGBUY_TUTORIAL_OVERRIDE, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM));
+            lines.Add(LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGSELL_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM));
+
+            return AccessibleSpeechUtils.CombineLines(lines);
+        }
+
+        protected override string GetOpponentTurnHelp()
+        {
+            // No-op
+            return "";
+        }
+
+        public override string GetHelp()
+        {
+            var gameEntity = GameState.Get().GetGameEntity();
+            if (gameEntity is TB_BaconShop_Tutorial)
+			{
+                return ((TB_BaconShop_Tutorial)gameEntity).GetHelp();
+			}
+
+            return base.GetHelp();
+        }
+
+        #endregion
+
+        #region Not used in BGs
+
+        internal override void ReadOpponentResources()
+		{
+			// No-op
+		}
+
+        internal override void ReadOpponentHand()
+		{
+			// No-op
+		}
+
+		internal override void ReadPlayerDeck()
+		{
+			// No-op
+		}
+
+		internal override void ReadOpponentDeck()
+		{
+			// No-op
+		}
+
+		#endregion
+	}
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsHeroBuddyCard.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsHeroBuddyCard.cs
new file mode 100644
index 0000000..77e7858
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsHeroBuddyCard.cs
@@ -0,0 +1,27 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsHeroBuddyCard : AccessibleBattlegroundsCard
+    {
+		internal AccessibleBattlegroundsHeroBuddyCard(AccessibleComponent parent, Card card) : base(parent, card)
+        {
+        }
+
+		internal override List<string> GetLines()
+		{
+            var ret = new List<string>();
+
+            var heroCard = GameState.Get().GetFriendlySidePlayer().GetHero();
+
+            ret.AddRange(AccessibleCardUtils.GetHeroBuddyCardLinesForHeroCard(heroCard));
+
+            ret.Insert(1, AccessibleCardUtils.GetCost(m_card));
+
+            return ret;
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsLeaderboardMgr.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsLeaderboardMgr.cs
new file mode 100644
index 0000000..1cb73f7
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsLeaderboardMgr.cs
@@ -0,0 +1,158 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+	class AccessibleBattlegroundsLeaderboardMgr
+	{
+		private static AccessibleBattlegroundsLeaderboardMgr s_instance;
+
+		private bool m_readingLeaderboard;
+
+		private AccessibleListOfItems<AccessiblePlayerLeaderboardTeam> m_accessibleTeams;
+
+		internal static AccessibleBattlegroundsLeaderboardMgr Get()
+		{
+			if (s_instance == null)
+			{
+				s_instance = new AccessibleBattlegroundsLeaderboardMgr();
+			}
+
+			return s_instance;
+		}
+
+		public void ReadNextOpponent()
+		{
+			var nextOpponentTeam = PlayerLeaderboardManager.Get().GetNextOpponentTile().m_parent;
+			StartReadingLeaderboard(GetTeamIndex(nextOpponentTeam));
+		}
+
+		public void ReadMyself()
+		{
+			var myTeam = PlayerLeaderboardManager.Get().GetMyTile().m_parent;
+			StartReadingLeaderboard(GetTeamIndex(myTeam));
+		}
+
+		public void ReadNextOpponentToEnd()
+		{
+			ReadTeam(PlayerLeaderboardManager.Get().GetNextOpponentTile().m_parent);
+		}
+
+		public void ReadMyselfToEnd()
+		{
+			ReadTeam(PlayerLeaderboardManager.Get().GetMyTile().m_parent);
+		}
+
+		private static void ReadTeam(PlayerLeaderboardTeam team)
+		{
+			if (team == null)
+			{
+				return;
+			}
+
+			var accessibleTeam = CreateAccessibleTeam(team);
+			accessibleTeam.ReadAllLines();
+		}
+
+		internal int GetNumTeamsAlive()
+		{
+			var teams = PlayerLeaderboardManager.Get().m_teams;
+
+			int ret = 0;
+
+			foreach (var team in teams)
+			{
+				if (team?.Members[0].Entity.GetRealTimeRemainingHP() > 0)
+				{
+					ret++;
+				}
+			}
+
+			return ret;
+		}
+
+		internal bool HandleAccessibleInput()
+		{
+			if (AccessibleKey.BATTLEGROUNDS_READ_LEADERBOARD.IsPressed() && !m_readingLeaderboard)
+			{
+				StartReadingLeaderboard();
+				return true;
+			}
+			else if (AccessibleKey.BACK.IsPressed() && m_readingLeaderboard)
+			{
+				StopReadingLeaderboard();
+				AccessibleInputMgr.HideMouse();
+				return true;
+			}
+			else if (m_readingLeaderboard)
+			{
+				AccessibleInputMgr.MoveMouseTo(m_accessibleTeams.GetItemBeingRead().GetCard());
+
+				return m_accessibleTeams.HandleAccessibleInput();
+			}
+
+			return false;
+		}
+
+		internal void StartReadingLeaderboard(int fromIndex = 0)
+		{
+			var teams = PlayerLeaderboardManager.Get().m_teams;
+
+			if (teams == null || teams.Count == 0)
+			{
+				return;
+			}
+
+			var accessibleTeams = new List<AccessiblePlayerLeaderboardTeam>();
+
+			foreach (var team in teams)
+			{
+				accessibleTeams.Add(CreateAccessibleTeam(team));
+			}
+
+			m_accessibleTeams = new AccessibleListOfItems<AccessiblePlayerLeaderboardTeam>(AccessibleGameplay.Get(), accessibleTeams);
+			m_readingLeaderboard = true;
+
+			m_accessibleTeams.StartReadingFromIndex(fromIndex);
+		}
+
+		internal void StopReadingLeaderboard()
+		{
+			m_readingLeaderboard = false;
+		}
+
+		internal bool IsReadingLeaderboard()
+		{
+			return m_readingLeaderboard;
+		}
+
+		private int GetTeamIndex(PlayerLeaderboardTeam team)
+		{
+			var teams = PlayerLeaderboardManager.Get().m_teams;
+
+			for (int i = 0; i < teams.Count; i++)
+			{
+				var t = teams[i];
+
+				if (t == team)
+				{
+					return i;
+				}
+			}
+
+			return 0; // Allow StartReading to fail gracefully
+		}
+
+		private static AccessiblePlayerLeaderboardTeam CreateAccessibleTeam(PlayerLeaderboardTeam team)
+		{
+			switch (team)
+			{
+				case PlayerLeaderboardSoloTeam solo:
+					return new AccessiblePlayerLeaderboardSoloTeam(AccessibleGameplay.Get(), solo);
+				case PlayerLeaderboardDuosTeam duos:
+					return new AccessiblePlayerLeaderboardDuosTeam(AccessibleGameplay.Get(), duos);
+			}
+			return null;
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPartyAnnouncements.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPartyAnnouncements.cs
new file mode 100644
index 0000000..8b5a330
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPartyAnnouncements.cs
@@ -0,0 +1,41 @@
+using System;
+using System.Collections.Generic;
+using Blizzard.GameService.SDK.Client.Integration;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsPartyAnnouncements
+    {
+		private static AccessibleBattlegroundsPartyAnnouncements s_instance;
+
+		internal static AccessibleBattlegroundsPartyAnnouncements Get()
+		{
+			if (s_instance == null)
+			{
+				s_instance = new AccessibleBattlegroundsPartyAnnouncements();
+			}
+
+			return s_instance;
+		}
+        public static void AnnounceEvent(PartyManager.PartyInviteEvent inviteEvent, BnetGameAccountId playerGameAccountId, PartyManager.PartyData data, object userData) {
+            string name=PartyManager.Get().GetPartyMemberName(playerGameAccountId);
+            LocalizationKey localizationStr=null;
+		    switch (inviteEvent)
+		    {
+                		case PartyManager.PartyInviteEvent.FRIEND_ACCEPTED_INVITE:
+                        localizationStr=LocalizationKey.BATTLEGROUNDS_PARTY_PLAYER_JOINED;
+                break;
+                		case PartyManager.PartyInviteEvent.FRIEND_DECLINED_INVITE:
+                                        localizationStr=LocalizationKey.BATTLEGROUNDS_PARTY_PLAYER_DECLINED_INVITE;
+                                        break;
+		case PartyManager.PartyInviteEvent.INVITE_EXPIRED:
+		case PartyManager.PartyInviteEvent.FRIEND_LEFT:
+                localizationStr=LocalizationKey.BATTLEGROUNDS_PARTY_PLAYER_LEFT;
+                break;
+            }
+            if(localizationStr!=null) {
+                AccessibilityMgr.Output(null, LocalizationUtils.Format(localizationStr,name));
+            }
+        }
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPartyMember.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPartyMember.cs
new file mode 100644
index 0000000..c135956
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPartyMember.cs
@@ -0,0 +1,59 @@
+using System;
+using System.Collections.Generic;
+using static BaconParty;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsPartyMember : AccessibleItem, IEquatable<AccessibleBattlegroundsPartyMember>
+    {
+        private BaconPartyMemberInfo m_memberInfo;
+
+        internal AccessibleBattlegroundsPartyMember(AccessibleComponent parent, BaconParty.BaconPartyMemberInfo info) : base(parent)
+        {
+            m_memberInfo = info;
+        }
+
+        public bool Equals(AccessibleBattlegroundsPartyMember other)
+        {
+            return this.m_memberInfo.playerGameAccountId == other.m_memberInfo.playerGameAccountId;
+        }
+
+        public override int GetHashCode()
+        {
+            return m_memberInfo.playerGameAccountId.GetHashCode();
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+            ret.Add(PartyManager.Get().GetPartyMemberName(m_memberInfo.playerGameAccountId));
+            switch (m_memberInfo.status)
+            {
+                case Status.Waiting:
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_PARTY_MEMBER_WAITING));
+                    break;
+                case Status.Ready:
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_PARTY_MEMBER_READY));
+                    break;
+                case Status.NotReady:
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_PARTY_MEMBER_NOT_READY));
+                    break;
+                case Status.Leader:
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_PARTY_MEMBER_LEADER));
+                    break;
+                    case Status.Spectate:
+                    ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_PARTY_MEMBER_SPECTATE));
+                    break;
+                default:
+                    Log.Accessibility.PrintWarning("AccessibleBattlegroundsPartyMember: unhandled status {0} for member {1}", Enum.GetName(typeof(Status), m_memberInfo.status), PartyManager.Get().GetPartyMemberName(m_memberInfo.playerGameAccountId));
+                    break;
+            }
+            return ret;
+        }
+
+        internal BaconParty.BaconPartyMemberInfo GetMemberInfo()
+        {
+            return m_memberInfo;
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPowerTaskListDescriber.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPowerTaskListDescriber.cs
new file mode 100644
index 0000000..24f90ee
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessibleBattlegroundsPowerTaskListDescriber.cs
@@ -0,0 +1,12 @@
+﻿using PegasusGame;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class AccessibleBattlegroundsPowerTaskListDescriber : AccessiblePowerTaskListDescriber
+    {
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardDuosTeam.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardDuosTeam.cs
new file mode 100644
index 0000000..0eb7f59
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardDuosTeam.cs
@@ -0,0 +1,57 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static FriendListFrame;
+
+namespace Accessibility
+{
+    class AccessiblePlayerLeaderboardDuosTeam : AccessiblePlayerLeaderboardTeam
+    {
+        private PlayerLeaderboardDuosTeam m_duosTeam;
+
+        internal AccessiblePlayerLeaderboardDuosTeam(AccessibleComponent parent, PlayerLeaderboardDuosTeam team) : base(parent, team)
+        {
+            m_duosTeam = team;
+        }
+
+        internal override PlayerLeaderboardCard GetCard()
+        {
+            return m_duosTeam.Members[0];
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+            var defaultHeroEntity = GetCard().Entity;
+
+            AccessibleCardUtils.AddLineIfExists(GetTeamName(), ret);
+            AccessibleCardUtils.AddLineIfExists(GetPlace(), ret);
+            AddHealthAndArmorLines(defaultHeroEntity, ret);
+
+            AddHeroSummary(m_duosTeam.Members[0], ret);
+            AddHeroSummary(m_duosTeam.Members[1], ret);
+
+            return ret;
+        }
+
+        private void AddHeroSummary(PlayerLeaderboardCard card, List<string> ret)
+        {
+            var heroEntity = card.Entity;
+
+            AccessibleCardUtils.AddLineIfExists(GetName(heroEntity), ret);
+            AccessibleCardUtils.AddLineIfExists(GetTavernTier(heroEntity), ret);
+            AccessibleCardUtils.AddLineIfExists(GetRacesText(card.m_overlay.m_recentCombatsPanel), ret);
+            AccessibleCardUtils.AddLineIfExists(GetTriplesText(heroEntity), ret);
+
+            AddCombatInfoLines(heroEntity, ret);
+        }
+
+        private string GetTeamName()
+        {
+            var firstPlayerName = GetName(m_duosTeam.Members[0].Entity);
+            var secondPlayerName = GetName(m_duosTeam.Members[1].Entity);
+            return $"{firstPlayerName} {LocalizationUtils.Get(LocalizationKey.FORMATTING_LIST_FINAL_SEPARATOR)} {secondPlayerName}";
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardSoloTeam.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardSoloTeam.cs
new file mode 100644
index 0000000..d0a53d2
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardSoloTeam.cs
@@ -0,0 +1,41 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static FriendListFrame;
+
+namespace Accessibility
+{
+    class AccessiblePlayerLeaderboardSoloTeam : AccessiblePlayerLeaderboardTeam
+    {
+        private PlayerLeaderboardSoloTeam m_soloTeam;
+
+        internal AccessiblePlayerLeaderboardSoloTeam(AccessibleComponent parent, PlayerLeaderboardSoloTeam team) : base(parent, team)
+        {
+            m_soloTeam = team;
+        }
+
+        internal override PlayerLeaderboardCard GetCard()
+        {
+            return m_soloTeam.Members[0];
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+            var heroEntity = GetCard().Entity;
+
+            AccessibleCardUtils.AddLineIfExists(GetName(heroEntity), ret);
+            AccessibleCardUtils.AddLineIfExists(GetPlace(), ret);
+            AddHealthAndArmorLines(heroEntity, ret);
+            AccessibleCardUtils.AddLineIfExists(GetTavernTier(heroEntity), ret);
+            AccessibleCardUtils.AddLineIfExists(GetRacesText(GetCard().m_overlay?.m_recentCombatsPanel), ret);
+            AccessibleCardUtils.AddLineIfExists(GetTriplesText(heroEntity), ret);
+
+            AddCombatInfoLines(heroEntity, ret);
+
+            return ret;
+        }
+
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardTeam.cs b/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardTeam.cs
new file mode 100644
index 0000000..efcb539
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/AccessiblePlayerLeaderboardTeam.cs
@@ -0,0 +1,131 @@
+using System;
+using System.Collections.Generic;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public abstract class AccessiblePlayerLeaderboardTeam : AccessibleItem
+    {
+        protected PlayerLeaderboardTeam m_team;
+
+        internal AccessiblePlayerLeaderboardTeam(AccessibleComponent parent, PlayerLeaderboardTeam team) : base(parent)
+        {
+            m_team = team;
+        }
+
+        protected void AddCombatInfoLines(Entity heroEntity, List<string> ret)
+        {
+            var playerId = heroEntity.GetTag(GAME_TAG.PLAYER_ID);
+            var combatHistory = PlayerLeaderboardManager.Get().GetRecentCombatHistoryForPlayer(playerId);
+
+            if (combatHistory == null || combatHistory.Count == 0)
+            {
+                return;
+            }
+
+            var lastCombat = combatHistory[combatHistory.Count - 1];
+            var winStreak = lastCombat.winStreak;
+            var winStreakLabel = GameStrings.Get("GAMEPLAY_BACON_WIN_STREAK_ICON");
+            ret.Add(AccessibleSpeechUtils.CombineWordsWithColon(winStreakLabel, winStreak.ToString()));
+
+            var lastCombatToRead = Math.Max(0, combatHistory.Count - PlayerLeaderboardRecentCombatsPanel.MAX_VISIBLE_COMBATS_PER_PANEL);
+
+            for (int i = combatHistory.Count - 1; i >= lastCombatToRead; i--)
+            {
+                var combat = combatHistory[i];
+                var combatSummary = FormatCombatSummary(combat);
+                AccessibleCardUtils.AddLineIfExists(combatSummary, ret);
+            }
+        }
+
+        protected string FormatCombatSummary(PlayerLeaderboardRecentCombatsPanel.RecentCombatInfo combat)
+        {
+            var opponentTile = PlayerLeaderboardManager.Get().GetTileForPlayerId(combat.opponentId);
+
+            if (opponentTile == null)
+            {
+                // Can happen at the start of the game and during the tutorial
+                AccessibilityUtils.LogDebug($"Attempted to format combat against null opponent. ownerId={combat.ownerId} opponentId={combat.opponentId} isDefeated={combat.isDefeated}");
+                return null;
+            }
+
+            var opponentHeroName = opponentTile.GetHeroName();
+
+            if (combat.damageTarget == combat.ownerId)
+            {
+                return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TOOK_DAMAGE, combat.damage, opponentHeroName);
+            }
+            else if (combat.damageTarget == combat.opponentId)
+            {
+                return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_DEALT_DAMAGE, combat.damage, opponentHeroName);
+            }
+            else
+            {
+                return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TIED, opponentHeroName);
+            }
+        }
+
+        protected string GetName(Entity heroEntity)
+        {
+            var playerId = heroEntity.GetTag(GAME_TAG.PLAYER_ID);
+            var playerName = GameState.Get().GetGameEntity().GetBestNameForPlayer(playerId);
+            var asHeroText = GameStrings.Format("GAMEPLAY_BACON_ALTERNATE_PLAYER_NAME", heroEntity.GetName());
+
+            return $"{playerName} {asHeroText}";
+        }
+
+        protected string GetPlace()
+        {
+            var place = m_team.GetBestPlacement();
+
+            return TB_BaconShop.GetPlaceString(place);
+        }
+
+        protected void AddHealthAndArmorLines(Entity heroEntity, List<string> ret)
+        {
+            if (heroEntity == null)
+            {
+                return;
+            }
+
+            // Note: Kel'Thuzad sometimes has negative health for a while which is just weird
+            var health = Math.Max(0, heroEntity.GetCurrentHealth());
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_HEALTH, health));
+
+            var armor = heroEntity.GetArmor();
+
+            if (armor > 0)
+            {
+                ret.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+            }
+        }
+
+        protected string GetTavernTier(Entity heroEntity)
+        {
+            var tier = heroEntity?.GetRealTimePlayerTechLevel();
+
+            if (tier == 0)
+            {
+                return "";
+            }
+
+            return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER, tier);
+        }
+
+        protected string GetRacesText(PlayerLeaderboardRecentCombatsPanel recentCombatsPanel)
+        {
+            return recentCombatsPanel?.m_accessibleRacesCounter;
+        }
+
+        protected string GetTriplesText(Entity heroEntity)
+        {
+            var triples = heroEntity.GetTag(GAME_TAG.PLAYER_TRIPLES);
+            var triplesCreatedLabel = LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARD_STATS_PLAYER_TRIPLES_CREATED);
+
+            return AccessibleSpeechUtils.CombineWordsWithColon(triplesCreatedLabel, triples.ToString());
+        }
+
+        internal abstract PlayerLeaderboardCard GetCard();
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Battlegrounds/BattlegroundsCardEffectInterpreter.cs b/Assembly-CSharp/Accessibility/Battlegrounds/BattlegroundsCardEffectInterpreter.cs
new file mode 100644
index 0000000..d43e3e1
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Battlegrounds/BattlegroundsCardEffectInterpreter.cs
@@ -0,0 +1,290 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    public class BattlegroundsCardEffectInterpreter
+    {
+        private static HashSet<string> s_relevantAvengerCards = new HashSet<string>() {
+			"BG21_009", "BG21_009_G", "BG21_030", "BG21_030_G", "BG21_031", "BG21_031_G",
+			"BG22_HERO_002_Buddy", "BG22_HERO_002_Buddy_G", "BG22_HERO_003_Buddy", "BG22_HERO_003_Buddy_G",
+			"BG22_HERO_002p", "BG22_HERO_003p"
+		};
+
+		private static HashSet<string> s_relevantTriggerCards = new HashSet<string>()
+		{
+			"BGS_110", "BGS_111", "BGS_204", "BG21_024", "BG21_024_G", "BG20_HERO_100_Buddy", "BG20_HERO_100_Buddy_G", "BG22_HERO_305_Buddy", "BG22_HERO_305_Buddy_G",
+			"BG20_HERO_100p",
+			"BG24_708", "BG24_708_G", "BG24_300", "BG24_300_G"
+		};
+
+		private static HashSet<string> s_tarecgosas = new HashSet<string>()
+		{
+			"BG21_015", "BG21_015_G",
+		};
+
+		private static HashSet<string> s_nonRelevantCards = new HashSet<string>()
+		{
+			"BG24_Reward_113"
+		};
+
+		// Used by regression tests only
+		internal static bool AreAllBGCardsAccountedFor(HashSet<string> cardIdsWithPermanentlyEffects)
+		{
+			var superSet = new HashSet<string>();
+			foreach (var elem in s_relevantAvengerCards) superSet.Add(elem);
+			foreach (var elem in s_relevantTriggerCards) superSet.Add(elem);
+			foreach (var elem in s_tarecgosas) superSet.Add(elem);
+			foreach (var elem in s_nonRelevantCards) superSet.Add(elem);
+
+			var ret = true;
+
+			foreach (var cardId in cardIdsWithPermanentlyEffects)
+			{
+				if (!superSet.Contains(cardId))
+				{
+					ret = false;
+					AccessibilityUtils.LogDebug($"Found unhandled BG cardID with permanently effect: {cardId}");
+				}
+			}
+
+			foreach (var cardId in superSet)
+			{
+				if (!cardIdsWithPermanentlyEffects.Contains(cardId))
+				{
+					ret = false;
+					AccessibilityUtils.LogDebug($"Found outdated BG cardID with permanently effect (no longer needed): {cardId}");
+				}
+			}
+
+			return ret;
+		}
+
+		internal static bool ShouldOutputStateDiff(PowerTaskList taskList, AccessibleInGameState before, AccessibleInGameState after)
+		{
+			if (!IsFriendlyPlayerTriggerEffect(taskList))
+			{
+				return false;
+			}
+
+			var sourceEntityId = taskList.GetSourceEntity().GetEntityId();
+			var sourceEntityCardId = taskList.GetSourceEntity().GetCardId();
+
+			// Not all minions trigger in the same task as their underlying effects e.g. BG buddies trigger in a previous task
+			if (s_relevantAvengerCards.Contains(sourceEntityCardId) && HasAvengeTriggered(before, after, sourceEntityId))
+			{
+				return true;
+			}
+
+			return s_relevantTriggerCards.Contains(sourceEntityCardId);
+		}
+
+		private static bool HasAvengeTriggered(AccessibleInGameState before, AccessibleInGameState after, int entityId)
+		{
+			var beforeEntity = before.GetEntity(entityId);
+			var afterEntity = after.GetEntity(entityId);
+
+			if (beforeEntity == null || afterEntity == null )
+			{
+				return false;
+			}
+
+			var avengeTotal = afterEntity.GetTag(GAME_TAG.SCORE_VALUE_1);
+
+			var beforeCurAvenge = beforeEntity.GetTag(GAME_TAG.SCORE_VALUE_2);
+			var afterCurAvenge = afterEntity.GetTag(GAME_TAG.SCORE_VALUE_2);
+
+			if (afterCurAvenge > 0 && afterCurAvenge == avengeTotal)
+			{
+				// Note: The actual trigger will come after
+				// The order is SCORE_VALUE_2 set to SCORE_VALUE_1 and in a future task list SCORE_VALUE_2 set to 0
+				return true;
+			}
+			else if (afterCurAvenge == 0 && beforeCurAvenge == avengeTotal)
+			{
+				// We're in the task that actually applies the effects on the other minions
+				return true;
+			}
+
+			return false;
+		}
+
+		private static bool IsFriendlyPlayerTriggerEffect(PowerTaskList taskList)
+		{
+			if (taskList == null)
+			{
+				return false;
+			}
+
+			if (!taskList.IsTriggerBlock())
+			{
+				return false;
+			}
+
+			var sourceEntity = taskList.GetSourceEntity();
+
+			if (sourceEntity == null)
+			{
+				return false;
+			}
+
+			if (!sourceEntity.IsControlledByFriendlySidePlayer())
+			{
+				// Don't output opponent buffs to reduce noise since not all would always be that interesting
+				// Could be useful for Tarecgosas and SI:Sefins maybe in a 1v1 scenario at the end of the game but we'll wait for feedback
+				return false;
+			}
+
+			return true;
+		}
+
+		internal static List<string> GetTarecgosaDiffs(PowerTaskList taskList, AccessibleInGameState prevState, AccessibleInGameState newState, AccessibleInGameState stateAtStartOfCombatPhase)
+		{
+			var ret = new List<string>();
+
+			if (!IsFriendlyPlayerTriggerEffect(taskList))
+			{
+				return ret;
+			}
+
+			if (AccessibleInGameState.WasAnyPlayerMinionBuffedOrDebuffed(prevState, newState, s_tarecgosas))
+			{
+				var tarecgosasAfter = GetTarecgosas(newState);
+				var tarecgosasBefore = GetTarecgosas(prevState);
+				var tarecgosasAtStartOfCombatPhase = GetTarecgosas(stateAtStartOfCombatPhase);
+
+				var tarecgosaLines = GetTarecgosaLines(tarecgosasAtStartOfCombatPhase, tarecgosasBefore, tarecgosasAfter);
+
+				if (tarecgosaLines.Count > 0)
+				{
+					var triggerSource = AccessibleSpeechUtils.GetEntityName(taskList.GetSourceEntity());
+
+					ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAYER_CARD_TRIGGERED, triggerSource));
+					ret.AddRange(tarecgosaLines);
+				}
+			}
+
+			return ret;
+		}
+
+		private static List<string> GetTarecgosaLines(List<Entity> tarecgosasAtStartOfCombatPhase, List<Entity> tarecgosasBefore, List<Entity> tarecgosasAfter)
+		{
+			var ret = new List<string>();
+
+			var socTarecgosasById = new Dictionary<int, Entity>();
+			var beforeTarecgosasById = new Dictionary<int, Entity>();
+
+			tarecgosasAtStartOfCombatPhase.ForEach(t => socTarecgosasById.Add(t.GetEntityId(), t));
+			tarecgosasBefore.ForEach(t => beforeTarecgosasById.Add(t.GetEntityId(), t));
+
+			foreach(var tarecgosa in tarecgosasAfter)
+			{
+				var entityId = tarecgosa.GetEntityId();
+
+				if (socTarecgosasById.ContainsKey(entityId) && beforeTarecgosasById.ContainsKey(entityId))
+				{
+					var diff = GetTarecgosaDiff(socTarecgosasById[entityId], beforeTarecgosasById[entityId], tarecgosa);
+
+					if (diff != null && diff.Length > 0)
+					{
+						var tarecgosaName = AccessibleSpeechUtils.GetFullNameInZone(tarecgosa);
+						ret.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT, tarecgosaName, diff));
+					}
+				}
+			}
+
+			return ret;
+		}
+
+		private static string GetTarecgosaDiff(Entity soc, Entity before, Entity after)
+		{
+			var lines = new List<string>();
+
+			if (after.GetCurrentHealth() <= 0)
+			{
+				return null;
+			}
+
+			if (HasTransformed(before, after))
+			{
+				// Normal to Golden Tarecgosas would be covered by this
+				lines.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_TRANSFORMED, AccessibleSpeechUtils.GetEntityName(after)));
+				return AccessibleSpeechUtils.HumanizeList(lines);
+			}
+
+			var gainedDescriptions = new List<string>();
+
+			// Effects
+			var gainedDivineShield = after.HasDivineShield() && !before.HasDivineShield() && !before.HasDivineShield();
+			var gainedWindfury = after.HasWindfury() && !before.HasWindfury() && !before.HasWindfury();
+			var gainedTaunt = after.HasTaunt() && !before.HasTaunt() && !soc.HasTaunt();
+			var gainedReborn = after.HasReborn() && !before.HasReborn() && !soc.HasReborn();
+			var becamePoisonous = after.IsPoisonous() && !before.IsPoisonous() && !before.IsPoisonous();
+			// TODO: Think about deathrattles as those would be considerably harder (does N'Zoth's fish become permanent?)
+
+			if (gainedDivineShield) gainedDescriptions.Add(LocalizedText.GLOBAL_DIVINE_SHIELD);
+			if (gainedWindfury) gainedDescriptions.Add(LocalizedText.GLOBAL_WINDFURY);
+			if (gainedTaunt) gainedDescriptions.Add(LocalizedText.GLOBAL_TAUNT);
+			if (gainedReborn) gainedDescriptions.Add(LocalizedText.GLOBAL_REBORN);
+			if (becamePoisonous) lines.Add(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS));
+
+			// Stats
+			var atkDiff = after.GetATK() - before.GetATK();
+			var healthDiff = after.GetHealth() - before.GetHealth();
+
+			if (atkDiff > 0) gainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_ATTACK, atkDiff));
+			if (healthDiff > 0) gainedDescriptions.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_N_HEALTH, healthDiff));
+
+			// Group everything together
+			var groupedGainedDescriptions = AccessibleSpeechUtils.HumanizeList(gainedDescriptions);
+
+			if (groupedGainedDescriptions.Length > 0)
+			{
+				lines.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_DIFF_ENTITY_GAINED_STATS, groupedGainedDescriptions));
+			}
+
+			return AccessibleSpeechUtils.HumanizeList(lines);
+		}
+
+		private static bool HasTransformed(Entity before, Entity after)
+		{
+			if (before == null || after == null)
+			{
+				return false;
+			}
+
+			var beforeName = AccessibleSpeechUtils.GetEntityName(before);
+			var afterName = AccessibleSpeechUtils.GetEntityName(after);
+
+			return !beforeName.Equals(afterName);
+		}
+
+		private static List<Entity> GetTarecgosas(AccessibleInGameState state)
+		{
+			var ret = new List<Entity>();
+
+			foreach(var minion in state.GetPlayerMinions())
+			{
+				if (IsTarecgosa(minion))
+				{
+					ret.Add(minion);
+				}
+			}
+
+			return ret;
+		}
+
+		private static bool IsTarecgosa(Entity minion)
+		{
+			if (minion == null)
+			{
+				return false;
+			}
+
+			return s_tarecgosas.Contains(minion.GetCardId());
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs b/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs
new file mode 100644
index 0000000..6885dec
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CardEffectInterpreter.cs
@@ -0,0 +1,486 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    public class CardEffectInterpreter
+    {
+        private static HashSet<string> friendlyCards = new HashSet<string>() { "AT_002", "AT_006", "AT_009", "AT_010", "AT_013", "AT_015", "AT_016", "AT_018", "AT_019", "AT_019e", "AT_024", "AT_028", "AT_029", "AT_031", "AT_033", "AT_035", "AT_035t", "AT_037b", "AT_038", "AT_039", "AT_040", "AT_041", "AT_042", "AT_043", "AT_046", "AT_047", "AT_048", "AT_049", "AT_053", "AT_054", "AT_055", "AT_057", "AT_058", "AT_060", "AT_061", "AT_062", "AT_066", "AT_068", "AT_069", "AT_072", "AT_073", "AT_074", "AT_076", "AT_077", "AT_079", "AT_082", "AT_083", "AT_084", "AT_089", "AT_090", "AT_091", "AT_096", "AT_099", "AT_100", "AT_104", "AT_108", "AT_111", "AT_112", "AT_113", "AT_115", "AT_115e", "AT_118", "AT_119", "AT_127", "AT_128", "AT_132", "AT_132_SHAMANa", "AT_132_SHAMANe", "AT_132_WARLOCKa", "AT_132_WARLOCKb", "AT_133", "AV_100", "AV_101", "AV_107", "AV_109", "AV_113", "AV_113p", "AV_113t2", "AV_113t3", "AV_113t7", "AV_113t8", "AV_113t9", "AV_116", "AV_119", "AV_124", "AV_130", "AV_136t", "AV_139", "AV_147", "AV_201", "AV_203p", "AV_203pe", "AV_203po", "AV_204", "AV_205", "AV_205a", "AV_205p", "AV_205pb", "AV_206p", "AV_207", "AV_207p", "AV_211", "AV_213", "AV_215", "AV_226", "AV_244", "AV_256", "AV_258p2", "AV_258pt", "AV_258t", "AV_258t2", "AV_260", "AV_264", "AV_268", "AV_269", "AV_269e", "AV_277", "AV_281", "AV_282", "AV_282t2", "AV_282t4", "AV_283", "AV_284", "AV_290", "AV_292", "AV_293", "AV_293e", "AV_294", "AV_295", "AV_295a", "AV_295b", "AV_296e", "AV_309", "AV_312", "AV_316hp", "AV_316t4", "AV_317", "AV_323", "AV_326", "AV_328", "AV_329", "AV_330", "AV_331e", "AV_333", "AV_334", "AV_336", "AV_336e", "AV_337", "AV_338", "AV_339", "AV_340", "AV_341", "AV_342", "AV_343", "AV_344", "AV_360", "AV_400", "AV_405", "AV_565", "AV_657", "AV_660", "AV_661", "AV_664", "AV_710", "AV_COIN1", "AV_COIN2", "BAR_021", "BAR_025", "BAR_026", "BAR_030", "BAR_031", "BAR_034", "BAR_034t", "BAR_034t2", "BAR_037", "BAR_038", "BAR_041", "BAR_042", "BAR_060", "BAR_061", "BAR_063", "BAR_065", "BAR_070", "BAR_072", "BAR_073", "BAR_077", "BAR_079t10", "BAR_079t10b", "bar_079t10c", "BAR_079t11", "BAR_079t15", "BAR_079t15b", "BAR_079t15c", "BAR_080", "BAR_081", "BAR_308", "BAR_309", "BAR_310", "BAR_318", "BAR_321", "BAR_323", "BAR_324", "BAR_325", "BAR_326", "BAR_327", "BAR_328", "BAR_329", "BAR_330", "BAR_533", "BAR_534", "BAR_535", "BAR_537e", "BAR_539", "BAR_540", "BAR_542", "BAR_546", "BAR_549", "BAR_550", "BAR_551", "BAR_552e", "BAR_552o", "BAR_721t", "BAR_751", "BAR_812", "BAR_841", "BAR_842", "BAR_842t", "BAR_842t2", "BAR_843", "BAR_854e", "BAR_873", "BAR_880", "BAR_880t", "BAR_880t2", "BAR_881", "BAR_888", "BAR_891", "BAR_891t", "BAR_891t2", "BAR_896", "BAR_910", "BAR_914", "BAR_914t", "BAR_914t2", "BAR_915", "BAR_919t", "BAR_COIN1", "BAR_COIN2", "BAR_COIN3", "BCON_002", "BCON_003", "BCON_004", "BCON_005", "BCON_006", "BCON_009", "BCON_012", "BCON_013", "BCON_014", "BCON_015", "BCON_016", "BCON_018", "BCON_022", "BCON_024", "BCON_027", "BG_AT_069", "BG_AT_069_G", "BG_AV_309", "BG_AV_309_G", "BG_BOT_312", "BG_BOT_312e", "BG_BT_010", "BG_CFM_063", "BG_CFM_063_G", "BG_CFM_315", "BG_CFM_316", "BG_DAL_077", "BG_DAL_575", "BG_DS1_070", "BG_EX1_103", "BG_EX1_534", "BG_EX1_556", "BG_GVG_027", "BG_GVG_048", "BG_ICC_807", "BG_LOOT_368", "BG_OG_221", "BG_OG_256", "BG_SCH_149", "BG_ULD_217", "BG_UNG_073", "BG19_010", "BG19_010_G", "BG20_201", "BG20_201_G", "BG20_204", "BG20_208", "BG20_208_G", "BG20_210", "BG20_210_G", "BG20_303", "BG20_303_G", "BG20_GEM", "BG20_GEMt", "BG20_HERO_100p", "BG20_HERO_102p", "BG20_HERO_102pe", "BG20_HERO_102pe_Buddy", "BG20_HERO_201_Buddy", "BG20_HERO_201_Buddy_G", "BG20_HERO_201p", "BG20_HERO_201p2", "BG20_HERO_202pt", "BG20_HERO_242p", "BG20_HERO_283_Buddy", "BG20_HERO_283_Buddy_G", "BG20_HERO_283p_t2", "BG20_HERO_666_Buddy", "BG20_HERO_666_Buddy_G", "BG20_HERO_666p_t0", "BG20_HERO_666p_t3a", "BG20_HERO_666p_t3b", "BG20_HERO_666p_t3c", "BG20_HERO_666p_t3d", "BG20_HERO_666p_t4a", "BG20_HERO_666p_t4b", "BG20_HERO_666p_t4c", "BG20_HERO_666p_t4d", "BG20_HERO_666p_t5a", "BG20_HERO_666p_t5b", "BG20_HERO_666p_t5c", "BG20_HERO_666p_t5d", "BG20_HERO_666p_t6a", "BG20_HERO_666p_t6b", "BG20_HERO_666p_t6c", "BG20_HERO_666p_t6d", "BG21_000", "BG21_000_G", "BG21_000_Ge", "BG21_000e", "BG21_001", "BG21_001_G", "BG21_002", "BG21_002_G", "BG21_003", "BG21_003_G", "BG21_005", "BG21_005_G", "BG21_006", "BG21_006_G", "BG21_007", "BG21_007_G", "BG21_009", "BG21_009_G", "BG21_010", "BG21_010_G", "BG21_013", "BG21_013_G", "BG21_017", "BG21_017_G", "BG21_021", "BG21_021_G", "BG21_024", "BG21_024_G", "BG21_025", "BG21_025_G", "BG21_028", "BG21_028_G", "BG21_029", "BG21_029_G", "BG21_033", "BG21_033_G", "BG21_038", "BG21_038_G", "BG21_040", "BG21_HERO_000_Buddy", "BG21_HERO_000_Buddy_G", "BG21_HERO_000p", "BG21_HERO_000p2", "BG21_HERO_000p3", "BG21_HERO_002t", "BG21_HERO_010_Buddy_G", "BG21_HERO_010p", "BG21_HERO_020p", "BG21_HERO_030p", "BG21_HERO_030pe", "BG22_401", "BG22_401_G", "BG22_403", "BG22_403_G", "BG22_HERO_001p_t1", "BG22_HERO_001p_t1_s", "BG22_HERO_001p_t1e", "BG22_HERO_001p_t2", "BG22_HERO_001p_t2_s", "BG22_HERO_001p_t3_s", "BG22_HERO_002_Buddy", "BG22_HERO_002_Buddy_G", "BG22_HERO_002p", "BG22_HERO_003_Buddy", "BG22_HERO_003_Buddy_G", "BG22_HERO_003p", "BG22_HERO_005p", "BG22_HERO_007_Buddy", "BG22_HERO_007_Buddy_G", "BG22_HERO_007p2", "BG22_HERO_201_Buddy", "BG22_HERO_201_Buddy_G", "BG22_HERO_201p", "BG22_HERO_305_Buddy", "BG22_HERO_305_Buddy_G", "BG23_000", "BG23_000_G", "BG23_000_Gt", "BG23_000t", "BG23_002", "BG23_004", "BG23_004_G", "BG23_004_Gt", "BG23_004t", "BG23_005", "BG23_005_G", "BG23_006", "BG23_006_G", "BG23_006_Gt", "BG23_006t", "BG23_007", "BG23_007_G", "BG23_007_Gt", "BG23_007t", "BG23_008", "BG23_008_G", "BG23_008_Gt", "BG23_008t", "BG23_011", "BG23_011_G", "BG23_011_Gt", "BG23_011t", "BG23_012", "BG23_015_Gt", "BG23_015t", "BG23_018t", "BG23_190_G", "BG23_193", "BG23_193_G", "BG23_351", "BG23_351_G", "BG23_HERO_200p", "BG23_HERO_200p_2", "BG23_HERO_201p", "BG23_HERO_302p", "BG23_HERO_304p", "BG23_HERO_306p", "BG24_003", "BG24_003_G", "BG24_022", "BG24_022_G", "BG24_023", "BG24_023_G", "BG24_704", "BG24_704_G", "BG24_712", "BG24_712_G", "BG24_715", "BG24_715_G", "BG24_Quest_112", "BG24_Quest_114", "BG24_Quest_120", "BG24_Quest_123", "BG24_Quest_124", "BG24_Quest_125", "BG24_Quest_126", "BG24_Quest_151", "BG24_Quest_152", "BG24_Quest_311", "BG24_Quest_313", "BG24_Quest_314", "BG24_Quest_318", "BG24_Quest_320", "BG24_Quest_328", "BG24_Quest_351", "BG24_Quest_352", "BG24_QuestsPlayerEnch_t", "BG24_Reward_107", "BG24_Reward_111", "BG24_Reward_115", "BG24_Reward_129", "BG24_Reward_130", "BG24_Reward_136", "BG24_Reward_305", "BG24_Reward_306", "BG24_Reward_309", "BG24_Reward_311", "BG24_Reward_311t", "BG24_Reward_323", "BG24_Reward_331", "BG24_Reward_360", "BG24_Reward_362", "BG24_Reward_363e", "BG24_Reward_708", "BG24_Reward_715t", "BG24_Reward_715t2", "BG24_Reward_715t3", "BG24_Reward_715t4", "BG24_Reward_718", "BG24_Reward_718t", "BG25_910", "BGS_001", "BGS_006", "BGS_009", "BGS_010", "BGS_012", "BGS_014", "BGS_017", "BGS_018", "BGS_020", "BGS_021", "BGS_023", "BGS_024", "BGS_025", "BGS_026", "BGS_028", "BGS_030", "BGS_031", "BGS_036", "BGS_038", "BGS_040", "BGS_044", "BGS_046t", "BGS_048", "BGS_053", "BGS_056", "BGS_061", "BGS_066", "BGS_069", "BGS_071", "BGS_079", "BGS_080", "BGS_082", "BGS_083", "BGS_105", "BGS_112", "BGS_121", "BGS_123", "BGS_128", "BGS_132", "BGS_134", "BGS_200", "BGS_202", "BGS_204", "BGS_TreasureDiscover_001", "BGS_TreasureDiscover_002", "BGS_TreasureDiscover_003", "BGS_TreasureDiscover_004", "BGS_TreasureDiscover_005", "BGS_Treasures_000", "BGS_Treasures_001", "BGS_Treasures_002", "BGS_Treasures_004", "BGS_Treasures_007", "BGS_Treasures_009", "BGS_Treasures_010", "BGS_Treasures_011", "BGS_Treasures_012", "BGS_Treasures_013", "BGS_Treasures_015", "BGS_Treasures_016", "BGS_Treasures_018", "BGS_Treasures_019", "BGS_Treasures_020", "BGS_Treasures_021", "BGS_Treasures_026", "BGS_Treasures_028", "BGS_Treasures_032", "BGS_Treasures_038", "BOM_003p", "BOM_01_ArrivalInOrgrimmar_01s", "BOM_01_Brukan_01p", "BOM_01_Brukan_08t", "BOM_01_Dawngrasp_04t", "BOM_01_ForTheHorde_05s", "BOM_01_Golem_05p", "BOM_01_Guff_02t", "BOM_01_Guff_03p2", "BOM_01_Guff_04p2", "BOM_01_Guff_05p2", "BOM_01_Guff_06p2", "BOM_01_Guff_07p2", "BOM_01_HezrulBloodmark_02p", "BOM_01_IshaAwak_04p", "BOM_01_Plaguemaw_03p", "BOM_01_PrideOfTheFrostwolves_0", "BOM_01_StrengthAndHonor_05s_Copy", "BOM_01_Tamsin_03t", "BOM_01_Tamsin_04p3", "BOM_01_Tamsin_05p3", "BOM_01_Tamsin_06p3", "BOM_01_Tamsin_07p3", "BOM_02_AWildAnimal_01s", "BOM_02_Garona_008hb", "BOM_02_Kargal_01p", "BOM_02_Octobot_07p", "BOM_02_OneCoin_01s", "BOM_02_SludgeBeast_03p", "BOM_02_TavishSharesHisLoot_01s", "BOM_02_TavishTamesABeast_01s", "BOM_02_ThreeCoins_01s", "BOM_02_TwoCoins_01s", "BOM_02_Whirleygig_04p", "BOM_02_Xyrella_01p1", "BOM_02_Xyrella_01p2", "BOM_02_XyrellasPrayer_06s", "BOM_03_Anacondra_06p", "BOM_03_AngryTreant_01p", "BOM_03_Barak_03p", "BOM_03_Dawngrasp_02p", "BOM_03_Guff_01p", "BOM_03_Guff_08p", "BOM_03_GuffTrips_01s", "BOM_03_Mutanus_07p", "BOM_03_Party_05p", "BOM_03_RestAndRelaxation_03s", "BOM_03_Rokara_02p", "BOM_03_Smythe_04p", "BOM_03_Snapjaw_04s", "BOM_03_Tamsin_08t", "BOM_03_Vapos_02p", "BOM_04_Aquarrior_006t", "BOM_04_BurningBladeSummoner_005t", "BOM_04_Cariel_005p", "BOM_04_Cariel_006p", "BOM_04_Kurtrus_001p4", "BOM_04_Tamsin_008p", "BOM_04_TamsinsPerfume_008s", "BOM_04_Tavish_005p", "BOM_04_Tavish_006p", "BOM_04_Xyrella_005p", "BOM_04_Xyrella_006p", "BOM_05_Bolvar_007hb", "BOM_05_Bolvar_007p", "BOM_05_Guff_004p", "BOM_05_Guff_03t", "BOM_05_Rokara_004p", "BOM_05_Tamsin_001p", "BOM_05_Tamsin_002p", "BOM_05_Tamsin_004p", "BOM_06_Anetheron_006p", "BOM_06_Cariel_002p", "BOM_06_Cariel_003p", "BOM_06_Cariel_004p", "BOM_06_Cariel_005p", "BOM_06_Cariel_005p2", "BOM_06_Cariel_006p", "BOM_06_Cariel_006p2", "BOM_06_Cariel_007p", "BOM_06_Cariel_008p", "BOM_06_CarielsHealing_006s", "BOM_06_Kurtrus_006t", "BOM_06_Monstrosity_007p", "BOM_06_SummonInfernal_005s", "BOM_06_Tamsin_008p", "BOM_06_YoungSisters_001s", "BOM_06_YoungTamsin_001p", "BOM_07_Aquarrior_006t", "BOM_07_Scabbs_Bob_001p", "BOM_07_Scabbs_Cariel_005p", "BOM_07_Scabbs_Cariel_006p", "BOM_07_Scabbs_Cariel_007p", "BOM_07_Scabbs_Dawngrasp_003t", "BOM_07_Scabbs_EdwinVanCleef_008p", "BOM_07_Scabbs_Hogger_003p", "BOM_07_Scabbs_Kurtrus_005p", "BOM_07_Scabbs_Kurtrus_006p", "BOM_07_Scabbs_Kurtrus_007p", "BOM_07_Scabbs_MrSmite_006p3", "BOM_07_Scabbs_Sneed_005p", "BOM_07_Scabbs_Sneed_005pe", "BOM_07_Scabbs_Tavish_005p", "BOM_07_Scabbs_Tavish_006p", "BOM_07_Scabbs_Tavish_007p", "BOM_07_Scallywag_001t", "BOM_08_CallPet_004s", "BOM_08_Guff_003t", "BOM_08_Guff_008t", "BOM_08_Kodobane_004t", "BOM_08_Mida_008t", "BOM_08_Rokara_008t", "BOM_08_Scabbs_002t", "BOM_08_Scabbs_003t", "BOM_08_Scabbs_005t", "BOM_08_Scabbs_008t", "BOM_08_Simulacrum_004s", "BOM_08_Tavish_Drekthar_006p", "BOM_08_Tavish_Kazakusan_008p", "BOM_08_Tavish_Tavish_001p", "BOM_08_Tavish_Tavish_002p", "BOM_08_Tavish_Tavish_003p", "BOM_08_Tavish_Tavish_004p", "BOM_08_Tavish_Tavish_005p", "BOM_08_Tavish_Tavish_006p", "BOM_08_Tavish_Tavish_007p", "BOM_08_Tavish_Tavish_008p", "BOM_08_Tracking_004s", "BOM_08_Xyrella_002t", "BOM_08_Xyrella_003t", "BOM_08_Xyrella_008t", "BOM_09_Brukan_001p", "BOM_09_Brukan_002p", "BOM_09_Brukan_004p", "BOM_09_Brukan_005p", "BOM_09_Brukan_006p", "BOM_09_Guff_003p", "BOM_09_Guff_006t", "BOM_09_Guff_008t", "BOM_09_Ichman_003p", "BOM_09_Primalist_005p", "BOM_09_Rokara_006t", "BOM_09_Rokara_008t", "BOM_09_Scabbs_008t", "BOM_09_Supplies_004t", "BOM_09_Tamsin_001p", "BOM_09_Vanndar_007p", "BOM_09_Xyrella_008t", "BOM_10_BellowingRoar_006s", "BOM_10_DarkNaaru_008p", "BOM_10_Jaina_003t", "BOM_10_OnyxiaEgg_005t", "BOM_10_OnyxiaPhase2_005p", "BOM_10_OnyxiaPhase3_006p", "BOM_10_Scabbs_001t", "BOM_10_Tavish_001t", "BOM_10_Varian_003t", "BOOM_COIN", "BOT_034", "BOT_038", "BOT_042", "BOT_054", "BOT_066", "BOT_067", "BOT_069", "BOT_079", "BOT_083", "BOT_084", "BOT_087", "BOT_093", "BOT_099", "BOT_101", "BOT_107", "BOT_218", "BOT_219", "BOT_219t", "BOT_224", "BOT_226", "BOT_234", "BOT_238p2", "BOT_238p4", "BOT_238p6", "BOT_242", "BOT_243", "BOT_254", "BOT_256", "BOT_258e", "BOT_263", "BOT_267", "BOT_270", "BOT_273", "BOT_273t1", "BOT_273t2", "BOT_273t3", "BOT_280", "BOT_283", "BOT_286", "BOT_288", "BOT_291", "BOT_299", "BOT_312", "BOT_312e", "BOT_401", "BOT_402", "BOT_404", "BOT_407", "BOT_411e", "BOT_411e2", "BOT_413", "BOT_419", "BOT_420", "BOT_422", "BOT_422a", "BOT_422b", "BOT_423", "BOT_429", "BOT_431", "BOT_433", "BOT_435", "BOT_436", "BOT_437", "BOT_438", "BOT_438e", "BOT_443", "BOT_444", "BOT_444e", "BOT_445", "BOT_451", "BOT_507", "BOT_508", "BOT_509", "BOT_511", "BOT_517", "BOT_521", "BOT_529", "BOT_532", "BOT_533", "BOT_535", "BOT_537", "BOT_539", "BOT_562", "BOT_565", "BOT_567", "BOT_568", "BOT_573", "BOT_576", "BOT_600", "BOT_700", "BOT_700e", "BOT_908", "BOT_909", "BOT_910", "BOT_912", "BOT_913", "BOTA_203", "BOTA_207", "BOTA_211", "BOTA_231", "BOTA_231e", "BOTA_232", "BOTA_241", "BRM_001", "BRM_006", "BRM_007", "BRM_012", "BRM_017", "BRM_018", "BRM_018e", "BRM_019", "BRM_022", "BRM_026", "BRM_027", "BRM_028", "BRM_030", "BRMA_01", "BRMA01_4", "BRMA02_2", "BRMA02_2_2_TB", "BRMA02_2_2c_TB", "BRMA02_2H", "BRMA04_4", "BRMA04_4H", "BRMA06_2", "BRMA06_2H", "BRMA06_2H_TB", "BRMA09_2", "BRMA09_2_TB", "BRMA09_2H", "BRMA09_3", "BRMA09_3H", "BRMA09_4", "BRMA09_4H", "BRMA09_5", "BRMA09_5H", "BRMA10_3", "BRMA10_3H", "BRMA11_2H", "BRMA11_2H_2_TB", "BRMA12_2", "BRMA12_2H", "BRMA15_3", "BRMA17_5", "BRMA17_5_TB", "BRMA17_5H", "BRMC_84", "BRMC_87", "BRMC_92", "BRMC_93", "BRMC_95h", "BRMC_95he", "BRMC_96", "BRMC_99", "BT_003", "BT_006", "BT_008", "BT_009", "BT_010", "BT_014", "BT_018", "BT_019t", "BT_021", "BT_022", "BT_024", "BT_025", "BT_025e", "BT_035", "BT_036", "BT_042", "BT_101", "BT_108", "BT_109", "BT_113", "BT_115", "BT_124", "BT_128", "BT_129", "BT_130", "BT_132", "BT_135", "BT_136t", "BT_136ta", "BT_136tb", "BT_142", "BT_155", "BT_159", "BT_160", "BT_160e", "BT_163", "BT_173", "BT_175", "BT_175t", "BT_188", "BT_190", "BT_198", "BT_202", "BT_203", "BT_210", "BT_210t", "BT_212", "BT_213", "BT_214", "BT_249", "BT_252", "BT_253", "BT_256", "BT_257", "BT_292", "BT_300", "BT_302", "BT_304", "BT_306", "BT_309t", "BT_321", "BT_341", "BT_352", "BT_407", "BT_416", "BT_416e", "BT_427", "BT_480", "BT_481", "BT_486", "BT_488", "BT_491", "BT_509", "BT_512", "BT_702", "BT_703", "BT_707", "BT_709", "BT_713", "BT_720", "BT_721", "BT_726", "BT_728", "BT_735", "BT_752", "BT_753", "BT_761", "BT_814", "BT_922", "BT_COIN", "BTA_01p", "BTA_03", "BTA_05", "BTA_06", "BTA_07", "BTA_08", "BTA_09", "BTA_12", "BTA_15", "BTA_16", "BTA_BOSS_01p", "BTA_BOSS_03p", "BTA_BOSS_07s4", "BTA_BOSS_10t", "BTA_BOSS_12p", "BTA_BOSS_13p", "BTA_BOSS_14p", "BTA_BOSS_16p", "BTA_BOSS_16s", "BTA_BOSS_16t2", "BTA_BOSS_16te3", "BTA_BOSS_22p", "BTA_BOSS_24t", "BTA_BOSS_25p", "BTA_BOSS_26s", "CFH_1342", "CFH_1343e", "CFH_1346", "CFH_1350", "CFH_1351", "CFH_1353", "CFM_026", "CFM_061", "CFM_062", "CFM_063", "CFM_064", "CFM_067", "CFM_084_Slush", "CFM_095", "CFM_120", "CFM_305", "CFM_308", "CFM_308a", "CFM_310", "CFM_312", "CFM_313", "CFM_315", "CFM_316", "CFM_321", "CFM_334", "CFM_336", "CFM_338", "CFM_343", "CFM_344", "CFM_602", "CFM_602a", "CFM_602b", "CFM_604", "CFM_605", "CFM_606", "CFM_610", "CFM_611", "CFM_614", "CFM_616", "CFM_619", "CFM_620", "CFM_621t10", "CFM_621t17", "CFM_621t20", "CFM_621t22", "CFM_621t23", "CFM_621t24", "CFM_621t26", "CFM_621t28", "CFM_621t3", "CFM_621t30", "CFM_621t31", "CFM_621t32", "CFM_621t37", "CFM_621t38", "CFM_621t39", "CFM_621t6", "CFM_621t8", "CFM_621t9", "CFM_626", "CFM_630", "CFM_639", "CFM_643", "CFM_648", "CFM_649", "CFM_650", "CFM_651", "CFM_654", "CFM_659", "CFM_660", "CFM_661", "CFM_663", "CFM_668", "CFM_668t", "CFM_668t2", "CFM_669", "CFM_672", "CFM_685", "CFM_691", "CFM_694", "CFM_713", "CFM_715", "CFM_717", "CFM_750", "CFM_752", "CFM_753", "CFM_754", "CFM_755", "CFM_800", "CFM_806", "CFM_811", "CFM_816", "CFM_852", "CFM_853", "CFM_902", "CFM_905", "CFM_940", "CORE_AT_029", "CORE_AT_047", "CORE_AT_055", "CORE_AT_061", "CORE_BOT_083", "CORE_BOT_420", "CORE_BOT_533", "CORE_BRM_006", "CORE_BT_035", "CORE_BT_036", "CORE_BT_416", "CORE_BT_427", "CORE_BT_480", "CORE_BT_491", "CORE_CFM_120", "CORE_CFM_605", "CORE_CS2_009", "CORE_CS2_013", "CORE_CS2_023", "CORE_CS2_039", "CORE_CS2_045", "CORE_CS2_046", "CORE_CS2_053", "CORE_CS2_073", "CORE_CS2_074", "CORE_CS2_077", "CORE_CS2_088", "CORE_CS2_089", "CORE_CS2_092", "CORE_CS2_117", "CORE_CS2_188", "CORE_CS3_002", "CORE_CS3_009", "CORE_CS3_029", "CORE_DAL_416", "CORE_DAL_609", "CORE_DRG_226", "CORE_DRG_229", "CORE_DS1_184", "CORE_EX1_004", "CORE_EX1_011", "CORE_EX1_012", "CORE_EX1_014", "CORE_EX1_043", "CORE_EX1_046", "CORE_EX1_059", "CORE_EX1_084", "CORE_EX1_093", "CORE_EX1_096", "CORE_EX1_103", "CORE_EX1_110", "CORE_EX1_130", "CORE_EX1_145", "CORE_EX1_158", "CORE_EX1_160", "CORE_EX1_164", "CORE_EX1_165", "CORE_EX1_169", "CORE_EX1_178", "CORE_EX1_188", "CORE_EX1_189", "CORE_EX1_190", "CORE_EX1_193", "CORE_EX1_194", "CORE_EX1_195", "CORE_EX1_248", "CORE_EX1_284", "CORE_EX1_287", "CORE_EX1_289", "CORE_EX1_294", "CORE_EX1_362", "CORE_EX1_506", "CORE_EX1_509", "CORE_EX1_534", "CORE_EX1_554", "CORE_EX1_571", "CORE_EX1_573", "CORE_EX1_575", "CORE_EX1_606", "CORE_EX1_611", "CORE_EX1_623", "CORE_FP1_007", "CORE_FP1_011", "CORE_FP1_020", "CORE_GIL_191", "CORE_GIL_598", "CORE_GIL_828", "CORE_GVG_053", "CORE_ICC_018", "CORE_ICC_019", "CORE_ICC_025", "CORE_ICC_026", "CORE_ICC_027", "CORE_ICC_028", "CORE_ICC_029", "CORE_ICC_034", "CORE_ICC_039", "CORE_ICC_050", "CORE_ICC_052", "CORE_ICC_054", "CORE_ICC_056", "CORE_ICC_065", "CORE_ICC_069", "CORE_ICC_079", "CORE_ICC_082", "CORE_ICC_086", "CORE_ICC_089", "CORE_ICC_091", "CORE_ICC_092", "CORE_ICC_093", "CORE_ICC_094", "CORE_ICC_200", "CORE_ICC_201", "CORE_ICC_206", "CORE_ICC_207", "CORE_ICC_210", "CORE_ICC_213", "CORE_ICC_215", "CORE_ICC_221", "CORE_ICC_235", "CORE_ICC_257", "CORE_ICC_281", "CORE_ICC_289", "CORE_ICC_314", "CORE_ICC_415", "CORE_ICC_450", "CORE_ICC_466", "CORE_ICC_467", "CORE_ICC_702", "CORE_ICC_705", "CORE_ICC_801", "CORE_ICC_807", "CORE_ICC_808", "CORE_ICC_809", "CORE_ICC_810", "CORE_ICC_812", "CORE_ICC_823", "CORE_ICC_827", "CORE_ICC_831", "CORE_ICC_832", "CORE_ICC_833", "CORE_ICC_835", "CORE_ICC_838", "CORE_ICC_900", "CORE_ICC_903", "CORE_ICC_904", "CORE_ICC_912", "CORE_KAR_009", "CORE_KAR_065", "CORE_KAR_069", "CORE_LOE_012", "CORE_LOE_039", "CORE_LOE_050", "CORE_LOE_079", "CORE_LOOT_413", "CORE_LOOT_516", "CORE_NEW1_008", "CORE_NEW1_018", "CORE_NEW1_026", "CORE_NEW1_031", "CORE_OG_047", "CORE_OG_070", "CORE_OG_109", "CORE_OG_229", "CORE_OG_241", "CORE_OG_273", "CORE_TRL_243", "CORE_TRL_307", "CORE_ULD_191", "CORE_ULD_209", "CORE_UNG_020", "CORE_UNG_108", "CORE_UNG_963", "CRED_02", "CRED_04", "CRED_09", "CRED_103", "CRED_106", "CRED_107", "CRED_109", "CRED_11", "CRED_110", "CRED_111", "CRED_115", "CRED_12", "CRED_127", "CRED_13", "CRED_130", "CRED_145", "CRED_146", "CRED_152", "CRED_156", "CRED_159", "CRED_160", "CRED_164", "CRED_177", "CRED_183", "CRED_187", "CRED_190", "CRED_192", "CRED_197", "CRED_198", "CRED_199", "CRED_20", "CRED_201", "CRED_203", "CRED_207", "CRED_209", "CRED_213", "CRED_226", "CRED_242", "CRED_246", "CRED_249", "CRED_25", "CRED_251", "CRED_256", "CRED_260", "CRED_264", "CRED_276", "CRED_28", "CRED_37", "CRED_41", "CRED_51", "CRED_53", "CRED_57", "CRED_59", "CRED_74", "CRED_75", "CRED_77", "CRED_79", "CRED_80", "CRED_82", "CRED_89", "CRED_90", "CRED_91", "CRED_92", "CRED_94", "CRED_95", "CRED_99", "CS1h_001_H1", "CS1h_001_H1_AT_132", "CS1h_001_H2", "CS1h_001_H2_AT_132", "CS1h_001_H3", "CS2_003", "CS2_004", "CS2_004_Puzzle", "CS2_005", "CS2_007", "CS2_009", "CS2_011", "CS2_013", "CS2_013t", "CS2_023", "CS2_027", "CS2_038", "CS2_039", "CS2_041", "CS2_045", "CS2_046", "CS2_049_H1", "CS2_049_H1_AT_132", "CS2_049_H2", "CS2_049_H2_AT_132", "CS2_049_H3", "CS2_049_H3_AT_132", "CS2_049_H4", "CS2_049_H4_AT_132", "CS2_049_H5", "CS2_053", "CS2_053e", "CS2_056_H1", "CS2_056_H2", "CS2_056_H3", "CS2_058", "CS2_059", "CS2_073", "CS2_074", "CS2_077", "CS2_087", "CS2_088", "CS2_089", "CS2_092", "CS2_101_H1", "CS2_101_H1_AT_132", "CS2_101_H2", "CS2_101_H2_AT_132", "CS2_101_H3", "CS2_101_H3_AT_132", "CS2_101_H4", "CS2_102_H1", "CS2_102_H1_AT_132", "CS2_102_H2", "CS2_102_H2_AT_132", "CS2_102_H3", "CS2_102_H3_AT_132", "CS2_102_H4", "CS2_102_H4_AT_132", "CS2_103", "CS2_104", "CS2_105", "CS2_117", "CS2_147", "CS2_151", "CS2_188", "CS2_196", "CS2_226", "CS2_236", "CS2_237", "CS3_002", "CS3_005", "CS3_008e", "CS3_009", "CS3_012e", "CS3_015", "CS3_017", "CS3_024", "CS3_028", "CS3_029", "CS3_033", "CS3_034", "DAL_007", "DAL_008", "DAL_010", "DAL_040", "DAL_049", "DAL_059", "DAL_060", "DAL_062", "DAL_064", "DAL_070", "DAL_077", "DAL_078", "DAL_087", "DAL_088", "DAL_095", "DAL_141", "DAL_141ts", "DAL_146", "DAL_147", "DAL_163", "DAL_256", "DAL_256ts", "DAL_350b", "DAL_351", "DAL_351ts", "DAL_352", "DAL_354", "DAL_355", "DAL_357", "DAL_376", "DAL_377", "DAL_378", "DAL_378ts", "DAL_400", "DAL_413", "DAL_415", "DAL_416", "DAL_422", "DAL_432", "DAL_433", "DAL_544", "DAL_550", "DAL_553", "DAL_554", "DAL_558", "DAL_560", "DAL_563", "DAL_565", "DAL_568", "DAL_568ts", "DAL_570", "DAL_575", "DAL_578", "DAL_579p", "DAL_581", "DAL_582", "DAL_582t", "DAL_587", "DAL_589", "DAL_602", "DAL_604", "DAL_606", "DAL_607", "DAL_608", "DAL_609", "DAL_613", "DAL_710", "DAL_710e", "DAL_720", "DAL_721", "DAL_724", "DAL_727", "DAL_729", "DAL_731", "DAL_733", "DAL_736", "DAL_739", "DAL_741", "DAL_743", "DAL_747", "DAL_752", "DAL_773", "DAL_774", "DAL_799", "DAL_COIN", "DALA_702", "DALA_703", "DALA_704", "DALA_705", "DALA_707", "DALA_708", "DALA_711", "DALA_716", "DALA_717", "DALA_719", "DALA_721", "DALA_725", "DALA_727", "DALA_733", "DALA_736", "DALA_737", "DALA_738", "DALA_740ts5", "DALA_741", "DALA_741e", "DALA_743", "DALA_747e", "DALA_829t", "DALA_854", "DALA_854e", "DALA_854e2", "DALA_902", "DALA_905", "DALA_907", "DALA_908", "DALA_910", "DALA_913", "DALA_BOSS_03p", "DALA_BOSS_03px", "DALA_BOSS_03t3", "DALA_BOSS_03t4", "DALA_BOSS_04p", "DALA_BOSS_05p", "DALA_BOSS_06p", "DALA_BOSS_06px", "DALA_BOSS_09p", "DALA_BOSS_09px", "DALA_BOSS_14p", "DALA_BOSS_14px", "DALA_BOSS_16p", "DALA_BOSS_16px", "DALA_BOSS_18p", "DALA_BOSS_18px", "DALA_BOSS_25t", "DALA_BOSS_27p", "DALA_BOSS_30p", "DALA_BOSS_31p", "DALA_BOSS_31px", "DALA_BOSS_32p", "DALA_BOSS_34p", "DALA_BOSS_37p", "DALA_BOSS_37px", "DALA_BOSS_38p", "DALA_BOSS_38px", "DALA_BOSS_38t", "DALA_BOSS_39p", "DALA_BOSS_41p", "DALA_BOSS_41px", "DALA_BOSS_42p", "DALA_BOSS_42px", "DALA_BOSS_44p", "DALA_BOSS_44px", "DALA_BOSS_46p", "DALA_BOSS_46px", "DALA_BOSS_47p", "DALA_BOSS_47px", "DALA_BOSS_51p", "DALA_BOSS_52p", "DALA_BOSS_52px", "DALA_BOSS_53p", "DALA_BOSS_53px", "DALA_BOSS_55p", "DALA_BOSS_55px", "DALA_BOSS_56p", "DALA_BOSS_60p", "DALA_BOSS_60px", "DALA_BOSS_62p", "DALA_BOSS_66p", "DALA_BOSS_67p", "DALA_BOSS_68p", "DALA_BOSS_68px", "DALA_BOSS_69p", "DALA_BOSS_69px", "DALA_BOSS_71p", "DALA_BOSS_71px", "DALA_BOSS_73p", "DALA_BOSS_73px", "DALA_BOSS_74p", "DALA_BOSS_74px", "DALA_BOSS_75p", "DALA_Druid_HP1", "DALA_Druid_HP2", "DALA_Hunter_HP1", "DALA_Hunter_HP2", "DALA_Paladin_HP1", "DALA_Paladin_HP2", "DALA_Priest_HP1", "DALA_Priest_HP2", "DALA_Shaman_HP2", "DALA_Warlock_HP2", "DALA_Warrior_HP2", "DE_104", "DE_105", "DE_110", "DE_116", "DE_122", "DE_999", "DE_JC_001", "DED_002", "DED_003", "DED_005", "DED_009", "DED_500", "DED_504", "DED_505", "DED_506", "DED_508", "DED_510", "DED_511", "DED_512", "DED_514", "DED_514e", "DED_516", "DED_524", "DMF_002", "DMF_004t1", "DMF_004t2", "DMF_053", "DMF_055", "DMF_056", "DMF_057e", "DMF_057o", "DMF_058", "DMF_058e", "DMF_058o", "DMF_061", "DMF_061a", "DMF_061b", "DMF_061t", "DMF_064", "DMF_065t", "DMF_069", "DMF_073", "DMF_075", "DMF_080", "DMF_083", "DMF_084", "DMF_086", "DMF_088", "DMF_089", "DMF_090", "DMF_090t", "DMF_091", "DMF_100", "DMF_104", "DMF_105", "DMF_105t", "DMF_106", "DMF_107", "DMF_109", "DMF_111", "DMF_113", "DMF_119", "DMF_121", "DMF_122", "DMF_123", "DMF_124", "DMF_124t", "DMF_125", "DMF_163", "DMF_184", "DMF_186", "DMF_186a", "DMF_189", "DMF_194", "DMF_195", "DMF_202", "DMF_219", "DMF_223", "DMF_224", "DMF_224e", "DMF_229", "DMF_235", "DMF_236", "DMF_237", "DMF_238", "DMF_244", "DMF_244t", "DMF_247", "DMF_249", "DMF_254t5", "DMF_511e", "DMF_512", "DMF_513", "DMF_514", "DMF_514t", "DMF_515", "DMF_516", "DMF_517", "DMF_520", "DMF_523", "DMF_525", "DMF_526", "DMF_526a", "DMF_530", "DMF_531", "DMF_534", "DMF_703", "DMF_703t", "DMF_704", "DMF_706", "DMF_707", "DMF_709", "DMF_730", "DMF_730t", "DMF_732", "DMF_733", "DMF_734", "DMF_734e", "DMF_COIN1", "DMF_COIN2", "DRG_008", "DRG_010", "DRG_019", "DRG_020", "DRG_024", "DRG_028", "DRG_030", "DRG_031", "DRG_033", "DRG_035", "DRG_036", "DRG_036t", "DRG_049", "DRG_051", "DRG_052", "DRG_054", "DRG_060", "DRG_064", "DRG_070", "DRG_071", "DRG_072", "DRG_074", "DRG_075", "DRG_077", "DRG_084", "DRG_086", "DRG_091", "DRG_099", "DRG_099t2", "DRG_099t3", "DRG_102", "DRG_104", "DRG_107", "DRG_202", "DRG_207", "DRG_208", "DRG_215", "DRG_217", "DRG_224", "DRG_225", "DRG_226", "DRG_229", "DRG_233", "DRG_235", "DRG_235e", "DRG_238p", "DRG_238p3", "DRG_238p4", "DRG_238p5", "DRG_250", "DRG_251", "DRG_254", "DRG_255", "DRG_258", "DRG_270", "DRG_270t1", "DRG_270t2", "DRG_301", "DRG_302", "DRG_302e", "DRG_308", "DRG_308e", "DRG_311", "DRG_311a", "DRG_311b", "DRG_312", "DRG_313", "DRG_314", "DRG_315", "DRG_317", "DRG_318", "DRG_320", "DRG_320t", "DRG_323", "DRG_324", "DRG_401", "DRG_401e", "DRG_402", "DRG_610", "DRG_610t2", "DRG_610t3", "DRG_620", "DRG_620t2", "DRG_620t3", "DRG_650", "DRG_650t2", "DRG_650t3", "DRG_COIN", "DRGA_002", "DRGA_011ts5", "DRGA_01q", "DRGA_06", "DRGA_099t3", "DRGA_BOSS_02t", "DRGA_BOSS_02t3", "DRGA_BOSS_02tt", "DRGA_BOSS_03p", "DRGA_BOSS_03p_H", "DRGA_BOSS_03t", "DRGA_BOSS_03t2", "DRGA_BOSS_05p", "DRGA_BOSS_05p_H", "DRGA_BOSS_05t", "DRGA_BOSS_06t2", "DRGA_BOSS_07p", "DRGA_BOSS_07p4", "DRGA_BOSS_07t", "DRGA_BOSS_08p", "DRGA_BOSS_08p_H", "DRGA_BOSS_08t", "DRGA_BOSS_08t2", "DRGA_BOSS_09p", "DRGA_BOSS_09p_H", "DRGA_BOSS_09t2", "DRGA_BOSS_11p", "DRGA_BOSS_11p_H", "DRGA_BOSS_11t", "DRGA_BOSS_12p", "DRGA_BOSS_12p_H", "DRGA_BOSS_12t", "DRGA_BOSS_13p", "DRGA_BOSS_13p_H", "DRGA_BOSS_15p", "DRGA_BOSS_18p", "DRGA_BOSS_18p_H", "DRGA_BOSS_21p", "DRGA_BOSS_21t2", "DRGA_BOSS_22p", "DRGA_BOSS_22p_H", "DRGA_BOSS_25p", "DRGA_BOSS_25p_H", "DRGA_BOSS_27p", "DRGA_BOSS_27p_H", "DRGA_BOSS_29p", "DRGA_BOSS_30p", "DRGA_BOSS_30p_H", "DRGA_BOSS_30t2", "DRGA_BOSS_30t4", "DRGA_BOSS_30t6", "DRGA_BOSS_30t7", "DRGA_BOSS_31p", "DRGA_BOSS_31p_H", "DRGA_BOSS_31p2", "DRGA_BOSS_35p", "DRGA_BOSS_36p", "DRGA_BOSS_37p", "DRGA_BOSS_38p", "DS1_055", "DS1_070", "DS1_184", "EX1_004", "EX1_011", "EX1_012", "EX1_014", "EX1_014t", "EX1_015", "EX1_019", "EX1_025", "EX1_043", "EX1_046", "EX1_058", "EX1_059", "EX1_076", "EX1_084", "EX1_089", "EX1_093", "EX1_096", "EX1_103", "EX1_110", "EX1_112", "EX1_116", "EX1_128", "EX1_130", "EX1_131", "EX1_132", "EX1_136", "EX1_145", "EX1_145e", "EX1_145o", "EX1_155", "EX1_155a", "EX1_155b", "EX1_158", "EX1_158e", "EX1_160", "EX1_160a", "EX1_160b", "EX1_164", "EX1_164a", "EX1_164b", "EX1_165", "EX1_169", "EX1_178", "EX1_180", "EX1_181", "EX1_182", "EX1_183", "EX1_184", "EX1_188", "EX1_189", "EX1_190", "EX1_191", "EX1_192", "EX1_193", "EX1_194", "EX1_195", "EX1_196", "EX1_244", "EX1_248", "EX1_284", "EX1_287", "EX1_289", "EX1_294", "EX1_295", "EX1_303", "EX1_316", "EX1_317", "EX1_339", "EX1_345", "EX1_349", "EX1_350", "EX1_354", "EX1_355", "EX1_362", "EX1_363", "EX1_365", "EX1_366", "EX1_371", "EX1_379", "EX1_392", "EX1_409", "EX1_506", "EX1_509", "EX1_533", "EX1_534", "EX1_538", "EX1_549", "EX1_554", "EX1_556", "EX1_562", "EX1_570", "EX1_571", "EX1_572", "EX1_573", "EX1_573a", "EX1_573b", "EX1_575", "EX1_577", "EX1_583", "EX1_584", "EX1_587", "EX1_590", "EX1_597", "EX1_606", "EX1_611", "EX1_613", "EX1_614", "EX1_621", "EX1_623", "EX1_tk33", "EX1_tk33_2_TB", "EXP_003", "EXP_013", "EXP_102", "EXP_103", "EXP_105", "FB_Annoyo_001", "FB_BuildABrawl001a", "FB_BuildABrawl001c", "FB_BuildABrawl001c_ench", "FB_BuildABrawl002a", "FB_BuildABrawl002a_ench", "FB_BuildABrawl002b", "FB_BuildABrawl002b_ench", "FB_BuildABrawl002c", "FB_BuildABrawl003b", "FB_Champs_CS2_013", "FB_Champs_CS2_073", "FB_Champs_CS2_188", "FB_Champs_DAL_736", "FB_Champs_EX1_164", "FB_Champs_EX1_165", "FB_Champs_EX1_169", "FB_Champs_EX1_556", "FB_Champs_EX1_571", "FB_Champs_FP1_028", "FB_Champs_ICC_221", "FB_Champs_ICC_466", "FB_Champs_ICC_705", "FB_Champs_LOOT_017", "FB_Champs_LOOT_080", "FB_Champs_LOOT_080t2", "FB_Champs_LOOT_080t3", "FB_Champs_LOOT_093", "FB_Champs_LOOT_306", "FB_Champs_LOOT_333", "FB_Champs_LOOT_539", "FB_Champs_NEW1_008", "FB_Champs_NEW1_008a", "FB_Champs_NEW1_008b", "FB_Champs_UNG_067", "FB_ELO002", "FB_ELO002_copy", "FB_ELO002a_copy", "FB_ELO002a_ench_copy", "FB_ELO002c", "FB_ELO002c_copy", "FB_ELO002c_ench", "FB_ELO002c_ench_copy", "FB_ExpansionDraft_001a", "FB_ExpansionDraft_001b", "FB_ExpansionDraft_001c", "FB_ExpansionDraft_001d", "FB_ExpansionDraft_002a", "FB_ExpansionDraft_002b", "FB_ExpansionDraft_002c", "FB_LK001", "FB_LK002", "FB_LK006", "FB_RagRaid_DeckRefresh", "FB_RagRaid_Draw", "FB_RagRaid_InnkeeperReset", "FB_SPT_Annoyo_HP", "FB_SPT_Annoyo_HP_0", "FB_SPT_Annoyo_HP_1", "FB_Toki_Boss_mental", "FB_Toki_BossSpell_01", "FB_Toki_ForceSwapSides", "FB_Toki_HeroPower", "FB_Toki_IncreaseHealth", "FB_Toki_Quest", "FB_Toki_SummonParadoxes", "FB_Toki_TimePortal_Reload", "FB_Toki2_Hero", "FB_WI_GetLoot_Ench", "FP1_001", "FP1_002", "FP1_003", "FP1_007", "FP1_011", "FP1_012", "FP1_013", "FP1_014", "FP1_015", "FP1_018", "FP1_020", "FP1_023", "FP1_028", "GAME_005", "GIL_116", "GIL_118", "GIL_128", "GIL_145", "GIL_188", "GIL_190", "GIL_191", "GIL_198", "GIL_203", "GIL_408t5", "GIL_507", "GIL_508", "GIL_513", "GIL_515", "GIL_531", "GIL_537", "GIL_540", "GIL_540_test", "GIL_548", "GIL_553", "GIL_557", "GIL_571", "GIL_577", "GIL_578", "GIL_580", "GIL_581", "GIL_584", "GIL_586", "GIL_598", "GIL_607", "GIL_608", "GIL_616", "GIL_616t", "GIL_620", "GIL_637", "GIL_646", "GIL_653", "GIL_661", "GIL_663", "GIL_664", "GIL_665", "GIL_667", "GIL_677", "GIL_682", "GIL_683", "GIL_696", "GIL_803", "GIL_805", "GIL_813", "GIL_815", "GIL_816", "GIL_819", "GIL_820", "GIL_827", "GIL_828", "GIL_833", "GIL_835", "GIL_836", "GIL_902", "GIL_903", "GIL_COIN", "GILA_400p", "GILA_401", "GILA_410", "GILA_411", "GILA_412", "GILA_500p2", "GILA_503e", "GILA_506", "GILA_506t", "GILA_513", "GILA_610", "GILA_802", "GILA_806", "GILA_811", "GILA_816a", "GILA_816b", "GILA_816c", "GILA_817", "GILA_818", "GILA_819", "GILA_824", "GILA_825", "GILA_825e", "GILA_827", "GILA_850b", "GILA_852a", "GILA_852b", "GILA_852c", "GILA_853b", "GILA_903", "GILA_906", "GILA_BOSS_20p", "GILA_BOSS_21p", "GILA_BOSS_23p", "GILA_BOSS_27p", "GILA_BOSS_31p", "GILA_BOSS_32p", "GILA_BOSS_33p", "GILA_BOSS_35p", "GILA_BOSS_37e2", "GILA_BOSS_37p", "GILA_BOSS_37t", "GILA_BOSS_38p", "GILA_BOSS_40p", "GILA_BOSS_43p", "GILA_BOSS_43t", "GILA_BOSS_48p", "GILA_BOSS_49t", "GILA_BOSS_52p", "GILA_BOSS_52p2", "GILA_BOSS_55p", "GILA_BOSS_57t", "GILA_BOSS_58p", "GILA_BOSS_60p", "GILA_BOSS_60t", "GILA_BOSS_99t", "GILA_BOSS_99t2", "GILA_BOSS_99t3", "GVG_003", "GVG_005", "GVG_010", "GVG_011", "GVG_012", "GVG_014", "GVG_017", "GVG_022", "GVG_023", "GVG_025", "GVG_026", "GVG_027", "GVG_028t", "GVG_029", "GVG_030", "GVG_031", "GVG_032", "GVG_032a", "GVG_033", "GVG_034", "GVG_035", "GVG_036", "GVG_039", "GVG_041", "GVG_041b", "GVG_042", "GVG_043", "GVG_046", "GVG_048", "GVG_053", "GVG_055", "GVG_056", "GVG_057", "GVG_059", "GVG_060", "GVG_061", "GVG_062", "GVG_069", "GVG_078", "GVG_082", "GVG_083", "GVG_092", "GVG_096", "GVG_097", "GVG_102", "GVG_104", "GVG_105", "GVG_107", "GVG_110", "GVG_114", "GVG_115", "GVG_116", "GVG_117", "GVG_118", "HERO_01bp", "HERO_01bp2", "HERO_01dbp", "HERO_01dbp2", "HERO_01fbp", "HERO_01fbp2", "HERO_01obp", "HERO_01obp2", "HERO_01qbp", "HERO_01qbp2", "HERO_01vbp", "HERO_01vbp2", "HERO_01wbp", "HERO_01wbp2", "HERO_02bp", "HERO_02bp2", "HERO_02fbp", "HERO_02fbp2", "HERO_02mbp", "HERO_02mbp2", "HERO_04bp", "HERO_04bp2", "HERO_04ebp", "HERO_04ebp2", "HERO_04fbp", "HERO_04fbp2", "HERO_04fbp3", "HERO_04lbp", "HERO_04lbp2", "HERO_04ubp", "HERO_04ubp2", "HERO_04wbp", "HERO_04wbp2", "HERO_07bp", "HERO_07bp2", "HERO_07dbp", "HERO_07dbp2", "HERO_07ebp", "HERO_07ebp2", "HERO_07ybp", "HERO_07ybp2", "HERO_09bp", "HERO_09bp2", "HERO_09dbp", "HERO_09dbp2", "ICC_018", "ICC_019", "ICC_025", "ICC_026", "ICC_027", "ICC_028", "ICC_029", "ICC_034", "ICC_039", "ICC_047a", "ICC_050", "ICC_052", "ICC_054", "ICC_056", "ICC_065", "ICC_069", "ICC_079", "ICC_082", "ICC_086", "ICC_089", "ICC_091", "ICC_092", "ICC_093", "ICC_094", "ICC_200", "ICC_201", "ICC_206", "ICC_207", "ICC_210", "ICC_213", "ICC_215", "ICC_221", "ICC_235", "ICC_257", "ICC_281", "ICC_289", "ICC_314", "ICC_314t1", "ICC_314t2", "ICC_314t4", "ICC_314t7", "ICC_415", "ICC_450", "ICC_466", "ICC_467", "ICC_702", "ICC_705", "ICC_801", "ICC_807", "ICC_808", "ICC_809", "ICC_810", "ICC_812", "ICC_823", "ICC_827", "ICC_827p", "ICC_829p", "ICC_831", "ICC_832", "ICC_832a", "ICC_832b", "ICC_832p", "ICC_833", "ICC_835", "ICC_838", "ICC_900", "ICC_903", "ICC_904", "ICC_912", "ICC_COIN", "ICCA01_004", "ICCA01_009", "ICCA05_002p", "ICCA06_002p", "ICCA08_002p", "ICCA08_027", "KAR_002", "KAR_003", "KAR_003a", "KAR_003b", "KAR_004", "KAR_005", "KAR_009", "KAR_010", "KAR_021", "KAR_025", "KAR_026", "KAR_029", "KAR_030a", "KAR_044", "KAR_057", "KAR_061", "KAR_062", "KAR_065", "KAR_069", "KAR_072", "KAR_075", "KAR_077", "KAR_090", "KAR_091", "KAR_094", "KAR_095", "KAR_114", "KAR_204", "KAR_205", "KAR_702", "KAR_710", "KAR_A01_02", "KAR_A02_06", "KAR_A02_06H", "KAR_A02_09", "KAR_A02_09H", "KAR_A02_10", "KAR_A02_11", "KAR_A02_13", "KAR_A02_13H", "KAR_A10_05", "KAR_A10_06", "KAR_A10_22", "KARA_00_02", "KARA_00_02H", "KARA_00_04", "KARA_00_04H", "KARA_00_07", "KARA_00_09", "KARA_00_11", "KARA_06_03hp", "KARA_06_03hpheroic", "KARA_07_03", "KARA_07_03heroic", "KARA_07_05", "KARA_07_05heroic", "KARA_07_06", "KARA_07_06heroic", "KARA_07_07", "KARA_07_07heroic", "KARA_07_08", "KARA_07_08heroic", "KARA_08_02", "KARA_08_02H", "KARA_08_04", "KARA_09_03", "KARA_09_03heroic", "KARA_09_05", "KARA_09_05heroic", "KARA_13_02", "KARA_13_02H", "KARA_13_12", "KARA_13_12H", "KARA_13_13", "KARA_13_13H", "KARA_13_23", "LETL_001P5_01", "LETL_001P5_02", "LETL_001P5_03", "LETL_001P5_04", "LETL_001P5_05", "LETL_002P2_01", "LETL_002P2_02", "LETL_002P2_03", "LETL_002P2_03e2", "LETL_002P2_04", "LETL_002P2_05", "LETL_002P4_01", "LETL_002P4_02", "LETL_002P4_03", "LETL_002P4_04", "LETL_002P4_05", "LETL_002P5_01", "LETL_002P5_02", "LETL_002P5_03", "LETL_002P5_04", "LETL_002P5_05", "LETL_002P7_02", "LETL_002P7_03", "LETL_002P7_04", "LETL_002P7_05", "LETL_003P1e", "LETL_004P1_01", "LETL_004P1_02", "LETL_004P1_03", "LETL_004P1_04", "LETL_004P1_05", "LETL_009P9_01", "LETL_009P9_02", "LETL_009P9_03", "LETL_009P9_04", "LETL_009P9_05", "LETL_012P4_01", "LETL_012P4_02", "LETL_012P4_03", "LETL_012P4_04", "LETL_012P4_05", "LETL_012P7_01", "LETL_012P7_02", "LETL_012P7_03", "LETL_012P7_04", "LETL_012P7_05", "LETL_014P6_01", "LETL_014P6_02", "LETL_014P6_03", "LETL_014P6_04", "LETL_014P6_05", "LETL_019E2_01", "LETL_019E2_02", "LETL_019E2_03", "LETL_019E2_04", "LETL_019P1_01", "LETL_019P1_02", "LETL_019P1_03", "LETL_019P1_04", "LETL_019P1_05", "LETL_020P6_01", "LETL_020P6_02", "LETL_020P6_03", "LETL_020P6_04", "LETL_020P6_05", "LETL_021P1_01", "LETL_021P1_02", "LETL_021P1_03", "LETL_021P1_04", "LETL_021P1_05", "LETL_022P1_01", "LETL_022P1_01m", "LETL_022P1_02", "LETL_022P1_02m", "LETL_022P1_03", "LETL_022P1_03m", "LETL_024E2_04", "LETL_024E2e", "LETL_024P2_01", "LETL_024P2_01t", "LETL_024P2_01t2", "LETL_024P2_02", "LETL_024P2_02t", "LETL_024P2_02t2", "LETL_024P2_03", "LETL_024P2_03t", "LETL_024P2_03t2", "LETL_024P2_04", "LETL_024P2_04t", "LETL_024P2_04t2", "LETL_024P2_05", "LETL_024P2_05t", "LETL_024P2_05t2", "LETL_024P3_01", "LETL_024P3_02", "LETL_024P3_03", "LETL_024P3_04", "LETL_024P3_05", "LETL_025P7_01", "LETL_025P7_02", "LETL_025P7_03", "LETL_027P3_01", "LETL_027P3_01m", "LETL_027P3_02", "LETL_027P3_02m", "LETL_027P3_03", "LETL_027P3_03m", "LETL_027P3_04", "LETL_027P3_04m", "LETL_027P3_05", "LETL_027P3_05m", "LETL_029P11_01", "LETL_029P11_02", "LETL_029P11_03", "LETL_029P12_01", "LETL_029P12_02", "LETL_029P12_03", "LETL_029P12_04", "LETL_029P12_05", "LETL_032P4_01", "LETL_032P4_02", "LETL_032P4_03", "LETL_032P4_04", "LETL_032P4_05", "LETL_032P5_01", "LETL_032P5_02", "LETL_032P5_03", "LETL_032P5_04", "LETL_032P5_05", "LETL_034P1_01", "LETL_034P1_01e", "LETL_034P1_02", "LETL_034P1_02e", "LETL_034P1_03", "LETL_034P1_03e", "LETL_034P1_04", "LETL_034P1_04e", "LETL_034P1_T_01", "LETL_034P1_T_02", "LETL_034P1_T_03", "LETL_034P1_T_04", "LETL_034P3_01", "LETL_034P3_02", "LETL_034P3_03", "LETL_034P3_04", "LETL_034P3_05", "LETL_036P4_01", "LETL_036P4_02", "LETL_036P4_03", "LETL_037P2_01", "LETL_037P2_02", "LETL_037P2_03", "LETL_037P2_04", "LETL_037P2_05", "LETL_040P5_02", "LETL_040P5_03", "LETL_040P5_04", "LETL_040P9_01", "LETL_040P9_02", "LETL_040P9_03", "LETL_040P9_04", "LETL_040P9_05", "LETL_1020_01", "LETL_1052_01", "LETL_1061_01", "LETL_1100_01", "LETL_1100_02", "LETL_1100_03", "LETL_1100_04", "LETL_1100_05", "LETL_1101_01", "LETL_1101_02", "LETL_1101_03", "LETL_1101_04", "LETL_1101_05", "LETL_1105_01", "LETL_1109_01", "LETL_1109e", "LETL_1115_01", "LETL_1118_01", "LETL_1128_01", "LETL_1128_02", "LETL_1129", "LETL_1132", "LETL_1138_01", "LETL_1138_01m", "LETL_1138_02", "LETL_1138_02m", "LETL_1138_03", "LETL_1138_03m", "LETL_1138_04", "LETL_1138_04m", "LETL_1138_05", "LETL_1138_05m", "LETL_1146_01", "LETL_1146_02", "LETL_1146_03", "LETL_1146_04", "LETL_1146_05", "LETL_220_01", "LETL_220_02", "LETL_220_03", "LETL_220_04", "LETL_220_05", "LETL_224_01", "LETL_224_02", "LETL_224_03", "LETL_224_04", "LETL_224_05", "LETL_233_01", "LETL_233_02", "LETL_233_03", "LETL_233_04", "LETL_233_05", "LETL_250_01", "LETL_250_02", "LETL_250_03", "LETL_250_04", "LETL_250_05", "LETL_253_01", "LETL_253_02", "LETL_253_03", "LETL_253_04", "LETL_253_T_01", "LETL_253_T_02", "LETL_253_T_03", "LETL_253_T_04", "LETL_253e", "LETL_258_01", "LETL_258_02", "LETL_258_03", "LETL_258_04", "LETL_258_05", "LETL_263_01", "LETL_263_01x", "LETL_263_01y", "LETL_263_01z", "LETL_263_02", "LETL_263_02x", "LETL_263_02y", "LETL_263_02z", "LETL_263_03", "LETL_263_03x", "LETL_263_03y", "LETL_263_03z", "LETL_263_04", "LETL_263_04x", "LETL_263_04y", "LETL_263_04z", "LETL_263_05", "LETL_263_05x", "LETL_263_05y", "LETL_263_05z", "LETL_266_01", "LETL_266_02", "LETL_266_03", "LETL_266_04", "LETL_266_T_01", "LETL_266_T_02", "LETL_266_T_03", "LETL_266_T_04", "LETL_266e", "LETL_274_01", "LETL_274_02", "LETL_274_03", "LETL_274_04", "LETL_274_05", "LETL_276_01", "LETL_276_02", "LETL_276_03", "LETL_276_04", "LETL_276_05", "LETL_279_01", "LETL_279_02", "LETL_279_03", "LETL_279_04", "LETL_280_01", "LETL_280_02", "LETL_280_03", "LETL_280_04", "LETL_280_05", "LETL_282_01", "LETL_282_02", "LETL_282_03", "LETL_282_04", "LETL_282_05", "LETL_309_01", "LETL_309_02", "LETL_309_03", "LETL_309_04", "LETL_309_05", "LETL_318_01", "LETL_318_02", "LETL_318_03", "LETL_318_04", "LETL_318_05", "LETL_319_01", "LETL_319_02", "LETL_319_03", "LETL_319_04", "LETL_319_05", "LETL_330_01", "LETL_330_02", "LETL_330_03", "LETL_330_04", "LETL_330_05", "LETL_342_01", "LETL_342_02", "LETL_342_03", "LETL_342_04", "LETL_342_05", "LETL_343_01", "LETL_343_02", "LETL_343_03", "LETL_343_04", "LETL_343_04e", "LETL_375_04", "LETL_391_01", "LETL_391_02", "LETL_391_03", "LETL_391_04", "LETL_391_05", "LETL_391e", "LETL_406_01", "LETL_406_02", "LETL_406_03", "LETL_406_04", "LETL_406_05", "LETL_407_01", "LETL_407_02", "LETL_407_03", "LETL_407_04", "LETL_407_05", "LETL_409_01", "LETL_409_02", "LETL_409_03", "LETL_409_04", "LETL_409_05", "LETL_411_01", "LETL_411_02", "LETL_411_03", "LETL_411e2", "LETL_413_01", "LETL_413_02", "LETL_413_03", "LETL_413_04", "LETL_413_05", "LETL_430_01", "LETL_430_02", "LETL_430_03", "LETL_430_04", "LETL_430_05", "LETL_436_04", "LETL_440_01", "LETL_440_02", "LETL_440_03", "LETL_440_04", "LETL_440_05", "LETL_441_01", "LETL_441_02", "LETL_441_03", "LETL_441_04", "LETL_441_05", "LETL_460_01", "LETL_460_02", "LETL_460_03", "LETL_460_04", "LETL_460_05", "LETL_461_01", "LETL_461_01x", "LETL_461_01y", "LETL_461_02", "LETL_461_02x", "LETL_461_02y", "LETL_461_03", "LETL_461_03x", "LETL_461_03y", "LETL_462_01", "LETL_462_02", "LETL_462_03", "LETL_462_04", "LETL_462_05", "LETL_465_01", "LETL_465_02", "LETL_465_03", "LETL_465_04", "LETL_472_01y", "LETL_472_02y", "LETL_472_03y", "LETL_472_04y", "LETL_472_05y", "LETL_511_01", "LETL_511_02", "LETL_511_03", "LETL_511_04", "LETL_511_05", "LETL_511e", "LETL_514_01", "LETL_517_01", "LETL_517_02", "LETL_517_03", "LETL_518_01", "LETL_518_02", "LETL_518_03", "LETL_519_01", "LETL_519_02", "LETL_519_03", "LETL_530_01", "LETL_530_02", "LETL_530_03", "LETL_530_04", "LETL_530_05", "LETL_531_01", "LETL_531_01e", "LETL_533_01", "LETL_533_02", "LETL_533_03", "LETL_533_04", "LETL_533_05", "LETL_533e", "LETL_537_01", "LETL_538_01", "LETL_539_01", "LETL_539_02", "LETL_539_03", "LETL_539_04", "LETL_539_05", "LETL_542_01", "LETL_612_01", "LETL_612_02", "LETL_612_03", "LETL_612_04", "LETL_613_01", "LETL_613_02", "LETL_613_03", "LETL_613_04", "LETL_657_01", "LETL_657_02", "LETL_657_03", "LETL_657_04", "LETL_657e", "LETL_680_01", "LETL_680_02", "LETL_680_03", "LETL_680_04", "LETL_707e", "LETL_754_01", "LETL_754_02", "LETL_754_03", "LETL_754_04", "LETL_754_05", "LETL_755_01", "LETL_755_02", "LETL_755_03", "LETL_755_04", "LETL_755_05", "LETL_773_01", "LETL_773_02", "LETL_773_03", "LETL_773_04", "LETL_773_05", "LETL_812P2_01", "LETL_812P5", "LETL_816P2_01", "LETL_817P1_01", "LETL_817P3_01", "LETL_818P2_01", "LETL_818P3_01", "LETL_822P2_01", "LETL_823P3_01", "LETL_823P3_05", "LETL_824H2", "LETL_824H3", "LETL_824P2_01", "LETL_824P2_04", "LETL_828P1_02", "LETL_828P1_05", "LETL_831P1_03", "LETL_831P1_05", "LETL_832P1_01", "LETL_833H3", "LETL_8342P4", "LETL_8342P5", "LETL_836H", "LETL_837_1", "LETL_837_3", "LETL_838H2", "LETL_839P1_01", "LETL_839P1_03", "LETL_839P2_01", "LETL_839P2_03", "LETL_841H", "LETL_841H_Heroic", "LETL_844H3", "LETL_845P2_04", "LETL_845P2_05", "LETL_845P5_01", "LETL_847P1_01", "LETL_848H", "LETL_848H_Heroic", "LETL_848P6_03", "LETL_848P6_04", "LETL_850P1_01", "LETL_850P1_02", "LETL_851H2", "LETL_852P1", "LETL_852P4", "LETL_853P2_01", "LETL_853P2_02", "LETL_854P2_01", "LETL_856P1_01", "LETL_857P2_01", "LETL_859P2", "LETL_860P2", "LETL_860P2_05", "LETL_861P1_01", "LETL_862H2", "LETL_862P1", "LETL_862P1e3", "LETL_862P1e5", "LETL_862P2", "LETL_863P4", "LETL_864H2", "LETL_866P1_01", "LETL_866P2_01", "LETL_901", "LETL_903P1_01", "LETL_903P1_02", "LETL_904_01", "LETL_904_02", "LETL_904_03", "LETL_905_01", "LETL_905_02", "LETL_905_03", "LETL_906", "LETL_908_01", "LETL_908_02", "LETL_908_03", "LETL_909_01", "LETL_909_02", "LETL_909_03", "LETL_910", "LETL_912_01", "LETL_912_02", "LETL_912_03", "LETL_914", "LETL_917_01", "LETL_917_02", "LETL_917_03", "LETL_917_04", "LETL_917_05", "LETL_919_01", "LETL_919_02", "LETL_919_03", "LETL_919_04", "LETL_919_05", "LETL_920_01", "LETL_920_02", "LETL_920_03", "LETL_920_04", "LETL_920_05", "LETL_922_01", "LETL_922_02", "LETL_922_03", "LETL_922_04", "LETL_922_05", "LETL_923_01", "LETL_923_02", "LETL_923_03", "LETL_923_04", "LETL_923_05", "LETL_926_01", "LETL_926_02", "LETL_926_03", "LETL_926_04", "LETL_926_05", "LETL_927_01", "LETL_927_02", "LETL_928_01", "LETL_928_02", "LETL_928_03", "LETL_928_04", "LETL_928_05", "LETL_929_01", "LETL_929_02", "LETL_929_03", "LETL_929_04", "LETL_929_05", "LETL_935_01", "LETL_938_01", "LETL_947_01", "LETL_952_01", "LETL_952_02", "LETL_952_03", "LETL_952_04", "LETL_952_05", "LETL_954_01", "LETL_954_02", "LETL_954_03", "LETL_954_04", "LETL_954_05", "LETL_964_01", "LETL_964_02", "LETL_964_03", "LETL_964_04", "LETL_964_05", "LETL_974_01", "LETL_976_01", "LETL_985_01", "LETL_985_02", "LETL_985_03", "LETL_985_04", "LETL_985_05", "LETL_985e", "LETLDEV_DISC_01", "LETLT_001_01", "LETLT_002_01", "LETLT_003_01", "LETLT_004_01", "LETLT_005_01", "LETLT_011_01", "LETLT_022_02", "LETLT_023_02", "LETLT_025_02", "LETLT_027_02", "LETLT_032_02", "LETLT_033_02", "LETLT_034_02", "LETLT_036_02", "LETLT_037_02", "LETLT_037_03", "LETLT_038_03", "LETLT_038_04m_01p", "LETLT_038_04m_02p", "LETLT_038_04m_03p", "LETLT_038_04m_04p", "LETLT_038_04m_05p", "LETLT_052_02", "LETLT_055_03", "LETLT_056_03", "LETLT_058_02", "LETLT_072p1_01", "LETLT_072p2_01", "LETLT_075_01", "LETLT_081_03", "LETLT_081_03e", "LETLT_082_03", "LETLT_088_03", "LETLT_101_01", "LETLT_101_02", "LETLT_105_02", "LETLT_107_02", "LETLT_108_02", "LETLT_109_02", "LETLT_110_02", "LETLT_112_02", "LETLT_113_02", "LETLT_116_01", "LETLT_118_02", "LETLT_120_02", "LETLT_122_03", "LETLT_127_02", "LETLT_133_01", "LOE_007", "LOE_009", "LOE_012", "LOE_017", "LOE_019", "LOE_019t", "LOE_019t2", "LOE_024t", "LOE_026", "LOE_039", "LOE_050", "LOE_058", "LOE_058t", "LOE_058t2", "LOE_061", "LOE_079", "LOE_086", "LOE_089", "LOE_105", "LOE_105e", "LOE_110", "LOE_113", "LOE_115", "LOE_115a", "LOE_115b", "LOE_118", "LOE_118e", "LOEA_01", "LOEA_01H", "LOEA02_02", "LOEA02_02h", "LOEA02_03", "LOEA02_04", "LOEA02_05", "LOEA02_06", "LOEA02_10", "LOEA04_28a", "LOEA04_28b", "LOEA04_29a", "LOEA04_29b", "LOEA05_02", "LOEA05_02a", "LOEA05_02h", "LOEA05_02ha", "LOEA05_03", "LOEA05_03h", "LOEA06_02", "LOEA06_02h", "LOEA06_03", "LOEA06_03h", "LOEA07_26", "LOEA07_28", "LOEA09_2", "LOEA09_2H", "LOEA09_3", "LOEA09_3b", "LOEA09_3c", "LOEA09_3d", "LOEA09_3H", "LOEA10_2", "LOEA10_2H", "LOEA10_5", "LOEA10_5H", "LOEA12_2", "LOEA12_2H", "LOEA13_2", "LOEA13_2H", "LOEA15_2", "LOEA15_2H", "LOEA16_12", "LOEA16_13", "LOEA16_15", "LOEA16_18", "LOEA16_18H", "LOEA16_19", "LOEA16_20", "LOEA16_22", "LOEA16_22H", "LOEA16_23", "LOEA16_23H", "LOEA16_24", "LOEA16_24H", "LOEA16_25", "LOEA16_25H", "LOEA16_26", "LOEA16_26H", "LOEA16_3", "LOEA16_7", "LOOT_008", "LOOT_010", "LOOT_017", "LOOT_026", "LOOT_026e", "LOOT_033", "LOOT_042", "LOOT_047", "LOOT_054", "LOOT_054b", "LOOT_054c", "LOOT_054d", "LOOT_056", "LOOT_062", "LOOT_064", "LOOT_064t1", "LOOT_064t2", "LOOT_069", "LOOT_079", "LOOT_080", "LOOT_080t2", "LOOT_080t3", "LOOT_088", "LOOT_091", "LOOT_091t1", "LOOT_091t2", "LOOT_093", "LOOT_103", "LOOT_103t1", "LOOT_103t2", "LOOT_104", "LOOT_106", "LOOT_106t", "LOOT_108", "LOOT_113", "LOOT_115", "LOOT_131", "LOOT_144", "LOOT_152", "LOOT_153", "LOOT_154", "LOOT_161", "LOOT_165", "LOOT_167", "LOOT_170", "LOOT_184", "LOOT_187", "LOOT_203", "LOOT_203t2", "LOOT_203t3", "LOOT_204", "LOOT_209", "LOOT_210", "LOOT_211", "LOOT_214", "LOOT_217", "LOOT_233", "LOOT_253", "LOOT_278", "LOOT_278t1", "LOOT_278t2", "LOOT_278t3", "LOOT_278t4", "LOOT_285", "LOOT_285t", "LOOT_285t3", "LOOT_285t4", "LOOT_286t1", "LOOT_286t2", "LOOT_286t3", "LOOT_286t4", "LOOT_291", "LOOT_306", "LOOT_309", "LOOT_314", "LOOT_329", "LOOT_333", "LOOT_344", "LOOT_344e", "LOOT_351", "LOOT_353", "LOOT_357", "LOOT_357l", "LOOT_368", "LOOT_370", "LOOT_373", "LOOT_375", "LOOT_380", "LOOT_383", "LOOT_388", "LOOT_392", "LOOT_394", "LOOT_398", "LOOT_412", "LOOT_413", "LOOT_414", "LOOT_415", "LOOT_415t1", "LOOT_415t2", "LOOT_415t3", "LOOT_415t4", "LOOT_415t5", "LOOT_420", "LOOT_500", "LOOT_506", "LOOT_507", "LOOT_507t", "LOOT_507t2", "LOOT_511", "LOOT_516", "LOOT_518", "LOOT_519", "LOOT_520", "LOOT_521", "LOOT_526", "LOOT_529", "LOOT_534", "LOOT_535", "LOOT_539", "LOOT_540", "LOOT_541", "LOOT_541t", "LOOT_542", "LOOT_998h", "LOOT_998j", "LOOT_998k", "LOOT_999_OLD", "LOOT_COIN", "LOOTA_104", "LOOTA_800", "LOOTA_813", "LOOTA_816", "LOOTA_817", "LOOTA_820", "LOOTA_823", "LOOTA_836", "LOOTA_837", "LOOTA_838", "LOOTA_841", "LOOTA_842b", "LOOTA_BOSS_04p", "LOOTA_BOSS_10p", "LOOTA_BOSS_110", "LOOTA_BOSS_12p", "LOOTA_BOSS_15p", "LOOTA_BOSS_18p", "LOOTA_BOSS_22p", "LOOTA_BOSS_22t", "LOOTA_BOSS_24p", "LOOTA_BOSS_26p5", "LOOTA_BOSS_26p8", "LOOTA_BOSS_27p", "LOOTA_BOSS_31p", "LOOTA_BOSS_36p", "LOOTA_BOSS_37p", "LOOTA_BOSS_40p", "LOOTA_BOSS_41p", "LOOTA_BOSS_42p", "LOOTA_BOSS_45p", "LOOTA_BOSS_46p", "LOOTA_BOSS_48p", "LOOTA_BOSS_49p", "LT21_003_01", "LT21_003_02", "LT21_003_03", "LT21_003_04", "LT21_003_05", "LT21_013_001", "LT21_013_002", "LT21_013_003", "LT21_013_004", "LT21_013_005", "LT21_014_001", "LT21_014_002", "LT21_014_003", "LT21_014_004", "LT21_014_005", "LT21_019_01", "LT21_019_02", "LT21_019_03", "LT21_019_04", "LT21_019_05", "LT21_020_01", "LT21_020_02", "LT21_020_03", "LT21_020_04", "LT21_020_05", "LT21_05E2_01", "LT21_05E2_02", "LT21_05E2_03", "LT21_05E2_04", "LT21_05P1_01", "LT21_05P1_02", "LT21_05P1_03", "LT21_05P1_04", "LT21_05P1_05", "LT21_05P2_01", "LT21_05P2_01mB", "LT21_05P2_01mC", "LT21_05P2_02", "LT21_05P2_02mB", "LT21_05P2_02mC", "LT21_05P2_03", "LT21_05P2_03mB", "LT21_05P2_03mC", "LT21_05P2_04", "LT21_05P2_04mB", "LT21_05P2_04mC", "LT21_05P2_05", "LT21_05P2_05mB", "LT21_05P2_05mC", "LT21_07P1_01", "LT21_07P1_02", "LT21_07P1_03", "LT21_07P1_04", "LT21_07P1_05", "LT22_001P3_01", "LT22_001P3_02", "LT22_001P3_03", "LT22_001P3_04", "LT22_001P3_05", "LT22_002E1_01", "LT22_002E1_02", "LT22_002E1_03", "LT22_002E1_04", "LT22_002E3_01", "LT22_002E3_02", "LT22_002E3_03", "LT22_002E3_04", "LT22_003E3_01", "LT22_003E3_02", "LT22_003E3_03", "LT22_003E3_04", "LT22_003P1_01", "LT22_003P1_02", "LT22_003P1_03", "LT22_003P1_04", "LT22_003P1_05", "LT22_006P3_01", "LT22_006P3_02", "LT22_006P3_03", "LT22_006P3_04", "LT22_006P3_05", "LT22_007E3_01", "LT22_007E3_02", "LT22_007E3_03", "LT22_007E3_04", "LT22_007P3_01", "LT22_007P3_02", "LT22_007P3_03", "LT22_007P3_04", "LT22_007P3_05", "LT22_008P2_01", "LT22_008P2_02", "LT22_008P2_03", "LT22_008P2_04", "LT22_008P2_05", "LT22_009P2_01", "LT22_009P2_02", "LT22_009P2_03", "LT22_009P2_04", "LT22_009P2_05", "LT22_009P3_01", "LT22_009P3_02", "LT22_009P3_03", "LT22_009P3_04", "LT22_009P3_05", "LT22_010P2_01", "LT22_010P2_02", "LT22_010P2_03", "LT22_010P2_04", "LT22_010P2_05", "LT22_011P1_01", "LT22_011P1_02", "LT22_011P1_03", "LT22_011P1_04", "LT22_011P1_05", "LT22_012P2_01", "LT22_012P2_02", "LT22_012P2_03", "LT22_012P2_04", "LT22_012P2_05", "LT22_012P3_01", "LT22_012P3_02", "LT22_012P3_03", "LT22_012P3_04", "LT22_012P3_05", "LT22_013E2_01", "LT22_013E2_02", "LT22_013E2_03", "LT22_013E2_04", "LT22_013E2e", "LT22_013P2_01", "LT22_013P2_02", "LT22_013P2_03", "LT22_013P2_04", "LT22_013P2_05", "LT22_013P2e2", "LT22_014P3a_01", "LT22_014P3a_02", "LT22_014P3a_03", "LT22_014P3a_04", "LT22_014P3a_05", "LT22_015E2_01", "LT22_015E2_02", "LT22_015E2_03", "LT22_015E2_04", "LT22_015E2e", "LT22_015E3_01", "LT22_015E3_02", "LT22_015E3_03", "LT22_015E3_04", "LT22_015E3e", "LT22_015P1_01", "LT22_015P1_02", "LT22_015P1_03", "LT22_015P1_04", "LT22_015P1_05", "LT22_015P2_01", "LT22_015P2_02", "LT22_015P2_03", "LT22_015P2_04", "LT22_015P2_05", "LT22_016E3_01", "LT22_016E3_02", "LT22_016E3_03", "LT22_016E3_04", "LT22_016P2_01", "LT22_016P2_01a", "LT22_016P2_01b", "LT22_016P2_01c", "LT22_016P2_02", "LT22_016P2_02a", "LT22_016P2_02b", "LT22_016P2_02c", "LT22_016P2_03", "LT22_016P2_03a", "LT22_016P2_03b", "LT22_016P2_03c", "LT22_016P2_04", "LT22_016P2_04a", "LT22_016P2_04b", "LT22_016P2_04c", "LT22_016P2_05", "LT22_016P2_05a", "LT22_016P2_05b", "LT22_016P2_05c", "LT22_023E3_01", "LT22_023E3_02", "LT22_023E3_03", "LT22_023E3_04", "LT22_023P1_01", "LT22_023P1_02", "LT22_023P1_03", "LT22_023P1_04", "LT22_023P1_05", "LT22_023P2_01", "LT22_023P2_02", "LT22_023P2_03", "LT22_023P2_04", "LT22_023P2_05", "LT22_024P2_01", "LT22_024P2_02", "LT22_024P2_03", "LT22_024P2_04", "LT22_024P2_05", "LT23_011E2_02", "LT23_011E2_03", "LT23_011E2_04", "LT23_011P1_01", "LT23_011P1_02", "LT23_011P1_03", "LT23_011P1_04", "LT23_011P1_05", "LT23_011T1_01", "LT23_011T1_02", "LT23_011T1_03", "LT23_011T1_04", "LT23_011T1_05", "LT23_016P2_01", "LT23_016P2_02", "LT23_016P2_03", "LT23_016P2_04", "LT23_016P2_05", "LT23_016T1_01", "LT23_016T1_02", "LT23_016T1_03", "LT23_016T1_04", "LT23_016T1_05", "LT23_018E3_01", "LT23_018E3_02", "LT23_018E3_03", "LT23_018E3_04", "LT23_019P1_01", "LT23_019P1_02", "LT23_019P1_03", "LT23_019P1_04", "LT23_019P1_05", "LT23_019P2_01", "LT23_019P2_02", "LT23_019P2_03", "LT23_019P2_04", "LT23_019P2_05", "LT23_020P1_01", "LT23_020P1_02", "LT23_020P1_03", "LT23_020P1_04", "LT23_020P1_05", "LT23_020P3_01", "LT23_020P3_02", "LT23_020P3_03", "LT23_020P3_04", "LT23_020P3_05", "LT23_022E2_01", "LT23_022E2_02", "LT23_022E2_03", "LT23_022E2_04", "LT23_022E2e", "LT23_022E3_01", "LT23_022E3_02", "LT23_022E3_03", "LT23_022E3_04", "LT23_022P1_01", "LT23_022P1_02", "LT23_022P1_03", "LT23_022P1_04", "LT23_022P1_05", "LT23_024E1_01", "LT23_024E1_02", "LT23_024E1_03", "LT23_024E1_04", "LT23_024P2_01", "LT23_024P2_01t", "LT23_024P2_01t2", "LT23_024P2_02", "LT23_024P2_02t", "LT23_024P2_02t2", "LT23_024P2_03", "LT23_024P2_03t", "LT23_024P2_03t2", "LT23_024P2_04", "LT23_024P2_04t", "LT23_024P2_04t2", "LT23_024P2_05", "LT23_024P2_05t", "LT23_024P2_05t2", "LT23_024T1_01", "LT23_024T1_02", "LT23_024T1_03", "LT23_025E1_01", "LT23_025E1_02", "LT23_025E1_03", "LT23_025E1_04", "LT23_025P1m_01b", "LT23_025P1m_02b", "LT23_025P1m_03b", "LT23_025P1m_04b", "LT23_025P1m_05b", "LT23_026P2_01", "LT23_026P2_02", "LT23_026P2_03", "LT23_026P2_04", "LT23_026P2_05", "LT23_028P2_01", "LT23_028P2_02", "LT23_028P2_03", "LT23_028P2_04", "LT23_028P2_05", "LT23_028P3_01", "LT23_028P3_02", "LT23_028P3_03", "LT23_028P3_04", "LT23_028P3_05", "LT23_029P3_01", "LT23_029P3_02", "LT23_029P3_03", "LT23_029P3_04", "LT23_029P3_05", "LT23_030E3_03", "LT23_030E3_04", "LT23_031P2_01", "LT23_031P2_02", "LT23_031P2_03", "LT23_031P2_04", "LT23_031P2_05", "LT23_031P3_01", "LT23_031P3_02", "LT23_031P3_03", "LT23_031P3_04", "LT23_031P3_05", "LT23_031T1_04", "LT23_031T1_05", "LT23_032E2_02", "LT23_032E2_03", "LT23_032E2_04", "LT23_032P1_01", "LT23_032P1_02", "LT23_032P1_03", "LT23_032P1_04", "LT23_032P1_05", "LT23_032P2_01", "LT23_032P2_02", "LT23_032P2_03", "LT23_032P2_04", "LT23_032P2_05", "LT23_032P3a1", "LT23_032P3a2", "LT23_032P3a3", "LT23_032P3a4", "LT23_032P3a5", "LT23_032P3f", "LT23_032P3f1", "LT23_032P3f2", "LT23_032P3f3", "LT23_032P3f4", "LT23_033E1_01", "LT23_033E1_02", "LT23_033E1_03", "LT23_033E1_04", "LT23_033P2_01", "LT23_033P2_02", "LT23_033P2_03", "LT23_033P2_04", "LT23_033P2_05", "LT23_034E1_01", "LT23_034E1_01t", "LT23_034E1_02", "LT23_034E1_02t", "LT23_034E1_03", "LT23_034E1_03t", "LT23_034E1_04", "LT23_034E1_04t", "LT23_034E1_05t", "LT23_034P2_01", "LT23_034P2_02", "LT23_034P2_03", "LT23_034P2_04", "LT23_034P2_05", "LT23_034T1_01", "LT23_034T1_02", "LT23_034T1_03", "LT23_034T1_04", "LT23_034T1_05", "LT23_035P1_01", "LT23_035P1_02", "LT23_035P1_03", "LT23_035P1_04", "LT23_035P1_05", "LT23_035P2_01", "LT23_035P2_02", "LT23_035P2_03", "LT23_035P2_04", "LT23_035P2_05", "LT23_036P1a_01", "LT23_036P1a_02", "LT23_036P1a_03", "LT23_036P1a_04", "LT23_036P1a_05", "LT23_036P1am", "LT23_036P1b_01", "LT23_036P1b_02", "LT23_036P1b_03", "LT23_036P1b_04", "LT23_036P1b_05", "LT23_036P1c_01", "LT23_036P1c_02", "LT23_036P1c_03", "LT23_036P1c_04", "LT23_036P1c_05", "LT23_036P2_01", "LT23_036P2_02", "LT23_036P2_03", "LT23_036P2_04", "LT23_036P2_05", "LT23_036T1_01", "LT23_036T1_02", "LT23_036T1_03", "LT23_036T1_04", "LT23_036T1_05", "LT23_037P2_01", "LT23_037P2_02", "LT23_037P2_03", "LT23_037P2_04", "LT23_037P2_05", "LT23_800H", "LT23_801P1", "LT23_801P2", "LT23_802H2", "LT23_802H3", "LT23_802P3", "LT23_805H", "LT23_805H1", "LT23_806P1", "LT23_807P2", "LT23_808P1", "LT23_809H3", "LT23_809H5", "LT23_809P1", "LT23_811H", "LT23_811P2", "LT23_813P1", "LT23_815P1", "LT23_815P2", "LT23_816H", "LT23_817P1", "LT23_818H4", "LT23_818P1", "LT23_820P1", "LT23_821H2", "LT23_821P1", "LT23_823H2", "LT23_823H3", "LT23_823P1c", "LT23_823P1d", "LT23T_101_02", "LT23T_105_02", "LT23T_110_01", "LT23T_111_01", "LT23T_118_02", "LT23T_125_02", "LT23T_126_02", "LT23T_127_01", "LT23T_127_02", "LT24_001E1_01", "LT24_001E1_02", "LT24_001E1_03", "LT24_001E1_04", "LT24_001E3_01", "LT24_001E3_02", "LT24_001E3_03", "LT24_001E3_04", "LT24_001P1_01", "LT24_001P1_02", "LT24_001P1_03", "LT24_001P1_04", "LT24_001P1_05", "LT24_001P3_01", "LT24_001P3_02", "LT24_001P3_03", "LT24_001P3_04", "LT24_001P3_05", "LT24_001T1_01", "LT24_001T1_02", "LT24_001T1_03", "LT24_001T1_04", "LT24_001T1_05", "LT24_002P2s_01", "LT24_002P2s_02", "LT24_002P2s_03", "LT24_002P2s_04", "LT24_002P2s_05", "LT24_002P2x_01", "LT24_002P2x_02", "LT24_002P2x_03", "LT24_002P2x_04", "LT24_002P2x_05", "LT24_002P2y2_01", "LT24_002P2y2_02", "LT24_002P2y2_03", "LT24_002P2y2_04", "LT24_002P2z_01", "LT24_002P2z_02", "LT24_002P2z_03", "LT24_002P2z_04", "LT24_002P2z_05", "LT24_002P3_05a", "LT24_002T1_01", "LT24_002T1_02", "LT24_002T1_03", "LT24_002T1_04", "LT24_002T1_05", "LT24_003P1_01", "LT24_003P1_02", "LT24_003P1_03", "LT24_003P1_04", "LT24_003P1_05", "LT24_003P2_01", "LT24_003P2_02", "LT24_003P2_03", "LT24_003P2_04", "LT24_003P2_05", "LT24_003P3_01", "LT24_003P3_02", "LT24_003P3_03", "LT24_003P3_04", "LT24_003P3_05", "LT24_003T2_01", "LT24_006E3_01", "LT24_006E3_02", "LT24_006E3_03", "LT24_006E3_04", "LT24_006P2_01", "LT24_006P2_02", "LT24_006P2_03", "LT24_006P2_04", "LT24_006P2_05", "LT24_006P3_01", "LT24_006P3_02", "LT24_006P3_03", "LT24_006P3_04", "LT24_006P3_05", "LT24_007E2_01", "LT24_007E2_02", "LT24_007E2_03", "LT24_007E2_04", "LT24_007P2b", "LT24_007P2b2", "LT24_007T1_01", "LT24_007T1_02", "LT24_007T1_03", "LT24_007T1_04", "LT24_007T1_05", "LT24_008P3a_01", "LT24_008P3a_02", "LT24_008P3a_03", "LT24_008P3a_04", "LT24_008P3a_05", "LT24_008P3am_01", "LT24_008P3am_02", "LT24_008P3am_03", "LT24_008P3am_04", "LT24_008P3am_05", "LT24_008P3b_01", "LT24_008P3b_02", "LT24_008P3b_03", "LT24_008P3b_04", "LT24_008P3b_05", "LT24_008P3bm_01", "LT24_008P3bm_02", "LT24_008P3bm_03", "LT24_008P3bm_04", "LT24_008P3bm_05", "LT24_010H_01", "LT24_010H_02", "LT24_010H_03", "LT24_010P3_01", "LT24_010P3_02", "LT24_010P3_03", "LT24_010P3_04", "LT24_010P3_05", "LT24_011P3_01", "LT24_011P3_02", "LT24_011P3_03", "LT24_011P3_04", "LT24_011P3_05", "LT24_013P1_01", "LT24_013P1_02", "LT24_013P1_03", "LT24_013P1_04", "LT24_013P1_05", "LT24_013P3_01", "LT24_013P3_02", "LT24_013P3_03", "LT24_013P3_04", "LT24_013P3_05", "LT24_016T1_01", "LT24_016T1_02", "LT24_016T1_03", "LT24_016T1_04", "LT24_016T1_05", "LT24_017E1_01", "LT24_017E1_02", "LT24_017E1_03", "LT24_017E1_04", "LT24_017E2_01", "LT24_017E2_02", "LT24_017E2_03", "LT24_017E2_04", "LT24_017E3_01", "LT24_017E3_02", "LT24_017E3_03", "LT24_017E3_04", "LT24_017P2_01", "LT24_017P2_02", "LT24_017P2_03", "LT24_017P2_04", "LT24_017P2_05", "LT24_017P3_01", "LT24_017P3_02", "LT24_017P3_03", "LT24_017P3_04", "LT24_017P3_05", "LT24_019E3_01", "LT24_019E3_02", "LT24_019E3_03", "LT24_019E3_04", "LT24_020P1_01", "LT24_020P1_02", "LT24_020P1_03", "LT24_020P1_04", "LT24_020P1_05", "LT24_020P3_01a", "LT24_020P3_01b", "LT24_020P3_02a", "LT24_020P3_02b", "LT24_020P3_03a", "LT24_020P3_03b", "LT24_020P3_04a", "LT24_020P3_04b", "LT24_020P3_05a", "LT24_020P3_05b", "LT24_020P6_01", "LT24_020P6_02", "LT24_020P6_03", "LT24_020P6_04", "LT24_020P6_05", "LT24_024E1_03", "LT24_024E1_04", "LT24_024E3_01", "LT24_024E3_02", "LT24_024E3_03", "LT24_024E3_04", "LT24_024P1_01", "LT24_024P1_02", "LT24_024P1_03", "LT24_024P1_04", "LT24_024P1_05", "LT24_027E1_01", "LT24_027E1_02", "LT24_027E1_03", "LT24_027E1_04", "LT24_027E2_01", "LT24_027E2_02", "LT24_027E2_03", "LT24_027E2_04", "LT24_027P1_01", "LT24_027P1_02", "LT24_027P1_03", "LT24_027P1_04", "LT24_027P1_05", "LT24_027P3_01", "LT24_027P3_02", "LT24_027P3_03", "LT24_027P3_04", "LT24_027P3_05", "LT24_810P1", "LT24_811H2", "LT24_813H2", "LT24_814P1", "LT24_814P3", "LT24_814P4", "LT24_814P5", "LT24_815P1", "LT24_817P1", "LT24_819P2", "LT24_820P1", "LT24_820P3", "LT24_821H", "LT24_821H2", "LT24_822P1", "MAW_002", "MAW_003", "MAW_003t", "MAW_004", "MAW_005", "MAW_006", "MAW_009", "MAW_011", "MAW_012", "MAW_012t", "MAW_015", "MAW_016", "MAW_018", "MAW_021", "MAW_023e", "MAW_024", "MAW_024e3", "MAW_025", "MAW_025b", "MAW_027", "MAW_029", "Mekka2", "Mekka3", "NAX1_04", "NAX11_04", "NAX12_04", "NAX13_02", "NAX13_03", "NAX1h_04", "NAX6_03t", "NAX8_02", "NAX8_02H", "NAX8_02H_TB", "NAX8_03", "NAX8_04", "NAX8_05", "NAX9_06", "NAX9_07", "NEW1_008", "NEW1_008a", "NEW1_008b", "NEW1_009", "NEW1_014", "NEW1_016", "NEW1_018", "NEW1_024", "NEW1_026", "NEW1_031", "NEW1_036", "NEW1_037", "NEW1_040", "OG_006", "OG_006b", "OG_023", "OG_026", "OG_031", "OG_042", "OG_045", "OG_047", "OG_047a", "OG_047b", "OG_048", "OG_051", "OG_070", "OG_072", "OG_073", "OG_080", "OG_080b", "OG_080d", "OG_080e", "OG_087", "OG_090", "OG_094", "OG_101", "OG_102", "OG_104", "OG_109", "OG_113", "OG_114", "OG_118", "OG_122", "OG_133", "OG_134", "OG_135", "OG_147", "OG_156", "OG_158", "OG_182", "OG_184", "OG_191", "OG_195", "OG_195a", "OG_195b", "OG_198", "OG_201", "OG_202", "OG_202a", "OG_202b", "OG_205", "OG_207", "OG_208", "OG_211", "OG_216", "OG_221", "OG_222", "OG_223", "OG_229", "OG_234", "OG_236", "OG_241", "OG_249", "OG_251", "OG_255", "OG_256", "OG_257", "OG_260", "OG_266", "OG_267", "OG_270", "OG_272", "OG_273", "OG_276", "OG_277", "OG_281", "OG_283", "OG_284", "OG_286", "OG_287", "OG_288", "OG_291", "OG_292", "OG_293", "OG_296", "OG_304", "OG_306", "OG_309", "OG_310", "OG_311", "OG_313", "OG_316", "OG_318", "OG_320", "OG_323", "OG_324", "OG_330", "OG_335", "OG_337", "OG_339", "ONY_001", "ONY_003", "ONY_004", "ONY_005ta10", "ONY_005ta12", "ONY_005ta2", "ONY_005ta5", "ONY_005ta8", "ONY_005tb12", "ONY_005tb2", "ONY_005tb5", "ONY_005tb7", "ONY_005tb7e", "ONY_005tb9", "ONY_005tc6", "ONY_008", "ONY_009", "ONY_012", "ONY_012e", "ONY_016", "ONY_016t", "ONY_016t2", "ONY_017", "ONY_018t", "ONY_019", "ONY_021", "ONY_022", "ONY_023", "ONY_025", "ONY_027", "ONY_028", "ONY_028t", "ONY_029", "ONY_030", "ONY_031", "ONY_033", "ONY_034", "PART_001", "PART_003", "PART_004", "PART_006", "PART_007", "PCVPDR_SCH_Paladint1", "PCVPDR_SCH_Paladint2", "PCVPDR_SCH_Warriort1", "PRO_001", "PRO_001a", "PRO_001c", "Prologue_Azshara", "Prologue_CenariusHP", "Prologue_ChaosStrike", "Prologue_Maiev", "Prologue_ManaBurn", "Prologue_MoongladePortal", "Prologue_Ravencrest", "Prologue_Sorcerer", "PVPDR_021", "PVPDR_022", "PVPDR_036", "PVPDR_AV_Neutralp1", "PVPDR_AV_Neutralp2", "PVPDR_AV_Neutralp2m1", "PVPDR_AV_Neutralp3p1", "PVPDR_AV_Neutralp3p2", "PVPDR_AV_Neutralp3p2e1", "PVPDR_AV_Neutralp6", "PVPDR_AV_Neutralp6p1", "PVPDR_AV_Neutralp6p2", "PVPDR_AV_Neutralp6p2e1", "PVPDR_AV_Neutralp6p3", "PVPDR_AV_Neutralt1", "PVPDR_AV_Neutralt11", "PVPDR_AV_Neutralt12", "PVPDR_AV_Neutralt12t1", "PVPDR_AV_Neutralt2", "PVPDR_AV_Neutralt3", "PVPDR_AV_Neutralt4", "PVPDR_AV_Neutralt5", "PVPDR_AV_Neutralt6", "PVPDR_AV_Neutralt6t1", "PVPDR_AV_Neutralt7", "PVPDR_AV_Neutralt8t", "PVPDR_AV_Neutralt8t2", "PVPDR_AV_Neutralt9", "PVPDR_AV_Passive02", "PVPDR_AV_Passive02e1", "PVPDR_AV_Passive03", "PVPDR_AV_Passive03e1", "PVPDR_AV_Passive04", "PVPDR_AV_Passive04e1", "PVPDR_AV_Passive05", "PVPDR_AV_Passive05e1", "PVPDR_AV_Passive14", "PVPDR_AV_Passive14e1", "PVPDR_AV_Passive15", "PVPDR_AV_Passive15e1", "PVPDR_AV_Passive16", "PVPDR_AV_Passive16e1", "PVPDR_AV_Passive22", "PVPDR_AV_Passive22e1", "PVPDR_AV_Passive23", "PVPDR_AV_Passive23e1", "PVPDR_AV_Passive24", "PVPDR_AV_Passive24e1", "PVPDR_AV_Passive25", "PVPDR_AV_Passive25e1", "PVPDR_AV_Passive28", "PVPDR_AV_Passive28e1", "PVPDR_AV_Passive29", "PVPDR_AV_Passive29e1", "PVPDR_AV_Passive31", "PVPDR_AV_Passive31e1", "PVPDR_AV_Passive32", "PVPDR_AV_Passive32e1", "PVPDR_AV_Passive35", "PVPDR_AV_Passive35e1", "PVPDR_AV_Passive36", "PVPDR_AV_Passive36e1", "PVPDR_BAR_Passive01", "PVPDR_BAR_Passive01e1", "PVPDR_BAR_Passive04", "PVPDR_BAR_Passive04e1", "PVPDR_BAR_Passive07", "PVPDR_BAR_Passive07e1", "PVPDR_BAR_Passive08", "PVPDR_BAR_Passive08e1", "PVPDR_BAR_Passive11", "PVPDR_BAR_Passive11e1", "PVPDR_BAR_Passive15", "PVPDR_BAR_Passive15e1", "PVPDR_BAR_Passive17", "PVPDR_BAR_Passive17e1", "PVPDR_BAR_Passive22", "PVPDR_BAR_Passive22e1", "PVPDR_BAR_Passive25", "PVPDR_BAR_Passive25e1", "PVPDR_BAR_Passive28", "PVPDR_Brann_HP3", "PVPDR_Brann_T2", "PVPDR_Brann_T4", "PVPDR_Brann_T4_2", "PVPDR_Brann_T5", "PVPDR_Brann_T6", "PVPDR_Darius_P2", "PVPDR_Darius_T2", "PVPDR_Darius_T5", "PVPDR_DMF_Druidt1", "PVPDR_DMF_Hunterp1", "PVPDR_DMF_Huntert2", "PVPDR_DMF_Magep1", "PVPDR_DMF_Paladinp1", "PVPDR_DMF_Paladint2", "PVPDR_DMF_Priestt2", "PVPDR_DMF_Shamant2", "PVPDR_DMF_Shamant2c", "PVPDR_DMF_Warlockp1", "PVPDR_DMF_Warlockt3", "PVPDR_DMF_Warriorp1", "PVPDR_DMF_Warriort1", "PVPDR_DMF_Warriort2", "PVPDR_Elise_HP1", "PVPDR_Elise_HP2", "PVPDR_Elise_T1", "PVPDR_Elise_T2", "PVPDR_Elise_T3", "PVPDR_Elise_T4", "PVPDR_Elise_T4_2", "PVPDR_Elise_T5", "PVPDR_Elise_T6", "PVPDR_Finley_HP1", "PVPDR_Finley_HP2", "PVPDR_Finley_HP3", "PVPDR_Finley_T1", "PVPDR_Finley_T4", "PVPDR_Finley_T4_2", "PVPDR_Finley_T5", "PVPDR_GUEST_Diablop1", "PVPDR_GUEST_Diablop3", "PVPDR_GUEST_Diablot1", "PVPDR_GUEST_Diablot3e", "PVPDR_GUEST_Diablot5", "PVPDR_GUEST_Diablot6", "PVPDR_GUEST_Diablot6s1", "PVPDR_GUEST_Diablot6s4", "PVPDR_LOOT_SmartyPants", "PVPDR_Reno_T1", "PVPDR_Reno_T4", "PVPDR_Reno_T4_2", "PVPDR_Reno_T4_2hp", "PVPDR_REV_Passive4", "PVPDR_REV_Passive4e", "PVPDR_SCH_Active03", "PVPDR_SCH_Active08", "PVPDR_SCH_Active11", "PVPDR_SCH_Active14", "PVPDR_SCH_Active17e1", "PVPDR_SCH_Active19", "PVPDR_SCH_Active19e1", "PVPDR_SCH_Active23", "PVPDR_SCH_Active28", "PVPDR_SCH_Active28s1", "PVPDR_SCH_Active28s2", "PVPDR_SCH_Active30", "PVPDR_SCH_Active31", "PVPDR_SCH_Active31s1", "PVPDR_SCH_Active31s2", "PVPDR_SCH_Active34", "PVPDR_SCH_Active35", "PVPDR_SCH_Active35s1", "PVPDR_SCH_Active35s2", "PVPDR_SCH_Active38", "PVPDR_SCH_Active46", "PVPDR_SCH_Active47", "PVPDR_SCH_Active50", "PVPDR_SCH_Active60", "PVPDR_SCH_DemonHunterp1", "PVPDR_SCH_DemonHuntert2", "PVPDR_SCH_Druidp1s1", "PVPDR_SCH_Druidp1s2", "PVPDR_SCH_Druidp2", "PVPDR_SCH_Druidp3", "PVPDR_SCH_Druidp3s1", "PVPDR_SCH_Druidp3s2", "PVPDR_SCH_Druidp3s3", "PVPDR_SCH_Druidt1s", "PVPDR_SCH_Druidt1s2", "PVPDR_SCH_Druidt2", "PVPDR_SCH_Druidt3", "PVPDR_SCH_Druidt4", "PVPDR_SCH_Druidt5", "PVPDR_SCH_Druidt6", "PVPDR_SCH_Huntert2", "PVPDR_SCH_Magep1", "PVPDR_SCH_Magep1e", "PVPDR_SCH_Maget2", "PVPDR_SCH_Maget5e", "PVPDR_SCH_Paladinp1", "PVPDR_SCH_Paladint1", "PVPDR_SCH_Paladint2", "PVPDR_SCH_Passive02", "PVPDR_SCH_Passive03", "PVPDR_SCH_Passive04", "PVPDR_SCH_Passive05", "PVPDR_SCH_Passive05e1", "PVPDR_SCH_Passive12", "PVPDR_SCH_Passive16", "PVPDR_SCH_Passive22", "PVPDR_SCH_Passive22e", "PVPDR_SCH_Passive32", "PVPDR_SCH_Passive32e", "PVPDR_SCH_Passive34", "PVPDR_SCH_Passive34e", "PVPDR_SCH_Priestp1", "PVPDR_SCH_Roguet1", "PVPDR_SCH_Roguet2", "PVPDR_SCH_Shamanp1", "PVPDR_SCH_Shamant2", "PVPDR_SCH_Warlockp3", "PVPDR_SCH_Warlockt2", "PVPDR_SCH_Warlockt5", "PVPDR_SCH_Warriort1", "PVPDR_Shaw_P1", "PVPDR_Shaw_P2", "PVPDR_Shaw_P3", "PVPDR_Shaw_T1", "PVPDR_Shaw_T2", "PVPDR_Shaw_T3", "PVPDR_Shaw_T5", "PVPDR_SW_Passive_01", "PVPDR_SW_Passive_01e1", "PVPDR_SW_Passive_05e2", "PVPDR_SW_Passive_06", "PVPDR_SW_Passive_06e1", "PVPDR_SW_Passive_09", "PVPDR_SW_Passive20", "PVPDR_Tess_P1", "PVPDR_Tess_P2", "PVPDR_Tess_P3", "PVPDR_Tess_T6", "PVPDR_TEST_DiscoverBucket", "PVPDR_TEST_FiveLeaves", "PVPDR_TEST_Leaf", "PVPDR_Toki_T2", "PVPDR_Toki_T4", "PVPDR_TSC_Passive2e1", "PVPDR_TSC_Passive3", "PVPDR_TSC_Passive3e1", "PVPDR_TSC_Passive4", "PVPDR_TSC_Passive4e1", "PVPDR_YOP_Active01", "PVPDR_YOP_Active02", "PVPDR_YOP_DemHun", "PVPDR_YOP_DemonHunterP1", "PVPDR_YOP_DemonHuntert2", "PVPDR_YOP_HunterT1", "PVPDR_YOP_LocPriT1", "PVPDR_YOP_MageT3", "PVPDR_YOP_PriestP1", "PVPDR_YOP_PriestP1m1", "PVPDR_YOP_PriestT2", "PVPDR_YOP_RogueP1", "PVPDR_YOP_ShamanT1", "PVPDR_YOP_ShamanT2", "PVPDR_YOP_WarPalT1", "PVPDR_YOP_WarriorP1", "PVPDR_YOP_WarriorT1", "RAWR_001", "RAWR_005", "RAWR_005a", "RAWR_005b", "RAWR_006", "RAWR_007", "RAWR_008", "REV_000", "REV_002", "REV_006", "REV_012", "REV_016", "REV_019", "REV_019t", "REV_020", "REV_238", "REV_239", "REV_240", "REV_244", "REV_244t", "REV_245", "REV_247", "REV_247e", "REV_248", "REV_253", "REV_290", "REV_308", "REV_310", "REV_311", "REV_311t", "REV_311t2", "REV_313", "REV_314", "REV_314e", "REV_318", "REV_333", "REV_334", "REV_336", "REV_336t4", "REV_337", "REV_338", "REV_350", "REV_350t2", "REV_351", "REV_353", "REV_353t", "REV_353t2", "REV_356", "REV_360", "REV_361", "REV_362", "REV_363", "REV_365", "REV_371", "REV_372", "REV_373", "REV_375", "REV_504", "REV_505", "REV_507", "REV_508", "REV_510", "REV_513", "REV_514", "REV_516", "REV_517", "REV_750", "REV_825", "REV_827", "REV_828", "REV_835", "REV_835t", "REV_839", "REV_842", "REV_843", "REV_900", "REV_901", "REV_917", "REV_931", "REV_934", "REV_935", "REV_935t", "REV_936", "REV_937", "REV_938", "REV_938t", "REV_939e", "REV_939e2", "REV_942e2", "REV_943", "REV_945", "REV_947", "REV_948", "REV_951t", "REV_955", "REV_956", "REV_958", "REV_958t", "REV_983", "REV_COIN1", "REV_COIN2", "RLK_590", "RM_001", "SCH_120", "SCH_126", "SCH_133", "SCH_136", "SCH_138", "SCH_142", "SCH_149", "SCH_157", "SCH_158", "SCH_158e", "SCH_160", "SCH_162", "SCH_181", "SCH_182", "SCH_199t10", "SCH_199t11", "SCH_199t12", "SCH_199t13", "SCH_199t15", "SCH_199t18", "SCH_199t19", "SCH_199t21", "SCH_199t23", "SCH_199t24", "SCH_199t25", "SCH_199t26", "SCH_199t27", "SCH_199t28", "SCH_199t3", "SCH_199t30", "SCH_199t31", "SCH_199t5", "SCH_199t6", "SCH_199t7", "SCH_199t8", "SCH_199t9", "SCH_224", "SCH_230", "SCH_231", "SCH_232", "SCH_233", "SCH_233e", "SCH_234", "SCH_237", "SCH_237e", "SCH_242", "SCH_243", "SCH_244", "SCH_245", "SCH_247", "SCH_250", "SCH_252", "SCH_259t", "SCH_270", "SCH_270e", "SCH_273", "SCH_300", "SCH_300e", "SCH_302", "SCH_305", "SCH_307t", "SCH_311", "SCH_317", "SCH_333", "SCH_333e", "SCH_337", "SCH_340", "SCH_350", "SCH_351", "SCH_352", "SCH_353", "SCH_354", "SCH_356", "SCH_357", "SCH_422", "SCH_426", "SCH_427", "SCH_507", "SCH_507e", "SCH_522", "SCH_523", "SCH_524", "SCH_525", "SCH_530", "SCH_532", "SCH_533", "SCH_537", "SCH_600", "SCH_603", "SCH_606", "SCH_607b", "SCH_609", "SCH_610", "SCH_612", "SCH_612a", "SCH_612b", "SCH_615", "SCH_617", "SCH_623", "SCH_700", "SCH_702", "SCH_703", "SCH_705", "SCH_706", "SCH_707", "SCH_708", "SCH_709", "SCH_710", "SCH_711", "SCH_714", "SLUSH_003", "SLUSH_009", "SLUSH_009p", "SLUSH_009w", "SLUSH_038", "SLUSH_054", "SLUSH_060", "SLUSH_064", "SLUSH_111", "SLUSH_157", "SLUSH_224", "SLUSH_226", "SLUSH_BAD_1", "SLUSH_BAD_4", "Story_01_ArcaneKeysmith", "Story_01_ArchimondeHP", "Story_01_Bigglesworth", "Story_01_BookofRunes", "Story_01_CobaltSpellkin", "Story_01_FeralSpirit", "Story_01_GrayCat", "Story_01_JainaMidHP", "Story_01_JainaMidHP2", "Story_01_JainaMidHP3", "Story_01_LibramofWisdom", "Story_01_ThrallHP", "Story_01_Upgrade", "Story_01_VoltaicBurst", "Story_02_BeastCompanion", "Story_02_BloodmaulBrute", "Story_02_Burgle", "Story_02_Cairne", "Story_02_DaelinHP", "Story_02_EVILCableRat", "Story_02_EVILMiscreant", "Story_02_GorgromHP", "Story_02_HenchClanBurglar", "Story_02_Intimidation", "Story_02_Marshspawn", "Story_02_QuilboarHP", "Story_02_RexxarMidHP", "Story_02_RexxarMidHP2", "Story_02_RexxarMidHP3", "Story_02_RexxarWarHP", "Story_02_TeachersPet", "Story_02_Warship", "Story_02_WinkFox", "Story_03_Baine", "Story_03_ChargedDoomhammer", "Story_03_CorruptGarroshHP", "Story_03_DivineBell", "Story_03_GarroshHP", "Story_03_GarroshHP2", "Story_03_GeyahHP", "Story_03_JainaHP", "Story_03_Karnuk", "Story_03_MightofHellscream", "Story_03_RehgarHP", "Story_03_Rexxar", "Story_03_Runespear", "Story_03_ThrallMinion", "Story_03_TrickTotem", "Story_03_YShaarjsPower", "Story_04_AlonsusHP", "Story_04_ArthasHP", "Story_04_ArthasMinion", "Story_04_DarknessBeckons", "Story_04_DarkPortalHP", "Story_04_DivertForces", "Story_04_DragonRoar", "Story_04_FinalStand", "Story_04_Frostmourne", "Story_04_HolyWrath", "Story_04_IcebladeHP", "Story_04_Jaina", "Story_04_KelThuzad", "Story_04_KingTerenas", "Story_04_LibramofCompassion", "Story_04_LibramofHoliness", "Story_04_MalGanisHP", "Story_04_SaurfangHP", "Story_04_TimeOut", "Story_04_UnbrokenFaith", "Story_05_AllianceCommander", "Story_05_AllianceCommanderts", "Story_05_AnduinYoungHP", "Story_05_AnduinYoungHP2", "Story_05_Apotheosis", "Story_05_Bananas", "Story_05_FaithsDefender", "Story_05_FaithsDefenderts", "Story_05_HighPriestRohan", "Story_05_JourneyBelow", "Story_05_LightProphecy", "Story_05_Lorthemar", "Story_05_MassResurrection", "Story_05_Mekkatorque", "Story_05_MercifulHeart", "Story_05_MetalBrew", "Story_05_MoiraHP", "Story_05_Nathanos", "Story_05_RepairBot", "Story_05_SaurfangHP", "Story_05_SolvetheRiddles", "Story_05_StewardofScrolls", "Story_05_TownCrier", "Story_05_UndercityHuckster", "Story_05_VarianMinion", "Story_06_CleverDisguise", "Story_06_Daerion_03p", "Story_06_EbonGryphon", "Story_06_FelFuror", "Story_06_FutureGladiator", "Story_06_HastyBlade", "Story_06_Helka_02p", "Story_06_JainaMinion", "Story_06_Kathranatir", "Story_06_Kingslayers", "Story_06_LoGosh", "Story_06_ManaWyrm", "Story_06_NoMercy", "Story_06_Rehgar_01p", "Story_06_RehgarMinion", "Story_06_ShadyBusiness", "Story_06_Steeldancer", "Story_06_ThistleDagger", "Story_06_ToxicVial", "Story_06_TrickTotem", "Story_06_Valeera_03p", "Story_06_Valeera_04p", "Story_06_Valeera_06p", "Story_06_Valeera_09p", "Story_06_Varian", "Story_06_WandThief", "Story_06_Wrathion", "Story_06_Wyvern", "Story_07_Archimonde_005p", "Story_07_AthleticStudies", "Story_07_Blackmoore_001p", "Story_07_CallWarchief", "Story_07_CapturedCrocolisk", "Story_07_DrekThar_002p", "Story_07_DrekTharMinion", "Story_07_EarthenMight", "Story_07_ElementalGathering", "Story_07_EventheOdds", "Story_07_FireSpiritWolf", "Story_07_FocusingIrisSpell", "Story_07_Garrosh_008p", "Story_07_Jaina_007p", "Story_07_Kalecgos", "Story_07_PepTalk", "Story_07_RegenerativeBlood", "Story_07_SpiritofAirt", "Story_07_SpiritofEartht", "Story_07_SpiritoftheWildt", "Story_07_SpiritofWatert", "Story_07_Taretha", "Story_07_TarethasMemory", "Story_07_TarethasMemorye", "Story_07_Thrall_006p", "Story_07_Thrall_007p", "Story_07_Warmaster", "Story_07_WildElemental", "Story_07_WildSpiritWolf", "Story_07_Ysera", "Story_08_AncientofWind", "Story_08_AncientofWindta", "Story_08_AncientofWindtb", "Story_08_ArchdruidsBlessing", "Story_08_Archimonde_004p", "Story_08_Cenarius_001p", "Story_08_CenariusMinion", "Story_08_DarnassianNightsaber", "Story_08_EmeraldExplorer", "Story_08_Fertilize", "Story_08_ForestOwl", "Story_08_Gibberling", "Story_08_Guidance", "Story_08_Malfurion_007p", "Story_08_Malfurion_008p", "Story_08_MalfurionBear", "Story_08_MalfurionBear_001p", "Story_08_MalfurionCat", "Story_08_MalfurionCat_001p", "Story_08_Naisha", "Story_08_NatureStudies", "Story_08_NetherweaveBandage", "Story_08_Planting", "Story_08_Powershifting", "Story_08_PriestessMaiev", "Story_08_PriestessMaievFake", "Story_08_TyrandePriestess", "Story_08_UndercityHuckster", "Story_08_WellofEternity", "Story_08_WildStag", "Story_09_AnimatedBroomstick", "Story_09_CacheofCash", "Story_09_CurseofWeakness", "Story_09_DragonEggPuzzle", "Story_09_ElekkGrazer", "Story_09_FelLordBetrug", "Story_09_FiendishCircle", "Story_09_FontofPower", "Story_09_GrimoireofSacrifice", "Story_09_Guldan_001p", "Story_09_Guldan_002p", "Story_09_HandofGuldan", "Story_09_Helboar", "Story_09_HoardingDragon", "Story_09_HungryDragon", "Story_09_PrimordialProtector", "Story_09_PrimordialStudies", "Story_09_RavenFamiliar", "Story_09_RingToss", "Story_09_RingTosst", "Story_09_RitualofDoom", "Story_09_SenseDemons", "Story_09_ServantofKalimos", "Story_09_ShadowCouncil", "Story_09_ShadowCouncil_Puzzle", "Story_09_ShadowreaverWarlock", "Story_09_Soularium", "Story_09_Soulwringer", "Story_09_SpiritJailer", "Story_09_TerongorShaman", "Story_09_ViciousFelhound", "Story_09_VioletWurm", "Story_09_ZuluhedMinion", "Story_10_BloodElfAllies", "Story_10_BrokenAllies", "Story_10_BrothersStormrage_004", "Story_10_FatesDemand", "Story_10_GreaterMyrmidon", "Story_10_Illidan_003p", "Story_10_Illidan_004p", "Story_10_Illidan_005p", "Story_10_Illidan_006p", "Story_10_Illidan_008p", "Story_10_IllidariStudies", "Story_10_KaldoreiMemories", "Story_10_LadyVashj2", "Story_10_LordofOutland", "Story_10_Malfurion_004p", "Story_10_MoargPainsmith", "Story_10_MurgulReaver", "Story_10_NagaAllies", "Story_10_NagaArmy", "Story_10_NagaMyrmidon", "Story_10_ParasiticShadowfiend", "Story_10_PrimordialStudies", "Story_10_SecondSlice", "Story_10_ShadowStrike", "Story_10_SkullofGuldanSpell", "Story_10_SummonShadowDemons", "Story_10_Tranquility", "Story_10_TwinSlice", "Story_10_UnleashedTerrorguard", "Story_10_Velas_004p", "Story_10_VengefulCryptLord", "Story_10_WardensDetermination", "Story_11_AbyssalEnvoy", "Story_11_AncientTrident", "Story_11_AquaticForm", "Story_11_BackupPlan", "Story_11_BagofCoinsPuzzle", "Story_11_BehemothsLure", "Story_11_BlackwaterBehemoth", "Story_11_BoldCharge", "Story_11_BoldCharge2", "Story_11_BoldCharge3", "Story_11_BoldCharge3e", "Story_11_BrightIdea", "Story_11_BrightIdeae", "Story_11_Bubblebote", "Story_11_BubblebotPuzzle", "Story_11_BubbleUp", "Story_11_BubbleUpe", "Story_11_Caye_012p", "Story_11_Caye_013p", "Story_11_Caye_1", "Story_11_Caye_2", "Story_11_Caye_3", "Story_11_ClockworkGoblinPuzzle", "Story_11_Dathril2", "Story_11_DredgeLord", "Story_11_DredgeLorde", "Story_11_ExceptionalAide", "Story_11_ExceptionalAide2", "Story_11_ExceptionalAide3", "Story_11_ExplorersSceptor", "Story_11_ExploretheSeas", "Story_11_ExploretheSeas2", "Story_11_ExploretheSeas3", "Story_11_Extinguish", "Story_11_FacelessSummonPuzzle", "Story_11_Faelin_002p", "Story_11_Faelin_003p", "Story_11_Faelin_005p", "Story_11_Faelin_006p", "Story_11_Faelin_007p", "Story_11_Faelin_009p", "Story_11_Faelin_010p", "Story_11_Faelin_011p", "Story_11_Faelin_015p", "Story_11_Faelin_016p", "Story_11_Faelin_1", "Story_11_Faelin_2", "Story_11_Finley_009p", "Story_11_Finley_1", "Story_11_Finley_2", "Story_11_Finley_3", "Story_11_FinleysDad", "Story_11_FinleysMum", "Story_11_FlamewreathedFaceless", "Story_11_FreezingPotione", "Story_11_FreshSeawaterB", "Story_11_FrontLines", "Story_11_GiantTentaclePuzzle", "Story_11_GoneFishinPuzzle", "Story_11_Grace_1", "Story_11_Grace_2", "Story_11_Grace_3", "Story_11_Halus_010p", "Story_11_Halus_1", "Story_11_Halus_2", "Story_11_Halus_3", "Story_11_Hedra", "Story_11_HighSeasRevenge", "Story_11_HighSeasRevengee", "Story_11_IgnitionFireA", "Story_11_Ini_1", "Story_11_Ini_2", "Story_11_InisToolkite", "Story_11_IniToolkit", "Story_11_LadyAshvane", "Story_11_LightningBloom", "Story_11_MechaShark", "Story_11_MetaltoothLeapPuzzle", "Story_11_MoonlitGuidance", "Story_11_Mothership", "Story_11_Motivate3", "Story_11_Motivate3e", "Story_11_NatureStudies", "Story_11_Overboard", "Story_11_ParrrleyPuzzle", "Story_11_Pashmar", "Story_11_PowerUp", "Story_11_PriestessMemory", "Story_11_PureofHeart", "Story_11_PureofHearte", "Story_11_QuickFix", "Story_11_QuickFix2", "Story_11_RadarDetector", "Story_11_RadianceofAzshara", "Story_11_RearrangeCargo", "Story_11_Renew", "Story_11_RocketBoots", "Story_11_SeafloorSaviorPuzzle", "Story_11_SeascoutPuzzle", "Story_11_SeaSummoning", "Story_11_SecurityAutoPuzzle", "Story_11_SerpentWig", "Story_11_ShipShape", "Story_11_Silivaz", "Story_11_SouthseaPuzzle", "Story_11_SplosiveSolutions", "Story_11_SunkenBanshee", "Story_11_SunkenSweeper", "Story_11_SuperiorEfficiency2e", "Story_11_SupplyChain", "Story_11_SupportBot", "Story_11_SupportBote", "Story_11_Swap", "Story_11_Swap2", "Story_11_Swap2e", "Story_11_Swap3", "Story_11_Swap3e", "Story_11_Swape", "Story_11_SwapPlayer", "Story_11_SwapPlayer2", "Story_11_SwapPlayer3", "Story_11_Tenacity", "Story_11_Tenacitye", "Story_11_Tooltime", "Story_11_TrashedDreams", "Story_11_TrashedDreamse", "Story_11_TrueHeroism", "Story_11_TrueHeroism2e", "Story_11_TrueHeroisme", "Story_11_Valiance", "Story_11_Valiancee", "Story_11_VespersCannone", "Story_11_Zaqul", "SW_001e", "SW_006", "SW_021", "SW_023", "SW_024", "SW_026", "SW_028", "SW_028t2", "SW_028t5", "SW_028t6", "SW_029", "SW_030", "SW_031", "SW_031t", "SW_031t2", "SW_034", "SW_035", "SW_036", "SW_039t3", "SW_041", "SW_042", "SW_045", "SW_049", "SW_052", "SW_052t", "SW_052t2", "SW_052t6", "SW_054", "SW_056", "SW_059", "SW_060", "SW_064", "SW_065", "SW_067", "SW_068", "SW_069", "SW_070", "SW_076", "SW_079e4", "SW_079e5", "SW_079t", "SW_079te", "SW_081", "SW_085", "SW_086", "SW_087", "SW_087e", "SW_087e2", "SW_087t", "SW_091", "SW_091t", "SW_091t3", "SW_093", "SW_094", "SW_095", "SW_097t", "SW_114", "SW_305", "SW_307", "SW_310", "SW_313", "SW_313t", "SW_313t2", "SW_315", "SW_316", "SW_316e", "SW_320", "SW_322t", "SW_322t2", "SW_400", "SW_405", "SW_411", "SW_418", "SW_418e2", "SW_422", "SW_422a", "SW_422b", "SW_428", "SW_428t", "SW_428t2", "SW_428t4", "SW_429", "SW_432", "SW_432e", "SW_433", "SW_433t", "SW_433t2", "SW_433t3", "SW_434", "SW_437", "SW_437e", "SW_439", "SW_439t", "SW_440", "SW_443", "SW_443e", "SW_450", "SW_450t", "SW_450t2", "SW_455", "SW_457", "SW_458", "SW_458e", "SW_462", "SW_462e", "SW_463", "SW_COIN1", "SW_COIN2", "TB_006", "TB_007", "TB_01_BOM_Mercs_Cariel_001p", "TB_01_BOM_Mercs_Kurtrus_001p", "TB_01_BOM_Mercs_Scabbs_001p", "TB_01_BOM_Mercs_Xyrella_001p", "TB_011", "TB_207_BagOfSpells", "TB_207_MaskedBall", "TB_207CatacombQ", "TB_207masterChest", "TB_3Wishes_Spell", "TB_3Wishes_Spell_2", "TB_abBerskp", "TB_abHealp", "TB_abSpdp", "TB_AVH_002", "TB_AVH_007", "TB_AVH_017", "TB_AVH_025", "TB_AVH_026", "TB_AVH_027", "TB_AVH_HP011", "TB_AVH_HP012", "TB_AVH_HP013", "TB_AVH_HP014", "TB_AVH_HP015", "TB_AVH_HP016", "TB_AVH_HP020", "TB_AVH_HP021", "TB_AVH_HP022", "TB_AVH_HP023", "TB_AVH_HP024", "TB_Bacon_Secrets_01", "TB_Bacon_Secrets_02", "TB_Bacon_Secrets_04", "TB_Bacon_Secrets_05", "TB_Bacon_Secrets_07", "TB_Bacon_Secrets_08", "TB_Bacon_Secrets_09", "TB_Bacon_Secrets_10", "TB_Bacon_Secrets_11", "TB_Bacon_Secrets_12", "TB_Bacon_Secrets_13", "TB_BaconShop_8p_Sell2", "TB_BaconShop_8p_Sell2_Button", "TB_BaconShop_HERO_10_Buddy", "TB_BaconShop_HERO_10_Buddy_G", "TB_BaconShop_HERO_16_Buddy", "TB_BaconShop_HERO_16_Buddy_G", "TB_BaconShop_HERO_18_Buddy", "TB_BaconShop_HERO_18_Buddy_G", "TB_BaconShop_HERO_22_Buddy", "TB_BaconShop_HERO_22_Buddy_G", "TB_BaconShop_HERO_23_ALTp", "TB_BaconShop_HERO_23_Buddy", "TB_BaconShop_HERO_23_Buddy_G", "TB_BaconShop_HERO_27_Buddy", "TB_BaconShop_HERO_27_Buddy_G", "TB_BaconShop_HERO_28_Buddy", "TB_BaconShop_HERO_28_Buddy_G", "TB_BaconShop_HERO_34_Buddy", "TB_BaconShop_HERO_34_Buddy_G", "TB_BaconShop_HERO_35_Buddy_t2", "TB_BaconShop_HERO_35_Buddy_t3", "TB_BaconShop_HERO_35_Buddy_t6t", "TB_BaconShop_HERO_35_Buddy_t8", "TB_BaconShop_HERO_37_Buddy", "TB_BaconShop_HERO_38_Buddy", "TB_BaconShop_HERO_38_Buddy_G", "TB_BaconShop_HERO_40_Buddy", "TB_BaconShop_HERO_40_Buddy_G", "TB_BaconShop_HERO_50_Buddy_G", "TB_BaconShop_HERO_56_Buddy", "TB_BaconShop_HERO_56_Buddy_G", "TB_BaconShop_HERO_64_Buddy", "TB_BaconShop_HERO_64_Buddy_G", "TB_BaconShop_HERO_74_Buddy", "TB_BaconShop_HERO_74_Buddy_G", "TB_BaconShop_HERO_75_Buddy", "TB_BaconShop_HERO_75_Buddy_G", "TB_BaconShop_HERO_76_Buddy", "TB_BaconShop_HERO_76_Buddy_G", "TB_BaconShop_HERO_92_Buddy", "TB_BaconShop_HERO_92_Buddy_G", "TB_BaconShop_HERO_94_Buddy", "TB_BaconShop_HERO_94_Buddy_G", "TB_BaconShop_HERO_95_Buddy", "TB_BaconShop_HERO_95_Buddy_G", "TB_BaconShop_HERO_96p", "TB_BaconShop_HP_001", "TB_BaconShop_HP_008a", "TB_BaconShop_HP_010", "TB_BaconShop_HP_011", "TB_BaconShop_HP_012", "TB_BaconShop_HP_013", "TB_BaconShop_HP_017", "TB_BaconShop_HP_017e", "TB_BaconShop_HP_018", "TB_BaconShop_HP_020", "TB_BaconShop_HP_022_ALT", "TB_BaconShop_HP_022t", "TB_BaconShop_HP_024", "TB_BaconShop_HP_025", "TB_BaconShop_HP_031", "TB_BaconShop_HP_034", "TB_BaconShop_HP_036", "TB_BaconShop_HP_037a", "TB_BaconShop_HP_038", "TB_BaconShop_HP_038t", "TB_BaconShop_HP_039", "TB_BaconShop_HP_040", "TB_BaconShop_HP_041", "TB_BaconShop_HP_041a", "TB_BaconShop_HP_041b", "TB_BaconShop_HP_041c", "TB_BaconShop_HP_041d", "TB_BaconShop_HP_041f", "TB_BaconShop_HP_041g", "TB_BaconShop_HP_041h", "TB_BaconShop_HP_041i", "TB_BaconShop_HP_041j", "TB_BaconShop_HP_045", "TB_BaconShop_HP_047", "TB_BaconShop_HP_047t", "TB_BaconShop_HP_049", "TB_BaconShop_HP_050", "TB_BaconShop_HP_051", "TB_BaconShop_HP_057", "TB_BaconShop_HP_058", "TB_BaconShop_HP_064", "TB_BaconShop_HP_070", "TB_BaconShop_HP_072", "TB_BaconShop_HP_073", "TB_BaconShop_HP_076", "TB_BaconShop_HP_080", "TB_BaconShop_HP_080t", "TB_BaconShop_HP_084", "TB_BaconShop_HP_085", "TB_BaconShop_HP_086", "TB_BaconShop_HP_087t", "TB_BaconShop_HP_100", "TB_BaconShop_HP_101", "TB_BaconShop_HP_101t2", "TB_BaconShop_HP_103", "TB_BaconShop_HP_106", "TB_BaconShop_HP_107", "TB_BaconShop_HP_702", "TB_BaconShop_Keysmith", "TB_BaconShop_Triples_01", "TB_BaconShopCombat", "TB_BaconShopCombat2", "TB_BaconShopHPHun1", "TB_BaconShopHPLock1", "TB_BaconShopHPPri1", "TB_BaconShopQuest", "TB_BaconShopQuestHand", "TB_BaconShopRandSpells_001", "TB_BaconShopRandSpells_002", "TB_BaconShopSell2", "TB_BaconUps_002", "TB_BaconUps_003", "TB_BaconUps_004", "TB_BaconUps_005", "TB_BaconUps_006", "TB_BaconUps_007", "TB_BaconUps_009", "TB_BaconUps_011", "TB_BaconUps_014", "TB_BaconUps_019", "TB_BaconUps_025", "TB_BaconUps_026", "TB_BaconUps_027", "TB_BaconUps_030", "TB_BaconUps_031", "TB_BaconUps_032", "TB_BaconUps_032e", "TB_BaconUps_034", "TB_BaconUps_035", "TB_BaconUps_039", "TB_BaconUps_040", "TB_BaconUps_041", "TB_BaconUps_042", "TB_BaconUps_044", "TB_BaconUps_049", "TB_BaconUps_050", "TB_BaconUps_051", "TB_BaconUps_052", "TB_BaconUps_059", "TB_BaconUps_061", "TB_BaconUps_062", "TB_BaconUps_063", "TB_BaconUps_064", "TB_BaconUps_066", "TB_BaconUps_067", "TB_BaconUps_068", "TB_BaconUps_069", "TB_BaconUps_070", "TB_BaconUps_071", "TB_BaconUps_072", "TB_BaconUps_073", "TB_BaconUps_074", "TB_BaconUps_077", "TB_BaconUps_080", "TB_BaconUps_082", "TB_BaconUps_083", "TB_BaconUps_084", "TB_BaconUps_085", "TB_BaconUps_086", "TB_BaconUps_087", "TB_BaconUps_089", "TB_BaconUps_090", "TB_BaconUps_092", "TB_BaconUps_093", "TB_BaconUps_100", "TB_BaconUps_106", "TB_BaconUps_108", "TB_BaconUps_112", "TB_BaconUps_113", "TB_BaconUps_120", "TB_BaconUps_121", "TB_BaconUps_123", "TB_BaconUps_124", "TB_BaconUps_130", "TB_BaconUps_132t", "TB_BaconUps_137", "TB_BaconUps_138", "TB_BaconUps_139", "TB_BaconUps_140", "TB_BaconUps_141", "TB_BaconUps_142", "TB_BaconUps_144", "TB_BaconUps_145", "TB_BaconUps_152", "TB_BaconUps_154", "TB_BaconUps_162", "TB_Baconups_203", "TB_BaconUps_207", "TB_BaconUps_250", "TB_BaconUps_252", "TB_BaconUps_254", "TB_BaconUps_256", "TB_BaconUps_258", "TB_BaconUps_300", "TB_BaconUps_303", "TB_BaconUps_304", "TB_BaconUps_308", "TB_BaconUps_320", "TB_BBR3_BOSS_02p", "TB_BBR3_Boss_04p", "TB_BBR3_BOSS_05p", "TB_BBR3_BOSS_07p", "TB_BBR3_BOSS_09p", "TB_BlingBrawl_Blade1e", "TB_BossRumble_001hp", "TB_BossRumble_002hp", "TB_BossRumble_003hp", "TB_BountyHunt_Consume", "TB_BRMA10_3H", "TB_Champs_EX1_145", "TB_Champs_EX1_145e", "TB_Champs_EX1_145o", "TB_CheaterChess_Black", "TB_Chupacabran_HP", "TB_ckAutoAdapt", "TB_ckAutoBrawlCrackRazormaw", "TB_ckAutoDiscover", "TB_ckAutoDiscover2", "TB_ckAutoFight7SemiRand", "TB_ckAutoQuest", "TB_ckSellFriend", "TB_ckSellFriend2", "TB_CoOpBossSpell_3", "TB_CoOpBossSpell_4", "TB_CoOpv3_003", "TB_CoOpv3_009", "TB_CoOpv3_010", "TB_Coopv3_101", "TB_Coopv3_102", "TB_Coopv3_102b", "TB_Coopv3_104", "TB_Coopv3_104_NewClasses", "TB_DiscoverMyDeck_Discovery", "TB_DK_Guldan", "TB_DK_Jaina", "TB_DK_Malfurion", "TB_DK_Valeera", "TB_DK_Valeera_HP", "TB_EVILBRM_BoomHeroPower", "TB_EVILBRM_GarrSummon", "TB_EVILBRM_LOOTA_813", "TB_EVILBRM_OnyxiaHeroPower", "TB_EVILBRM_RafaamHeroPower", "TB_EVILBRM_RafaamHeroPower2", "TB_FactionWar_AnnoySpell1", "TB_FactionWar_AnnoySpell1_Update", "TB_FactionWar_AnnoySpell2", "TB_FactionWar_Boss_RagFirst", "tb_Fairytalecard_01", "tb_Fairytalecard_02e", "tb_Fairytalecard_03", "tb_Fairytalecard_04", "tb_Fairytalecard_05", "tb_Fairytalecard_06", "tb_Fairytalecard_07", "TB_Firefest2_003", "TB_Firefest2a", "TB_Firefest2b", "TB_Firefest2c", "TB_Firefest2d", "TB_FullCannon", "TB_FullCannonV2", "TB_FullCannonV3", "TB_FW_DrBoomMega", "TB_FW_ImbaTron", "TB_FW_OmegaMax", "TB_GiftExchange_Treasure", "TB_GiftExchange_Treasure_Spell", "TB_GiftReceiptSpell", "TB_HeadlessHorseman_003", "TB_HeadlessHorseman_004", "TB_HeadlessHorseman_HP5", "TB_HeadlessHorseman_HP6", "TB_HeadlessHorseman_s001a", "TB_HeadlessHorseman_s001b", "TB_HeadlessHorseman_s001c", "TB_HeadlessHorseman_s001d", "TB_HeadlessRedux_002", "TB_Henchmania_ChuH", "TB_Henchmania_DiscoverA", "TB_Henchmania_DiscoverAe", "TB_Henchmania_DiscoverC", "TB_Henchmania_MyraH", "TB_Ignoblegarden1", "TB_Ignoblegarden2", "TB_Ignoblegarden2e", "TB_Investigation_002hp", "TB_John_001p5", "TB_John_001p7", "TB_John_003e", "TB_John_004", "TB_John_004p", "TB_John_201", "TB_John_203", "TB_John_204", "TB_John_205", "TB_John_207", "TB_John_208", "TB_John_210", "TB_John_211", "TB_John_212", "TB_John_213", "TB_John_214", "TB_John_216", "TB_John_217", "TB_John_218", "TB_John_302", "TB_KaraPortal_001", "TB_KaraPortal_002", "TB_KaraPortal_003", "TB_KoboldGiftMinion", "TB_KT_AnubarakHP", "TB_KTRAF_1", "TB_KTRAF_10", "TB_KTRAF_101", "TB_KTRAF_2", "TB_KTRAF_3", "TB_KTRAF_4", "TB_KTRAF_6", "TB_KTRAF_HP_KT_3", "TB_KTRAF_HP_RAF3", "TB_KTRAF_HP_RAF4", "TB_KTRAF_HP_RAF5", "TB_LEAGUE_REVIVAL_BrannAIHp", "TB_LEAGUE_REVIVAL_FinleyChest", "TB_LEAGUE_REVIVAL_TekahnAIHp", "TB_LEAGUE_REVIVAL_TerravisHp", "TB_LL_ArchwitchWillow", "TB_LL_BarakKodobane", "TB_LL_Blackthorn", "TB_LL_Fireheart", "TB_LL_Sonya", "TB_LL_Whatley", "TB_LOEA13_2", "TB_Lunar_Dog", "TB_Lunar_DogE", "TB_Lunar_DogEe", "TB_Lunar_Dragon", "TB_Lunar_DragonE", "TB_Lunar_Monkey", "TB_Lunar_MonkeyE", "TB_Lunar_Ox", "TB_Lunar_OxE", "TB_Lunar_Pig", "TB_Lunar_PigE", "TB_Lunar_Rabbit", "TB_Lunar_RabbitE", "TB_Lunar_Rat", "TB_Lunar_RatE", "TB_Lunar_Snake", "TB_Lunar_SnakeE", "TB_Lunar_Tiger", "TB_Lunar_TigerE", "TB_MagicalGuardians_Copycat", "TB_MagicalGuardians_MagicSpell", "TB_MagicalGuardians_Malygos", "TB_MammothParty_302", "TB_Marin_001", "TB_MartinAutoDiscover2", "TB_MartinAutoFight7SemiRand", "TB_MartinAutoQuest", "TB_MartinSellFriend2", "TB_MatchGame_Shuffle", "TB_MechWar_Boss1_HeroPower", "TB_MP_02e", "TB_Murgstone_001", "TB_Noblegarden_005", "TB_Noblegarden_006", "TB_NvP_HP002", "TB_NvP_HP003", "TB_NvP_HP004", "TB_NvP_HP005", "TB_PickYourFate_11b", "TB_PickYourFate_4_EnchMinion", "TB_PickYourFate_6", "TB_PingPong_003", "TB_Presents_001", "TB_Presents_002", "TB_Presents_003", "TB_Rage_003", "TB_Rage_004", "TB_ReturningPlayer_HoundmastHP", "TB_RoadToNR_Finley_HP", "TB_RoadToNR_OrgrimmarHP", "TB_RoadToNR_RenoHP", "TB_SC20_001a", "TB_SC20_001b", "TB_SC20_001c", "TB_SC20_002", "TB_SC20_003", "TB_SC20_004", "TB_SPT_BossHeroPower", "TB_SPT_DALA_BossHeroPower", "TB_SPT_DALA_Minion1", "TB_SPT_DALA_Minion3", "TB_SPT_DPromoHP", "TB_SPT_DPromoSecre8", "TB_SPT_DPromoSecret1", "TB_SPT_DPromoSecret10", "TB_SPT_DPromoSecret2", "TB_SPT_DPromoSecret3", "TB_SPT_DPromoSecret4", "TB_SPT_DPromoSecret5", "TB_SPT_DPromoSecret6", "TB_SPT_DPromoSecret9", "TB_SPT_DPromoSpell2", "TB_SPT_DPromoSpellBovine1", "TB_SPT_DPromoSpellPortal2", "TB_SPT_Minion1", "TB_SPT_Minion3", "TB_SPT_MTH_BossHeroPower", "TB_SPT_MTH_Minion1", "TB_SPT_MTH_Minion3", "TB_Superfriends001e", "TB_Superfriends002e", "TB_TagTeam_Warlock", "TB_TempleOutrun_DALA_719", "TB_TempleOutrun_Lazul_HP", "TB_TempleOutrun_Lazul_HP3", "TB_TempleOutrun_Treasure_Reno1", "TB_ThunderdomeWeaponC", "TB_ThunderdomeWeaponD", "TB_ThunderdomeWeaponF", "TBA01_5", "TBA01_6", "TBST_003", "TBST_004", "TBUD_1", "TID_003", "TID_005", "TID_078", "TID_078e", "TID_703", "TID_707", "TID_709t3", "TID_710", "TID_714", "TID_715", "TID_718", "TID_920", "TID_931", "TID_949", "TOT_004", "TOT_005", "TOT_006", "TOT_007", "TOT_008", "TOT_013", "TOT_014", "TOT_014a", "TOT_014b", "TOT_015", "TOT_016", "TOT_017", "TOT_018", "TOT_022", "TOT_026", "TOT_028", "TOT_029", "TOT_030", "TOT_030t1", "TOT_030t2", "TOT_030t3", "TOT_031", "TOT_032", "TOT_035", "TOT_037", "TOT_038", "TOT_039", "TOT_041", "TOT_045", "TOT_046", "TOT_049", "TOT_050", "TOT_054", "TOT_056", "TOT_057", "TOT_058", "TOT_061", "TOT_063", "TOT_067", "TOT_068", "TOT_069", "TOT_102", "TOT_103", "TOT_106", "TOT_107", "TOT_108", "TOT_111", "TOT_112", "TOT_113", "TOT_114", "TOT_114t", "TOT_115", "TOT_200", "TOT_201", "TOT_203", "TOT_204", "TOT_206", "TOT_208", "TOT_210", "TOT_300", "TOT_301", "TOT_301e", "TOT_302", "TOT_306e", "TOT_306h", "TOT_306t", "TOT_308", "TOT_309", "TOT_311", "TOT_313", "TOT_316", "TOT_320", "TOT_330", "TOT_334", "TOT_341", "TOT_343", "TOT_345", "TRL_010", "TRL_015", "TRL_020", "TRL_057", "TRL_058", "TRL_058e", "TRL_071", "TRL_074", "TRL_077", "TRL_082", "TRL_082e", "TRL_096", "TRL_097", "TRL_119", "TRL_124", "TRL_126", "TRL_128", "TRL_131", "TRL_151", "TRL_156", "TRL_232", "TRL_243", "TRL_244", "TRL_247", "TRL_249", "TRL_254", "TRL_254a", "TRL_254b", "TRL_255", "TRL_259", "TRL_260", "TRL_302", "TRL_304", "TRL_305", "TRL_306", "TRL_307", "TRL_310", "TRL_310e", "TRL_318", "TRL_324", "TRL_329", "TRL_339", "TRL_349", "TRL_351", "TRL_362", "TRL_363", "TRL_400", "TRL_405", "TRL_503", "TRL_504", "TRL_506", "TRL_507", "TRL_509", "TRL_509t", "TRL_517", "TRL_520", "TRL_521", "TRL_523", "TRL_525", "TRL_527", "TRL_528", "TRL_531", "TRL_537", "TRL_541", "TRL_542", "TRL_566", "TRL_900", "TRL_901", "TRL_COIN", "TRLA_105", "TRLA_106", "TRLA_115", "TRLA_116", "TRLA_121", "TRLA_122", "TRLA_123", "TRLA_125", "TRLA_127", "TRLA_130", "TRLA_134", "TRLA_135", "TRLA_139", "TRLA_140", "TRLA_144", "TRLA_148", "TRLA_150", "TRLA_151", "TRLA_156", "TRLA_159", "TRLA_161", "TRLA_163", "TRLA_164", "TRLA_165", "TRLA_166", "TRLA_169", "TRLA_170", "TRLA_172", "TRLA_173", "TRLA_176", "TRLA_178", "TRLA_180", "TRLA_184", "TRLA_186", "TRLA_188", "TRLA_192", "TRLA_807", "TRLA_807e2", "TRLA_809", "TRLA_809e2", "TSC_006", "TSC_020", "TSC_026t", "TSC_034", "TSC_039t", "TSC_052", "TSC_054", "TSC_059", "TSC_061", "TSC_069", "TSC_070", "TSC_072", "TSC_076", "TSC_079", "TSC_083", "TSC_210", "TSC_213", "TSC_215", "TSC_216t", "TSC_608", "TSC_609", "TSC_614", "TSC_631", "TSC_632", "TSC_633", "TSC_638", "TSC_638t", "TSC_638t2", "TSC_638t3", "TSC_638t4", "TSC_640", "TSC_641tb", "TSC_641td", "TSC_643", "TSC_644t", "TSC_645", "TSC_646", "TSC_648", "TSC_649", "TSC_650", "TSC_650a", "TSC_650d", "TSC_654", "TSC_656", "TSC_658", "TSC_660", "TSC_702", "TSC_753", "TSC_772", "TSC_772t", "TSC_776t", "TSC_823", "TSC_823e", "TSC_908", "TSC_912", "TSC_912t", "TSC_916", "TSC_917", "TSC_922", "TSC_923", "TSC_925", "TSC_927", "TSC_927t", "TSC_928", "TSC_929", "TSC_929t", "TSC_938", "TSC_941", "TSC_942", "TSC_943", "TSC_944", "TSC_945t", "TSC_946", "TSC_947", "TSC_948", "TSC_950", "TSC_950t", "TSC_950t2", "TSC_952", "TSC_957", "TSC_959", "TSC_960", "TSC_COIN1", "TSC_COIN2", "tt_010", "TU4c_006", "TU4c_008", "TU4e_002", "TU4f_004", "TU5_CS2_023", "TU5_CS2_147", "TU5_CS2_196", "TU5_DS1_055", "TU5_EX1_011", "TU5_EX1_015", "TUT_MLondon01", "ULD_131", "ULD_134", "ULD_135", "ULD_135a", "ULD_135b", "ULD_136", "ULD_140", "ULD_140p", "ULD_143", "ULD_145", "ULD_152", "ULD_154", "ULD_155", "ULD_155p", "ULD_156", "ULD_160", "ULD_167", "ULD_171", "ULD_174", "ULD_177", "ULD_178", "ULD_178a", "ULD_178a2", "ULD_178a3", "ULD_178a4", "ULD_182", "ULD_183", "ULD_186", "ULD_189", "ULD_191", "ULD_195", "ULD_196", "ULD_197", "ULD_208", "ULD_209", "ULD_209t", "ULD_212", "ULD_215", "ULD_216", "ULD_217", "ULD_229", "ULD_231", "ULD_236", "ULD_250", "ULD_253", "ULD_256", "ULD_258", "ULD_262", "ULD_265", "ULD_266", "ULD_268", "ULD_270", "ULD_273", "ULD_276", "ULD_285", "ULD_286", "ULD_286t", "ULD_291", "ULD_292", "ULD_292a", "ULD_292b", "ULD_304", "ULD_309", "ULD_326", "ULD_327", "ULD_328", "ULD_413", "ULD_429", "ULD_430", "ULD_431", "ULD_431p", "ULD_433", "ULD_433p", "ULD_438", "ULD_439", "ULD_500", "ULD_616", "ULD_702", "ULD_705", "ULD_711", "ULD_711p3", "ULD_712", "ULD_713", "ULD_715", "ULD_716", "ULD_719", "ULD_720", "ULD_724", "ULD_724p", "ULD_726", "ULD_727", "ULD_COIN", "ULDA_001", "ULDA_002", "ULDA_003", "ULDA_004", "ULDA_004e", "ULDA_008", "ULDA_012", "ULDA_013", "ULDA_014", "ULDA_015", "ULDA_016", "ULDA_018", "ULDA_020", "ULDA_021", "ULDA_023", "ULDA_039", "ULDA_040", "ULDA_045t", "ULDA_111", "ULDA_116", "ULDA_117", "ULDA_203", "ULDA_205", "ULDA_301", "ULDA_302", "ULDA_303", "ULDA_304", "ULDA_305", "ULDA_307", "ULDA_307ts", "ULDA_402", "ULDA_402e", "ULDA_405", "ULDA_406", "ULDA_407", "ULDA_502", "ULDA_504", "ULDA_507", "ULDA_601", "ULDA_602", "ULDA_603", "ULDA_604", "ULDA_606", "ULDA_607", "ULDA_701e2", "ULDA_712", "ULDA_801t", "ULDA_804t", "ULDA_BOSS_01p", "ULDA_BOSS_01px", "ULDA_BOSS_02p", "ULDA_BOSS_02px", "ULDA_BOSS_03p", "ULDA_BOSS_04p", "ULDA_BOSS_04px", "ULDA_BOSS_07p", "ULDA_BOSS_08p", "ULDA_BOSS_08px", "ULDA_BOSS_09p", "ULDA_BOSS_11p", "ULDA_BOSS_12p", "ULDA_BOSS_12px", "ULDA_BOSS_13p", "ULDA_BOSS_15p", "ULDA_BOSS_15px", "ULDA_BOSS_16e", "ULDA_BOSS_17e", "ULDA_BOSS_17p", "ULDA_BOSS_17px", "ULDA_BOSS_19p", "ULDA_BOSS_19px", "ULDA_BOSS_21p", "ULDA_BOSS_25p", "ULDA_BOSS_27px", "ULDA_BOSS_31p", "ULDA_BOSS_31px", "ULDA_BOSS_32p", "ULDA_BOSS_36p", "ULDA_BOSS_36px", "ULDA_BOSS_37p1", "ULDA_BOSS_39m", "ULDA_BOSS_39p3", "ULDA_BOSS_39px3", "ULDA_BOSS_40p3", "ULDA_BOSS_41p", "ULDA_BOSS_41px", "ULDA_BOSS_42e", "ULDA_BOSS_42e2", "ULDA_BOSS_42p", "ULDA_BOSS_42px", "ULDA_BOSS_43p", "ULDA_BOSS_43px", "ULDA_BOSS_47p", "ULDA_BOSS_48p", "ULDA_BOSS_49p", "ULDA_BOSS_49px", "ULDA_BOSS_55p", "ULDA_BOSS_56p", "ULDA_BOSS_62p", "ULDA_BOSS_66p", "ULDA_BOSS_66px", "ULDA_BOSS_70p", "ULDA_BOSS_70px", "ULDA_BOSS_71p", "ULDA_BOSS_71px", "ULDA_BOSS_77p", "ULDA_BOSS_77px", "ULDA_BOSS_79p", "ULDA_Brann_HP3", "ULDA_Elise_HP1", "ULDA_Elise_HP2", "ULDA_Finley_HP1", "ULDA_Finley_HP2", "ULDA_Finley_HP3", "UNG_002", "UNG_010", "UNG_011", "UNG_017", "UNG_017t1", "UNG_017t2", "UNG_020", "UNG_022", "UNG_024", "UNG_028", "UNG_029", "UNG_030", "UNG_032", "UNG_037", "UNG_047", "UNG_057", "UNG_060", "UNG_063", "UNG_065t", "UNG_067", "UNG_068", "UNG_072", "UNG_073", "UNG_075", "UNG_076", "UNG_078", "UNG_080", "UNG_082", "UNG_083", "UNG_086", "UNG_088", "UNG_089", "UNG_094t1", "UNG_094t2", "UNG_094t5", "UNG_098", "UNG_098t1", "UNG_100", "UNG_101", "UNG_103", "UNG_108", "UNG_109", "UNG_111t1", "UNG_116", "UNG_201", "UNG_208", "UNG_211b", "UNG_800", "UNG_809", "UNG_816", "UNG_823", "UNG_829", "UNG_829t2", "UNG_830", "UNG_832", "UNG_836", "UNG_842", "UNG_843", "UNG_845", "UNG_846", "UNG_851", "UNG_851t1", "UNG_854", "UNG_856", "UNG_900", "UNG_907", "UNG_912", "UNG_913", "UNG_914", "UNG_915", "UNG_916", "UNG_917", "UNG_917t1", "UNG_920", "UNG_920t1", "UNG_920t2", "UNG_922", "UNG_922t1", "UNG_923", "UNG_925", "UNG_926", "UNG_927", "UNG_934", "UNG_937", "UNG_938", "UNG_940", "UNG_940t1", "UNG_942", "UNG_942t", "UNG_948", "UNG_952", "UNG_952e", "UNG_954", "UNG_954t1", "UNG_957", "UNG_960", "UNG_961", "UNG_962", "UNG_963", "UNG_999t2", "UNG_999t2e", "UNG_COIN", "VAN_CS2_003", "VAN_CS2_004", "VAN_CS2_005", "VAN_CS2_007", "VAN_CS2_009", "VAN_CS2_011", "VAN_CS2_013", "VAN_CS2_023", "VAN_CS2_027", "VAN_CS2_038", "VAN_CS2_039", "VAN_CS2_041", "VAN_CS2_045", "VAN_CS2_046", "VAN_CS2_053", "VAN_CS2_059", "VAN_CS2_073", "VAN_CS2_074", "VAN_CS2_077", "VAN_CS2_087", "VAN_CS2_088", "VAN_CS2_089", "VAN_CS2_092", "VAN_CS2_102_H3", "VAN_CS2_103", "VAN_CS2_103_Puzzle", "VAN_CS2_104", "VAN_CS2_105", "VAN_CS2_117", "VAN_CS2_147", "VAN_CS2_151", "VAN_CS2_188", "VAN_CS2_196", "VAN_CS2_226", "VAN_CS2_236", "VAN_CS2_237", "VAN_DS1_055", "VAN_DS1_070", "VAN_DS1_184", "VAN_EX1_004", "VAN_EX1_011", "VAN_EX1_012", "VAN_EX1_014", "VAN_EX1_015", "VAN_EX1_019", "VAN_EX1_025", "VAN_EX1_043", "VAN_EX1_046", "VAN_EX1_058", "VAN_EX1_059", "VAN_EX1_076", "VAN_EX1_084", "VAN_EX1_089", "VAN_EX1_093", "VAN_EX1_096", "VAN_EX1_103", "VAN_EX1_110", "VAN_EX1_112", "VAN_EX1_116", "VAN_EX1_128", "VAN_EX1_130", "VAN_EX1_131", "VAN_EX1_132", "VAN_EX1_136", "VAN_EX1_145", "VAN_EX1_145e", "VAN_EX1_145o", "VAN_EX1_155", "VAN_EX1_158", "VAN_EX1_158e", "VAN_EX1_160", "VAN_EX1_160a", "VAN_EX1_160b", "VAN_EX1_164", "VAN_EX1_164a", "VAN_EX1_164b", "VAN_EX1_165", "VAN_EX1_169", "VAN_EX1_178", "VAN_EX1_244", "VAN_EX1_248", "VAN_EX1_284", "VAN_EX1_287", "VAN_EX1_289", "VAN_EX1_294", "VAN_EX1_295", "VAN_EX1_303", "VAN_EX1_316", "VAN_EX1_317", "VAN_EX1_339", "VAN_EX1_345", "VAN_EX1_349", "VAN_EX1_350", "VAN_EX1_354", "VAN_EX1_355", "VAN_EX1_362", "VAN_EX1_363", "VAN_EX1_365", "VAN_EX1_366", "VAN_EX1_371", "VAN_EX1_379", "VAN_EX1_392", "VAN_EX1_409", "VAN_EX1_506", "VAN_EX1_533", "VAN_EX1_534", "VAN_EX1_538", "VAN_EX1_549", "VAN_EX1_554", "VAN_EX1_556", "VAN_EX1_562", "VAN_EX1_570", "VAN_EX1_571", "VAN_EX1_572", "VAN_EX1_573", "VAN_EX1_573a", "VAN_EX1_573b", "VAN_EX1_575", "VAN_EX1_577", "VAN_EX1_583", "VAN_EX1_584", "VAN_EX1_587", "VAN_EX1_590", "VAN_EX1_597", "VAN_EX1_606", "VAN_EX1_611", "VAN_EX1_613", "VAN_EX1_614", "VAN_EX1_621", "VAN_EX1_623", "VAN_EX1_tk33", "VAN_HERO_01bp", "VAN_HERO_01bp2", "VAN_HERO_02bp", "VAN_HERO_02bp2", "VAN_HERO_04bp", "VAN_HERO_04bp2", "VAN_HERO_07bp", "VAN_HERO_07bp2", "VAN_HERO_09bp", "VAN_HERO_09bp2", "VAN_NEW1_008", "VAN_NEW1_008a", "VAN_NEW1_008b", "VAN_NEW1_009", "VAN_NEW1_014", "VAN_NEW1_016", "VAN_NEW1_018", "VAN_NEW1_024", "VAN_NEW1_026", "VAN_NEW1_031", "VAN_NEW1_036", "VAN_NEW1_037", "VAN_NEW1_040", "VAN_PRO_001", "VAN_PRO_001c", "VAN_tt_010", "WC_003", "WC_005", "WC_007", "WC_008", "WC_013", "WC_016", "WC_026", "WC_027", "WC_028", "WC_030", "WC_032", "WC_033", "WC_034", "WC_036", "WC_803", "WC_805", "XXX_003", "XXX_004", "XXX_007", "XXX_011", "XXX_016", "XXX_017", "XXX_021", "XXX_042", "XXX_048", "XXX_052", "XXX_053", "XXX_054", "XXX_055", "XXX_058", "XXX_061", "XXX_062", "XXX_122", "XXX_124", "XXX_126", "XXX_208", "XXX_209", "XXX_400", "XXX_410", "XXX_411", "XXX_412", "XXX_414", "XXX_415", "XXX_416", "XXX_417", "XXX_418", "XXX_419", "XXX_420", "XXX_56633", "XXX_72501", "XXX_74590", "XXX_Duels_001", "XXX_Duels_002", "XXX_Duels_004", "XXX_Duels_006", "YOD_001", "YOD_001b", "YOD_001c", "YOD_001ts", "YOD_004", "YOD_005", "YOD_005ts", "YOD_012", "YOD_012ts", "YOD_013", "YOD_015", "YOD_016", "YOD_017", "YOD_023", "YOD_024", "YOD_025", "YOD_026", "YOD_028", "YOD_029", "YOD_035", "YOD_038", "YOD_041", "YOD_043", "YOP_001", "YOP_001e", "YOP_003", "YOP_003t", "YOP_004", "YOP_005", "YOP_009", "YOP_010", "YOP_011", "YOP_015", "YOP_015t", "YOP_017", "YOP_018", "YOP_018e", "YOP_019", "YOP_022", "YOP_024", "YOP_024t", "YOP_025", "YOP_026", "YOP_029", "YOP_030", "YOP_032", "YOP_034" };
+        private static HashSet<string> unfriendlyCards = new HashSet<string>() { "AT_001", "AT_004", "AT_005", "AT_012", "AT_022", "AT_023", "AT_025", "AT_030", "AT_036", "AT_037", "AT_037a", "AT_044", "AT_050", "AT_050t", "AT_051", "AT_056", "AT_059", "AT_063", "AT_063t", "AT_064", "AT_078", "AT_081", "AT_094", "AT_103", "AT_105", "AT_106", "AT_110", "AT_122", "AT_123", "AT_130", "AT_131", "AT_132_HUNTER_H1", "AV_108", "AV_113t1", "AV_114", "AV_131", "AV_132", "AV_133", "AV_138", "AV_200p2", "AV_202p", "AV_203", "AV_207p2", "AV_212", "AV_218", "AV_222", "AV_224", "AV_250", "AV_251", "AV_255", "AV_257t", "AV_258pt3", "AV_258pt4", "AV_258t3", "AV_258t4", "AV_259", "AV_266", "AV_267", "AV_282t", "AV_282t3", "AV_282t5", "AV_285", "AV_313", "AV_315", "AV_316", "AV_322", "AV_324", "AV_331", "AV_704", "BAR_024", "BAR_027", "BAR_032", "BAR_044", "BAR_044t", "BAR_044t2", "BAR_066", "BAR_069", "BAR_071", "BAR_078", "BAR_079t12", "BAR_079t12c", "BAR_079t13", "BAR_079t13b", "BAR_079t13c", "BAR_305", "BAR_306", "BAR_311", "BAR_314", "BAR_314t", "BAR_314t2", "BAR_315", "BAR_316", "BAR_319", "BAR_319t", "BAR_319t2", "BAR_320", "BAR_334", "BAR_536", "BAR_536t", "BAR_536t2", "BAR_538", "BAR_541", "BAR_547", "BAR_705", "BAR_745", "BAR_748", "BAR_750", "BAR_801", "BAR_840", "BAR_845", "BAR_879", "BAR_879t", "BAR_888t", "BAR_911", "BAR_913", "BAR_916", "BCON_007", "BCON_008", "BCON_011", "BCON_019", "BCON_020", "BCON_021", "BCON_023", "BCON_025", "BG_DAL_775", "BG_DAL_775_G", "BG_FP1_024", "BG20_202", "BG20_202_G", "BG20_HERO_282p", "BG20_HERO_666p_t1a", "BG20_HERO_666p_t1b", "BG20_HERO_666p_t1c", "BG20_HERO_666p_t1d", "BG21_023", "BG21_023_G", "BG22_HERO_001p_t4", "BG22_HERO_001p_t4_s", "BG23_190", "BG23_314", "BG23_314_G", "BG23_318", "BG23_318_G", "BG24_719", "BG24_719_G", "BG24_Reward_535", "BGS_002", "BGS_004", "BGS_032", "BGS_055", "BGS_077", "BGS_130", "BGS_203", "BGS_Treasures_003", "BGS_Treasures_005", "BGS_Treasures_014", "BGS_Treasures_014e", "BGS_Treasures_034", "BGS_Treasures_036", "BOM_01_Brukan_02p1", "BOM_01_Brukan_03p1", "BOM_01_Brukan_04p1", "BOM_01_Brukan_05p1", "BOM_01_Brukan_06p1", "BOM_01_Brukan_07p1", "BOM_01_Dawngrasp_05p4", "BOM_01_Dawngrasp_06p4", "BOM_01_Dawngrasp_07p4", "BOM_01_Feegly_07p", "BOM_01_Twinbraid_06p", "BOM_02_Serena_02p", "BOM_02_TavishFiresAShot_01s", "BOM_02_Trixie_05p", "BOM_03_Brukan_02p", "BOM_03_Dawngrasp_08t", "BOM_03_PowerOfLove_08s", "BOM_03_Tamsin_02p", "BOM_03_ThunderBluff_01t", "BOM_04_Dawngrasp_006p", "BOM_04_HurlGlaive_002s", "BOM_04_Samuro_001p", "BOM_04_Sarilus_004p", "BOM_04_Scabbs_005p", "BOM_04_Scabbs_006p", "BOM_05_Brukan_004p", "BOM_05_HooktuskCannon_002t", "BOM_05_MemoryBurn_08s", "BOM_05_Xyrella_006p2", "BOM_06_Anetheron_005p", "BOM_06_Anetheron_005p2", "BOM_06_CarrionSwarm_005s1e1", "BOM_06_Kurtrus_006t2e1", "BOM_06_SniperTavish_004t", "BOM_07_Scabbs_Brukan_006t", "BOM_07_Scabbs_Brukan_007t", "BOM_07_Scabbs_Brukan_008t", "BOM_07_Scabbs_Cariel_008t", "BOM_07_Scabbs_Dawngrasp_006t", "BOM_07_Scabbs_Dawngrasp_007t", "BOM_07_Scabbs_Dawngrasp_008t", "BOM_07_Scabbs_Guff_006t", "BOM_07_Scabbs_Guff_007t", "BOM_07_Scabbs_Guff_008t", "BOM_07_Scabbs_Kurtrus_008t", "BOM_07_Scabbs_Prestor_002p", "BOM_07_Scabbs_Rokara_006t", "BOM_07_Scabbs_Rokara_007t", "BOM_07_Scabbs_Rokara_008t", "BOM_07_Scabbs_Tavish_008t", "BOM_07_Scabbs_Xyrella_005p", "BOM_07_Scabbs_Xyrella_006p", "BOM_07_Scabbs_Xyrella_007p", "BOM_07_Scabbs_Xyrella_008t", "BOM_08_Brukan_003t", "BOM_08_Brukan_008t", "BOM_08_Dawngrasp_003t", "BOM_08_Dawngrasp_008t", "BOM_08_KillCommand_004s", "BOM_08_Tavish_Galvangar_005p", "BOM_08_Tavish_Rokara_003p", "BOM_09_Brukan_007p", "BOM_09_Brukan_008p", "BOM_09_Dawngrasp_006t", "BOM_09_Dawngrasp_008t", "BOM_09_Fight_002_Lethal", "BOM_09_KnockOff_007s", "BOM_09_Lokholar_006p", "BOM_09_Rokara_003p", "BOM_09_Snivvle_004p", "BOM_09_Tamsin_008hb", "BOM_09_Tamsin_008p", "BOM_10_BreathOfFire_006s", "BOM_10_Broll_003t", "BOM_10_Dawngrasp_001p", "BOM_10_Dawngrasp_002p", "BOM_10_Dawngrasp_003p", "BOM_10_Dawngrasp_004p", "BOM_10_Dawngrasp_005p", "BOM_10_Dawngrasp_006p", "BOM_10_Dawngrasp_007p", "BOM_10_Dawngrasp_008p", "BOM_10_Lethal_Puzzle_006", "BOM_10_OnyxiaPhase1_004p", "BOM_10_ShardOfTheNaaru_008s", "BOM_10_TailSweep_006s", "BOM_10_WingBuffet_006s", "BOT_031", "BOT_033", "BOT_104", "BOT_107e", "BOT_222", "BOT_238p1", "BOT_238p3", "BOT_245", "BOT_246", "BOT_251", "BOT_251e", "BOT_257", "BOT_277", "BOT_277t2", "BOT_308", "BOT_447", "BOT_448", "BOT_453", "BOT_540", "BOT_544", "BOT_558", "BOT_601", "BOT_907", "BOTA_101", "BOTA_202", "BOTA_212", "BOTA_223", "BOTA_229", "BOTA_235", "BOTA_240", "BOTA_244", "BOTA_702", "BOTA_BOSS_20p4", "BRM_002", "BRM_003", "BRM_005", "BRM_008", "BRM_010", "BRM_011", "BRM_013", "BRM_015", "BRM_016", "BRM_027p", "BRM_027pH", "BRM_030t", "BRM_034", "BRMA03_2", "BRMA04_2", "BRMA04_3", "BRMA04_3H", "BRMA05_2", "BRMA05_2H", "BRMA05_3", "BRMA05_3e", "BRMA05_3H", "BRMA05_3He", "BRMA07_2", "BRMA07_2_2_TB", "BRMA07_2_2c_TB", "BRMA07_2H", "BRMA07_3", "BRMA08_3", "BRMA09_6", "BRMA11_3", "BRMA12_8", "BRMA13_5", "BRMA13_8", "BRMA14_5", "BRMA14_5H", "BRMA16_3", "BRMA16_4", "BRMA17_4", "BRMC_100", "BRMC_100e", "BRMC_91", "BT_002", "BT_011", "BT_020", "BT_026", "BT_072", "BT_100", "BT_106", "BT_109t", "BT_110", "BT_114", "BT_117", "BT_126", "BT_134", "BT_196", "BT_199", "BT_205", "BT_230", "BT_233", "BT_235", "BT_291", "BT_335t2", "BT_354", "BT_355", "BT_429", "BT_429p", "BT_429p2", "BT_490", "BT_493", "BT_514", "BT_601", "BT_714", "BT_717", "BT_722", "BT_723", "BT_724", "BT_729", "BT_732", "BT_737", "BT_740", "BT_801", "BT_937", "BTA_13", "BTA_BOSS_05p", "BTA_BOSS_07s2", "BTA_BOSS_10p", "BTA_BOSS_10p2", "BTA_BOSS_15s", "BTA_BOSS_17p", "BTA_BOSS_19p", "BTA_BOSS_19s", "BTA_BOSS_20p", "BTA_BOSS_20t", "BTA_BOSS_21p", "BTA_BOSS_22s", "BTA_BOSS_22t", "BTA_BOSS_24p", "BTA_BOSS_25s", "CFH_1341", "CFH_1344", "CFH_1347", "CFM_021", "CFM_065", "CFM_094", "CFM_335", "CFM_341", "CFM_603", "CFM_608", "CFM_609", "CFM_621t16", "CFM_621t18", "CFM_621t2", "CFM_621t21", "CFM_621t25", "CFM_621t29", "CFM_621t33", "CFM_621t4", "CFM_621t5", "CFM_623", "CFM_646", "CFM_647", "CFM_657", "CFM_662", "CFM_667", "CFM_690", "CFM_693", "CFM_696", "CFM_707", "CFM_716", "CFM_751", "CFM_855", "CFM_900", "CORE_AT_037", "CORE_AT_064", "CORE_BOT_453", "CORE_BRM_013", "CORE_BT_235", "CORE_BT_355", "CORE_BT_429", "CORE_BT_801", "CORE_CFM_751", "CORE_CS1_112", "CORE_CS1_130", "CORE_CS2_028", "CORE_CS2_029", "CORE_CS2_032", "CORE_CS2_033", "CORE_CS2_042", "CORE_CS2_062", "CORE_CS2_064", "CORE_CS2_072", "CORE_CS2_075", "CORE_CS2_076", "CORE_CS2_093", "CORE_CS2_108", "CORE_CS2_181", "CORE_CS2_189", "CORE_CS2_203", "CORE_DAL_371", "CORE_DS1_185", "CORE_EX1_005", "CORE_EX1_049", "CORE_EX1_066", "CORE_EX1_082", "CORE_EX1_134", "CORE_EX1_144", "CORE_EX1_154", "CORE_EX1_186", "CORE_EX1_197", "CORE_EX1_198", "CORE_EX1_238", "CORE_EX1_246", "CORE_EX1_249", "CORE_EX1_259", "CORE_EX1_275", "CORE_EX1_279", "CORE_EX1_302", "CORE_EX1_304", "CORE_EX1_309", "CORE_EX1_312", "CORE_EX1_319", "CORE_EX1_382", "CORE_EX1_391", "CORE_EX1_400", "CORE_EX1_407", "CORE_EX1_410", "CORE_EX1_603", "CORE_EX1_610", "CORE_EX1_617", "CORE_EX1_619", "CORE_EX1_622", "CORE_EX1_625", "CORE_GIL_124", "CORE_GIL_622", "CORE_GIL_801", "CORE_GVG_008", "CORE_GVG_076", "CORE_ICC_021", "CORE_ICC_041", "CORE_ICC_047", "CORE_ICC_049", "CORE_ICC_051", "CORE_ICC_055", "CORE_ICC_058", "CORE_ICC_064", "CORE_ICC_075", "CORE_ICC_078", "CORE_ICC_085", "CORE_ICC_088", "CORE_ICC_099", "CORE_ICC_214", "CORE_ICC_233", "CORE_ICC_236", "CORE_ICC_238", "CORE_ICC_244", "CORE_ICC_468", "CORE_ICC_469", "CORE_ICC_481", "CORE_ICC_701", "CORE_ICC_802", "CORE_ICC_828", "CORE_ICC_830", "CORE_ICC_836", "CORE_ICC_837", "CORE_ICC_849", "CORE_ICC_910", "CORE_KAR_073", "CORE_LOOT_101", "CORE_NEW1_020", "CORE_TRL_345", "CORE_ULD_271", "CORE_UNG_817", "CORE_UNG_848", "CRED_10", "CRED_118", "CRED_184", "CRED_189", "CRED_202", "CRED_220", "CRED_32", "CRED_44", "CRED_60", "CRED_67", "CRED_83", "CS1_112", "CS1_113", "CS1_129", "CS1_130", "CS1_130_Puzzle", "CS2_008", "CS2_012", "CS2_022", "CS2_024", "CS2_025", "CS2_026", "CS2_028", "CS2_029", "CS2_031", "CS2_032", "CS2_033", "CS2_034_H1", "CS2_034_H1_AT_132", "CS2_034_H2", "CS2_034_H2_AT_132", "CS2_034_H3", "CS2_034_H3_AT_132", "CS2_034_H4", "CS2_037", "CS2_042", "CS2_057", "CS2_061", "CS2_062", "CS2_063", "CS2_064", "CS2_072", "CS2_075", "CS2_076", "CS2_084", "CS2_093", "CS2_094", "CS2_108", "CS2_114", "CS2_141", "CS2_150", "CS2_181", "CS2_189", "CS2_203", "CS2_233", "CS2_234", "CS3_003", "CS3_016", "CS3_027", "CS3_031", "CS3_036", "DAL_009", "DAL_011", "DAL_030", "DAL_039", "DAL_052", "DAL_065", "DAL_071", "DAL_173", "DAL_177", "DAL_177ts", "DAL_182", "DAL_350", "DAL_350a", "DAL_366", "DAL_366t1", "DAL_366t2", "DAL_366t3", "DAL_366t4", "DAL_371", "DAL_373", "DAL_373ts", "DAL_539", "DAL_577", "DAL_577ts", "DAL_605", "DAL_614", "DAL_615", "DAL_716", "DAL_723", "DAL_728", "DAL_769", "DAL_775", "DALA_706", "DALA_712", "DALA_713", "DALA_714", "DALA_714a", "DALA_714b", "DALA_714c", "DALA_720", "DALA_724", "DALA_726", "DALA_740ts4", "DALA_865", "DALA_865e", "DALA_865e2", "DALA_901", "DALA_903", "DALA_914", "DALA_BOSS_01p", "DALA_BOSS_01px", "DALA_BOSS_03t", "DALA_BOSS_03t2", "DALA_BOSS_08p", "DALA_BOSS_08px", "DALA_BOSS_12p", "DALA_BOSS_12px", "DALA_BOSS_13p", "DALA_BOSS_19p", "DALA_BOSS_19px", "DALA_BOSS_22p", "DALA_BOSS_22px", "DALA_BOSS_23p", "DALA_BOSS_23px", "DALA_BOSS_29p", "DALA_BOSS_45p", "DALA_BOSS_45px", "DALA_BOSS_47t", "DALA_BOSS_48t", "DALA_BOSS_50p", "DALA_BOSS_50px", "DALA_BOSS_51t2", "DALA_BOSS_56e", "DALA_BOSS_58p", "DALA_BOSS_59t2", "DALA_BOSS_59t3", "DALA_BOSS_63p", "DALA_BOSS_63px", "DALA_BOSS_64p", "DALA_BOSS_64px", "DALA_BOSS_70p", "DALA_BOSS_70px", "DALA_Mage_HP1", "DALA_Mage_HP2", "DALA_Rogue_HP2", "DALA_Shaman_HP1", "DALA_Warlock_HP1", "DALA_Warrior_HP1", "DE_106", "DE_112", "DE_117", "DE_119", "DED_001", "DED_007", "DED_502", "DED_507", "DED_517", "DED_518", "DED_521", "DED_523", "DH_Prologue_CS2_057", "DH_Prologue_EX1_277", "DMF_004t4", "DMF_004t5", "DMF_054", "DMF_054t", "DMF_057", "DMF_066", "DMF_071", "DMF_101", "DMF_101t", "DMF_103", "DMF_108", "DMF_110", "DMF_115", "DMF_116", "DMF_117", "DMF_117t", "DMF_117t2", "DMF_174", "DMF_174t", "DMF_187", "DMF_191", "DMF_221", "DMF_225", "DMF_227", "DMF_254t3", "DMF_254t4", "DMF_254t7", "DMF_518", "DMF_519", "DMF_522", "DMF_529", "DMF_700", "DMF_701", "DMF_701t", "DMF_702", "DREAM_02", "DREAM_04", "DREAM_05", "DRG_006", "DRG_022", "DRG_023", "DRG_037", "DRG_062", "DRG_067", "DRG_069", "DRG_078", "DRG_081", "DRG_095", "DRG_099t1", "DRG_099t4", "DRG_106", "DRG_201", "DRG_204", "DRG_205", "DRG_206", "DRG_213", "DRG_219", "DRG_223", "DRG_246", "DRG_247", "DRG_248", "DRG_249", "DRG_255t2", "DRG_256", "DRG_257", "DRG_270t11", "DRG_270t4", "DRG_270t5", "DRG_270t6", "DRG_270t7", "DRG_270t8", "DRG_270t9", "DRG_304", "DRG_307", "DRG_321", "DRG_500", "DRG_660", "DRG_660t2", "DRG_660t3", "DRGA_004", "DRGA_011ts4", "DRGA_099t4", "DRGA_BOSS_04p", "DRGA_BOSS_04t", "DRGA_BOSS_05t2", "DRGA_BOSS_05t3", "DRGA_BOSS_05t4", "DRGA_BOSS_05t5", "DRGA_BOSS_06p", "DRGA_BOSS_06p_H", "DRGA_BOSS_09t", "DRGA_BOSS_10p", "DRGA_BOSS_10p_H", "DRGA_BOSS_13t", "DRGA_BOSS_15t2", "DRGA_BOSS_16p", "DRGA_BOSS_16p2", "DRGA_BOSS_20p", "DRGA_BOSS_20p_H", "DRGA_BOSS_20t", "DRGA_BOSS_21t", "DRGA_BOSS_22t2", "DRGA_BOSS_22t3", "DRGA_BOSS_24p", "DRGA_BOSS_24p_H", "DRGA_BOSS_30t", "DRGA_BOSS_30t2t", "DRGA_BOSS_30t3", "DRGA_BOSS_30t5", "DRGA_BOSS_32p", "DRGA_BOSS_32p_H", "DRGA_BOSS_33t", "DS1_183", "DS1_185", "DS1_233", "DS1h_292_H1", "DS1h_292_H1_AT_132", "DS1h_292_H2", "DS1h_292_H3", "DS1h_292_H3_AT_132", "EX1_002", "EX1_005", "EX1_029", "EX1_029_Puzzle", "EX1_048", "EX1_049", "EX1_057", "EX1_066", "EX1_082", "EX1_091", "EX1_102", "EX1_124", "EX1_126", "EX1_129", "EX1_133", "EX1_134", "EX1_137", "EX1_144", "EX1_154", "EX1_154a", "EX1_154b", "EX1_161", "EX1_166", "EX1_166a", "EX1_166b", "EX1_173", "EX1_179", "EX1_186", "EX1_197", "EX1_198", "EX1_238", "EX1_241", "EX1_245", "EX1_246", "EX1_249", "EX1_251", "EX1_259", "EX1_275", "EX1_277", "EX1_278", "EX1_279", "EX1_283", "EX1_298", "EX1_301", "EX1_302", "EX1_304", "EX1_308", "EX1_309", "EX1_312", "EX1_313", "EX1_319", "EX1_320", "EX1_332", "EX1_334", "EX1_360", "EX1_382", "EX1_384", "EX1_391", "EX1_400", "EX1_407", "EX1_408", "EX1_410", "EX1_537", "EX1_539", "EX1_544", "EX1_558", "EX1_578", "EX1_581", "EX1_593", "EX1_594", "EX1_596", "EX1_603", "EX1_607", "EX1_609", "EX1_610", "EX1_617", "EX1_619", "EX1_622", "EX1_624", "EX1_625", "EX1_625t", "EX1_625t2", "EX1_626", "FB_Champs_CS2_084", "FB_Champs_CS2_108", "FB_Champs_CS2_233", "FB_Champs_EX1_005", "FB_Champs_EX1_029", "FB_Champs_EX1_166", "FB_Champs_EX1_246", "FB_Champs_EX1_308", "FB_Champs_EX1_619", "FB_Champs_NEW1_019", "FB_Duelers_Endl", "FB_ELO002a", "FB_ELO002a_ench", "FB_ELO002b", "FB_ELO002b_copy", "FB_ELO002b_ench", "FB_ELO002b_ench_copy", "FB_IKC_SetupYes", "FB_Juggernaut_Bomb_Effect", "FB_Juggernaut_MinionEnchant", "FB_LK_ClearBoard", "FB_LK005", "FB_LK007p", "FB_LK011", "FB_LKDebug001", "FB_LKDebug002", "FB_LKStats001d", "FB_RagRaid_Amulet", "FB_RagRaid_DestroyEverything", "FB_RagRaid_DoubleBlast", "FB_Toki_Boss_Minion1", "FB_Toki_do_auto", "FB_Toki_TimePortalSpell", "FP1_006", "FP1_019", "FP1_021", "FP1_024", "FP1_025", "FP1_026", "GIL_000", "GIL_117", "GIL_124", "GIL_134", "GIL_147", "GIL_504", "GIL_506", "GIL_518", "GIL_543", "GIL_583", "GIL_600", "GIL_614", "GIL_614e2", "GIL_622", "GIL_648", "GIL_654", "GIL_687", "GIL_693", "GIL_694", "GIL_801", "GIL_825", "GILA_500h4", "GILA_500p2t", "GILA_501", "GILA_503", "GILA_508", "GILA_510", "GILA_600h2", "GILA_601", "GILA_803", "GILA_804", "GILA_820", "GILA_821a", "GILA_821b", "GILA_821c", "GILA_900h2", "GILA_904", "GILA_910", "GILA_BOSS_22p", "GILA_BOSS_24t", "GILA_BOSS_26t", "GILA_BOSS_27t", "GILA_BOSS_29p", "GILA_BOSS_29t", "GILA_BOSS_35t", "GILA_BOSS_36p", "GILA_BOSS_41t", "GILA_BOSS_42p", "GILA_BOSS_44p", "GILA_BOSS_49t2", "GILA_BOSS_51p", "GILA_BOSS_54p", "GILA_BOSS_55t2", "GILA_BOSS_56p", "GILA_BOSS_57p", "GILA_BOSS_59p", "GILA_BOSS_61t3", "GILA_BOSS_62p", "GILA_BOSS_66p", "GILA_BOSS_68p", "GILA_BOSS_68t", "GVG_001", "GVG_002", "GVG_004", "GVG_007", "GVG_008", "GVG_009", "GVG_015", "GVG_019", "GVG_020", "GVG_038", "GVG_045", "GVG_047", "GVG_050", "GVG_052", "GVG_072", "GVG_073", "GVG_074", "GVG_075", "GVG_076", "GVG_090", "GVG_099", "GVG_101", "GVG_108", "GVG_110t", "GVG_120", "HERO_05bp", "HERO_05bp2", "HERO_05dbp", "HERO_05dbp2", "HERO_05ybp", "HERO_05ybp2", "HERO_08aabp", "HERO_08aabp2", "HERO_08aebp", "HERO_08aebp2", "HERO_08bp", "HERO_08bp2", "HERO_08dbp", "HERO_08dbp2", "HERO_08ebp", "HERO_08ebp2", "HERO_08fbp", "HERO_08fbp2", "HERO_08fbp3", "HERO_08lbp", "HERO_08lbp2", "HERO_08tbp", "HERO_08tbp2", "HERO_08xbp", "HERO_08xbp2", "ICC_021", "ICC_041", "ICC_047", "ICC_047b", "ICC_047t", "ICC_047t2", "ICC_049", "ICC_051", "ICC_055", "ICC_058", "ICC_064", "ICC_075", "ICC_078", "ICC_085", "ICC_088", "ICC_099", "ICC_214", "ICC_233", "ICC_236", "ICC_238", "ICC_244", "ICC_244e", "ICC_314t3", "ICC_314t5", "ICC_314t6", "ICC_314t8", "ICC_468", "ICC_469", "ICC_481", "ICC_481p", "ICC_701", "ICC_802", "ICC_828", "ICC_830", "ICC_830p", "ICC_831p", "ICC_833h", "ICC_833t", "ICC_834h", "ICC_836", "ICC_837", "ICC_849", "ICC_910", "ICCA01_011", "ICCA04_002", "ICCA04_008p", "ICCA04_011p", "ICCA05_004p", "ICCA05_021", "ICCA06_004", "ICCA06_005", "ICCA07_008", "ICCA08_024", "ICCA08_025", "ICCA08_026", "ICCA08_028", "ICCA08_030p", "KAR_013", "KAR_019", "KAR_041", "KAR_051", "KAR_073", "KAR_076", "KAR_092", "KAR_A10_01", "KAR_A10_02", "KAR_A10_03", "KAR_A10_04", "KAR_A10_09", "KAR_A10_10", "KAR_A10_33", "KARA_04_02hp", "KARA_08_03", "KARA_08_03H", "KARA_08_05", "KARA_08_05H", "KARA_09_06", "KARA_09_06heroic", "KARA_09_07", "KARA_09_07heroic", "KARA_12_03", "KARA_12_03H", "KARA_13_11", "LETL_000_02", "LETL_001P9_01", "LETL_001P9_02", "LETL_001P9_03", "LETL_001P9_04", "LETL_001P9_05", "LETL_003P4_01", "LETL_003P4_02", "LETL_003P4_03", "LETL_003P4_04", "LETL_003P4_05", "LETL_005P3_01", "LETL_005P3_02", "LETL_005P3_03", "LETL_005P3_04", "LETL_005P3_05", "LETL_005P4_01", "LETL_005P4_02", "LETL_005P4_03", "LETL_005P4_04", "LETL_005P4_05", "LETL_005P8_01", "LETL_005P8_02", "LETL_005P8_03", "LETL_005P8_04", "LETL_005P8_05", "LETL_006P8_01", "LETL_006P8_02", "LETL_006P8_03", "LETL_006P8_04", "LETL_006P8_05", "LETL_006P9_01", "LETL_006P9_02", "LETL_006P9_03", "LETL_006P9_04", "LETL_006P9_05", "LETL_007P4_01", "LETL_007P4_02", "LETL_007P4_03", "LETL_007P4_04", "LETL_007P4_05", "LETL_008P11_01", "LETL_008P11_02", "LETL_008P11_03", "LETL_008P9_01", "LETL_008P9_02", "LETL_008P9_03", "LETL_009P6_01", "LETL_009P6_02", "LETL_009P6_03", "LETL_009P6_04", "LETL_009P6_05", "LETL_010P2_01", "LETL_010P2_02", "LETL_010P2_03", "LETL_010P2_04", "LETL_010P2_05", "LETL_010P5_01", "LETL_010P5_02", "LETL_010P5_03", "LETL_010P5_04", "LETL_010P5_05", "LETL_011P2_01", "LETL_011P2_02", "LETL_011P2_03", "LETL_012P6_01", "LETL_012P6_02", "LETL_012P6_03", "LETL_012P6_04", "LETL_012P6_05", "LETL_014P1_01", "LETL_014P1_02", "LETL_014P1_03", "LETL_014P1_04", "LETL_014P1_05", "LETL_014P2_01", "LETL_014P2_02", "LETL_014P2_03", "LETL_014P2_04", "LETL_014P2_05", "LETL_014P3_01", "LETL_014P3_02", "LETL_014P3_03", "LETL_014P3_04", "LETL_014P3_05", "LETL_015P9_01", "LETL_015P9_02", "LETL_015P9_03", "LETL_015P9_04", "LETL_015P9_05", "LETL_017P1_01", "LETL_017P1_02", "LETL_017P1_03", "LETL_017P1_04", "LETL_017P1_05", "LETL_017P2_01", "LETL_017P2_02", "LETL_017P2_03", "LETL_017P2_04", "LETL_017P2_05", "LETL_017P6_01", "LETL_017P6_02", "LETL_017P6_03", "LETL_017P6_04", "LETL_017P6_05", "LETL_017P7_01", "LETL_017P7_02", "LETL_017P7_03", "LETL_017P7_04", "LETL_017P7_05", "LETL_018P10_01", "LETL_018P10_02", "LETL_018P10_03", "LETL_018P7_01", "LETL_018P7_02", "LETL_018P7_03", "LETL_018P7_04", "LETL_018P7_05", "LETL_018P9_01", "LETL_018P9_02", "LETL_018P9_03", "LETL_019P2_01", "LETL_019P2_02", "LETL_019P2_03", "LETL_019P2_04", "LETL_019P2_05", "LETL_019P3_01", "LETL_019P3_02", "LETL_019P3_03", "LETL_019P3_04", "LETL_019P3_05", "LETL_019P6_01", "LETL_019P6_02", "LETL_019P6_03", "LETL_019P6_04", "LETL_019P6_05", "LETL_021P5_01", "LETL_021P5_02", "LETL_021P5_03", "LETL_022P4_01", "LETL_022P4_02", "LETL_022P4_03", "LETL_022P4_04", "LETL_022P4_05", "LETL_027P2_01", "LETL_027P2_02", "LETL_027P2_03", "LETL_027P2_04", "LETL_027P2_05", "LETL_027P6_01", "LETL_027P6_02", "LETL_027P6_03", "LETL_027P6_04", "LETL_027P6_05", "LETL_027P7_01", "LETL_027P7_02", "LETL_027P7_03", "LETL_028P11_01", "LETL_028P11_02", "LETL_028P11_03", "LETL_028P11_04", "LETL_028P11_05", "LETL_028P9_01", "LETL_028P9_02", "LETL_028P9_03", "LETL_028P9_04", "LETL_028P9_05", "LETL_029P10_01", "LETL_029P10_02", "LETL_029P10_03", "LETL_029P10_04", "LETL_029P10_05", "LETL_029P5_01", "LETL_029P5_02", "LETL_029P5_03", "LETL_029P5_04", "LETL_029P5_05", "LETL_029P6_01", "LETL_029P6_02", "LETL_029P6_03", "LETL_029P6_04", "LETL_029P6_05", "LETL_030P3_01", "LETL_030P3_02", "LETL_030P3_03", "LETL_030P3_04", "LETL_030P3_05", "LETL_030P4_01", "LETL_030P4_02", "LETL_030P4_03", "LETL_030P4_04", "LETL_030P4_05", "LETL_030P6_01", "LETL_030P6_02", "LETL_030P6_03", "LETL_030P6_04", "LETL_030P6_05", "LETL_030P6e", "LETL_031P2_01", "LETL_031P2_02", "LETL_031P2_03", "LETL_031P2_04", "LETL_031P2_05", "LETL_031P4_01", "LETL_031P4_02", "LETL_031P4_03", "LETL_031P4_04", "LETL_031P4_05", "LETL_031P7_01", "LETL_031P7_02", "LETL_031P7_03", "LETL_031P7_04", "LETL_031P7_05", "LETL_032P6_01", "LETL_032P6_02", "LETL_032P6_03", "LETL_032P6_04", "LETL_032P6_05", "LETL_033P2_01", "LETL_033P2_02", "LETL_033P2_03", "LETL_033P2_04", "LETL_033P2_05", "LETL_039P8_01", "LETL_039P8_02", "LETL_039P8_03", "LETL_039P8_04", "LETL_039P8_05", "LETL_040P3_01", "LETL_040P3_02", "LETL_040P3_03", "LETL_040P3_04", "LETL_040P3_05", "LETL_040P8_01", "LETL_040P8_02", "LETL_040P8_03", "LETL_1021_01", "LETL_1023_01", "LETL_1024_01", "LETL_1054_01", "LETL_1055_01", "LETL_1060_01", "LETL_1060_02", "LETL_1060_03", "LETL_1060_04", "LETL_1060_05", "LETL_1062_01", "LETL_1063_01", "LETL_1063_02", "LETL_1063_03", "LETL_1063_04", "LETL_1063_05", "LETL_1073_01", "LETL_1073_02", "LETL_1073_03", "LETL_1073_04", "LETL_1073_05", "LETL_1074_01", "LETL_1074_02", "LETL_1074_03", "LETL_1074_04", "LETL_1074_05", "LETL_1075_01", "LETL_1075_02", "LETL_1075_03", "LETL_1075_04", "LETL_1075_05", "LETL_1076_01", "LETL_1076_02", "LETL_1076_03", "LETL_1076_04", "LETL_1076_05", "LETL_1077_01", "LETL_1077_02", "LETL_1077_03", "LETL_1077_04", "LETL_1077_05", "LETL_1078_01", "LETL_1078_02", "LETL_1078_03", "LETL_1078_04", "LETL_1078_05", "LETL_1079_01", "LETL_1079_02", "LETL_1079_03", "LETL_1079_04", "LETL_1079_05", "LETL_1080_01", "LETL_1080_02", "LETL_1080_03", "LETL_1080_04", "LETL_1080_05", "LETL_1102_01", "LETL_1102_02", "LETL_1104_01", "LETL_1106_01", "LETL_1106_02", "LETL_1106_03", "LETL_1106_04", "LETL_1106_05", "LETL_1116_01", "LETL_1116_02", "LETL_1116_03", "LETL_1116_04", "LETL_1116_05", "LETL_1134", "LETL_222_01", "LETL_222_02", "LETL_222_03", "LETL_222_04", "LETL_222_05", "LETL_225_01", "LETL_225_02", "LETL_225_03", "LETL_225_04", "LETL_225_05", "LETL_234_01", "LETL_234_02", "LETL_234_03", "LETL_234_04", "LETL_234_05", "LETL_236_01", "LETL_236_02", "LETL_236_03", "LETL_236_04", "LETL_236_05", "LETL_237_01", "LETL_237_02", "LETL_237_03", "LETL_237_04", "LETL_237_05", "LETL_240_01", "LETL_240_02", "LETL_240_03", "LETL_242_01", "LETL_242_02", "LETL_242_03", "LETL_242_04", "LETL_242_05", "LETL_246_01", "LETL_246_02", "LETL_246_03", "LETL_246_04", "LETL_246_05", "LETL_251_01", "LETL_251_02", "LETL_251_03", "LETL_251_04", "LETL_251_05", "LETL_257_01", "LETL_257_02", "LETL_257_03", "LETL_257_04", "LETL_257_05", "LETL_262_01", "LETL_262_02", "LETL_262_03", "LETL_262_04", "LETL_262_05", "LETL_270_01", "LETL_270_02", "LETL_270_03", "LETL_290_01", "LETL_290_02", "LETL_290_03", "LETL_290_04", "LETL_290_05", "LETL_292_01", "LETL_292_02", "LETL_292_03", "LETL_292_04", "LETL_292_05", "LETL_293_01", "LETL_293_02", "LETL_293_03", "LETL_293_04", "LETL_300_01", "LETL_300_02", "LETL_300_03", "LETL_300_04", "LETL_300_05", "LETL_301_01", "LETL_301_02", "LETL_301_03", "LETL_301_04", "LETL_301_05", "LETL_302_01", "LETL_302_02", "LETL_302_03", "LETL_302_04", "LETL_302_05", "LETL_306_01", "LETL_306_02", "LETL_306_03", "LETL_306_04", "LETL_306_05", "LETL_307_01", "LETL_307_02", "LETL_307_03", "LETL_307_04", "LETL_307_05", "LETL_310_01", "LETL_310_02", "LETL_310_03", "LETL_311_01", "LETL_311_02", "LETL_311_03", "LETL_311e", "LETL_317_01", "LETL_317_02", "LETL_317_03", "LETL_317_04", "LETL_317_05", "LETL_320_01", "LETL_320_02", "LETL_320_03", "LETL_320_04", "LETL_320_05", "LETL_324_01", "LETL_324_02", "LETL_324_03", "LETL_324_04", "LETL_324_05", "LETL_328_01", "LETL_328_02", "LETL_328_03", "LETL_328_04", "LETL_328_05", "LETL_331_01", "LETL_331_02", "LETL_331_03", "LETL_331_04", "LETL_331_05", "LETL_332_01a", "LETL_332_01b", "LETL_332_02a", "LETL_332_02b", "LETL_332_03a", "LETL_332_03b", "LETL_332_04a", "LETL_332_04b", "LETL_332_05a", "LETL_332_05b", "LETL_336_01", "LETL_336_02", "LETL_336_03", "LETL_336_04", "LETL_336_05", "LETL_340_01", "LETL_340_02", "LETL_340_03", "LETL_340_04", "LETL_340_05", "LETL_356_05", "LETL_373_01", "LETL_373_02", "LETL_373_03", "LETL_396_01", "LETL_396_02", "LETL_396_03", "LETL_396_04", "LETL_396_05", "LETL_403_01", "LETL_403_02", "LETL_403_03", "LETL_403_04", "LETL_403_05", "LETL_404_01", "LETL_404_02", "LETL_404_03", "LETL_404_04", "LETL_404_05", "LETL_408_01", "LETL_408_02", "LETL_408_03", "LETL_408_04", "LETL_408_05", "LETL_412_01", "LETL_412_02", "LETL_412_03", "LETL_412_04", "LETL_412_05", "LETL_414_01", "LETL_414_02", "LETL_414_03", "LETL_414_04", "LETL_414_05", "LETL_420_01", "LETL_420_02", "LETL_420_03", "LETL_420_04", "LETL_420_05", "LETL_431_01", "LETL_431_02", "LETL_431_03", "LETL_431_04", "LETL_431_05", "LETL_432_01", "LETL_432_02", "LETL_432_03", "LETL_432_04", "LETL_432_05", "LETL_450_01", "LETL_450_02", "LETL_450_03", "LETL_450_04", "LETL_450_05", "LETL_451_01", "LETL_451_02", "LETL_451_03", "LETL_451_04", "LETL_451_05", "LETL_463_01", "LETL_463_02", "LETL_463_03", "LETL_463_04", "LETL_463_05", "LETL_470_01", "LETL_470_02", "LETL_470_03", "LETL_470_04", "LETL_470_05", "LETL_471_01", "LETL_471_02", "LETL_471_03", "LETL_471_04", "LETL_471_05", "LETL_472_01", "LETL_472_01x", "LETL_472_02", "LETL_472_02x", "LETL_472_03", "LETL_472_03x", "LETL_472_04", "LETL_472_04x", "LETL_472_05", "LETL_472_05x", "LETL_480_01x", "LETL_480_01y", "LETL_480_01z", "LETL_480_02x", "LETL_480_02y", "LETL_480_02z", "LETL_480_03x", "LETL_480_03y", "LETL_480_03z", "LETL_480_04x", "LETL_480_04y", "LETL_480_04z", "LETL_480_05x", "LETL_480_05y", "LETL_480_05z", "LETL_507_01", "LETL_507_02", "LETL_507_03", "LETL_507_04", "LETL_507_05", "LETL_507e", "LETL_516_01", "LETL_516_02", "LETL_516_03", "LETL_516_04", "LETL_516e", "LETL_527_01", "LETL_527_02", "LETL_527_03", "LETL_527_04", "LETL_527_05", "LETL_532_01", "LETL_535_05", "LETL_546_01", "LETL_546_02", "LETL_547_01", "LETL_547_02", "LETL_550_01", "LETL_550_02", "LETL_550_03", "LETL_550_04", "LETL_550_05", "LETL_552_01", "LETL_552_02", "LETL_552_03", "LETL_552_04", "LETL_552_05", "LETL_553_01", "LETL_553_02", "LETL_553_03", "LETL_553_04", "LETL_553_05", "LETL_555_01", "LETL_555_02", "LETL_555_03", "LETL_555_04", "LETL_555_05", "LETL_556_01", "LETL_556_02", "LETL_556_03", "LETL_556_04", "LETL_556_05", "LETL_634_01", "LETL_634_02", "LETL_634_03", "LETL_634_04", "LETL_670_02", "LETL_670_03", "LETL_670_04", "LETL_670e", "LETL_759_01", "LETL_759_02", "LETL_759_03", "LETL_759_04", "LETL_759_05", "LETL_760_01", "LETL_760_02", "LETL_760_03", "LETL_760_04", "LETL_760_05", "LETL_761_01", "LETL_761_02", "LETL_761_03", "LETL_761_04", "LETL_761_05", "LETL_762_01", "LETL_762_02", "LETL_762_03", "LETL_762_04", "LETL_762_05", "LETL_763_01", "LETL_763_02", "LETL_763_03", "LETL_763_04", "LETL_763_05", "LETL_764_01", "LETL_764_02", "LETL_764_03", "LETL_764_04", "LETL_764_05", "LETL_765_01", "LETL_765_02", "LETL_765_03", "LETL_765_04", "LETL_765_05", "LETL_766_01", "LETL_766_02", "LETL_766_03", "LETL_766_04", "LETL_766_05", "LETL_768_01", "LETL_768_02", "LETL_768_03", "LETL_768_04", "LETL_768_05", "LETL_770_01", "LETL_770_02", "LETL_770_03", "LETL_770_04", "LETL_770_05", "LETL_771_01", "LETL_771_02", "LETL_771_03", "LETL_771_04", "LETL_771_5", "LETL_772_01", "LETL_772_02", "LETL_772_03", "LETL_772_04", "LETL_772_05", "LETL_774_01", "LETL_774_02", "LETL_774_03", "LETL_774_04", "LETL_774_05", "LETL_774e", "LETL_812P4_01", "LETL_813_01", "LETL_815P1_01", "LETL_815P1_02", "LETL_815P2_01", "LETL_815P2_02", "LETL_816P1_01", "LETL_816P1_03", "LETL_818P1_01", "LETL_820P1_01", "LETL_820P1_02", "LETL_820P2_01", "LETL_820P2_02", "LETL_820P4_01", "LETL_820P4_01m", "LETL_821H3", "LETL_821P1_01", "LETL_821P1_02", "LETL_821P1_04", "LETL_821P2_01", "LETL_822P1_01", "LETL_822P1_03", "LETL_823P1_01", "LETL_823P1_03", "LETL_823P2_01", "LETL_823P4_01", "LETL_823P4_02", "LETL_823P4_03", "LETL_823P4_04", "LETL_823P4_05", "LETL_824P3_02", "LETL_824P3_02_4", "LETL_828P2_01", "LETL_828P2_03", "LETL_828P3_01", "LETL_829P1_02", "LETL_829P1_05", "LETL_830P1_01", "LETL_830P1_03", "LETL_830P2_01", "LETL_830P2_03", "LETL_831H2", "LETL_832H", "LETL_832P3_03", "LETL_832P3_04", "LETL_835P1_01", "LETL_835P1_02", "LETL_835P2_01", "LETL_835P2_03", "LETL_837H", "LETL_838P1_03", "LETL_838P1_04", "LETL_839P1_01t", "LETL_839P1_03t", "LETL_840He", "LETL_842P1_01", "LETL_842P1_02", "LETL_843P3_02", "LETL_844P1_01", "LETL_844P2_01", "LETL_845P1_01", "LETL_845P3_04", "LETL_845P3_05", "LETL_845P4_04", "LETL_845P4_05", "LETL_846H", "LETL_846P3_01", "LETL_847P2_01", "LETL_847P2_02", "LETL_847P3_01", "LETL_847P3_02", "LETL_847P4_01", "LETL_847P4_02", "LETL_848P1_01", "LETL_849P2_04", "LETL_849P2_05", "LETL_849P4_04", "LETL_849P4_05", "LETL_852P2", "LETL_852P3", "LETL_855P1_04", "LETL_855P1_05", "LETL_858P1_01", "LETL_859P1", "LETL_859P3", "LETL_861H", "LETL_861P2e2", "LETL_862H3", "LETL_862P1e", "LETL_862P1e2", "LETL_862P1e6", "LETL_862P1e7", "LETL_863P1", "LETL_863P2", "LETL_863P3", "LETL_864H", "LETL_864P1", "LETL_864P2", "LETL_865H", "LETL_865P1", "LETL_903P2_01", "LETL_903P2_02", "LETL_930_01", "LETL_930_02", "LETL_930_03", "LETL_930_04", "LETL_930_05", "LETL_931_01", "LETL_932_01", "LETL_933_01", "LETL_933_02", "LETL_933_03", "LETL_933_04", "LETL_933_05", "LETL_933e", "LETL_934_01", "LETL_936_01", "LETL_936_02", "LETL_936_03", "LETL_936_04", "LETL_936_05", "LETL_936e", "LETL_949_01", "LETL_950_01", "LETL_950_02", "LETL_950_03", "LETL_950_04", "LETL_950_05", "LETL_951_01", "LETL_951_02", "LETL_951_03", "LETL_951_04", "LETL_951_05", "LETL_956_01", "LETL_956_02", "LETL_956_03", "LETL_956_04", "LETL_956_05", "LETL_960_01", "LETL_960_02", "LETL_960_03", "LETL_960_04", "LETL_960_05", "LETL_965_01", "LETL_965_02", "LETL_965_03", "LETL_965_04", "LETL_965_05", "LETL_973_01", "LETL_975_01", "LETL_979_01", "LETL_NPC_Attack_Fireball", "LETL_test_Silence", "LETLT_006_01", "LETLT_007_01", "LETLT_008_01", "LETLT_021_01", "LETLT_031_02", "LETLT_037_04", "LETLT_038_02", "LETLT_041_02", "LETLT_048_02e", "LETLT_050_03", "LETLT_055_02", "LETLT_056_02", "LETLT_059_02", "LETLT_060_01", "LETLT_060_03", "LETLT_060_03e", "LETLT_074p1_01", "LETLT_076p1_01", "LETLT_081_02", "LETLT_083_02", "LETLT_083_03", "LETLT_084_02", "LETLT_091_01", "LETLT_091_02", "LETLT_100_03", "LETLT_101_03", "LETLT_103_02", "LETLT_103_03", "LETLT_106_03", "LETLT_111_02", "LETLT_126_02", "LETLT_129_02", "LETLT_130_03", "LETLT_131_02", "LETLT_133_02", "LETLT_137_02", "LETLT_138_02", "LOE_002", "LOE_002t", "LOE_016", "LOE_021", "LOE_027", "LOE_046", "LOE_058t3", "LOE_104", "LOE_111", "LOEA01_12", "LOEA01_12h", "LOEA04_25", "LOEA04_25h", "LOEA06_04", "LOEA06_04h", "LOEA07_18", "LOEA07_20", "LOEA07_29", "LOEA09_6", "LOEA09_6H", "LOEA09_9", "LOEA09_9H", "LOEA15_3", "LOEA15_3H", "LOEA16_10", "LOEA16_11", "LOEA16_4", "LOEA16_6", "LOEA16_8", "LOEA16_9", "LOOT_013", "LOOT_014", "LOOT_037", "LOOT_043", "LOOT_043t2", "LOOT_043t3", "LOOT_051", "LOOT_051t1", "LOOT_051t2", "LOOT_060", "LOOT_077", "LOOT_101", "LOOT_111", "LOOT_118", "LOOT_122", "LOOT_132", "LOOT_150", "LOOT_172", "LOOT_278t4e", "LOOT_285t2", "LOOT_347", "LOOT_358", "LOOT_364", "LOOT_389", "LOOT_410", "LOOT_415t6", "LOOT_417", "LOOT_503", "LOOT_503t", "LOOT_503t2", "LOOT_504", "LOOT_504t", "LOOT_522", "LOOT_998l", "LOOTA_102", "LOOTA_805", "LOOTA_806", "LOOTA_811", "LOOTA_826", "LOOTA_827", "LOOTA_842", "LOOTA_843", "LOOTA_BOSS_05p", "LOOTA_BOSS_06p", "LOOTA_BOSS_09p", "LOOTA_BOSS_11p", "LOOTA_BOSS_13p", "LOOTA_BOSS_20p", "LOOTA_BOSS_21p", "LOOTA_BOSS_23p", "LOOTA_BOSS_25p", "LOOTA_BOSS_26p2", "LOOTA_BOSS_26p3", "LOOTA_BOSS_26p4", "LOOTA_BOSS_26p6", "LOOTA_BOSS_26p7", "LOOTA_BOSS_28p", "LOOTA_BOSS_29p", "LOOTA_BOSS_30p", "LOOTA_BOSS_39p", "LOOTA_BOSS_44p", "LOOTA_BOSS_47p", "LOOTA_BOSS_49t2", "LOOTA_BOSS_51p", "LOOTA_BOSS_53p", "LOOTA_BOSS_99t", "LT21_002_01", "LT21_002_02", "LT21_002_03", "LT21_002_04", "LT21_002_05", "LT21_015_001", "LT21_015_002", "LT21_015_003", "LT21_015_004", "LT21_015_005", "LT21_02P2_01", "LT21_02P2_02", "LT21_02P2_03", "LT21_02P2_04", "LT21_02P2_05", "LT21_02P3_01", "LT21_02P3_02", "LT21_02P3_03", "LT21_02P3_04", "LT21_02P3_05", "LT21_05P2_01mA", "LT21_05P2_02mA", "LT21_05P2_03mA", "LT21_05P2_04mA", "LT21_05P2_05mA", "LT21_05P3_01", "LT21_05P3_02", "LT21_05P3_03", "LT21_05P3_04", "LT21_05P3_05", "LT21_07P2_01", "LT21_07P2_02", "LT21_07P2_03", "LT21_07P2_04", "LT21_07P2_05", "LT21_07P3_01", "LT21_07P3_02", "LT21_07P3_03", "LT21_07P3_04", "LT21_07P3_05", "LT22_002E3mP", "LT22_002P1_01", "LT22_002P1_02", "LT22_002P1_03", "LT22_002P1_04", "LT22_002P1_05", "LT22_002P2_01", "LT22_002P2_02", "LT22_002P2_03", "LT22_002P2_04", "LT22_002P2_05", "LT22_002P3_01", "LT22_002P3_02", "LT22_002P3_03", "LT22_002P3_04", "LT22_002P3_05", "LT22_002P3a_01", "LT22_002P3a_02", "LT22_002P3a_03", "LT22_002P3a_04", "LT22_002P3a_05", "LT22_002P3b_01", "LT22_002P3b_02", "LT22_002P3b_03", "LT22_002P3b_04", "LT22_002P3b_05", "LT22_003P3a_01", "LT22_003P3a_02", "LT22_003P3a_03", "LT22_003P3a_04", "LT22_003P3a_05", "LT22_003P3b_01", "LT22_003P3b_02", "LT22_003P3b_03", "LT22_003P3b_04", "LT22_003P3b_05", "LT22_004P2_01", "LT22_004P2_02", "LT22_004P2_03", "LT22_004P2_04", "LT22_004P2_05", "LT22_004P3_01", "LT22_004P3_02", "LT22_004P3_03", "LT22_004P3_04", "LT22_004P3_05", "LT22_005P1_01", "LT22_005P1_02", "LT22_005P1_03", "LT22_005P1_04", "LT22_005P1_05", "LT22_005P2_01", "LT22_005P2_02", "LT22_005P2_03", "LT22_005P2_04", "LT22_005P2_05", "LT22_005P3_01", "LT22_005P3_02", "LT22_005P3_03", "LT22_005P3_04", "LT22_005P3_05", "LT22_007P1_01", "LT22_007P1_02", "LT22_007P1_03", "LT22_007P1_04", "LT22_007P1_05", "LT22_008E2e", "LT22_009P1_01", "LT22_009P1_02", "LT22_009P1_03", "LT22_009P1_04", "LT22_009P1_05", "LT22_010P1_01", "LT22_010P1_02", "LT22_010P1_03", "LT22_010P1_04", "LT22_010P1_05", "LT22_010P3_01", "LT22_010P3_02", "LT22_010P3_03", "LT22_010P3_04", "LT22_010P3_05", "LT22_012P3e", "LT22_013E3_01", "LT22_013E3_02", "LT22_013E3_03", "LT22_013E3_04", "LT22_013E3e", "LT22_013P1_01", "LT22_013P1_02", "LT22_013P1_03", "LT22_013P1_04", "LT22_013P1_05", "LT22_013P3_01", "LT22_013P3_02", "LT22_013P3_03", "LT22_013P3_04", "LT22_013P3_05", "LT22_014P2_01", "LT22_014P2_02", "LT22_014P2_03", "LT22_014P2_04", "LT22_014P2_05", "LT22_014P3b_01", "LT22_014P3b_02", "LT22_014P3b_03", "LT22_014P3b_04", "LT22_014P3b_05", "LT22_016P1_01", "LT22_016P1_02", "LT22_016P1_03", "LT22_016P1_04", "LT22_016P1_05", "LT22_016P3a_01", "LT22_016P3a_02", "LT22_016P3a_03", "LT22_016P3a_04", "LT22_016P3a_05", "LT22_023H_01", "LT22_023H_02", "LT22_023H_03", "LT22_024P3_01", "LT22_024P3_02", "LT22_024P3_03", "LT22_024P3_04", "LT22_024P3_05", "LT23_011P2a_01", "LT23_011P2a_02", "LT23_011P2a_03", "LT23_011P2a_04", "LT23_011P2a_05", "LT23_011P2b_01", "LT23_011P2b_02", "LT23_011P2b_03", "LT23_011P2b_04", "LT23_011P2b_05", "LT23_011P2c_01", "LT23_011P2c_02", "LT23_011P2c_03", "LT23_011P2c_04", "LT23_011P2c_05", "LT23_011P3a_01", "LT23_011P3a_02", "LT23_011P3a_03", "LT23_011P3a_04", "LT23_011P3a_05", "LT23_011P3b_01", "LT23_011P3b_02", "LT23_011P3b_03", "LT23_011P3b_04", "LT23_011P3b_05", "LT23_011P3c_01", "LT23_011P3c_02", "LT23_011P3c_03", "LT23_011P3c_04", "LT23_011P3c_05", "LT23_016P1_01", "LT23_016P1_02", "LT23_016P1_03", "LT23_016P1_04", "LT23_016P1_05", "LT23_016P3_01", "LT23_016P3_02", "LT23_016P3_03", "LT23_016P3_04", "LT23_016P3_05", "LT23_017E3_01", "LT23_017E3_02", "LT23_017E3_03", "LT23_017E3_04", "LT23_017E3e", "LT23_017P1_01", "LT23_017P1_02", "LT23_017P1_03", "LT23_017P1_04", "LT23_017P1_05", "LT23_017P2_01", "LT23_017P2_02", "LT23_017P2_03", "LT23_017P2_04", "LT23_017P2_05", "LT23_017P2a_01", "LT23_017P2a_02", "LT23_017P2a_03", "LT23_017P2a_04", "LT23_017P2a_05", "LT23_017P2b_01", "LT23_017P2b_02", "LT23_017P2b_03", "LT23_017P2b_04", "LT23_017P2b_05", "LT23_017P2ea", "LT23_017P2eb", "LT23_018P1_01", "LT23_018P1_02", "LT23_018P1_03", "LT23_018P1_04", "LT23_018P1_05", "LT23_018P2_01", "LT23_018P2_02", "LT23_018P2_03", "LT23_018P2_04", "LT23_018P2_05", "LT23_018P3_01", "LT23_018P3_02", "LT23_018P3_03", "LT23_018P3_04", "LT23_018P3_05", "LT23_019P3_01", "LT23_019P3_02", "LT23_019P3_03", "LT23_019P3_04", "LT23_019P3_05", "LT23_020P2_01", "LT23_020P2_02", "LT23_020P2_03", "LT23_020P2_04", "LT23_020P2_05", "LT23_021P1_01", "LT23_021P1_02", "LT23_021P1_03", "LT23_021P1_04", "LT23_021P1_05", "LT23_021P2_01", "LT23_021P2_02", "LT23_021P2_03", "LT23_021P2_04", "LT23_021P2_05", "LT23_021P3_01", "LT23_021P3_02", "LT23_021P3_03", "LT23_021P3_04", "LT23_021P3_05", "LT23_022P3b_01", "LT23_022P3b_02", "LT23_022P3b_03", "LT23_022P3b_04", "LT23_022P3b_05", "LT23_024P1_01", "LT23_024P1_02", "LT23_024P1_03", "LT23_024P1_04", "LT23_024P1_05", "LT23_024P3_01", "LT23_024P3_02", "LT23_024P3_03", "LT23_024P3_04", "LT23_024P3_05", "LT23_024P3m_01", "LT23_024P3m_02", "LT23_024P3m_03", "LT23_024P3m_04", "LT23_024P3m_05", "LT23_025P2_01", "LT23_025P2_02", "LT23_025P2_03", "LT23_025P2_04", "LT23_025P2_05", "LT23_025P3_01", "LT23_025P3_02", "LT23_025P3_03", "LT23_025P3_04", "LT23_025P3_05", "LT23_026P1_01", "LT23_026P1_02", "LT23_026P1_03", "LT23_026P1_04", "LT23_026P1_05", "LT23_029P1_01", "LT23_029P1_02", "LT23_029P1_03", "LT23_029P1_04", "LT23_029P1_05", "LT23_029P2_01", "LT23_029P2_02", "LT23_029P2_03", "LT23_029P2_04", "LT23_029P2_05", "LT23_030P1_01", "LT23_030P1_02", "LT23_030P1_03", "LT23_030P1_04", "LT23_030P1_05", "LT23_030P2_01", "LT23_030P2_02", "LT23_030P2_03", "LT23_030P2_04", "LT23_030P2_05", "LT23_030P3_01", "LT23_030P3_02", "LT23_030P3_03", "LT23_030P3_04", "LT23_030P3_05", "LT23_031P1_01", "LT23_031P1_02", "LT23_031P1_03", "LT23_031P1_04", "LT23_031P1_05", "LT23_032P3d1", "LT23_032P3d2", "LT23_032P3d3", "LT23_032P3d4", "LT23_032P3d5", "LT23_033P1_01", "LT23_033P1_02", "LT23_033P1_03", "LT23_033P1_04", "LT23_033P1_05", "LT23_033P3_01", "LT23_033P3_02", "LT23_033P3_03", "LT23_033P3_04", "LT23_033P3_05", "LT23_034P3_01", "LT23_034P3_02", "LT23_034P3_03", "LT23_034P3_04", "LT23_034P3_05", "LT23_035P3_01", "LT23_035P3_02", "LT23_035P3_03", "LT23_035P3_04", "LT23_035P3_05", "LT23_036E3_01", "LT23_036E3_02", "LT23_036E3_03", "LT23_036E3_04", "LT23_037P1_01", "LT23_037P1_02", "LT23_037P1_03", "LT23_037P1_04", "LT23_037P1_05", "LT23_037P3_01", "LT23_037P3_02", "LT23_037P3_03", "LT23_037P3_04", "LT23_037P3_05", "LT23_800P2", "LT23_803P1", "LT23_803P2", "LT23_804P1", "LT23_804P2", "LT23_805P1", "LT23_807P1", "LT23_809H2", "LT23_811H2", "LT23_811P1", "LT23_812H3", "LT23_816P2", "LT23_818P2", "LT23_819P1", "LT23_819P2", "LT23_822P1b", "LT23_826H3", "LT23_826P4_1", "LT23_826P4_2", "LT23T_100_02", "LT23T_101_03", "LT23T_103_02", "LT23T_111_02", "LT23T_115_03", "LT23T_116_02", "LT23T_117_03", "LT23T_126_01", "LT24_001E2_01", "LT24_001E2_02", "LT24_001E2_03", "LT24_001E2_04", "LT24_002P1_01", "LT24_002P1_02", "LT24_002P1_03", "LT24_002P1_04", "LT24_002P1_05", "LT24_002P2y_01", "LT24_002P2y_02", "LT24_002P2y_03", "LT24_002P2y_04", "LT24_002P2y_05", "LT24_006T1_01", "LT24_006T1_02", "LT24_006T1_03", "LT24_006T1_04", "LT24_006T1_05", "LT24_007P1_01", "LT24_007P1_02", "LT24_007P1_03", "LT24_007P1_04", "LT24_007P1_05", "LT24_007P2c", "LT24_007P2c2", "LT24_007P2ca", "LT24_007P2ce", "LT24_007P3_01", "LT24_007P3_02", "LT24_007P3_03", "LT24_007P3_04", "LT24_007P3_05", "LT24_008E1_01", "LT24_008E1_02", "LT24_008E1_03", "LT24_008E1_04", "LT24_008E2_01", "LT24_008E2_02", "LT24_008E2_03", "LT24_008E2_04", "LT24_008P1a_01", "LT24_008P1a_02", "LT24_008P1a_03", "LT24_008P1a_04", "LT24_008P1a_05", "LT24_008P1b_01", "LT24_008P1b_02", "LT24_008P1b_03", "LT24_008P1b_04", "LT24_008P1b_05", "LT24_008P2a_01", "LT24_008P2a_02", "LT24_008P2a_03", "LT24_008P2a_04", "LT24_008P2a_05", "LT24_008T1_01", "LT24_008T1_02", "LT24_008T1_03", "LT24_008T1_04", "LT24_008T1_05", "LT24_010P1_01", "LT24_010P1_02", "LT24_010P1_03", "LT24_010P1_04", "LT24_010P1_05", "LT24_011E3_01", "LT24_011E3_02", "LT24_011E3_03", "LT24_011E3_04", "LT24_011P1_01", "LT24_011P1_02", "LT24_011P1_03", "LT24_011P1_04", "LT24_011P1_05", "LT24_011P1e", "LT24_011P2_01", "LT24_011P2_02", "LT24_011P2_03", "LT24_011P2_04", "LT24_011P2_05", "LT24_011P2e", "LT24_011T2_01", "LT24_011T2_02", "LT24_011T2_03", "LT24_011T2_04", "LT24_011T2_05", "LT24_011T2e", "LT24_013P2_01", "LT24_013P2_02", "LT24_013P2_03", "LT24_013P2_04", "LT24_013P2_05", "LT24_016P1_01", "LT24_016P1_02", "LT24_016P1_03", "LT24_016P1_04", "LT24_016P1_05", "LT24_016P3_01", "LT24_016P3_02", "LT24_016P3_03", "LT24_016P3_04", "LT24_016P3_05", "LT24_017P1_01", "LT24_017P1_02", "LT24_017P1_03", "LT24_017P1_04", "LT24_017P1_05", "LT24_017P3_01p", "LT24_017P3_02p", "LT24_017P3_03p", "LT24_017P3_04p", "LT24_017P3_05p", "LT24_019P1_01", "LT24_019P1_02", "LT24_019P1_03", "LT24_019P1_04", "LT24_019P1_05", "LT24_019P2_01", "LT24_019P2_02", "LT24_019P2_03", "LT24_019P2_04", "LT24_019P2_05", "LT24_019P3_01", "LT24_019P3_02", "LT24_019P3_03", "LT24_019P3_04", "LT24_019P3_05", "LT24_019T1_01", "LT24_019T1_02", "LT24_019T1_03", "LT24_019T1_04", "LT24_019T1_05", "LT24_020P4_01a", "LT24_020P4_01b", "LT24_020P4_02a", "LT24_020P4_02b", "LT24_020P4_03a", "LT24_020P4_03b", "LT24_020P4_04a", "LT24_020P4_04b", "LT24_020P4_05a", "LT24_020P4_05b", "LT24_020P5_01a", "LT24_020P5_01b", "LT24_020P5_02a", "LT24_020P5_02b", "LT24_020P5_03a", "LT24_020P5_03b", "LT24_020P5_04a", "LT24_020P5_04b", "LT24_020P5_05a", "LT24_020P5_05b", "LT24_020T2_01", "LT24_020T2_02", "LT24_020T2_03", "LT24_021E1_01", "LT24_021E1_02", "LT24_021E1_03", "LT24_021E1_04", "LT24_021P2_01", "LT24_021P2_02", "LT24_021P2_03", "LT24_021P2_04", "LT24_021P2_05", "LT24_021P3_01", "LT24_021P3_02", "LT24_021P3_03", "LT24_021P3_04", "LT24_021P3_05", "LT24_021T1_01", "LT24_024P2_01", "LT24_024P2_02", "LT24_024P2_03", "LT24_024P2_04", "LT24_024P2_05", "LT24_024P3_01", "LT24_024P3_02", "LT24_024P3_03", "LT24_024P3_04", "LT24_024P3_05", "LT24_027E3_01", "LT24_027E3_02", "LT24_027E3_03", "LT24_027E3_04", "LT24_027P2_01", "LT24_027P2_02", "LT24_027P2_03", "LT24_027P2_04", "LT24_027P2_05", "LT24_027P2a_01", "LT24_027P2a_02", "LT24_027P2a_03", "LT24_027P2a_04", "LT24_027P2a_05", "LT24_027P2b_01", "LT24_027P2b_02", "LT24_027P2b_03", "LT24_027P2b_04", "LT24_027P2b_05", "LT24_027P2c_01", "LT24_027P2c_02", "LT24_027P2c_03", "LT24_027P2c_04", "LT24_027P2c_05", "LT24_810H", "LT24_810P2", "LT24_813P1", "LT24_814H", "LT24_814P2", "LT24_814P6", "LT24_815H4", "LT24_816P1", "LT24_817H2", "LT24_817P2", "LT24_818P1", "LT24_819P3", "LT24_820H", "LT24_820H2", "LT24_820H5", "LT24_822P2", "MAW_000", "MAW_001", "MAW_010", "MAW_010t", "MAW_013", "MAW_019", "MAW_023", "MAW_025a", "MAW_026", "MAW_033t", "MAW_034", "Mission_ForceDrawInOrder", "NAX1_05", "NAX10_03", "NAX10_03H", "NAX11_02", "NAX11_02H", "NAX11_02H_2_TB", "NAX12_02", "NAX12_02H", "NAX12_02H_2_TB", "NAX12_02H_2c_TB", "NAX14_02", "NAX14_04", "NAX15_02", "NAX15_02H", "NAX15_04", "NAX15_04H", "NAX3_02", "NAX3_02_TB", "NAX3_02H", "NAX3_03", "NAX4_05", "NAX5_02", "NAX5_02H", "NAX6_02", "NAX6_02H", "NAX6_03", "NAX6_04", "NAX7_03", "NAX7_03H", "NAX8_03t", "NAX8_04t", "NAX8_05t", "NAXM_001", "NAXM_002", "NEW1_003", "NEW1_004", "NEW1_005", "NEW1_007", "NEW1_007a", "NEW1_007b", "NEW1_017", "NEW1_019", "NEW1_020", "NEW1_030", "NEW1_041", "OG_027", "OG_033", "OG_061", "OG_080c", "OG_080f", "OG_081", "OG_083", "OG_085", "OG_086", "OG_100", "OG_116", "OG_117", "OG_120", "OG_149", "OG_151", "OG_161", "OG_162", "OG_169", "OG_175", "OG_176", "OG_179", "OG_203", "OG_206", "OG_212", "OG_215", "OG_219", "OG_227", "OG_239", "OG_244", "OG_245", "OG_254", "OG_258", "OG_265", "OG_268", "OG_274", "OG_279", "OG_280", "OG_282", "OG_314", "OG_328", "OG_329", "OG_333", "ONY_005ta1", "ONY_005ta13", "ONY_005ta3", "ONY_005ta4", "ONY_005ta6", "ONY_005ta7", "ONY_005tb14", "ONY_005tb4", "ONY_005tc1", "ONY_005tc2", "ONY_005tc7", "ONY_006", "ONY_007", "ONY_010", "ONY_011", "ONY_013", "ONY_014", "ONY_018", "ONY_018t2", "ONY_026", "ONY_032", "ONY_035", "PART_002", "PART_005", "PRO_001b", "Prologue_Captain", "Prologue_ChaosNova", "Prologue_Jarod", "Prologue_MannorothHP", "Prologue_UnstableEnergy3", "Prologue_XaviusHP", "PVPDR_035", "PVPDR_042", "PVPDR_125", "PVPDR_AV_Neutralp3", "PVPDR_AV_Neutralp3p3", "PVPDR_AV_Neutralp4", "PVPDR_AV_Neutralp5", "PVPDR_AV_Neutralt8t3", "PVPDR_AV_Neutralt8t4", "PVPDR_AV_Passive36m1", "PVPDR_BAR_Passive10", "PVPDR_BAR_Passive10e1", "PVPDR_BAR_Passive19", "PVPDR_BAR_Passive19e1", "PVPDR_BAR_Passive21", "PVPDR_BAR_Passive21e1", "PVPDR_BAR_Passive23", "PVPDR_BAR_Passive23e1", "PVPDR_BAR_Passive26", "PVPDR_BAR_Passive26e1", "PVPDR_BAR_Passive27", "PVPDR_BAR_Passive27e1", "PVPDR_Brann_HP1", "PVPDR_Brann_T1", "PVPDR_Brann_T3", "PVPDR_Darius_PCannon", "PVPDR_DMF_Druidp1", "PVPDR_DMF_Roguet2", "PVPDR_Finley_T6", "PVPDR_GUEST_Diablop2", "PVPDR_GUEST_Diablot2", "PVPDR_GUEST_Diablot3", "PVPDR_GUEST_Diablot4", "PVPDR_GUEST_Diablot4m1", "PVPDR_GUEST_Diablot6h1", "PVPDR_GUEST_Diablot6s2", "PVPDR_GUEST_Diablot6s3", "PVPDR_GUEST_Diablot6s3e", "PVPDR_Reno_HP1", "PVPDR_Reno_T3", "PVPDR_Reno_T6", "PVPDR_SCH_Active02", "PVPDR_SCH_Active07", "PVPDR_SCH_Active17", "PVPDR_SCH_Active25", "PVPDR_SCH_Active39", "PVPDR_SCH_Active39s1", "PVPDR_SCH_Active39s2", "PVPDR_SCH_Active42", "PVPDR_SCH_Active43", "PVPDR_SCH_Active44", "PVPDR_SCH_Active52", "PVPDR_SCH_Active54", "PVPDR_SCH_Active55", "PVPDR_SCH_Active57", "PVPDR_SCH_Active61", "PVPDR_SCH_Hunterp1", "PVPDR_SCH_Magep3", "PVPDR_SCH_Maget1", "PVPDR_SCH_Maget5", "PVPDR_SCH_Passive15a1", "PVPDR_SCH_Passive23", "PVPDR_SCH_Passive23e", "PVPDR_SCH_Passive39", "PVPDR_SCH_Passive39e", "PVPDR_SCH_Priestt1", "PVPDR_SCH_Warlockt1", "PVPDR_SCH_Warlockt4", "PVPDR_SCH_Warriorp1", "PVPDR_SCH_Warriort2", "PVPDR_Tess_T1", "PVPDR_Tess_T2", "PVPDR_Tess_T4", "PVPDR_Toki_T3", "PVPDR_Toki_T6", "PVPDR_YOP_DruidP1", "PVPDR_YOP_DruidT1", "PVPDR_YOP_MageP1", "PVPDR_YOP_MageP1m1", "PVPDR_YOP_MageT1t", "PVPDR_YOP_PaladinT3", "PVPDR_YOP_PriestT1", "PVPDR_YOP_PriestT1e1", "PVPDR_YOP_RogueT1", "RAWR_004", "REV_013t", "REV_023", "REV_246", "REV_249", "REV_251", "REV_252", "REV_252t", "REV_307", "REV_319", "REV_364", "REV_369", "REV_374", "REV_506", "REV_506e", "REV_601", "REV_601t", "REV_602", "REV_828t", "REV_834", "REV_840", "REV_845", "REV_906", "REV_920", "REV_920t", "REV_923", "REV_924", "REV_939", "REV_946", "REV_950", "REV_980", "REV_990", "SCH_199t2", "SCH_199t29", "SCH_235", "SCH_236", "SCH_239", "SCH_241", "SCH_248", "SCH_253", "SCH_271", "SCH_276", "SCH_307", "SCH_313", "SCH_348", "SCH_355", "SCH_509", "SCH_512", "SCH_514", "SCH_517", "SCH_521", "SCH_526", "SCH_535", "SCH_604", "SCH_607", "SCH_607a", "SCH_701", "SCH_704", "SLUSH_163", "SLUSH_BAD_2", "SLUSH_BAD_3", "SLUSH_BAD_5", "Story_01_AethasHP", "Story_01_ArthasHP", "Story_01_GarroshHP", "Story_01_Iceball", "Story_01_JainaHP", "Story_01_JainaHP2", "Story_01_JainaYoungHP", "Story_01_JainaYoungHP2", "Story_01_JainaYoungHP3", "Story_01_LordaeronAttendant", "Story_01_Shandris", "Story_01_TheramoreGates", "Story_01_TheramoreGuard", "Story_01_WaterElemental", "Story_01_WaterElemental2", "Story_02_BlackhandHP", "Story_02_DarkscaleHP", "Story_02_GronnTrap", "Story_02_Haratha", "Story_02_KulTiranGuard", "Story_02_LeoroxxHP", "Story_02_MishaHP", "Story_02_Monsoon", "Story_02_RexxarHP", "Story_02_RexxarMidHP4", "Story_02_Spirit", "Story_02_StuffedSack", "Story_02_WoundedFootman", "Story_03_AnduinHP", "Story_03_CairneHP", "Story_03_CorruptGarrosh", "Story_03_ElementalRift", "Story_03_EvenTotem", "Story_03_FireElementalHP", "Story_03_FreshPerspective", "Story_03_GarroshArmadaHP", "Story_03_OddTotem", "Story_03_Saurfang", "Story_03_ZarzhetHP", "Story_04_BlademasterHP", "Story_04_FightTrainer", "Story_04_GuldanReinforcements", "Story_04_IcebladeWeapon", "Story_04_LibramofJustice", "Story_04_RadiantLightspawn", "Story_04_UtherHP3", "Story_04_UtherHP4", "Story_04_WallsLordaeron", "Story_04_YoungUtherHP", "Story_05_Alleria", "Story_05_AncientBrewmaster", "Story_05_AnduinHP", "Story_05_AnduinHP2", "Story_05_ForbiddenWords", "Story_05_JadeWarlord", "Story_05_JainaHP", "Story_05_JainaMinion", "Story_05_MarkedShot", "Story_05_MonkeyKingHP", "Story_05_UntamedAmbertail", "Story_05_VarianHP", "Story_05_VelenHP", "Story_05_WarMachine", "Story_05_YouthfulBrewmaster", "Story_06_AssassinsTraining", "Story_06_Broll", "Story_06_ChoGall_07p", "Story_06_GaronaShadow", "Story_06_Lilian", "Story_06_SanguineStrike", "Story_06_SilentShadow", "Story_06_SilentShadow2", "Story_06_SilentShadow3", "Story_06_SilentShadow4", "Story_06_Stasia_05p", "Story_06_Taoshi", "Story_06_TessGreymane", "Story_06_Tethys", "Story_06_Upheaval", "Story_06_Valeera_07p", "Story_06_Valeera_08p", "Story_06_Vendellin_04p", "Story_07_Deathwing_006p", "Story_07_Deathwing_006p2", "Story_07_Deathwing_006p3", "Story_07_Devastate", "Story_07_FeverPitch", "Story_07_HideousAmalgamation", "Story_07_Jaina_007p2", "Story_07_Mannoroth_004p", "Story_07_RouseRabble", "Story_07_SpiritofFire", "Story_07_SpiritofFiret", "Story_08_ArchdruidsRage", "Story_08_CorruptingRage", "Story_08_Hopelessness", "Story_08_Illidan_005p", "Story_08_Keeper", "Story_08_KeeperCorrupt", "Story_08_Mannoroth_002p", "Story_08_NightmareDemon", "Story_08_Nordrassil", "Story_08_Ragnaros_007p", "Story_08_Saurfang", "Story_08_Tyrande", "Story_08_WayofArchdruid", "Story_08_Weeding", "Story_09_AbyssalEnforcer", "Story_09_BlastcrystalPotion", "Story_09_BloodclawDragon", "Story_09_CouncilNecrolyte", "Story_09_DarkestHour", "Story_09_DemonfirePuzzle", "Story_09_DrainSoul", "Story_09_DreadInfernal", "Story_09_Duskbreaker", "Story_09_EnsnareSoul", "Story_09_FelfirePotion", "Story_09_Felrattler", "Story_09_FlameImp", "Story_09_ForgottenShaman", "Story_09_ForgottenShaman2", "Story_09_ForgottenWarrior", "Story_09_Guldan_005p", "Story_09_Guldan_006p", "Story_09_Guldan_007p", "Story_09_Guldan_008p", "Story_09_HarvestSoul", "Story_09_HellfirePuzzle", "Story_09_Hysteria", "Story_09_KilroggMinion", "Story_09_Lethal", "Story_09_MortalCoilPuzzle", "Story_09_Nerzhul_003p", "Story_09_PowerofGuldan", "Story_09_RainofFire", "Story_09_RaiseDead", "Story_09_Riftcleaver", "Story_09_SchoolSpirits", "Story_09_SerpentshrinePortal", "Story_09_Shadowbolt", "Story_09_SoulRend", "Story_09_SoulShear", "Story_09_SuspiciousElemental", "Story_09_Terongor", "Story_09_TombGuardian_008p", "Story_09_TormentSoul", "Story_09_VulgarHomunculus", "Story_09_WeakenedElemental", "Story_10_Akama", "Story_10_Akama_008p", "Story_10_Anubarak_006p", "Story_10_FesteringGhoul", "Story_10_FlameCrash", "Story_10_IcecrownObelisk", "Story_10_LadyVashj", "Story_10_Magtheridon_005p", "Story_10_PoisonTreant", "Story_10_SkullofGuldan", "Story_10_StolenVengeance", "Story_10_SulkingImp", "Story_10_Tichondrius_002p", "Story_11_AbyssalWarden", "Story_11_AbyssalWarden2", "Story_11_Activate", "Story_11_Azshara_016p", "Story_11_BackupPlane", "Story_11_Captain_006p", "Story_11_CharmOffensive", "Story_11_Clapbacke", "Story_11_Compass_009p", "Story_11_CrystalPowerPuzzle", "Story_11_Dathril_012p", "Story_11_ExcavationPuzzle", "Story_11_Faelin_016p2", "Story_11_FinleysCompasse", "Story_11_FireballPuzzle", "Story_11_FireElemental", "Story_11_FlamecannonPuzzle", "Story_11_FlamestrikePuzzle", "Story_11_FreezingPotion", "Story_11_Frostbolt", "Story_11_Gaia", "Story_11_Grace_005p", "Story_11_GracefulBlade", "Story_11_Handmaiden_005p", "Story_11_Hurricane_005p", "Story_11_IciclePuzzle", "Story_11_LightningStormPuzzle", "Story_11_MortalCoil", "Story_11_MurlocMenace", "Story_11_Orgozoa", "Story_11_Ozumat_007p", "Story_11_Patrol_001p", "Story_11_PyroblastPuzzle", "Story_11_QueensVengeance", "Story_11_RunedOrb", "Story_11_ScaldingPuzzle", "Story_11_SeafloorGatewayPuzzle", "Story_11_SeaReaver", "Story_11_Sivara", "Story_11_SpammyArcanistPuzzle", "Story_11_SpreadingMadness", "Story_11_StormTyrant2", "Story_11_Sundering_011p", "Story_11_SuperiorEfficiencye", "Story_11_Swash", "Story_11_Swash2", "Story_11_Swash2e", "Story_11_Swashe", "Story_11_UnstableShadowBlast", "Story_11_VespersCannonMinion", "Story_11_Vortex", "Story_11_WaterElemental", "Story11_DrawInOrder", "SW_012", "SW_027", "SW_028t", "SW_032", "SW_039", "SW_039t", "SW_040", "SW_043", "SW_046", "SW_052t4", "SW_072", "SW_078", "SW_079e6", "SW_079t3", "SW_079t3e", "SW_084", "SW_088", "SW_089", "SW_090", "SW_107", "SW_108", "SW_108t", "SW_110", "SW_311", "SW_311t", "SW_321", "SW_322", "SW_412", "SW_417", "SW_433t3a", "SW_441", "SW_442", "SW_445", "SW_452", "SW_460", "TB_008", "TB_01_BOM_Mercs_Dawngrasp_001p", "TB_01_BOM_Mercs_Guff_001p", "TB_abBS", "TB_abFarm", "TB_abLM", "TB_abMine", "TB_abStables", "TB_AVH_001", "TB_AVH_HP001", "TB_AVH_HP002", "TB_AVH_HP003", "TB_AVH_HP004", "TB_AVH_HP005", "TB_AVH_HP006", "TB_Bacon_Secrets_03", "TB_Bacon_Secrets_06", "TB_BaconShop_HERO_17_Buddy", "TB_BaconShop_HERO_17_Buddy_G", "TB_BaconShop_HERO_55_Buddy", "TB_BaconShop_HP_009", "TB_BaconShop_HP_014", "TB_BaconShop_HP_016", "TB_BaconShop_HP_019", "TB_BaconShop_HP_027", "TB_BaconShop_HP_043", "TB_BaconShopBuy", "TB_BaconShopHPWar1", "TB_BaconUps_054", "TB_BaconUps_075", "TB_BaconUps_079", "TB_BaconUps_103", "TB_BaconUps_118", "TB_BaconUps_126", "TB_BaconUps_128", "TB_BaconUps_148", "TB_Baconups_205", "TB_BBR3_BOSS_01p", "TB_BBR3_BOSS_03p1", "TB_BoomBotFestival_001e", "TB_BuildaBoss_404p", "TB_Burgle_Peddler3", "TB_CardTutorial_01", "TB_CoOpBossSpell_6", "TB_CoopHero_001", "TB_CoOpv3_002", "TB_CoOpv3_004", "TB_CoOpv3_005", "TB_CoOpv3_006", "TB_CoOpv3_007", "TB_CoOpv3_008", "TB_CoOpv3_012", "TB_CoOpv3_013", "TB_CoOpv3_200", "TB_CoOpv3_201", "TB_DK_Anduin", "TB_DK_Rexxar", "TB_DK_Thrall", "TB_EVILBRM_LOOTA_805", "TB_FactionWar_Boss_Rag", "TB_FactionWar_Boss_Rag_0", "TB_FactionWar_Herald", "TB_FactionWar_Rag1", "tb_Fairytalecard_02", "TB_FGHighStriker", "TB_Firefest2_001", "TB_Firefest2_002", "TB_Firefest2_005", "TB_Firefest2_Ahune_HP", "TB_FW_HeroPower_Boom", "TB_FW_HeroPower_Boom_Update", "TB_GiftExchange_Snowball", "TB_HeadlessHorseman_001", "TB_HeadlessHorseman_002", "TB_HeadlessHorseman_HP1", "TB_HeadlessHorseman_s004", "TB_HeadlessHorseman_s005", "TB_HeadlessRedux_HP1", "TB_Henchmania_BoomEnchantBan", "TB_Henchmania_DiscoverB", "TB_HunterPrince_02", "TB_HunterPrince_03", "TB_HunterPrince_03a", "TB_HunterPrince_03b", "TB_Ignoblegarden3", "TB_John_001p3", "TB_John_001p4", "TB_John_001p6", "TB_John_26p2", "TB_KTRAF_11", "TB_KTRAF_12", "TB_KTRAF_4m", "TB_KTRAF_7", "TB_LEAGUE_REVIVAL_FinleySandHP", "TB_LevelUp_002", "TB_LL_ArugalForever", "TB_LL_BarakForever", "TB_LL_BlackthornForever", "TB_LL_EliseForever", "TB_LL_FireheartForever", "TB_LL_LeadesrForevere1", "TB_LL_NozdormuForever", "TB_LL_SonyaForever", "TB_LL_WhatleyForever", "TB_LL_WillowForever", "TB_LL_XyrellaForever", "TB_Lunar_Rooster", "TB_Lunar_RoosterE", "TB_MagicalGuardians_Fireblast", "TB_MagicalGuardians_Fireblast2", "TB_MammothParty_301", "TB_MammothParty_hp002", "TB_MammothParty_s004", "TB_MammothParty_s101", "TB_MammothParty_s101b", "TB_MechWar_Boss2_HeroPower", "TB_OG_027", "TB_Prototype_HP1", "TB_Rage_001", "TB_Rage_002", "TB_RoadToNR_DinoHP", "TB_RoadToNR_MurgathaHP", "TB_ShipBattle_03", "TB_ShipBattle_04", "TB_SPT_DPromoMinion2", "TB_SPT_DPromoSecret7", "TB_SPT_DPromoSpell1", "TB_TagTeam_ClearBoard", "TB_TempleOutrun_HHHead", "TB_TempleOutrun_Toggwaggle_HP", "TB_ThunderdomeWeaponA", "TB_ThunderdomeWeaponE", "TB_Zombeast_H", "TBST_002", "TID_001", "TID_074", "TID_075", "TID_708", "TID_709t", "TID_709t2", "TID_716", "TOT_009", "TOT_011", "TOT_021", "TOT_023", "TOT_027", "TOT_030t4", "TOT_033", "TOT_036", "TOT_042", "TOT_044", "TOT_047", "TOT_051", "TOT_052", "TOT_059", "TOT_064", "TOT_100e", "TOT_103e", "TOT_116", "TOT_118", "TOT_207", "TOT_209", "TOT_340", "TP_Bling_HP2", "TRL_012", "TRL_059", "TRL_065h", "TRL_127", "TRL_157", "TRL_240", "TRL_245", "TRL_246", "TRL_257", "TRL_258", "TRL_313", "TRL_316t", "TRL_317", "TRL_321", "TRL_341", "TRL_343", "TRL_345", "TRL_347", "TRL_360", "TRL_500", "TRL_505", "TRL_512", "TRL_524", "TRL_526", "TRL_543", "TRL_546", "TRL_555", "TRL_569", "TRLA_065p", "TRLA_129", "TRLA_129s", "TRLA_132", "TRLA_137", "TRLA_157", "TRLA_162e", "TRLA_167", "TRLA_177", "TRLA_182", "TRLA_806e2", "TRLA_808e2", "TSC_001", "TSC_002", "TSC_017", "TSC_023", "TSC_029", "TSC_055", "TSC_056", "TSC_056e", "TSC_057t", "TSC_058", "TSC_064", "TSC_209", "TSC_211", "TSC_217", "TSC_219t", "TSC_219t2", "TSC_219t3", "TSC_219t4", "TSC_637", "TSC_641tc", "TSC_651", "TSC_775", "TSC_775t", "TSC_911", "TSC_913t", "TSC_924", "TSC_926", "TSC_932", "TSC_934t3", "TSC_939", "TSC_940", "TSC_956", "TSC_963", "TU4a_004", "TU4c_002", "TU4c_004", "TU4d_003", "TU4e_005", "TU5_CS2_022", "TU5_CS2_025", "TU5_CS2_029", "TU5_DS1_185", "TU5_EX1_593", "ULD_158", "ULD_161", "ULD_162", "ULD_165", "ULD_172", "ULD_181", "ULD_184", "ULD_190", "ULD_238", "ULD_239", "ULD_240", "ULD_269", "ULD_271", "ULD_272", "ULD_280", "ULD_288", "ULD_293", "ULD_324", "ULD_410", "ULD_435", "ULD_705t", "ULD_707", "ULD_714", "ULD_717", "ULD_718", "ULD_728", "ULDA_006", "ULDA_010", "ULDA_019", "ULDA_024", "ULDA_032", "ULDA_034", "ULDA_044", "ULDA_113", "ULDA_115", "ULDA_204", "ULDA_207", "ULDA_401", "ULDA_404", "ULDA_703e2", "ULDA_713", "ULDA_912", "ULDA_BOSS_05p", "ULDA_BOSS_18e", "ULDA_BOSS_18p", "ULDA_BOSS_18px", "ULDA_BOSS_22p", "ULDA_BOSS_22px", "ULDA_BOSS_23p", "ULDA_BOSS_26p", "ULDA_BOSS_33p", "ULDA_BOSS_34p", "ULDA_BOSS_37p3", "ULDA_BOSS_37px3", "ULDA_BOSS_37t", "ULDA_BOSS_38p1", "ULDA_BOSS_38px1", "ULDA_BOSS_39p2", "ULDA_BOSS_39px2", "ULDA_BOSS_40p2", "ULDA_BOSS_40px2", "ULDA_BOSS_46p", "ULDA_BOSS_52p1", "ULDA_BOSS_54p", "ULDA_BOSS_59p", "ULDA_BOSS_59px", "ULDA_BOSS_60p", "ULDA_BOSS_60px", "ULDA_BOSS_61p", "ULDA_BOSS_61px", "ULDA_BOSS_67p2", "ULDA_BOSS_67p2e", "ULDA_BOSS_68p", "ULDA_BOSS_72e", "ULDA_BOSS_72ex", "ULDA_BOSS_74p", "ULDA_BOSS_74px", "ULDA_BOSS_75p", "ULDA_BOSS_75px", "ULDA_BOSS_76p", "ULDA_BOSS_76px", "ULDA_Brann_HP1", "ULDA_Reno_HP1", "ULDSLUSH_123", "UNG_004", "UNG_018", "UNG_025", "UNG_027", "UNG_027t2", "UNG_057t1", "UNG_064", "UNG_084", "UNG_087", "UNG_094t4", "UNG_094t6", "UNG_111", "UNG_113", "UNG_114", "UNG_116t", "UNG_202", "UNG_205", "UNG_211c", "UNG_211d", "UNG_803", "UNG_807", "UNG_817", "UNG_818", "UNG_831", "UNG_834", "UNG_835", "UNG_840", "UNG_847", "UNG_848", "UNG_904", "UNG_910", "UNG_932", "UNG_933", "UNG_934t2", "UNG_941", "UNG_946", "UNG_953", "UNG_955", "UNG_956", "UNG_956e", "VAN_CS1_112", "VAN_CS1_113", "VAN_CS1_129", "VAN_CS1_130", "VAN_CS2_008", "VAN_CS2_012", "VAN_CS2_022", "VAN_CS2_024", "VAN_CS2_025", "VAN_CS2_026", "VAN_CS2_028", "VAN_CS2_029", "VAN_CS2_031", "VAN_CS2_032", "VAN_CS2_033", "VAN_CS2_037", "VAN_CS2_042", "VAN_CS2_057", "VAN_CS2_061", "VAN_CS2_062", "VAN_CS2_063", "VAN_CS2_064", "VAN_CS2_072", "VAN_CS2_075", "VAN_CS2_076", "VAN_CS2_084", "VAN_CS2_093", "VAN_CS2_094", "VAN_CS2_108", "VAN_CS2_114", "VAN_CS2_141", "VAN_CS2_150", "VAN_CS2_181", "VAN_CS2_189", "VAN_CS2_203", "VAN_CS2_233", "VAN_CS2_234", "VAN_DREAM_02", "VAN_DREAM_04", "VAN_DREAM_05", "VAN_DS1_183", "VAN_DS1_185", "VAN_DS1_233", "VAN_EX1_002", "VAN_EX1_005", "VAN_EX1_029", "VAN_EX1_048", "VAN_EX1_049", "VAN_EX1_057", "VAN_EX1_066", "VAN_EX1_082", "VAN_EX1_091", "VAN_EX1_102", "VAN_EX1_124", "VAN_EX1_126", "VAN_EX1_129", "VAN_EX1_133", "VAN_EX1_134", "VAN_EX1_137", "VAN_EX1_144", "VAN_EX1_154", "VAN_EX1_154a", "VAN_EX1_154b", "VAN_EX1_161", "VAN_EX1_166", "VAN_EX1_166a", "VAN_EX1_166b", "VAN_EX1_170", "VAN_EX1_173", "VAN_EX1_238", "VAN_EX1_241", "VAN_EX1_245", "VAN_EX1_246", "VAN_EX1_249", "VAN_EX1_251", "VAN_EX1_259", "VAN_EX1_275", "VAN_EX1_277", "VAN_EX1_278", "VAN_EX1_279", "VAN_EX1_283", "VAN_EX1_298", "VAN_EX1_301", "VAN_EX1_302", "VAN_EX1_304", "VAN_EX1_308", "VAN_EX1_309", "VAN_EX1_312", "VAN_EX1_313", "VAN_EX1_319", "VAN_EX1_320", "VAN_EX1_323", "VAN_EX1_332", "VAN_EX1_334", "VAN_EX1_360", "VAN_EX1_382", "VAN_EX1_384", "VAN_EX1_391", "VAN_EX1_400", "VAN_EX1_407", "VAN_EX1_408", "VAN_EX1_410", "VAN_EX1_522", "VAN_EX1_537", "VAN_EX1_539", "VAN_EX1_544", "VAN_EX1_558", "VAN_EX1_578", "VAN_EX1_581", "VAN_EX1_593", "VAN_EX1_594", "VAN_EX1_596", "VAN_EX1_603", "VAN_EX1_607", "VAN_EX1_609", "VAN_EX1_610", "VAN_EX1_617", "VAN_EX1_619", "VAN_EX1_622", "VAN_EX1_624", "VAN_EX1_625", "VAN_EX1_626", "VAN_HERO_05bp", "VAN_HERO_05bp2", "VAN_HERO_08bp", "VAN_HERO_08bp2", "VAN_NEW1_003", "VAN_NEW1_004", "VAN_NEW1_005", "VAN_NEW1_007", "VAN_NEW1_007a", "VAN_NEW1_007b", "VAN_NEW1_017", "VAN_NEW1_019", "VAN_NEW1_020", "VAN_NEW1_030", "VAN_NEW1_041", "WC_004", "WC_014", "WC_017", "WC_020", "WC_021", "WC_022", "WC_041", "WC_701", "XXX_001", "XXX_002", "XXX_005", "XXX_006", "XXX_008", "XXX_012", "XXX_018", "XXX_023", "XXX_024", "XXX_029", "XXX_030", "XXX_032", "XXX_041", "XXX_046", "XXX_049", "XXX_056", "XXX_057", "XXX_059", "XXX_063", "XXX_109", "XXX_115", "XXX_115e", "XXX_129", "XXX_64956", "XXX_95142", "YOD_014", "YOD_018", "YOD_020", "YOD_022", "YOD_029t", "YOP_006", "YOP_007", "YOP_020", "YOP_023", "YOP_027", "YOP_033" };
+
+        public enum CardEffect { UNKNOWN, FRIENDLY, UNFRIENDLY };
+
+        public static CardEffect ExtractEffect(string cardText)
+        {
+            try
+            {
+                return GetSpellEffect(cardText);
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        public static CardEffect GetEffect(string cardId)
+        {
+            if (friendlyCards.Contains(cardId))
+            {
+                return CardEffect.FRIENDLY;
+            }
+            else if (unfriendlyCards.Contains(cardId))
+            {
+                return CardEffect.UNFRIENDLY;
+            }
+            else
+            {
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        private static CardEffect GetSpellEffect(string cardText)
+        {
+            var isFriendly = false;
+            var isUnfriendly = false;
+
+            // Shortcut friendlies (e.g. destroy a friendly must be a friendly even though it reads "destroy" whereas any other would likely target both and thus become unfriendly)
+            if (IsDestroyAFriendlyMinion(cardText))
+			{
+                return CardEffect.FRIENDLY;
+			}
+
+            if (IsSecret(cardText) ||
+                IsChooseAFriendlyMinion(cardText) ||
+                IsDiscover(cardText) ||
+                IsChooseN(cardText) ||
+                IsGiveSomething(cardText) ||
+                IsGainSomething(cardText) ||
+                IsDrawSomething(cardText) ||
+                IsRestoreSomething(cardText) ||
+                IsDoubleSomething(cardText) ||
+                IsPutACopyOf(cardText) ||
+                IsQuest(cardText) ||
+                IsWheneverItAttacks(cardText) ||
+                IsShuffle(cardText) ||
+                IsTrigger(cardText) ||
+                IsReveal(cardText) ||
+                IsSwap(cardText) ||
+                IsAddToHand(cardText) ||
+                IsReplaceYour(cardText) ||
+                IsAdapt(cardText) ||
+                IsResurrect(cardText) ||
+                IsSetGoodStats(cardText) ||
+                IsReturn(cardText) ||
+                IsRecruit(cardText) ||
+                IsSummon(cardText) ||
+                IsCostsLess(cardText) ||
+                IsWildcard(cardText)
+                )
+            {
+                isFriendly = true;
+            }
+
+            if (IsDealNDamage(cardText) ||
+                IsDestroySomething(cardText) ||
+                IsFreezeSomething(cardText) ||
+                IsTakeControl(cardText) ||
+                IsGainControl(cardText) ||
+                IsTransformSomething(cardText) ||
+                IsChangeSomething(cardText) ||
+                IsReturnSomething(cardText) ||
+                IsSilenceSomething(cardText) ||
+                IsShoot(cardText) ||
+                IsDealDamage(cardText) ||
+                IsThrowWeaponAt(cardText) ||
+                IsReduce(cardText) ||
+                IsChooseAnEnemyMinion(cardText) ||
+                IsSetBadStats(cardText) ||
+                IsForceMinion(cardText) ||
+                IsStealStats(cardText) ||
+                IsChooseMinionToGoDormant(cardText) ||
+                IsRemoveMinionFromGame(cardText)
+                )
+            {
+                isUnfriendly = true;
+            }
+
+            if (isFriendly && isUnfriendly)
+            {
+                // Most cards that are both friendly and unfriendly are something like deal X damage to someone and gain Y health so we want to target unfriendly characters first
+                return CardEffect.UNFRIENDLY;
+            }
+            else if (isFriendly)
+            {
+                return CardEffect.FRIENDLY;
+            }
+            else if (isUnfriendly)
+            {
+                return CardEffect.UNFRIENDLY;
+            }
+            else
+            {
+                return CardEffect.UNKNOWN;
+            }
+        }
+
+        private static Regex s_costsLessRegex = new Regex(@" costs \(\d\) less.");
+        private static bool IsCostsLess(string cardText)
+        {
+            return s_costsLessRegex.Match(cardText).Success;
+        }
+
+        private static bool IsDestroyAFriendlyMinion(string cardText)
+        {
+            return cardText.Contains("Destroy a friendly minion");
+        }
+
+        private static bool IsChooseAnEnemyMinion(string cardText)
+        {
+            return cardText.Contains("Choose an enemy minion");
+        }
+
+        private static bool IsReduce(string cardText)
+        {
+            return cardText.Contains("Reduce ");
+        }
+
+        private static bool IsThrowWeaponAt(string cardText)
+        {
+            return cardText.Contains("Throw your weapon ");
+        }
+
+        private static bool IsRecruit(string cardText)
+        {
+            return cardText.Contains("<b>Recruit</b>");
+        }
+
+        private static bool IsReturn(string cardText)
+        {
+            return cardText.Contains(" return it ");
+        }
+
+        private static Regex s_setAtkHealthRegex = new Regex(@"Set a minion's Attack and Health to (\d).");
+        private static bool IsSetBadStats(string cardText)
+        {
+            var match = s_setAtkHealthRegex.Match(cardText);
+
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            var val = int.Parse(match.Groups[1].Value);
+
+            return val < 3;
+        }
+
+        private static bool IsSetGoodStats(string cardText)
+        {
+            var match = s_setAtkHealthRegex.Match(cardText);
+
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            var val = int.Parse(match.Groups[1].Value);
+
+            return val >= 3;
+        }
+
+        private static bool IsResurrect(string cardText)
+        {
+            return cardText.Contains("Resurrect ");
+        }
+
+        private static bool IsAdapt(string cardText)
+        {
+            return cardText.Contains("<b>Adapt</b>");
+        }
+
+        private static bool IsReplaceYour(string cardText)
+        {
+            return cardText.Contains("Replace your ");
+        }
+
+        private static Regex s_addToHandRegex = new Regex(@"Add .* to your hand.*");
+        private static Regex s_addToHandLCRegex = new Regex(@" add .* to your hand.*");
+        private static Regex s_addToHandBrokenRegex = new Regex(@"Add .* to_your hand.*");
+        private static Regex s_addToHandBroken2Regex = new Regex(@"Add .* to your_hand.*");
+        private static bool IsAddToHand(string cardText)
+        {
+            return s_addToHandRegex.Match(cardText).Success ||
+                s_addToHandLCRegex.Match(cardText).Success ||
+                s_addToHandBrokenRegex.Match(cardText).Success ||
+                s_addToHandBroken2Regex.Match(cardText).Success;
+        }
+
+        private static bool IsSwap(string cardText)
+        {
+            return cardText.Contains("Swap ");
+        }
+
+        private static bool IsReveal(string cardText)
+        {
+            return cardText.Contains("Reveal ");
+        }
+
+        private static bool IsTrigger(string cardText)
+        {
+            return cardText.Contains("Trigger ");
+        }
+
+        private static bool IsShuffle(string cardText)
+        {
+            return cardText.Contains("Shuffle ");
+        }
+
+        private static bool IsDealDamage(string cardText)
+        {
+            return cardText.Contains("Deal damage ") || cardText.Contains("Deal that much damage");
+        }
+
+        private static bool IsWheneverItAttacks(string cardText)
+        {
+            return cardText.Contains("Whenever it attacks");
+        }
+
+        private static bool IsShoot(string cardText)
+        {
+            return cardText.Contains("Shoot ");
+        }
+
+        private static bool IsQuest(string cardText)
+        {
+            return cardText.Contains("<b>Quest:</b>") || cardText.Contains("<b>Sidequest:</b>") || cardText.Contains("<b>Questline:</b>");
+        }
+
+        private static bool IsPutACopyOf(string cardText)
+        {
+            return cardText.Contains("Put a copy of");
+        }
+
+        private static bool IsDoubleSomething(string cardText)
+        {
+            return cardText.Contains("Double ");
+        }
+
+        private static bool IsSilenceSomething(string cardText)
+        {
+            return cardText.Contains("<b>Silence</b> ");
+        }
+
+        private static bool IsRestoreSomething(string cardText)
+        {
+            return cardText.Contains("Restore ");
+        }
+
+        private static bool IsReturnSomething(string cardText)
+        {
+            return cardText.Contains("Return ");
+        }
+
+        private static bool IsChangeSomething(string cardText)
+        {
+            return cardText.Contains("Change ");
+        }
+
+        private static bool IsTransformSomething(string cardText)
+        {
+            return cardText.Contains("Transform ");
+        }
+
+        private static bool IsDrawSomething(string cardText)
+        {
+            return cardText.Contains("Draw ");
+        }
+
+        private static bool IsGainSomething(string cardText)
+        {
+            return cardText.Contains("Gain ");
+        }
+
+        private static bool IsForceMinion(string cardText)
+        {
+            return cardText.Contains("Force ");
+        }
+
+        private static bool IsStealStats(string cardText)
+        {
+            return cardText.Contains("It steals "); // e.g. Shadow Word: Devour
+        }
+
+        private static bool IsChooseMinionToGoDormant(string cardText)
+        {
+            return cardText.Contains("Choose a minion") && cardText.Contains("It goes <b>Dormant</b>"); // e.g. Incarceration
+        }
+
+        private static bool IsRemoveMinionFromGame(string cardText)
+        {
+            return cardText.Contains("Remove a minion\nfrom the game"); // e.g. Life Sentence
+        }
+
+        private static bool IsGainControl(string cardText)
+        {
+            return cardText.Contains("Gain control ") || cardText.Contains("gain control");
+        }
+
+        private static bool IsFreezeSomething(string cardText)
+        {
+            return cardText.Contains("<b>Freeze</b> a");
+        }
+
+        private static bool IsSummon(string cardText)
+        {
+            return cardText.Contains("Summon ") || cardText.Contains(" summon ");
+        }
+
+        private static bool IsDestroySomething(string cardText)
+        {
+            return cardText.Contains("Destroy ") || cardText.Contains(" destroy it");
+        }
+
+        private static bool IsGiveSomething(string cardText)
+        {
+            return cardText.Contains("Give ") || cardText.Contains(" give it") || cardText.Contains("G[x]ive ");
+        }
+
+        private static Regex s_dealNDamageRegex = new Regex(@".*Deal \*?\d+\*? damage.*");
+        private static Regex s_dealXYDamageRegex = new Regex(@".*Deal \*?\d+\*?-\*?\d\*? damage.*");
+        private static Regex s_dealNDamageBrokenRegex = new Regex(@".*Deal_\*?\d+\*? damage.*");
+        private static Regex s_dealNDamageBroken2Regex = new Regex(@".*Deal_\*?\d+\*?_damage.*");
+        private static Regex s_dealNDamageMidStringRegex = new Regex(@".*, deal \*?\d+\*? damage.*"); // See Scalerider
+        private static bool IsDealNDamage(string cardText)
+        {
+            return s_dealNDamageRegex.Match(cardText).Success ||
+                s_dealXYDamageRegex.Match(cardText).Success ||
+                s_dealNDamageBrokenRegex.Match(cardText).Success ||
+                s_dealNDamageBroken2Regex.Match(cardText).Success ||
+                s_dealNDamageMidStringRegex.Match(cardText).Success;
+        }
+
+        private static bool IsTakeControl(string cardText)
+        {
+            return cardText.Contains("Take control ");
+        }
+
+        private static bool IsChooseN(string cardText)
+        {
+            return cardText.Contains("<b>Choose One ") || cardText.Contains("<b>Choose Twice");
+        }
+
+        private static bool IsDiscover(string cardText)
+        {
+            return cardText.Contains("<b>Discover</b>");
+        }
+
+        private static bool IsSecret(string cardText)
+        {
+            return cardText.Contains("<b>Secret:</b>");
+        }
+
+        private static bool IsChooseAFriendlyMinion(string cardText)
+        {
+            return cardText.Contains("Choose a friendly minion");
+        }
+
+        private static HashSet<string> s_wildcards = new HashSet<string>()
+        {
+            "The next spell you cast this turn costs (2) less.",
+"Put a random minion from each player's hand into the battlefield.",
+"When you play or discard this, deal 4 damage to a random enemy.",
+"This turn, your healing effects deal damage instead.",
+"Add two Razorpetals to_your hand that deal_1 damage.",
+"Each time you play a Beast this turn, add_a_random Beast to_your hand.",
+"The next spell you cast this turn costs Health instead of Mana.",
+"Copy the lowest Cost minion in your hand.",
+"Each turn this is in your hand, transform it into a random Mage spell.",
+"Enemy spells cost (5) more next turn.",
+"Each player gains 2_Mana Crystals.",
+"Add 2 random <b>Deathrattle</b> cards to_your hand.",
+"Each player draws 2_cards.",
+"Whenever a minion dies this turn, gain 1 Mana Crystal this turn only.",
+"Your hero is <b>Immune</b> until your next turn.",
+"The next Elemental you_play this turn costs (2) less.",
+"Choose a minion. Add_a copy of it to your hand.",
+"Each player transforms a random minion in their hand into a Demon.",
+"Add a random card from another class to_your hand.",
+"Copy all Beasts in your_hand.",
+"Add a random Hunter Beast, <b>Secret</b>, and weapon to your_hand.",
+"Your hero can't take damage this turn.",
+"Your opponent has 2 fewer Mana Crystals next turn.",
+"Set the Attack of all enemy minions to 1 until your next turn.",
+"Your next spell this turn casts twice.",
+"Set each player to 0 Mana Crystals. Set the Cost of cards in all hands and decks to (1).",
+"Cast 10 random spells <i>(targets chosen randomly).</i>",
+"Replay 5 cards from other classes you've played this game.",
+"[x]Your <b>Deathrattles</b>\ntrigger twice.\nLasts 3 turns.",
+"[x]Your minions have\n+1 Attack.\nLasts 3 turns.",
+"[x]Cast 20 Mana worth of\nMage spells at enemies.",
+"Your minions cost (2) less this turn <i>(but not less than 1)</i>.",
+"[x]Your Hero Power\ndeals 1 more damage\nthis game.",
+"Fill your board with 2/1 Whelps with <b>Rush</b>.",
+"The next spell you cast this turn casts twice.",
+"Your spells this turn are <b>Poisonous</b>.",
+"Light every card in the opponent's hand on fire. In 3 turns, any still\nin hand are destroyed!",
+"Put an enemy minion on the bottom of your deck.",
+"Add two random\nspells from other classes\nthat cost (5) or more\nto your hand.",
+"Until your next turn, your hero can only take 1 damage at a time.",
+"Refresh 2 Mana Crystals.\n<b>Overload:</b> (2)",
+"Set your Mana Crystals to 0. Set the Cost of cards in your hand and deck to (1).",
+"[x]For the rest of the game,\nplayers draw an extra card\nat the start of their turn.",
+"Your opponent summons a random minion from their hand."
+		};
+
+        private static HashSet<string> s_wildcardSubsets = new HashSet<string>()
+        {
+            "Put one of each <b>Secret</b> from your deck into",
+            "Each player equips",
+            "Set the Attack and Health of all minions",
+            "Cast a random",
+            "Fill your hand with",
+            "When you play",
+            "At the start of your next turn",
+            "Increase the damage of",
+            "Play 3 cards\n with",
+            "Play 3 different",
+            "At the start of your next",
+            "Unlock your <b>Overloaded</b>",
+            "Take 6\n damage on your turns",
+            "Take 6\ndamage on your turns",
+            "At the end of your",
+            "Add three ",
+            "<b>Dredge</b>. ",
+            "(targets\nchosen randomly)",
+			"this turn. They each attack",
+		};
+
+        private static bool IsWildcard(string cardText)
+        {
+            if (s_wildcards.Contains(cardText))
+            {
+                return true;
+            }
+
+            foreach (var wc in s_wildcardSubsets)
+            {
+                if (cardText.Contains(wc))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private static bool IsAtTheEndOfYourTurn(string cardText)
+		{
+            return cardText.Contains("At the end of your");
+
+		}
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectible.cs b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectible.cs
new file mode 100644
index 0000000..06d94ee
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectible.cs
@@ -0,0 +1,13 @@
+namespace Accessibility
+{
+abstract class AccessibleCollectible : AccessibleItem
+{
+        protected AccessibleCollectible(AccessibleComponent parent) : base(parent)
+        {
+        }
+
+        internal abstract void Activate();
+        internal abstract void UpdateMouse();
+        internal abstract string GetName();
+}
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectibleBattlegroundsFinisher.cs b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectibleBattlegroundsFinisher.cs
new file mode 100644
index 0000000..3357dc3
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectibleBattlegroundsFinisher.cs
@@ -0,0 +1,63 @@
+using System;
+using System.Collections.Generic;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleCollectibleBattlegroundsFinisher : AccessibleCollectible
+    {
+        private CollectibleBattlegroundsFinisher m_finisher;
+
+        internal AccessibleCollectibleBattlegroundsFinisher(AccessibleComponent parent, CollectibleBattlegroundsFinisher finisher) : base(parent)
+        {
+            m_finisher = finisher;
+        }
+
+        internal override void Activate()
+        {
+            var curPage = AccessibleCollectionManager.Get().GetBattlegroundsPageManager().GetCurrentPage() as BaconCollectionPageDisplay;
+            var pageDataModel = curPage.GetOrCreateFinisherCollectionPageDataModel();
+            BattlegroundsFinisherDataModel finisherDataModel = null;
+            foreach (var dataModel in pageDataModel.FinisherList)
+            {
+                if (dataModel.FinisherDbiId == m_finisher.DbfRecord.ID)
+                {
+                    finisherDataModel = dataModel;
+                }
+            }
+
+            if (finisherDataModel == null)
+            {
+                AccessibilityUtils.LogFatalError("AccessibleCollectibleBattlegroundsFinisher.Activate: Could not find an appropriate finisher data model on the current page, the details display will not behave correctly.");
+                finisherDataModel = m_finisher.CreateFinisherDataModel();
+            }
+
+            curPage.OnFinisherClicked(finisherDataModel);
+        }
+
+        internal override List<string> GetLines()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            if (CollectionManager.Get().IsFavoriteBattlegroundsFinisher(m_finisher.FinisherId))
+            {
+                lines.Add(GameStrings.Get("GLUE_BACON_COLLECTION_FAVORITE_FINISHER"));
+            }
+
+            AccessibleCardUtils.AddOwnedLine(lines, m_finisher.OwnedCount);
+            AccessibleCardUtils.AddLineIfExists(GameStrings.GetRarityText((TAG_RARITY)m_finisher.DbfRecord.Rarity), lines);
+
+            return lines;
+        }
+
+        internal override string GetName()
+        {
+            return m_finisher.DbfRecord.CollectionName;
+        }
+
+        internal override void UpdateMouse()
+        {
+            // This would be very complicated, and since we don't click with the mouse to activate we don't care.
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectibleFactory.cs b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectibleFactory.cs
new file mode 100644
index 0000000..8a79476
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectibleFactory.cs
@@ -0,0 +1,37 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Accessibility
+{
+    static class AccessibleCollectibleFactory
+    {
+        internal static List<AccessibleCollectible> MakeAccessibleCollectibles<TCollectible>(ICollection<TCollectible> collectibles, List<CollectionCardActors> cardActors, bool readOwned, bool readFavorites) where TCollectible : ICollectible
+        {
+            switch (collectibles)
+            {
+                case List<CollectibleCard> cards:
+                return MakeAccessibleCollectibleCards(cards, cardActors, readOwned, readFavorites);
+                case List<CollectibleBattlegroundsFinisher> finishers:
+                return MakeAccessibleCollectibleBattlegroundsFinishers(finishers);
+                default:
+                return null;
+            }
+        }
+
+        private static List<AccessibleCollectible> MakeAccessibleCollectibleCards(List<CollectibleCard> cards, List<CollectionCardActors> cardActors, bool readOwned, bool readFavorites)
+        {
+            var accessibleCards = new List<AccessibleCollectible>(cards.Count);
+            for (int i = 0; i < cards.Count(); i++)
+            {
+                accessibleCards.Add(new AccessibleCollectibleCard(AccessibleCollectionManager.Get(), cards[i], true, false, readOwned, readFavorites, cardActors[i]));
+            }
+            return accessibleCards;
+        }
+
+        private static List<AccessibleCollectible> MakeAccessibleCollectibleBattlegroundsFinishers(List<CollectibleBattlegroundsFinisher> finishers)
+        {
+            return finishers.Select((finisher) => new AccessibleCollectibleBattlegroundsFinisher(AccessibleCollectionManager.Get(), finisher) as AccessibleCollectible).ToList();
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionCardBack.cs b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionCardBack.cs
new file mode 100644
index 0000000..b2631d1
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionCardBack.cs
@@ -0,0 +1,56 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleCollectionCardBack : AccessibleCollectible
+    {
+        private readonly CollectionCardBack m_cardBack;
+
+        internal AccessibleCollectionCardBack(AccessibleComponent parent, CollectionCardBack cardBack) : base(parent)
+        {
+            m_cardBack = cardBack;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(GetName());
+
+            if (m_cardBack.m_favoriteBanner?.activeInHierarchy ?? false)
+			{
+                ret.Add(GameStrings.Get("GLUE_COLLECTION_MANAGER_FAVORITE_CARD_BACK"));
+			}
+
+            var numCopies = 0;
+            if (CardBackManager.Get()?.IsCardBackOwned(m_cardBack.GetCardBackId()) ?? false)
+			{
+                numCopies = 1;
+			}
+            AccessibleCardUtils.AddOwnedLine(ret, numCopies);
+
+            return ret;
+        }
+
+        internal int GetCardBackId()
+		{
+            return m_cardBack.GetCardBackId();
+		}
+
+        internal override void Activate()
+        {
+            AccessibleInputMgr.ClickRightMouseButton();
+        }
+
+        internal override void UpdateMouse()
+        {
+            AccessibleInputMgr.MoveMouseTo(m_cardBack.GetComponent<Actor>());
+        }
+
+        internal override string GetName()
+        {
+            return m_cardBack.m_name.Text;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionDeckBoxVisual.cs b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionDeckBoxVisual.cs
new file mode 100644
index 0000000..bfa0b40
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionDeckBoxVisual.cs
@@ -0,0 +1,112 @@
+﻿using System;
+using System.Collections.Generic;
+using Hearthstone.Progression;
+using Hearthstone.DataModels;
+
+namespace Accessibility
+{
+    class AccessibleCollectionDeckBoxVisual : AccessibleItem
+    {
+        private readonly CollectionDeckBoxVisual m_deck;
+
+        private bool m_inCollectionManager;
+
+        internal AccessibleCollectionDeckBoxVisual(AccessibleComponent parent, CollectionDeckBoxVisual deck, bool inCollectionManager=false) : base(parent)
+        {
+            m_deck = deck;
+            m_inCollectionManager = inCollectionManager;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_inCollectionManager)
+            {
+                return GetLinesForCollectionManager();
+            }
+            else
+            {
+                return GetLinesForDeckSelectionScreen();
+            }
+        }
+
+        private List<string> GetLinesForDeckSelectionScreen()
+        {
+            // Name and class
+            var ret = GetCommonDeckLines();
+            try
+            {
+                // Hero level
+                var heroLevel = GameUtils.GetHeroLevel(m_deck.GetClass());
+                var currentLevel = heroLevel.CurrentLevel?.Level;
+                ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_DECK_HERO_LEVEL, currentLevel));
+                if (GameUtils.HERO_SKIN_ACHIEVEMENTS.TryGetValue(m_deck.GetClass(), out var value))
+                {
+                    AchievementDataModel achievementDataModel = AchievementManager.Get().GetAchievementDataModel(value.Golden500Win);
+                                AchievementDataModel achievementDataModel2 = AchievementManager.Get().GetAchievementDataModel(value.Honored1kWin);
+                    int num = achievementDataModel?.Progress ?? 0;
+                    int num2 = achievementDataModel?.Quota ?? 0;
+                    if (achievementDataModel != null && AchievementManager.Get().IsAchievementComplete(achievementDataModel.ID))
+                    {
+                        num = achievementDataModel2?.Progress ?? num;
+                        num2 = achievementDataModel2?.Quota ?? num2;
+                    }
+                    ret.Add(GameStrings.Format("GLOBAL_HERO_WINS", num,""));
+                }
+            }        
+            catch (Exception)
+            {
+                // In some scenarios such as the first time we open practice mode right after the tutorial ends the hero level isn't populated
+            }
+            if (m_deck.m_isLoanerDeck && FreeDeckMgr.Get().Status == FreeDeckMgr.FreeDeckStatus.TRIAL_PERIOD) {
+                ret.Insert(1, LocalizationUtils.Format(LocalizationKey.SCREEN_DECK_PICKER_TRAY_DISPLAY_LOANER_DECK, FreeDeckMgr.Get().TrialPeriodEndTime));
+            }
+            return ret;
+        }
+
+        private List<string> GetLinesForCollectionManager()
+        {
+            // Name and class for now. TODO: Missing cards later
+            return GetCommonDeckLines();
+        }
+
+        private List<string> GetCommonDeckLines()
+        {
+            var ret = new List<string>();
+
+            // Deck name
+            var deckName = m_deck.GetDeckNameText().Text;
+            ret.Add(deckName);
+
+            if (SceneMgr.Get()?.GetMode() != SceneMgr.Mode.ADVENTURE)
+			{
+				// Format
+				var deckFormat = m_deck.GetFormatType();
+				ret.Add(GameStrings.GetFormatName(deckFormat));
+			}
+
+			// Hero name
+			var className = GameStrings.GetClassName(m_deck.GetClass());
+            if (!className.Equals(deckName, StringComparison.InvariantCultureIgnoreCase))
+            {
+                ret.Add(className);
+            }
+
+            if (m_deck.GetClass() == TAG_CLASS.DEATHKNIGHT)
+            {
+                ret.Add(AccessibleRuneUtils.StringifyRunePattern(m_deck.GetCollectionDeck().Runes));
+            }
+
+            // Invalid cards (used to be missing cards before 23.2.0 but decks can now have more than 30 while being built)
+            if (m_deck.m_isShowingInvalidCardCount)
+            {
+                var collectionDeck = m_deck.GetCollectionDeck();
+				int maxCardCount = collectionDeck.GetMaxCardCount();
+				int totalValidCardCount = collectionDeck.GetTotalValidCardCount();
+
+                ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK, totalValidCardCount, maxCardCount));
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionManager.cs b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionManager.cs
new file mode 100644
index 0000000..cce100b
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleCollectionManager.cs
@@ -0,0 +1,2390 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleCollectionManager : AccessibleScreen, AccessibleUI
+    {
+        private enum Mode
+        {
+            INVALID,
+            TRADITIONAL,
+            EMBEDDED,
+            BACON, // TODO
+            LETTUCE // TODO
+        }
+
+        private enum State
+        {
+            LOADING,
+            MAIN_MENU,
+            BROWSE_COLLECTION_MENU,
+            BROWSING_CARDS,
+            BROWSING_COINS,
+            BROWSING_CARD_BACKS,
+            BROWSING_HERO_SKINS,
+            BROWSING_HERO_SKIN_CLASSES,
+            MANAGE_DECKS_MENU,
+            BROWSING_DECKS_FOR_EDITING,
+            BROWSING_DECKS_FOR_DELETING,
+            EDIT_DECK_MENU,
+            EDIT_DECK_SEE_COLLECTION,
+            EDIT_DECK_SEE_DECK,
+            EDIT_DECK_RENAME_DECK,
+            CREATE_DECK_FROM_CLIPBOARD,
+            CRAFTING_MENU,
+            CRAFTING_SEE_COLLECTION,
+            VIEW_CARD,
+            VIEW_CARD_READ_CARD,
+            VIEW_CARD_VIEW_RELATED_CARDS,
+            VIEW_CARD_CRAFTING,
+            BATTLEGROUNDS_MAIN_MENU,
+            BATTLEGROUNDS_BROWSING_HERO_SKINS,
+            BATTLEGROUNDS_BROWSING_GUIDE_SKINS,
+            BATTLEGROUNDS_BROWSING_FINISHERS,
+        };
+
+        private State m_curState;
+
+        private Mode m_curMode;
+
+        private AccessibleMenu m_mainMenu;
+
+        private AccessibleMenu m_browseCollectionMenu;
+
+        private AccessibleMenu m_manageDecksMenu;
+
+        private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_editDecksMenu;
+
+        private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_deleteDecksMenu;
+
+        private AccessibleMenu m_editDeckMenu;
+
+        // Collection book stuff
+        private TAG_CLASS? m_curClassContext;
+        private AccessibleListOfItems<AccessibleCollectible> m_curPageCollectibles;
+        private AccessibleListOfItems<AccessibleCollectionCardBack> m_curPageCardBacks; // Card backs code is different than everything else
+        private AccessibleListOfItems<AccessibleCollectionHeroPickerButton> m_heroPickerClassButtons; // Hero skins are grouped by classes now
+        private bool m_justPressedLeft;
+        private int m_curPageNum;
+        private bool m_shouldAnnounceBattlegroundsHeroSkinFilterMode;
+
+        // Crafting
+        private AccessibleMenu m_craftingMenu;
+        private AccessibleMenu m_viewCardMenu;
+        private AccessibleMenu m_viewCardCraftingMenu;
+        private CraftingUI m_craftingUI;
+        private CardInfoPane m_cardInfoPane;
+        private EntityDef m_cardBeingRead;
+        private TAG_PREMIUM m_cardBeingReadPremium;
+        private AccessibleItem m_accessibleCardBeingRead;
+        private AccessibleListOfItems<AccessibleMultilineText> m_relatedCards;
+        private State m_stateBeforeViewCard; // Used to go back to the right menu after closing a card view
+
+        private bool m_waitingForServerResponse; // Used to read things more intuitively when regaining focus in certain cases
+
+        private bool m_justCanceledDisenchantPopup;
+
+        private bool m_isTransitioning;
+
+        internal bool m_willEditDeck;
+
+        private static AccessibleCollectionManager s_instance = new AccessibleCollectionManager();
+
+        internal static AccessibleCollectionManager Get()
+        {
+            return s_instance;
+        }
+
+        internal void OnCollectionManagerOpened()
+        {
+            SetMode();
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED && m_curMode != Mode.BACON)
+            {
+                return;
+            }
+
+            m_curState = State.LOADING;
+            m_stateBeforeViewCard = State.LOADING;
+            m_waitingForServerResponse = false;
+            m_justCanceledDisenchantPopup = false;
+            m_willEditDeck = false;
+            m_shouldAnnounceBattlegroundsHeroSkinFilterMode = true;
+
+            AccessibilityUtils.LogDebug("CM OnCollectionManagerOpened");
+            if (m_curMode == Mode.TRADITIONAL || m_curMode == Mode.BACON)
+            {
+                AccessibilityMgr.SetScreen(this);
+            }
+        }
+
+        private void SetMode()
+        {
+            switch (SceneMgr.Get().GetMode())
+            {
+                case SceneMgr.Mode.COLLECTIONMANAGER:
+                m_curMode = Mode.TRADITIONAL;
+                break;
+                case SceneMgr.Mode.TAVERN_BRAWL:
+                case SceneMgr.Mode.PVP_DUNGEON_RUN:
+                m_curMode = Mode.EMBEDDED;
+                break;
+                case SceneMgr.Mode.BACON_COLLECTION:
+                case SceneMgr.Mode.BACON:
+                m_curMode = Mode.BACON;
+                break;
+                case SceneMgr.Mode.LETTUCE_COLLECTION:
+                m_curMode = Mode.LETTUCE;
+                break;
+                default:
+                m_curMode = Mode.INVALID;
+                break;
+            }
+        }
+
+        private void HandlePageInput()
+        {
+            HandlePageInput(m_curPageCollectibles);
+        }
+
+        private void HandleCardBacksPageInput()
+        {
+            HandlePageInput(m_curPageCardBacks);
+        }
+
+        private void HandlePageInput<T>(AccessibleListOfItems<T> items) where T : AccessibleItem
+        {
+            if (items != null)
+            {
+                if (AccessibleKey.READ_NEXT_PAGE.IsPressed())
+                {
+                    GetPageManager().m_pageRightClickableRegion.TriggerRelease();
+                }
+                else if (AccessibleKey.READ_PREV_PAGE.IsPressed())
+                {
+                    GetPageManager().m_pageLeftClickableRegion.TriggerRelease();
+                }
+                else if (!items.HandleAccessibleInput())
+                {
+                    if (AccessibleKey.READ_PREV_ITEM.IsPressed())
+                    {
+                        m_justPressedLeft = true;
+                        GetPageManager().m_pageLeftClickableRegion.TriggerRelease();
+                    }
+                    else if (AccessibleKey.READ_NEXT_ITEM.IsPressed())
+                    {
+                        GetPageManager().m_pageRightClickableRegion.TriggerRelease();
+                    }
+                }
+                else
+                {
+                    m_justPressedLeft = false;
+                }
+            }
+        }
+
+        private CollectibleDisplay GetCollectibleDisplay()
+        {
+            return CollectionManager.Get().GetCollectibleDisplay();
+        }
+
+        private CollectionManagerDisplay GetTraditionalCollectibleDisplay()
+        {
+            return GetCollectibleDisplay() as CollectionManagerDisplay;
+        }
+
+        private BaconCollectionDisplay GetBattlegroundsCollectibleDisplay()
+        {
+            return GetCollectibleDisplay() as BaconCollectionDisplay;
+        }
+
+
+        private ManaFilterTabManager GetManaFilterTabManager()
+        {
+            return GetTraditionalCollectibleDisplay()?.m_manaTabManager;
+        }
+
+        private BookPageManager GetPageManager()
+        {
+            return GetCollectibleDisplay().GetPageManager();
+        }
+
+        private CollectionPageManager GetTraditionalPageManager()
+        {
+            return GetPageManager() as CollectionPageManager;
+        }
+
+        internal BaconCollectionPageManager GetBattlegroundsPageManager()
+        {
+            return GetPageManager() as BaconCollectionPageManager;
+        }
+
+        internal void OnCancelDisenchantPopup()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            m_justCanceledDisenchantPopup = true;
+        }
+
+        internal void OnPageChanged<TCollectible>(int curPageNum, ICollection<TCollectible> collectiblesToDisplay, List<CollectionCardActors> cardActors) where TCollectible : ICollectible
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED && m_curMode != Mode.BACON)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug("CM OnPageChanged");
+            AccessibilityUtils.LogDebug($"CM curPageNum {curPageNum}");
+
+            var classContext = ShouldAnnounceClass() ? GetTraditionalPageManager().m_currentClassContext as CollectionTabInfo? : null;
+
+            AccessibilityUtils.LogDebug($"CM classContext={classContext} | m_curClassContext={m_curClassContext}");
+
+            if (m_curState == State.BATTLEGROUNDS_BROWSING_HERO_SKINS && m_shouldAnnounceBattlegroundsHeroSkinFilterMode)
+            {
+                ReadBattlegroundsHeroSkinFilterMode();
+            }
+
+            if (curPageNum != m_curPageNum && IsBrowsingCards())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, curPageNum));
+                AccessibilityMgr.Output(this, classContext == null ? null : GameStrings.GetClassName((classContext?.tagClass) ?? TAG_CLASS.NEUTRAL));
+            }
+            else if (curPageNum != m_curPageNum && IsBrowsingOtherCollectibles())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, curPageNum));
+            }
+
+            var readOwned = IsBrowsingOtherCollectibles() || IsCrafting() || m_curMode == Mode.BACON;
+            var readFavorites = m_curState == State.BROWSING_HERO_SKIN_CLASSES || m_curState == State.BROWSING_HERO_SKINS || m_curState == State.BROWSING_COINS || m_curMode == Mode.BACON;
+
+            var accessibleCollectibles = AccessibleCollectibleFactory.MakeAccessibleCollectibles(collectiblesToDisplay, cardActors, readOwned, readFavorites);
+
+            if (accessibleCollectibles == null)
+            {
+                return;
+            }
+
+            var curPageCards = new AccessibleListOfItems<AccessibleCollectible>(this, accessibleCollectibles);
+
+            if (IsWaitingForServerResponse() && (m_stateBeforeViewCard == State.CRAFTING_SEE_COLLECTION || m_stateBeforeViewCard == State.BROWSING_CARDS))
+            {
+                OnServerResponse();
+
+                var prevIndex = m_curPageCollectibles.GetItemBeingReadIndex();
+                var readFromIndex = Math.Min(prevIndex, curPageCards.Count);
+
+                if (m_curClassContext != classContext?.tagClass || m_curPageNum != curPageNum)
+                {
+                    readFromIndex = 0;
+                }
+
+                curPageCards.StartReadingFromIndex(readFromIndex);
+            }
+            else if (m_curPageCollectibles == null || !SameCards(curPageCards.Items, m_curPageCollectibles.Items))
+            {
+                if (IsBrowsingCards() || IsBrowsingOtherCollectibles())
+                {
+                    if (m_justPressedLeft)
+                    {
+                        curPageCards.StartReadingReverse();
+                    }
+                    else
+                    {
+                        curPageCards.StartReading();
+                    }
+                }
+            }
+
+            m_curPageCollectibles = curPageCards;
+            m_curClassContext = classContext?.tagClass;
+            m_curPageNum = curPageNum;
+            m_justPressedLeft = false;
+        }
+
+        private bool ShouldAnnounceClass()
+        {
+            return (m_curMode == Mode.TRADITIONAL || m_curMode == Mode.EMBEDDED) && (!CollectionDeckTray.Get()?.IsZilliaxSideboardOpen() ?? true);
+        }
+
+        internal void OnCardBacksPageChanged(int curPageNum, List<CollectionCardActors> cardActors)
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug("CM OnCardBacksPageChanged");
+            AccessibilityUtils.LogDebug($"CM curPageNum {curPageNum}");
+
+            if (curPageNum != m_curPageNum)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, curPageNum));
+            }
+
+            var accessibleCardBacks = new List<AccessibleCollectionCardBack>(cardActors.Count);
+            foreach (var actor in cardActors)
+            {
+                var cardBack = actor.GetPreferredActor().GetComponent<CollectionCardBack>(); // Flimsy but covered by tests
+                accessibleCardBacks.Add(new AccessibleCollectionCardBack(this, cardBack));
+            }
+
+            var curPageCardBacks = new AccessibleListOfItems<AccessibleCollectionCardBack>(this, accessibleCardBacks);
+
+            if (m_curPageCardBacks == null || !SameCardBacks(curPageCardBacks.Items, m_curPageCardBacks.Items))
+            {
+                if (m_justPressedLeft)
+                {
+                    curPageCardBacks.StartReadingReverse();
+                }
+                else
+                {
+                    curPageCardBacks.StartReading();
+                }
+            }
+
+            m_curPageCardBacks = curPageCardBacks;
+            m_curClassContext = TAG_CLASS.NEUTRAL;
+            m_curPageNum = curPageNum;
+            m_justPressedLeft = false;
+        }
+
+        internal void OnShowNoMatchesFound(string key)
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED && m_curMode != Mode.BACON)
+            {
+                return;
+            }
+
+            var text = GameStrings.Get(key);
+            m_curPageCollectibles = new AccessibleListOfItems<AccessibleCollectible>(this, new List<AccessibleCollectible>(), text);
+            m_curPageCollectibles.StartReading();
+        }
+
+        private bool SameCards(List<AccessibleCollectible> l1, List<AccessibleCollectible> l2)
+        {
+            if (l1.Count != l2.Count)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < l1.Count; i++)
+            {
+                if (!l1[i].GetName().Equals(l2[i].GetName()))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        private bool SameCardBacks(List<AccessibleCollectionCardBack> l1, List<AccessibleCollectionCardBack> l2)
+        {
+            if (l1.Count != l2.Count)
+            {
+                return false;
+            }
+
+            for (int i = 0; i < l1.Count; i++)
+            {
+                if (l1[i].GetCardBackId() != l2[i].GetCardBackId())
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        internal void OnCollectionManagerClosed()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug("CM OnCollectionManagerClosed");
+            AccessibilityMgr.TransitioningScreens();
+        }
+
+        internal void OnCollectibleDisplayReady()
+        {
+            AccessibilityUtils.LogDebug("CM OnCollectibleDisplayReady");
+            AccessibilityUtils.LogDebug($"{SceneMgr.Get().GetMode()}");
+
+            if (m_curMode == Mode.TRADITIONAL)
+            {
+                SetupMainMenu();
+            }
+            else if (m_curMode == Mode.BACON)
+            {
+                SetupBattlegroundsMainMenu();
+            }
+        }
+
+        internal void OnChangeViewMode(CollectionUtils.ViewMode prevMode, CollectionUtils.ViewMode curMode)
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            if (prevMode == CollectionUtils.ViewMode.MASS_DISENCHANT && curMode == CollectionUtils.ViewMode.CARDS)
+            {
+                MassDisenchant.Get()?.HideThis();
+            }
+        }
+
+        #region Battlegrounds
+        private AccessibleMenu m_BattlegroundsMainMenu;
+
+        private void SetupBattlegroundsMainMenu()
+        {
+            m_BattlegroundsMainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION), () => Navigation.GoBack());
+            m_BattlegroundsMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_BROWSE_HERO_SKINS), BattlegroundsBrowseHeroSkins);
+            m_BattlegroundsMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_BROWSE_GUIDE_SKINS), BattlegroundsBrowseGuideSkins);
+            m_BattlegroundsMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_BROWSE_FINISHERS), BattlegroundsBrowseFinishers);
+
+            ReadBattlegroundsMainMenu();
+        }
+
+        private void ReadBattlegroundsMainMenu(bool readMenuName=true)
+        {
+            m_BattlegroundsMainMenu.StartReading(readMenuName);
+            m_curState = State.BATTLEGROUNDS_MAIN_MENU;
+        }
+
+        private void RereadBattlegroundsMainMenu()
+        {
+            ReadBattlegroundsMainMenu(false);
+        }
+
+
+        private void BattlegroundsBrowseHeroSkins()
+        {
+            m_curState = State.BATTLEGROUNDS_BROWSING_HERO_SKINS;
+            var heroSkinsTab = GetBattlegroundsPageManager().m_heroSkinsTab;
+            if (heroSkinsTab.IsSelected())
+            {
+                ReadBattlegroundsHeroSkinFilterMode();
+                StartReadingCurrentPage(m_curPageCollectibles);
+            }
+            else
+            {
+                ChangeToTab(heroSkinsTab);
+            }
+        }
+
+        private void BattlegroundsBrowseGuideSkins()
+        {
+            m_curState = State.BATTLEGROUNDS_BROWSING_GUIDE_SKINS;
+            var guideSkinsTab = GetBattlegroundsPageManager().m_guideSkinsTab;
+            if (guideSkinsTab.IsSelected())
+            {
+                StartReadingCurrentPage(m_curPageCollectibles);
+            }
+            else
+            {
+                ChangeToTab(guideSkinsTab);
+            }
+        }
+
+        private void BattlegroundsBrowseFinishers()
+        {
+            m_curState = State.BATTLEGROUNDS_BROWSING_FINISHERS;
+            var finishersTab = GetBattlegroundsPageManager().m_finishersTab;
+            if (finishersTab.IsSelected())
+            {
+                StartReadingCurrentPage(m_curPageCollectibles);
+            }
+            else
+            {
+                ChangeToTab(finishersTab);
+            }
+        }
+
+        private void ReadBattlegroundsHeroSkinFilterMode()
+        {
+            m_shouldAnnounceBattlegroundsHeroSkinFilterMode = false;
+            var currentFilterMode = GetBattlegroundsCollectibleDisplay().GetHeroSkinFilterMode();
+            switch (currentFilterMode)
+            {
+                case CollectionUtils.BattlegroundsHeroSkinFilterMode.DEFAULT:
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_HERO_SKIN_FILTER_MODE_OWNED));
+                break;
+                case CollectionUtils.BattlegroundsHeroSkinFilterMode.ALL:
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_HERO_SKIN_FILTER_MODE_ALL));
+                break;
+            }
+        }
+
+
+        #endregion
+
+        #region Input
+
+        public void HandleInput()
+        {
+            switch (m_curState)
+            {
+                case State.BROWSING_CARDS:
+                case State.BROWSING_COINS:
+                case State.BATTLEGROUNDS_BROWSING_FINISHERS:
+                case State.BATTLEGROUNDS_BROWSING_GUIDE_SKINS:
+                case State.BATTLEGROUNDS_BROWSING_HERO_SKINS:
+                    HandleBrowsingCollectionInput();
+                    break;
+                case State.BROWSING_HERO_SKINS:
+                    HandleBrowsingCollectionInput(true);
+                    break;
+                case State.BROWSING_CARD_BACKS:
+                    HandleBrowsingCardBacksInput();
+                    break;
+                case State.BROWSING_HERO_SKIN_CLASSES:
+                    HandleBrowsingHeroSkinClassesInput();
+                    break;
+                case State.MANAGE_DECKS_MENU:
+                    m_manageDecksMenu?.HandleAccessibleInput();
+                    break;
+                case State.BROWSING_DECKS_FOR_EDITING:
+                    m_editDecksMenu?.HandleAccessibleInput();
+                    break;
+                case State.BROWSING_DECKS_FOR_DELETING:
+                    m_deleteDecksMenu?.HandleAccessibleInput();
+                    break;
+                case State.MAIN_MENU:
+                    m_mainMenu?.HandleAccessibleInput();
+                    break;
+                    case State.BATTLEGROUNDS_MAIN_MENU:
+                    m_BattlegroundsMainMenu?.HandleAccessibleInput();
+                    break;
+                case State.BROWSE_COLLECTION_MENU:
+                    m_browseCollectionMenu?.HandleAccessibleInput();
+                    break;
+                case State.EDIT_DECK_MENU:
+                    m_editDeckMenu?.HandleAccessibleInput();
+                    break;
+                case State.EDIT_DECK_SEE_COLLECTION:
+                    HandleEditDeckSeeCollection();
+                    break;
+                case State.EDIT_DECK_SEE_DECK:
+                    HandleEditDeckSeeDeck();
+                    break;
+                case State.CRAFTING_MENU:
+                    m_craftingMenu?.HandleAccessibleInput();
+                    break;
+                case State.CRAFTING_SEE_COLLECTION:
+                    HandleCraftingSeeCollection();
+                    break;
+                case State.VIEW_CARD:
+                    m_viewCardMenu?.HandleAccessibleInput();
+                    break;
+                case State.VIEW_CARD_READ_CARD:
+                    HandleViewCardReadCard();
+                    break;
+                    case State.VIEW_CARD_VIEW_RELATED_CARDS:
+                    HandleViewCardViewRelatedCards();
+                    break;
+                case State.VIEW_CARD_CRAFTING:
+                    m_viewCardCraftingMenu?.HandleAccessibleInput();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        private void HandleCommonBrowseCollectionInput()
+        {
+            UpdateMouseWhenBrowsingCollection();
+
+            if (AccessibleKey.GLOBAL_FIND.IsPressed())
+            {
+                var collectionSearch = GetCollectibleDisplay().m_search;
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_SEARCH_PROMPT));
+                collectionSearch.m_background.TriggerRelease();
+                collectionSearch.ClearFilter(false);
+                return;
+            }
+
+            if (IsBrowsingCards())
+            {
+                HandleCommonBrowsingCardsInput();
+            }
+            else
+            {
+                HandlePageInput();
+            }
+        }
+
+        private void HandleCommonBrowsingCardsInput()
+        {
+            HandleManaFiltersInput();
+            if (!HandleClassTabsInput())
+            {
+                HandlePageInput(); // Protect against tabs
+            }
+
+            if (AccessibleKey.READ_TOOLTIP.IsPressed())
+            {
+                AccessibilityUtils.ReadTooltip(this);
+            }
+        }
+
+        private bool IsBrowsingCards()
+        {
+            return m_curState == State.BROWSING_CARDS || m_curState == State.CRAFTING_SEE_COLLECTION || m_curState == State.EDIT_DECK_SEE_COLLECTION;
+        }
+
+        private bool IsBrowsingOtherCollectibles()
+        {
+            return m_curState == State.BROWSING_HERO_SKIN_CLASSES || m_curState == State.BROWSING_HERO_SKINS || m_curState == State.BROWSING_CARD_BACKS || m_curState == State.BROWSING_COINS || m_curState == State.BATTLEGROUNDS_BROWSING_FINISHERS || m_curState == State.BATTLEGROUNDS_BROWSING_GUIDE_SKINS || m_curState == State.BATTLEGROUNDS_BROWSING_HERO_SKINS;
+        }
+
+        private bool IsCrafting()
+        {
+            return CraftingTray.Get()?.IsShown() ?? false;
+        }
+
+        private void HandleBrowsingCollectionInput(bool heroSkins = false)
+        {
+            if (m_curState == State.BATTLEGROUNDS_BROWSING_HERO_SKINS && (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed() || AccessibleKey.READ_PREV_VALID_ITEM.IsPressed()))
+            {
+                m_shouldAnnounceBattlegroundsHeroSkinFilterMode = true;
+                GetBattlegroundsCollectibleDisplay().ToggleHeroSkinFilterMode();
+                return;
+            }
+
+            HandleCommonBrowseCollectionInput();
+
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                if (heroSkins)
+                {
+                    OnBrowseHeroSkins();
+                }
+                else
+                {
+                    if (m_curMode == Mode.TRADITIONAL)
+                    {
+                        RereadMainMenu();
+                    }
+                    else if (m_curMode == Mode.BACON)
+                    {
+                        RereadBattlegroundsMainMenu();
+                    }
+                    RemoveFiltersIfNecessary();
+                }
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_curPageCollectibles.GetItemBeingRead()?.Activate();
+            }
+        }
+
+        private void HandleBrowsingCardBacksInput()
+        {
+            UpdateMouseWhenBrowsingCardBacks();
+            HandleCardBacksPageInput();
+
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                RereadMainMenu();
+                RemoveFiltersIfNecessary();
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_curPageCardBacks.GetItemBeingRead()?.Activate();
+            }
+        }
+
+        private void HandleBrowsingHeroSkinClassesInput()
+        {
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                RereadMainMenu();
+                GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.CARDS);
+                RemoveFiltersIfNecessary();
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                ChooseHeroSkinClass(m_heroPickerClassButtons.GetItemBeingRead());
+            }
+            else
+            {
+                m_heroPickerClassButtons.HandleAccessibleInput();
+            }
+        }
+
+        private void ChooseHeroSkinClass(AccessibleCollectionHeroPickerButton button)
+        {
+            if (button == null)
+            {
+                return;
+            }
+
+            button.GetHeroPickerButton().TriggerRelease();
+
+            m_curState = State.BROWSING_HERO_SKINS;
+        }
+
+        private void RemoveFiltersIfNecessary()
+        {
+            m_shouldAnnounceBattlegroundsHeroSkinFilterMode = true;
+
+            var collectionSearch = GetCollectibleDisplay()?.m_search;
+            collectionSearch?.ClearFilter(true);
+
+            var filterTabManager = GetManaFilterTabManager();
+
+            if (filterTabManager?.IsFilterActive ?? false)
+            {
+                filterTabManager.ClearFilter(true);
+            }
+
+            if (CollectionDeckTray.Get()?.IsZilliaxSideboardOpen() ?? false)
+            {
+                GetTraditionalPageManager()?.m_ZilliaxModulesTab.TriggerRelease();
+            }
+        }
+
+        private void HandleEditDeckSeeCollection()
+        {
+            HandleCommonBrowseCollectionInput();
+
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                SetupEditDeckMenu();
+                RemoveFiltersIfNecessary();
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_curPageCollectibles.GetItemBeingRead()?.Activate();
+            }
+            else
+            {
+                HandleEditDeckShortcuts();
+            }
+        }
+
+        private void HandleCraftingSeeCollection()
+        {
+            HandleCommonBrowseCollectionInput();
+
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                ReadCraftingMenu();
+                RemoveFiltersIfNecessary();
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_curPageCollectibles.GetItemBeingRead()?.Activate();
+            }
+        }
+
+        private void HandleEditDeckShortcuts()
+        {
+            if (AccessibleKey.SEE_PLAYER_DECK.IsPressed())
+            {
+                EditDeckSeeDeck();
+            }
+            else if (AccessibleKey.SEE_PLAYER_HAND.IsPressed())
+            {
+                EditDeckAddCards();
+            }
+        }
+
+        private void HandleEditDeckSeeDeck()
+        {
+            UpdateMouseWhenEditingDeck();
+
+            m_editingDeckCards?.HandleAccessibleInput();
+
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                SetupEditDeckMenu();
+            }
+            else if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    AccessibleInputMgr.ClickLeftMouseButton();
+                }
+            }
+            else if (AccessibleKey.SPACE.IsPressed())
+            {
+                OpenSideboard();
+            }
+            else if (AccessibleKey.EDIT_DECK_ENTER_CRAFTING_MODE.IsPressed())
+            {
+                AccessibleInputMgr.ClickRightMouseButton();
+            }
+            else
+            {
+                HandleEditDeckShortcuts();
+            }
+        }
+
+        internal bool IsInEditDeckMode()
+        {
+            return m_curState == State.EDIT_DECK_MENU || m_curState == State.EDIT_DECK_RENAME_DECK || m_curState == State.EDIT_DECK_SEE_COLLECTION || m_curState == State.EDIT_DECK_SEE_DECK;
+        }
+
+        private void UpdateMouseWhenBrowsingCollection()
+        {
+            UpdateMouseWhenBrowsingCollectibles(m_curPageCollectibles);
+        }
+
+        private void UpdateMouseWhenBrowsingCardBacks()
+        {
+            UpdateMouseWhenBrowsingCollectibles(m_curPageCardBacks);
+        }
+
+        private void UpdateMouseWhenBrowsingCollectibles<T>(AccessibleListOfItems<T> items) where T : AccessibleCollectible
+        {
+            if (items == null || items.Count == 0)
+            {
+                return;
+            }
+
+            items.GetItemBeingRead()?.UpdateMouse();
+        }
+
+        private AccessibleEditingDeckCard m_prevCardBeingRead;
+
+        private void UpdateMouseWhenEditingDeck()
+        {
+            var curCard = m_editingDeckCards?.GetItemBeingRead();
+
+            if (curCard != m_prevCardBeingRead)
+            {
+                AccessibilityUtils.CenterScrollbarAroundObject(CollectionDeckTray.Get().m_scrollbar, curCard.GetCardTile().gameObject);
+            }
+
+            AccessibleInputMgr.MoveMouseTo(curCard.GetCardTile().GetActor());
+
+            m_prevCardBeingRead = curCard;
+        }
+
+        private static bool s_justOutOfSetFilterTray;
+
+        internal void OnSelectFilterItem()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            s_justOutOfSetFilterTray = true;
+
+            if (m_curState == State.MAIN_MENU)
+            {
+                // Reset main menu to ease journey
+                m_mainMenu.SetIndex(0);
+            }
+            else if (m_curState == State.CRAFTING_MENU)
+            {
+                // Focus crafting menu on "browse cards" to ease journey
+                if (CanMassDisenchant(CraftingTray.Get()?.m_massDisenchantButton))
+                {
+                    m_craftingMenu.SetIndex(1);
+                }
+                else
+                {
+                    m_craftingMenu.SetIndex(0);
+                }
+            }
+        }
+
+        private bool CanMassDisenchant(PegUIElement massDisenchantButton)
+        {
+            if (massDisenchantButton == null)
+            {
+                return false;
+            }
+
+            return massDisenchantButton.IsEnabled();
+        }
+
+        private void HandleManaFiltersInput()
+        {
+            int? numKeyPressed = AccessibleInputMgr.TryGetPressedNumKey();
+
+            if (numKeyPressed.HasValue)
+            {
+                int pressedTab = numKeyPressed.Value;
+
+                if (pressedTab == 10)
+                {
+                    pressedTab = 0;
+                }
+                else if (pressedTab > ManaFilterTabManager.NUM_MANA_FILTERS)
+                {
+                    return;
+                }
+
+                var tabs = GetManaFilterTabManager().m_tabs;
+
+                if (pressedTab >= tabs.Count)
+                {
+                    return;
+                }
+
+                m_justPressedLeft = false;
+                ClickManaFilter(tabs[pressedTab]);
+            }
+        }
+
+        private void ClickManaFilter(ManaFilterTab manaFilterTab)
+        {
+            if (!GetManaFilterTabManager()?.IsManaValueActive(manaFilterTab.GetManaID()) ?? false)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_MANA_FILTER_ON, manaFilterTab.m_manaCostText));
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MANA_FILTER_OFF));
+            }
+
+            manaFilterTab.TriggerRelease();
+        }
+
+        private bool HandleClassTabsInput()
+        {
+            if (AccessibleKey.READ_NEXT_VALID_ITEM.IsPressed())
+            {
+                FlipToNextClass(1);
+                return true;
+            }
+            else if (AccessibleKey.READ_PREV_VALID_ITEM.IsPressed())
+            {
+                FlipToNextClass(-1);
+                return true;
+            }
+
+            return false;
+        }
+
+        private void FlipToFirstClassTab()
+        {
+            var classTabs = GetTraditionalPageManager().m_classTabs.FindAll(t => t.IsVisible()); // Show only visible tabs due to filters
+
+            if (classTabs.Count > 0)
+            {
+                classTabs[0].TriggerRelease();
+            }
+        }
+
+        private void FlipToNextClass(int inc)
+        {
+            m_justPressedLeft = false;
+
+            var classTabs = GetTraditionalPageManager().m_classTabs.FindAll(t => t.IsVisible()); // Show only visible tabs due to filters
+
+            var curClassTab = 0;
+            for (int i = 0; i < classTabs.Count; i++)
+            {
+                if (classTabs[i].IsSelected())
+                {
+                    curClassTab = i;
+                    break;
+                }
+            }
+
+            int targetClassTab = curClassTab + inc;
+
+            if (targetClassTab < 0)
+            {
+                targetClassTab = classTabs.Count - 1;
+            }
+            else if (targetClassTab >= classTabs.Count)
+            {
+                targetClassTab = 0;
+            }
+
+            classTabs[targetClassTab].TriggerRelease();
+        }
+
+        private void SetupMainMenu()
+        {
+            m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION), () => Navigation.GoBack());
+            m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION), OnBrowseCollection);
+            m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MY_DECKS), SetupDeckManagementMenu);
+
+            if (CollectionManagerDisplay.ShouldSeeCraftingButton())
+            {
+                m_mainMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_CRAFTING_MODE_SHORT"), ClickCraftingButton);
+            }
+
+            AddChangeSetButton(m_mainMenu);
+
+            ReadMainMenu();
+        }
+
+        private void OnBrowseCollection()
+        {
+            m_browseCollectionMenu = new AccessibleMenu(this, "", RereadMainMenu);
+
+            m_browseCollectionMenu.AddOption(LocalizedText.GLOBAL_CARD_PLURAL, OnBrowseCards);
+
+            if (GetTraditionalPageManager().m_heroSkinsTab.IsVisible())
+            {
+                m_browseCollectionMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_MANAGER_HERO_SKINS_TITLE"), OnBrowseHeroSkins);
+            }
+
+            if (GetTraditionalPageManager().m_cardBacksTab.IsVisible())
+            {
+                m_browseCollectionMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_MANAGER_CARD_BACKS_TITLE"), OnBrowseCardBacks);
+            }
+
+            if (GetTraditionalPageManager().m_coinsTab.IsVisible())
+            {
+                m_browseCollectionMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_MANAGER_COINS_TITLE"), OnBrowseCoins);
+            }
+
+            m_browseCollectionMenu.StartReading();
+            m_curState = State.BROWSE_COLLECTION_MENU;
+        }
+
+        private void OnBrowseHeroSkins()
+        {
+            m_curState = State.LOADING;
+
+            var heroSkinsTab = GetTraditionalPageManager().m_heroSkinsTab;
+            if (heroSkinsTab.IsSelected())
+            {
+                m_heroPickerClassButtons.StartReading();
+                m_curState = State.BROWSING_HERO_SKIN_CLASSES;
+            }
+            else
+            {
+                ChangeToTab(heroSkinsTab);
+            }
+        }
+
+        private void OnBrowseCardBacks()
+        {
+            m_curState = State.BROWSING_CARD_BACKS;
+
+            var cardBacksTab = GetTraditionalPageManager().m_cardBacksTab;
+            if (cardBacksTab.IsSelected())
+            {
+                StartReadingCurrentPage(m_curPageCardBacks);
+            }
+            else
+            {
+                ChangeToTab(cardBacksTab);
+            }
+        }
+
+        private void ResetBook()
+        {
+            m_curPageCollectibles = null;
+            m_curPageCardBacks = null;
+            m_curPageNum = 0;
+            m_justPressedLeft = false;
+            m_curClassContext = TAG_CLASS.NEUTRAL;
+        }
+
+        private void StartReadingCurrentPage<T>(AccessibleListOfItems<T> items) where T : AccessibleItem
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+            items.StartReading();
+        }
+
+        private void OnBrowseCoins()
+        {
+            m_curState = State.BROWSING_COINS;
+
+            var coinsTab = GetTraditionalPageManager().m_coinsTab;
+            if (coinsTab.IsSelected())
+            {
+                StartReadingCurrentPage(m_curPageCollectibles);
+            }
+            else
+            {
+                ChangeToTab(coinsTab);
+            }
+        }
+
+        private void ChangeToTab(PegUIElement tab)
+        {
+            ResetBook();
+            tab.TriggerRelease();
+        }
+
+        private void ReadMainMenu(bool readMenuName = true)
+        {
+            m_mainMenu.StartReading(readMenuName);
+            m_curState = State.MAIN_MENU;
+        }
+
+        private void RereadMainMenu()
+        {
+            ReadMainMenu(false);
+        }
+
+        private void OnBrowseCards()
+        {
+            FlipToFirstClassTab();
+            OutputFilter();
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+            AccessibilityMgr.Output(this, GameStrings.GetClassName(m_curClassContext ?? TAG_CLASS.NEUTRAL));
+            m_curPageCollectibles.StartReading();
+            m_curState = State.BROWSING_CARDS;
+        }
+
+        private void SetupDeckManagementMenu()
+        {
+            m_manageDecksMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MY_DECKS), RereadMainMenu);
+
+            if (HasDecks())
+            {
+                m_manageDecksMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK), SetupEditDecksMenu);
+            }
+
+            if (CanCreateDecks())
+            {
+                m_manageDecksMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_NEW_DECK), OnNewDeck);
+            }
+
+            if (CanDeleteDecks())
+            {
+                m_manageDecksMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_DELETE_DECK), SetupDeleteDecksMenu);
+            }
+
+            m_manageDecksMenu.StartReading();
+            m_curState = State.MANAGE_DECKS_MENU;
+        }
+
+        private void SetupDeleteDecksMenu()
+        {
+            m_deleteDecksMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_DELETE_DECK), SetupDeckManagementMenu);
+            var scrollbar = CollectionDeckTray.Get().m_scrollbar;
+
+            foreach (var traySection in GetVisibleTraySections())
+            {
+                var deckBox = traySection.m_deckBox;
+
+                m_deleteDecksMenu.AddOption(new AccessibleCollectionDeckBoxVisual(this, deckBox, true), () => DeleteDeck(deckBox), () => AccessibilityUtils.CenterScrollbarAroundObject(scrollbar, deckBox.gameObject));
+            }
+
+            m_deleteDecksMenu.StartReading();
+            m_curState = State.BROWSING_DECKS_FOR_DELETING;
+        }
+
+        private void DeleteDeck(CollectionDeckBoxVisual deck)
+        {
+            CollectionManager.Get().RegisterDeckDeletedListener(OnDeckDeleted);
+            deck.m_deleteButton.TriggerRelease();
+        }
+
+        private void OnDeckDeleted(CollectionDeck removedDeck)
+        {
+            SetupDeckManagementMenu();
+
+            CollectionManager.Get().RemoveDeckDeletedListener(OnDeckDeleted);
+        }
+
+        private void SetupEditDecksMenu()
+        {
+            m_editDecksMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK), SetupDeckManagementMenu);
+            var scrollbar = CollectionDeckTray.Get().m_scrollbar;
+
+            foreach (var traySection in GetVisibleTraySections())
+            {
+                var deckBox = traySection.m_deckBox;
+                m_editDecksMenu.AddOption(new AccessibleCollectionDeckBoxVisual(this, deckBox, true), () => EditDeck(deckBox), () => AccessibilityUtils.CenterScrollbarAroundObject(scrollbar, deckBox.gameObject));
+            }
+
+            m_editDecksMenu.StartReading();
+            m_curState = State.BROWSING_DECKS_FOR_EDITING;
+        }
+
+        internal void OnFinishRenamingDeck()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            if (m_curState == State.EDIT_DECK_RENAME_DECK)
+            {
+                // Prevent against rename notifications when the deck closes
+                SetupEditDeckMenu();
+            }
+        }
+
+        private List<TraySection> GetVisibleTraySections()
+        {
+            var ret = new List<TraySection>();
+
+            var collectionDeckTray = CollectionDeckTray.Get();
+            var decksContent = collectionDeckTray.GetDecksContent();
+
+            foreach (var traySection in decksContent.m_traySections)
+            {
+                if (traySection.IsDeckBoxShown())
+                {
+                    ret.Add(traySection);
+                }
+            }
+
+            return ret;
+        }
+
+        private void SetupEditDeckMenu()
+        {
+            AccessibilityUtils.LogDebug("Setup EditDeckMenu");
+
+            AccessibleInputMgr.HideMouse();
+
+            var collectionDeckTray = CollectionDeckTray.Get();
+            var decksContent = collectionDeckTray.GetDecksContent();
+            var deckName = !collectionDeckTray.IsSideboardOpen ? CollectionManager.Get().GetEditedDeck().Name : LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_SIDEBOARD);
+
+            //m_editDeckMenu = new AccessibleMenu(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK), null); // TODO: Back from both edit and create new
+            m_editDeckMenu = new AccessibleMenu(this, deckName, null); // TODO: Back from both edit and create new
+
+            m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_ADD_CARDS_OPTION), EditDeckAddCards);
+            if (!collectionDeckTray.IsSideboardOpen)
+            {
+                m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION), () => EditDeckSeeDeck());
+                if (m_curMode == Mode.TRADITIONAL)
+                    m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_RENAME_DECK_OPTION), EditDeckRenameDeck);
+                m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_COPY_DECK_OPTION), EditDeckCopyDeck);
+                if (m_curMode == Mode.TRADITIONAL)
+                    SetupEditDeckFormatSwitcherButtons();
+                    if (SceneMgr.Get().IsInTavernBrawlMode())
+                    m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_DELETE_DECK), () => TavernBrawlDisplay.Get().m_editDeckButton.TriggerRelease());
+                m_editDeckMenu.AddOption(CollectionDeckTray.Get().m_doneButton.GetText(), EditDeckDone);
+            }
+            else
+            {
+                m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_SIDEBOARD_OPTION), () => EditDeckSeeDeck());
+                if (collectionDeckTray.IsZilliaxSideboardOpen())
+                m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_LOAD_SAVED_VERSION_OPTION), SetupSavedZilliaxVersions);
+                m_editDeckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_BACK_TO_DECK_OPTION), CloseSideboard);
+            }
+            m_editDeckMenu.StartReading();
+            m_curState = State.EDIT_DECK_MENU;
+
+            var sideboardContent = collectionDeckTray.GetSideboardCardsContent();
+            sideboardContent?.UnregisterCardCountUpdated(OnSideboardCardCountUpdated);
+            sideboardContent?.RegisterCardCountUpdated(OnSideboardCardCountUpdated);
+
+            CollectionDeckTray.Get().m_cardsContent.UnregisterCardCountUpdated(OnDeckCardCountUpdated);
+            CollectionDeckTray.Get().m_cardsContent.RegisterCardCountUpdated(OnDeckCardCountUpdated);
+        }
+
+        private void SetupEditDeckFormatSwitcherButtons()
+        {
+            var deckOptionsMenu = CollectionDeckTray.Get().GetDecksContent().m_deckOptionsMenu;
+            foreach (var format in deckOptionsMenu.GetFormatTypesToConvert(CollectionManager.Get().GetEditedDeck().FormatType))
+            {
+                if (DeckOptionsMenu.s_FORMAT_TO_SWITCH_STRING.TryGetValue(format, out var switchString) && (format != PegasusShared.FormatType.FT_TWIST || deckOptionsMenu.CanConvertCurrentDeckToTwist()))
+                {
+                    m_editDeckMenu.AddOption(GameStrings.Get(switchString), () => deckOptionsMenu.StartCoroutine(deckOptionsMenu.SwitchFormat(format)));
+                }
+            }
+        }
+
+        internal void OnDeckFormatChanged(CollectionDeck deck)
+        {
+            if (CollectionManager.Get() .GetEditedDeck() != deck)
+            {
+                return;
+            }
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_FORMAT_CHANGED));
+            SetupEditDeckMenu();
+        }
+
+        private void SetupSavedZilliaxVersions()
+        {
+            GetTraditionalPageManager().m_ZilliaxBlueprintsTab.TriggerRelease();
+            EditDeckAddCards();
+        }
+
+        private void OnCardCountUpdated(int cardCount, int maxCount, bool isSideboard)
+        {
+            if (m_isTransitioning)
+            {
+                return;
+            }
+            if ((m_curState == State.EDIT_DECK_SEE_DECK || m_curState == State.EDIT_DECK_SEE_COLLECTION) && (!CollectionDeckTray.Get().IsSideboardOpen || isSideboard))
+            {
+                int deckSize = GetDeckSize();
+
+                if (CollectionDeckTray.Get().IsZilliaxSideboardOpen())
+                {
+                    // This is needed because we only want to count functional modules for Zilliax.
+                    var sideboardDeck = CollectionManager.Get().GetEditedDeck().GetCurrentSideboardDeck() as ZilliaxSideboardDeck;
+                    cardCount = sideboardDeck.GetFunctionalModules().Count;
+                }
+                
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(!isSideboard ? LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK : LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_SIDEBOARD, cardCount, deckSize));
+
+                // Update deck cards if needed
+                if (m_curState == State.EDIT_DECK_SEE_DECK)
+                {
+                    UpdateEditingDeckCardsAfterCardRemoved();
+                }
+            }
+        }
+
+        private void OnDeckCardCountUpdated(int cardCount, int maxCount)
+        {
+            OnCardCountUpdated(cardCount, maxCount, false);
+        }
+
+        private void OnSideboardCardCountUpdated(int cardCount, int maxCount)
+        {
+            OnCardCountUpdated(cardCount, maxCount, true);
+        }
+
+        private int GetDeckSize()
+        {
+            var collectionDeckTray = CollectionDeckTray.Get();
+            if (collectionDeckTray.IsSideboardOpen)
+            {
+                if (collectionDeckTray.IsZilliaxSideboardOpen())
+                {
+                    // Technically 3 cards, however we don't support changing the cosmetic module
+                    return 2;
+                }
+                return (collectionDeckTray.GetCurrentDeckContext() as SideboardDeck).DataModel.MaxCards;
+            }
+            return CollectionManager.Get().GetDeckSize();
+        }
+
+        private void UpdateEditingDeckCardsAfterCardRemoved()
+        {
+            var numCardsBeforeRemovingCard = m_editingDeckCards.Count;
+            var editingDeckCards = BuildAccessibleEditingDeckCards();
+            var numCardsAfterRemovingCard = editingDeckCards.Count;
+
+            AccessibilityUtils.LogDebug($"CM card removed numCardsBeforeRemovingCard={numCardsBeforeRemovingCard} numCardsAfterRemovingCard={numCardsAfterRemovingCard}");
+
+
+            if (editingDeckCards.Count == 0)
+            {
+                SetupEditDeckMenu();
+            }
+            else if (numCardsBeforeRemovingCard != numCardsAfterRemovingCard)
+            {
+                m_editingDeckCards.UpdateItems(editingDeckCards);
+                m_editingDeckCards.StartReading();
+            }
+            else
+            {
+                m_editingDeckCards.GetItemBeingRead().Reset();
+                m_editingDeckCards.StartReading();
+            }
+        }
+
+        private void EditDeckRenameDeck()
+        {
+            var collectionDeckTray = CollectionDeckTray.Get();
+            var decksContent = collectionDeckTray.GetDecksContent();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT));
+
+            decksContent.m_editingTraySection.m_deckBox.SetDeckName("");
+            decksContent.RenameCurrentlyEditingDeck();
+            AccessibilityMgr.AllowTextInput();
+
+            m_curState = State.EDIT_DECK_RENAME_DECK;
+        }
+
+        private void EditDeckCopyDeck()
+        {
+            CollectionInputMgr.Get().CopyEditedDeck();
+        }
+
+        private AccessibleListOfItems<AccessibleEditingDeckCard> m_editingDeckCards;
+
+        private void EditDeckSeeDeck(bool isReread = false)
+        {
+            var editingDeckCards = BuildAccessibleEditingDeckCards();
+            var cachedCardIdx = m_editingDeckCards?.GetItemBeingReadIndex();
+
+            if (editingDeckCards.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(!CollectionDeckTray.Get().IsSideboardOpen ? LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_DECK : LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_SIDEBOARD));
+            }
+            else
+            {
+                AccessibleInputMgr.HideMouse();
+
+                if (!isReread)
+                {
+                    int cardCount = CountCards(editingDeckCards);
+                    int deckSize = GetDeckSize();
+                    AccessibilityMgr.Output(this, LocalizationUtils.Format(!CollectionDeckTray.Get().IsSideboardOpen ? LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK : LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_SIDEBOARD, cardCount, deckSize));
+                }
+
+                m_editingDeckCards = new AccessibleListOfItems<AccessibleEditingDeckCard>(this, BuildAccessibleEditingDeckCards());
+                if (isReread)
+                {
+                    m_editingDeckCards.StartReadingFromIndex(cachedCardIdx ?? 0);
+                }
+                else
+                {
+                    m_editingDeckCards.StartReading();
+                }
+                m_curState = State.EDIT_DECK_SEE_DECK;
+            }
+        }
+
+        private int CountCards(List<AccessibleEditingDeckCard> editingDeckCards)
+        {
+            int ret = 0;
+
+            foreach (var card in editingDeckCards)
+            {
+                ret += card.GetCardTile().GetSlot()?.Count ?? 0;
+            }
+
+            return ret;
+        }
+
+        private List<AccessibleEditingDeckCard> BuildAccessibleEditingDeckCards()
+        {
+            var editingDeckCards = new List<AccessibleEditingDeckCard>();
+
+            foreach (var cardTile in GetCardTilesInUse())
+            {
+                editingDeckCards.Add(new AccessibleEditingDeckCard(this, cardTile));
+            }
+
+            return editingDeckCards;
+        }
+
+        private List<DeckTrayDeckTileVisual> GetCardTilesInUse()
+        {
+            var ret = new List<DeckTrayDeckTileVisual>();
+
+            CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
+            var cardTiles = collectionDeckTray.GetCurrentCardListContext().GetCardTiles();
+
+            foreach (var cardTile in cardTiles)
+            {
+                if (cardTile.IsInUse())
+                {
+                    ret.Add(cardTile);
+                }
+            }
+
+            return ret;
+        }
+
+
+
+        private void EditDeckAddCards()
+        {
+            if (ShouldAnnounceClass())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+                AccessibilityMgr.Output(this, GameStrings.GetClassName(m_curClassContext ?? TAG_CLASS.NEUTRAL));
+            }
+            m_curPageCollectibles.StartReading();
+            m_curState = State.EDIT_DECK_SEE_COLLECTION;
+        }
+
+        private void EditDeckDone()
+        {
+            CollectionDeckTray.Get().m_doneButton.TriggerRelease();
+        }
+
+        private void EditDeck(CollectionDeckBoxVisual deckBox)
+        {
+            PrepareToEditDeck();
+            AccessibleInputMgr.Click(deckBox.transform);
+        }
+
+        internal void PrepareToEditDeck()
+        {
+            m_willEditDeck = true;
+        }
+
+        internal void OnStartEditingDeck(bool isNew = false)
+        {
+            m_willEditDeck = false;
+            if (isNew)
+            {
+                return; // Handled elsewhere.
+            }
+            if (m_curMode == Mode.EMBEDDED)
+            {
+                AccessibilityMgr.ShowUI(this);
+            }
+            SetupEditDeckMenu();
+        }
+
+        internal void OnDoneEditingDeck()
+        {
+            if (m_curState != State.EDIT_DECK_MENU && m_curState != State.EDIT_DECK_SEE_COLLECTION && m_curState != State.EDIT_DECK_SEE_DECK)
+            {
+                return;
+            }
+            m_willEditDeck = false;
+            if (m_curMode == Mode.EMBEDDED)
+            {
+                AccessibilityMgr.HideUI(this);
+            }
+            else
+            {
+                ReadMainMenu();
+            }
+        }
+
+        private void OnNewDeck()
+        {
+            GetNewDeckButton().TriggerRelease();
+        }
+
+        private bool CanCreateDecks()
+        {
+            var newDeckButton = GetNewDeckButton();
+
+            return newDeckButton != null && newDeckButton.IsEnabled() && newDeckButton.IsUsable();
+        }
+
+        private bool CanDeleteDecks()
+        {
+            return HasDecks(); // TODO
+        }
+
+        private CollectionDeckTrayButton GetNewDeckButton()
+        {
+            return CollectionDeckTray.Get()?.GetDecksContent()?.m_newDeckButton;
+        }
+
+        private bool HasDecks()
+        {
+            return GetVisibleTraySections().Count > 0;
+        }
+
+        internal void OnEditDeckScreen()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            // Just wait if we're creating from clipboard as it'll switch back once the cards fill
+            if (m_curState != State.CREATE_DECK_FROM_CLIPBOARD)
+            {
+                if (m_curMode == Mode.TRADITIONAL)
+                {
+                    AccessibilityMgr.SetScreen(this);
+                }
+                else if (m_curMode == Mode.EMBEDDED)
+                {
+                    AccessibilityMgr.ShowUI(this);
+                }
+
+                SetupEditDeckMenu();
+            }
+        }
+
+        private void OpenSideboard()
+        {
+            var curCard = m_editingDeckCards?.GetItemBeingRead()?.GetCardTile();
+            if (curCard?.GetActor().GetEntityDef().HasSideboard ?? false)
+            {
+                m_isTransitioning = true;
+                CollectionDeckTray.Get().OnDeckTileSideboardButtonPressed(curCard.GetActor());
+            }
+        }
+
+        private void CloseSideboard()
+        {
+            var DeckTray = CollectionDeckTray.Get();
+            if (DeckTray.IsSideboardOpen)
+            {
+                m_isTransitioning = true;
+                DeckTray.OnSideboardDoneButtonPressed();
+            }
+        }
+
+        internal void OnSideboardOpenedOrClosed(bool isOpen)
+        {
+            SetupEditDeckMenu();
+            m_isTransitioning = false;
+        }
+
+
+        private void SetupCraftingMenu(bool forceHideMassDisenchantButton = false)
+        {
+            AccessibleInputMgr.HideMouse();
+
+            var collectionDeckTray = CollectionDeckTray.Get();
+
+            m_craftingMenu = new AccessibleMenu(this, "", ClickCraftingButton);
+
+            if (!forceHideMassDisenchantButton)
+            {
+                var massDisenchantButton = CraftingTray.Get().m_massDisenchantButton;
+
+                if (CanMassDisenchant(massDisenchantButton))
+                {
+                    m_craftingMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_CRAFTING_DISENCHANT_BUTTON_TEXT"), massDisenchantButton.TriggerRelease);
+                }
+            }
+            m_craftingMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARDS), CraftingBrowseCards);
+            m_craftingMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_DUST), ReadArcaneDust);
+
+            AddChangeSetButton(m_craftingMenu);
+
+            ReadCraftingMenu();
+        }
+
+        private void ReadCraftingMenu()
+        {
+            m_craftingMenu.StartReading();
+            m_curState = State.CRAFTING_MENU;
+        }
+
+        private void CraftingBrowseCards()
+        {
+            FlipToFirstClassTab();
+            OutputFilter();
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, m_curPageNum));
+            AccessibilityMgr.Output(this, GameStrings.GetClassName(m_curClassContext ?? TAG_CLASS.NEUTRAL));
+            m_curPageCollectibles.StartReading();
+            m_curState = State.CRAFTING_SEE_COLLECTION;
+        }
+
+        private void AddChangeSetButton(AccessibleMenu menu)
+        {
+            if (CollectionManagerDisplay.ShouldSeeFilterButton())
+            {
+                menu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CHANGE_SET), GetCollectibleDisplay().m_setFilterTray.m_toggleButton.TriggerPress);
+            }
+        }
+
+        private void OutputFilter()
+        {
+            var filterTray = GetCollectibleDisplay().m_setFilterTray;
+
+            //if (filterTray?.HasActiveFilter() ?? false)
+            if (filterTray?.m_selected != null)
+            {
+                AccessibilityMgr.Output(this, filterTray.m_selected.Text);
+            }
+        }
+
+        private void ReadArcaneDust()
+        {
+            var arcaneDust = NetCache.Get().GetArcaneDustBalance();
+            AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_ARCANE_DUST, arcaneDust));
+        }
+
+        private void ClickCraftingButton()
+        {
+            GetCollectibleDisplay().m_craftingModeButton.TriggerRelease();
+        }
+
+        internal void OnCraftingTrayOpened()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            SetupCraftingMenu();
+        }
+
+        internal void OnCraftingTrayClosed()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            RereadMainMenu();
+        }
+
+        internal void OnEnterCraftMode(EntityDef cardBeingRead, TAG_PREMIUM cardBeingReadPremium, CardInfoPane cardInfoPane, CraftingUI craftingUI)
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            m_cardBeingRead = cardBeingRead;
+            m_cardBeingReadPremium = cardBeingReadPremium;
+            m_cardInfoPane = cardInfoPane;
+            m_craftingUI = craftingUI;
+            PushState();
+
+            m_viewCardMenu = new AccessibleMenu(this, "", CancelCraftMode);
+
+            m_viewCardMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_CARD), ReadCard);
+
+            var relatedCardIds = CraftingManager.Get().GetRelatedCardIds(m_cardBeingRead, out bool unused);
+
+            if (relatedCardIds.Count > 0)
+            {
+                m_viewCardMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_RELATED_CARDS), () => ReadRelatedCards(relatedCardIds));
+            }
+
+            m_viewCardMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR), ReadCardFlavor);
+            m_viewCardMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_CRAFTING_MODE_SHORT"), ViewCardCraftingMenu);
+
+            ReadViewCard();
+        }
+
+        private void PushState()
+        {
+            AccessibilityUtils.LogDebug($"PushState - {m_curState}");
+            m_stateBeforeViewCard = m_curState;
+        }
+
+        private void PopState()
+        {
+            AccessibilityUtils.LogDebug($"PopState - cur: {m_curState} ; prev: {m_stateBeforeViewCard}");
+            m_curState = m_stateBeforeViewCard;
+        }
+
+        private void CancelCraftMode()
+        {
+            Navigation.GoBack();
+        }
+
+        private void ReadRelatedCards(List<string> cardIds)
+        {
+            var accessibleRelatedCards = new List<AccessibleMultilineText>();
+            foreach (var relatedCardId in cardIds)
+            {
+                var entityDef = DefLoader.Get().GetEntityDef(relatedCardId);
+
+                var lines = AccessibleCardUtils.GetLinesForNormalEntityDef(entityDef, m_cardBeingReadPremium);
+                var card = new AccessibleMultilineText(this, lines);
+                accessibleRelatedCards.Add(card);
+            }
+
+            m_relatedCards = new AccessibleListOfItems<AccessibleMultilineText>(this, accessibleRelatedCards);
+            m_relatedCards.StartReading();
+            m_curState = State.VIEW_CARD_VIEW_RELATED_CARDS;
+        }
+
+        private void ReadCard()
+        {
+            var collectibleCard = CollectionManager.Get().GetCard(m_cardBeingRead.GetCardId(), m_cardBeingReadPremium);
+            m_accessibleCardBeingRead = new AccessibleCollectibleCard(this, collectibleCard);
+
+            m_accessibleCardBeingRead.ReadLine();
+            m_curState = State.VIEW_CARD_READ_CARD;
+        }
+
+        private void HandleViewCardReadCard()
+        {
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                ReadViewCard();
+            }
+            else
+            {
+                m_accessibleCardBeingRead.HandleAccessibleInput();
+            }
+        }
+
+        private void HandleViewCardViewRelatedCards()
+        {
+            if (AccessibleKey.BACK.IsPressed())
+            {
+                ReadViewCard();
+            }
+            else
+            {
+                m_relatedCards.HandleAccessibleInput();
+            }
+        }
+
+        private void ReadCardFlavor()
+        {
+            AccessibilityMgr.Output(this, m_cardInfoPane.m_flavorText.Text);
+        }
+
+        private void ReadViewCard()
+        {
+            m_viewCardMenu.StartReading();
+            m_curState = State.VIEW_CARD;
+        }
+
+        private void ViewCardCraftingMenu()
+        {
+            if (m_craftingUI.m_soulboundNotification.activeSelf)
+            {
+                AccessibilityMgr.Output(this, m_craftingUI.m_soulboundTitle.Text);
+                AccessibilityMgr.Output(this, m_craftingUI.m_soulboundDesc.Text);
+                return;
+            }
+
+            m_viewCardCraftingMenu = new AccessibleMenu(this, "", ReadViewCard);
+
+            var disenchantText = LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_CARD_FOR_N_DUST, m_craftingUI.m_disenchantDustGain);
+            if (m_craftingUI.m_numOwnedIncludePending > 0)
+            {
+                m_viewCardCraftingMenu.AddOption(disenchantText, ClickDisenchantCard);
+            }
+
+            var craftText = LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_FOR_N_DUST, m_craftingUI.m_craftCost);
+            m_viewCardCraftingMenu.AddOption(craftText, ClickCraftCard);
+
+            m_viewCardCraftingMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_DUST), ReadArcaneDust);
+
+            m_viewCardCraftingMenu.StartReading();
+            m_curState = State.VIEW_CARD_CRAFTING;
+        }
+
+        private void ClickCraftCard()
+        {
+            if (m_craftingUI?.m_reachedCardLimit ?? false)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_CARD_LIMIT_REACHED));
+            }
+            else if (m_craftingUI?.m_craftCost > NetCache.Get().GetArcaneDustBalance())
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_NOT_ENOUGH_DUST));
+            }
+            //Looks like this is no longer trustworthy in 25.4, so moved it to the bottom.
+            else if (m_craftingUI?.m_buttonCreate?.IsButtonEnabled() ?? false)
+            {
+                m_craftingUI.m_buttonCreate.TriggerRelease();
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_CANNOT_DO_THAT));
+            }
+        }
+
+        private void ClickDisenchantCard()
+        {
+            if (m_craftingUI?.m_buttonDisenchant?.IsButtonEnabled() ?? false)
+            {
+                m_craftingUI.m_buttonDisenchant.TriggerRelease();
+            }
+            else
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_CANNOT_DO_THAT));
+            }
+        }
+
+        internal void OnCancelCraftMode(CardInfoPane cardInfoPane, CraftingUI craftingUI)
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            m_cardInfoPane = null;
+            m_craftingUI = null;
+
+            CraftingRereadIfPossible();
+        }
+
+        internal void OnCreateAnimStarted()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            m_curState = State.LOADING;
+        }
+
+        internal void OnCreateAnimDone()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            CommitCrafting();
+        }
+
+        internal void OnDisenchantAnimStarted()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            m_curState = State.LOADING;
+        }
+
+        internal void OnDisenchantAnimDone()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            CommitCrafting();
+        }
+
+        private void CommitCrafting()
+        {
+            WaitingForServerResponse();
+            CancelCraftMode();
+        }
+
+        internal void OnMassDisenchantAnimStarted()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"OnMassDisenchantAnimStarted() m_curState={m_curState}");
+            m_curState = State.LOADING;
+        }
+
+        internal void OnMassDisenchantAnimDone()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"OnMassDisenchantAnimDone() m_curState={m_curState}");
+            CraftingTray.Get().m_massDisenchantButton.TriggerRelease();
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_DONE));
+
+            SetupCraftingMenu(true);
+        }
+
+        internal void OnCardCreated()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_DONE));
+
+            if (m_stateBeforeViewCard == State.EDIT_DECK_SEE_DECK)
+            {
+                OnServerResponse();
+            }
+
+            // The reread is handled by the normal flow as the server response triggers it
+            PopState();
+        }
+
+        internal void OnCardDisenchanted()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"OnCardDisenchanted");
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_DONE));
+
+            if (m_stateBeforeViewCard == State.EDIT_DECK_SEE_DECK)
+            {
+                OnServerResponse();
+            }
+
+            // The reread is handled by the normal flow as the server response triggers it
+            PopState();
+        }
+
+        private void CraftingRereadIfPossible()
+        {
+            AccessibilityUtils.LogDebug($"CraftingRereadIfPossible: IsWaitingForServerResponse: {IsWaitingForServerResponse()} ; m_curState: {m_curState} ; m_stateBeforeViewCard: {m_stateBeforeViewCard}");
+            if (IsWaitingForServerResponse())
+            {
+                return;
+            }
+
+            if (m_stateBeforeViewCard == State.BROWSING_CARDS)
+            {
+                m_curPageCollectibles.StartReading();
+                m_curState = State.BROWSING_CARDS;
+            }
+            else if (m_stateBeforeViewCard == State.CRAFTING_SEE_COLLECTION)
+            {
+                m_curPageCollectibles.StartReading();
+                m_curState = State.CRAFTING_SEE_COLLECTION;
+            }
+            else if (m_stateBeforeViewCard == State.EDIT_DECK_SEE_DECK)
+            {
+                EditDeckSeeDeck(isReread: true);
+            }
+            else
+            {
+                AccessibilityUtils.LogFatalError($"CraftingRereadIfPossible - reached unexpected state: {m_stateBeforeViewCard}");
+            }
+        }
+
+        #endregion
+
+        public void OnGainedFocus()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.BACON)
+            {
+                return;
+            }
+
+            if (m_curState == State.MAIN_MENU)
+            {
+                if (s_justOutOfSetFilterTray)
+                {
+                    s_justOutOfSetFilterTray = false;
+                    RereadMainMenu();
+                }
+                else
+                {
+                    ReadMainMenu();
+                }
+            }
+            else if (m_curState == State.BROWSING_DECKS_FOR_DELETING)
+            {
+                if (!CollectionManager.Get().IsDeleteDeckPending())
+                {
+                    m_deleteDecksMenu?.StartReading();
+                }
+            }
+            else if (m_curState == State.CRAFTING_MENU)
+            {
+                m_craftingMenu?.StartReading();
+            }
+            else if (m_curState == State.BROWSING_CARDS || m_curState == State.CRAFTING_SEE_COLLECTION || m_curState == State.BROWSING_HERO_SKINS || m_curState == State.BROWSING_COINS || m_curState == State.BATTLEGROUNDS_BROWSING_FINISHERS || m_curState == State.BATTLEGROUNDS_BROWSING_GUIDE_SKINS || m_curState == State.BATTLEGROUNDS_BROWSING_HERO_SKINS)
+            {
+                RereadIfPossible(m_curPageCollectibles);
+            }
+            else if (m_curState == State.BROWSING_CARD_BACKS)
+            {
+                RereadIfPossible(m_curPageCardBacks);
+            }
+            else if (m_justCanceledDisenchantPopup)
+            {
+                m_justCanceledDisenchantPopup = false;
+                m_viewCardCraftingMenu.StartReading();
+            }
+        }
+
+        private void RereadIfPossible<T>(AccessibleListOfItems<T> items) where T : AccessibleItem
+        {
+            if (!IsWaitingForServerResponse())
+            {
+                items.StartReading();
+            }
+        }
+
+        private void RereadAfterServerResponse<T>(AccessibleListOfItems<T> items) where T : AccessibleItem
+        {
+            OnServerResponse();
+            RereadIfPossible(items);
+        }
+
+        #region Help
+
+        public string GetHelp()
+        {
+            switch (m_curState)
+            {
+                case State.MAIN_MENU:
+                    return m_mainMenu?.GetHelp();
+                case State.BROWSE_COLLECTION_MENU:
+                    return m_browseCollectionMenu?.GetHelp();
+                case State.BROWSING_CARDS:
+                    return GetHelpForBrowsingCollection();
+                case State.BROWSING_COINS:
+                    return GetHelpForBrowsingCoins();
+                case State.BROWSING_CARD_BACKS:
+                    return GetHelpForBrowsingCardBacks();
+                case State.BROWSING_HERO_SKINS:
+                    return GetHelpForBrowsingHeroSkins();
+                case State.BROWSING_HERO_SKIN_CLASSES:
+                    return GetHelpForBrowsingHeroSkins();
+                case State.MANAGE_DECKS_MENU:
+                    return m_manageDecksMenu?.GetHelp();
+                case State.BROWSING_DECKS_FOR_EDITING:
+                    return m_editDecksMenu?.GetHelp();
+                case State.BROWSING_DECKS_FOR_DELETING:
+                    return m_deleteDecksMenu?.GetHelp();
+                case State.EDIT_DECK_MENU:
+                    return m_editDeckMenu?.GetHelp();
+                case State.EDIT_DECK_SEE_COLLECTION:
+                    return GetHelpForEditDeckSeeCollection();
+                case State.EDIT_DECK_SEE_DECK:
+                    return GetHelpForEditDeckSeeDeck();
+                case State.EDIT_DECK_RENAME_DECK:
+                    return GetHelpForEditDeckRenameDeck();
+                case State.CRAFTING_MENU:
+                    return m_craftingMenu?.GetHelp();
+                case State.CRAFTING_SEE_COLLECTION:
+                    return GetHelpForCraftingSeeCollection();
+                case State.VIEW_CARD:
+                    return m_viewCardMenu?.GetHelp();
+                case State.VIEW_CARD_READ_CARD:
+                    return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+                    case State.VIEW_CARD_VIEW_RELATED_CARDS:
+                    return m_relatedCards?.GetHelp(true);
+                case State.VIEW_CARD_CRAFTING:
+                    return m_viewCardCraftingMenu?.GetHelp();
+                case State.BATTLEGROUNDS_MAIN_MENU:
+                    return m_BattlegroundsMainMenu?.GetHelp();
+                case State.BATTLEGROUNDS_BROWSING_FINISHERS:
+                case State.BATTLEGROUNDS_BROWSING_GUIDE_SKINS:
+                    return m_curPageCollectibles?.GetHelp(true);
+                case State.BATTLEGROUNDS_BROWSING_HERO_SKINS:
+                    return GetHelpForBrowsingBattlegroundsHeroSkins();
+            }
+
+            return "";
+        }
+
+        internal void OnFinishingDeckAutoFill()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            m_curState = State.LOADING;
+        }
+
+        private string GetHelpForBrowsingCollection()
+        {
+            return AccessibleSpeechUtils.CombineLines(GetHelpLinesForBrowsingCollection());
+        }
+
+        private List<string> GetHelpLinesForBrowsingCollection()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_COLLECTION_HELP, AccessibleKey.READ_NEXT_VALID_ITEM));
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_COLLECTION_FILTERS_HELP, AccessibleKey.GLOBAL_FIND));
+
+            return ret;
+        }
+
+        private string GetHelpForBrowsingCoins()
+        {
+            return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_COINS_HELP, AccessibleKey.CONFIRM);
+        }
+
+        private string GetHelpForBrowsingCardBacks()
+        {
+            return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_CARD_BACKS_HELP, AccessibleKey.CONFIRM);
+        }
+
+        private string GetHelpForBrowsingHeroSkins()
+        {
+            return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_HERO_SKINS_HELP, AccessibleKey.CONFIRM);
+        }
+
+                private string GetHelpForBrowsingBattlegroundsHeroSkins()
+        {
+            return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_READ_BATTLEGROUNDS_HERO_SKINS_HELP, AccessibleKey.CONFIRM);
+        }
+
+        internal void OnDeleteDeckCanceled()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            m_deleteDecksMenu?.StartReading();
+        }
+
+        private string GetHelpForEditDeckSeeDeck()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP));
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP, AccessibleKey.CONFIRM));
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CRAFT_CARD_HELP, AccessibleKey.EDIT_DECK_ENTER_CRAFTING_MODE));
+
+            return AccessibleSpeechUtils.CombineLines(ret);
+        }
+
+        private string GetHelpForEditDeckSeeCollection()
+        {
+            var ret = GetHelpLinesForBrowsingCollection();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_ADD_CARD_HELP, AccessibleKey.CONFIRM));
+
+            return AccessibleSpeechUtils.CombineLines(ret);
+        }
+
+        private string GetHelpForEditDeckRenameDeck()
+        {
+            return LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT);
+        }
+
+        private string GetHelpForCraftingSeeCollection()
+        {
+            var ret = GetHelpLinesForBrowsingCollection();
+
+            return AccessibleSpeechUtils.CombineLines(ret);
+        }
+
+        #endregion
+
+        internal void OnCreateDeckFromClipboard()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            m_curState = State.CREATE_DECK_FROM_CLIPBOARD;
+        }
+
+        internal void OnFinishAutoAddCardsWithTiming()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            if (m_curState == State.CREATE_DECK_FROM_CLIPBOARD)
+            {
+                if (m_curMode == Mode.TRADITIONAL)
+                {
+                    AccessibilityMgr.SetScreen(this);
+                }
+                SetupEditDeckMenu();
+            }
+        }
+
+        internal bool IsCreatingDeckFromClipboard()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.EMBEDDED)
+            {
+                return false;
+            }
+
+            return m_curState == State.CREATE_DECK_FROM_CLIPBOARD;
+        }
+
+        #region Favorites
+
+        internal void OnFavoriteHeroSkinChanged()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.BACON)
+            {
+                return;
+            }
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_FAVORITE_HERO_SKIN_SET));
+            RereadAfterServerResponse(m_curPageCollectibles);
+        }
+
+        internal void OnFavoriteBattlegroundsGuideSkinChanged()
+        {
+            if (m_curMode != Mode.BACON)
+            {
+                return;
+            }
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_FAVORITE_BATTLEGROUNDS_GUIDE_SKIN_SET));
+            RereadAfterServerResponse(m_curPageCollectibles);
+        }
+
+        internal void OnFavoriteBattlegroundsFinisherChanged()
+        {
+            if (m_curMode != Mode.BACON)
+            {
+                return;
+            }
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_FAVORITE_BATTLEGROUNDS_FINISHER_SET));
+            RereadAfterServerResponse(m_curPageCollectibles);
+        }
+
+        internal void OnFavoriteCardBackChanged(bool isFavorite)
+        {
+            if (m_curMode != Mode.TRADITIONAL || !isFavorite) // Signal on favorite=true only
+            {
+                return;
+            }
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_FAVORITE_CARD_BACK_SET));
+            RereadAfterServerResponse(m_curPageCardBacks);
+        }
+
+        internal void OnFavoriteCoinChanged()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_FAVORITE_COIN_SET));
+            RereadAfterServerResponse(m_curPageCollectibles);
+        }
+
+        #endregion
+
+        internal void WaitingForServerResponse()
+        {
+            if (m_curMode != Mode.TRADITIONAL && m_curMode != Mode.BACON && m_curMode != Mode.EMBEDDED)
+            {
+                return;
+            }
+
+            AccessibilityUtils.LogDebug("WaitingForServerResponse()");
+            m_waitingForServerResponse = true;
+        }
+
+        private void OnServerResponse()
+        {
+            AccessibilityUtils.LogDebug("OnServerResponse()");
+            m_waitingForServerResponse = false;
+        }
+
+        private bool IsWaitingForServerResponse()
+        {
+            AccessibilityUtils.LogDebug($"IsWaitingForServerResponse() -> {m_waitingForServerResponse}");
+            return m_waitingForServerResponse;
+        }
+
+        internal void OnBrowsingHeroSkinClasses()
+        {
+            if (m_curMode != Mode.TRADITIONAL)
+            {
+                return;
+            }
+
+            var collectionPageDisplay = GetTraditionalPageManager().GetCollectionPageDisplay();
+            var heroPickerButtons = collectionPageDisplay.GetCollectionHeroPickerButtons();
+
+            var accessibleHeroPickerButtons = new List<AccessibleCollectionHeroPickerButton>();
+            foreach (var btn in heroPickerButtons.m_heroButtons)
+            {
+                accessibleHeroPickerButtons.Add(new AccessibleCollectionHeroPickerButton(this, btn));
+            }
+            m_heroPickerClassButtons = new AccessibleListOfItems<AccessibleCollectionHeroPickerButton>(this, accessibleHeroPickerButtons);
+            m_heroPickerClassButtons.StartReading();
+
+            m_curState = State.BROWSING_HERO_SKIN_CLASSES;
+        }
+
+        public void HandleAccessibleInput()
+        {
+            HandleInput();
+        }
+
+        public string GetAccessibleHelp()
+        {
+            return GetHelp();
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/CollectionManager/AccessibleDeckTemplatePickerButton.cs b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleDeckTemplatePickerButton.cs
new file mode 100644
index 0000000..8116cec
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleDeckTemplatePickerButton.cs
@@ -0,0 +1,35 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleDeckTemplatePickerButton : AccessibleItem
+    {
+        private readonly DeckTemplatePickerButton m_button;
+
+        private bool m_isCustomDeck;
+
+        internal AccessibleDeckTemplatePickerButton(AccessibleComponent parent, DeckTemplatePickerButton button, bool isCustomDeck = false) : base(parent)
+        {
+            m_button = button;
+            m_isCustomDeck = isCustomDeck;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            // Template name
+            ret.Add(m_button.m_title.Text);
+
+            if (!m_isCustomDeck)
+            {
+                // Owned cards
+                var ownedCardCount = m_button.GetOwnedCardCount();
+                int deckSize = CollectionManager.Get().GetDeckSize();
+                ret.Add(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_RECIPE_OWNED_CARDS_COUNT, ownedCardCount, deckSize));
+            }
+
+            return ret;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/CollectionManager/AccessibleEditingDeckCard.cs b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleEditingDeckCard.cs
new file mode 100644
index 0000000..94aad52
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleEditingDeckCard.cs
@@ -0,0 +1,86 @@
+﻿using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleEditingDeckCard : AccessibleItem
+    {
+        private AccessibleCollectibleCard m_card;
+
+        private CollectibleCard m_collectibleCard;
+
+        private readonly DeckTrayDeckTileVisual m_cardTile;
+
+        private readonly CollectionDeckSlot m_slot;
+
+        private bool m_includeEligibility;
+
+        public AccessibleEditingDeckCard(AccessibleComponent parent, DeckTrayDeckTileVisual cardTile, bool includeEligibility = true) : base(parent)
+        {
+            m_cardTile = cardTile;
+            m_slot = cardTile.GetSlot();
+            m_includeEligibility = includeEligibility;
+            SetupCard();
+        }
+
+        public AccessibleEditingDeckCard(AccessibleComponent parent, CollectionDeckSlot slot, bool includeEligibility = true) : base(parent)
+        {
+            m_slot = slot;
+            m_includeEligibility = includeEligibility;
+            SetupCard();
+        }
+
+        private void SetupCard()
+        {
+            var cardId = m_slot.CardID;
+            var cardRecord = GameUtils.GetCardRecord(cardId);
+            var cardEntityDef = m_slot.GetEntityDef();
+            var premium = m_cardTile != null ? m_cardTile.GetPremium() : m_slot.PreferredPremium;
+
+            m_collectibleCard = new CollectibleCard(cardRecord, cardEntityDef, premium);
+        }
+
+        internal override List<string> GetLines()
+        {
+            int count = m_slot?.Count ?? 1;
+            m_card = new AccessibleCollectibleCard(m_parent, m_collectibleCard, count);
+            var lines = m_card.GetLines();
+            var eligibility = GetEligibility();
+            if (m_includeEligibility && eligibility != null)
+            {
+                lines.Insert(1, eligibility);
+            }
+            return lines;
+        }
+
+        private string GetEligibility()
+        {
+            if (m_cardTile != null)
+            {
+                var deck = m_cardTile.GetDeck();
+                if (!deck.Runes.CanAddRunes(m_collectibleCard.Runes, 3))
+                {
+                    return LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_INVALID_CARD);
+                }
+                switch (deck.GetSlotStatus(m_cardTile.GetSlot()))
+                {
+                    case CollectionDeck.SlotStatus.MISSING:
+                    return GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_MISSING");
+                    case CollectionDeck.SlotStatus.NOT_VALID:
+                    return LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_INVALID_CARD);
+                    default:
+                    return null;
+                }
+            }
+            else if (!m_slot.Owned)
+            {
+                return GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_MISSING");
+            }
+            return null;
+        }
+
+        public DeckTrayDeckTileVisual GetCardTile()
+        {
+            return m_cardTile;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/CollectionManager/AccessibleFormatTypePickerPopup.cs b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleFormatTypePickerPopup.cs
new file mode 100644
index 0000000..e50c94e
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/CollectionManager/AccessibleFormatTypePickerPopup.cs
@@ -0,0 +1,94 @@
+﻿using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using PegasusShared;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleFormatTypePickerPopup : AccessibleUI
+    {
+        private readonly Widget m_formatTypePickerPopup;
+
+		private AccessibleHorizontalMenu<AccessibleMultilineText> m_formatTypes;
+
+		private static AccessibleFormatTypePickerPopup s_instance;
+
+		public AccessibleFormatTypePickerPopup(Widget formatTypePickerPopup)
+		{
+			m_formatTypePickerPopup = formatTypePickerPopup;
+		}
+
+		internal static void Show(Widget formatTypePickerPopup)
+		{
+			if (s_instance != null)
+			{
+				// Should never happen but might as well protect against potential HS bugs
+				Hide();
+			}
+
+			s_instance = new AccessibleFormatTypePickerPopup(formatTypePickerPopup);
+			AccessibilityMgr.ShowUI(s_instance);
+			s_instance.ReadPopup();
+		}
+
+		internal static void Hide()
+		{
+			AccessibilityMgr.HideUI(s_instance);
+			s_instance = null;
+		}
+
+		private void ReadPopup()
+		{
+			var formatWrapper = AccessibleWidgetUtils.GetChildObject(m_formatTypePickerPopup, "Root/Controller Popup Bone/Controller/Popup/FormatWrapper");
+
+			if (formatWrapper == null)
+			{
+				AccessibilityUtils.LogFatalError("AccessibleFormatTypePickerPopup: Could not find FormatWrapper");
+				return;
+			}
+
+			var TwistFormatButton = AccessibleWidgetUtils.GetPegUIElement(formatWrapper, "TwistFormat");
+			var standardFormatButton = AccessibleWidgetUtils.GetPegUIElement(formatWrapper, "StandardFormat");
+			var wildFormatButton = AccessibleWidgetUtils.GetPegUIElement(formatWrapper, "WildFormat");
+			var casualFormatButton = AccessibleWidgetUtils.GetPegUIElement(formatWrapper, "Casual");
+
+			m_formatTypes = new AccessibleHorizontalMenu<AccessibleMultilineText>(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_FORMAT), null);
+
+			AddFormatTypeIfActive(m_formatTypes, standardFormatButton, GameStrings.GetFormatName(FormatType.FT_STANDARD), "GLUE_TOURNAMENT_DESCRIPTION_STANDARD");
+			AddFormatTypeIfActive(m_formatTypes, wildFormatButton, GameStrings.GetFormatName(FormatType.FT_WILD), "GLUE_TOURNAMENT_DESCRIPTION_WILD");
+			AddFormatTypeIfActive(m_formatTypes, TwistFormatButton, GameStrings.GetFormatName(FormatType.FT_TWIST), "GLUE_TOURNAMENT_DESCRIPTION_TWIST");
+			AddFormatTypeIfActive(m_formatTypes, casualFormatButton, GameStrings.Get("GLUE_TOURNAMENT_CASUAL"), "GLUE_TOURNAMENT_DESCRIPTION_CASUAL");
+
+			if (m_formatTypes.GetNumItems() == 0)
+			{
+				AccessibilityUtils.LogFatalError("AccessibleFormatTypePickerPopup: Attempted to open a picker with no active formats");
+				m_formatTypes = null; // Prevent access
+				return;
+			}
+
+			m_formatTypes.StartReading();
+		}
+
+		private void AddFormatTypeIfActive(AccessibleHorizontalMenu<AccessibleMultilineText> formatTypes, PegUIElement formatButton, string formatName, string formatDescriptionKey)
+		{
+			if (formatButton == null || !formatButton.isActiveAndEnabled)
+			{
+				return;
+			}
+
+			var text = new AccessibleMultilineText(this, formatName, GameStrings.Get(formatDescriptionKey));
+			formatTypes.AddOption(text, () => AccessibleWidgetUtils.ClickButton(formatButton), () => AccessibleInputMgr.MoveMouseTo(formatButton));
+		}
+
+		public string GetAccessibleHelp()
+		{
+			return m_formatTypes?.GetHelp();
+		}
+
+		public void HandleAccessibleInput()
+		{
+			m_formatTypes?.HandleAccessibleInput();
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/Crafting/AccessibleCraftingTestingUtils.cs b/Assembly-CSharp/Accessibility/Crafting/AccessibleCraftingTestingUtils.cs
new file mode 100644
index 0000000..539018d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Crafting/AccessibleCraftingTestingUtils.cs
@@ -0,0 +1,131 @@
+﻿using Assets;
+using Hearthstone.DataModels;
+using Hearthstone.Progression;
+using PegasusUtil;
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace Accessibility
+{
+    class AccessibleCraftingTestingUtils
+    {
+
+		// TODO: figure out what to do with this file (it doesn't function since 26.0).
+		private static Network.CardSaleResult s_cardSaleResult;
+
+		private static int s_totalDisenchantAmount;
+
+		private static string WAITING_FOR_SERVER_RESPONSE_TEST_MESSAGE = "Waiting for server response";
+
+        internal static bool IsTestingCrafting()
+		{
+			return HearthstoneAccessConstants.DEV_MODE; // Used to be a flag but not a good idea given that I kept forgetting about turning it on
+		}
+
+		internal static bool TriggerOnCardSaleResponse(bool error=false)
+		{
+			if (s_cardSaleResult == null)
+			{
+				return false;
+			}
+
+			if (error)
+			{
+				s_cardSaleResult.Action = Network.CardSaleResult.SaleResult.GENERIC_FAILURE;
+			}
+
+			CollectionManager.Get().OnCardSale();
+
+			if (s_cardSaleResult.Action == Network.CardSaleResult.SaleResult.CARD_WAS_BOUGHT)
+			{
+				// CollectionManager.Get().OnCardAdded(s_cardSaleResult.AssetName, s_cardSaleResult.Premium, 1, false); Broke in 26.0. 
+				CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
+					.RefreshCurrentPageContents();
+				CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks();
+			}
+			else if (s_cardSaleResult.Action == Network.CardSaleResult.SaleResult.CARD_WAS_SOLD)
+			{
+				// CollectionManager.Get().OnCardRemoved(s_cardSaleResult.AssetName, s_cardSaleResult.Premium, 1); Broke in 26.0.
+				CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
+					.RefreshCurrentPageContents();
+				CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks();
+			}
+
+			s_cardSaleResult = null;
+			return true;
+		}
+
+		internal static Network.CardSaleResult GetCardSaleResult()
+		{
+			return s_cardSaleResult;
+		}
+
+		internal static Collection AddFakeCards(Collection collection)
+		{
+			var yesterday = DateTime.Today.AddDays(-1).ToFileTimeUtc();
+
+			// Primordial studies x3
+			var fakeStack = new PegasusShared.CardStack();
+			var fakeCardDef = new PegasusShared.CardDef();
+			fakeCardDef.Premium = 0;
+			fakeCardDef.Asset = 59213;
+			fakeStack.CardDef = fakeCardDef;
+			fakeStack.Count = 3;
+			fakeStack.NumSeen = 3;
+			fakeStack.LatestInsertDate = TimeUtils.FileTimeUtcToPegDate(yesterday);
+			collection.Stacks.Add(fakeStack);
+
+			// Lab Partner x2
+			var fakeStack2 = new PegasusShared.CardStack();
+			var fakeCardDef2 = new PegasusShared.CardDef();
+			fakeCardDef2.Premium = 0;
+			fakeCardDef2.Asset = GameUtils.TranslateCardIdToDbId("SCH_310");
+			fakeStack2.CardDef = fakeCardDef2;
+			fakeStack2.Count = 2;
+			fakeStack2.NumSeen = 2;
+			fakeStack2.LatestInsertDate = TimeUtils.FileTimeUtcToPegDate(yesterday);
+			collection.Stacks.Add(fakeStack2);
+
+			return collection;
+		}
+
+		internal static bool TriggerMassDisenchantResponse()
+		{
+			if (s_totalDisenchantAmount == 0)
+			{
+				return false;
+			}
+
+			CollectionManager.Get().OnMassDisenchantResponse();
+
+			s_totalDisenchantAmount = 0;
+			return true;
+		}
+
+		internal static Network.MassDisenchantResponse GetMassDisenchantResponse()
+		{
+			var ret = new Network.MassDisenchantResponse();
+			ret.Amount = s_totalDisenchantAmount;
+
+			return ret;
+		}
+
+		internal static void DoMassDisenchant()
+		{
+			s_totalDisenchantAmount = MassDisenchant.Get().GetTotalAmount();
+		}
+
+		internal static void CraftingTransaction(CraftingPendingTransaction transaction, PegasusShared.CardDef cardDef, int expectedTransactionCost, int normalOwned, int goldenOwned)
+		{
+			s_cardSaleResult = new Network.CardSaleResult();
+			// TODO: Upgrade to golden (from card, from nothing, etc)
+			s_cardSaleResult.Action = expectedTransactionCost > 0 ? Network.CardSaleResult.SaleResult.CARD_WAS_BOUGHT : Network.CardSaleResult.SaleResult.CARD_WAS_SOLD;
+			s_cardSaleResult.AssetID = cardDef.Asset;
+			s_cardSaleResult.AssetName = GameUtils.TranslateDbIdToCardId(cardDef.Asset);
+			// s_cardSaleResult.Amount = transaction.NormalCreateCount + transaction.GoldenCreateCount + transaction.NormalDisenchantCount + transaction.GoldenUpgradeFromNormalCount + transaction.GoldenUpgradeFromNothingCount + transaction.GoldenDisenchantCount;
+			s_cardSaleResult.Premium = transaction.Premium;
+			AccessibilityMgr.OutputNotification(WAITING_FOR_SERVER_RESPONSE_TEST_MESSAGE);
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/EntityComparer.cs b/Assembly-CSharp/Accessibility/EntityComparer.cs
new file mode 100644
index 0000000..9ad24e7
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/EntityComparer.cs
@@ -0,0 +1,38 @@
+﻿using Assets;
+using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static Accessibility.AccessibleSpeechUtils;
+
+namespace Accessibility
+{
+    class EntityComparer : IEqualityComparer<Entity>
+    {
+        public bool Equals(Entity e1, Entity e2)
+        {
+            if (e1 == null || e2 == null)
+            {
+                // None of this should happen but..
+                if (e1 == e2)
+                {
+                    return true; // Keep the hashCode contract
+                }
+
+                return false;
+            }
+
+            return e1.GetEntityId() == e2.GetEntityId();
+        }
+
+        public int GetHashCode(Entity e)
+        {
+            if (e == null)
+            {
+                return 0;
+            }
+
+            return e.GetEntityId().GetHashCode();
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/GlobalAccessibleMenuUtils.cs b/Assembly-CSharp/Accessibility/GlobalAccessibleMenuUtils.cs
new file mode 100644
index 0000000..15674a5
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/GlobalAccessibleMenuUtils.cs
@@ -0,0 +1,28 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    public class GlobalAccessibleMenuUtils
+    {
+        public static bool ReadPrevIsPressed()
+        {
+            return AccessibleKey.READ_PREV_GLOBAL_MENU_OPTION.IsPressed() || AccessibleKey.READ_PREV_GLOBAL_VALID_MENU_OPTION.IsPressed();
+        }
+
+        public static bool ReadNextIsPressed()
+        {
+            return AccessibleKey.READ_NEXT_GLOBAL_MENU_OPTION.IsPressed() || AccessibleKey.READ_NEXT_GLOBAL_VALID_MENU_OPTION.IsPressed();
+        }
+
+        internal static bool ConfirmIsPressed()
+        {
+            return AccessibleKey.GLOBAL_CONFIRM.IsPressed();
+        }
+
+        internal static bool BackIsPressed()
+        {
+            return AccessibleKey.GLOBAL_BACK.IsPressed();
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/HSADevTools.cs b/Assembly-CSharp/Accessibility/HSADevTools.cs
new file mode 100644
index 0000000..9c7d6ed
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/HSADevTools.cs
@@ -0,0 +1,271 @@
+﻿using Blizzard.T5.Configuration;
+using PegasusShared;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Accessibility
+{
+    class HSADevTools
+    {
+        private static int s_curCheat;
+
+        internal static void Init()
+        {
+            // Disable cinematics and other things blind users wouldn't be able to enjoy
+            InitNecessaryOverrides();
+
+            if (!HearthstoneAccessConstants.DEV_MODE)
+            {
+                return;
+            }
+
+            //ResetRotationTutorial();
+
+            //ShowFakeNerfedCards();
+
+            //ShowFakeAddedCards();
+
+            //ShowGoldCapAlert();
+
+            //ShowFakeBreakingNews();
+
+            //ResetLoginPopupSequence();
+
+            //SetNewPlayerFirstTime();
+
+            //SetFirstTimeHub(); // Only applies on the next login actually
+
+            //SetNotReturningPlayer(); // Ran into something weird here and had to fix it -- TODO: Rethink this
+
+            //SetReturningPlayer(); // Done via method -- TODO: Rethink this
+
+            // DumpAchievementsWithCustomVisuals();
+        }
+
+        private static void ResetRotationTutorial()
+        {
+            SetNotReturningPlayer();
+            CheatMgr.Get().ProcessCheat("resetrotationtutorial veteran");
+        }
+
+        private static void ShowFakeBreakingNews()
+        {
+            Vars.Key("Cheats.ShowFakeBreakingNews").Set(true.ToString(), false);
+        }
+
+        private static void ShowFakeAddedCards()
+        {
+            Vars.Key("Cheats.ShowFakeAddedCards").Set(true.ToString(), false);
+        }
+
+        private static void ShowFakeNerfedCards()
+        {
+            Vars.Key("Cheats.ShowFakeNerfedCards").Set(true.ToString(), false);
+        }
+
+        private static void ResetLoginPopupSequence()
+        {
+            GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.PLAYER_OPTIONS, GameSaveKeySubkeyId.LOGIN_POPUP_SEQUENCE_SEEN_POPUPS, new long[0]));
+        }
+
+        private static void InitNecessaryOverrides()
+        {
+            Options.Get().SetBool(Option.HAS_SEEN_NEW_CINEMATIC, true);
+        }
+
+        private static void SetNotReturningPlayer()
+        {
+            //ReturningPlayerMgr.Get().Cheat_SetReturningPlayerProgress((int)ReturningPlayerStatus.RPS_NOT_RETURNING_PLAYER);
+        }
+
+        private static void SetReturningPlayer()
+        {
+            //ReturningPlayerMgr.Get().Cheat_SetReturningPlayerProgress((int)ReturningPlayerStatus.RPS_ACTIVE);
+            // Options.Get().SetInt(Option.RETURNING_PLAYER_BANNER_SEEN, 0); Removed in 24.0.0 but no longer necessary anyways since this entire file is deprecated
+        }
+
+        private static void SetFirstTimeHub()
+        {
+            Options.Get().SetBool(Option.HAS_SEEN_HUB, false);
+            Options.Get().SetBool(Option.HAS_SEEN_PRACTICE_TRAY, false);
+            Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, false);
+            Options.Get().SetBool(Option.HAS_SEEN_THE_COIN, false);
+            Options.Get().SetBool(Option.HAS_SEEN_EXPERT_AI_UNLOCK, false);
+        }
+
+        private static void SetNewPlayerFirstTime()
+        {
+            var profileProgress = ReactiveNetCacheObject<NetCache.NetCacheProfileProgress>.CreateInstance();
+            profileProgress.Value.CampaignProgress = TutorialProgress.NOTHING_COMPLETE;
+        }
+
+        internal static void RunTests()
+        {
+            //ShowFatalError(); // TODO: Figure out where we want to test this given that it forces a close
+
+            RunManualTests();
+        }
+
+        private static void RunManualTests()
+        {
+            var cheats = new string[]{
+                // vvv All of this is automated now. Keeping the list as it might be useful to test new features
+
+                // Testing requires bronze 10 thingy
+                "notice card 2 NEW1_040 true",
+
+                // Daily quests on login
+                "iks",
+
+                // ReconnectHelperDialog
+                "hsashowreconnecthelperdialog false false false",
+                "hsashowreconnecthelperdialog false true false",
+                "hsashowreconnecthelperdialog true false false",
+
+                // Quest toasts
+                "notice gold 327 1 true",
+                "notice arcane_orbs 327 1 true",
+                "notice dust 327 1 true",
+                "notice booster 2 1 true",
+                "notice booster 1 10 true",
+                "notice card 2 NEW1_040 true",
+                "notice cardback 1 1 true",
+                "notice cardback 2 1 true",
+                "hsashowquesttoastmount",
+                "hsashowquesttoastminiset",
+
+                // Welcome quests
+                "hsashowwelcomequests",
+
+                // Returning player banner
+                "hsashowreturningplayerbanner",
+
+                // Show Set Rotation Tutorial Popup
+                "setrotationrotatedboosterspopup",
+
+                // Show Ranked Intro Popup
+                "rankedintropopup",
+
+                // Show login popup sequence - Not used for now as we're blocking it
+                // "loginpopupsequence",
+
+                // Show arena coming soon popup
+                // TODO: CheatMgr has an "arena popup" command for this but we never have prefabs for the next one so
+
+                // Alerts & Warnings
+                "alert",
+                "warning",
+
+                // Other popups
+                "hsashowstandardcomingsoonpopup",
+                "hsashowcoresetavailablepopup",
+                "hsashowwhizbangpopup",
+
+                // Quest progress legacy popup
+                "questprogresspopup QuestTitle QuestDescription 3 10",
+
+                // Quest complete popups
+                //"questcompletepopup 1", // Hero -> this is that empty broken one
+                "questcompletepopup 11", // Card pack
+                "questcompletepopup 12", // Gold
+                "questcompletepopup 55", // Arcane Dust
+                "questcompletepopup 58", // Card
+                "questcompletepopup 59", // Gold Card
+                "questcompletepopup 60", // Rare Card
+                "questcompletepopup 61", // Gold legendary card
+                "questcompletepopup 94", // Free ticket
+                "questcompletepopup 98", // Golden hero unlocked (druid)
+                "questcompletepopup 110", // Mount
+                "questcompletepopup 130", // Two cards
+                "questcompletepopup 215", // Card back
+                "questcompletepopup 2628", // Arcane orbs
+
+                // Season end dialog with reward chests
+                "seasondialog diamond1",
+
+                // Banners
+                "banner",
+
+                // End of game experience
+                "simendofgamexp 7",
+
+                // Quote
+                "quote default",
+
+                // Fixed rewards
+                "fixedrewardcomplete 5794",
+
+                // Legacy rewards
+                //"hsashowleaguepromotionrewards", // Seems broken as it's missing a "done" button at the end when all packages open
+                //"hsashowquestchestreward", // Seems broken as it's missing a "done" button at the end when all packages open
+
+                // Rank rewards
+                "rankreward bronze5 all", // TODO: Not implemented yet
+
+                // Track rewards
+                "showtrackreward 1 1 1", // 1 Card
+                "showtrackreward 1 1 2", // 2 Boosters
+                "showtrackreward 1 1 4", // 1 Random card
+                "showtrackreward 1 1 5", // 1 Custom coin
+                "showtrackreward 1 1 7", // GOLD; DUST; BOOSTER; BOOSTER; TAVERN_TICKET; CARD; RANDOM_CARD; CARD_BACK; HERO_SKIN; CUSTOM_COIN;
+                "showtrackreward 1 1 10", // CARD; REWARD_TRACK_XP_BOOST;
+                "showtrackreward 1 1 15", // Hero skin
+                "showtrackreward 1 1 16", // Gold
+                "showtrackreward 1 1 20", // Card back
+                "showtrackreward 1 1 26", // Tavern ticket
+                "showtrackreward 1 1 68", // 10 Hero skins (Choose one)
+                "showtrackreward 1 1 78", // Arcane orbs
+                "showtrackreward 1 1 162", // Card subset (all from 162 - 205)
+
+                // ReconnectHelperDialog forcing a close
+                "hsashowreconnecthelperdialog true false true",
+
+                ///
+                ///
+                ///
+
+                // TODO: Decide how we're going to handle these which require something to change at login time (e.g. returning player, veteran, etc.)
+                // Used to test track rewards scroll vvv
+                //"hsashowchangedcardspopup", // 5 changed cards
+                //"hsashowaddedcardspopup", // 5 added cards
+
+                // TODO: Test fatal errors?
+            };
+
+            var curCheat = s_curCheat % cheats.Length;
+            var cheat = cheats[curCheat];
+
+            AccessibilityUtils.LogDebug($"Running test cheat: {cheat}");
+            CheatMgr.Get().ProcessCheat(cheat);
+
+            s_curCheat++;
+        }
+
+        private static void ShowFatalError()
+        {
+            /*var fatalErrorMessage = new FatalErrorMessage();
+            FatalErrorMgr.Get().Add(fatalErrorMessage);*/
+            Error.AddFatal(FatalErrorReason.INACTIVITY_TIMEOUT, "GLOBAL_ERROR_INACTIVITY_KICK");
+            var fatalErrorMessage = new FatalErrorMessage();
+            fatalErrorMessage.m_text = "It's been a while since your last Hearthstone action and your connection was shut down. Relaunch the game when you're ready!";
+            fatalErrorMessage.m_reason = FatalErrorReason.INACTIVITY_TIMEOUT;
+
+            SceneMgr.Get().GoToFatalErrorScreen(fatalErrorMessage);
+        }
+
+        private static void DumpAchievementsWithCustomVisuals()
+        {
+            var lines = new List<string>();
+            foreach (var record in GameDbf.Achieve.GetRecords().Where((r) => r.CustomVisualWidget != ""))
+            {
+                lines.Add($"{record.ID}, {record.Name.GetString()}, {record.CustomVisualWidget}");
+            }
+            AccessibilityUtils.LogDebug("Dumping all achievements with a custom reward widget:");
+            AccessibilityUtils.LogDebug(AccessibleSpeechUtils.CombineLines(lines));
+        }
+
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/HSASpeech.cs b/Assembly-CSharp/Accessibility/HSASpeech.cs
new file mode 100644
index 0000000..9473d38
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/HSASpeech.cs
@@ -0,0 +1,88 @@
+﻿using System;
+
+namespace Accessibility
+{
+    public class HSASpeech
+    {
+        public class L10N
+        {
+            // Used for falling back to TTS in languages other than English while we think about this..
+            private LocalizationKey m_localizationKey;
+            private object[] m_args;
+
+            public static L10N Of(LocalizationKey localizationKey, params object[] args)
+            {
+                return new L10N
+                {
+                    m_localizationKey = localizationKey,
+                    m_args = args
+                };
+            }
+
+            public string GetLocalizedText()
+            {
+                if (m_args == null || m_args.Length == 0)
+                {
+                    return LocalizationUtils.Get(m_localizationKey);
+                }
+                else
+                {
+                    return LocalizationUtils.Format(m_localizationKey, m_args);
+                }
+            }
+        }
+
+        public static string FILE_EXTENSION = ".ogg";
+
+        public string Key { get; }
+
+        public string Value { get; }
+
+        public int Hash { get; }
+
+        private L10N m_l10n;
+
+        public HSASpeech(string key, string value, L10N l10n)
+        {
+            Key = key;
+            Value = value;
+            Hash = ComputeHashCode(value);
+            m_l10n = l10n;
+        }
+
+        public HSASpeech(string key, int hash)
+        {
+            Key = key;
+            Hash = hash;
+        }
+
+        public string GetFileName()
+        {
+            return $"{Key}-{Hash}{FILE_EXTENSION}";
+        }
+
+        private int ComputeHashCode(string value)
+        {
+            unchecked
+            {
+                int hash1 = 5381;
+                int hash2 = hash1;
+
+                for (int i = 0; i < value.Length && value[i] != '\0'; i += 2)
+                {
+                    hash1 = ((hash1 << 5) + hash1) ^ value[i];
+                    if (i == value.Length - 1 || value[i + 1] == '\0')
+                        break;
+                    hash2 = ((hash2 << 5) + hash2) ^ value[i + 1];
+                }
+
+                return Math.Abs(hash1 + (hash2 * 1566083941));
+            }
+        }
+
+        public string GetLocalizedText()
+        {
+            return m_l10n.GetLocalizedText();
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs b/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs
new file mode 100644
index 0000000..7cd6137
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/HearthstoneAccessConstants.cs
@@ -0,0 +1,32 @@
+﻿using System.IO;
+
+namespace Accessibility
+{
+    public class HearthstoneAccessConstants
+    {
+        public static string HEARTHSTONE_VERSION = "25.0.0.158725";
+
+        public static string HEARTHSTONE_ACCESS_VERSION = "46";
+
+        public static bool DEV_MODE = false;
+
+        public static bool DEBUG_SOUND = false;
+
+        public static string GetGithubToken()
+        {
+            return DEV_MODE ? File.ReadAllText(Path.Combine(Directory.GetCurrentDirectory(), "dev-github-token.txt")) : null;
+        }
+
+        private static string GetGithubGroupName()
+        {
+            return DEV_MODE ? File.ReadAllText(Path.Combine(Directory.GetCurrentDirectory(), "dev-github-group.txt")) : "HearthstoneAccess";
+        }
+
+        public static string GetHearthstoneAccessRepoUrl()
+        {
+            var githubGroupName = GetGithubGroupName();
+
+            return $"https://raw.githubusercontent.com/{githubGroupName}/HearthstoneAccess";
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/InGameSystemTests.cs b/Assembly-CSharp/Accessibility/InGameSystemTests.cs
new file mode 100644
index 0000000..d12f6e9
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/InGameSystemTests.cs
@@ -0,0 +1,372 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Text;
+using System.Text.RegularExpressions;
+
+namespace Accessibility
+{
+    class InGameSystemTests
+    {
+        internal static void Run()
+        {
+            TestCardEffectInterpreter();
+            TestLocalization();
+            ScanBattlegroundsPermanentEffects();
+        }
+
+        #region Card Effects
+
+        internal static void BuildTestCardEffectInterpreter()
+        {
+            // Build using enUS and just record the IDs so other languages are ok
+            var allCards = GameUtils.GetAllCardIds();
+            AccessibilityUtils.LogDebug($"Building {allCards.Count} cards");
+
+            int okCount = 0;
+            int failCount = 0;
+
+            var friendlyCards = new SortedSet<string>();
+            var unfriendlyCards = new SortedSet<string>();
+
+            foreach (var cardId in allCards)
+            {
+                EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+                var cardTextInHand = entityDef.GetCardTextInHand();
+                var effect = CardEffectInterpreter.ExtractEffect(cardTextInHand);
+
+                if (effect == CardEffectInterpreter.CardEffect.FRIENDLY)
+                {
+                    friendlyCards.Add(cardId);
+                    okCount++;
+                }
+                else if (effect == CardEffectInterpreter.CardEffect.UNFRIENDLY)
+                {
+                    unfriendlyCards.Add(cardId);
+                    okCount++;
+                }
+                else
+                {
+                    failCount++;
+                }
+            }
+
+            AccessibilityUtils.LogDebug("Build ended");
+            AccessibilityUtils.LogDebug($"#OK: {okCount}");
+            AccessibilityUtils.LogDebug($"#FAIL: {failCount}");
+            AccessibilityUtils.LogDebug($"#TOTAL: {okCount + failCount}");
+
+            AccessibilityUtils.LogDebug("friendlyCards:");
+            AccessibilityUtils.LogDebug(GenerateCardsHashSetCode("friendlyCards", friendlyCards));
+            AccessibilityUtils.LogDebug("unfriendlyCards:");
+            AccessibilityUtils.LogDebug(GenerateCardsHashSetCode("unfriendlyCards", unfriendlyCards));
+        }
+
+        private static string GenerateCardsHashSetCode(string variableName, SortedSet<string> cardIds)
+        {
+            var sb = new StringBuilder();
+            sb.Append($"private static HashSet<string> {variableName} = new HashSet<string>() {{");
+
+            int i = 0;
+            foreach (var cardId in cardIds)
+            {
+                if (i > 0)
+                {
+                    sb.Append(",");
+                }
+
+                sb.Append($"\"{cardId}\"");
+
+                i++;
+            }
+            sb.Append("};");
+
+            return sb.ToString();
+        }
+
+        internal static void TestCardEffectInterpreter()
+        {
+            AccessibilityMgr.Output(null, "Testing card effects interpreter");
+
+            var allCards = CollectionManager.Get().GetAllCards(); // TODO: We probably should include hero powers here as well..
+            AccessibilityUtils.LogDebug($"Testing {allCards.Count} cards");
+
+            int okCount = 0;
+            int failCount = 0;
+
+            foreach (var card in allCards)
+            {
+                //if (card.CardType == TAG_CARDTYPE.SPELL || IsBattlecryMinion(card)) // We don't really care about battlecries right now as none of the unhandled ones is really in a grey area
+                if (card.CardType == TAG_CARDTYPE.SPELL || card.CardType == TAG_CARDTYPE.HERO_POWER)
+                {
+                    if (IsEffectHandled(card))
+                    {
+                        okCount++;
+                    }
+                    else
+                    {
+                        failCount++;
+                        AccessibilityUtils.LogDebug($"Failed to handle {card.Name} - {card.CardInHandText}");
+                    }
+                }
+            }
+
+            AccessibilityUtils.LogDebug("Test ended");
+            AccessibilityUtils.LogDebug($"#OK: {okCount}");
+            AccessibilityUtils.LogDebug($"#FAIL: {failCount}");
+            AccessibilityUtils.LogDebug($"#TOTAL: {okCount + failCount}");
+
+            AccessibilityMgr.Output(null, $"OK count: {okCount}");
+            AccessibilityMgr.Output(null, $"Fail count: {failCount}");
+        }
+
+        private static bool IsBattlecryMinion(CollectibleCard card)
+        {
+            if (card.CardType != TAG_CARDTYPE.MINION)
+            {
+                return false;
+            }
+
+            return card.CardInHandText.Contains("<b>Battlecry:</b>");
+        }
+
+        private static bool IsEffectHandled(CollectibleCard card)
+        {
+            return CardEffectInterpreter.GetEffect(card.CardId) != CardEffectInterpreter.CardEffect.UNKNOWN;
+            //return CardEffectInterpreter.GetEffect(card.CardInHandText) != CardEffectInterpreter.CardEffect.UNKNOWN;
+        }
+
+        #endregion
+
+        #region Localization
+
+        // Used to test any localization we get from Blizzard to ensure TTS doesn't break in HS updates
+        internal static void TestLocalization()
+        {
+            AccessibilityMgr.Output(null, "Testing localization");
+            s_failedAssertions = 0;
+
+            AccessibilityUtils.LogDebug($"Testing localization");
+
+            AccessibilityUtils.LogDebug($"Making sure all strings exist");
+            foreach (var key in LocalizationKey.GetAllKeys())
+            {
+                if (!GameStrings.HasKey(key.Key))
+                {
+                    AccessibilityUtils.LogDebug($"Missing key: {key.Key}");
+                }
+            }
+
+            AccessibilityUtils.LogDebug($"Testing Blizzard provided strings");
+
+            AssertEquals("Game Menu", LocalizationUtils.Get(LocalizationKey.MENU_GAME_MENU_TITLE));
+            AssertEquals("Solo Adventures", LocalizationUtils.Get(LocalizationKey.GLOBAL_SOLO_ADVENTURES));
+            AssertEquals("Help", LocalizationUtils.Get(LocalizationKey.GLOBAL_HELP));
+            AssertEquals("Your Turn", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOUR_TURN));
+            AssertEquals("Reconnected", LocalizationUtils.Get(LocalizationKey.GLOBAL_RECONNECTED));
+            AssertEquals("Choose One", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_CHOOSE_ONE));
+            AssertEquals("Starting Hand", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN));
+            AssertEquals("Keep or Replace Cards", LocalizationUtils.Get(LocalizationKey.GAMEPLAY_MULLIGAN_KEEP_OR_REPLACE_CARDS));
+            AssertEquals("Taunt", LocalizationUtils.Get(LocalizationKey.GLOBAL_TAUNT));
+            AssertEquals("Deathrattle", LocalizationUtils.Get(LocalizationKey.GLOBAL_DEATHRATTLE));
+            AssertEquals("Battlecry", LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLECRY));
+            AssertEquals("Charge", LocalizationUtils.Get(LocalizationKey.GLOBAL_CHARGE));
+            AssertEquals("Lifesteal", LocalizationUtils.Get(LocalizationKey.GLOBAL_LIFESTEAL));
+            AssertEquals("Rush", LocalizationUtils.Get(LocalizationKey.GLOBAL_RUSH));
+            AssertEquals("Windfury", LocalizationUtils.Get(LocalizationKey.GLOBAL_WINDFURY));
+            AssertEquals("Divine Shield", LocalizationUtils.Get(LocalizationKey.GLOBAL_DIVINE_SHIELD));
+            AssertEquals("Freeze", LocalizationUtils.Get(LocalizationKey.GLOBAL_FREEZE));
+            AssertEquals("Frozen", LocalizationUtils.Get(LocalizationKey.GLOBAL_FROZEN));
+            AssertEquals("Poisonous", LocalizationUtils.Get(LocalizationKey.GLOBAL_POISONOUS));
+            AssertEquals("Stealth", LocalizationUtils.Get(LocalizationKey.GLOBAL_STEALTH));
+            AssertEquals("Immune", LocalizationUtils.Get(LocalizationKey.GLOBAL_IMMUNE));
+            AssertEquals("Dormant", LocalizationUtils.Get(LocalizationKey.GLOBAL_DORMANT));
+            AssertEquals("Enchantment", LocalizationUtils.Get(LocalizationKey.GLOBAL_ENCHANTMENT));
+            AssertEquals("Silence", LocalizationUtils.Get(LocalizationKey.GLOBAL_SILENCE));
+            AssertEquals("The following sets are now Wild!", LocalizationUtils.Get(LocalizationKey.UI_SET_ROTATION_ROTATED_BOOSTERS_POPUP_TITLE));
+            AssertEquals("Reconnecting", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECTING));
+            AssertEquals("Options", LocalizationUtils.Get(LocalizationKey.GLOBAL_OPTIONS));
+            AssertEquals("Practice", LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION));
+            AssertEquals("Arcane Dust", LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_DUST));
+            AssertEquals("Gold", LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_GOLD));
+            AssertEquals("Arcane Orbs", LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ARCANE_ORBS));
+            AssertEquals("New Class Unlocked!", LocalizationUtils.Get(LocalizationKey.UI_REWARD_NEW_CLASS_UNLOCKED));
+            AssertEquals("You are currently offline", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_OFFLINE));
+            AssertEquals("You must reconnect before you can proceed. However, you can still access your collection offline.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_REQUIRED));
+            AssertEquals("Reconnect Failed", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_FAILED));
+            AssertEquals("Please verify that your device has Internet access enabled and try again.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_NO_INTERNET));
+            AssertEquals("New version available", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER));
+            AssertEquals("You must update before you can proceed.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY));
+            AssertEquals("It's been a while since your last Hearthstone action and your connection was shut down.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_INACTIVE_TIMEOUT));
+            AssertEquals("Unable to reconnect. Please relaunch Hearthstone.", LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RESTART_REQUIRED));
+            AssertEquals("Not yet! You can still attack.", LocalizationUtils.Get(LocalizationKey.TUTORIAL_NO_ENDTURN_ATK));
+            AssertEquals("Not yet! You have more cards to play!", LocalizationUtils.Get(LocalizationKey.TUTORIAL_NO_ENDTURN));
+            AssertEquals("Save that for the enemy!", LocalizationUtils.Get(LocalizationKey.TUTORIAL01_HELP_07));
+            AssertEquals("Ignore the puny gnoll and finish off Hogger.", LocalizationUtils.Get(LocalizationKey.TUTORIAL01_HELP_08));
+            AssertEquals("You gain a Mana Crystal every turn.", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_01));
+            AssertEquals("Your used Mana Crystals refill each turn.", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_03));
+            AssertEquals("Get Millhouse!", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_06));
+            AssertEquals("Expend your Mana each turn to crush this annoying gnome!", LocalizationUtils.Get(LocalizationKey.TUTORIAL02_HELP_07));
+            AssertEquals("'Battlecry' minions do something special when you play them.", LocalizationUtils.Get(LocalizationKey.TUTORIAL06_HELP_03));
+            AssertEquals("Kill enemy minions before they become a problem!", LocalizationUtils.Get(LocalizationKey.TUTORIAL06_HELP_04));
+            AssertEquals("Welcome to the Jungle", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_14));
+            AssertEquals("Kill his minions or he'll overwhelm you!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_15));
+            AssertEquals("Subdue minions with your hero power and spells!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_16));
+            AssertEquals("Sheep it!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_02));
+            AssertEquals("Save that for the Fen Creeper!", LocalizationUtils.Get(LocalizationKey.TUTORIAL04_HELP_03));
+            AssertEquals("This fight is totally not fair. Blame the terrible game designers.", LocalizationUtils.Get(LocalizationKey.TUTORIAL05_HELP_03));
+            AssertEquals("Your Taunt minions can protect you from attacks!", LocalizationUtils.Get(LocalizationKey.TUTORIAL05_HELP_04));
+            AssertEquals("This minion has a power that lasts until he dies.", LocalizationUtils.Get(LocalizationKey.TUTORIAL_RAID_LEADER_DESCRIPTION));
+            AssertEquals("You can have 10 cards in your hand.", LocalizationUtils.Get(LocalizationKey.TUTORIAL_ARCANE_INTELLECT_DESCRIPTION));
+            AssertEquals("Level 42", LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_DECK_HERO_LEVEL, 42));
+            AssertEquals("My Collection", LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION));
+            AssertEquals("My Decks", LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_MY_DECKS));
+            AssertEquals("New Deck", LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_NEW_DECK));
+            AssertEquals("Rename", LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_RENAME_DECK_OPTION));
+            AssertEquals("Page 2", LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM, 2));
+            AssertEquals("235 FREE Cards!", LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_HEADER));
+            AssertEquals("Core set now available!", LocalizationUtils.Get(LocalizationKey.UI_CORE_SET_POPUP_SUBHEADER));
+            AssertEquals("Choose Your Deck", LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE));
+            AssertEquals("Choose Opponent", LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_OPPONENT_MENU_TITLE));
+            AssertEquals("Choose Your Hero", LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CHOOSE_ADVENTURER_TITLE));
+            AssertEquals("Master Volume", LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_MASTER_VOLUME_OPTION));
+            AssertEquals("Music Volume", LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_MUSIC_VOLUME_OPTION));
+            AssertEquals("Fullscreen", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_FULLSCREEN_OPTION));
+            AssertEquals("Sound In Background", LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_SOUND_IN_BACKGROUND_OPTION));
+            AssertEquals("Allow Friends to Spectate my Games", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ALLOW_SPECTATORS_OPTION));
+            AssertEquals("Enable Screen Shake", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ENABLE_SCREEN_SHAKE_OPTION));
+            AssertEquals("Modes", LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_MODES));
+            AssertEquals("Choose a Mode", LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_MODE));
+            AssertEquals("Claim a Free Deck", LocalizationUtils.Get(LocalizationKey.UI_CHOOSE_FREE_DECK_TITLE));
+            AssertEquals("Open Packs", LocalizationUtils.Get(LocalizationKey.GLOBAL_OPEN_PACKS));
+            AssertEquals("NEW!", LocalizationUtils.Get(LocalizationKey.COLLECTION_CARD_NEW));
+            AssertEquals("Enchantment", LocalizationUtils.Get(LocalizationKey.GLOBAL_ENCHANTMENT));
+            AssertEquals("Journal", LocalizationUtils.Get(LocalizationKey.GLOBAL_JOURNAL));
+            AssertEquals("Play Standard", LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_STANDARD));
+            AssertEquals("Play Wild", LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_WILD));
+            AssertEquals("Play Casual", LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_PLAY_CASUAL));
+            AssertEquals("Ready!", LocalizationUtils.Get(LocalizationKey.GLOBAL_READY));
+            AssertEquals("1 Mana Crystal <b>Overloaded</b>.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_OVERLOADED_MANA, 1));
+            AssertEquals("2 Mana Crystals <b>Overloaded</b>.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_OVERLOADED_MANA, 2));
+            AssertEquals("1 Mana Crystal <b>Overloaded</b> last turn.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_LOCKED_MANA, 1));
+            AssertEquals("2 Mana Crystals <b>Overloaded</b> last turn.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_PLAYER_LOCKED_MANA, 2));
+            AssertEquals("1 Mana Crystal <b>Overloaded</b>.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_OVERLOADED_MANA, 1));
+            AssertEquals("2 Mana Crystals <b>Overloaded</b>.", LocalizationUtils.Format(LocalizationKey.GAMEPLAY_READ_OPPONENT_OVERLOADED_MANA, 2));
+            AssertEquals("Standard", LocalizationUtils.Get(LocalizationKey.GLOBAL_STANDARD));
+            AssertEquals("Wild", LocalizationUtils.Get(LocalizationKey.GLOBAL_WILD));
+            AssertEquals("Twist", LocalizationUtils.Get(LocalizationKey.GLOBAL_TWIST));
+            AssertEquals("Golden Tarecgosa", LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_READ_CARD_PREMIUM_GOLDEN, "Tarecgosa"));
+            AssertEquals("RECRUIT PHASE", LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE));
+            AssertEquals("COMBAT PHASE", LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE));
+            AssertEquals("Play", LocalizationUtils.Get(LocalizationKey.GLOBAL_PLAY));
+            AssertEquals("Battlegrounds", LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLEGROUNDS));
+            AssertEquals("1st Place!!!", TB_BaconShop.GetPlaceString(1));
+            AssertEquals("2nd Place!!", TB_BaconShop.GetPlaceString(2));
+            AssertEquals("3rd Place!", TB_BaconShop.GetPlaceString(3));
+            AssertEquals("4th Place!", TB_BaconShop.GetPlaceString(4));
+            AssertEquals("5th Place", TB_BaconShop.GetPlaceString(5));
+            AssertEquals("6th Place", TB_BaconShop.GetPlaceString(6));
+            AssertEquals("7th Place", TB_BaconShop.GetPlaceString(7));
+            AssertEquals("8th Place", TB_BaconShop.GetPlaceString(8));
+            AssertEquals("Triples Created", LocalizationUtils.Get(LocalizationKey.BATTLEGROUNDS_GAMEPLAY_LEADERBOARD_STATS_PLAYER_TRIPLES_CREATED));
+            AssertEquals("As Millhouse Manastorm", GameStrings.Format("GAMEPLAY_BACON_ALTERNATE_PLAYER_NAME", "Millhouse Manastorm"));
+            AssertEquals("Mixed Minions", GameStrings.Get("GLOBAL_RACE_MIXED_BATTLEGROUNDS"));
+            AssertEquals("Frame Rate", LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_FRAME_RATE_OPTION));
+
+            // GameStrings we depend on
+            // Made turns to hold out generic so need to signal if something else shows up
+            AssertEquals("|4(Turn,Turns) to Hold Out", GameStrings.Get("BOH_UTHER_08"));
+            AssertEquals("|4(Turn,Turns) to Hold Out", GameStrings.Get("BOH_GULDAN_01"));
+            AssertEquals("|4(Turn,Turns) to Hold Out", GameStrings.Get("BOH_ILLIDAN_08"));
+            AssertEquals(3, GameStrings.FindKeysWithValue("|4(Turn,Turns) to Hold Out").Count);
+
+            AccessibilityUtils.LogDebug($"Localization test ended");
+
+            if (s_failedAssertions > 0)
+            {
+                AccessibilityMgr.Output(null, $"Failed {s_failedAssertions} assertions");
+            }
+            else
+            {
+                AccessibilityMgr.Output(null, "All tests OK");
+            }
+        }
+
+        private static int s_failedAssertions;
+
+        private static void AssertEquals(string expected, string actual)
+        {
+            if (!expected.Equals(actual))
+            {
+                AccessibilityUtils.LogDebug($"Assertion failed. Expected: {expected} , Actual: {actual}");
+                s_failedAssertions++;
+            }
+        }
+
+        private static void AssertEquals(int expected, int actual)
+        {
+            if (!expected.Equals(actual))
+            {
+                AccessibilityUtils.LogDebug($"Assertion failed. Expected: {expected} , Actual: {actual}");
+                s_failedAssertions++;
+            }
+        }
+
+		#endregion
+
+		#region Battlegrounds
+
+        internal static void ScanBattlegroundsPermanentEffects()
+        {
+            // Build using enUS and just record the IDs so other languages are ok
+            var allCards = GameUtils.GetAllCardIds();
+
+            AccessibilityUtils.LogDebug($"Scanning {allCards.Count} cards");
+
+            var bgCardIds = allCards.FindAll(c => c.StartsWith("BG"));
+
+            AccessibilityUtils.LogDebug($"Found {bgCardIds} BG cards");
+            AccessibilityUtils.LogDebug($"Scanning cards with 'permanently' in their description");
+
+            var permanentlyEffectCards = new HashSet<string>();
+
+            foreach (var cardId in bgCardIds)
+            {
+                EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+                var cardTextInHand = entityDef.GetCardTextInHand();
+
+                if (cardTextInHand.ToLower().Contains("permanently"))
+				{
+                    permanentlyEffectCards.Add(cardId);
+					AccessibilityUtils.LogDebug($"Found card with 'permanently' effect. Card name={entityDef.GetName()} ; Card ID={entityDef.GetCardId()}; Card Description={cardTextInHand}");
+				}
+            }
+
+            AccessibilityUtils.LogDebug("Scanning ended");
+            AccessibilityUtils.LogDebug($"#BG cards: {bgCardIds.Count}");
+
+            var permanentlyEffectCardsText = $"#Permanently effect cards: {permanentlyEffectCards.Count}";
+            AccessibilityUtils.LogDebug(permanentlyEffectCardsText);
+            AccessibilityMgr.Output(null, permanentlyEffectCardsText);
+
+            var ok = BattlegroundsCardEffectInterpreter.AreAllBGCardsAccountedFor(permanentlyEffectCards);
+
+            if (ok)
+			{
+				AccessibilityMgr.Output(null, $"BG permanently effect cards OK");
+			}
+            else
+			{
+				AccessibilityMgr.Output(null, $"BG permanently effect cards FAIL");
+			}
+        }
+
+        // Util for outputting test-only text. Used so our tests don't flag direct usages of AccessibilityMgr.Output as missing translations (this file is ignored)
+		internal static void Output(string text)
+		{
+            AccessibilityMgr.Output(null, text);
+		}
+
+		#endregion
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs b/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs
new file mode 100644
index 0000000..6a622be
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/InaccessibleDialogBase.cs
@@ -0,0 +1,20 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Accessibility
+{
+    public abstract class InaccessibleDialogBase : DialogBase
+    {
+        public override string GetAccessibleHelp()
+        {
+            return LocalizationUtils.Get(LocalizationKey.UI_UNKNOWN_DIALOG);
+        }
+
+        public override void HandleAccessibleInput()
+        {
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Localization/DefaultGameStrings.cs b/Assembly-CSharp/Accessibility/Localization/DefaultGameStrings.cs
new file mode 100644
index 0000000..fb167df
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Localization/DefaultGameStrings.cs
@@ -0,0 +1,500 @@
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using Assets;
+using Blizzard.T5.Core;
+using Blizzard.T5.Jobs;
+using Blizzard.T5.Core.Utils;
+using PegasusShared;
+using UnityEngine;
+using Accessibility;
+
+// Simplified copy of GameStrings.cs without logging and forcing enUS locale
+// Used for defaults for non-localized versions
+// Could do it some other way but might as well use what's already proven and tested
+public class DefaultGameStrings
+{
+    #region Accessibility
+    private static Locale DEFAULT_LOCALE = Locale.enUS;
+	private static CultureInfo DEFAULT_CULTURE_INFO = new CultureInfo("en-US");
+	#endregion
+
+	public const string s_UnknownName = "UNKNOWN";
+
+	private static Map<Global.GameStringCategory, GameStringTable> s_tables = new Map<Global.GameStringCategory, GameStringTable>();
+
+	private static readonly char[] LANGUAGE_RULE_ARG_DELIMITERS = new char[1] { ',' };
+
+	private static List<Global.GameStringCategory> s_nativeGameStringCatetories = new List<Global.GameStringCategory>
+	{
+		Global.GameStringCategory.GLOBAL,
+		Global.GameStringCategory.GLUE
+	};
+
+	public static void LoadAll()
+	{
+		AccessibilityUtils.LogDebug("DefaultGameStrings.LoadAll()");
+		float realtimeSinceStartup = Time.realtimeSinceStartup;
+        LoadCategory(Global.GameStringCategory.ACCESSIBILITY, native: false);
+        float realtimeSinceStartup2 = Time.realtimeSinceStartup;
+	}
+	public static IAsyncJobResult CreateLoadCategoryJob(Global.GameStringCategory category, bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.CreateLoadCategoryJob({category}, {native})");
+
+		return new JobDefinition($"DefaultGameStrings.LoadCategory[{category}]", Job_LoadCategory(category, native));
+	}
+
+	private static IEnumerator<IAsyncJobResult> Job_LoadCategory(Global.GameStringCategory category, bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.Job_LoadCategory({category}, {native})");
+		if (!s_tables.ContainsKey(category))
+		{
+            LoadCategory(category, native);
+		}
+        yield break;
+    }
+
+	private static void ReloadAllInternal(bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.ReloadAllInternal({native})");
+
+		float realtimeSinceStartup = Time.realtimeSinceStartup;
+		foreach (Global.GameStringCategory value in Enum.GetValues(typeof(Global.GameStringCategory)))
+		{
+			if (value != 0 && (!native || s_nativeGameStringCatetories.Contains(value)))
+			{
+				if (s_tables.ContainsKey(value))
+				{
+					UnloadCategory(value);
+				}
+				LoadCategory(value, native);
+			}
+		}
+		float realtimeSinceStartup2 = Time.realtimeSinceStartup;
+		AccessibilityUtils.LogDebug(string.Format("Reloading {0} GameStrings took {1}s)", native ? "Native" : "All", realtimeSinceStartup2 - realtimeSinceStartup));
+	}
+
+	public static void ReloadAll()
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.ReloadAll()");
+
+		ReloadAllInternal(native: false);
+	}
+
+	public static void LoadNative()
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.LoadNative()");
+
+		ReloadAllInternal(native: true);
+	}
+
+    public static bool HasKey(string key)
+	{
+		return Find(key) != null;
+	}
+
+	public static bool TryGet(string key, out string localized)
+	{
+		localized = null;
+		string text = Find(key);
+		if (text == null)
+		{
+			return false;
+		}
+		localized = ParseLanguageRules(text);
+		return true;
+	}
+
+	public static string Get(string key)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.Get({key})");
+
+		if (!TryGet(key, out var localized))
+		{
+			return key;
+		}
+		return localized;
+	}
+
+	public static string Format(string key, params object[] args)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.Format({key})");
+
+		string text = Find(key);
+		if (text == null)
+		{
+			return key;
+		}
+		return FormatLocalizedString(text, args);
+	}
+
+	public static string FormatLocalizedString(string text, params object[] args)
+	{
+		text = string.Format(DEFAULT_CULTURE_INFO, text, args);
+		text = ParseLanguageRules(text);
+		return text;
+	}
+
+	public static string FormatLocalizedStringWithPlurals(string text, GameStrings.PluralNumber[] pluralNumbers, params object[] args)
+	{
+		text = string.Format(DEFAULT_CULTURE_INFO, text, args);
+		text = ParseLanguageRules(text, pluralNumbers);
+		return text;
+	}
+
+	public static string FormatPlurals(string key, GameStrings.PluralNumber[] pluralNumbers, params object[] args)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.FormatPlurals({key})");
+
+		string text = Find(key);
+		if (text == null)
+		{
+			return key;
+		}
+		text = string.Format(DEFAULT_CULTURE_INFO, text, args);
+		return ParseLanguageRules(text, pluralNumbers);
+	}
+
+	public static string FormatStringWithPlurals(List<LocalizedString> protoLocalized, string stringKey, params object[] optionalFormatArgs)
+	{
+		Locale locale = DEFAULT_LOCALE;
+		LocalizedString localizedString = protoLocalized.FirstOrDefault((LocalizedString s) => s.Key == stringKey);
+		LocalizedStringValue localizedStringValue = null;
+		if (localizedString == null)
+		{
+			Debug.LogWarning($"DefaultGameStrings.FormatStringWithPlurals() - localizedStr was null for string key {stringKey}");
+			return null;
+		}
+		localizedStringValue = localizedString.Values.FirstOrDefault((LocalizedStringValue v) => v.Locale == (int)locale);
+		if (localizedStringValue.Value == null)
+		{
+			Debug.LogWarning($"DefaultGameStrings.FormatStringWithPlurals() - localizedVal was null");
+			return null;
+		}
+		return ParseLanguageRules(string.Format(localizedStringValue.Value, optionalFormatArgs));
+	}
+
+	public static string ParseLanguageRules(string str)
+	{
+		str = ParseLanguageRule1(str);
+		str = ParseLanguageRule4(str);
+		return str;
+	}
+
+	public static string ParseLanguageRules(string str, GameStrings.PluralNumber[] pluralNumbers)
+	{
+		str = ParseLanguageRule1(str);
+		str = ParseLanguageRule4(str, pluralNumbers);
+		return str;
+	}
+
+	private static bool LoadCategory(Global.GameStringCategory cat, bool native)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.LoadCategory({cat}, {native})");
+
+		if (s_tables.ContainsKey(cat))
+		{
+			return false;
+		}
+		GameStringTable gameStringTable = new GameStringTable();
+		if (!gameStringTable.Load(cat, DEFAULT_LOCALE, native))
+		{
+			return false;
+		}
+		s_tables.Add(cat, gameStringTable);
+		return true;
+	}
+
+	private static bool UnloadCategory(Global.GameStringCategory cat)
+	{
+		AccessibilityUtils.LogDebug($"DefaultGameStrings.UnloadCategory({cat})");
+
+		if (!s_tables.Remove(cat))
+		{
+			AccessibilityUtils.LogDebug($"GameStrings.UnloadCategory() - {cat} was never loaded");
+			return false;
+		}
+		return true;
+	}
+
+	private static string Find(string key)
+	{
+		if (key == null)
+		{
+			return null;
+		}
+		foreach (GameStringTable value in s_tables.Values)
+		{
+			string text = value.Get(key);
+			if (text != null)
+			{
+				return text;
+			}
+		}
+		if (key.StartsWith("Assets/"))
+		{
+		}
+		return null;
+	}
+
+	private static string[] ParseLanguageRuleArgs(string str, int ruleIndex, out int argStartIndex, out int argEndIndex)
+	{
+		argStartIndex = -1;
+		argEndIndex = -1;
+		argStartIndex = str.IndexOf('(', ruleIndex + 2);
+		if (argStartIndex < 0)
+		{
+			return null;
+		}
+		argEndIndex = str.IndexOf(')', argStartIndex + 1);
+		if (argEndIndex < 0)
+		{
+			return null;
+		}
+		StringBuilder stringBuilder = new StringBuilder();
+		stringBuilder.Append(str, argStartIndex + 1, argEndIndex - argStartIndex - 1);
+		string text = stringBuilder.ToString();
+		MatchCollection matchCollection = Regex.Matches(text, "(?<!\\/)(?:[0-9]+,)*[0-9]+(?!\\/)");
+		if (matchCollection.Count == 0)
+		{
+			matchCollection = Regex.Matches(text, "(?<!\\/)(?:[0-9]+,)*[0-9]+");
+		}
+		if (matchCollection.Count > 0)
+		{
+			stringBuilder.Remove(0, stringBuilder.Length);
+			int num = 0;
+			foreach (Match item in matchCollection)
+			{
+				stringBuilder.Append(text, num, item.Index - num);
+				stringBuilder.Append('0', item.Length);
+				num = item.Index + item.Length;
+			}
+			stringBuilder.Append(text, num, text.Length - num);
+			text = stringBuilder.ToString();
+		}
+		string[] array = text.Split(LANGUAGE_RULE_ARG_DELIMITERS);
+		int num2 = 0;
+		for (int i = 0; i < array.Length; i++)
+		{
+			string text2 = array[i];
+			if (matchCollection.Count > 0)
+			{
+				stringBuilder.Remove(0, stringBuilder.Length);
+				int num3 = 0;
+				foreach (Match item2 in matchCollection)
+				{
+					if (item2.Index >= num2 && item2.Index < num2 + text2.Length)
+					{
+						int num4 = item2.Index - num2;
+						stringBuilder.Append(text2, num3, num4 - num3);
+						stringBuilder.Append(item2.Value);
+						num3 = num4 + item2.Length;
+					}
+				}
+				stringBuilder.Append(text2, num3, text2.Length - num3);
+				text2 = stringBuilder.ToString();
+				num2 += text2.Length + 1;
+			}
+			text2 = (array[i] = text2.Trim());
+		}
+		return array;
+	}
+
+	private static string ParseLanguageRule1(string str)
+	{
+		int num = str.IndexOf("|1");
+		if (num < 0)
+		{
+			return str;
+		}
+		StringBuilder stringBuilder;
+		string text;
+		int num3;
+		string[] array;
+		int num4;
+		for (stringBuilder = new StringBuilder(); num >= 0; stringBuilder.Append(text), stringBuilder.Append(array[num4]), str = str.Substring(num3 + 1), num = str.IndexOf("|1"))
+		{
+			text = str.Substring(0, num);
+			if (text.Length == 0)
+			{
+				break;
+			}
+			int num2 = str.IndexOf('(', num);
+			if (num2 < 0)
+			{
+				break;
+			}
+			num3 = str.IndexOf(')', num2);
+			if (num3 < 0)
+			{
+				break;
+			}
+			string text2 = str.Substring(num2 + 1, num3 - num2 - 1);
+			array = text2.Split(',');
+			if (array.Length != 2)
+			{
+				break;
+			}
+			char c = text[text.Length - 1];
+			num4 = 0;
+			switch (c)
+			{
+			case '0':
+			case '1':
+			case '3':
+			case '6':
+			case '7':
+			case '8':
+				num4 = 0;
+				continue;
+			case '2':
+			case '4':
+			case '5':
+			case '9':
+				num4 = 1;
+				continue;
+			default:
+				if (c >= '가' && c <= '힣')
+				{
+					num4 = (((c - 44032) % 28 == 0) ? 1 : 0);
+					continue;
+				}
+				break;
+			}
+			break;
+		}
+		stringBuilder.Append(str);
+		return stringBuilder.ToString();
+	}
+
+	private static string ParseLanguageRule4(string str, GameStrings.PluralNumber[] pluralNumbers = null)
+	{
+		StringBuilder stringBuilder = null;
+		int? num = null;
+		int num2 = 0;
+		int num3 = 0;
+		for (int num4 = str.IndexOf("|4"); num4 >= 0; num4 = str.IndexOf("|4", num4 + 2))
+		{
+			num3++;
+			int argStartIndex;
+			int argEndIndex;
+			string[] array = ParseLanguageRuleArgs(str, num4, out argStartIndex, out argEndIndex);
+			if (array == null)
+			{
+				continue;
+			}
+			int num5 = num2;
+			int num6 = num4 - num2;
+			string text = str.Substring(num5, num6);
+			GameStrings.PluralNumber pluralNumber = null;
+			if (pluralNumbers != null)
+			{
+				int pluralArgIndex = num3 - 1;
+				pluralNumber = Array.Find(pluralNumbers, (GameStrings.PluralNumber currPluralNumber) => currPluralNumber.m_index == pluralArgIndex);
+			}
+			int number;
+			if (pluralNumber != null)
+			{
+				num = pluralNumber.m_number;
+			}
+			else if (ParseLanguageRule4Number(array, text, out number))
+			{
+				num = number;
+			}
+			else if (!num.HasValue)
+			{
+				continue;
+			}
+			int pluralIndex = GetPluralIndex(num.Value);
+			if (pluralIndex >= array.Length)
+			{
+			}
+			else
+			{
+				string value = array[pluralIndex];
+				if (stringBuilder == null)
+				{
+					stringBuilder = new StringBuilder();
+				}
+				stringBuilder.Append(text);
+				stringBuilder.Append(value);
+				num2 = argEndIndex + 1;
+			}
+			if (pluralNumber != null && pluralNumber.m_useForOnlyThisIndex)
+			{
+				num = null;
+			}
+		}
+		if (stringBuilder == null)
+		{
+			return str;
+		}
+		stringBuilder.Append(str, num2, str.Length - num2);
+		return stringBuilder.ToString();
+	}
+
+	private static bool ParseLanguageRule4Number(string[] args, string betweenRulesStr, out int number)
+	{
+		if (ParseLanguageRule4Number_Foreward(args[0], out number))
+		{
+			return true;
+		}
+		if (ParseLanguageRule4Number_Backward(betweenRulesStr, out number))
+		{
+			return true;
+		}
+		number = 0;
+		return false;
+	}
+
+	private static bool ParseLanguageRule4Number_Foreward(string str, out int number)
+	{
+		number = 0;
+		Match match = Regex.Match(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+(?!\\/)");
+		if (!match.Success)
+		{
+			match = Regex.Match(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+");
+		}
+		if (!match.Success)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseInt(match.Value, out number))
+		{
+			return false;
+		}
+		return true;
+	}
+
+	private static bool ParseLanguageRule4Number_Backward(string str, out int number)
+	{
+		number = 0;
+		MatchCollection matchCollection = Regex.Matches(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+(?!\\/)");
+		if (matchCollection.Count == 0)
+		{
+			matchCollection = Regex.Matches(str, "(?<!\\/)(?:[0-9]+,)*[0-9]+");
+		}
+		if (matchCollection.Count == 0)
+		{
+			return false;
+		}
+		if (!GeneralUtils.TryParseInt(matchCollection[matchCollection.Count - 1].Value, out number))
+		{
+			return false;
+		}
+		return true;
+	}
+
+	private static int GetPluralIndex(int number)
+	{
+		if (number == 1)
+        {
+			return 0;
+        }
+		return 1;
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/Localization/LocalizationKey.cs b/Assembly-CSharp/Accessibility/Localization/LocalizationKey.cs
new file mode 100644
index 0000000..4be480a
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Localization/LocalizationKey.cs
@@ -0,0 +1,1189 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+public class LocalizationKey
+{
+    public static LocalizationKey WELCOME_TO_HEARTHSTONE = CreateKey("ACCESSIBILITY_WELCOME_TO_HEARTHSTONE");
+
+    // Press key to
+    public static LocalizationKey PRESS_KEY_TO_START = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_START");
+    public static LocalizationKey PRESS_KEY_TO_CONTINUE = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_CONTINUE");
+    public static LocalizationKey PRESS_KEY_TO_FINISH = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_FINISH");
+    public static LocalizationKey PRESS_KEY_TO_GO_BACK = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_GO_BACK");
+    public static LocalizationKey PRESS_KEY_TO_READ_DETAILS = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_READ_DETAILS");
+    public static LocalizationKey PRESS_KEY_TO_EXIT = CreateKey("ACCESSIBILITY_PRESS_KEY_TO_EXIT");
+    public static LocalizationKey PRESS_KEY_ONCE_DONE = CreateKey("ACCESSIBILITY_PRESS_KEY_ONCE_DONE");
+
+    // Menus
+    public static LocalizationKey MENU_HELP_NO_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HELP_NO_BACK_BUTTON");
+    public static LocalizationKey MENU_HELP_WITH_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HELP_WITH_BACK_BUTTON");
+    public static LocalizationKey MENU_HORIZONTAL_HELP_NO_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HORIZONTAL_HELP_NO_BACK_BUTTON");
+    public static LocalizationKey MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON = CreateKey("ACCESSIBILITY_MENU_HORIZONTAL_HELP_WITH_BACK_BUTTON");
+    public static LocalizationKey MENU_OPTION_FORMAT = CreateKey("ACCESSIBILITY_MENU_OPTION_FORMAT");
+    public static LocalizationKey MENU_NO_ITEMS = CreateKey("ACCESSIBILITY_LIST_NO_ITEMS");
+    public static LocalizationKey MENU_GAME_MENU_TITLE = CreateKey("GLOBAL_TOOLTIP_MENU_HEADER");
+    public static LocalizationKey OPTIONS_MENU_TITLE = CreateKey("ACCESSIBILITY_OPTIONS_MENU_TITLE");
+    public static LocalizationKey OPTIONS_MENU_GRAPHICS_QUALITY_OPTION = CreateKey("ACCESSIBILITY_OPTIONS_MENU_GRAPHICS_QUALITY_OPTION");
+    public static LocalizationKey OPTIONS_MENU_GRAPHICS_RESOLUTION_OPTION = CreateKey("ACCESSIBILITY_OPTIONS_MENU_GRAPHICS_RESOLUTION_OPTION");
+    public static LocalizationKey OPTIONS_MENU_DEBUG_LOGGING_OPTION = CreateKey("ACCESSIBILITY_OPTIONS_MENU_DEBUG_LOGGING_OPTION");
+    public static LocalizationKey OPTIONS_MENU_FRAME_RATE_OPTION = CreateKey("GLOBAL_OPTIONS_GRAPHICS_FPS_LABEL");
+    public static LocalizationKey SOUND_OPTIONS_MENU_TITLE = CreateKey("GLOBAL_OPTIONS_SOUND_OPTIONS_LABEL");
+    public static LocalizationKey SOUND_OPTIONS_MENU_MASTER_VOLUME_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_MASTER_VOLUME_LABEL");
+    public static LocalizationKey SOUND_OPTIONS_MENU_MUSIC_VOLUME_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_MUSIC_VOLUME_LABEL");
+    public static LocalizationKey SOUND_OPTIONS_AMBIENT_SOUNDS_VOLUME_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_AMBIENT_SOUNDS_VOLUME_LABEL");
+    public static LocalizationKey SOUND_OPTIONS_MENU_DIALOG_VOLUME_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_DIALOG_VOLUME_LABEL");
+    public static LocalizationKey SOUND_OPTIONS_MENU_SOUND_EFFECT_VOLUME_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_SOUND_EFFECT_VOLUME_LABEL");
+    public static LocalizationKey SOUND_OPTIONS_SOUND_MONO_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_MONO");
+    public static LocalizationKey SOUND_OPTIONS_MENU_SOUND_IN_BACKGROUND_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_IN_BACKGROUND");
+    public static LocalizationKey SOUND_OPTIONS_MENU_RESET_DEFAULTS_OPTION = CreateKey("GLOBAL_OPTIONS_SOUND_RESET_DEFAULTS");
+    public static LocalizationKey OPTIONS_MENU_FULLSCREEN_OPTION = CreateKey("GLOBAL_OPTIONS_GRAPHICS_FULLSCREEN_LABEL");
+    public static LocalizationKey OPTIONS_MENU_SPEECH_IN_BACKGROUND_OPTION = CreateKey("ACCESSIBILITY_OPTIONS_MENU_SPEECH_IN_BACKGROUND_OPTION");
+    public static LocalizationKey OPTIONS_MENU_ALLOW_SPECTATORS_OPTION = CreateKey("GLOBAL_OPTIONS_SPECTATOR_OPEN_JOIN");
+    public static LocalizationKey OPTIONS_MENU_ENABLE_SCREEN_SHAKE_OPTION = CreateKey("GLOBAL_OPTIONS_SCREEN_SHAKE");
+    public static LocalizationKey OPTIONS_MENU_ADJUST_VOLUME = CreateKey("ACCESSIBILITY_OPTIONS_MENU_ADJUST_VOLUME");
+    public static LocalizationKey OPTIONS_MENU_CHECKBOX_LABEL = CreateKey("ACCESSIBILITY_OPTIONS_MENU_CHECKBOX_LABEL");
+    public static LocalizationKey OPTIONS_MENU_CHECKBOX_CHECKED = CreateKey("ACCESSIBILITY_OPTIONS_MENU_CHECKBOX_CHECKED");
+    public static LocalizationKey OPTIONS_MENU_CHECKBOX_NOT_CHECKED = CreateKey("ACCESSIBILITY_OPTIONS_MENU_CHECKBOX_NOT_CHECKED");
+    public static LocalizationKey OPTIONS_MENU_AUTO_ATTACK_SPEED = CreateKey("ACCESSIBILITY_OPTIONS_MENU_AUTO_ATTACK_SPEED");
+    public static LocalizationKey OPTIONS_MENU_AUTO_ATTACK_SPEED_SLOW = CreateKey("ACCESSIBILITY_OPTIONS_MENU_AUTO_ATTACK_SPEED_SLOW");
+    public static LocalizationKey OPTIONS_MENU_AUTO_ATTACK_SPEED_MEDIUM = CreateKey("ACCESSIBILITY_OPTIONS_MENU_AUTO_ATTACK_SPEED_MEDIUM");
+    public static LocalizationKey OPTIONS_MENU_AUTO_ATTACK_SPEED_FAST = CreateKey("ACCESSIBILITY_OPTIONS_MENU_AUTO_ATTACK_SPEED_FAST");
+    public static LocalizationKey OPTIONS_MENU_SAVE_BATTLE_LOGS = CreateKey("ACCESSIBILITY_OPTIONS_MENU_SAVE_BATTLE_LOGS");
+
+    // Hub
+    public static LocalizationKey HUB_MAIN_MENU_TITLE = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_TITLE");
+    public static LocalizationKey HUB_MAIN_MENU_OPTION_GAME_MENU = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_OPTION_GAME_MENU");
+    public static LocalizationKey HUB_MAIN_MENU_OPTION_SOCIAL_MENU = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_OPTION_SOCIAL_MENU");
+    public static LocalizationKey HUB_MAIN_MENU_OPTION_HELP = CreateKey("ACCESSIBILITY_HUB_MAIN_MENU_OPTION_HELP");
+    public static LocalizationKey HUB_TAVERN_BRAWL_INACCESSIBLE = CreateKey("ACCESSIBILITY_HUB_TAVERN_BRAWL_INACCESSIBLE");
+
+    // Global
+    public static LocalizationKey GLOBAL_SOLO_ADVENTURES = CreateKey("GLUE_ADVENTURE");
+    public static LocalizationKey GLOBAL_ARENA    = CreateKey("ACCESSIBILITY_MODES_ARENA");
+    public static LocalizationKey GLOBAL_TAVERN    = CreateKey("ACCESSIBILITY_MODES_TAVERN");
+    public static LocalizationKey GLOBAL_BATTLEGROUNDS = CreateKey("GLUE_BACON");
+    public static LocalizationKey GLOBAL_GAME_MODES = CreateKey("GLUE_GAME_MODES");
+    public static LocalizationKey GLOBAL_CHOOSE_MODE = CreateKey("GLUE_GAME_MODES_POPUP_HEADER");
+    public static LocalizationKey GLOBAL_MY_COLLECTION = CreateKey("GLUE_MY_COLLECTION");
+    public static LocalizationKey GLOBAL_OPEN_PACKS = CreateKey("GLUE_OPEN_PACKS");
+    public static LocalizationKey GLOBAL_JOURNAL = CreateKey("GLUE_TOOLTIP_BUTTON_JOURNAL_HEADLINE");
+    public static LocalizationKey GLOBAL_SHOP = CreateKey("GLUE_STORE_HEADLINE");
+    public static LocalizationKey GLOBAL_HELP = CreateKey("GLOBAL_HELP");
+    public static LocalizationKey GLOBAL_LOADING_GAME = CreateKey("ACCESSIBILITY_GLOBAL_LOADING_GAME");
+    public static LocalizationKey GLOBAL_CLOSING_GAME = CreateKey("ACCESSIBILITY_GLOBAL_CLOSING_GAME");
+    public static LocalizationKey GLOBAL_GAME_LOADED = CreateKey("ACCESSIBILITY_GLOBAL_GAME_LOADED");
+    public static LocalizationKey GLOBAL_LOADING = CreateKey("ACCESSIBILITY_GLOBAL_LOADING");
+    public static LocalizationKey GLOBAL_GAME_QUEUE_WAIT_TIME = CreateKey("GLOBAL_GAME_QUEUE_WAIT_TIME");
+    public static LocalizationKey GLOBAL_GAME_QUEUE_TIME_IN_QUEUE = CreateKey("GLOBAL_GAME_QUEUE_TIME_IN_QUEUE");
+    public static LocalizationKey GLOBAL_PLEASE_WAIT = CreateKey("ACCESSIBILITY_GLOBAL_PLEASE_WAIT");
+    public static LocalizationKey GLOBAL_RECONNECTED = CreateKey("GLOBAL_RECONNECT_RECONNECTED_HEADER");
+    public static LocalizationKey GLOBAL_CARD = CreateKey("ACCESSIBILITY_GLOBAL_CARD");
+    public static LocalizationKey GLOBAL_CARD_PLURAL = CreateKey("ACCESSIBILITY_GLOBAL_CARD_PLURAL");
+    public static LocalizationKey GLOBAL_SECRET = CreateKey("ACCESSIBILITY_GLOBAL_SECRET");
+    public static LocalizationKey GLOBAL_GAME_SPEED = CreateKey("ACCESSIBILITY_GLOBAL_GAME_SPEED");
+    public static LocalizationKey GLOBAL_GAME_SPEED_CANNOT_ADJUST_VS_PLAYERS = CreateKey("ACCESSIBILITY_GLOBAL_GAME_SPEED_CANNOT_ADJUST_VS_PLAYERS");
+    public static LocalizationKey GLOBAL_OPTIONS = CreateKey("GLOBAL_OPTIONS");
+    public static LocalizationKey GLOBAL_NEW_HEARTHSTONE_ACCESS_VERSION_AVAILABLE = CreateKey("ACCESSIBILITY_GLOBAL_NEW_HEARTHSTONE_ACCESS_VERSION_AVAILABLE");
+    public static LocalizationKey GLOBAL_CANNOT_DO_THAT = CreateKey("ACCESSIBILITY_GLOBAL_CANNOT_DO_THAT");
+    public static LocalizationKey GLOBAL_SWITCH_FORMAT = CreateKey("ACCESSIBILITY_GLOBAL_SWITCH_FORMAT");
+    public static LocalizationKey GLOBAL_CHOOSE_FORMAT = CreateKey("ACCESSIBILITY_GLOBAL_CHOOSE_FORMAT");
+    public static LocalizationKey GLOBAL_STANDARD = CreateKey("GLOBAL_STANDARD");
+    public static LocalizationKey GLOBAL_WILD = CreateKey("GLOBAL_WILD");
+    public static LocalizationKey GLOBAL_TWIST = CreateKey("GLOBAL_TWIST");
+    public static LocalizationKey GLOBAL_PLAY = CreateKey("GLOBAL_PLAY");
+
+    // Global cont'd
+    public static LocalizationKey GLOBAL_ACCESSIBILITY_ON = CreateKey("ACCESSIBILITY_GLOBAL_ACCESSIBILITY_ON");
+    public static LocalizationKey GLOBAL_ACCESSIBILITY_OFF = CreateKey("ACCESSIBILITY_GLOBAL_ACCESSIBILITY_OFF");
+    public static LocalizationKey GLOBAL_STREAMER_MODE_ON = CreateKey("ACCESSIBILITY_GLOBAL_STREAMER_MODE_ON");
+    public static LocalizationKey GLOBAL_STREAMER_MODE_OFF = CreateKey("ACCESSIBILITY_GLOBAL_STREAMER_MODE_OFF");
+
+    // Formatting
+    public static LocalizationKey FORMATTING_PERIOD = CreateKey("ACCESSIBILITY_FORMATTING_PERIOD");
+    public static LocalizationKey FORMATTING_SENTENCE_ENDING_CHARACTERS = CreateKey("ACCESSIBILITY_FORMATTING_SENTENCE_ENDING_CHARACTERS");
+    public static LocalizationKey FORMATTING_LIST_SEPARATOR = CreateKey("ACCESSIBILITY_FORMATTING_LIST_SEPARATOR");
+    public static LocalizationKey FORMATTING_LIST_FINAL_SEPARATOR = CreateKey("ACCESSIBILITY_FORMATTING_LIST_FINAL_SEPARATOR");
+
+    // Orders
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_1 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_1");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_2 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_2");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_3 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_3");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_4 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_4");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_5 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_5");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_6 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_6");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_7 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_7");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_8 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_8");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_9 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_9");
+    public static LocalizationKey FORMATTING_ORDINAL_NUMBER_10 = CreateKey("ACCESSIBILITY_FORMATTING_ORDINAL_NUMBER_10");
+
+    // Input
+    public static LocalizationKey INPUT_COMMAND_WITH_MODIFIER_FORMAT = CreateKey("ACCESSIBILITY_INPUT_COMMAND_WITH_MODIFIER_FORMAT");
+    public static LocalizationKey INPUT_COMMAND_WITH_CTRL_FORMAT = CreateKey("ACCESSIBILITY_INPUT_COMMAND_WITH_CTRL_FORMAT");
+    public static string INPUT_KEY_OVERRIDE_FORMAT = "ACCESSIBILITY_INPUT_KEY_OVERRIDE_{0}";
+
+    // Card reading
+    public static LocalizationKey READ_CARD_COST = CreateKey("ACCESSIBILITY_READ_CARD_COST");
+    public static LocalizationKey READ_CARD_ATK_HEALTH = CreateKey("ACCESSIBILITY_READ_CARD_ATK_HEALTH");
+    public static LocalizationKey READ_CARD_ATK_DURABILITY = CreateKey("ACCESSIBILITY_READ_CARD_ATK_DURABILITY");
+    public static LocalizationKey READ_CARD_DURABILITY = CreateKey("ACCESSIBILITY_READ_CARD_DURABILITY");
+    public static LocalizationKey READ_HERO_CARD_ATK = CreateKey("ACCESSIBILITY_READ_HERO_CARD_ATK");
+    public static LocalizationKey READ_HERO_CARD_HEALTH = CreateKey("ACCESSIBILITY_READ_HERO_CARD_HEALTH");
+    public static LocalizationKey READ_HERO_CARD_ARMOR = CreateKey("ACCESSIBILITY_READ_HERO_CARD_ARMOR");
+    public static LocalizationKey READ_CARD_N_COPIES = CreateKey("ACCESSIBILITY_READ_CARD_N_COPIES");
+    public static LocalizationKey READ_COLLECTION_CARD_NAME_GOLDEN = CreateKey("ACCESSIBILITY_READ_COLLECTION_CARD_NAME_GOLDEN");
+    public static LocalizationKey READ_COLLECTION_CARD_NAME_DIAMOND = CreateKey("ACCESSIBILITY_READ_COLLECTION_CARD_NAME_DIAMOND");
+    public static LocalizationKey READ_COLLECTION_CARD_NAME_SIGNATURE = CreateKey("ACCESSIBILITY_READ_COLLECTION_CARD_NAME_SIGNATURE");
+
+    // Global keywords
+    public static LocalizationKey GLOBAL_TAUNT = CreateKey("GLOBAL_KEYWORD_TAUNT");
+    public static LocalizationKey GLOBAL_DEATHRATTLE = CreateKey("GLOBAL_KEYWORD_DEATHRATTLE");
+    public static LocalizationKey GLOBAL_BATTLECRY = CreateKey("GLOBAL_KEYWORD_BATTLECRY");
+    public static LocalizationKey GLOBAL_CHARGE = CreateKey("GLOBAL_KEYWORD_CHARGE");
+    public static LocalizationKey GLOBAL_LIFESTEAL = CreateKey("GLOBAL_KEYWORD_LIFESTEAL");
+    public static LocalizationKey GLOBAL_RUSH = CreateKey("GLOBAL_KEYWORD_RUSH");
+    public static LocalizationKey GLOBAL_WINDFURY = CreateKey("GLOBAL_KEYWORD_WINDFURY");
+    public static LocalizationKey GLOBAL_DIVINE_SHIELD = CreateKey("GLOBAL_KEYWORD_DIVINE_SHIELD");
+    public static LocalizationKey GLOBAL_FREEZE = CreateKey("GLOBAL_KEYWORD_FREEZE");
+    public static LocalizationKey GLOBAL_FROZEN = CreateKey("GLOBAL_KEYWORD_FROZEN");
+    public static LocalizationKey GLOBAL_POISONOUS = CreateKey("GLOBAL_KEYWORD_POISONOUS");
+    public static LocalizationKey GLOBAL_STEALTH = CreateKey("GLOBAL_KEYWORD_STEALTH");
+    public static LocalizationKey GLOBAL_IMMUNE = CreateKey("GLOBAL_KEYWORD_IMMUNE");
+    public static LocalizationKey GLOBAL_DORMANT = CreateKey("GLOBAL_KEYWORD_DORMANT");
+    public static LocalizationKey GLOBAL_REBORN = CreateKey("GLOBAL_KEYWORD_REBORN");
+    public static LocalizationKey GLOBAL_ENCHANTMENT = CreateKey("GLOBAL_CARDTYPE_ENCHANTMENT");
+    public static LocalizationKey GLOBAL_SILENCE = CreateKey("GLOBAL_KEYWORD_SILENCE");
+    public static LocalizationKey GLOBAL_CURSED = CreateKey("ACCESSIBILITY_GLOBAL_KEYWORD_CURSED");
+    public static LocalizationKey GLOBAL_READY = CreateKey("GAMEPLAY_LETTUCE_READY_BUTTON");
+        public static LocalizationKey GLOBAL_HAUNTED = CreateKey("ACCESSIBILITY_GLOBAL_KEYWORD_HAUNTED");
+
+    // Gameplay
+    public static LocalizationKey GAMEPLAY_YOUR_TURN = CreateKey("GAMEPLAY_YOUR_TURN");
+    public static LocalizationKey GAMEPLAY_OPPONENT_TURN = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_TURN");
+    public static LocalizationKey GAMEPLAY_TURN_ENDED = CreateKey("ACCESSIBILITY_GAMEPLAY_TURN_ENDED");
+    public static LocalizationKey GAMEPLAY_CHOICES_HIDDEN = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOICES_HIDDEN");
+    public static LocalizationKey GAMEPLAY_PLAYER_CARD_TRIGGERED = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_CARD_TRIGGERED");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CARD_TRIGGERED = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CARD_TRIGGERED");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CARD_TRIGGERED_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CARD_TRIGGERED_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_CARD_IN_ZONE_TRIGGERED = CreateKey("ACCESSIBILITY_GAMEPLAY_CARD_IN_ZONE_TRIGGERED");
+    public static LocalizationKey GAMEPLAY_PLAYER_PLAYED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_PLAYED_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_PLAYED_CARD_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_PLAYED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_PLAYED_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_PLAYED_CARD_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_SUMMONED_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_SUMMONED_MINION");
+    public static LocalizationKey GAMEPLAY_PLAYER_SUMMONED_MINION_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_SUMMONED_MINION_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_SUMMONED_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_SUMMONED_MINION");
+    public static LocalizationKey GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_SUMMONED_MINION_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_TRADED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_TRADED_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_TRADED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_TRADED_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_PLAYER_EQUIPPED_WEAPON_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_EQUIPPED_WEAPON_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_OPPONENT_EQUIPPED_WEAPON_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_EQUIPPED_WEAPON_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_USED_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_USED_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_PLAYER_USED_HERO_POWER_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_USED_HERO_POWER_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_USED_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_USED_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_OPPONENT_USED_HERO_POWER_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_USED_HERO_POWER_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_PLAYER_CAST_SECRET = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_CAST_SECRET");
+    public static LocalizationKey GAMEPLAY_PLAYER_CAST_SECRET_BIG_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_CAST_SECRET_BIG_CARD");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CAST_SECRET = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CAST_SECRET");
+    public static LocalizationKey GAMEPLAY_OPPONENT_CAST_N_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_CAST_N_SECRETS");
+    public static LocalizationKey GAMEPLAY_PLAYER_DREW_CARD_FROM_EMPTY_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DREW_CARD_FROM_EMPTY_DECK");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DREW_CARD_FROM_EMPTY_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DREW_CARD_FROM_EMPTY_DECK");
+    public static LocalizationKey GAMEPLAY_PLAYER_DREW_CARD_BUT_BURNED = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DREW_CARD_BUT_BURNED");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DREW_CARD_BUT_BURNED = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DREW_CARD_BUT_BURNED");
+    public static LocalizationKey GAMEPLAY_ENTITY_ATTACKED = CreateKey("ACCESSIBILITY_GAMEPLAY_ENTITY_ATTACKED");
+    public static LocalizationKey GAMEPLAY_ENTITY_ATTACKED_OTHER = CreateKey("ACCESSIBILITY_GAMEPLAY_ENTITY_ATTACKED_OTHER");
+    public static LocalizationKey GAMEPLAY_JOUST_PLAYER_REVEALED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_PLAYER_REVEALED_CARD");
+    public static LocalizationKey GAMEPLAY_JOUST_OPPONENT_REVEALED_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_OPPONENT_REVEALED_CARD");
+    public static LocalizationKey GAMEPLAY_JOUST_PLAYER_NO_VALID_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_PLAYER_NO_VALID_CARDS");
+    public static LocalizationKey GAMEPLAY_JOUST_OPPONENT_NO_VALID_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_JOUST_OPPONENT_NO_VALID_CARDS");
+
+    // Gameplay
+    public static LocalizationKey GAMEPLAY_PLAYER_TURN_START_READ_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_TURN_START_READ_MANA");
+    public static LocalizationKey GAMEPLAY_YOU_GO_FIRST = CreateKey("ACCESSIBILITY_GAMEPLAY_YOU_GO_FIRST");
+    public static LocalizationKey GAMEPLAY_OPPONENT_GOES_FIRST = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_GOES_FIRST");
+    public static LocalizationKey GAMEPLAY_YOU_START_WITH_N_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_YOU_START_WITH_N_CARDS");
+    public static LocalizationKey GAMEPLAY_PLAYER_DREW_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DREW_CARDS");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DREW_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DREW_CARDS");
+    public static LocalizationKey GAMEPLAY_PLAYER_DISCARDED_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAYER_DISCARDED_CARDS");
+    public static LocalizationKey GAMEPLAY_OPPONENT_DISCARDED_CARDS = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_DISCARDED_CARDS");
+    public static LocalizationKey GAMEPLAY_YOU_GET_THE_COIN = CreateKey("ACCESSIBILITY_GAMEPLAY_YOU_GET_THE_COIN");
+    public static LocalizationKey GAMEPLAY_WAITING_FOR_OPPONENT = CreateKey("ACCESSIBILITY_GAMEPLAY_WAITING_FOR_OPPONENT");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_RIGHT = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_RIGHT");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_LEFT = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION_AT_THE_LEFT");
+    public static LocalizationKey GAMEPLAY_QUERY_SUMMON_MINION_BETWEEN = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_SUMMON_MINION_BETWEEN");
+    public static LocalizationKey GAMEPLAY_QUERY_PLAY_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_PLAY_CARD");
+    public static LocalizationKey GAMEPLAY_QUERY_TRADE_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_TRADE_CARD");
+    public static LocalizationKey GAMEPLAY_QUERY_FORGE_CARD = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_FORGE_CARD");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_VALID_PLAYS = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_VALID_PLAYS");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_CAN_ATK = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_CAN_ATK");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_LOCATION = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_LOCATION");
+    public static LocalizationKey GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_QUERY_END_TURN_WHEN_CAN_USE_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_NO_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_NO_MINIONS");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_ATTACKED");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_HERO_CANT_BE_TARGETED");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_HERO_NO_VALID_ATTACKERS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_HERO_NO_VALID_ATTACKERS");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_NOT_FRIENDLY_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_NOT_FRIENDLY_MINION");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_NOT_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_NOT_MINION");
+    public static LocalizationKey GAMEPLAY_SEND_TO_FACE_NOT_VALID_ATTACKER = CreateKey("ACCESSIBILITY_GAMEPLAY_SEND_TO_FACE_NOT_VALID_ATTACKER");
+    public static LocalizationKey GAMEPLAY_CHOOSE_TARGET = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOOSE_TARGET");
+    public static LocalizationKey GAMEPLAY_CHOOSE_ONE = CreateKey("GAMEPLAY_CHOOSE_ONE");
+    public static LocalizationKey GAMEPLAY_N_SECONDS_REMAINING = CreateKey("ACCESSIBILITY_GAMEPLAY_N_SECONDS_REMAINING");
+    public static LocalizationKey GAMEPLAY_VS_PLAYER_ANNOUNCEMENT = CreateKey("ACCESSIBILITY_GAMEPLAY_VS_PLAYER_ANNOUNCEMENT");
+
+    // Gameplay read zones
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_HAND_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_HAND_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_MINIONS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_MINIONS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_MINIONS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_MINIONS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_SECRETS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_SECRETS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_COUNT = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_SECRETS_COUNT");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_HERO_POWER_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_HERO_POWER_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_HERO_POWER_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_HERO_POWER_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_PLAYER_WEAPON_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_PLAYER_WEAPON_EMPTY");
+    public static LocalizationKey GAMEPLAY_SEE_ZONE_OPPONENT_WEAPON_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_ZONE_OPPONENT_WEAPON_EMPTY");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA_CURRENT_AND_TOTAL = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA_CURRENT_AND_TOTAL");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_MANA_CURRENT_AND_TOTAL = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_MANA_CURRENT_AND_TOTAL");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_MANA");
+    public static LocalizationKey GAMEPLAY_READ_CORPSES = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CORPSES");
+    public static LocalizationKey GAMEPLAY_READ_CORPSES_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CORPSES_EMPTY");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_NO_VALID_PLAYS = CreateKey("ACCESSIBILITY_GAMEPLAY_NO_VALID_PLAYS");
+    public static LocalizationKey GAMEPLAY_NO_ANOMELIES = CreateKey("ACCESSIBILITY_GAMEPLAY_NO_ANOMALIES");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_OVERLOADED_MANA = CreateKey("GAMEPLAY_TOOLTIP_MANA_OVERLOAD_DESCRIPTION");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_LOCKED_MANA = CreateKey("GAMEPLAY_TOOLTIP_MANA_LOCKED_DESCRIPTION");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_OVERLOADED_MANA = CreateKey("GAMEPLAY_TOOLTIP_ENEMYOVERLOAD_DESC");
+
+    // Gameplay game over
+    public static LocalizationKey GAMEPLAY_GAME_OVER_WON = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_WON");
+    public static LocalizationKey GAMEPLAY_GAME_OVER_LOST = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_LOST");
+    public static LocalizationKey GAMEPLAY_GAME_OVER_TIED = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_TIED");
+    public static LocalizationKey GAMEPLAY_GAME_OVER_GENERIC = CreateKey("ACCESSIBILITY_GAMEPLAY_GAME_OVER_GENERIC");
+
+    // Gameplay zones
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_HERO = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_HERO");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_HERO = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_HERO");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_HERO_POWER = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_HERO_POWER");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_WEAPON");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_WEAPON");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_MINIONS");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_MINIONS");
+    public static LocalizationKey GAMEPLAY_ZONE_PLAYER_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_PLAYER_SECRETS");
+    public static LocalizationKey GAMEPLAY_ZONE_OPPONENT_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_ZONE_OPPONENT_SECRETS");
+
+    // Gameplay diff zones
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_SECRETS");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_SECRETS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_SECRETS");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_PLAYER_GRAVEYARD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_PLAYER_GRAVEYARD");
+    public static LocalizationKey GAMEPLAY_DIFF_ZONE_OPPONENT_GRAVEYARD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ZONE_OPPONENT_GRAVEYARD");
+
+    // Gameplay entity diffs
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_DIED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_DIED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_DIED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_DIED");
+    public static LocalizationKey GAMEPLAY_DIFF_WEAPON_BROKE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_WEAPON_BROKE");
+    public static LocalizationKey GAMEPLAY_DIFF_AURA_FADED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_AURA_FADED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_AURAS_FADED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_AURAS_FADED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_TRANSFORMED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_TRANSFORMED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TRANSFORMED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TRANSFORMED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_TOOK_N_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_TOOK_N_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TOOK_N_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_TOOK_N_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_DURABILITY = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_DURABILITY");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_ATTACK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_ATTACK");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_HEALTH = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_HEALTH");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_N_ARMOR = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_N_ARMOR");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_RECOVERED_N_HEALTH = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_RECOVERED_N_HEALTH");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_RECOVERED_N_HEALTH = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_RECOVERED_N_HEALTH");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_INVULNERABLE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_INVULNERABLE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_INVULNERABLE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_INVULNERABLE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_WAS_CURSED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_WAS_CURSED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_WERE_CURSED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_WERE_CURSED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_SILENCED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_SILENCED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_SILENCED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_SILENCED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_WAS_HAUNTED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_WAS_HAUNTED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_WERE_HAUNTED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_WERE_HAUNTED");
+
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_DORMANT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_DORMANT");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_FROZEN = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_FROZEN");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_IMMUNE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_IMMUNE");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_MAGNETIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_MAGNETIC");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_NO_LONGER_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_NO_LONGER_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_POISONOUS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_NO_LONGER_POISONOUS");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_BECAME_STEALTHED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_BECAME_STEALTHED");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_STEALTHED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_BECAME_STEALTHED");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_GAINED_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_GAINED_STATS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_GAINED_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_GAINED_STATS");
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_LOST_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_LOST_STATS");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES_LOST_STATS");
+
+    // Speeches
+    public static LocalizationKey GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_ENTITY_SPEECHES_FORMAT");
+
+    // Gameplay entity naming
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME_IN_LIST = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_ENTITY_FULL_NAME_IN_LIST");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME_IN_LIST = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_ENTITY_FULL_NAME_IN_LIST");
+    public static LocalizationKey GAMEPLAY_DIFF_MULTIPLE_ENTITIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MULTIPLE_ENTITIES");
+
+    // Gameplay entity groups
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_EVERYONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_EVERYONE");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_EVERYONE_ELSE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_EVERYONE_ELSE");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_ALL_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_ALL_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_ALL_OTHER_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_ALL_OTHER_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_BOTH_HEROES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_BOTH_HEROES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_ENEMIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_ENEMIES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_ENEMIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_ENEMIES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_FRIENDLY_CHARACTERS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_FRIENDLY_CHARACTERS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_CHARACTERS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_CHARACTERS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OPPONENT_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OPPONENT_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_OPPONENT_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_OPPONENT_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_FRIENDLY_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_FRIENDLY_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_MINIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OTHER_FRIENDLY_MINIONS");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_FRIENDLY_SAME_NAME_ENTITIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_FRIENDLY_SAME_NAME_ENTITIES");
+    public static LocalizationKey GAMEPLAY_DIFF_GROUP_OPPONENT_SAME_NAME_ENTITIES = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_GROUP_OPPONENT_SAME_NAME_ENTITIES");
+
+    // Gameplay movements
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_PLAYER_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_PLAYER_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_OPPONENT_EQUIPPED_WEAPON = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_OPPONENT_EQUIPPED_WEAPON");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_PLAYER_HERO_POWER_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_OPPONENT_HERO_POWER_CHANGED");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_RETURNED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_RETURNED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_FROM_ZONE_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_FROM_ZONE_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_FROM_ZONE_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_FROM_ZONE_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_TO_ZONE");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_ENTITY_MOVED_ZONES_GENERIC");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_MULTIPLE_ENTITIES_MOVED_ZONES_GENERIC");
+
+    // Gameplay movements continued
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_HAND = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_HAND");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_DECK = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_DECK");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_PLAYER_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_PLAYER_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_OPPONENT_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_OPPONENT_BATTLEFIELD");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_PLAYER = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_PLAYER");
+    public static LocalizationKey GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_OPPONENT = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_MOVEMENT_CARDS_TAKEN_CONTROL_BY_OPPONENT");
+
+    // Gameplay spell damage
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_SPELL_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_LOST_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_LOST_SPELL_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_SPELL_DAMAGE");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_LOST_SPELL_DAMAGE = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_LOST_SPELL_DAMAGE");
+
+    // Gameplay mana crystals
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_MANA");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_MANA = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_MANA");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_MANA_AND_EMPTY_MANA_CRYSTALS");
+    public static LocalizationKey GAMEPLAY_DIFF_PLAYER_GAINED_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_PLAYER_GAINED_EMPTY_MANA_CRYSTALS");
+    public static LocalizationKey GAMEPLAY_DIFF_OPPONENT_GAINED_EMPTY_MANA_CRYSTALS = CreateKey("ACCESSIBILITY_GAMEPLAY_DIFF_OPPONENT_GAINED_EMPTY_MANA_CRYSTALS");
+
+    // Gameplay help
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HERO_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_OPPONENT_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_HERO_HELP");
+    public static LocalizationKey GAMEPLAY_READ_CARDS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARDS_HELP");
+    public static LocalizationKey GAMEPLAY_CONFIRM_TO_ATTACK_TARGET = CreateKey("ACCESSIBILITY_GAMEPLAY_CONFIRM_TO_ATTACK_TARGET");
+    public static LocalizationKey GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION");
+    public static LocalizationKey GAMEPLAY_CONFIRM_END_TURN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CONFIRM_END_TURN_HELP");
+    public static LocalizationKey GAMEPLAY_TRY_AGAIN = CreateKey("ACCESSIBILITY_GAMEPLAY_TRY_AGAIN");
+    public static LocalizationKey GAMEPLAY_SEE_VALID_OPTIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_VALID_OPTIONS");
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_HAND_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HAND_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_HAND_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_HAND_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_MINIONS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_MINIONS_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_OPPONENT_MINIONS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_MINIONS_HELP");
+    public static LocalizationKey GAMEPLAY_SEE_PLAYER_SECRETS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_SECRETS_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_WEAPON_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_WEAPON_HELP");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_WEAPON_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_WEAPON_HELP");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_HERO_POWER_HELP");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_PLAYER_DECK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_PLAYER_DECK_HELP");
+    public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_DECK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_DECK_HELP");
+    public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA_HELP");
+    public static LocalizationKey GAMEPLAY_READ_OPPONENT_MANA_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_MANA_HELP");
+    public static LocalizationKey GAMEPLAY_READ_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARD_HELP");
+    public static LocalizationKey GAMEPLAY_READ_CARD_TOOLTIP_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARD_TOOLTIP_HELP");
+    public static LocalizationKey GAMEPLAY_PLAY_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAY_CARD_HELP");
+    public static LocalizationKey GAMEPLAY_TRADE_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_TRADE_CARD_HELP");
+    public static LocalizationKey GAMEPLAY_SUMMON_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SUMMON_MINION_HELP");
+    public static LocalizationKey GAMEPLAY_CHOICE_MODE_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOICE_MODE_HELP");
+    public static LocalizationKey GAMEPLAY_HIDDEN_CHOICE_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_HIDDEN_CHOICE_HELP");
+    public static LocalizationKey GAMEPLAY_CHOOSE_TARGET_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOOSE_TARGET_HELP");
+    public static LocalizationKey GAMEPLAY_ATTACK_WITH_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_MINION_HELP");
+    public static LocalizationKey GAMEPLAY_ATTACK_WITH_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_HERO_HELP");
+    public static LocalizationKey GAMEPLAY_USE_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_USE_HERO_POWER_HELP");
+    public static LocalizationKey GAMEPLAY_READ_THROUGH_VALID_TARGETS = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_THROUGH_VALID_TARGETS");
+    public static LocalizationKey GAMEPLAY_ATTACK_THIS_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_THIS_MINION_HELP");
+    public static LocalizationKey GAMEPLAY_CANCEL_ATTACK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CANCEL_ATTACK_HELP");
+    public static LocalizationKey GAMEPLAY_CANCEL_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CANCEL_HELP");
+    public static LocalizationKey GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP");
+    public static LocalizationKey GAMEPLAY_OPEN_HISTORY_LOG_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_OPEN_HISTORY_LOG_HELP");
+    public static LocalizationKey GAMEPLAY_READ_HISTORY_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_HISTORY_HELP");
+    public static LocalizationKey GAMEPLAY_END_TURN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_END_TURN_HELP");
+
+    // Gameplay History Log
+    public static LocalizationKey GAMEPLAY_HISTORY_LOG_EMPTY = CreateKey("ACCESSIBILITY_GAMEPLAY_HISTORY_LOG_EMPTY");
+    public static LocalizationKey GAMEPLAY_HISTORY_LOG_ENTRY_FORMAT = CreateKey("ACCESSIBILITY_GAMEPLAY_HISTORY_LOG_ENTRY_FORMAT");
+    public static LocalizationKey GAMEPLAY_HISTORY_LOG_CLOSE = CreateKey("ACCESSIBILITY_GAMEPLAY_HISTORY_LOG_CLOSE");
+
+    // Gameplay special events
+    public static LocalizationKey GAMEPLAY_SPECIAL_STARTING_PLAYER_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_SPECIAL_STARTING_PLAYER_BATTLEFIELD"); // See BoH Jaina 6
+    public static LocalizationKey GAMEPLAY_SPECIAL_STARTING_OPPONENT_BATTLEFIELD = CreateKey("ACCESSIBILITY_GAMEPLAY_SPECIAL_STARTING_OPPONENT_BATTLEFIELD"); // See BoH Rexxar 3
+
+    // Mulligan
+    public static LocalizationKey GAMEPLAY_MULLIGAN_WILL_BE_REPLACED = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_WILL_BE_REPLACED");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_WILL_NOT_BE_REPLACED = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_WILL_NOT_BE_REPLACED");
+    public static LocalizationKey GAMEPLAY_MULLIGAN = CreateKey("GAMEPLAY_MULLIGAN_STARTING_HAND");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_KEEP_OR_REPLACE_CARDS = CreateKey("GAMEPLAY_MULLIGAN_SUBTITLE");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_HELP");
+    public static LocalizationKey GAMEPLAY_MULLIGAN_HELP_WAITING_FOR_GAME_TO_START = CreateKey("ACCESSIBILITY_GAMEPLAY_MULLIGAN_HELP_WAITING_FOR_GAME_TO_START");
+
+    // Battlegrounds
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_CARD_TIER");
+    public static LocalizationKey BATTLEGROUNDS_PARTY_PLAYER_JOINED = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_PARTY_PLAYER_JOINED");
+     public static LocalizationKey BATTLEGROUNDS_PARTY_PLAYER_DECLINED_INVITE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_PARTY_PLAYER_DECLINED_INVITE");
+     public static LocalizationKey BATTLEGROUNDS_PARTY_PLAYER_LEFT = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_PARTY_PLAYER_LEFT");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_CARD_COST = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_CARD_COST");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DARKMOON_TICKET = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DARKMOON_TICKET");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_CARD_PREMIUM_GOLDEN = CreateKey("GLUE_MASS_DISENCHANT_PREMIUM_TITLE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE = CreateKey("GLUE_BACON_INFO_POPUP_RECRUIT");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE = CreateKey("GLUE_BACON_INFO_POPUP_COMBAT");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE_START_DESCRIBE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_RECRUIT_PHASE_START_DESCRIBE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_INCLUDE_ARMOR = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_INCLUDE_ARMOR");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_AGAINST_DEAD_PLAYER = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_START_DESCRIBE_AGAINST_DEAD_PLAYER");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_CURRENT_AND_TOTAL = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_CURRENT_AND_TOTAL");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_REMAINING_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_REMAINING_GOLD");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_ZONE_MINIONS_FOR_SALE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_ZONE_MINIONS_FOR_SALE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_SEE_ZONE_MINIONS_FOR_SALE_EMPTY = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_SEE_ZONE_MINIONS_FOR_SALE_EMPTY");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_BUY_MINION = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_BUY_MINION");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_SELL_MINION = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_SELL_MINION");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN_FOR_N_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_FREEZE_TAVERN_FOR_N_GOLD");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_UNFREEZE_TAVERN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_UNFREEZE_TAVERN");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_REFRESH_TAVERN_FOR_N_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_REFRESH_TAVERN_FOR_N_GOLD");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_UPGRADE_TAVERN_FOR_N_GOLD = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_UPGRADE_TAVERN_FOR_N_GOLD");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_ANOMALY = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_ANOMALY");
+
+    // Battlegrounds cont'd
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_LAST_POSITION = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_LAST_POSITION");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_FIRST_POSITION = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_TO_FIRST_POSITION");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_BETWEEN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_QUERY_MOVE_MINION_BETWEEN");
+
+    // Battlegrounds in-game stats
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_LEADERBOARD_STATS_PLAYER_TRIPLES_CREATED = CreateKey("GLUE_BACON_STATS_LABEL_TRIPLES");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_DEALT_DAMAGE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_DEALT_DAMAGE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TOOK_DAMAGE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TOOK_DAMAGE");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TIED = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_LEADERBOARDS_PLAYER_STATS_TIED");
+
+    // Battlegrounds diffs
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_TAVERN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_TAVERN");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_TAVERN = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_TAVERN");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_HAND = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARD_ADDED_TO_HAND");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_HAND = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_MOVEMENT_CARDS_ADDED_TO_HAND");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME_IN_LIST = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_BARTENDER_ENTITY_FULL_NAME_IN_LIST");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_MINIONS = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_MINIONS");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_OTHER_BARTENDER_MINIONS = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_OTHER_BARTENDER_MINIONS");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_SAME_NAME_ENTITIES = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_DIFF_GROUP_BARTENDER_SAME_NAME_ENTITIES");
+
+    // Battlegrounds cont'd
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_PLAYER_WON = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_PLAYER_WON");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_OPPONENT_WON = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_OPPONENT_WON");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_DIED = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_DIED");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_REMAINING = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_COMBAT_PHASE_ENDED_N_PLAYERS_REMAINING");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_BUDDY_METER = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_BUDDY_METER");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_ZONE_HERO_BUDDY = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_ZONE_HERO_BUDDY");
+
+    // Battlegrounds help messages
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_PLAYER_GOLD_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_TAVERN_INFORMATION_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_TAVERN_INFORMATION_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_HERO_BUDDY_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_HERO_BUDDY_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_NEXT_OPPONENT_STATS_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_NEXT_OPPONENT_STATS_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_LEADERBOARD_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_LEADERBOARD_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_MY_STATS_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_MY_STATS_HELP");
+    public static LocalizationKey BATTLEGROUNDS_GAMEPLAY_READ_RACES_IN_GAME_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_GAMEPLAY_READ_RACES_IN_GAME_HELP");
+
+    // UI
+    public static LocalizationKey UI_POPUP = CreateKey("ACCESSIBILITY_UI_POPUP");
+    public static LocalizationKey UI_REWARDS_TITLE = CreateKey("ACCESSIBILITY_UI_REWARDS_TITLE");
+    public static LocalizationKey UI_UNKNOWN_POPUP = CreateKey("ACCESSIBILITY_UI_UNKNOWN_POPUP");
+    public static LocalizationKey UI_UNKNOWN_DIALOG = CreateKey("ACCESSIBILITY_UI_UNKNOWN_DIALOG");
+
+    // Alert Popup
+    public static LocalizationKey UI_ALERT_POPUP_TITLE = CreateKey("ACCESSIBILITY_UI_ALERT_POPUP_TITLE");
+
+    // Core Set Popup
+    public static LocalizationKey UI_CORE_SET_POPUP_HEADER = CreateKey("GLUE_CORE_SET_POPUP_HEADER");
+    public static LocalizationKey UI_CORE_SET_POPUP_SUBHEADER = CreateKey("GLUE_CORE_SET_POPUP_SUBHEADER");
+
+    // Reward scroll
+    public static LocalizationKey UI_REWARD_SCROLL_HELP = CreateKey("ACCESSIBILITY_UI_REWARD_SCROLL_HELP");
+
+    // Quest notification popup
+    public static LocalizationKey UI_QUEST_NOTIFICATION_POPUP_HELP = CreateKey("ACCESSIBILITY_UI_QUEST_NOTIFICATION_POPUP_HELP");
+
+    // Welcome quests
+    public static LocalizationKey UI_WELCOME_QUESTS_HELP = CreateKey("ACCESSIBILITY_UI_WELCOME_QUESTS_HELP");
+
+    // Reward
+    public static LocalizationKey UI_REWARD_TITLE = CreateKey("ACCESSIBILITY_UI_REWARD_TITLE");
+    public static LocalizationKey UI_REWARD_HELP = CreateKey("ACCESSIBILITY_UI_REWARD_HELP");
+
+    // Ranked intro popup
+    public static LocalizationKey UI_RANKED_INTRO_POPUP = CreateKey("ACCESSIBILITY_UI_RANKED_INTRO_POPUP");
+
+    // Ranked bonus stars popup
+    public static LocalizationKey UI_RANKED_BONUS_STARS_POPUP = CreateKey("ACCESSIBILITY_UI_RANKED_BONUS_STARS_POPUP");
+
+    // Set rotation rotated boosters popup
+    public static LocalizationKey UI_SET_ROTATION_ROTATED_BOOSTERS_POPUP_TITLE = CreateKey("GLUE_ROTATED_SETS_DIALOG");
+
+    // Reconnect helper dialog
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RECONNECTING = CreateKey("GLOBAL_RECONNECT_RECONNECTING_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_TITLE = CreateKey("ACCESSIBILITY_UI_RECONNECT_HELPER_DIALOG_TITLE");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_OFFLINE = CreateKey("GLUE_RECONNECT_HELPER_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RECONNECT_REQUIRED = CreateKey("GLUE_RECONNECT_HELPER_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RECONNECT_FAILED = CreateKey("GLUE_RECONNECT_HELPER_FAILED_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_NO_INTERNET = CreateKey("GLUE_RECONNECT_HELPER_ACCESS_DISABLED_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER = CreateKey("GLUE_RECONNECT_HELPER_BAD_VERSION_HEADER");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY = CreateKey("GLUE_RECONNECT_HELPER_BAD_VERSION_RESET_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_INACTIVE_TIMEOUT = CreateKey("GLUE_RECONNECT_HELPER_INACTIVE_TIMEOUT_BODY");
+    public static LocalizationKey UI_RECONNECT_HELPER_DIALOG_RESTART_REQUIRED = CreateKey("GLUE_RECONNECT_HELPER_RESET_REQUIRED_BODY");
+
+    // Season end dialog
+    public static LocalizationKey UI_SEASON_END_DIALOG_RANK_EARNED = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_RANK_EARNED");
+    public static LocalizationKey UI_SEASON_END_DIALOG_CHEST_EARNED = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_CHEST_EARNED");
+    public static LocalizationKey UI_SEASON_END_DIALOG_CHEST_EARNED_HELP = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_CHEST_EARNED_HELP");
+    public static LocalizationKey UI_SEASON_END_DIALOG_SEASON_WELCOME = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_SEASON_WELCOME");
+    public static LocalizationKey UI_SEASON_END_DIALOG_REDUCED_WELCOME = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_REDUCED_WELCOME");
+    public static LocalizationKey UI_SEASON_END_DIALOG_REMINDER_CHEST = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_REMINDER_CHEST");
+    public static LocalizationKey UI_SEASON_END_DIALOG_REMINDER_CARDBACK = CreateKey("ACCESSIBILITY_UI_SEASON_END_DIALOG_REMINDER_CARDBACK");
+
+    // Card list popup
+    public static LocalizationKey UI_CARD_LIST_POPUP_HELP = CreateKey("ACCESSIBILITY_UI_CARD_LIST_POPUP_HELP");
+
+    // Chest reward display
+    public static LocalizationKey UI_CHEST_REWARD_DISPLAY_TITLE = CreateKey("ACCESSIBILITY_UI_CHEST_REWARD_DISPLAY_TITLE");
+    public static LocalizationKey UI_CHEST_REWARD_DISPLAY_HELP = CreateKey("ACCESSIBILITY_UI_CHEST_REWARD_DISPLAY_HELP");
+
+    // Reward boxes display
+    public static LocalizationKey UI_REWARD_BOXES_DISPLAY_TITLE = CreateKey("ACCESSIBILITY_UI_REWARD_BOXES_DISPLAY_TITLE");
+    public static LocalizationKey UI_REWARD_BOXES_DISPLAY_HELP = CreateKey("ACCESSIBILITY_UI_REWARD_BOXES_DISPLAY_HELP");
+
+    // Quests (via AccessibleQuest)
+    public static LocalizationKey UI_QUEST_NO_NAME_XP_ONLY = CreateKey("ACCESSIBILITY_UI_QUEST_NO_NAME_XP_ONLY");
+    public static LocalizationKey UI_QUEST_REWARD_DESCRIPTION = CreateKey("ACCESSIBILITY_UI_QUEST_REWARD_DESCRIPTION");
+    public static LocalizationKey UI_QUEST_REWARD_CHOOSE_ONE_DESCRIPTION = CreateKey("ACCESSIBILITY_UI_QUEST_REWARD_CHOOSE_ONE_DESCRIPTION");
+
+    // Quest log
+    public static LocalizationKey UI_QUEST_LOG_NO_QUESTS = CreateKey("ACCESSIBILITY_UI_QUEST_LOG_NO_QUESTS");
+    public static LocalizationKey UI_QUEST_LOG_ABANDON_QUEST = CreateKey("ACCESSIBILITY_UI_QUEST_LOG_ABANDON_QUEST");
+    public static LocalizationKey UI_QUEST_LOG_REROLL_QUEST = CreateKey("ACCESSIBILITY_UI_QUEST_LOG_REROLL_QUEST");
+
+    // Rewards track XP gains
+    public static LocalizationKey UI_TRACK_REWARD_LEVEL_UP = CreateKey("ACCESSIBILITY_UI_TRACK_REWARD_LEVEL_UP");
+    public static LocalizationKey UI_TRACK_REWARD_XP_GAIN = CreateKey("ACCESSIBILITY_UI_TRACK_REWARD_XP_GAIN");
+    public static LocalizationKey UI_TRACK_REWARD_XP_GAIN_FROM_QUEST = CreateKey("ACCESSIBILITY_UI_TRACK_REWARD_XP_GAIN_FROM_QUEST");
+
+    // Rank changes
+    public static LocalizationKey UI_RANK_CHANGE_UI_CURRENT_RANK = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_CURRENT_RANK");
+    public static LocalizationKey UI_RANK_CHANGE_UI_NEW_RANK = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_NEW_RANK");
+    public static LocalizationKey UI_RANK_CHANGE_UI_CURRENT_STARS = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_CURRENT_STARS");
+    public static LocalizationKey UI_RANK_CHANGE_UI_EARNED_STARS = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_EARNED_STARS");
+    public static LocalizationKey UI_RANK_CHANGE_UI_LOST_STARS = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_LOST_STARS");
+    public static LocalizationKey UI_RANK_CHANGE_UI_STAR_BONUS_MULT = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_STAR_BONUS_MULT");
+    public static LocalizationKey UI_RANK_CHANGE_UI_WIN_STREAK_MULT = CreateKey("ACCESSIBILITY_UI_RANK_CHANGE_UI_WIN_STREAK_MULT");
+
+    // Battlegrounds UI stuff
+    public static LocalizationKey UI_BATTLEGROUNDS_RATING_CHANGE_INCREASED = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_RATING_CHANGE_INCREASED");
+    public static LocalizationKey UI_BATTLEGROUNDS_RATING_CHANGE_DECREASED = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_RATING_CHANGE_DECREASED");
+    public static LocalizationKey UI_BATTLEGROUNDS_RATING_CHANGE_NEW_RATING = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_RATING_CHANGE_NEW_RATING");
+    public static LocalizationKey UI_BATTLEGROUNDS_RATING_NO_CHANGE = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_RATING_NO_CHANGE");
+    public static LocalizationKey UI_BATTLEGROUNDS_MULLIGAN_PLAYERS_READY = CreateKey("ACCESSIBILITY_UI_BATTLEGROUNDS_MULLIGAN_PLAYERS_READY");
+
+    // Rewards
+    public static LocalizationKey UI_REWARD_TYPE_REWARD_PACKAGE = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_REWARD_PACKAGE");
+    public static LocalizationKey UI_REWARD_TYPE_ARCANE_DUST = CreateKey("GLUE_CRAFTING_ARCANEDUST");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_CARD_PACK = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_CARD_PACK");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_CARD = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_CARD");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_CARD_BACK = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_CARD_BACK");
+    public static LocalizationKey UI_REWARD_TYPE_GOLD = CreateKey("GLUE_TOOLTIP_GOLD_HEADER");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_MOUNT = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_MOUNT");
+    public static LocalizationKey UI_REWARD_TYPE_ARCANE_ORBS = CreateKey("GLUE_TOOLTIP_BOOSTER_CURRENCY_HEADER");
+    public static LocalizationKey UI_REWARD_TYPE_ONE_MINI_SET = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_ONE_MINI_SET");
+    public static LocalizationKey UI_REWARD_TYPE_UNKNOWN = CreateKey("ACCESSIBILITY_UI_REWARD_TYPE_UNKNOWN");
+    public static LocalizationKey UI_REWARD_N_TICKETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_TICKETS");
+    public static LocalizationKey UI_REWARD_MINI_SET_WITH_N_CARDS = CreateKey("ACCESSIBILITY_UI_REWARD_MINI_SET_WITH_N_CARDS");
+    public static LocalizationKey UI_REWARD_N_ARCANE_ORBS = CreateKey("ACCESSIBILITY_UI_REWARD_N_ARCANE_ORBS");
+    public static LocalizationKey UI_REWARD_N_ARCANE_DUST = CreateKey("ACCESSIBILITY_UI_REWARD_N_ARCANE_DUST");
+    public static LocalizationKey UI_REWARD_N_CARD_PACKS = CreateKey("ACCESSIBILITY_UI_REWARD_N_CARD_PACKS");
+    public static LocalizationKey UI_REWARD_N_GOLD = CreateKey("ACCESSIBILITY_UI_REWARD_N_GOLD");
+    public static LocalizationKey UI_REWARD_CARD_FROM_CLASS = CreateKey("ACCESSIBILITY_UI_REWARD_CARD_FROM_CLASS");
+    public static LocalizationKey UI_REWARD_CORE_CARD_FROM_CLASS = CreateKey("ACCESSIBILITY_UI_REWARD_CORE_CARD_FROM_CLASS");
+    public static LocalizationKey UI_REWARD_GOLDEN_HERO = CreateKey("ACCESSIBILITY_UI_REWARD_GOLDEN_HERO");
+    public static LocalizationKey UI_REWARD_CLASS_HERO = CreateKey("ACCESSIBILITY_UI_REWARD_CLASS_HERO");
+    public static LocalizationKey UI_REWARD_CLASS_UNLOCK_PROGRESS = CreateKey("ACCESSIBILITY_UI_REWARD_CLASS_UNLOCK_PROGRESS");
+    public static LocalizationKey UI_REWARD_NEW_CLASS_UNLOCKED = CreateKey("GLUE_CLASS_UNLOCKED_CLASS");
+    public static LocalizationKey UI_REWARD_CARD = CreateKey("ACCESSIBILITY_UI_REWARD_CARD");
+    public static LocalizationKey UI_REWARD_N_HERO_SKINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_HERO_SKINS");
+    public static LocalizationKey UI_REWARD_N_CARD_BACKS = CreateKey("ACCESSIBILITY_UI_REWARD_N_CARD_BACKS");
+    public static LocalizationKey UI_REWARD_N_ARENA_TICKETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_ARENA_TICKETS");
+    public static LocalizationKey UI_REWARD_N_RUNESTONES = CreateKey("ACCESSIBILITY_UI_REWARD_N_RUNESTONES");
+    public static LocalizationKey UI_REWARD_N_ADVENTURES = CreateKey("ACCESSIBILITY_UI_REWARD_N_ADVENTURES");
+    public static LocalizationKey UI_REWARD_N_TAVERN_BRAWL_TICKETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_TAVERN_BRAWL_TICKETS");
+    public static LocalizationKey UI_REWARD_N_CUSTOM_COINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_CUSTOM_COINS");
+    public static LocalizationKey UI_REWARD_XP_BOOST = CreateKey("ACCESSIBILITY_UI_REWARD_XP_BOOST");
+    public static LocalizationKey UI_REWARD_N_MINI_SETS = CreateKey("ACCESSIBILITY_UI_REWARD_N_MINI_SETS");
+    public static LocalizationKey UI_REWARD_N_BATTLEGROUNDS_HERO_SKINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_BATTLEGROUNDS_HERO_SKINS");
+    public static LocalizationKey UI_REWARD_N_BATTLEGROUNDS_GUIDE_SKINS = CreateKey("ACCESSIBILITY_UI_REWARD_N_BATTLEGROUNDS_GUIDE_SKINS");
+    public static LocalizationKey UI_REWARD_DECK = CreateKey("ACCESSIBILITY_UI_REWARD_DECK");
+    public static LocalizationKey UI_REWARD_LOANER_DECKS = CreateKey("ACCESSIBILITY_UI_REWARD_LOANER_DECKS");
+    public static LocalizationKey UI_REWARD_GAME_MODE = CreateKey("ACCESSIBILITY_UI_REWARD_GAME_MODE");
+    public static LocalizationKey UI_REWARD_NEW_CLASS_STRENGTHS = CreateKey("ACCESSIBILITY_UI_REWARD_NEW_CLASS_STRENGTHS");
+    public static LocalizationKey UI_REWARD_NEW_CLASS_WEAKNESSES = CreateKey("ACCESSIBILITY_UI_REWARD_NEW_CLASS_WEAKNESSES");
+
+    // Choose free deck UI
+    public static LocalizationKey UI_CHOOSE_FREE_DECK_TITLE = CreateKey("GLUE_FREE_DECK_POPUP_TITLE");
+
+    // Social
+    public static LocalizationKey UI_SOCIAL_MENU_NAME = CreateKey("ACCESSIBILITY_UI_SOCIAL_MENU_NAME");
+    public static LocalizationKey UI_SOCIAL_BATTLETAG_COPIED_TO_CLIPBOARD = CreateKey("ACCESSIBILITY_UI_SOCIAL_BATTLETAG_COPIED_TO_CLIPBOARD");
+    public static LocalizationKey UI_SOCIAL_CHAT_MESSAGE_RECEIVED = CreateKey("ACCESSIBILITY_UI_SOCIAL_CHAT_MESSAGE_RECEIVED");
+    public static LocalizationKey UI_SOCIAL_CHAT_MESSAGE_SENT = CreateKey("ACCESSIBILITY_UI_SOCIAL_CHAT_MESSAGE_SENT");
+    public static LocalizationKey UI_SOCIAL_CHAT_SEND_MESSAGE = CreateKey("ACCESSIBILITY_UI_SOCIAL_CHAT_SEND_MESSAGE");
+    public static LocalizationKey UI_SOCIAL_CHAT_TYPE_MESSAGE_PROMPT = CreateKey("ACCESSIBILITY_UI_SOCIAL_CHAT_TYPE_MESSAGE_PROMPT");
+    public static LocalizationKey UI_SOCIAL_INVITE_FRIEND_TO_BG = CreateKey("ACCESSIBILITY_UI_SOCIAL_INVITE_FRIEND_TO_BG");
+    public static LocalizationKey UI_SOCIAL_FRIEND_NO_CHALLENGE = CreateKey("ACCESSIBILITY_UI_SOCIAL_FRIEND_NO_CHALLENGE");
+
+    // Reporting popup
+    public static LocalizationKey UI_REPORTING_POPUP_NO_SUBCOMPLAINTS_SELECTED = CreateKey("ACCESSIBILITY_UI_REPORTING_POPUP_NO_SUBCOMPLAINTS_SELECTED");
+
+    // Rewards Track
+    public static LocalizationKey UI_REWARDS_TRACK_READ_LEVEL = CreateKey("ACCESSIBILITY_UI_REWARDS_TRACK_READ_LEVEL");
+    public static LocalizationKey UI_REWARDS_TRACK_XP_PROGRESS = CreateKey("ACCESSIBILITY_UI_REWARDS_TRACK_XP_PROGRESS");
+    public static LocalizationKey UI_REWARDS_TRACK_CLAIM_REWARDS = CreateKey("ACCESSIBILITY_UI_REWARDS_TRACK_CLAIM_REWARDS");
+    public static LocalizationKey UI_REWARDS_TRACK_CLAIM_REWARDS_NO_REWARDS = CreateKey("ACCESSIBILITY_UI_REWARDS_TRACK_CLAIM_REWARDS_NO_REWARDS");
+    public static LocalizationKey UI_REWARDS_TRACK_DECK_CHOICE_CONFIRMATION_PROMPT = CreateKey("ACCESSIBILITY_UI_REWARDS_TRACK_DECK_CHOICE_CONFIRMATION_PROMPT");
+    public static LocalizationKey UI_REWARDS_TRACK_BROWSE_DECK_HELP = CreateKey("ACCESSIBILITY_UI_REWARDS_TRACK_BROWSE_DECK_HELP");
+
+    // Shop
+    public static LocalizationKey UI_SHOP_READ_GOLD = CreateKey("ACCESSIBILITY_UI_SHOP_READ_GOLD");
+    public static LocalizationKey UI_SHOP_READ_RUNESTONES = CreateKey("ACCESSIBILITY_UI_SHOP_READ_RUNESTONES");
+    public static LocalizationKey UI_SHOP_BUY_PACKS = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_PACKS");
+    public static LocalizationKey UI_SHOP_BUY_MINI_SETS = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_MINI_SETS");
+    public static LocalizationKey UI_SHOP_BUY_HERO_SKINS = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_HERO_SKINS");
+    public static LocalizationKey UI_SHOP_BUY_BUNDLES = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_BUNDLES");
+    public static LocalizationKey UI_SHOP_BUY_OTHERS = CreateKey("ACCESSIBILITY_UI_SHOP_BUY_OTHERS");
+    public static LocalizationKey UI_SHOP_ITEM_READ_DESCRIPTION = CreateKey("ACCESSIBILITY_UI_SHOP_ITEM_READ_DESCRIPTION");
+    public static LocalizationKey UI_SHOP_ITEM_BUY_FOR_N_GOLD = CreateKey("ACCESSIBILITY_UI_SHOP_ITEM_BUY_FOR_N_GOLD");
+    public static LocalizationKey UI_SHOP_ITEM_BUY_FOR_N_RUNESTONES = CreateKey("ACCESSIBILITY_UI_SHOP_ITEM_BUY_FOR_N_RUNESTONES");
+    public static LocalizationKey UI_SHOP_ITEM_GET_FOR_FREE = CreateKey("ACCESSIBILITY_UI_SHOP_ITEM_GET_FOR_FREE");
+    public static LocalizationKey UI_SHOP_READ_CARDS = CreateKey("ACCESSIBILITY_UI_SHOP_READ_CARDS");
+    public static LocalizationKey UI_SHOP_READ_CARDS_HELP = CreateKey("ACCESSIBILITY_UI_SHOP_READ_CARDS_HELP");
+    public static LocalizationKey UI_SHOP_PURCHASE_COMPLETE_GOLD_REMAINING = CreateKey("ACCESSIBILITY_UI_SHOP_PURCHASE_COMPLETE_GOLD_REMAINING");
+    public static LocalizationKey UI_SHOP_PURCHASE_COMPLETE_RUNESTONES_REMAINING = CreateKey("ACCESSIBILITY_UI_SHOP_PURCHASE_COMPLETE_RUNESTONES_REMAINING");
+    public static LocalizationKey UI_SHOP_NOT_ENOUGH_RUNESTONES = CreateKey("ACCESSIBILITY_UI_SHOP_NOT_ENOUGH_RUNESTONES");
+
+    // Screens
+    public static LocalizationKey SCREEN_GO_BACK = CreateKey("ACCESSIBILITY_SCREEN_GO_BACK");
+
+    // Fatal error screen
+    public static LocalizationKey SCREEN_FATAL_ERROR_SCREEN_TITLE = CreateKey("ACCESSIBILITY_SCREEN_FATAL_ERROR_SCREEN_TITLE");
+
+    // End game screen
+    public static LocalizationKey SCREEN_END_GAME_SCREEN_HERO_LEVEL_UP = CreateKey("ACCESSIBILITY_SCREEN_END_GAME_SCREEN_HERO_LEVEL_UP");
+
+    // Coose adventurer screen
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURER_SCREEN_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURER_SCREEN_TITLE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP");
+
+    // Adventure screen
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_TITLE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_TITLE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_CHOOSE_ADVENTURER_TITLE = CreateKey("GLUE_CHOOSE_YOUR_HERO");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_CHOOSE_CHAPTER_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_CHAPTER_TITLE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_CHOOSE_MISSION_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_MISSION_TITLE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_CHOOSE_MISSION_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_MISSION_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_MISSION_LOCKED = CreateKey("ACCESSIBILITY_SCREEN_MISSION_LOCKED");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_MISSION_AVAILABLE = CreateKey("ACCESSIBILITY_SCREEN_MISSION_AVAILABLE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_MISSION_COMPLETED = CreateKey("ACCESSIBILITY_SCREEN_MISSION_COMPLETED");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_PLAYING_MISSION_LOCKED = CreateKey("ACCESSIBILITY_SCREEN_PLAYING_LOCKED_MISSION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_TITLE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_TITLE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_PLAY_OPTION = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_PLAY_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_WAITING_FOR_VO_HELP = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_WAITING_FOR_VO_HELP");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_CANT_READ_DECK = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_CANT_READ_DECK");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE");
+    public static LocalizationKey SCREEN_ADVENTURE_SCREEN_PROGRESS_MESSAGE = CreateKey("ACCESSIBILITY_SCREEN_ADVENTURE_SCREEN_PROGRESS_MESSAGE");
+
+    // Choose adventure screen
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_TITLE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_PRACTICE_OPTION = CreateKey("GLUE_PRACTICE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_HEROES_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_HEROES_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_MERCENARIES_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_BOOK_OF_MERCENARIES_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_ASHES_PROLOGUE_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_ASHES_PROLOGUE_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_DEATH_KNIGHT_PROLOGUE_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_MENU_DEATH_KNIGHT_PROLOGUE_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_TITLE = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_TITLE");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_NORMAL_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_NORMAL_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_EXPERT_OPTION = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_DIFFICULTY_MENU_EXPERT_OPTION");
+    public static LocalizationKey SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_EXPERT_LOCKED = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_ADVENTURE_SCREEN_PRACTICE_CHOOSE_EXPERT_LOCKED");
+
+    // Choose opponent menu
+    public static LocalizationKey SCREEN_CHOOSE_OPPONENT_MENU_TITLE = CreateKey("GLUE_CHOOSE_OPPONENT");
+    public static LocalizationKey SCREEN_CHOOSE_OPPONENT_MENU_UNDEFEATED_OPPONENT_LABEL = CreateKey("ACCESSIBILITY_SCREEN_CHOOSE_OPPONENT_MENU_UNDEFEATED_OPPONENT_LABEL");
+
+    // Choose deck screen
+    public static LocalizationKey SCREEN_CHOOSE_DECK_TITLE = CreateKey("GLUE_CHOOSE_YOUR_DECK");
+    public static LocalizationKey SCREEN_CHOOSE_DECK_HERO_LEVEL = CreateKey("GLOBAL_PROGRESSION_TOOLTIP_CLASS_DEFAULT_DESC");
+    public static LocalizationKey SCREEN_CHOOSE_DECK_COLLECTION_AVAILABLE = CreateKey("ACCESSIBILITY_CHOOSE_DECK_COLLECTION_AVAILABLE");
+
+    // My collection screen
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_BROWSE_COLLECTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_MY_DECKS = CreateKey("GLUE_COLLECTION_MY_DECKS");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_NEW_DECK = CreateKey("GLUE_COLLECTION_NEW_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_DELETE_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_DELETE_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_RECIPE_OWNED_CARDS_COUNT = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_RECIPE_OWNED_CARDS_COUNT");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_RECIPE_CHOOSE_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_RECIPE_CHOOSE_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CUSTOM_DECK_CHOOSE_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CUSTOM_DECK_CHOOSE_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_ADD_CARDS_OPTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_ADD_CARDS_OPTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_SIDEBOARD_OPTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_SIDEBOARD_OPTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_LOAD_SAVED_VERSION_OPTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_LOAD_SAVED_VERSION_OPTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_BACK_TO_DECK_OPTION = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_BACK_TO_DECK_OPTION");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_SIDEBOARD = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION_EMPTY_SIDEBOARD");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_INVALID_CARD = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_INVALID_CARD");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_SIDEBOARD = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_SIDEBOARD");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_RENAME_DECK_OPTION = CreateKey("GLUE_COLLECTION_DECK_RENAME");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_COPY_DECK_OPTION = CreateKey("GLUE_COLLECTION_DECK_COPY_TOOLTIP_HEADLINE");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_SIDEBOARD = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_SIDEBOARD");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_FORMAT_CHANGED = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_FORMAT_CHANGED");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_COLLECTION_PAGE_NUM = CreateKey("GLUE_COLLECTION_PAGE_NUM");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_COLLECTION_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_COLLECTION_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_COLLECTION_FILTERS_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_COLLECTION_FILTERS_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_COINS_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_COINS_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_CARD_BACKS_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_CARD_BACKS_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_HERO_SKINS_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_HERO_SKINS_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_READ_BATTLEGROUNDS_HERO_SKINS_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_READ_BATTLEGROUNDS_HERO_SKINS_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_ADD_CARD_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_ADD_CARD_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_REMOVE_CARD_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_CRAFT_CARD_HELP = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_CRAFT_CARD_HELP");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_EDIT_DECK_RENAME_DECK_PROMPT");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_SEARCH_PROMPT = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_SEARCH_PROMPT");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_MANA_FILTER_ON = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_MANA_FILTER_ON");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_MANA_FILTER_OFF = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_MANA_FILTER_OFF");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CHANGE_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CHANGE_SET");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_FAVORITE_HERO_SKIN_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_FAVORITE_HERO_SKIN_SET");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_FAVORITE_BATTLEGROUNDS_GUIDE_SKIN_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_FAVORITE_BATTLEGROUNDS_GUIDE_SKIN_SET");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_FAVORITE_BATTLEGROUNDS_FINISHER_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_FAVORITE_BATTLEGROUNDS_FINISHER_SET");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_FAVORITE_CARD_BACK_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_FAVORITE_CARD_BACK_SET");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_FAVORITE_COIN_SET = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_FAVORITE_COIN_SET");
+
+    // Crafting
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARDS = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARDS");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_READ_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_READ_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_MASS_DISENCHANT_FOR_N_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_MASS_DISENCHANT_FOR_N_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_READ_CARD = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_READ_CARD");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_READ_RELATED_CARDS = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_READ_RELATED_CARDS");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_FOR_N_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_FOR_N_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_CARD_FOR_N_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_CARD_FOR_N_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_NOT_ENOUGH_DUST = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_NOT_ENOUGH_DUST");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_CARD_LIMIT_REACHED = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_ERROR_CARD_LIMIT_REACHED");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_DONE = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_CRAFT_CARD_DONE");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_DONE = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_CRAFTING_DISENCHANT_DONE");
+
+    // Battlegrounds collection
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_BROWSE_HERO_SKINS = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_BROWSE_HERO_SKINS");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_BROWSE_GUIDE_SKINS = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_BROWSE_GUIDE_SKINS");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_BROWSE_FINISHERS = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_BROWSE_FINISHERS");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_HERO_SKIN_FILTER_MODE_OWNED = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_HERO_SKIN_FILTER_MODE_OWNED");
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_HERO_SKIN_FILTER_MODE_ALL = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_BATTLEGROUNDS_HERO_SKIN_FILTER_MODE_ALL");
+
+    // Pack opening screen
+    public static LocalizationKey SCREEN_PACK_OPENING_OPEN_CARDS_HELP = CreateKey("ACCESSIBILITY_SCREEN_PACK_OPENING_OPEN_CARDS_HELP");
+    public static LocalizationKey SCREEN_PACK_OPENING_MASS_PACK_OPENING_HELP = CreateKey("ACCESSIBILITY_SCREEN_PACK_OPENING_MASS_PACK_OPENING_HELP");
+    public static LocalizationKey SCREEN_PACK_OPENING_CATCHUP_PACK_OPENING_HELP = CreateKey("ACCESSIBILITY_SCREEN_PACK_OPENING_CATCHUP_PACK_OPENING_HELP");
+    public static LocalizationKey SCREEN_PACK_OPENING_NO_CARD_PACKS = CreateKey("ACCESSIBILITY_SCREEN_PACK_OPENING_NO_CARD_PACKS");
+
+    // Mass pack opening
+    public static LocalizationKey MASS_PACK_OPENING_QUANTITY_PROMPT = CreateKey("ACCESSIBILITY_MASS_PACK_OPENING_QUANTITY_PROMPT");
+    public static LocalizationKey MASS_PACK_OPENING_QUANTITY_PROMPT_ERROR = CreateKey("ACCESSIBILITY_MASS_PACK_OPENING_QUANTITY_PROMPT_ERROR");
+
+    public static LocalizationKey MASS_PACK_OPENING_SUMMARY_LEGENDARY_COUNT = CreateKey("ACCESSIBILITY_MASS_PACK_OPENING_SUMMARY_LEGENDARY_COUNT");
+    public static LocalizationKey MASS_PACK_OPENING_SUMMARY_EPIC_COUNT = CreateKey("ACCESSIBILITY_MASS_PACK_OPENING_SUMMARY_EPIC_COUNT");
+    public static LocalizationKey MASS_PACK_OPENING_SUMMARY_RARE_COUNT = CreateKey("ACCESSIBILITY_MASS_PACK_OPENING_SUMMARY_RARE_COUNT");
+    public static LocalizationKey MASS_PACK_OPENING_SUMMARY_COMMON_COUNT = CreateKey("ACCESSIBILITY_MASS_PACK_OPENING_SUMMARY_COMMON_COUNT");
+    public static LocalizationKey MASS_PACK_OPENING_SUMMARY_CLASS_COUNT = CreateKey("ACCESSIBILITY_MASS_PACK_OPENING_SUMMARY_CLASS_COUNT");
+    public static LocalizationKey MASS_PACK_OPENING_SUMMARY_HELP = CreateKey("ACCESSIBILITY_MASS_PACK_OPENING_SUMMARY_HELP");
+
+    // Deck picker
+    public static LocalizationKey SCREEN_DECK_PICKER_TRAY_DISPLAY_LOANER_DECK = CreateKey("ACCESSIBILITY_SCREEN_DECK_PICKER_TRAY_DISPLAY_LOANER_DECK");
+
+    // Hearthstone/Play screen
+    public static LocalizationKey SCREEN_HEARTHSTONE_RANKED_READ_RANK = CreateKey("ACCESSIBILITY_SCREEN_HEARTHSTONE_RANKED_READ_RANK");
+    public static LocalizationKey SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STARS = CreateKey("ACCESSIBILITY_SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STARS");
+    public static LocalizationKey SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STAR_BONUS = CreateKey("ACCESSIBILITY_SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STAR_BONUS");
+
+    // Hearthstone (virtual) menu
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_RANKED = CreateKey("GLOBAL_PLAY_RANKED");
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_CASUAL = CreateKey("GLUE_PLAY_CASUAL");
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_HEARTHSTONE = CreateKey("ACCESSIBILITY_SCREEN_HEARTHSTONE_PLAY_HEARTHSTONE");
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_STANDARD = CreateKey("GLOBAL_PLAY_STANDARD");
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_WILD = CreateKey("GLOBAL_PLAY_WILD");
+    public static LocalizationKey SCREEN_HEARTHSTONE_PLAY_TWIST = CreateKey("GLUE_PLAY_TWIST");
+
+    // Battlegrounds screen menus
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_SEE_PARTY = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_SEE_PARTY");
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_READ_STATS = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_READ_STATS");
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_OPTIONS_NARRATE_ATTACKS = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_OPTIONS_NARRATE_ATTACKS");
+
+    //Battlegrounds party screen
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_PARTY_MEMBER_WAITING = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_PARTY_MEMBER_WAITING");
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_PARTY_MEMBER_READY = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_PARTY_MEMBER_READY");
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_PARTY_MEMBER_LEADER = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_PARTY_MEMBER_LEADER");
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_PARTY_MEMBER_NOT_READY = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_PARTY_MEMBER_NOT_READY");
+    public static LocalizationKey SCREEN_BATTLEGROUNDS_PARTY_MEMBER_SPECTATE = CreateKey("ACCESSIBILITY_SCREEN_BATTLEGROUNDS_PARTY_MEMBER_SPECTATE");
+
+    // Duels main menu
+    public static LocalizationKey SCREEN_DUELS_READ_STATS = CreateKey("ACCESSIBILITY_DUELS_READ_STATS");
+    public static LocalizationKey SCREEN_DUELS_CHOOSE_TYPE = CreateKey("ACCESSIBILITY_DUELS_CHOOSE_TYPE");
+    public static LocalizationKey SCREEN_DUELS_LOSSES_COUNT = CreateKey("ACCESSIBILITY_DUELS_LOSSES_COUNT");
+    public static LocalizationKey DUELS_CHOOSE_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_DUELS_CHOOSE_HERO_POWER_HELP");
+    public static LocalizationKey DUELS_CHOOSE_STARTER_TREASURE_HELP = CreateKey("ACCESSIBILITY_DUELS_CHOOSE_STARTER_TREASURE_HELP");
+    public static LocalizationKey DUELS_CHOOSE_TREASURE_REWARD_HELP = CreateKey("ACCESSIBILITY_DUELS_CHOOSE_TREASURE_REWARD_HELP");
+    public static LocalizationKey DUELS_CHOOSE_LOOT_HELP = CreateKey("ACCESSIBILITY_DUELS_CHOOSE_LOOT_HELP");
+    public static LocalizationKey DUELS_HEROIC_RUN_ENDED = CreateKey("ACCESSIBILITY_DUELS_HEROIC_RUN_ENDED");
+
+    // Quest progress toast
+    public static LocalizationKey TOAST_QUEST_PROGRESS_TOAST_TITLE = CreateKey("ACCESSIBILITY_TOAST_QUEST_PROGRESS_TOAST_TITLE");
+    public static LocalizationKey TOAST_QUEST_PROGRESS_TOAST_PROGRESS = CreateKey("ACCESSIBILITY_TOAST_QUEST_PROGRESS_TOAST_PROGRESS");
+
+    // Quest toast
+    public static LocalizationKey TOAST_QUEST_TOAST_TITLE = CreateKey("ACCESSIBILITY_TOAST_QUEST_TOAST_TITLE");
+
+    // Collectible cards
+    public static LocalizationKey COLLECTION_CARD_NEW = CreateKey("GLUE_COLLECTION_CARD_NEW");
+
+    // Death knight runes
+    public static LocalizationKey READ_CARD_RUNE_BLOOD = CreateKey("ACCESSIBILITY_READ_CARD_RUNE_BLOOD");
+    public static LocalizationKey READ_CARD_RUNE_FROST = CreateKey("ACCESSIBILITY_READ_CARD_RUNE_FROST");
+    public static LocalizationKey READ_CARD_RUNE_UNHOLY = CreateKey("ACCESSIBILITY_READ_CARD_RUNE_UNHOLY");
+
+    // Tutorial
+    public static LocalizationKey TUTORIAL_LOADING_TUTORIAL = CreateKey("ACCESSIBILITY_TUTORIAL_LOADING_TUTORIAL");
+    public static LocalizationKey TUTORIAL_WELCOME_BACK = CreateKey("ACCESSIBILITY_TUTORIAL_WELCOME_BACK");
+    public static LocalizationKey NEW_TUTORIAL_DEFEATED_REXXAR = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_DEFEATED_REXXAR");
+    public static LocalizationKey NEW_TUTORIAL_DEFEATED_GARROSH = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_DEFEATED_GARROSH");
+    public static LocalizationKey NEW_TUTORIAL_DEFEATED_LICH_KING = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_DEFEATED_LICH_KING");
+    public static LocalizationKey NEW_TUTORIAL_NEXT_REXXAR = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_NEXT_REXXAR");
+    public static LocalizationKey NEW_TUTORIAL_NEXT_GARROSH = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_NEXT_GARROSH");
+    public static LocalizationKey NEW_TUTORIAL_NEXT_LICH_KING = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_NEXT_LICH_KING");
+
+    // Tutorial generic narrator speeches
+    public static LocalizationKey TUTORIAL_NARRATOR_INTRO = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO");
+    public static LocalizationKey NEW_TUTORIAL_NARRATOR_INTRO = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_NARRATOR_INTRO");
+    public static LocalizationKey TUTORIAL_NARRATOR_HELP_KEYS = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_HELP_KEYS");
+    public static LocalizationKey TUTORIAL_NARRATOR_INTRO_END = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO_END");
+    public static LocalizationKey TUTORIAL_FREE_STARTING_PACK = CreateKey("ACCESSIBILITY_TUTORIAL_FREE_STARTING_PACK");
+    public static LocalizationKey TUTORIAL_NICE_WORK = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_WORK");
+    public static LocalizationKey TUTORIAL_NICE_JOB = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_JOB");
+    public static LocalizationKey TUTORIAL_NICE_ONE = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_ONE");
+    public static LocalizationKey TUTORIAL_GOOD_JOB = CreateKey("ACCESSIBILITY_TUTORIAL_GOOD_JOB");
+    public static LocalizationKey TUTORIAL_YOU_GOT_IT = CreateKey("ACCESSIBILITY_TUTORIAL_YOU_GOT_IT");
+    public static LocalizationKey TUTORIAL_REMEMBER_HOW_TO_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_IT");
+    public static LocalizationKey TUTORIAL_REMEMBER_HOW_TO_DO_THAT = CreateKey("ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_THAT");
+    public static LocalizationKey TUTORIAL_TRY_IT_OUT = CreateKey("ACCESSIBILITY_TUTORIAL_TRY_IT_OUT");
+    public static LocalizationKey TUTORIAL_ALL_RIGHT = CreateKey("ACCESSIBILITY_TUTORIAL_ALL_RIGHT");
+    public static LocalizationKey TUTORIAL_LETS_LEARN_HOW = CreateKey("ACCESSIBILITY_TUTORIAL_LETS_LEARN_HOW");
+    public static LocalizationKey TUTORIAL_CAN_YOU_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_CAN_YOU_DO_IT");
+    public static LocalizationKey TUTORIAL_THINK_YOU_CAN_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_THINK_YOU_CAN_DO_IT");
+    public static LocalizationKey TUTORIAL_GOT_IT = CreateKey("ACCESSIBILITY_TUTORIAL_GOT_IT");
+    public static LocalizationKey TUTORIAL_NO_ENDTURN_ATK = CreateKey("TUTORIAL_NO_ENDTURN_ATK");
+    public static LocalizationKey TUTORIAL_NO_ENDTURN = CreateKey("TUTORIAL_NO_ENDTURN");
+    public static LocalizationKey TUTORIAL_NO_ENDTURN_HP = CreateKey("ACCESSIBILITY_TUTORIAL_NO_ENDTURN_HP");
+
+    // Tutorial Hogger
+    public static LocalizationKey TUTORIAL_HOGGER_START = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_START");
+    public static LocalizationKey TUTORIAL01_HELP_07 = CreateKey("TUTORIAL01_HELP_07");
+    public static LocalizationKey TUTORIAL01_HELP_08 = CreateKey("TUTORIAL01_HELP_08");
+    public static LocalizationKey TUTORIAL_HOGGER_FORCE_CARD_READ = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_CARD_READ");
+    public static LocalizationKey TUTORIAL_HOGGER_SUMMON_MINION_FIRST = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_SUMMON_MINION_FIRST");
+    public static LocalizationKey TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST");
+    public static LocalizationKey TUTORIAL_HOGGER_2_0 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_0");
+    public static LocalizationKey TUTORIAL_HOGGER_2_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_1");
+    public static LocalizationKey TUTORIAL_HOGGER_2_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2");
+    public static LocalizationKey TUTORIAL_HOGGER_2_2B = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2B");
+    public static LocalizationKey TUTORIAL_HOGGER_2_2D = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2D");
+    public static LocalizationKey TUTORIAL_HOGGER_2_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_3");
+    public static LocalizationKey TUTORIAL_HOGGER_2_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_4");
+    public static LocalizationKey TUTORIAL_HOGGER_2_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_5");
+    public static LocalizationKey TUTORIAL_HOGGER_2_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_6");
+    public static LocalizationKey TUTORIAL_HOGGER_3_0 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_0");
+    public static LocalizationKey TUTORIAL_HOGGER_3_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_1");
+    public static LocalizationKey TUTORIAL_HOGGER_3_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_2");
+    public static LocalizationKey TUTORIAL_HOGGER_3_2_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_2_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_3_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_3");
+    public static LocalizationKey TUTORIAL_HOGGER_3_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_4");
+    public static LocalizationKey TUTORIAL_HOGGER_3_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_5");
+    public static LocalizationKey TUTORIAL_HOGGER_3_5_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_5_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_3_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_6");
+    public static LocalizationKey TUTORIAL_HOGGER_3_7 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_7");
+    public static LocalizationKey TUTORIAL_HOGGER_4_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_1");
+    public static LocalizationKey TUTORIAL_HOGGER_4_1_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_1_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_2");
+    public static LocalizationKey TUTORIAL_HOGGER_4_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_4");
+    public static LocalizationKey TUTORIAL_HOGGER_4_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_5");
+    public static LocalizationKey TUTORIAL_HOGGER_4_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_6");
+    public static LocalizationKey TUTORIAL_HOGGER_4_6_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_6_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_8 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_8");
+    public static LocalizationKey TUTORIAL_HOGGER_4_9 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_9");
+    public static LocalizationKey TUTORIAL_HOGGER_4_9_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_9_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_10 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_10");
+    public static LocalizationKey TUTORIAL_HOGGER_4_11 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_11");
+    public static LocalizationKey TUTORIAL_HOGGER_4_11_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_11_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_12 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_12");
+    public static LocalizationKey TUTORIAL_HOGGER_4_13 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_13");
+    public static LocalizationKey TUTORIAL_HOGGER_4_13_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_13_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_4_16 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_16");
+    public static LocalizationKey TUTORIAL_HOGGER_4_17 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_17");
+    public static LocalizationKey TUTORIAL_HOGGER_6_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_1");
+    public static LocalizationKey TUTORIAL_HOGGER_6_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_2");
+    public static LocalizationKey TUTORIAL_HOGGER_6_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_3");
+    public static LocalizationKey TUTORIAL_HOGGER_6_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_4");
+    public static LocalizationKey TUTORIAL_HOGGER_6_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_5");
+    public static LocalizationKey TUTORIAL_HOGGER_6_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_6");
+    public static LocalizationKey TUTORIAL_HOGGER_6_7 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_7");
+    public static LocalizationKey TUTORIAL_HOGGER_6_8 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_8");
+    public static LocalizationKey TUTORIAL_HOGGER_6_9 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_9");
+    public static LocalizationKey TUTORIAL_HOGGER_6_10 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_10");
+    public static LocalizationKey TUTORIAL_HOGGER_6_12 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_12");
+    public static LocalizationKey TUTORIAL_HOGGER_6_12_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_12_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_6_13 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_13");
+    public static LocalizationKey TUTORIAL_HOGGER_6_13_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_13_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_6_14 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_14");
+    public static LocalizationKey TUTORIAL_HOGGER_6_15 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_15");
+    public static LocalizationKey TUTORIAL_HOGGER_6_16 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_16");
+    public static LocalizationKey TUTORIAL_HOGGER_6_16_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_16_HELP");
+    public static LocalizationKey TUTORIAL_HOGGER_6_21 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_21");
+    public static LocalizationKey TUTORIAL_HOGGER_8_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_8_1");
+
+    // Tutorial Millhouse Manastorm
+    public static LocalizationKey TUTORIAL02_HELP_01 = CreateKey("TUTORIAL02_HELP_01");
+    public static LocalizationKey TUTORIAL02_HELP_03 = CreateKey("TUTORIAL02_HELP_03");
+    public static LocalizationKey TUTORIAL02_HELP_06 = CreateKey("TUTORIAL02_HELP_06");
+    public static LocalizationKey TUTORIAL02_HELP_07 = CreateKey("TUTORIAL02_HELP_07");
+    public static LocalizationKey TUTORIAL_RAID_LEADER_DESCRIPTION = CreateKey("TUTORIAL_RAID_LEADER_DESCRIPTION");
+    public static LocalizationKey TUTORIAL_ARCANE_INTELLECT_DESCRIPTION = CreateKey("TUTORIAL_ARCANE_INTELLECT_DESCRIPTION");
+    public static LocalizationKey TUTORIAL_MILLHOUSE_SEE_MANA_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_MILLHOUSE_SEE_MANA_HELP");
+    public static LocalizationKey TUTORIAL06_HELP_03 = CreateKey("TUTORIAL06_HELP_03");
+
+    // Tutorial Lorewalker Cho
+    public static LocalizationKey TUTORIAL_CHO_1 = CreateKey("ACCESSIBILITY_TUTORIAL_CHO_1");
+    public static LocalizationKey TUTORIAL06_HELP_02 = CreateKey("ACCESSIBILITY_TUTORIAL06_HELP_02");
+    public static LocalizationKey TUTORIAL06_HELP_04 = CreateKey("TUTORIAL06_HELP_04");
+
+    // Tutorial King Mukla
+    public static LocalizationKey TUTORIAL_MUKLA_START = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START");
+    public static LocalizationKey TUTORIAL_MUKLA_START_B = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START_B");
+    public static LocalizationKey TUTORIAL_MUKLA_START_C = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START_C");
+    public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP");
+    public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_B");
+    public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_C");
+    public static LocalizationKey TUTORIAL04_HELP_14 = CreateKey("TUTORIAL04_HELP_14");
+    public static LocalizationKey TUTORIAL04_HELP_15 = CreateKey("TUTORIAL04_HELP_15");
+    public static LocalizationKey TUTORIAL04_HELP_16 = CreateKey("TUTORIAL04_HELP_16");
+    public static LocalizationKey TUTORIAL04_HELP_02 = CreateKey("TUTORIAL04_HELP_02");
+    public static LocalizationKey TUTORIAL04_HELP_03 = CreateKey("TUTORIAL04_HELP_03");
+
+    // Tutorial Hemet Nesingwary
+    public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP");
+    public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_B");
+    public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_C");
+
+    // Tutorial Illidan Stormrage
+    public static LocalizationKey TUTORIAL05_HELP_03 = CreateKey("TUTORIAL05_HELP_03");
+    public static LocalizationKey TUTORIAL05_HELP_04 = CreateKey("TUTORIAL05_HELP_04");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP");
+    public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B");
+
+    // New tutorial Rexxar
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_START = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_START");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_2_2 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_2_2");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_2_2D = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_2_2D");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_3_0 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_3_0");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_3_2 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_3_2");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_3_4 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_3_4");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_3_5 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_3_5");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_0 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_0");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_1 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_1");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_2 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_2");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_2_HELP = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_2_HELP");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_3 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_3");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_5 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_5");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_9 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_9");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_10 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_10");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_10_HELP = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_10_HELP");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_4_11 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_4_11");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_6_3 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_6_3");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_6_9 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_6_9");
+    public static LocalizationKey NEW_TUTORIAL_REXXAR_7_0 = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_REXXAR_7_0");
+
+    // New tutorial Garrosh
+    public static LocalizationKey NEW_TUTORIAL_GARROSH_TAUNT_HELP = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_GARROSH_TAUNT_HELP");
+
+    // New tutorial Lich King
+    public static LocalizationKey NEW_TUTORIAL_LICH_KING_WEAPON_EQUIPPED_HELP_E = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_LICH_KING_WEAPON_EQUIPPED_HELP_E");
+    public static LocalizationKey NEW_TUTORIAL_LICH_KING_WEAPON_EQUIPPED_HELP_F = CreateKey("ACCESSIBILITY_NEW_TUTORIAL_LICH_KING_WEAPON_EQUIPPED_HELP_F");
+
+    // In-game tutorial first time mulligan
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D");
+    public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E");
+
+    // Tutorials in the collection manager. Currently just E.T.C.
+    public static LocalizationKey SCREEN_COLLECTION_MANAGER_ETC_TUTORIAL = CreateKey("ACCESSIBILITY_SCREEN_COLLECTION_MANAGER_ETC_TUTORIAL");
+
+    // Battlegrounds tutorial
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_DRAGBUY_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_DRAGBUY_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_DRAGBUY_BODY_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_DRAGBUY_BODY_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_DRAGSELL_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_DRAGSELL_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_DRAGSELL_BODY_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_DRAGSELL_BODY_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_MINION_MOVE_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_MINION_MOVE_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_MINION_UPGRADE_TAVERN_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_MINION_UPGRADE_TAVERN_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_REFRESH_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_REFRESH_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_FREEZE_TUTORIAL_OVERRIDE = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_FREEZE_TUTORIAL_OVERRIDE");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_READ_TIME_REMAINING = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_READ_TIME_REMAINING");
+    public static LocalizationKey BATTLEGROUNDS_TUTORIAL_SUMMON_MINION_HELP = CreateKey("ACCESSIBILITY_BATTLEGROUNDS_TUTORIAL_SUMMON_MINION_HELP");
+
+    //arena
+    public static LocalizationKey ARENA_DRAFT_SWITCH_HELP = CreateKey("ACCESSIBILITY_ARENA_DRAFT_SWITCH_HELP");
+    public static LocalizationKey ARENA_WINS_LOSSES = CreateKey("ACCESSIBILITY_ARENA_WINS_LOSSES");
+    public static LocalizationKey ARENA_TICKETS_COUNT = CreateKey("ACCESSIBILITY_ARENA_TICKETS_COUNT");
+
+    //journal
+    public static LocalizationKey ACHIEVEMENT_CATEGORY_TITLE = CreateKey("ACCESSIBILITY_ACHIEVEMENT_CATEGORY_TITLE");
+    public static LocalizationKey ACHIEVEMENT_CATEGORY_RECENT = CreateKey("ACCESSIBILITY_ACHIEVEMENT_CATEGORY_RECENT");
+    public static LocalizationKey ACHIEVEMENT_CATEGORY_ITEM = CreateKey("ACCESSIBILITY_ACHIEVEMENT_CATEGORY_ITEM");
+    public static LocalizationKey ACHIEVEMENT_SHOWING_INCOMPLETE = CreateKey("ACCESSIBILITY_ACHIEVEMENT_SHOWING_INCOMPLETE");
+    public static LocalizationKey ACHIEVEMENT_LIST_HELP = CreateKey("ACCESSIBILITY_ACHIEVEMENT_LIST_HELP");
+    public static LocalizationKey ACHIEVEMENT_VIEW_TIER = CreateKey("ACCESSIBILITY_ACHIEVEMENT_VIEW_TIER");
+    public static LocalizationKey ACHIEVEMENT_VIEW_PROGRESS = CreateKey("ACCESSIBILITY_ACHIEVEMENT_VIEW_PROGRESS");
+    public static LocalizationKey ACHIEVEMENT_VIEW_COMPLETED = CreateKey("ACCESSIBILITY_ACHIEVEMENT_VIEW_COMPLETED");
+    public static LocalizationKey ACHIEVEMENT_VIEW_CLAIM = CreateKey("ACCESSIBILITY_ACHIEVEMENT_VIEW_CLAIM");
+    public static LocalizationKey ACHIEVEMENT_CLAIMABLE = CreateKey("ACCESSIBILITY_ACHIEVEMENT_CLAIMABLE");
+    public static LocalizationKey ACHIEVEMENT_VIEW_EARN = CreateKey("ACCESSIBILITY_ACHIEVEMENT_VIEW_EARN");
+    public static LocalizationKey ACHIEVEMENT_COULD_NOT_CLAIM = CreateKey("ACCESSIBILITY_ACHIEVEMENT_COULD_NOT_CLAIM");
+    public static LocalizationKey ACCESSIBILITY_JOURNAL_EVENT_REWARD_TRACK_PREVIEW=CreateKey("ACCESSIBILITY_JOURNAL_EVENT_REWARD_TRACK_PREVIEW");
+    public static LocalizationKey ACCESSIBILITY_JOURNAL_EVENT_REWARD_TRACK_DESC=CreateKey("ACCESSIBILITY_JOURNAL_EVENT_REWARD_TRACK_DESC");
+
+    public static LocalizationKey TAVERN_GUIDE_QUEST_COMPLETED = CreateKey("ACCESSIBILITY_TAVERN_GUIDE_QUEST_COMPLETED");
+    public static LocalizationKey TAVERN_GUIDE_QUEST_UNLOCK_REQUIREMENT = CreateKey("ACCESSIBILITY_TAVERN_GUIDE_QUEST_UNLOCK_REQUIREMENT");
+    public static LocalizationKey TAVERN_GUIDE_QUEST_SET_LABEL = CreateKey("ACCESSIBILITY_TAVERN_GUIDE_QUEST_SET_LABEL");
+    public static LocalizationKey TAVERN_GUIDE_QUEST_RECOMMENDED_CLASSES = CreateKey("ACCESSIBILITY_TAVERN_GUIDE_QUEST_RECOMMENDED_CLASSES");
+    public static LocalizationKey TAVERN_GUIDE_NEW = CreateKey("ACCESSIBILITY_TAVERN_GUIDE_NEW");
+    public static LocalizationKey TAVERN_GUIDE_CLAIM_REWARD = CreateKey("ACCESSIBILITY_TAVERN_GUIDE_CLAIM_REWARD");
+
+    public static LocalizationKey APPRENTICE_REWARD_REMINDER = CreateKey("ACCESSIBILITY_APPRENTICE_REWARD_REMINDER");
+
+    public string Key { get; private set; }
+
+    private LocalizationKey(string key)
+    {
+        Key = key;
+    }
+
+    private static List<LocalizationKey> s_keys;
+    private static Dictionary<string, LocalizationKey> s_keyDict;
+
+    private static LocalizationKey CreateKey(string key)
+    {
+        if (key == null)
+        {
+            throw new ArgumentException($"Invoked CreateKey in an invalid context");
+        }
+
+        var newKey = new LocalizationKey(key);
+        if (s_keys == null)
+        {
+            s_keys = new List<LocalizationKey>();
+        }
+
+        if (s_keyDict == null)
+        {
+            s_keyDict = new Dictionary<string, LocalizationKey>();
+        }
+
+        if (s_keyDict.ContainsKey(key))
+        {
+            throw new ArgumentException($"Fatal error initializing localization keys. Found duplicate key: {key}");
+        }
+
+        s_keys.Add(newKey);
+        s_keyDict.Add(key, newKey);
+
+        return newKey;
+    }
+
+    public static List<LocalizationKey> GetAllKeys()
+    {
+        return s_keys;
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Localization/LocalizationUtils.cs b/Assembly-CSharp/Accessibility/Localization/LocalizationUtils.cs
new file mode 100644
index 0000000..a7d8e6a
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Localization/LocalizationUtils.cs
@@ -0,0 +1,130 @@
+﻿using Accessibility;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+public class LocalizationUtils
+{
+    private static Dictionary<int, LocalizationKey> ORDERS = new Dictionary<int, LocalizationKey>
+    {
+        [1] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_1,
+        [2] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_2,
+        [3] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_3,
+        [4] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_4,
+        [5] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_5,
+        [6] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_6,
+        [7] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_7,
+        [8] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_8,
+        [9] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_9,
+        [10] = LocalizationKey.FORMATTING_ORDINAL_NUMBER_10,
+    };
+
+    internal static bool HasKey(LocalizationKey key)
+    {
+        // Used to enable/disable narration in the tutorial
+        // The narrator will only disappear if a particular key hasn't been localized
+        // Note that we cannot default here
+        return GameStrings.HasKey(key.Key);
+    }
+
+    public static string Get(LocalizationKey key)
+    {
+        if (GameStrings.HasKey(key.Key))
+        {
+            return GameStrings.Get(key.Key);
+        }
+        else
+        {
+            return DefaultGameStrings.Get(key.Key);
+        }
+    }
+
+    public static string Format(LocalizationKey key, params object[] args)
+    {
+        if (GameStrings.HasKey(key.Key))
+        {
+            return GameStrings.Format(key.Key, args);
+        }
+        else
+        {
+            return DefaultGameStrings.Format(key.Key, args);
+        }
+    }
+
+    public static string FormatPlurals(LocalizationKey key, GameStrings.PluralNumber[] pluralNumbers, params object[] args)
+    {
+        if (GameStrings.HasKey(key.Key))
+        {
+            return GameStrings.FormatPlurals(key.Key, pluralNumbers, args);
+        }
+        else
+        {
+            return DefaultGameStrings.FormatPlurals(key.Key, pluralNumbers, args);
+        }
+    }
+
+    public static bool HasOverrideForKey(KeyCode keyCode)
+    {
+        var stringsKey = GetKeyOverrideLocalizationKey(keyCode);
+        return GameStrings.HasKey(stringsKey);
+    }
+
+    public static string GetOverrideForKey(KeyCode keyCode)
+    {
+        var stringsKey = GetKeyOverrideLocalizationKey(keyCode);
+
+        if (GameStrings.HasKey(stringsKey))
+        {
+            return GameStrings.Get(stringsKey);
+        }
+        else
+        {
+            return DefaultGameStrings.Get(stringsKey);
+        }
+    }
+
+    private static string GetKeyOverrideLocalizationKey(KeyCode keyCode)
+    {
+        var keyCodeStr = keyCode.ToString();
+        return String.Format(LocalizationKey.INPUT_KEY_OVERRIDE_FORMAT, keyCodeStr);
+    }
+
+    public static string GetPeriod()
+    {
+        return Get(LocalizationKey.FORMATTING_PERIOD);
+    }
+
+    public static string GetSentenceEndingCharacters()
+    {
+        return Get(LocalizationKey.FORMATTING_SENTENCE_ENDING_CHARACTERS);
+    }
+
+    public static string GetOrdinalNumber(int num)
+    {
+        if (num >= 1 && num <= 10 && GameStrings.HasKey(ORDERS[num].Key)) // Simply default to a normal digit representation for non-translated locales
+        {
+            return Get(ORDERS[num]);
+        }
+
+        return $"{num}";
+    }
+
+    public static bool IsOrdinalNumber(string text)
+    {
+        return GetOrdinalNumbers().Contains(text);
+    }
+    private static List<string> GetOrdinalNumbers()
+    {
+        var ret = new List<string>();
+
+        foreach (var entry in ORDERS)
+        {
+            ret.Add(GetOrdinalNumber(entry.Key));
+        }
+
+        return ret;
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Localization/LocalizedText.cs b/Assembly-CSharp/Accessibility/Localization/LocalizedText.cs
new file mode 100644
index 0000000..fa4ae4d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Localization/LocalizedText.cs
@@ -0,0 +1,75 @@
+﻿using Accessibility;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+class LocalizedText
+{
+    // Menus
+    public static string GAME_MENU_TITLE => LocalizationUtils.Get(LocalizationKey.MENU_GAME_MENU_TITLE);
+    public static string OPTIONS_MENU_ADJUST_VOLUME => LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ADJUST_VOLUME);
+    public static string MENU_NO_ITEMS => LocalizationUtils.Get(LocalizationKey.MENU_NO_ITEMS);
+
+    // Hub
+    public static string HUB_MAIN_MENU_TITLE => LocalizationUtils.Get(LocalizationKey.HUB_MAIN_MENU_TITLE);
+    public static string HUB_BATTLEGROUNDS_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLEGROUNDS);
+    public static string HUB_TAVERN_BRAWL_OPTION => GameStrings.Get("GLOBAL_TAVERN_BRAWL");
+    public static string HUB_GAME_MODES_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_MODES);
+    public static string HUB_MY_COLLECTION_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_MY_COLLECTION);
+    public static string HUB_HELP_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_HELP);
+
+    // Modes
+    public static string MODES_MENU_TITLE => LocalizationUtils.Get(LocalizationKey.GLOBAL_CHOOSE_MODE);
+    public static string MODES_SOLO_ADVENTURES_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_SOLO_ADVENTURES);
+        public static string MODES_ARENA_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_ARENA);
+        public static string MODES_TAVERN_OPTION => LocalizationUtils.Get(LocalizationKey.GLOBAL_TAVERN);
+
+    // Global
+    public static string GLOBAL_GAME_LOADED => LocalizationUtils.Get(LocalizationKey.GLOBAL_GAME_LOADED);
+    public static string GLOBAL_LOADING => LocalizationUtils.Get(LocalizationKey.GLOBAL_LOADING);
+    public static string GLOBAL_PLEASE_WAIT => LocalizationUtils.Get(LocalizationKey.GLOBAL_PLEASE_WAIT);
+    public static string GLOBAL_CARD => LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD);
+    public static string GLOBAL_CARD_PLURAL => LocalizationUtils.Get(LocalizationKey.GLOBAL_CARD_PLURAL);
+    public static string GLOBAL_RECONNECTED => LocalizationUtils.Get(LocalizationKey.GLOBAL_RECONNECTED);
+    public static string GLOBAL_OPTIONS => LocalizationUtils.Get(LocalizationKey.GLOBAL_OPTIONS);
+    public static string GLOBAL_PRESS_ENTER_TO_CONFIRM_OR_BACKSPACE_TO_CANCEL => AccessibleSpeech.TUTORIAL_HOGGER_2_5.GetLocalizedText();
+
+    // Global keywords
+    public static string GLOBAL_TAUNT => LocalizationUtils.Get(LocalizationKey.GLOBAL_TAUNT);
+    public static string GLOBAL_DEATHRATTLE => LocalizationUtils.Get(LocalizationKey.GLOBAL_DEATHRATTLE);
+    public static string GLOBAL_BATTLECRY => LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLECRY);
+    public static string GLOBAL_CHARGE => LocalizationUtils.Get(LocalizationKey.GLOBAL_CHARGE);
+    public static string GLOBAL_LIFESTEAL => LocalizationUtils.Get(LocalizationKey.GLOBAL_LIFESTEAL);
+    public static string GLOBAL_RUSH => LocalizationUtils.Get(LocalizationKey.GLOBAL_RUSH);
+    public static string GLOBAL_WINDFURY => LocalizationUtils.Get(LocalizationKey.GLOBAL_WINDFURY);
+    public static string GLOBAL_DIVINE_SHIELD => LocalizationUtils.Get(LocalizationKey.GLOBAL_DIVINE_SHIELD);
+    public static string GLOBAL_FREEZE => LocalizationUtils.Get(LocalizationKey.GLOBAL_FREEZE);
+    public static string GLOBAL_FROZEN => LocalizationUtils.Get(LocalizationKey.GLOBAL_FROZEN);
+    public static string GLOBAL_POISONOUS => LocalizationUtils.Get(LocalizationKey.GLOBAL_POISONOUS);
+    public static string GLOBAL_STEALTH => LocalizationUtils.Get(LocalizationKey.GLOBAL_STEALTH);
+    public static string GLOBAL_IMMUNE => LocalizationUtils.Get(LocalizationKey.GLOBAL_IMMUNE);
+    public static string GLOBAL_DORMANT => LocalizationUtils.Get(LocalizationKey.GLOBAL_DORMANT);
+    public static string GLOBAL_REBORN => LocalizationUtils.Get(LocalizationKey.GLOBAL_REBORN);
+    public static string GLOBAL_ENCHANTMENT => LocalizationUtils.Get(LocalizationKey.GLOBAL_ENCHANTMENT);
+    public static string GLOBAL_SILENCE => LocalizationUtils.Get(LocalizationKey.GLOBAL_SILENCE);
+
+    // Gameplay
+    public static string GAMEPLAY_YOUR_TURN => LocalizationUtils.Get(LocalizationKey.GAMEPLAY_YOUR_TURN);
+    public static string GAMEPLAY_OPPONENT_TURN => LocalizationUtils.Get(LocalizationKey.GAMEPLAY_OPPONENT_TURN);
+    public static string GAMEPLAY_TURN_ENDED => LocalizationUtils.Get(LocalizationKey.GAMEPLAY_TURN_ENDED);
+
+    // UI
+    public static string UI_POPUP => LocalizationUtils.Get(LocalizationKey.UI_POPUP);
+    public static string UI_REWARDS_TITLE => LocalizationUtils.Get(LocalizationKey.UI_REWARDS_TITLE);
+
+    // Screens
+    public static string SCREEN_GO_BACK => LocalizationUtils.Get(LocalizationKey.SCREEN_GO_BACK);
+
+    // Collectible cards
+    public static string COLLECTION_CARD_NEW => LocalizationUtils.Get(LocalizationKey.COLLECTION_CARD_NEW).ToLower();
+
+    // Tutorial
+    public static string TUTORIAL_LOADING_TUTORIAL => LocalizationUtils.Get(LocalizationKey.TUTORIAL_LOADING_TUTORIAL);
+}
diff --git a/Assembly-CSharp/Accessibility/PackOpening/AccessibleMassPackOpeningQuantityPrompt.cs b/Assembly-CSharp/Accessibility/PackOpening/AccessibleMassPackOpeningQuantityPrompt.cs
new file mode 100644
index 0000000..9c8179d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/PackOpening/AccessibleMassPackOpeningQuantityPrompt.cs
@@ -0,0 +1,71 @@
+using System;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleMassPackOpeningQuantityPrompt
+    {
+        private static int s_maxQuantity;
+
+        public delegate void OnValidInputSubmittedDelegate(int qty);
+
+        private static OnValidInputSubmittedDelegate s_onValidInputSubmitted;
+
+        private static Action s_onInputCanceled;
+
+        public static void OnInputUpdated(string input)
+        {
+            AccessibilityMgr.Output(PackOpening.Get(), input);
+        }
+
+        public static void onInputSubmitted(string input)
+        {
+            if (int.TryParse(input, out var quantity))
+            {
+                if (quantity > 1 && quantity <= s_maxQuantity)
+                {
+                    s_onValidInputSubmitted(quantity);
+                    return;
+                }
+            }
+
+            AccessibilityMgr.Output(PackOpening.Get(), LocalizationUtils.Format(LocalizationKey.MASS_PACK_OPENING_QUANTITY_PROMPT_ERROR, 2, s_maxQuantity));
+            if (s_onInputCanceled != null)
+            {
+                s_onInputCanceled();
+            }
+        }
+
+        public static void OnInputCanceled(bool unused, GameObject unused2)
+        {
+            if (s_onInputCanceled != null)
+            {
+                s_onInputCanceled();
+            }
+        }
+
+        public static void show(int maxQuantity, OnValidInputSubmittedDelegate onValidInputSubmitted, Action onInputCanceled)
+        {
+            s_maxQuantity = maxQuantity;
+            s_onValidInputSubmitted = onValidInputSubmitted;
+            s_onInputCanceled = onInputCanceled;
+
+            var parms = new UniversalInputManager.TextInputParams {
+                m_canceledCallback = OnInputCanceled,
+                m_completedCallback = onInputSubmitted,
+                m_maxCharacters = 2,
+                m_number = true,
+                m_owner = PackOpening.Get().gameObject,
+                m_rect = new Rect(0, 0, Screen.width, Screen.height),
+                m_updatedCallback = OnInputUpdated
+            };
+
+            UniversalInputManager.Get().UseTextInput(parms);
+            AccessibilityMgr.AllowTextInput();
+            AccessibilityMgr.Output(PackOpening.Get(), LocalizationUtils.Format(LocalizationKey.MASS_PACK_OPENING_QUANTITY_PROMPT, 2, s_maxQuantity));
+        }
+    }
+}
+
+
+
diff --git a/Assembly-CSharp/Accessibility/PackOpening/AccessiblePackOpeningCard.cs b/Assembly-CSharp/Accessibility/PackOpening/AccessiblePackOpeningCard.cs
new file mode 100644
index 0000000..4685124
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/PackOpening/AccessiblePackOpeningCard.cs
@@ -0,0 +1,73 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessiblePackOpeningCard : AccessibleItem
+    {
+        private readonly PackOpeningCard m_card;
+
+        private readonly NetCache.BoosterCard m_boosterCard;
+
+        internal AccessiblePackOpeningCard(AccessibleComponent parent, PackOpeningCard card) : base(parent)
+        {
+            m_card = card;
+        }
+
+        internal AccessiblePackOpeningCard(AccessibleComponent parent, NetCache.BoosterCard boosterCard) : base(parent)
+        {
+            m_boosterCard = boosterCard;
+        }
+
+        internal override List<string> GetLines()
+        {
+            if (m_boosterCard != null || (m_card?.IsRevealed() ?? false))
+            {
+                return GetLinesForRevealedCard();
+            }
+            else
+            {
+                return GetLinesForHiddenCard();
+            }
+        }
+
+        private List<string> GetLinesForRevealedCard()
+        {
+            var ret = new List<string>();
+            var entityDef = GetEntityDef();
+            var premium = GetPremium();
+            ret.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(entityDef, premium, PackOpeningCard.GetClassName(entityDef)));
+
+            if (m_card != null && m_card.m_isNew)
+            {
+                ret.Add(LocalizedText.COLLECTION_CARD_NEW);
+            }
+
+            return ret;
+        }
+
+        private List<string> GetLinesForHiddenCard()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Get(LocalizationKey.UI_REWARD_TYPE_ONE_CARD));
+
+            return ret;
+        }
+
+        private EntityDef GetEntityDef()
+        {
+            return m_card != null ? m_card.GetEntityDef() : DefLoader.Get().GetEntityDef(m_boosterCard.Def.Name);
+        }
+
+        private TAG_PREMIUM GetPremium()
+        {
+            return m_card != null ? m_card.GetPremium() : m_boosterCard.Def.Premium;
+        }
+
+        public PackOpeningCard GetPackOpeningCard()
+        {
+            return m_card;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/PackOpening/AccessibleUnopenedPack.cs b/Assembly-CSharp/Accessibility/PackOpening/AccessibleUnopenedPack.cs
new file mode 100644
index 0000000..46037f0
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/PackOpening/AccessibleUnopenedPack.cs
@@ -0,0 +1,52 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleUnopenedPack : AccessibleItem
+    {
+        private readonly UnopenedPack m_pack;
+
+        internal AccessibleUnopenedPack(AccessibleComponent parent, UnopenedPack pack) : base(parent)
+        {
+            m_pack = pack;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_CARD_PACKS, m_pack.GetCount()));
+
+            AccessibleCardUtils.AddLineIfExists(GetLockedRibbonText(), ret);
+            AccessibleCardUtils.AddLineIfExists(GetPackName(), ret);
+
+            return ret;
+        }
+
+        public string GetLockedRibbonText()
+        {
+            if (m_pack.CanOpenPack())
+            {
+                return null;
+            }
+
+            return GameStrings.Get(m_pack.m_LockedRibbonText?.Text);
+        }
+
+        private string GetPackName()
+        {
+            return AccessibleCardUtils.GetCardPackName(m_pack.GetBoosterId());
+        }
+
+        public bool IsLocked()
+        {
+            return !m_pack.CanOpenPack();
+        }
+
+        public UnopenedPack GetUnopenedPack()
+        {
+            return m_pack;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/QueuedText.cs b/Assembly-CSharp/Accessibility/QueuedText.cs
new file mode 100644
index 0000000..0f96e9c
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/QueuedText.cs
@@ -0,0 +1,152 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using UnityEngine;
+
+namespace Accessibility
+{
+    public class QueuedText
+    {
+        private string m_text;
+
+        private bool m_playing;
+
+        private Stopwatch m_stopwatch;
+
+        private float m_playTimeMs;
+
+        private Action m_onStart, m_onEnd;
+
+        private bool m_interrupt;
+        private bool m_wait;
+
+        private bool m_narration;
+
+        public QueuedText(string text, Action onStart, Action onEnd, bool interrupt=false, bool wait=true, bool narration=false)
+        {
+            m_wait = wait; // Needs to be set first so we handle all text updates properly
+
+            UpdateText(text);
+            m_stopwatch = new Stopwatch();
+
+            m_onStart = onStart;
+            m_onEnd = onEnd;
+
+            m_interrupt = interrupt;
+
+            m_narration = narration;
+
+            //Log.Accessibility.Print($"SPS New QueuedText({text}) / PlayTime={m_playTimeMs}");
+        }
+
+        internal void UpdateText(string text)
+        {
+            if (m_playing)
+            {
+                return;
+            }
+
+            m_text = text;
+            m_playTimeMs = EstimatePlayTimeMs();
+        }
+
+        internal void UpdateSpeed()
+        {
+            if (m_playing)
+            {
+                return;
+            }
+
+            m_playTimeMs = EstimatePlayTimeMs();
+        }
+
+        private float EstimatePlayTimeMs()
+        {
+            // Was like this when testing initially vv
+            // Normal english speaking person rate = somewhere between 140~160. 150 seems like a good baseline
+            // Normal characters per word in english is ~4.5/wordl 5 seems like a good rate
+            // So 150WPM * 5Chars = 12.5CPS -> seems like a good baseline
+            // <100WPM is slow. JFK's speech was ~95WPM
+            // 100WPM is 8CPS
+            //int cps = 15; // This assumes 5/word + random spaces/punctuation = 1/word = 150WPM*6/60 = 15 CPS
+
+            //float safetyNet = 500;
+            //float safetyNet = 0;
+
+            if (!m_wait)
+            {
+                // Used for menus, popups, etc
+                return 0;
+            }
+
+            return (m_text.Length) / AccessibilityMgr.GetCPS() * 1000;
+        }
+
+        internal bool IsNarration()
+        {
+            return m_narration;
+        }
+
+        internal void Play()
+        {
+            if (!ScreenReader.Output(m_text, m_interrupt))
+            {
+                // e.g. optimized text which became empty
+                OnStartPlaying();
+                OnEndPlaying();
+            }
+            else
+            {
+                OnStartPlaying();
+            }
+        }
+
+        private void OnStartPlaying()
+        {
+            m_playing = true;
+            m_stopwatch.Start();
+
+            if (m_onStart != null)
+            {
+                AccessibilityUtils.LogDebug($"SPS OnStartPlaying {m_text}");
+                m_onStart();
+            }
+        }
+
+        internal void Interrupt()
+        {
+            OnEndPlaying();
+        }
+
+        private void OnEndPlaying()
+        {
+            m_playing = false;
+            m_stopwatch.Stop();
+
+            if (m_onEnd != null)
+            {
+                AccessibilityUtils.LogDebug($"SPS OnEndPlaying {m_text}");
+                m_onEnd();
+            }
+        }
+
+        internal bool IsPlaying()
+        {
+            if (m_stopwatch.ElapsedMilliseconds >= m_playTimeMs)
+            {
+                OnEndPlaying();
+            }
+
+            return m_playing;
+        }
+
+        public string GetText()
+        {
+            return m_text;
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/Ranked/AccessibleRankedUtils.cs b/Assembly-CSharp/Accessibility/Ranked/AccessibleRankedUtils.cs
new file mode 100644
index 0000000..c3c4ae3
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Ranked/AccessibleRankedUtils.cs
@@ -0,0 +1,116 @@
+﻿using Hearthstone.DataModels;
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace Accessibility
+{
+    class AccessibleRankedUtils
+    {
+        public static string GetBestRank(MedalInfoTranslator medalInfo)
+        {
+			if (medalInfo == null)
+			{
+				return null;
+			}
+            if (medalInfo.IsDisplayable())
+            {
+                var sb = new StringBuilder();
+                var bestFormat = medalInfo.GetBestCurrentRankFormatType();
+
+                if (bestFormat != PegasusShared.FormatType.FT_STANDARD)
+                {
+                    sb.Append($"{GameStrings.GetFormatName(bestFormat)} ");
+                }
+
+                var bestMedal = medalInfo.GetCurrentMedal(bestFormat);
+                sb.Append(GetRankText(bestMedal));
+
+                return sb.ToString();
+            }
+
+            return "";
+        }
+
+        public static string GetRankText(TranslatedMedalInfo medalInfo)
+		{
+			var sb = new StringBuilder();
+
+			sb.Append(medalInfo.GetRankName());
+
+			if (medalInfo.IsLegendRank())
+			{
+				sb.Append($" {medalInfo.legendIndex}");
+			}
+
+			return sb.ToString();
+		}
+
+        public static string GetRankStarsText(TranslatedMedalInfo medalInfo)
+		{
+			if (!medalInfo.IsLegendRank())
+			{
+				var earnedStars = medalInfo.earnedStars;
+				var maxStars = medalInfo.RankConfig.Stars;
+
+				return LocalizationUtils.Format(LocalizationKey.SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STARS, earnedStars, maxStars);
+			}
+
+			return null;
+		}
+
+        public static string GetStarBonusText(TranslatedMedalInfo medalInfo)
+		{
+			if (!medalInfo.IsLegendRank() && medalInfo.starsPerWin > 1)
+			{
+				return LocalizationUtils.Format(LocalizationKey.SCREEN_HEARTHSTONE_RANKED_READ_RANK_CURRENT_STAR_BONUS, medalInfo.starsPerWin);
+			}
+
+			return null;
+		}
+
+		public static bool PlayerHasStandardDecks()
+		{
+			return CollectionManager.Get().GetNumberOfStandardDecks() > 0 || PlayerHasLoanerDecks();
+		}
+
+		public static bool PlayerHasCasualDecks()
+		{
+			// This is highly inefficient but maintainability and less conflicts are more important here
+			var numStandardDecks = CollectionManager.Get().GetNumberOfStandardDecks();
+			var numWildDecks = CollectionManager.Get().GetNumberOfWildDecks();
+			var numTwistDecks = CollectionManager.Get().GetNumberOfTwistDecks();
+
+			var numEligibleDecks = numStandardDecks + numWildDecks + numTwistDecks;
+
+			return numEligibleDecks > 0 || PlayerHasLoanerDecks();
+		}
+
+		public static bool PlayerHasLoanerDecks()
+		{
+			var freeDeckMgr = FreeDeckMgr.Get();
+			return freeDeckMgr.Status == FreeDeckMgr.FreeDeckStatus.TRIAL_PERIOD && freeDeckMgr.GetLoanerDecksCount() > 0;
+		}
+
+		public static bool PlayerCanPlayWild()
+		{
+			if (!CollectionManager.Get().ShouldAccountSeeStandardWild())
+			{
+				return false;
+			}
+
+			// This is highly inefficient but maintainability and less conflicts are more important here
+			var numStandardDecks = CollectionManager.Get().GetNumberOfStandardDecks();
+			var numWildDecks = CollectionManager.Get().GetNumberOfWildDecks();
+
+			var numEligibleDecks = numStandardDecks + numWildDecks;
+
+			return numEligibleDecks > 0;
+		}
+
+		public static bool PlayerCanPlayTwist()
+		{
+            return CollectionManager.Get().AccountCanSeeTwist() && CollectionManager.Get().GetNumberOfTwistDecks() > 0;
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/ScreenReader.cs b/Assembly-CSharp/Accessibility/ScreenReader.cs
new file mode 100644
index 0000000..7422d75
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/ScreenReader.cs
@@ -0,0 +1,51 @@
+﻿using DavyKager;
+using System;
+using System.IO;
+
+namespace Accessibility
+{
+    class ScreenReader
+    {
+        internal static bool Output(string text, bool interrupt=false)
+        {
+            if (text.Length == 0)
+            {
+                return false;
+            }
+
+            bool success = Tolk.Output(text, interrupt);
+
+            AccessibilityUtils.LogDebug($"Output to screen reader (success={success}): {text}");
+
+            return success;
+        }
+
+        internal static void Load()
+        {
+            // Append accessibility deps (e.g. Tolk, NVDA drivers, etc.) to PATH
+            string path = System.Environment.GetEnvironmentVariable("PATH", System.EnvironmentVariableTarget.Process);
+            string accessibilityAssembliesDir = Path.Combine(Directory.GetCurrentDirectory(), "Hearthstone_Data", "Managed", "Accessibility");
+            path += $";{accessibilityAssembliesDir}";
+            System.Environment.SetEnvironmentVariable("PATH", path, System.EnvironmentVariableTarget.Process);
+
+            // Load Tolk
+            Tolk.TrySAPI(true);
+            Tolk.Load();
+        }
+
+        internal static void Unload()
+        {
+            Tolk.Unload();
+        }
+
+        internal static bool IsUsingSAPI()
+        {
+            return Tolk.DetectScreenReader().Equals("SAPI");
+        }
+
+        internal static void Interrupt()
+        {
+            Tolk.Output("", true);
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Shop/AccessibleShopUtils.cs b/Assembly-CSharp/Accessibility/Shop/AccessibleShopUtils.cs
new file mode 100644
index 0000000..788ddef
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Shop/AccessibleShopUtils.cs
@@ -0,0 +1,204 @@
+﻿using Blizzard.T5.Services;
+using Hearthstone.DataModels;
+using Hearthstone.UI;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+	class AccessibleShopUtils
+	{
+		internal static bool IsAccessibleCurrency(CurrencyType currency)
+		{
+			return currency == CurrencyType.GOLD || currency == CurrencyType.ROW_RUNESTONES;
+		}
+
+		internal static bool CanProductOrVariantsBeBoughtAccessibly(ProductDataModel dataModel)
+		{
+			var prices = dataModel.Prices;
+			var variants = dataModel.Variants;
+
+			if (HasAccessiblePrice(prices))
+			{
+				return true;
+			}
+
+			if (variants != null)
+			{
+				foreach (var variant in variants)
+				{
+					if (HasAccessiblePrice(variant.Prices))
+					{
+						return true;
+					}
+				}
+			}
+
+			return false;
+		}
+
+		internal static bool CanVariantBeBoughtAccessibly(ProductDataModel dataModel)
+		{
+			var prices = dataModel.Prices;
+
+			return HasAccessiblePrice(prices);
+		}
+
+		internal static bool CanBeBoughtAccessibly(ShopSlot slot)
+		{
+			if (!IsAvailable(slot))
+			{
+				return false;
+			}
+
+			var dataModel = slot.BrowserButtonDataModel?.DisplayProduct;
+
+			if (dataModel == null)
+			{
+				return false;
+			}
+
+			return CanProductOrVariantsBeBoughtAccessibly(dataModel);
+		}
+
+		internal static List<ShopSlot> FilterSlotsWhichCanBeBoughtAccessibly(List<ShopSlot> slots)
+		{
+			var ret = new List<ShopSlot>();
+
+			foreach (var slot in slots)
+			{
+				if (CanBeBoughtAccessibly(slot))
+				{
+					ret.Add(slot);
+				}
+			}
+
+			return ret;
+		}
+
+		internal static string GetBuyText(PriceDataModel price)
+		{
+			var cost = Mathf.RoundToInt(price.Amount);
+			if (cost == 0)
+			{
+				return LocalizationUtils.Get(LocalizationKey.UI_SHOP_ITEM_GET_FOR_FREE);
+			}
+			else if (price.Currency == CurrencyType.GOLD)
+			{
+				return LocalizationUtils.Format(LocalizationKey.UI_SHOP_ITEM_BUY_FOR_N_GOLD, cost);
+			}
+			else if (price.Currency == CurrencyType.ROW_RUNESTONES)
+			{
+				return LocalizationUtils.Format(LocalizationKey.UI_SHOP_ITEM_BUY_FOR_N_RUNESTONES, cost);
+			}
+			else
+			{
+				return "";
+			}
+		}
+
+		internal static bool IsAvailable(ShopSlot slot)
+		{
+			return IsAvailable(slot.BrowserButtonDataModel.DisplayProduct);
+		}
+
+		internal static bool IsAvailable(ProductDataModel dataModel)
+		{
+			return dataModel?.Availability == ProductAvailability.CAN_PURCHASE;
+		}
+
+	private static bool HasAccessiblePrice(DataModelList<PriceDataModel> prices)
+	{
+		foreach (var price in prices)
+		{
+			if (IsAccessibleCurrency(price.Currency))
+			{
+				return true;
+			}
+		}
+		return false;
+	}
+
+		internal static List<ProductDataModel> GetVariantsWhichCanBeBoughtAccessibly(ProductDataModel product)
+		{
+			var ret = new List<ProductDataModel>();
+
+			foreach (var variant in product.Variants)
+			{
+				if (IsAvailable(variant) && CanVariantBeBoughtAccessibly(variant))
+				{
+					ret.Add(variant);
+				}
+			}
+
+			return ret;
+		}
+
+		internal static List<string> CreateMultilineDescriptionForVariant(ProductDataModel variant)
+		{
+			var ret = new List<string>();
+
+			AccessibleCardUtils.AddLineIfExists(variant.DescriptionHeader, ret);
+
+			if (variant.Description != null)
+			{
+				var descLines = variant.Description.Split('•');
+
+				if (descLines != null)
+				{
+					foreach (var line in descLines)
+					{
+						if (line.Length > 0)
+						{
+							ret.Add(line);
+						}
+					}
+				}
+			}
+
+			return ret;
+		}
+
+		internal static long GetGoldBalance()
+		{
+			return ServiceManager.Get<CurrencyManager>().GetBalance(CurrencyType.GOLD);
+		}
+
+		internal static long GetRunestoneBalance()
+		{
+			return ServiceManager.Get<CurrencyManager>().GetBalance(CurrencyType.ROW_RUNESTONES);
+		}
+
+		internal static bool HasEnoughToBuyVariant(PriceDataModel price)
+		{
+			return ShopUtils.GetDeficit(price) == 0;
+		}
+
+		internal static void ReadGold(AccessibleComponent speaker)
+		{
+			var gold = GetGoldBalance();
+			AccessibilityMgr.Output(speaker, LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_GOLD, gold));
+		}
+
+		internal static void ReadRunestones(AccessibleComponent speaker)
+		{
+			var runestones = GetRunestoneBalance();
+			AccessibilityMgr.Output(speaker, LocalizationUtils.Format(LocalizationKey.UI_REWARD_N_RUNESTONES, runestones));
+		}
+
+		internal static void ReadRemainingGold(AccessibleComponent speaker)
+		{
+			var gold = GetGoldBalance();
+			AccessibilityMgr.Output(speaker, LocalizationUtils.Format(LocalizationKey.UI_SHOP_PURCHASE_COMPLETE_GOLD_REMAINING, gold));
+		}
+
+		internal static void ReadRemainingRunestones(AccessibleComponent speaker)
+		{
+			var runestones = GetRunestoneBalance();
+			AccessibilityMgr.Output(speaker, LocalizationUtils.Format(LocalizationKey.UI_SHOP_PURCHASE_COMPLETE_RUNESTONES_REMAINING, runestones));
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/Social/AccessibleFriendListFriendFrame.cs b/Assembly-CSharp/Accessibility/Social/AccessibleFriendListFriendFrame.cs
new file mode 100644
index 0000000..0ff9f5f
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Social/AccessibleFriendListFriendFrame.cs
@@ -0,0 +1,59 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using Blizzard.GameService.SDK.Client.Integration;
+
+namespace Accessibility
+{
+    class AccessibleFriendListFriendFrame : AccessibleItem, IEquatable<AccessibleFriendListFriendFrame>
+    {
+        private readonly FriendListFriendFrame m_frame;
+
+        internal AccessibleFriendListFriendFrame(AccessibleComponent parent, FriendListFriendFrame frame) : base(parent)
+        {
+            m_frame = frame;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            var friendDataModel = m_frame.m_friendDataModel;
+
+            if (friendDataModel.IsOnline)
+            {
+                ret.Add(friendDataModel.PlayerName);
+                AccessibleCardUtils.AddLineIfExists(AccessibleRankedUtils.GetBestRank(m_frame.m_rankedMedalInfo), ret);
+                if (RankMgr.Get().GetBattlegroundsMedalFromRankPresenceField(m_frame.GetFriend()?.GetHearthstoneGameAccount(), out var bgRating, out var gameType))
+                {
+                    AccessibleCardUtils.AddLineIfExists(LocalizedText.HUB_BATTLEGROUNDS_OPTION + " " + bgRating, ret);
+                }
+            }
+            else
+            {
+                var name = AccessibleSpeechUtils.CombineWordsWithComma(GameStrings.Get("GLOBAL_OFFLINE"), friendDataModel.PlayerName);
+                ret.Add(name);
+            }
+
+            ret.Add(friendDataModel.PlayerStatus);
+
+            return ret;
+        }
+
+        internal FriendListFriendFrame GetFriendListFriendFrame()
+        {
+            return m_frame;
+        }
+
+        public bool Equals(AccessibleFriendListFriendFrame other)
+        {
+            return GetFriendListFriendFrame().GetFriend() == other.GetFriendListFriendFrame().GetFriend();
+        }
+
+        public override int GetHashCode()
+        {
+            return GetFriendListFriendFrame().GetFriend().GetHashCode();
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Social/AccessibleFriendListRequestFrame.cs b/Assembly-CSharp/Accessibility/Social/AccessibleFriendListRequestFrame.cs
new file mode 100644
index 0000000..6d417cf
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Social/AccessibleFriendListRequestFrame.cs
@@ -0,0 +1,32 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+
+namespace Accessibility
+{
+    class AccessibleFriendListRequestFrame : AccessibleItem
+    {
+        private readonly FriendListRequestFrame m_frame;
+
+        internal AccessibleFriendListRequestFrame(AccessibleComponent parent, FriendListRequestFrame frame) : base(parent)
+        {
+            m_frame = frame;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            AccessibleCardUtils.AddLineIfExists(m_frame.m_PlayerNameText.Text, ret);
+            AccessibleCardUtils.AddLineIfExists(m_frame.m_TimeText.Text, ret);
+
+            return ret;
+        }
+
+        internal FriendListRequestFrame GetFriendListRequestFrame()
+        {
+            return m_frame;
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Social/AccessiblePlayerProfile.cs b/Assembly-CSharp/Accessibility/Social/AccessiblePlayerProfile.cs
new file mode 100644
index 0000000..6733da9
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Social/AccessiblePlayerProfile.cs
@@ -0,0 +1,58 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Text;
+using UnityEngine;
+using static FriendListFrame;
+
+namespace Accessibility
+{
+    class AccessiblePlayerProfile : AccessibleItem
+    {
+        private readonly FriendListFriendFrame m_frame;
+
+        private readonly Me m_me;
+
+        internal AccessiblePlayerProfile(AccessibleComponent parent, Me me) : base(parent)
+        {
+            m_me = me;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+
+            ret.Add(m_me.nameText.Text);
+
+            ret.AddRange(GetRankedPlayDataModel());
+
+            return ret;
+        }
+
+        private List<string> GetRankedPlayDataModel()
+        {
+            var ret = new List<string>();
+
+            MedalInfoTranslator medalInfo = RankMgr.Get().GetLocalPlayerMedalInfo();
+
+            var rankedMedalText = AccessibleRankedUtils.GetBestRank(medalInfo);
+
+            if (rankedMedalText?.Length > 0)
+            {
+                ret.Add(rankedMedalText);
+            }
+
+            return ret;
+        }
+
+        public void CopyBattleTagToClipboard()
+        {
+            BnetPlayer myPlayer = BnetPresenceMgr.Get().GetMyPlayer();
+
+            var battleTag = myPlayer.GetBattleTag();
+
+            ClipboardUtils.CopyToClipboard(battleTag.ToString());
+
+            UIStatus.Get().AddInfo(LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_BATTLETAG_COPIED_TO_CLIPBOARD));
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/Social/AccessibleRecentPlayer.cs b/Assembly-CSharp/Accessibility/Social/AccessibleRecentPlayer.cs
new file mode 100644
index 0000000..4058781
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Social/AccessibleRecentPlayer.cs
@@ -0,0 +1,28 @@
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleRecentPlayer : AccessibleItem
+    {
+        private BnetPlayer m_player;
+
+        internal AccessibleRecentPlayer(AccessibleComponent parent, BnetPlayer player) : base(parent)
+        {
+            m_player = player;
+        }
+
+        internal BnetPlayer GetPlayer()
+        {
+            return m_player;
+        }
+
+        internal override List<string> GetLines()
+        {
+            var ret = new List<string>();
+            ret.Add(m_player.GetBestName());
+            ret.Add(BnetRecentPlayerMgr.Get().GetRecentReason(m_player));
+            return ret;
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/Social/AccessibleReportingPopup.cs b/Assembly-CSharp/Accessibility/Social/AccessibleReportingPopup.cs
new file mode 100644
index 0000000..ca91db9
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Social/AccessibleReportingPopup.cs
@@ -0,0 +1,154 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using Blizzard.GameService.SDK.Client.Integration;
+
+namespace Accessibility
+{
+    class AccessibleReportingPopup : AccessibleUI
+    {
+        private enum State
+        {
+            COMPLAINT_MENU,
+            SUBCOMPLAINT_MENU
+        }
+
+        private State m_curState;
+
+        private BnetPlayer m_player;
+
+        private AccessibleMenu m_complaintMenu;
+
+        private ReportType.ComplaintType? m_selectedComplaint;
+
+        private AccessibleMenu m_subcomplaintMenu;
+
+        private List<AccessibleCheckBox> m_subcomplaintCheckboxes;
+
+        private HashSet<ReportType.SubcomplaintType> m_selectedSubcomplaints;
+
+        private Action m_onReportSubmitted;
+
+        private Action m_onReportCanceled;
+
+        private AccessibleReportingPopup(BnetPlayer player, Action onReportSubmitted = null, Action onReportCanceled = null)
+        {
+            m_player = player;
+            m_selectedSubcomplaints = new HashSet<ReportType.SubcomplaintType>();
+            m_onReportSubmitted = onReportSubmitted;
+            m_onReportCanceled = onReportCanceled;
+        }
+
+        internal static void show(BnetPlayer player, Action onReportSubmitted, Action onReportCanceled)
+        {
+            var popup = new AccessibleReportingPopup(player, onReportSubmitted, onReportCanceled);
+            popup.ReadPopup();
+        }
+
+        private void ReadPopup()
+        {
+            AccessibilityMgr.ShowUI(this);
+            AccessibilityMgr.Output(this, GameStrings.Format("GLOBAL_FRIENDLIST_REPORT_SELECT_HEADER_NONFRIEND", m_player.GetBestName()));
+            SetupComplaintMenu();
+            ReadComplaintMenu();
+        }
+
+        private void HidePopup(bool reportSubmitted)
+        {
+            AccessibilityMgr.HideUI(this);
+            if (reportSubmitted && m_onReportSubmitted != null)
+            {
+                m_onReportSubmitted();
+            }
+            else if (!reportSubmitted && m_onReportCanceled != null)
+            {
+                m_onReportCanceled();
+            }
+        }
+
+        private void SetupComplaintMenu()
+        {
+            m_complaintMenu = new AccessibleMenu(this, GameStrings.Get("GLOBAL_FRIENDLIST_REPORT_SELECT_REASON"), () => HidePopup(false));
+            foreach (var complaint in ReportingPopup.ReportReasons)
+            {
+                m_complaintMenu.AddOption(GameStrings.Get(ReportingPopup.ComplaintTypeLabels[complaint.Key]), () => SelectComplaint(complaint.Key, complaint.Value));
+            }
+        }
+
+        private void SelectComplaint(ReportType.ComplaintType complaint, List<ReportType.SubcomplaintType> subcomplaints)
+        {
+            m_selectedComplaint = complaint;
+            m_selectedSubcomplaints.Clear();
+            m_subcomplaintCheckboxes = new List<AccessibleCheckBox>();
+            foreach (var subcomplaint in subcomplaints)
+            {
+                m_subcomplaintCheckboxes.Add(new AccessibleCheckBox(this, GameStrings.Get(ReportingPopup.SubcomplaintTypeLabels[subcomplaint]), () => ToggleSubcomplaintSelection(subcomplaint), () => m_selectedSubcomplaints.Contains(subcomplaint)));
+            }
+
+            m_subcomplaintMenu = new AccessibleMenu(this, GameStrings.Get("GLOBAL_FRIENDLIST_REPORT_SELECT_OPTIONS"), ReadComplaintMenu);
+            foreach (var checkbox in m_subcomplaintCheckboxes)
+            {
+                m_subcomplaintMenu.AddOption(checkbox.GetText, checkbox.Toggle);
+            }
+
+            m_subcomplaintMenu.AddOption(GameStrings.Get("GLOBAL_BUTTON_SUBMIT"), SubmitReport);
+            m_subcomplaintMenu.StartReading();
+            m_curState = State.SUBCOMPLAINT_MENU;
+        }
+
+        private void ToggleSubcomplaintSelection(ReportType.SubcomplaintType subcomplaint)
+        {
+            if (!m_selectedSubcomplaints.Remove(subcomplaint))
+            {
+                m_selectedSubcomplaints.Add(subcomplaint);
+            }
+        }
+
+        private void SubmitReport()
+        {
+            if (m_selectedSubcomplaints.Count == 0)
+            {
+                AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_REPORTING_POPUP_NO_SUBCOMPLAINTS_SELECTED));
+                return;
+            }
+
+            AccessibilityUtils.LogDebug($"Reporting player {m_player.GetBestName()}: complaint type = {Enum.GetName(typeof(ReportType.ComplaintType), m_selectedComplaint.Value)}, subcomplaints = {String.Join(", ", m_selectedSubcomplaints.Select((s) => Enum.GetName(typeof(ReportType.SubcomplaintType), s)))}");
+            BattleNet.Get().SubmitReport(m_player.GetAccountId(), m_selectedComplaint.Value, new List<ReportType.SubcomplaintType>(m_selectedSubcomplaints));
+            AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_FRIENDLIST_REPORT_SELECT_COMPLETE"));
+            HidePopup(true);
+        }
+
+        private void ReadComplaintMenu()
+        {
+            m_complaintMenu.StartReading();
+            m_curState = State.COMPLAINT_MENU;
+        }
+
+        public string GetAccessibleHelp()
+        {
+            switch (m_curState)
+            {
+                case State.COMPLAINT_MENU:
+                return m_complaintMenu.GetHelp();
+                case State.SUBCOMPLAINT_MENU:
+                return m_subcomplaintMenu.GetHelp();
+                default:
+                return "";
+            }
+        }
+
+        public void HandleAccessibleInput()
+        {
+            switch (m_curState)
+            {
+                case State.COMPLAINT_MENU:
+                m_complaintMenu?.HandleAccessibleInput();
+                break;
+                case State.SUBCOMPLAINT_MENU:
+                m_subcomplaintMenu?.HandleAccessibleInput();
+                break;
+            }
+        }
+
+        }
+    }
diff --git a/Assembly-CSharp/Accessibility/Testing/AccessibleQuestsTestingUtils.cs b/Assembly-CSharp/Accessibility/Testing/AccessibleQuestsTestingUtils.cs
new file mode 100644
index 0000000..7f013f8
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Testing/AccessibleQuestsTestingUtils.cs
@@ -0,0 +1,245 @@
+﻿using Assets;
+using Hearthstone.DataModels;
+using Hearthstone.Progression;
+using PegasusUtil;
+using System;
+using System.Collections.Generic;
+using System.Text;
+
+namespace Accessibility
+{
+    class AccessibleQuestsTestingUtils
+    {
+		private static QuestListDataModel s_quests;
+
+		private static bool s_poolEnabled;
+
+		private static RerollQuestResponse s_rerollResponse;
+
+		internal static bool SetScenario(int scenarioId)
+		{
+			switch (scenarioId)
+			{
+				case 0:
+					s_poolEnabled = false;
+					s_quests = null;
+					return true;
+				case 1:
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { });
+					return true;
+				case 2:
+					// Daily quests only
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126 });
+					return true;
+				case 3:
+					// Weekly quests only
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { -1, 98, 97, 94 });
+					return true;
+				case 4:
+					// 4 daily + 3 weekly
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126, 64, 56, 98, 97, 94 });
+					return true;
+				case 5:
+					// 5 "daily" to test bounds (which are 4)
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126, 64, 56, 22 });
+					return true;
+				case 6:
+					// 5 daily + 3 weekly
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126, 64, 56, 22, 98, 97, 94 });
+					return true;
+				case 7:
+					// Including "next quest in X" tiles
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126, 64, -1, 98, 97, -2, -2 });
+					return true;
+				case 8:
+					// All quests complete scenario
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { -1, -2, -2, -2 });
+					return true;
+				// Abandon scenarios
+				case 9:
+					// Abandon first quest
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 126 });
+					return true;
+				case 10:
+					// Abandon last quest
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 126, 142 });
+					return true;
+				case 11:
+					// Abandon only quest
+					s_poolEnabled = false;
+					s_quests = CreateQuestListDataModel(new int[] { 142 });
+					return true;
+				case 12:
+					// Abandon only daily quest when a weekly one exists as well
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 142, 98 });
+					return true;
+				// Reroll scenarios
+				case 13:
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { -1, 98, -2, -2 });
+					return true;
+				case 99:
+					// Weekly quests only - special QuestsPopupOnLoginTest scenario
+					s_poolEnabled = true;
+					s_quests = CreateQuestListDataModel(new int[] { 98, 97, 94 });
+					return true;
+				default:
+					return false;
+			}
+		}
+
+		private static QuestListDataModel CreateQuestListDataModel(int[] questIds)
+		{
+			var ret = new QuestListDataModel();
+			ret.Quests = new Hearthstone.UI.DataModelList<QuestDataModel>();
+
+			foreach (var questId in questIds)
+			{
+				if (questId == -1)
+				{
+					var questPoolRecord = GetQuestPoolRecord(QuestPool.QuestPoolType.DAILY);
+					var timeUntilNextQuestString = QuestManager.Get().GetElapsedTimeString(new TimeSpan(3, 59, 0));
+					var questTile = QuestManager.Get().CreateNextQuestTimeDataModel(questPoolRecord, timeUntilNextQuestString);
+					ret.Quests.Add(questTile);
+				}
+				else if (questId == -2)
+				{
+					var questPoolRecord = GetQuestPoolRecord(QuestPool.QuestPoolType.WEEKLY);
+					var timeUntilNextQuestString = QuestManager.Get().GetElapsedTimeString(new TimeSpan(24 * 6 + 23, 0, 0));
+					var questTile = QuestManager.Get().CreateNextQuestTimeDataModel(questPoolRecord, timeUntilNextQuestString);
+					ret.Quests.Add(questTile);
+				}
+				else
+				{
+					ret.Quests.Add(QuestManager.Get().CreateQuestDataModelById(questId));
+				}
+			}
+
+			return ret;
+		}
+
+		private static QuestPoolDbfRecord GetQuestPoolRecord(QuestPool.QuestPoolType questPoolType)
+		{
+			var records = GameDbf.QuestPool.GetRecords();
+
+			foreach(var record in records)
+			{
+				if (record.QuestPoolType == questPoolType)
+				{
+					return record;
+				}
+			}
+
+			return null;
+		}
+
+		internal static QuestListDataModel GetQuests()
+		{
+			return s_quests;
+		}
+
+		internal static QuestListDataModel GetQuestsForPoolType(QuestPool.QuestPoolType questPoolType)
+		{
+			if (s_quests == null)
+			{
+				return CreateQuestListDataModel(new int[] { });
+			}
+
+			var ret = new QuestListDataModel();
+			ret.Quests = new Hearthstone.UI.DataModelList<QuestDataModel>();
+
+			foreach (var quest in s_quests.Quests)
+			{
+				if (quest.PoolType == questPoolType)
+				{
+					ret.Quests.Add(quest);
+				}
+			}
+
+			return ret;
+		}
+
+		internal static bool IsMockingQuests()
+		{
+			return s_quests != null;
+		}
+
+		internal static PlayerQuestStateUpdate GetPlayerQuestStateUpdate()
+		{
+			var ret = new PlayerQuestStateUpdate();
+			ret.Quest = new List<PlayerQuestState>();
+
+			foreach (var quest in s_quests.Quests)
+			{
+				var questState = new PlayerQuestState();
+				questState.QuestId = quest.QuestId;
+				questState.Progress = quest.Progress;
+				questState.Status = (int)quest.Status;
+				ret.Quest.Add(questState);
+			}
+
+			return ret;
+		}
+
+		internal static bool RerollQuest(int questId)
+		{
+			s_rerollResponse = new RerollQuestResponse();
+			s_rerollResponse.RerolledQuestId = questId;
+			s_rerollResponse.GrantedQuestId = 94;
+			s_rerollResponse.Success = true;
+
+			return true;
+		}
+
+		internal static void ReceiveRerollQuestResponseMessage()
+		{
+			QuestManager.Get().ReceiveRerollQuestResponseMessage();
+		}
+
+		internal static bool AbandonQuest(int questId)
+		{
+			return true;
+		}
+
+		internal static PlayerQuestPoolStateUpdate GetPlayerQuestPoolStateUpdate()
+		{
+			var ret = new PlayerQuestPoolStateUpdate();
+			ret.QuestPool = new List<PlayerQuestPoolState>();
+			var dailyState = new PlayerQuestPoolState();
+			dailyState.QuestPoolId = GetQuestPoolRecord(QuestPool.QuestPoolType.DAILY).ID;
+			dailyState.RerollAvailableCount = 0;
+			dailyState.SecondsUntilNextGrant = 4 * 60 * 60;
+
+			var weeklyState = new PlayerQuestPoolState();
+			weeklyState.QuestPoolId = GetQuestPoolRecord(QuestPool.QuestPoolType.WEEKLY).ID;
+			weeklyState.RerollAvailableCount = 1;
+			weeklyState.SecondsUntilNextGrant = 7 * 24 * 60 * 60;
+
+			ret.QuestPool.Add(dailyState);
+			ret.QuestPool.Add(weeklyState);
+
+			return ret;
+		}
+
+		internal static RerollQuestResponse GetRerollQuestResponse()
+		{
+			return s_rerollResponse;
+		}
+
+		internal static bool CanBeGrantedPoolQuests()
+		{
+			return s_poolEnabled;
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/Testing/AccessibleRewardsTrackTestingUtils.cs b/Assembly-CSharp/Accessibility/Testing/AccessibleRewardsTrackTestingUtils.cs
new file mode 100644
index 0000000..7b6bb02
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/Testing/AccessibleRewardsTrackTestingUtils.cs
@@ -0,0 +1,204 @@
+﻿using Hearthstone.Progression;
+using PegasusUtil;
+using System.Collections.Generic;
+using Blizzard.T5.Core;
+
+namespace Accessibility
+{
+	class AccessibleRewardsTrackTestingUtils
+	{
+		// Note: this needs to be updated every time the rewards track resets (the automated suite will fail with 0 rewards left to claim regardless of the scenario)
+		// The code is protected to stop Network requests from firing though so mocks should keep working and leave the actual track untouched unless something changes
+		// at some point
+		private static int TEST_TRACK_ID = 28;
+
+		private static Map<int, PlayerRewardTrackLevelState> s_cheatState;
+
+		private static bool s_premiumRewardsUnlocked;
+
+		private static int s_currentTrackLevel;
+
+		private static int s_currentTrackId;
+
+		internal static bool SetScenario(int scenarioId)
+		{
+			var ret = SetScenarioInternal(scenarioId);
+			RewardTrackManager.Get().GetRewardTrack(Assets.Achievement.RewardTrackType.GLOBAL).Cheat_SetPlayerRewardTrackLevelState(s_cheatState);
+			return ret;
+		}
+
+		private static bool SetScenarioInternal(int scenarioId)
+		{
+			switch(scenarioId)
+			{
+				case 0:
+					s_cheatState = null;
+					s_premiumRewardsUnlocked = false;
+					s_currentTrackLevel = 0;
+					s_currentTrackId = 0;
+					return true;
+				case 1:
+					CreateStateUpToLevel(0, 1, TEST_TRACK_ID, false);
+					return true;
+				case 2:
+					CreateStateUpToLevel(10, 12, TEST_TRACK_ID, false);
+					return true;
+				case 3:
+					CreateStateUpToLevel(13, 16, TEST_TRACK_ID, false);
+					return true;
+				case 4:
+					CreateStateUpToLevel(13, 16, TEST_TRACK_ID, true);
+					return true;
+				case 5:
+					CreateStateUpToLevel(100, 103, TEST_TRACK_ID, true);
+					return true;
+				case 6:
+					// Choose one
+					CreateStateUpToLevel(99, 100, TEST_TRACK_ID, true);
+					return true;
+				case 7:
+					// Nothing to claim from the start
+					CreateStateUpToLevel(1, 1, TEST_TRACK_ID, false);
+					return true;
+				default:
+					return false;
+			}
+		}
+
+		private static void CreateStateUpToLevel(int lastClaimedLevel, int curLevel, int trackId, bool includePremium)
+		{
+			s_cheatState = new Map<int, PlayerRewardTrackLevelState>();
+
+			var paidRewardStatus = includePremium ? 1 : 0;
+
+			for (int i = 1; i <= lastClaimedLevel; i++)
+			{
+				s_cheatState[i] = new PlayerRewardTrackLevelState
+				{
+					Level = i,
+					FreeRewardStatus = 1,
+					PaidRewardStatus = paidRewardStatus
+				};
+			}
+
+			for (int i = lastClaimedLevel + 1; i <= curLevel; i++)
+			{
+				s_cheatState[i] = new PlayerRewardTrackLevelState
+				{
+					Level = i,
+					FreeRewardStatus = 0,
+					PaidRewardStatus = 0
+				};
+			}
+
+			s_currentTrackId = trackId;
+			s_currentTrackLevel = curLevel;
+			s_premiumRewardsUnlocked = includePremium;
+		}
+
+		internal static bool IsMockingRewardsTrack()
+		{
+			return s_cheatState != null;
+		}
+
+		private static PlayerRewardTrackState s_stateUpdateAckdReward;
+
+		internal static bool AckRewardTrackReward(int rewardTrackId, int level, bool forPaidTrack)
+		{
+			// Note: turns out this isn't actually needed as ACKs are fire and forget
+			s_stateUpdateAckdReward = CreatePlayerRewardTrackStateUpdate(rewardTrackId, level, forPaidTrack, 2);
+
+			var notif = "Waiting for ACK response";
+			AccessibilityMgr.OutputNotification(notif);
+
+			return true;
+		}
+
+		private static PlayerRewardTrackState s_stateUpdateClaimedReward;
+
+		internal static bool ClaimRewardTrackReward(int rewardTrackId, int level, bool forPaidTrack, int chooseOneRewardItemId)
+		{
+			s_stateUpdateClaimedReward = CreatePlayerRewardTrackStateUpdate(rewardTrackId, level, forPaidTrack, 1);
+
+			if (chooseOneRewardItemId != 0)
+			{
+				RewardItemOutput rewardItem = new RewardItemOutput();
+				rewardItem.RewardItemId = chooseOneRewardItemId;
+				var rewardItemOutputs = new List<RewardItemOutput>();
+				rewardItemOutputs.Add(rewardItem);
+
+				s_stateUpdateClaimedReward.TrackLevel[0].RewardItemOutput = rewardItemOutputs;
+			}
+
+			var notif = "Waiting for Claimed response";
+			AccessibilityMgr.OutputNotification(notif);
+
+			return true;
+		}
+
+		private static PlayerRewardTrackState CreatePlayerRewardTrackStateUpdate(int rewardTrackId, int level, bool forPaidTrack, int newStatus)
+		{
+			var ret = new PlayerRewardTrackState();
+			ret.RewardTrackId = rewardTrackId;
+			ret.Level = level;
+			ret.TrackLevel = new List<PlayerRewardTrackLevelState>();
+
+			var curLevelState = s_cheatState[level];
+			var levelState = new PlayerRewardTrackLevelState();
+			levelState.Level = curLevelState.Level;
+			levelState.FreeRewardStatus = curLevelState.FreeRewardStatus;
+			levelState.PaidRewardStatus = curLevelState.PaidRewardStatus;
+
+			if (forPaidTrack)
+			{
+				levelState.PaidRewardStatus = newStatus;
+			}
+			else
+			{
+				levelState.FreeRewardStatus = newStatus;
+			}
+
+			ret.TrackLevel.Add(levelState);
+
+			return ret;
+		}
+
+		internal static bool TriggerClaimedRewardResponse()
+		{
+			if (s_stateUpdateClaimedReward != null)
+			{
+				RewardTrackManager.Get().GetRewardTrack(Assets.Achievement.RewardTrackType.GLOBAL).HandleRewardTrackStateUpdate(s_stateUpdateClaimedReward);
+				return true;
+			}
+
+			return false;
+		}
+
+		internal static bool TriggerAckdRewardResponse()
+		{
+			// This isn't actually needed as the ACK after grant is fire and forget
+			if (s_stateUpdateAckdReward != null)
+			{
+				RewardTrackManager.Get().GetRewardTrack(Assets.Achievement.RewardTrackType.GLOBAL).HandleRewardTrackStateUpdate(s_stateUpdateAckdReward);
+				return true;
+			}
+
+			return false;
+		}
+
+		internal static bool ArePremiumRewardsUnlocked()
+		{
+			return s_premiumRewardsUnlocked;
+		}
+
+		internal static int GetCurrentTrackLevel()
+		{
+			return s_currentTrackLevel;
+		}
+
+		internal static int GetCurrentTrackId()
+		{
+			return s_currentTrackId;
+		}
+	}
+}
diff --git a/Assembly-CSharp/Accessibility/arena/AccessibleArenaDisplay.cs b/Assembly-CSharp/Accessibility/arena/AccessibleArenaDisplay.cs
new file mode 100644
index 0000000..ff26271
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/arena/AccessibleArenaDisplay.cs
@@ -0,0 +1,132 @@
+using Assets;
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleArenaDisplay : AccessibleScreen
+    {
+        internal enum State {CLASS_CHOICE, DRAFT_CHOICE, DECK_VIEW, MANA_CURVE_VIEW, IDLE_SCREEN, CLAIM_REWARDS_SCREEN, LOADING}
+
+        internal static State m_curState = State.LOADING;
+	    private static AccessibleHorizontalMenu<AccessibleArenaDraftCard> m_accessibleDeckView;
+	    private static AccessibleHorizontalMenu<AccessibleArenaDraftCard> m_accessibleDraftChoices; 
+            private static AccessibleArenaDisplay s_instance = new AccessibleArenaDisplay();
+            private static int m_deckViewIndex=0;
+private static AccessibleMenu m_idleMenu;
+private static bool m_isDrafting=false;
+
+        internal static AccessibleArenaDisplay Get()
+        {
+            return s_instance;
+        }
+        internal static void OnDraftScreenShown() {
+
+        }
+
+        public static void ArenaIdleMenu() {
+            if(m_curState==State.DECK_VIEW) return;
+            m_curState=State.IDLE_SCREEN;
+        m_isDrafting=false;
+            m_idleMenu=new AccessibleMenu(null, DraftManager.Get().GetSceneHeadlineText(),() => DraftDisplay.Get().m_backButton.TriggerRelease());
+            m_idleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.ARENA_WINS_LOSSES,DraftManager.Get().GetWins(),DraftManager.Get().GetLosses()),null);
+            if(DraftDisplay.Get().m_playButton.IsEnabled()) {
+                m_idleMenu.AddOption(DraftDisplay.Get().m_playButton.m_newPlayButtonText.Text,() => DraftDisplay.Get().m_playButton.TriggerRelease());
+            }
+            m_idleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_MENU_SEE_DECK_OPTION),() => BuildDeckView());
+                        if(DraftDisplay.Get().m_retireButton.IsEnabled()) {
+                m_idleMenu.AddOption(DraftDisplay.Get().m_retireButton.m_buttonText.Text,() => DraftDisplay.Get().m_retireButton.TriggerRelease());
+            }
+            m_idleMenu.StartReading();
+        }
+
+        public static void BuildDeckView() {
+            m_curState=State.DECK_VIEW;
+            CollectionDeck draftDeck = DraftManager.Get().GetDraftDeck();   
+            List<CollectionDeckSlot> cards=draftDeck.GetSlots();
+            string menuTitle=LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_EDIT_DECK_CARDS_IN_DECK,draftDeck.GetTotalCardCount(), draftDeck.GetMaxCardCount());
+            m_accessibleDeckView= new AccessibleHorizontalMenu<AccessibleArenaDraftCard>(null, menuTitle, () => GoBackFromDeckView());
+            for(int i=0; i<cards.Count; i++) {
+                                                AccessibleArenaDraftCard newCard=new AccessibleArenaDraftCard(null, cards[i].GetEntityDef(),cards[i].Count);
+                                                                                m_accessibleDeckView.AddOption(newCard,null);
+    }
+    m_accessibleDeckView.StartReading();
+}
+
+        private static void GoBackFromDeckView() {
+            if(!m_isDrafting) {
+                m_curState=State.IDLE_SCREEN;
+                ArenaIdleMenu();
+            }
+            else {
+                DraftDisplay.Get().m_backButton.TriggerRelease();
+            }
+        }
+
+        public static void BuildDraftChoicesList(List<DraftDisplay.DraftChoice> cards) {
+            m_curState=State.DRAFT_CHOICE;
+            m_isDrafting=true;
+            m_accessibleDraftChoices= new AccessibleHorizontalMenu<AccessibleArenaDraftCard>(null, "",() => DraftDisplay.Get().m_backButton.TriggerRelease());
+            List<DraftCardVisual> visuals=DraftDisplay.Get().GetCardVisuals();
+            for(int i=0; i<cards.Count; i++) {
+                DraftCardVisual v=visuals[i];
+                var c=cards[i].m_actor;
+                if(c==null) c=cards[i].m_subActor;
+                                                AccessibleArenaDraftCard newCard=new AccessibleArenaDraftCard(null, c.GetEntityDef());
+                                m_accessibleDraftChoices.AddOption(newCard,() => v.ChooseThisCard());
+            }
+AccessibilityMgr.SetScreen(AccessibleArenaDisplay.Get());
+            m_accessibleDraftChoices.StartReading();
+        }
+
+        public void OnGainedFocus() {
+            /*
+            if(m_curState==State.DRAFT_CHOICE) {
+                m_accessibleDraftChoices.StartReading();
+            }
+            if(m_curState==State.DECK_VIEW) {
+                m_accessibleDeckView.StartReading();
+            }
+            if(m_curState==State.IDLE_SCREEN) {
+                m_idleMenu.StartReading();
+            }
+*/
+        }
+
+        public void HandleInput() {
+            if(m_curState==State.DRAFT_CHOICE) {
+                m_accessibleDraftChoices.HandleAccessibleInput();
+            }
+            if(m_curState==State.IDLE_SCREEN) {
+                m_idleMenu.HandleAccessibleInput();
+            }
+                        if(m_curState==State.DECK_VIEW) {
+                m_accessibleDeckView.HandleAccessibleInput();
+            }
+if(AccessibleKey.READ_NEXT_VALID_MENU_OPTION.IsPressed()) {
+            if(m_curState==State.DRAFT_CHOICE) {
+                BuildDeckView();
+            }
+else if(m_curState==State.DECK_VIEW&&m_isDrafting) {
+    m_curState=State.DRAFT_CHOICE;
+                m_accessibleDraftChoices.StartReading();
+            }
+
+            }
+        }
+
+        public string GetHelp() {
+            string ret="";
+            if(m_isDrafting) {
+                ret+=LocalizationUtils.Format(LocalizationKey.ARENA_DRAFT_SWITCH_HELP,AccessibleKey.READ_NEXT_VALID_ITEM);
+            }
+            if(m_curState==State.DRAFT_CHOICE) {
+                ret+=m_accessibleDraftChoices?.GetHelp();
+            }
+            if(m_curState==State.DECK_VIEW) {
+                ret+=m_accessibleDeckView?.GetHelp();
+            }
+            return ret;
+        }
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Accessibility/arena/AccessibleArenaDraftCard.cs b/Assembly-CSharp/Accessibility/arena/AccessibleArenaDraftCard.cs
new file mode 100644
index 0000000..bed8b8c
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/arena/AccessibleArenaDraftCard.cs
@@ -0,0 +1,218 @@
+using System;
+using System.Collections.Generic;
+
+namespace Accessibility
+{
+    class AccessibleArenaDraftCard : AccessibleItem
+    {
+        private readonly EntityDef m_entityDef;
+
+        private bool m_readClass;
+
+        private bool m_countOverride=true;
+        private int m_count;
+        internal AccessibleArenaDraftCard(AccessibleComponent parent, EntityDef def, int count=1) : base(parent)
+        {
+            m_entityDef=def;
+            m_count=count;
+        }
+
+        internal override List<string> GetLines()
+        {
+            switch (m_entityDef.GetCardType())
+            {
+                case TAG_CARDTYPE.HERO:
+                    return GetLinesForHero();
+                case TAG_CARDTYPE.HERO_POWER:
+                    return GetLinesForHeroPower();
+                case TAG_CARDTYPE.WEAPON:
+                case TAG_CARDTYPE.ENCHANTMENT:
+                case TAG_CARDTYPE.MINION:
+                case TAG_CARDTYPE.SPELL:
+                    return GetLinesForNormalCard();
+                default:
+                    Log.Accessibility.PrintError($"AccessibleCollectibleCard: Found unhandled CardType {m_entityDef.GetCardType()}");
+                    return GetLinesForNormalCard();
+            }
+        }
+
+        private List<string> GetLinesForHero()
+        {
+            if (m_entityDef.IsHeroSkin())
+            {
+                return GetLinesForHeroSkin();
+            }
+            else if (m_entityDef.GetArmor() > 0) // TODO: Figure out how we can differentiate this as this is a wild guess
+            {
+                return GetLinesForHeroCard();
+            }
+            else
+            {
+                // Generic default just in case we're missing something
+                var lines = new List<string>();
+                lines.Add(GetName());
+
+                AccessibleCardUtils.AddLineIfExists(GetResources(), lines);
+
+                return lines;
+            }
+        }
+
+        private List<string> GetLinesForHeroCard()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+            if (m_readClass)
+            {
+                lines.Add(GetClassName());
+            }
+            lines.Add(GetCost());
+            lines.Add(GetCardType());
+
+            var armor = m_entityDef.GetArmor();
+
+            lines.Add(LocalizationUtils.Format(LocalizationKey.READ_HERO_CARD_ARMOR, armor));
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            try
+            {
+                lines.AddRange(AccessibleCardUtils.GetHeroPowerCardLinesForHeroCard(m_entityDef.GetCardId()));
+            }
+            catch (Exception e)
+            {
+                AccessibilityUtils.LogFatalError(e);
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetRarity(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetSet(m_entityDef), lines);
+
+            return lines;
+        }
+
+        private string GetClassName()
+        {
+            return GameStrings.GetClassName(m_entityDef.GetClass());
+        }
+
+        private List<string> GetLinesForHeroSkin()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+
+                lines.Add(GetClassName());
+            return lines;
+        }
+
+        private List<string> GetLinesForHeroPower()
+        {
+            var lines = new List<string>();
+            lines.Add(GetName());
+            lines.Add(GetCost());
+
+            AccessibleCardUtils.AddLineIfExists(GetDescription(), lines);
+
+            return lines;
+        }
+
+        private List<string> GetLinesForNormalCard()
+        {
+            string className = null;
+            if (m_readClass)
+            {
+                className = GetClassName();
+            }
+
+            var lines = new List<string>();
+
+            if (IsCoin())
+            {
+                AddCoinName(lines);
+                AddFavoriteCoinIfNeeded(lines);
+                
+                lines.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(m_entityDef, TAG_PREMIUM.NORMAL));
+            }
+            else
+            {
+                lines.AddRange(AccessibleCardUtils.GetLinesForNormalEntityDef(m_entityDef, TAG_PREMIUM.NORMAL, className, false, GetNumCopies()));
+            }
+
+            AccessibleCardUtils.AddLineIfExists(GetCardCount(), lines);
+
+            AccessibleCardUtils.AddLineIfExists(AccessibleCardUtils.GetSet(m_entityDef), lines);
+
+            return lines;
+        }
+
+        private bool IsCoin()
+        {
+            return false;
+        }
+
+        private void AddCoinName(List<string> lines)
+        {
+
+        }
+
+        private void AddFavoriteCoinIfNeeded(List<string> lines)
+        {
+
+        }
+
+        private string GetDescription()
+        {
+            return m_entityDef.GetCardTextInHand();
+        }
+
+        private string GetCardType()
+        {
+            return AccessibleCardUtils.GetType(m_entityDef.GetCardType());
+        }
+
+        private string GetRarity()
+        {
+            return AccessibleCardUtils.GetRarity(m_entityDef);
+        }
+
+        private string GetCost()
+        {
+            return AccessibleCardUtils.GetCardCost(m_entityDef.GetCost());
+        }
+
+        private string GetCardCount()
+        {
+            var numCopies = GetNumCopies();
+
+            if (numCopies <= 1)
+            {
+                return "";
+            }
+            return LocalizationUtils.Format(LocalizationKey.READ_CARD_N_COPIES, numCopies);
+        }
+
+        private int GetNumCopies()
+        {
+            if (m_countOverride)
+            {
+                // Used by e.g. deck builder
+                return m_count;
+            }
+            else
+            {
+                return 1;
+            }
+        }
+
+        private string GetResources()
+        {
+            return AccessibleCardUtils.GetResourcesForEntityDef(m_entityDef);
+        }
+
+        internal string GetName()
+        {
+            return AccessibleCardUtils.GetNameWithPremium(m_entityDef.GetName(), TAG_PREMIUM.NORMAL);
+        }
+    }
+}
diff --git a/Assembly-CSharp/Accessibility/wip.txt b/Assembly-CSharp/Accessibility/wip.txt
new file mode 100644
index 0000000..1b46d0d
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/wip.txt
@@ -0,0 +1,190 @@
+ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HERO_HELP	Press {0} to look at your hero	0=key
+ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_HERO_HELP	Press {0} to look at your opponent's hero	0=key
+ACCESSIBILITY_GAMEPLAY_READ_CARDS_HELP	Use the up and down arrow keys to read cards
+ACCESSIBILITY_GAMEPLAY_CONFIRM_TO_ATTACK_TARGET	Press {0} to attack this target	0=key
+ACCESSIBILITY_GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION	Press {0} to summon this minion	0=key
+ACCESSIBILITY_GAMEPLAY_OPPONENT_TURN_VOICE	Your opponent is playing
+ACCESSIBILITY_GAMEPLAY_CONFIRM_END_TURN_HELP	Press {0} or {1} to end your turn. Press any other key to cancel	0=confirm key 1=end turn key
+ACCESSIBILITY_GAMEPLAY_SEE_VALID_OPTIONS	Use {0} to go through your valid options	0=key
+ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HAND_HELP	Press {0} to look at your hand	0=key
+ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_HAND_HELP	Press {0} to count the cards in your opponent's hand	0=key
+ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_MINIONS_HELP	Press {0} to look at your summoned minions	0=key
+ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_MINIONS_HELP	Press {0} to look at your opponent's minions	0=key
+ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_SECRETS_HELP	Press {0} to look at your secrets	0=key
+ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP	Press {0} to count your opponent's secrets	0=key
+ACCESSIBILITY_GAMEPLAY_READ_PLAYER_WEAPON_HELP	Press {0} to read your weapon	0=key
+ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_WEAPON_HELP	Press {0} to read your opponent's weapon	0=key
+ACCESSIBILITY_GAMEPLAY_READ_PLAYER_HERO_POWER_HELP	Press {0} to read your hero power	0=key
+ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP	Press {0} to read your opponent's hero power	0=key
+ACCESSIBILITY_GAMEPLAY_READ_PLAYER_HERO_HELP	Press {0} to read your hero	0=key
+ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HERO_HELP	Press {0} to read your opponent's hero	0=key
+ACCESSIBILITY_GAMEPLAY_COUNT_PLAYER_DECK_HELP	Press {0} to count the remaining cards in your deck	0=key
+ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_DECK_HELP	Press {0} to count the remaining cards in your opponent's deck	0=key
+ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA_HELP	Press {0} to read your mana	0=key
+ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_MANA_HELP	Press {0} to read your opponent's mana	0=key
+ACCESSIBILITY_GAMEPLAY_READ_CARD_HELP	Use the up and down arrow keys to read this card
+ACCESSIBILITY_GAMEPLAY_READ_CARD_TOOLTIP_HELP	Press {0} to get a description of this card's abilities	0=key
+ACCESSIBILITY_GAMEPLAY_PLAY_CARD_HELP	Press {0} to play this card	0=key
+ACCESSIBILITY_GAMEPLAY_SUMMON_MINION_HELP	Press {0} to summon this minion	0=key
+ACCESSIBILITY_GAMEPLAY_CHOICE_MODE_HELP	Use the arrow keys to go through your options. Press {0} to choose one	0=key
+ACCESSIBILITY_GAMEPLAY_CHOOSE_TARGET_HELP	Use {0} or the Zone keys to go through your targets. Press {1} to choose a target or {2} to cancel	0=tab key 1=confirm key 2=back key
+ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_MINION_HELP	Press {0} to attack with this minion	0=key
+ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_HERO_HELP	Press {0} to attack with your hero	0=key
+ACCESSIBILITY_GAMEPLAY_USE_HERO_POWER_HELP	Press {0} to use your hero power	0=key
+ACCESSIBILITY_GAMEPLAY_READ_THROUGH_VALID_TARGETS	Use {0} to read through your valid targets	0=key
+ACCESSIBILITY_GAMEPLAY_ATTACK_THIS_MINION_HELP	Press {0} to attack this minion	0=key
+ACCESSIBILITY_GAMEPLAY_ATTACK_PLAYER_HERO_HELP	Press {0} to attack your hero	0=key
+ACCESSIBILITY_GAMEPLAY_ATTACK_OPPONENT_HERO_HELP	Press {0} to attack your opponent's hero	0=key
+ACCESSIBILITY_GAMEPLAY_CANCEL_ATTACK_HELP	Press {0} to cancel the attack	0=key
+ACCESSIBILITY_GAMEPLAY_CANCEL_HELP	Press {0} to cancel	0=key
+ACCESSIBILITY_GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP	Use the left and right arrow keys to choose a position for this minion
+ACCESSIBILITY_GAMEPLAY_OPEN_HISTORY_LOG_HELP	Press {0} to open the play history log	0=key
+ACCESSIBILITY_GAMEPLAY_READ_HISTORY_HELP	Use the up and down arrow keys to read the play history. Press {0} to close the history log	0=key
+ACCESSIBILITY_GAMEPLAY_END_TURN_HELP	Press {0} to end your turn	0=key
+
+ACCESSIBILITY_TUTORIAL_WELCOME_BACK	Welcome back to the tutorial
+ACCESSIBILITY_TUTORIAL_DEFEATED_HOGGER	You've defeated Hogger
+ACCESSIBILITY_TUTORIAL_DEFEATED_MILLHOUSE	You've defeated Millhouse Manastorm
+ACCESSIBILITY_TUTORIAL_DEFEATED_CHO	You've defeated Lorewalker Cho
+ACCESSIBILITY_TUTORIAL_DEFEATED_MUKLA	You've defeated King Mukla
+ACCESSIBILITY_TUTORIAL_DEFEATED_NESINGWARY	You've defeated Hemet Nesingwary
+ACCESSIBILITY_TUTORIAL_DEFEATED_ILLIDAN	You've defeated Illidan Stormrage
+ACCESSIBILITY_TUTORIAL_NEXT_HOGGER	Your next opponent is Hogger
+ACCESSIBILITY_TUTORIAL_NEXT_MILLHOUSE	Your next opponent is Millhouse Manastorm
+ACCESSIBILITY_TUTORIAL_NEXT_CHO	Your next opponent is Lorewalker Cho
+ACCESSIBILITY_TUTORIAL_NEXT_MUKLA	Your next opponent is King Mukla
+ACCESSIBILITY_TUTORIAL_NEXT_NESINGWARY	Your next opponent is Hemet Nesingwary
+ACCESSIBILITY_TUTORIAL_NEXT_ILLIDAN	Your next and final opponent is Illidan Stormrage
+
+ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO	I'll be teaching you how to play through a set of six tutorial games
+ACCESSIBILITY_TUTORIAL_NARRATOR_HELP_KEYS	If you ever feel lost, press {0}. Even after the tutorial or when navigating menus, you can always use {0} whenever you need help	0=key
+ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO_END	Alright, let's get on with it
+ACCESSIBILITY_TUTORIAL_FREE_STARTING_PACK	Here's a basic Mage pack of cards to get you started. Press {0} to open it	0=key
+ACCESSIBILITY_TUTORIAL_NICE_WORK	Nice work
+ACCESSIBILITY_TUTORIAL_NICE_JOB	Nice job
+ACCESSIBILITY_TUTORIAL_NICE_ONE	Nice one
+ACCESSIBILITY_TUTORIAL_GOOD_JOB	Good job
+ACCESSIBILITY_TUTORIAL_YOU_GOT_IT	You got it!
+ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_IT	Remember how to do it?
+ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_THAT	Remember how to do that?
+ACCESSIBILITY_TUTORIAL_TRY_IT_OUT	Try it out!
+ACCESSIBILITY_TUTORIAL_ALL_RIGHT	All right!
+ACCESSIBILITY_TUTORIAL_LETS_LEARN_HOW	Let's learn how
+ACCESSIBILITY_TUTORIAL_CAN_YOU_DO_IT	Can you do it?
+ACCESSIBILITY_TUTORIAL_THINK_YOU_CAN_DO_IT	Think you can do it?
+ACCESSIBILITY_TUTORIAL_GOT_IT	Got it
+ACCESSIBILITY_TUTORIAL_NO_ENDTURN_ATK	Not yet! You can still attack
+ACCESSIBILITY_TUTORIAL_NO_ENDTURN	Not yet! You have more cards to play!
+ACCESSIBILITY_TUTORIAL_NO_ENDTURN_HP	Not yet! Use your Hero Power. Press {0} to select it	0=key
+
+ACCESSIBILITY_TUTORIAL_HOGGER_START	Your first opponent is a gnoll named Hogger. You will be playing as the powerful mage Jaina Proudmoore
+ACCESSIBILITY_TUTORIAL01_HELP_07	Save that for the enemy!
+ACCESSIBILITY_TUTORIAL01_HELP_08	Ignore the puny gnoll and finish off Hogger
+ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_CARD_READ	Use the up and down arrow keys to read this card first
+ACCESSIBILITY_TUTORIAL_HOGGER_SUMMON_MINION_FIRST	Summon the minion you just got first
+ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST	Use {0} and the arrow keys to read your opponent's minions first	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_2_0	When a turn starts, you always begin by drawing a card from your deck. Let's see the one we just drew
+ACCESSIBILITY_TUTORIAL_HOGGER_2_1	Press {0} to look at the cards in your hand	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_2_2	Ok, so... This card is a minion named Murloc Raider
+ACCESSIBILITY_TUTORIAL_HOGGER_2_2B	Minions are creatures that you can summon onto the battlefield to fight for your Hero
+ACCESSIBILITY_TUTORIAL_HOGGER_2_2D	This one costs 1 mana to summon and has 2 attack and 1 health
+ACCESSIBILITY_TUTORIAL_HOGGER_2_3	Let's start by summoning this minion
+ACCESSIBILITY_TUTORIAL_HOGGER_2_4	Press {0} to do so	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_2_5	Press {0} to confirm or {1} to cancel	0=confirm key 1=back key
+ACCESSIBILITY_TUTORIAL_HOGGER_2_6	Minions must wait a turn to attack once they're summoned, so we have nothing left to do
+ACCESSIBILITY_TUTORIAL_HOGGER_3_0	Your opponent's minion attacked your Hero so you took some damage
+ACCESSIBILITY_TUTORIAL_HOGGER_3_1	Let's see how much health we have left
+ACCESSIBILITY_TUTORIAL_HOGGER_3_2	Use the up and down arrow keys to read your hero card
+ACCESSIBILITY_TUTORIAL_HOGGER_3_2_HELP	Use {0} and the arrow keys to find out how much health your Hero has	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_3_3	If your Hero runs out of health, you lose. 28 health is still plenty though
+ACCESSIBILITY_TUTORIAL_HOGGER_3_4	Let's look at your opponent's hero now. Press {0}	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_3_5	Can you find how much health he has?
+ACCESSIBILITY_TUTORIAL_HOGGER_3_5_HELP	Use the up and down arrow keys to read your opponent's hero card
+ACCESSIBILITY_TUTORIAL_HOGGER_3_6	Once your opponent's Hero runs out of health, you win
+ACCESSIBILITY_TUTORIAL_HOGGER_3_7	Let's carry on
+ACCESSIBILITY_TUTORIAL_HOGGER_4_1	Looks like you got another minion. Can you summon this one yourself?
+ACCESSIBILITY_TUTORIAL_HOGGER_4_1_HELP	Use {0} and {1} to summon your minion	0=hand key 1=confirm key
+ACCESSIBILITY_TUTORIAL_HOGGER_4_2	When you already have minions on the battlefield, you can use the left and right arrow keys to select where the new minion will be placed
+ACCESSIBILITY_TUTORIAL_HOGGER_4_4	You now have two minions on the battlefield. This one was just summoned so it must wait a turn to attack
+ACCESSIBILITY_TUTORIAL_HOGGER_4_5	Let's learn how to navigate the battlefield
+ACCESSIBILITY_TUTORIAL_HOGGER_4_6	Use the left and right arrow keys to navigate your minions
+ACCESSIBILITY_TUTORIAL_HOGGER_4_6_HELP	Use {0} and the arrow keys to navigate your summoned minions	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_4_8	Let's look at your opponent's minions now. Press {0} to do so	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_4_9	Can you read this minion by yourself?
+ACCESSIBILITY_TUTORIAL_HOGGER_4_9_HELP	Use the up and down arrow keys to read your opponent's minions
+ACCESSIBILITY_TUTORIAL_HOGGER_4_10	Let's try to attack this minion now
+ACCESSIBILITY_TUTORIAL_HOGGER_4_11	Select the Murloc Raider you summoned last turn
+ACCESSIBILITY_TUTORIAL_HOGGER_4_11_HELP	Use {0} to get to your minion and {1} to launch an attack	0=minions key 1=confirm key
+ACCESSIBILITY_TUTORIAL_HOGGER_4_12	Press {0} to attack with this minion
+ACCESSIBILITY_TUTORIAL_HOGGER_4_13	Can you attack your opponent's minion?
+ACCESSIBILITY_TUTORIAL_HOGGER_4_13_HELP	Use {0} and {1} to attack your opponent's minion	0=opponent minions key 1=confirm key
+ACCESSIBILITY_TUTORIAL_HOGGER_4_16	Both minions had 2 attack and 1 health so they killed each other
+ACCESSIBILITY_TUTORIAL_HOGGER_4_17	Your other minion is still exhausted so there's nothing left to do. Remember how to end your turn?
+ACCESSIBILITY_TUTORIAL_HOGGER_6_1	Looks like you got another minion
+ACCESSIBILITY_TUTORIAL_HOGGER_6_2	This means you have two possible options right now
+ACCESSIBILITY_TUTORIAL_HOGGER_6_3	You can either summon the minion you just got, or use the one you summoned last turn to launch an attack
+ACCESSIBILITY_TUTORIAL_HOGGER_6_4	One way to do this would be using keys such as {0} to look at your hand or {1} to look at your summoned minions	0=hand key 1=minions key
+ACCESSIBILITY_TUTORIAL_HOGGER_6_5	However, there's an easier way to do it
+ACCESSIBILITY_TUTORIAL_HOGGER_6_6	Press {0}	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_6_7	You're now looking at your first option, which would be to summon the minion you just got
+ACCESSIBILITY_TUTORIAL_HOGGER_6_8	Try pressing {0} again	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_6_9	You're now looking at your second option, which would be to attack with the minion you summoned last turn
+ACCESSIBILITY_TUTORIAL_HOGGER_6_10	You can always use {0} to go through your valid options, so make sure to remember this key!	0=key
+ACCESSIBILITY_TUTORIAL_HOGGER_6_12	Alright. Let's begin by summoning the minion we just got
+ACCESSIBILITY_TUTORIAL_HOGGER_6_12_HELP	Use {0} or {1} and {2} to summon your minion	0=tab key 1=hand key 2=confirm key
+ACCESSIBILITY_TUTORIAL_HOGGER_6_13	Let's try to attack with our other minion now
+ACCESSIBILITY_TUTORIAL_HOGGER_6_13_HELP	Use {0} or {1} to find your minion and {2} to launch an attack	0=tab key 1=minions key 2=confirm key
+ACCESSIBILITY_TUTORIAL_HOGGER_6_14	You now have another choice to make. You can either attack one of your opponent's minions, or your opponent's hero himself
+ACCESSIBILITY_TUTORIAL_HOGGER_6_15	You can either use {0} to go through your valid targets or select your target directly using {1} or {2}	0=tab key 1=opponent minions key 2=opponent hero key
+ACCESSIBILITY_TUTORIAL_HOGGER_6_16	Go ahead and choose a target to attack
+ACCESSIBILITY_TUTORIAL_HOGGER_6_16_HELP	Use {0} and {1} to launch an attack	0=tab key 1=confirm key
+ACCESSIBILITY_TUTORIAL_HOGGER_6_21	We're ready to end our turn!
+ACCESSIBILITY_TUTORIAL_HOGGER_8_1	I'll let you continue playing by yourself. Just let me know if you need anything
+
+ACCESSIBILITY_TUTORIAL_02_HELP_01	You gain a Mana Crystal every turn
+ACCESSIBILITY_TUTORIAL02_HELP_03	Your used Mana Crystals refill each turn
+ACCESSIBILITY_TUTORIAL02_HELP_06	Get Millhouse!
+ACCESSIBILITY_TUTORIAL02_HELP_07	Expend your Mana each turn to crush this annoying gnome!
+ACCESSIBILITY_TUTORIAL_RAID_LEADER_DESCRIPTION	This minion has a power that lasts until he dies
+ACCESSIBILITY_TUTORIAL_ARCANE_INTELLECT_DESCRIPTION	You can have 10 cards in your hand
+ACCESSIBILITY_TUTORIAL_MILLHOUSE_SEE_MANA_HELP	Press {0} at any time to see how much mana you have	0=key
+ACCESSIBILITY_TUTORIAL06_HELP_03	Minions with Battlecry do something special when you summon them
+
+ACCESSIBILITY_TUTORIAL_CHO_1	This Voodoo Doctor healed your opponent's Hero
+ACCESSIBILITY_TUTORIAL06_HELP_02	When minions fight each other, they both take damage
+ACCESSIBILITY_TUTORIAL06_HELP_04	Kill enemy minions before they become a problem!
+
+ACCESSIBILITY_TUTORIAL_MUKLA_START	In this game, you'll see some cards with abilities you haven't seen before
+ACCESSIBILITY_TUTORIAL_MUKLA_START_B	If you run into something you don't understand when reading a card such as Charge or Taunt, press {0} to get more information	0=key
+ACCESSIBILITY_TUTORIAL_MUKLA_START_C	Press {0} whenever you're ready to start	0=key
+ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP	This gorilla your opponent just summoned has an ability named Taunt
+ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_B	Minions with Taunt must always be killed before you can attack anyone else
+ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_C	Taunt is an important ability as it can be used to protect your Hero
+ACCESSIBILITY_TUTORIAL04_HELP_14	Welcome to the Jungle
+ACCESSIBILITY_TUTORIAL04_HELP_15	Kill his minions or he'll overwhelm you!
+ACCESSIBILITY_TUTORIAL04_HELP_16	Subdue minions with your hero power and spells!
+ACCESSIBILITY_TUTORIAL04_HELP_02	Sheep it!
+ACCESSIBILITY_TUTORIAL04_HELP_03	Save that for the Fen Creeper!
+
+ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP	From now on, your Hero and your opponent's Hero will normally have a Hero Power
+ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_B	Every Hero has its own Hero Power and you can use it once per turn
+ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_C	You can always press {0} to see your Hero Power and {1} to see your opponent's Hero Power	0=hero power key 1=opponent hero power key
+
+ACCESSIBILITY_TUTORIAL05_HELP_03	This fight is totally not fair. Blame the terrible game designers
+ACCESSIBILITY_TUTORIAL05_HELP_04	Your Taunt minions can protect you from attacks!
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP	It looks like your opponent equipped a weapon
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B	Weapons are special cards which can be equipped by heroes
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C	Each weapon has some attack and some durability
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D	Once equipped, heroes can attack other characters during their turn
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E	Your opponent equipped Warglaive of Azzinoth: a weapon with 2 attack and 2 durability
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F	This means your opponent's Hero will have 2 attack during his turn, and will be able to attack any of your characters
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G	Mages don't often use weapons, but you'll be able to play with some later on once you've unlocked other classes
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H	You can press {0} at any time to see your weapon or {1} to see your opponent's one	0=weapon key 1=opponent weapon key
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP	Hear that sound? Weapons lose durability every time their Hero attacks
+ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B	Once they reach 0 durability, they break and the Hero can no longer attack
+
+ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME	Every normal game starts with the mulligan phase
+ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B	In this phase, both players can replace cards in their starting hand with random ones from their deck
+ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C	Use the arrow keys or {0} to go through your starting hand	0=key
+ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D	If you see a card you don't like, press {0} to mark it for replacement	0=key
+ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E	Once you've marked all cards you'd like to replace, press {0} to draw new ones and start the game	0=key
diff --git a/Assembly-CSharp/Accessibility/wip2.txt b/Assembly-CSharp/Accessibility/wip2.txt
new file mode 100644
index 0000000..ba928b3
--- /dev/null
+++ b/Assembly-CSharp/Accessibility/wip2.txt
@@ -0,0 +1,190 @@
+public static LocalizationKey GAMEPLAY_SEE_PLAYER_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HERO_HELP");
+public static LocalizationKey GAMEPLAY_SEE_OPPONENT_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_HERO_HELP");
+public static LocalizationKey GAMEPLAY_READ_CARDS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARDS_HELP");
+public static LocalizationKey GAMEPLAY_CONFIRM_TO_ATTACK_TARGET = CreateKey("ACCESSIBILITY_GAMEPLAY_CONFIRM_TO_ATTACK_TARGET");
+public static LocalizationKey GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION = CreateKey("ACCESSIBILITY_GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION");
+public static LocalizationKey GAMEPLAY_OPPONENT_TURN_VOICE = CreateKey("ACCESSIBILITY_GAMEPLAY_OPPONENT_TURN_VOICE");
+public static LocalizationKey GAMEPLAY_CONFIRM_END_TURN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CONFIRM_END_TURN_HELP");
+public static LocalizationKey GAMEPLAY_SEE_VALID_OPTIONS = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_VALID_OPTIONS");
+public static LocalizationKey GAMEPLAY_SEE_PLAYER_HAND_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_HAND_HELP");
+public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_HAND_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_HAND_HELP");
+public static LocalizationKey GAMEPLAY_SEE_PLAYER_MINIONS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_MINIONS_HELP");
+public static LocalizationKey GAMEPLAY_SEE_OPPONENT_MINIONS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_OPPONENT_MINIONS_HELP");
+public static LocalizationKey GAMEPLAY_SEE_PLAYER_SECRETS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SEE_PLAYER_SECRETS_HELP");
+public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_SECRETS_HELP");
+public static LocalizationKey GAMEPLAY_READ_PLAYER_WEAPON_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_WEAPON_HELP");
+public static LocalizationKey GAMEPLAY_READ_OPPONENT_WEAPON_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_WEAPON_HELP");
+public static LocalizationKey GAMEPLAY_READ_PLAYER_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_HERO_POWER_HELP");
+public static LocalizationKey GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HERO_POWER_HELP");
+public static LocalizationKey GAMEPLAY_READ_PLAYER_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_HERO_HELP");
+public static LocalizationKey GAMEPLAY_READ_OPPONENT_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_HERO_HELP");
+public static LocalizationKey GAMEPLAY_COUNT_PLAYER_DECK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_PLAYER_DECK_HELP");
+public static LocalizationKey GAMEPLAY_COUNT_OPPONENT_DECK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_COUNT_OPPONENT_DECK_HELP");
+public static LocalizationKey GAMEPLAY_READ_PLAYER_MANA_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_PLAYER_MANA_HELP");
+public static LocalizationKey GAMEPLAY_READ_OPPONENT_MANA_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_OPPONENT_MANA_HELP");
+public static LocalizationKey GAMEPLAY_READ_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARD_HELP");
+public static LocalizationKey GAMEPLAY_READ_CARD_TOOLTIP_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_CARD_TOOLTIP_HELP");
+public static LocalizationKey GAMEPLAY_PLAY_CARD_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_PLAY_CARD_HELP");
+public static LocalizationKey GAMEPLAY_SUMMON_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SUMMON_MINION_HELP");
+public static LocalizationKey GAMEPLAY_CHOICE_MODE_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOICE_MODE_HELP");
+public static LocalizationKey GAMEPLAY_CHOOSE_TARGET_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CHOOSE_TARGET_HELP");
+public static LocalizationKey GAMEPLAY_ATTACK_WITH_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_MINION_HELP");
+public static LocalizationKey GAMEPLAY_ATTACK_WITH_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_WITH_HERO_HELP");
+public static LocalizationKey GAMEPLAY_USE_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_USE_HERO_POWER_HELP");
+public static LocalizationKey GAMEPLAY_READ_THROUGH_VALID_TARGETS = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_THROUGH_VALID_TARGETS");
+public static LocalizationKey GAMEPLAY_ATTACK_THIS_MINION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_THIS_MINION_HELP");
+public static LocalizationKey GAMEPLAY_ATTACK_PLAYER_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_PLAYER_HERO_HELP");
+public static LocalizationKey GAMEPLAY_ATTACK_OPPONENT_HERO_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_ATTACK_OPPONENT_HERO_HELP");
+public static LocalizationKey GAMEPLAY_CANCEL_ATTACK_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CANCEL_ATTACK_HELP");
+public static LocalizationKey GAMEPLAY_CANCEL_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_CANCEL_HELP");
+public static LocalizationKey GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_SUMMONING_CHOOSE_POSITION_HELP");
+public static LocalizationKey GAMEPLAY_OPEN_HISTORY_LOG_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_OPEN_HISTORY_LOG_HELP");
+public static LocalizationKey GAMEPLAY_READ_HISTORY_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_READ_HISTORY_HELP");
+public static LocalizationKey GAMEPLAY_END_TURN_HELP = CreateKey("ACCESSIBILITY_GAMEPLAY_END_TURN_HELP");
+
+public static LocalizationKey TUTORIAL_WELCOME_BACK = CreateKey("ACCESSIBILITY_TUTORIAL_WELCOME_BACK");
+public static LocalizationKey TUTORIAL_DEFEATED_HOGGER = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_HOGGER");
+public static LocalizationKey TUTORIAL_DEFEATED_MILLHOUSE = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_MILLHOUSE");
+public static LocalizationKey TUTORIAL_DEFEATED_CHO = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_CHO");
+public static LocalizationKey TUTORIAL_DEFEATED_MUKLA = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_MUKLA");
+public static LocalizationKey TUTORIAL_DEFEATED_NESINGWARY = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_NESINGWARY");
+public static LocalizationKey TUTORIAL_DEFEATED_ILLIDAN = CreateKey("ACCESSIBILITY_TUTORIAL_DEFEATED_ILLIDAN");
+public static LocalizationKey TUTORIAL_NEXT_HOGGER = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_HOGGER");
+public static LocalizationKey TUTORIAL_NEXT_MILLHOUSE = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_MILLHOUSE");
+public static LocalizationKey TUTORIAL_NEXT_CHO = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_CHO");
+public static LocalizationKey TUTORIAL_NEXT_MUKLA = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_MUKLA");
+public static LocalizationKey TUTORIAL_NEXT_NESINGWARY = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_NESINGWARY");
+public static LocalizationKey TUTORIAL_NEXT_ILLIDAN = CreateKey("ACCESSIBILITY_TUTORIAL_NEXT_ILLIDAN");
+
+public static LocalizationKey TUTORIAL_NARRATOR_INTRO = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO");
+public static LocalizationKey TUTORIAL_NARRATOR_HELP_KEYS = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_HELP_KEYS");
+public static LocalizationKey TUTORIAL_NARRATOR_INTRO_END = CreateKey("ACCESSIBILITY_TUTORIAL_NARRATOR_INTRO_END");
+public static LocalizationKey TUTORIAL_FREE_STARTING_PACK = CreateKey("ACCESSIBILITY_TUTORIAL_FREE_STARTING_PACK");
+public static LocalizationKey TUTORIAL_NICE_WORK = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_WORK");
+public static LocalizationKey TUTORIAL_NICE_JOB = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_JOB");
+public static LocalizationKey TUTORIAL_NICE_ONE = CreateKey("ACCESSIBILITY_TUTORIAL_NICE_ONE");
+public static LocalizationKey TUTORIAL_GOOD_JOB = CreateKey("ACCESSIBILITY_TUTORIAL_GOOD_JOB");
+public static LocalizationKey TUTORIAL_YOU_GOT_IT = CreateKey("ACCESSIBILITY_TUTORIAL_YOU_GOT_IT");
+public static LocalizationKey TUTORIAL_REMEMBER_HOW_TO_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_IT");
+public static LocalizationKey TUTORIAL_REMEMBER_HOW_TO_DO_THAT = CreateKey("ACCESSIBILITY_TUTORIAL_REMEMBER_HOW_TO_DO_THAT");
+public static LocalizationKey TUTORIAL_TRY_IT_OUT = CreateKey("ACCESSIBILITY_TUTORIAL_TRY_IT_OUT");
+public static LocalizationKey TUTORIAL_ALL_RIGHT = CreateKey("ACCESSIBILITY_TUTORIAL_ALL_RIGHT");
+public static LocalizationKey TUTORIAL_LETS_LEARN_HOW = CreateKey("ACCESSIBILITY_TUTORIAL_LETS_LEARN_HOW");
+public static LocalizationKey TUTORIAL_CAN_YOU_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_CAN_YOU_DO_IT");
+public static LocalizationKey TUTORIAL_THINK_YOU_CAN_DO_IT = CreateKey("ACCESSIBILITY_TUTORIAL_THINK_YOU_CAN_DO_IT");
+public static LocalizationKey TUTORIAL_GOT_IT = CreateKey("ACCESSIBILITY_TUTORIAL_GOT_IT");
+public static LocalizationKey TUTORIAL_NO_ENDTURN_ATK = CreateKey("ACCESSIBILITY_TUTORIAL_NO_ENDTURN_ATK");
+public static LocalizationKey TUTORIAL_NO_ENDTURN = CreateKey("ACCESSIBILITY_TUTORIAL_NO_ENDTURN");
+public static LocalizationKey TUTORIAL_NO_ENDTURN_HP = CreateKey("ACCESSIBILITY_TUTORIAL_NO_ENDTURN_HP");
+
+public static LocalizationKey TUTORIAL_HOGGER_START = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_START");
+public static LocalizationKey TUTORIAL01_HELP_07 = CreateKey("ACCESSIBILITY_TUTORIAL01_HELP_07");
+public static LocalizationKey TUTORIAL01_HELP_08 = CreateKey("ACCESSIBILITY_TUTORIAL01_HELP_08");
+public static LocalizationKey TUTORIAL_HOGGER_FORCE_CARD_READ = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_CARD_READ");
+public static LocalizationKey TUTORIAL_HOGGER_SUMMON_MINION_FIRST = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_SUMMON_MINION_FIRST");
+public static LocalizationKey TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_FORCE_LOOK_AT_OPPONENT_MINIONS_FIRST");
+public static LocalizationKey TUTORIAL_HOGGER_2_0 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_0");
+public static LocalizationKey TUTORIAL_HOGGER_2_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_1");
+public static LocalizationKey TUTORIAL_HOGGER_2_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2");
+public static LocalizationKey TUTORIAL_HOGGER_2_2B = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2B");
+public static LocalizationKey TUTORIAL_HOGGER_2_2D = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_2D");
+public static LocalizationKey TUTORIAL_HOGGER_2_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_3");
+public static LocalizationKey TUTORIAL_HOGGER_2_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_4");
+public static LocalizationKey TUTORIAL_HOGGER_2_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_5");
+public static LocalizationKey TUTORIAL_HOGGER_2_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_2_6");
+public static LocalizationKey TUTORIAL_HOGGER_3_0 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_0");
+public static LocalizationKey TUTORIAL_HOGGER_3_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_1");
+public static LocalizationKey TUTORIAL_HOGGER_3_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_2");
+public static LocalizationKey TUTORIAL_HOGGER_3_2_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_2_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_3_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_3");
+public static LocalizationKey TUTORIAL_HOGGER_3_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_4");
+public static LocalizationKey TUTORIAL_HOGGER_3_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_5");
+public static LocalizationKey TUTORIAL_HOGGER_3_5_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_5_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_3_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_6");
+public static LocalizationKey TUTORIAL_HOGGER_3_7 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_3_7");
+public static LocalizationKey TUTORIAL_HOGGER_4_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_1");
+public static LocalizationKey TUTORIAL_HOGGER_4_1_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_1_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_4_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_2");
+public static LocalizationKey TUTORIAL_HOGGER_4_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_4");
+public static LocalizationKey TUTORIAL_HOGGER_4_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_5");
+public static LocalizationKey TUTORIAL_HOGGER_4_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_6");
+public static LocalizationKey TUTORIAL_HOGGER_4_6_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_6_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_4_8 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_8");
+public static LocalizationKey TUTORIAL_HOGGER_4_9 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_9");
+public static LocalizationKey TUTORIAL_HOGGER_4_9_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_9_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_4_10 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_10");
+public static LocalizationKey TUTORIAL_HOGGER_4_11 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_11");
+public static LocalizationKey TUTORIAL_HOGGER_4_11_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_11_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_4_12 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_12");
+public static LocalizationKey TUTORIAL_HOGGER_4_13 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_13");
+public static LocalizationKey TUTORIAL_HOGGER_4_13_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_13_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_4_16 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_16");
+public static LocalizationKey TUTORIAL_HOGGER_4_17 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_4_17");
+public static LocalizationKey TUTORIAL_HOGGER_6_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_1");
+public static LocalizationKey TUTORIAL_HOGGER_6_2 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_2");
+public static LocalizationKey TUTORIAL_HOGGER_6_3 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_3");
+public static LocalizationKey TUTORIAL_HOGGER_6_4 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_4");
+public static LocalizationKey TUTORIAL_HOGGER_6_5 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_5");
+public static LocalizationKey TUTORIAL_HOGGER_6_6 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_6");
+public static LocalizationKey TUTORIAL_HOGGER_6_7 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_7");
+public static LocalizationKey TUTORIAL_HOGGER_6_8 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_8");
+public static LocalizationKey TUTORIAL_HOGGER_6_9 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_9");
+public static LocalizationKey TUTORIAL_HOGGER_6_10 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_10");
+public static LocalizationKey TUTORIAL_HOGGER_6_12 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_12");
+public static LocalizationKey TUTORIAL_HOGGER_6_12_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_12_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_6_13 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_13");
+public static LocalizationKey TUTORIAL_HOGGER_6_13_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_13_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_6_14 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_14");
+public static LocalizationKey TUTORIAL_HOGGER_6_15 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_15");
+public static LocalizationKey TUTORIAL_HOGGER_6_16 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_16");
+public static LocalizationKey TUTORIAL_HOGGER_6_16_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_16_HELP");
+public static LocalizationKey TUTORIAL_HOGGER_6_21 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_6_21");
+public static LocalizationKey TUTORIAL_HOGGER_8_1 = CreateKey("ACCESSIBILITY_TUTORIAL_HOGGER_8_1");
+
+public static LocalizationKey TUTORIAL_02_HELP_01 = CreateKey("ACCESSIBILITY_TUTORIAL_02_HELP_01");
+public static LocalizationKey TUTORIAL02_HELP_03 = CreateKey("ACCESSIBILITY_TUTORIAL02_HELP_03");
+public static LocalizationKey TUTORIAL02_HELP_06 = CreateKey("ACCESSIBILITY_TUTORIAL02_HELP_06");
+public static LocalizationKey TUTORIAL02_HELP_07 = CreateKey("ACCESSIBILITY_TUTORIAL02_HELP_07");
+public static LocalizationKey TUTORIAL_RAID_LEADER_DESCRIPTION = CreateKey("ACCESSIBILITY_TUTORIAL_RAID_LEADER_DESCRIPTION");
+public static LocalizationKey TUTORIAL_ARCANE_INTELLECT_DESCRIPTION = CreateKey("ACCESSIBILITY_TUTORIAL_ARCANE_INTELLECT_DESCRIPTION");
+public static LocalizationKey TUTORIAL_MILLHOUSE_SEE_MANA_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_MILLHOUSE_SEE_MANA_HELP");
+public static LocalizationKey TUTORIAL06_HELP_03 = CreateKey("ACCESSIBILITY_TUTORIAL06_HELP_03");
+
+public static LocalizationKey TUTORIAL_CHO_1 = CreateKey("ACCESSIBILITY_TUTORIAL_CHO_1");
+public static LocalizationKey TUTORIAL06_HELP_02 = CreateKey("ACCESSIBILITY_TUTORIAL06_HELP_02");
+public static LocalizationKey TUTORIAL06_HELP_04 = CreateKey("ACCESSIBILITY_TUTORIAL06_HELP_04");
+
+public static LocalizationKey TUTORIAL_MUKLA_START = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START");
+public static LocalizationKey TUTORIAL_MUKLA_START_B = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START_B");
+public static LocalizationKey TUTORIAL_MUKLA_START_C = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_START_C");
+public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP");
+public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_B");
+public static LocalizationKey TUTORIAL_MUKLA_TAUNT_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_MUKLA_TAUNT_HELP_C");
+public static LocalizationKey TUTORIAL04_HELP_14 = CreateKey("ACCESSIBILITY_TUTORIAL04_HELP_14");
+public static LocalizationKey TUTORIAL04_HELP_15 = CreateKey("ACCESSIBILITY_TUTORIAL04_HELP_15");
+public static LocalizationKey TUTORIAL04_HELP_16 = CreateKey("ACCESSIBILITY_TUTORIAL04_HELP_16");
+public static LocalizationKey TUTORIAL04_HELP_02 = CreateKey("ACCESSIBILITY_TUTORIAL04_HELP_02");
+public static LocalizationKey TUTORIAL04_HELP_03 = CreateKey("ACCESSIBILITY_TUTORIAL04_HELP_03");
+
+public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP");
+public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_B");
+public static LocalizationKey TUTORIAL_HEMET_HERO_POWER_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_HEMET_HERO_POWER_HELP_C");
+
+public static LocalizationKey TUTORIAL05_HELP_03 = CreateKey("ACCESSIBILITY_TUTORIAL05_HELP_03");
+public static LocalizationKey TUTORIAL05_HELP_04 = CreateKey("ACCESSIBILITY_TUTORIAL05_HELP_04");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_E");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_F");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP");
+public static LocalizationKey TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B = CreateKey("ACCESSIBILITY_TUTORIAL_ILLIDAN_WEAPON_DURABILITY_HELP_B");
+
+public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME");
+public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B");
+public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C");
+public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D");
+public static LocalizationKey IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E = CreateKey("ACCESSIBILITY_IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E");
diff --git a/Assembly-CSharp/AchieveManager.cs b/Assembly-CSharp/AchieveManager.cs
index 06b29d5..4e7699b 100644
--- a/Assembly-CSharp/AchieveManager.cs
+++ b/Assembly-CSharp/AchieveManager.cs
@@ -13,922 +13,952 @@ using UnityEngine;
 
 public class AchieveManager : IService, IHasUpdate
 {
-	public delegate void AchieveCanceledCallback(int achieveID, bool success, object userData);
+    public delegate void AchieveCanceledCallback(int achieveID, bool success, object userData);
 
-	private class AchieveCanceledListener : EventListener<AchieveCanceledCallback>
-	{
-		public void Fire(int achieveID, bool success)
-		{
-			m_callback(achieveID, success, m_userData);
-		}
-	}
+    private class AchieveCanceledListener : EventListener<AchieveCanceledCallback>
+    {
+        public void Fire(int achieveID, bool success)
+        {
+            m_callback(achieveID, success, m_userData);
+        }
+    }
 
-	public delegate void AchievesUpdatedCallback(List<Achievement> updatedAchieves, List<Achievement> completedAchieves, object userData);
+    public delegate void AchievesUpdatedCallback(List<Achievement> updatedAchieves, List<Achievement> completedAchieves, object userData);
 
-	private class AchievesUpdatedListener : EventListener<AchievesUpdatedCallback>
-	{
-		public void Fire(List<Achievement> updatedAchieves, List<Achievement> completedAchieves)
-		{
-			m_callback(updatedAchieves, completedAchieves, m_userData);
-		}
-	}
+    private class AchievesUpdatedListener : EventListener<AchievesUpdatedCallback>
+    {
+        public void Fire(List<Achievement> updatedAchieves, List<Achievement> completedAchieves)
+        {
+            m_callback(updatedAchieves, completedAchieves, m_userData);
+        }
+    }
 
-	public delegate void LicenseAddedAchievesUpdatedCallback(List<Achievement> activeLicenseAddedAchieves, object userData);
+    public delegate void LicenseAddedAchievesUpdatedCallback(List<Achievement> activeLicenseAddedAchieves, object userData);
 
-	private class LicenseAddedAchievesUpdatedListener : EventListener<LicenseAddedAchievesUpdatedCallback>
-	{
-		public void Fire(List<Achievement> activeLicenseAddedAchieves)
-		{
-			m_callback(activeLicenseAddedAchieves, m_userData);
-		}
-	}
+    private class LicenseAddedAchievesUpdatedListener : EventListener<LicenseAddedAchievesUpdatedCallback>
+    {
+        public void Fire(List<Achievement> activeLicenseAddedAchieves)
+        {
+            m_callback(activeLicenseAddedAchieves, m_userData);
+        }
+    }
 
-	private static readonly long TIMED_ACHIEVE_VALIDATION_DELAY_TICKS = 600000000L;
+    private static readonly long TIMED_ACHIEVE_VALIDATION_DELAY_TICKS = 600000000L;
 
-	private static readonly long CHECK_LICENSE_ADDED_ACHIEVE_DELAY_TICKS = 3000000000L;
+    private static readonly long CHECK_LICENSE_ADDED_ACHIEVE_DELAY_TICKS = 3000000000L;
 
-	private static readonly long TIMED_AND_LICENSE_ACHIEVE_CHECK_DELAY_TICKS = Math.Min(TIMED_ACHIEVE_VALIDATION_DELAY_TICKS, CHECK_LICENSE_ADDED_ACHIEVE_DELAY_TICKS);
+    private static readonly long TIMED_AND_LICENSE_ACHIEVE_CHECK_DELAY_TICKS = Math.Min(TIMED_ACHIEVE_VALIDATION_DELAY_TICKS, CHECK_LICENSE_ADDED_ACHIEVE_DELAY_TICKS);
 
-	private Map<int, Achievement> m_achievements = new Map<int, Achievement>();
+    private Map<int, Achievement> m_achievements = new Map<int, Achievement>();
 
-	private bool m_allNetAchievesReceived;
+    private bool m_allNetAchievesReceived;
 
-	private int m_numEventResponsesNeeded;
+    private int m_numEventResponsesNeeded;
 
-	private HashSet<int> m_achieveValidationsToRequest = new HashSet<int>();
+    private HashSet<int> m_achieveValidationsToRequest = new HashSet<int>();
 
-	private HashSet<int> m_achieveValidationsRequested = new HashSet<int>();
+    private HashSet<int> m_achieveValidationsRequested = new HashSet<int>();
 
-	private HashSet<int> m_achievesSeenByPlayerThisSession = new HashSet<int>();
+    private HashSet<int> m_achievesSeenByPlayerThisSession = new HashSet<int>();
 
-	private bool m_disableCancelButtonUntilServerReturns;
+    private bool m_disableCancelButtonUntilServerReturns;
 
-	private Map<int, long> m_lastEventTimingValidationByAchieve = new Map<int, long>();
+    private Map<int, long> m_lastEventTimingValidationByAchieve = new Map<int, long>();
 
-	private Map<int, long> m_lastCheckLicenseAddedByAchieve = new Map<int, long>();
+    private Map<int, long> m_lastCheckLicenseAddedByAchieve = new Map<int, long>();
 
-	private long m_lastEventTimingAndLicenseAchieveCheck;
+    private long m_lastEventTimingAndLicenseAchieveCheck;
 
-	private bool m_queueNotifications;
+    private bool m_queueNotifications;
 
-	private List<int> m_achieveNotificationsToQueue = new List<int>();
+    private List<int> m_achieveNotificationsToQueue = new List<int>();
 
-	private List<AchievementNotification> m_blockedAchievementNotifications = new List<AchievementNotification>();
+    private List<AchievementNotification> m_blockedAchievementNotifications = new List<AchievementNotification>();
 
-	private List<AchieveCanceledListener> m_achieveCanceledListeners = new List<AchieveCanceledListener>();
+    private List<AchieveCanceledListener> m_achieveCanceledListeners = new List<AchieveCanceledListener>();
 
-	private List<AchievesUpdatedListener> m_achievesUpdatedListeners = new List<AchievesUpdatedListener>();
+    private List<AchievesUpdatedListener> m_achievesUpdatedListeners = new List<AchievesUpdatedListener>();
 
-	private List<LicenseAddedAchievesUpdatedListener> m_licenseAddedAchievesUpdatedListeners = new List<LicenseAddedAchievesUpdatedListener>();
+    private List<LicenseAddedAchievesUpdatedListener> m_licenseAddedAchievesUpdatedListeners = new List<LicenseAddedAchievesUpdatedListener>();
 
-	public IEnumerator<IAsyncJobResult> Initialize(ServiceLocator serviceLocator)
-	{
-		HearthstoneApplication.Get().WillReset += WillReset;
-		HearthstoneApplication.Get().Resetting += OnReset;
-		LoadAchievesFromDBF();
-		Network network = serviceLocator.Get<Network>();
-		network.RegisterNetHandler(CancelQuestResponse.PacketID.ID, OnQuestCanceled);
-		network.RegisterNetHandler(ValidateAchieveResponse.PacketID.ID, OnAchieveValidated);
-		network.RegisterNetHandler(TriggerEventResponse.PacketID.ID, OnEventTriggered);
-		network.RegisterNetHandler(AccountLicenseAchieveResponse.PacketID.ID, OnAccountLicenseAchieveResponse);
-		serviceLocator.Get<NetCache>().RegisterNewNoticesListener(OnNewNotices);
-		yield break;
-	}
+    public IEnumerator<IAsyncJobResult> Initialize(ServiceLocator serviceLocator)
+    {
+        HearthstoneApplication.Get().WillReset += WillReset;
+        HearthstoneApplication.Get().Resetting += OnReset;
+        LoadAchievesFromDBF();
+        Network network = serviceLocator.Get<Network>();
+        network.RegisterNetHandler(CancelQuestResponse.PacketID.ID, OnQuestCanceled);
+        network.RegisterNetHandler(ValidateAchieveResponse.PacketID.ID, OnAchieveValidated);
+        network.RegisterNetHandler(TriggerEventResponse.PacketID.ID, OnEventTriggered);
+        network.RegisterNetHandler(AccountLicenseAchieveResponse.PacketID.ID, OnAccountLicenseAchieveResponse);
+        serviceLocator.Get<NetCache>().RegisterNewNoticesListener(OnNewNotices);
+        yield break;
+    }
 
-	public Type[] GetDependencies()
-	{
-		return new Type[4]
-		{
-			typeof(Network),
-			typeof(NetCache),
-			typeof(GameDbf),
+    public Type[] GetDependencies()
+    {
+        return new Type[4]
+        {
+            typeof(Network),
+            typeof(NetCache),
+            typeof(GameDbf),
 			typeof(EventTimingManager)
-		};
-	}
-
-	public void Shutdown()
-	{
-	}
-
-	private void WillReset()
-	{
-		m_allNetAchievesReceived = false;
-		m_achieveValidationsToRequest.Clear();
-		m_achieveValidationsRequested.Clear();
-		m_achievesUpdatedListeners.Clear();
-		m_lastEventTimingValidationByAchieve.Clear();
-		m_lastCheckLicenseAddedByAchieve.Clear();
-		m_licenseAddedAchievesUpdatedListeners.Clear();
-		m_achievements.Clear();
-	}
-
-	private void OnReset()
-	{
-		LoadAchievesFromDBF();
-	}
-
-	public static AchieveManager Get()
-	{
-		return ServiceManager.Get<AchieveManager>();
-	}
-
-	public static bool IsPredicateTrue(Assets.Achieve.AltTextPredicate predicate)
-	{
-		if (predicate == Assets.Achieve.AltTextPredicate.CAN_SEE_WILD && CollectionManager.Get() != null && CollectionManager.Get().ShouldAccountSeeStandardWild())
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public void InitAchieveManager()
-	{
-		WillReset();
-		LoadAchievesFromDBF();
-	}
-
-	public bool IsReady()
-	{
-		if (!m_allNetAchievesReceived)
-		{
-			return false;
-		}
-		if (m_numEventResponsesNeeded > 0)
-		{
-			return false;
-		}
-		if (m_achieveValidationsToRequest.Count > 0)
-		{
-			return false;
-		}
-		if (m_achieveValidationsRequested.Count > 0)
-		{
-			return false;
-		}
+        };
+    }
+
+    public void Shutdown()
+    {
+    }
+
+    private void WillReset()
+    {
+        m_allNetAchievesReceived = false;
+        m_achieveValidationsToRequest.Clear();
+        m_achieveValidationsRequested.Clear();
+        m_achievesUpdatedListeners.Clear();
+        m_lastEventTimingValidationByAchieve.Clear();
+        m_lastCheckLicenseAddedByAchieve.Clear();
+        m_licenseAddedAchievesUpdatedListeners.Clear();
+        m_achievements.Clear();
+    }
+
+    private void OnReset()
+    {
+        LoadAchievesFromDBF();
+    }
+
+    public static AchieveManager Get()
+    {
+        return ServiceManager.Get<AchieveManager>();
+    }
+
+    public static bool IsPredicateTrue(Assets.Achieve.AltTextPredicate predicate)
+    {
+        if (predicate == Assets.Achieve.AltTextPredicate.CAN_SEE_WILD && CollectionManager.Get() != null && CollectionManager.Get().ShouldAccountSeeStandardWild())
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public void InitAchieveManager()
+    {
+        WillReset();
+        LoadAchievesFromDBF();
+    }
+
+    public bool IsReady()
+    {
+        if (!m_allNetAchievesReceived)
+        {
+            return false;
+        }
+        if (m_numEventResponsesNeeded > 0)
+        {
+            return false;
+        }
+        if (m_achieveValidationsToRequest.Count > 0)
+        {
+            return false;
+        }
+        if (m_achieveValidationsRequested.Count > 0)
+        {
+            return false;
+        }
 		if (GameUtils.IsTraditionalTutorialComplete() && !GameDownloadManagerProvider.Get().IsReadyToPlay)
 		{
 			return false;
 		}
-		if (NetCache.Get().GetNetObject<NetCache.NetCacheProfileNotices>() == null)
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public bool RegisterAchievesUpdatedListener(AchievesUpdatedCallback callback, object userData = null)
-	{
-		if (callback == null)
-		{
-			return false;
-		}
-		AchievesUpdatedListener achievesUpdatedListener = new AchievesUpdatedListener();
-		achievesUpdatedListener.SetCallback(callback);
-		achievesUpdatedListener.SetUserData(userData);
-		if (m_achievesUpdatedListeners.Contains(achievesUpdatedListener))
-		{
-			return false;
-		}
-		m_achievesUpdatedListeners.Add(achievesUpdatedListener);
-		return true;
-	}
-
-	public bool RemoveAchievesUpdatedListener(AchievesUpdatedCallback callback)
-	{
-		return RemoveAchievesUpdatedListener(callback, null);
-	}
-
-	public bool RemoveAchievesUpdatedListener(AchievesUpdatedCallback callback, object userData)
-	{
-		if (callback == null)
-		{
-			return false;
-		}
-		AchievesUpdatedListener achievesUpdatedListener = new AchievesUpdatedListener();
-		achievesUpdatedListener.SetCallback(callback);
-		achievesUpdatedListener.SetUserData(userData);
-		if (!m_achievesUpdatedListeners.Contains(achievesUpdatedListener))
-		{
-			return false;
-		}
-		m_achievesUpdatedListeners.Remove(achievesUpdatedListener);
-		return true;
-	}
-
-	public List<Achievement> GetNewCompletedAchievesToShow()
-	{
-		List<Achievement> list = new List<Achievement>();
-		QuestManager questManager = QuestManager.Get();
-		foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
-		{
-			Achievement value = achievement.Value;
-			if (value.IsNewlyCompleted() && !value.IsInternal() && value.RewardTiming != Assets.Achieve.RewardTiming.NEVER)
-			{
-				Assets.Achieve.Type achieveType = value.AchieveType;
-				if ((uint)(achieveType - 2) > 1u && achieveType != Assets.Achieve.Type.DAILY_REPEATABLE && !value.IsGenericRewardChest && (questManager == null || !questManager.IsProxyLegacyAchieve(value.ID)))
-				{
-					list.Add(value);
-				}
-			}
-		}
-		return list;
-	}
-
-	private static bool IsActiveQuest(Achievement obj, bool onlyNewlyActive)
-	{
-		if (!obj.Active)
-		{
-			return false;
-		}
-		if (!obj.CanShowInQuestLog)
-		{
-			return false;
-		}
-		if (onlyNewlyActive)
-		{
-			return obj.IsNewlyActive();
-		}
-		return true;
-	}
-
-	private static bool IsAutoDestroyQuest(Achievement obj)
-	{
-		if (!obj.CanShowInQuestLog)
-		{
-			return false;
-		}
-		return obj.AutoDestroy;
-	}
-
-	private static bool IsDialogQuest(Achievement obj)
-	{
-		if (!obj.CanShowInQuestLog)
-		{
-			return false;
-		}
-		return obj.QuestDialogId != 0;
-	}
-
-	public List<Achievement> GetActiveQuests(bool onlyNewlyActive = false)
-	{
-		List<Achievement> list = new List<Achievement>();
-		foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
-		{
-			Achievement value = achievement.Value;
-			if (IsActiveQuest(value, onlyNewlyActive))
-			{
-				list.Add(value);
-			}
-		}
-		return list;
-	}
-
-	public bool HasQuestsToShow(bool onlyNewlyActive = false)
-	{
-		bool result = false;
-		foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
-		{
-			if (IsActiveQuest(achievement.Value, onlyNewlyActive: false) && (achievement.Value.IsNewlyActive() || achievement.Value.AutoDestroy))
-			{
+        if (NetCache.Get().GetNetObject<NetCache.NetCacheProfileNotices>() == null)
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public bool RegisterAchievesUpdatedListener(AchievesUpdatedCallback callback, object userData = null)
+    {
+        if (callback == null)
+        {
+            return false;
+        }
+        AchievesUpdatedListener achievesUpdatedListener = new AchievesUpdatedListener();
+        achievesUpdatedListener.SetCallback(callback);
+        achievesUpdatedListener.SetUserData(userData);
+        if (m_achievesUpdatedListeners.Contains(achievesUpdatedListener))
+        {
+            return false;
+        }
+        m_achievesUpdatedListeners.Add(achievesUpdatedListener);
+        return true;
+    }
+
+    public bool RemoveAchievesUpdatedListener(AchievesUpdatedCallback callback)
+    {
+        return RemoveAchievesUpdatedListener(callback, null);
+    }
+
+    public bool RemoveAchievesUpdatedListener(AchievesUpdatedCallback callback, object userData)
+    {
+        if (callback == null)
+        {
+            return false;
+        }
+        AchievesUpdatedListener achievesUpdatedListener = new AchievesUpdatedListener();
+        achievesUpdatedListener.SetCallback(callback);
+        achievesUpdatedListener.SetUserData(userData);
+        if (!m_achievesUpdatedListeners.Contains(achievesUpdatedListener))
+        {
+            return false;
+        }
+        m_achievesUpdatedListeners.Remove(achievesUpdatedListener);
+        return true;
+    }
+
+    public List<Achievement> GetNewCompletedAchievesToShow()
+    {
+        List<Achievement> list = new List<Achievement>();
+        QuestManager questManager = QuestManager.Get();
+        foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
+        {
+            Achievement value = achievement.Value;
+            if (value.IsNewlyCompleted() && !value.IsInternal() && value.RewardTiming != Assets.Achieve.RewardTiming.NEVER)
+            {
+                Assets.Achieve.Type achieveType = value.AchieveType;
+                if ((uint)(achieveType - 2) > 1u && achieveType != Assets.Achieve.Type.DAILY_REPEATABLE && !value.IsGenericRewardChest && (questManager == null || !questManager.IsProxyLegacyAchieve(value.ID)))
+                {
+                    list.Add(value);
+                }
+            }
+        }
+        return list;
+    }
+
+    private static bool IsActiveQuest(Achievement obj, bool onlyNewlyActive)
+    {
+        if (!obj.Active)
+        {
+            return false;
+        }
+        if (!obj.CanShowInQuestLog)
+        {
+            return false;
+        }
+        if (onlyNewlyActive)
+        {
+            return obj.IsNewlyActive();
+        }
+        return true;
+    }
+
+    private static bool IsAutoDestroyQuest(Achievement obj)
+    {
+        if (!obj.CanShowInQuestLog)
+        {
+            return false;
+        }
+        return obj.AutoDestroy;
+    }
+
+    private static bool IsDialogQuest(Achievement obj)
+    {
+        if (!obj.CanShowInQuestLog)
+        {
+            return false;
+        }
+        return obj.QuestDialogId != 0;
+    }
+
+    public List<Achievement> GetActiveQuests(bool onlyNewlyActive = false)
+    {
+        List<Achievement> list = new List<Achievement>();
+        foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
+        {
+            Achievement value = achievement.Value;
+            if (IsActiveQuest(value, onlyNewlyActive))
+            {
+                list.Add(value);
+            }
+        }
+        return list;
+    }
+
+    public bool HasQuestsToShow(bool onlyNewlyActive = false)
+    {
+        bool result = false;
+        foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
+        {
+            if (IsActiveQuest(achievement.Value, onlyNewlyActive: false) && (achievement.Value.IsNewlyActive() || achievement.Value.AutoDestroy))
+            {
 				result = true;
 				break;
-			}
-		}
-		return result;
-	}
-
-	public bool MarkQuestAsSeenByPlayerThisSession(Achievement obj)
-	{
-		return m_achievesSeenByPlayerThisSession.Add(obj.ID);
-	}
-
-	public bool ResetQuestSeenByPlayerThisSession(Achievement obj)
-	{
-		return m_achievesSeenByPlayerThisSession.Remove(obj.ID);
-	}
-
-	public bool HasActiveAutoDestroyQuests()
-	{
-		foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
-		{
-			if (IsActiveQuest(achievement.Value, onlyNewlyActive: false) && IsAutoDestroyQuest(achievement.Value))
-			{
-				return true;
-			}
-		}
-		return false;
-	}
-
-	public bool HasActiveUnseenWelcomeQuestDialog()
-	{
-		int @int = Options.Get().GetInt(Option.LATEST_SEEN_WELCOME_QUEST_DIALOG);
-		foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
-		{
-			Achievement value = achievement.Value;
-			if (IsActiveQuest(value, onlyNewlyActive: false) && IsDialogQuest(value) && @int != value.ID)
-			{
-				return true;
-			}
-		}
-		return false;
-	}
-
-	public List<Achievement> GetNewlyProgressedQuests()
-	{
-		return Get().GetActiveQuests().FindAll((Achievement obj) => obj.AcknowledgedProgress < obj.Progress && obj.Progress > 0 && obj.Progress < obj.MaxProgress);
-	}
-
-	public bool HasUnlockedFeature(Assets.Achieve.Unlocks feature)
-	{
-		if (DemoMgr.Get().ArenaIs1WinMode() && feature == Assets.Achieve.Unlocks.FORGE)
-		{
-			return true;
-		}
-		Achievement achievement = null;
-		foreach (KeyValuePair<int, Achievement> achievement2 in m_achievements)
-		{
-			if (achievement2.Value.UnlockedFeature == feature)
-			{
-				achievement = achievement2.Value;
+            }
+        }
+        return result;
+    }
+
+    public bool MarkQuestAsSeenByPlayerThisSession(Achievement obj)
+    {
+        return m_achievesSeenByPlayerThisSession.Add(obj.ID);
+    }
+
+    public bool ResetQuestSeenByPlayerThisSession(Achievement obj)
+    {
+        return m_achievesSeenByPlayerThisSession.Remove(obj.ID);
+    }
+
+    public bool HasActiveAutoDestroyQuests()
+    {
+        foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
+        {
+            if (IsActiveQuest(achievement.Value, onlyNewlyActive: false) && IsAutoDestroyQuest(achievement.Value))
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public bool HasActiveUnseenWelcomeQuestDialog()
+    {
+        int @int = Options.Get().GetInt(Option.LATEST_SEEN_WELCOME_QUEST_DIALOG);
+        foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
+        {
+            Achievement value = achievement.Value;
+            if (IsActiveQuest(value, onlyNewlyActive: false) && IsDialogQuest(value) && @int != value.ID)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public List<Achievement> GetNewlyProgressedQuests()
+    {
+        return Get().GetActiveQuests().FindAll((Achievement obj) => obj.AcknowledgedProgress < obj.Progress && obj.Progress > 0 && obj.Progress < obj.MaxProgress);
+    }
+
+    public bool HasUnlockedFeature(Assets.Achieve.Unlocks feature)
+    {
+        if (DemoMgr.Get().ArenaIs1WinMode() && feature == Assets.Achieve.Unlocks.FORGE)
+        {
+            return true;
+        }
+        Achievement achievement = null;
+        foreach (KeyValuePair<int, Achievement> achievement2 in m_achievements)
+        {
+            if (achievement2.Value.UnlockedFeature == feature)
+            {
+                achievement = achievement2.Value;
+                break;
+            }
+        }
+        if (achievement == null)
+        {
+            Debug.LogWarning($"AchieveManager.HasUnlockedFeature(): could not find achieve that unlocks feature {feature}");
+            return false;
+        }
+        return achievement.IsCompleted();
+    }
+
+    public int NumDefaultHeroesUnlocked()
+    {
+        int ret = 0;
+
+        foreach (TAG_CLASS dEFAULT_HERO_CLASS in GameUtils.DEFAULT_HERO_CLASSES)
+        {
+            NetCache.HeroLevel heroLevel = GameUtils.GetHeroLevel(dEFAULT_HERO_CLASS);
+            if (heroLevel != null && heroLevel.CurrentLevel.Level != 0)
+            {
+                ret++;
+            }
+        }
+
+        return ret;
+    }
+
+    public bool HasUnlockedDefaultHeroes()
+    {
+        int i = 0;
+        for (int num = GameUtils.DEFAULT_HERO_CLASSES.Length; i < num; i++)
+        {
+            NetCache.HeroLevel heroLevel = GameUtils.GetHeroLevel(GameUtils.DEFAULT_HERO_CLASSES[i]);
+            if (heroLevel == null || heroLevel.CurrentLevel.Level == 0)
+            {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public Achievement GetAchievement(int achieveID)
+    {
+        if (!m_achievements.ContainsKey(achieveID))
+        {
+            return null;
+        }
+        return m_achievements[achieveID];
+    }
+
+    public IEnumerable<Achievement> GetCompletedAchieves()
+    {
+        return GetAchieves((Achievement a) => a.IsCompleted());
+    }
+
+    public List<Achievement> GetAchievesInGroup(Assets.Achieve.Type achieveGroup)
+    {
+        return new List<Achievement>(m_achievements.Values).FindAll((Achievement obj) => obj.AchieveType == achieveGroup);
+    }
+
+    public List<Achievement> GetAchievesInGroup(Assets.Achieve.Type achieveGroup, bool isComplete)
+    {
+        return GetAchievesInGroup(achieveGroup).FindAll((Achievement obj) => obj.IsCompleted() == isComplete);
+    }
+
+    public List<Achievement> GetAchievesForAdventureWing(int wingID)
+    {
+        return new List<Achievement>(m_achievements.Values).FindAll((Achievement obj) => obj.Enabled && obj.WingID == wingID);
+    }
+
+    public List<Achievement> GetAchievesForAdventureAndMode(int adventureId, int modeId)
+    {
+        return new List<Achievement>(m_achievements.Values).FindAll((Achievement obj) => obj.AdventureID == adventureId && obj.AdventureModeID == modeId);
+    }
+
+    public bool CanCancelQuest(int achieveID)
+    {
+        if (m_disableCancelButtonUntilServerReturns)
+        {
+            return false;
+        }
+        if (!CanCancelQuestNow())
+        {
+            return false;
+        }
+        if (!HasAccessToDailies())
+        {
+            return false;
+        }
+        Achievement achievement = GetAchievement(achieveID);
+        if (achievement == null)
+        {
+            return false;
+        }
+        if (!achievement.CanBeCancelled)
+        {
+            return false;
+        }
+        return achievement.Active;
+    }
+
+    public static bool HasAccessToDailies()
+    {
+        if (!Get().HasUnlockedFeature(Assets.Achieve.Unlocks.DAILY))
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public bool RegisterQuestCanceledListener(AchieveCanceledCallback callback)
+    {
+        return RegisterQuestCanceledListener(callback, null);
+    }
+
+    public bool RegisterQuestCanceledListener(AchieveCanceledCallback callback, object userData)
+    {
+        AchieveCanceledListener achieveCanceledListener = new AchieveCanceledListener();
+        achieveCanceledListener.SetCallback(callback);
+        achieveCanceledListener.SetUserData(userData);
+        if (m_achieveCanceledListeners.Contains(achieveCanceledListener))
+        {
+            return false;
+        }
+        m_achieveCanceledListeners.Add(achieveCanceledListener);
+        return true;
+    }
+
+    public bool RemoveQuestCanceledListener(AchieveCanceledCallback callback)
+    {
+        return RemoveQuestCanceledListener(callback, null);
+    }
+
+    public bool RemoveQuestCanceledListener(AchieveCanceledCallback callback, object userData)
+    {
+        AchieveCanceledListener achieveCanceledListener = new AchieveCanceledListener();
+        achieveCanceledListener.SetCallback(callback);
+        achieveCanceledListener.SetUserData(userData);
+        return m_achieveCanceledListeners.Remove(achieveCanceledListener);
+    }
+
+    public void CancelQuest(int achieveID)
+    {
+        if (!CanCancelQuest(achieveID))
+        {
+            FireAchieveCanceledEvent(achieveID, success: false);
+            return;
+        }
+        BlockAllNotifications();
+        m_disableCancelButtonUntilServerReturns = true;
+        Network.Get().RequestCancelQuest(achieveID);
+    }
+
+    public bool RegisterLicenseAddedAchievesUpdatedListener(LicenseAddedAchievesUpdatedCallback callback)
+    {
+        return RegisterLicenseAddedAchievesUpdatedListener(callback, null);
+    }
+
+    public bool RegisterLicenseAddedAchievesUpdatedListener(LicenseAddedAchievesUpdatedCallback callback, object userData)
+    {
+        LicenseAddedAchievesUpdatedListener licenseAddedAchievesUpdatedListener = new LicenseAddedAchievesUpdatedListener();
+        licenseAddedAchievesUpdatedListener.SetCallback(callback);
+        licenseAddedAchievesUpdatedListener.SetUserData(userData);
+        if (m_licenseAddedAchievesUpdatedListeners.Contains(licenseAddedAchievesUpdatedListener))
+        {
+            return false;
+        }
+        m_licenseAddedAchievesUpdatedListeners.Add(licenseAddedAchievesUpdatedListener);
+        return true;
+    }
+
+    public bool RemoveLicenseAddedAchievesUpdatedListener(LicenseAddedAchievesUpdatedCallback callback)
+    {
+        return RemoveLicenseAddedAchievesUpdatedListener(callback, null);
+    }
+
+    public bool RemoveLicenseAddedAchievesUpdatedListener(LicenseAddedAchievesUpdatedCallback callback, object userData)
+    {
+        LicenseAddedAchievesUpdatedListener licenseAddedAchievesUpdatedListener = new LicenseAddedAchievesUpdatedListener();
+        licenseAddedAchievesUpdatedListener.SetCallback(callback);
+        licenseAddedAchievesUpdatedListener.SetUserData(userData);
+        return m_licenseAddedAchievesUpdatedListeners.Remove(licenseAddedAchievesUpdatedListener);
+    }
+
+    public bool HasActiveLicenseAddedAchieves()
+    {
+        return GetActiveLicenseAddedAchieves().Count > 0;
+    }
+
+    public bool HasActiveLicenseForAdventure(AdventureDbId adventureId)
+    {
+        List<Achievement> activeLicenseAddedAchieves = GetActiveLicenseAddedAchieves();
+        for (int i = 0; i < activeLicenseAddedAchieves.Count; i++)
+        {
+            if (activeLicenseAddedAchieves[i].AdventureID == (int)adventureId)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public void NotifyOfClick(Achievement.ClickTriggerType clickType)
+    {
+        Log.Achievements.Print("AchieveManager.NotifyOfClick(): clickType {0}", clickType);
+		bool hasAllVanillaHeroes = GameModeUtils.HasUnlockedAllDefaultHeroes();
+        foreach (Achievement achiefe in GetAchieves(delegate (Achievement obj)
+        {
+            if (obj.AchieveTrigger != Assets.Achieve.Trigger.CLICK)
+            {
+                return false;
+            }
+            if (!obj.Enabled)
+            {
+                Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip disabled achieve {0}", obj.ID);
+                return false;
+            }
+            if (obj.IsCompleted())
+            {
+                Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip already completed achieve {0}", obj.ID);
+                return false;
+            }
+            if (!obj.ClickType.HasValue)
+            {
+                Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip missing ClickType achieve {0}", obj.ID);
+                return false;
+            }
+            if (obj.ClickType.Value != clickType)
+            {
+                Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip achieve {0} with non-matching ClickType {1}", obj.ID, obj.ClickType.Value);
+                return false;
+            }
+            if (clickType == Achievement.ClickTriggerType.BUTTON_ADVENTURE && !hasAllVanillaHeroes && AdventureUtils.DoesAdventureRequireAllHeroesUnlocked((AdventureDbId)obj.AdventureID))
+            {
+                Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip achieve {0} for BUTTON_ADVENTURE requiring all heroes unlocked", obj.ID);
+                return false;
+            }
+            return true;
+        }))
+        {
+            Log.Achievements.Print("AchieveManager.NotifyOfClick(): add achieve {0}", achiefe.ID);
+            m_achieveValidationsToRequest.Add(achiefe.ID);
+        }
+        ValidateAchievesNow();
+    }
+
+    public void CompleteAutoDestroyAchieve(int achieveId)
+    {
+        foreach (Achievement achiefe in GetAchieves(delegate (Achievement obj)
+        {
+            if (obj.IsCompleted())
+            {
+                return false;
+            }
+            if (!obj.Enabled)
+            {
+                return false;
+            }
+            return obj.Active && obj.AchieveTrigger == Assets.Achieve.Trigger.DESTROYED;
+        }))
+        {
+            if (achiefe.ID == achieveId)
+            {
+                m_achieveValidationsToRequest.Add(achiefe.ID);
+            }
+        }
+        ValidateAchievesNow();
+    }
+
+    public void NotifyOfAccountCreation()
+    {
+        foreach (Achievement achiefe in GetAchieves(delegate (Achievement obj)
+        {
+            if (obj.IsCompleted())
+            {
+                return false;
+            }
+            return obj.Enabled && obj.AchieveTrigger == Assets.Achieve.Trigger.ACCOUNT_CREATED;
+        }))
+        {
+            m_achieveValidationsToRequest.Add(achiefe.ID);
+        }
+        ValidateAchievesNow();
+    }
+
+    public void NotifyOfPacksReadyToOpen(UnopenedPack unopenedPack)
+    {
+        IEnumerable<Achievement> achieves = GetAchieves(delegate (Achievement obj)
+        {
+            if (!obj.Enabled)
+            {
+                return false;
+            }
+            if (obj.IsCompleted())
+            {
+                return false;
+            }
+            if (obj.AchieveTrigger != Assets.Achieve.Trigger.PACK_READY_TO_OPEN)
+            {
+                return false;
+            }
+            if (obj.BoosterRequirement != unopenedPack.GetBoosterId())
+            {
+                return false;
+            }
+            if (unopenedPack.GetCount() == 0)
+            {
+                return false;
+            }
+            return unopenedPack.CanOpenPack() ? true : false;
+        });
+        bool flag = false;
+        foreach (Achievement item in achieves)
+        {
+            m_achieveValidationsToRequest.Add(item.ID);
+            flag = true;
+        }
+        if (flag)
+        {
+            ValidateAchievesNow();
+        }
+    }
+
+    public void Update()
+    {
+        if (Network.IsRunning())
+        {
+            CheckTimedEventsAndLicenses(DateTime.UtcNow);
+        }
+    }
+
+    public void ValidateAchievesNow()
+    {
+        if (m_achieveValidationsToRequest.Count == 0)
+        {
+            return;
+        }
+		EventTimingManager eventTimingManager = EventTimingManager.Get();
+        List<AchieveRegionDataDbfRecord> records = GameDbf.AchieveRegionData.GetRecords();
+        foreach (int item in m_achieveValidationsToRequest)
+        {
+            AchieveRegionDataDbfRecord achieveRegionDataDbfRecord = null;
+            foreach (AchieveRegionDataDbfRecord item2 in records)
+            {
+				if (item2.AchieveId == item && !eventTimingManager.IsEventActive(item2.ProgressableEvent))
+                {
+                    achieveRegionDataDbfRecord = item2;
+                    break;
+                }
+            }
+			if (achieveRegionDataDbfRecord != null && !eventTimingManager.IsEventActive(achieveRegionDataDbfRecord.ProgressableEvent))
+            {
+                Log.Achievements.Print("AchieveManager.ValidateAchievesNow(): skip non-progressable achieve {0} event {1}", item, achieveRegionDataDbfRecord.ProgressableEvent);
+            }
+            else
+            {
+                Log.Achievements.Print("AchieveManager.ValidateAchievesNow(): ValidateAchieve {0}", item);
+                m_achieveValidationsRequested.Add(item);
+                Network.Get().ValidateAchieve(item);
+            }
+        }
+        m_achieveValidationsToRequest.Clear();
+    }
+
+    public void LoadAchievesFromDBF()
+    {
+        m_achievements.Clear();
+        List<AchieveDbfRecord> records = GameDbf.Achieve.GetRecords();
+        List<CharacterDialogDbfRecord> records2 = GameDbf.CharacterDialog.GetRecords();
+        Map<int, int> map = new Map<int, int>();
+        foreach (AchieveDbfRecord item in records)
+        {
+            int iD = item.ID;
+            int race = item.Race;
+            TAG_RACE? raceReq = null;
+            if (race != 0)
+            {
+                raceReq = (TAG_RACE)race;
+            }
+            int cardSet = item.CardSet;
+            TAG_CARD_SET? cardSetReq = null;
+            if (cardSet != 0)
+            {
+                cardSetReq = (TAG_CARD_SET)cardSet;
+            }
+            int myHeroClassId = item.MyHeroClassId;
+            TAG_CLASS? myHeroClassReq = null;
+            if (myHeroClassId != 0)
+            {
+                myHeroClassReq = (TAG_CLASS)myHeroClassId;
+            }
+            long rewardData = item.RewardData1;
+            long rewardData2 = item.RewardData2;
+            bool isGenericRewardChest = false;
+            string chestVisualPrefabPath = "";
+            List<RewardData> list = new List<RewardData>();
+            TAG_CLASS? classReward = null;
+            switch (item.Reward)
+            {
+                case "basic":
+                    Debug.LogWarning($"AchieveManager.LoadAchievesFromFile(): unable to define reward {item.Reward} for achieve {iD}");
+                    break;
+                case "card":
+                    {
+                        string cardID2 = GameUtils.TranslateDbIdToCardId((int)rewardData);
+                        TAG_PREMIUM premium2 = (TAG_PREMIUM)rewardData2;
+                        list.Add(new CardRewardData(cardID2, premium2, 1));
+                        break;
+                    }
+                case "card2x":
+                    {
+                        string cardID = GameUtils.TranslateDbIdToCardId((int)rewardData);
+                        TAG_PREMIUM premium = (TAG_PREMIUM)rewardData2;
+                        list.Add(new CardRewardData(cardID, premium, 2));
+                        break;
+                    }
+                case "cardback":
+                    list.Add(new CardBackRewardData((int)rewardData));
+                    break;
+                case "dust":
+                    list.Add(new ArcaneDustRewardData((int)rewardData));
+                    break;
+                case "forge":
+                    list.Add(new ForgeTicketRewardData((int)rewardData));
+                    break;
+                case "gold":
+                    list.Add(new GoldRewardData((int)rewardData));
+                    break;
+                case "goldhero":
+                    {
+                        string cardID3 = GameUtils.TranslateDbIdToCardId((int)rewardData);
+                        TAG_PREMIUM premium3 = (TAG_PREMIUM)rewardData2;
+                        list.Add(new CardRewardData(cardID3, premium3, 1));
+                        break;
+                    }
+                case "hero":
+                    {
+                        classReward = (TAG_CLASS)rewardData2;
+                        string vanillaHero = CollectionManager.GetVanillaHero(classReward.Value);
+                        if (!string.IsNullOrEmpty(vanillaHero))
+                        {
+                            list.Add(new CardRewardData(vanillaHero, TAG_PREMIUM.NORMAL, 1));
+                        }
+                        break;
+                    }
+                case "mount":
+                    list.Add(new MountRewardData((MountRewardData.MountType)rewardData));
+                    break;
+                case "pack":
+                    {
+                        int id = (int)((rewardData2 <= 0) ? 1 : rewardData2);
+                        list.Add(new BoosterPackRewardData(id, (int)rewardData));
+                        break;
+                    }
+                case "event_notice":
+                    {
+                        int eventType = (int)((rewardData > 0) ? rewardData : 0);
+                        list.Add(new EventRewardData(eventType));
+                        break;
+                    }
+                case "generic_reward_chest":
+                    isGenericRewardChest = true;
+                    list.AddRange(RewardUtils.GetRewardDataFromRewardChestAsset((int)rewardData, (int)rewardData2));
+                    chestVisualPrefabPath = GameDbf.RewardChest.GetRecord((int)rewardData).ChestPrefab;
+                    break;
+                case "arcane_orbs":
+                    list.Add(RewardUtils.CreateArcaneOrbRewardData((int)rewardData));
+                    break;
+                case "deck":
+				list.Add(RewardUtils.CreateDeckRewardData(0, (int)rewardData, (int)rewardData2, null));
+                    break;
+                case "mercenary":
+                    list.Add(RewardUtils.CreateMercenaryRewardData((int)rewardData, 0, TAG_PREMIUM.NORMAL));
+                    break;
+                case "mercenary_coins":
+                    list.Add(RewardUtils.CreateMercenaryCoinsRewardData((int)rewardData, (int)rewardData2, glowActive: true, nameActive: false));
+                    break;
+			case "renown":
+				list.Add(new MercenaryRenownRewardData((int)rewardData));
 				break;
-			}
-		}
-		if (achievement == null)
-		{
-			Debug.LogWarning($"AchieveManager.HasUnlockedFeature(): could not find achieve that unlocks feature {feature}");
-			return false;
-		}
-		return achievement.IsCompleted();
-	}
-
-	public Achievement GetAchievement(int achieveID)
-	{
-		if (!m_achievements.ContainsKey(achieveID))
-		{
-			return null;
-		}
-		return m_achievements[achieveID];
-	}
-
-	public IEnumerable<Achievement> GetCompletedAchieves()
-	{
-		return GetAchieves((Achievement a) => a.IsCompleted());
-	}
-
-	public List<Achievement> GetAchievesInGroup(Assets.Achieve.Type achieveGroup)
-	{
-		return new List<Achievement>(m_achievements.Values).FindAll((Achievement obj) => obj.AchieveType == achieveGroup);
-	}
-
-	public List<Achievement> GetAchievesInGroup(Assets.Achieve.Type achieveGroup, bool isComplete)
-	{
-		return GetAchievesInGroup(achieveGroup).FindAll((Achievement obj) => obj.IsCompleted() == isComplete);
-	}
-
-	public List<Achievement> GetAchievesForAdventureWing(int wingID)
-	{
-		return new List<Achievement>(m_achievements.Values).FindAll((Achievement obj) => obj.Enabled && obj.WingID == wingID);
-	}
-
-	public List<Achievement> GetAchievesForAdventureAndMode(int adventureId, int modeId)
-	{
-		return new List<Achievement>(m_achievements.Values).FindAll((Achievement obj) => obj.AdventureID == adventureId && obj.AdventureModeID == modeId);
-	}
-
-	public bool CanCancelQuest(int achieveID)
-	{
-		if (m_disableCancelButtonUntilServerReturns)
-		{
-			return false;
-		}
-		if (!CanCancelQuestNow())
-		{
-			return false;
-		}
-		if (!HasAccessToDailies())
-		{
-			return false;
-		}
-		Achievement achievement = GetAchievement(achieveID);
-		if (achievement == null)
-		{
-			return false;
-		}
-		if (!achievement.CanBeCancelled)
-		{
-			return false;
-		}
-		return achievement.Active;
-	}
-
-	public static bool HasAccessToDailies()
-	{
-		if (!Get().HasUnlockedFeature(Assets.Achieve.Unlocks.DAILY))
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public bool RegisterQuestCanceledListener(AchieveCanceledCallback callback)
-	{
-		return RegisterQuestCanceledListener(callback, null);
-	}
-
-	public bool RegisterQuestCanceledListener(AchieveCanceledCallback callback, object userData)
-	{
-		AchieveCanceledListener achieveCanceledListener = new AchieveCanceledListener();
-		achieveCanceledListener.SetCallback(callback);
-		achieveCanceledListener.SetUserData(userData);
-		if (m_achieveCanceledListeners.Contains(achieveCanceledListener))
-		{
-			return false;
-		}
-		m_achieveCanceledListeners.Add(achieveCanceledListener);
-		return true;
-	}
-
-	public bool RemoveQuestCanceledListener(AchieveCanceledCallback callback)
-	{
-		return RemoveQuestCanceledListener(callback, null);
-	}
-
-	public bool RemoveQuestCanceledListener(AchieveCanceledCallback callback, object userData)
-	{
-		AchieveCanceledListener achieveCanceledListener = new AchieveCanceledListener();
-		achieveCanceledListener.SetCallback(callback);
-		achieveCanceledListener.SetUserData(userData);
-		return m_achieveCanceledListeners.Remove(achieveCanceledListener);
-	}
-
-	public void CancelQuest(int achieveID)
-	{
-		if (!CanCancelQuest(achieveID))
-		{
-			FireAchieveCanceledEvent(achieveID, success: false);
-			return;
-		}
-		BlockAllNotifications();
-		m_disableCancelButtonUntilServerReturns = true;
-		Network.Get().RequestCancelQuest(achieveID);
-	}
-
-	public bool RegisterLicenseAddedAchievesUpdatedListener(LicenseAddedAchievesUpdatedCallback callback)
-	{
-		return RegisterLicenseAddedAchievesUpdatedListener(callback, null);
-	}
-
-	public bool RegisterLicenseAddedAchievesUpdatedListener(LicenseAddedAchievesUpdatedCallback callback, object userData)
-	{
-		LicenseAddedAchievesUpdatedListener licenseAddedAchievesUpdatedListener = new LicenseAddedAchievesUpdatedListener();
-		licenseAddedAchievesUpdatedListener.SetCallback(callback);
-		licenseAddedAchievesUpdatedListener.SetUserData(userData);
-		if (m_licenseAddedAchievesUpdatedListeners.Contains(licenseAddedAchievesUpdatedListener))
-		{
-			return false;
-		}
-		m_licenseAddedAchievesUpdatedListeners.Add(licenseAddedAchievesUpdatedListener);
-		return true;
-	}
-
-	public bool RemoveLicenseAddedAchievesUpdatedListener(LicenseAddedAchievesUpdatedCallback callback)
-	{
-		return RemoveLicenseAddedAchievesUpdatedListener(callback, null);
-	}
-
-	public bool RemoveLicenseAddedAchievesUpdatedListener(LicenseAddedAchievesUpdatedCallback callback, object userData)
-	{
-		LicenseAddedAchievesUpdatedListener licenseAddedAchievesUpdatedListener = new LicenseAddedAchievesUpdatedListener();
-		licenseAddedAchievesUpdatedListener.SetCallback(callback);
-		licenseAddedAchievesUpdatedListener.SetUserData(userData);
-		return m_licenseAddedAchievesUpdatedListeners.Remove(licenseAddedAchievesUpdatedListener);
-	}
-
-	public bool HasActiveLicenseAddedAchieves()
-	{
-		return GetActiveLicenseAddedAchieves().Count > 0;
-	}
-
-	public bool HasActiveLicenseForAdventure(AdventureDbId adventureId)
-	{
-		List<Achievement> activeLicenseAddedAchieves = GetActiveLicenseAddedAchieves();
-		for (int i = 0; i < activeLicenseAddedAchieves.Count; i++)
-		{
-			if (activeLicenseAddedAchieves[i].AdventureID == (int)adventureId)
-			{
-				return true;
-			}
-		}
-		return false;
-	}
-
-	public void NotifyOfClick(Achievement.ClickTriggerType clickType)
-	{
-		Log.Achievements.Print("AchieveManager.NotifyOfClick(): clickType {0}", clickType);
-		bool hasAllVanillaHeroes = GameModeUtils.HasUnlockedAllDefaultHeroes();
-		foreach (Achievement achiefe in GetAchieves(delegate(Achievement obj)
-		{
-			if (obj.AchieveTrigger != Assets.Achieve.Trigger.CLICK)
-			{
-				return false;
-			}
-			if (!obj.Enabled)
-			{
-				Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip disabled achieve {0}", obj.ID);
-				return false;
-			}
-			if (obj.IsCompleted())
-			{
-				Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip already completed achieve {0}", obj.ID);
-				return false;
-			}
-			if (!obj.ClickType.HasValue)
-			{
-				Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip missing ClickType achieve {0}", obj.ID);
-				return false;
-			}
-			if (obj.ClickType.Value != clickType)
-			{
-				Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip achieve {0} with non-matching ClickType {1}", obj.ID, obj.ClickType.Value);
-				return false;
-			}
-			if (clickType == Achievement.ClickTriggerType.BUTTON_ADVENTURE && !hasAllVanillaHeroes && AdventureUtils.DoesAdventureRequireAllHeroesUnlocked((AdventureDbId)obj.AdventureID))
-			{
-				Log.Achievements.Print("AchieveManager.NotifyOfClick(): skip achieve {0} for BUTTON_ADVENTURE requiring all heroes unlocked", obj.ID);
-				return false;
-			}
-			return true;
-		}))
-		{
-			Log.Achievements.Print("AchieveManager.NotifyOfClick(): add achieve {0}", achiefe.ID);
-			m_achieveValidationsToRequest.Add(achiefe.ID);
-		}
-		ValidateAchievesNow();
-	}
-
-	public void CompleteAutoDestroyAchieve(int achieveId)
-	{
-		foreach (Achievement achiefe in GetAchieves(delegate(Achievement obj)
-		{
-			if (obj.IsCompleted())
-			{
-				return false;
-			}
-			if (!obj.Enabled)
-			{
-				return false;
-			}
-			return obj.Active && obj.AchieveTrigger == Assets.Achieve.Trigger.DESTROYED;
-		}))
-		{
-			if (achiefe.ID == achieveId)
-			{
-				m_achieveValidationsToRequest.Add(achiefe.ID);
-			}
-		}
-		ValidateAchievesNow();
-	}
-
-	public void NotifyOfAccountCreation()
-	{
-		foreach (Achievement achiefe in GetAchieves(delegate(Achievement obj)
-		{
-			if (obj.IsCompleted())
-			{
-				return false;
-			}
-			return obj.Enabled && obj.AchieveTrigger == Assets.Achieve.Trigger.ACCOUNT_CREATED;
-		}))
-		{
-			m_achieveValidationsToRequest.Add(achiefe.ID);
-		}
-		ValidateAchievesNow();
-	}
-
-	public void NotifyOfPacksReadyToOpen(UnopenedPack unopenedPack)
-	{
-		IEnumerable<Achievement> achieves = GetAchieves(delegate(Achievement obj)
-		{
-			if (!obj.Enabled)
-			{
-				return false;
-			}
-			if (obj.IsCompleted())
-			{
-				return false;
-			}
-			if (obj.AchieveTrigger != Assets.Achieve.Trigger.PACK_READY_TO_OPEN)
-			{
-				return false;
-			}
-			if (obj.BoosterRequirement != unopenedPack.GetBoosterId())
-			{
-				return false;
-			}
-			if (unopenedPack.GetCount() == 0)
-			{
-				return false;
-			}
-			return unopenedPack.CanOpenPack() ? true : false;
-		});
-		bool flag = false;
-		foreach (Achievement item in achieves)
-		{
-			m_achieveValidationsToRequest.Add(item.ID);
-			flag = true;
-		}
-		if (flag)
-		{
-			ValidateAchievesNow();
-		}
-	}
-
-	public void Update()
-	{
-		if (Network.IsRunning())
-		{
-			CheckTimedEventsAndLicenses(DateTime.UtcNow);
-		}
-	}
-
-	public void ValidateAchievesNow()
-	{
-		if (m_achieveValidationsToRequest.Count == 0)
-		{
-			return;
-		}
-		EventTimingManager eventTimingManager = EventTimingManager.Get();
-		List<AchieveRegionDataDbfRecord> records = GameDbf.AchieveRegionData.GetRecords();
-		foreach (int item in m_achieveValidationsToRequest)
-		{
-			AchieveRegionDataDbfRecord achieveRegionDataDbfRecord = null;
-			foreach (AchieveRegionDataDbfRecord item2 in records)
-			{
-				if (item2.AchieveId == item && !eventTimingManager.IsEventActive(item2.ProgressableEvent))
-				{
-					achieveRegionDataDbfRecord = item2;
-					break;
-				}
-			}
-			if (achieveRegionDataDbfRecord != null && !eventTimingManager.IsEventActive(achieveRegionDataDbfRecord.ProgressableEvent))
-			{
-				Log.Achievements.Print("AchieveManager.ValidateAchievesNow(): skip non-progressable achieve {0} event {1}", item, achieveRegionDataDbfRecord.ProgressableEvent);
-			}
-			else
-			{
-				Log.Achievements.Print("AchieveManager.ValidateAchievesNow(): ValidateAchieve {0}", item);
-				m_achieveValidationsRequested.Add(item);
-				Network.Get().ValidateAchieve(item);
-			}
-		}
-		m_achieveValidationsToRequest.Clear();
-	}
-
-	public void LoadAchievesFromDBF()
-	{
-		m_achievements.Clear();
-		List<AchieveDbfRecord> records = GameDbf.Achieve.GetRecords();
-		List<CharacterDialogDbfRecord> records2 = GameDbf.CharacterDialog.GetRecords();
-		Map<int, int> map = new Map<int, int>();
-		foreach (AchieveDbfRecord item in records)
-		{
-			int iD = item.ID;
-			int race = item.Race;
-			TAG_RACE? raceReq = null;
-			if (race != 0)
-			{
-				raceReq = (TAG_RACE)race;
-			}
-			int cardSet = item.CardSet;
-			TAG_CARD_SET? cardSetReq = null;
-			if (cardSet != 0)
-			{
-				cardSetReq = (TAG_CARD_SET)cardSet;
-			}
-			int myHeroClassId = item.MyHeroClassId;
-			TAG_CLASS? myHeroClassReq = null;
-			if (myHeroClassId != 0)
-			{
-				myHeroClassReq = (TAG_CLASS)myHeroClassId;
-			}
-			long rewardData = item.RewardData1;
-			long rewardData2 = item.RewardData2;
-			bool isGenericRewardChest = false;
-			string chestVisualPrefabPath = "";
-			List<RewardData> list = new List<RewardData>();
-			TAG_CLASS? classReward = null;
-			switch (item.Reward)
-			{
-			case "basic":
-				Debug.LogWarning($"AchieveManager.LoadAchievesFromFile(): unable to define reward {item.Reward} for achieve {iD}");
-				break;
-			case "card":
-			{
-				string cardID2 = GameUtils.TranslateDbIdToCardId((int)rewardData);
-				TAG_PREMIUM premium2 = (TAG_PREMIUM)rewardData2;
-				list.Add(new CardRewardData(cardID2, premium2, 1));
-				break;
-			}
-			case "card2x":
-			{
-				string cardID = GameUtils.TranslateDbIdToCardId((int)rewardData);
-				TAG_PREMIUM premium = (TAG_PREMIUM)rewardData2;
-				list.Add(new CardRewardData(cardID, premium, 2));
-				break;
-			}
-			case "cardback":
-				list.Add(new CardBackRewardData((int)rewardData));
-				break;
-			case "dust":
-				list.Add(new ArcaneDustRewardData((int)rewardData));
-				break;
-			case "forge":
-				list.Add(new ForgeTicketRewardData((int)rewardData));
-				break;
-			case "gold":
-				list.Add(new GoldRewardData((int)rewardData));
-				break;
-			case "goldhero":
-			{
-				string cardID3 = GameUtils.TranslateDbIdToCardId((int)rewardData);
-				TAG_PREMIUM premium3 = (TAG_PREMIUM)rewardData2;
-				list.Add(new CardRewardData(cardID3, premium3, 1));
-				break;
-			}
-			case "hero":
-			{
-				classReward = (TAG_CLASS)rewardData2;
-				string vanillaHero = CollectionManager.GetVanillaHero(classReward.Value);
-				if (!string.IsNullOrEmpty(vanillaHero))
-				{
-					list.Add(new CardRewardData(vanillaHero, TAG_PREMIUM.NORMAL, 1));
-				}
-				break;
-			}
-			case "mount":
-				list.Add(new MountRewardData((MountRewardData.MountType)rewardData));
-				break;
-			case "pack":
-			{
-				int id = (int)((rewardData2 <= 0) ? 1 : rewardData2);
-				list.Add(new BoosterPackRewardData(id, (int)rewardData));
-				break;
-			}
-			case "event_notice":
-			{
-				int eventType = (int)((rewardData > 0) ? rewardData : 0);
-				list.Add(new EventRewardData(eventType));
-				break;
-			}
-			case "generic_reward_chest":
-				isGenericRewardChest = true;
-				list.AddRange(RewardUtils.GetRewardDataFromRewardChestAsset((int)rewardData, (int)rewardData2));
-				chestVisualPrefabPath = GameDbf.RewardChest.GetRecord((int)rewardData).ChestPrefab;
-				break;
-			case "arcane_orbs":
-				list.Add(RewardUtils.CreateArcaneOrbRewardData((int)rewardData));
-				break;
-			case "deck":
-				list.Add(RewardUtils.CreateDeckRewardData(0, (int)rewardData, (int)rewardData2, null));
-				break;
-			case "mercenary":
-				list.Add(RewardUtils.CreateMercenaryRewardData((int)rewardData, 0, TAG_PREMIUM.NORMAL));
-				break;
-			case "mercenary_coins":
-				list.Add(RewardUtils.CreateMercenaryCoinsRewardData((int)rewardData, (int)rewardData2, glowActive: true, nameActive: false));
-				break;
-			case "renown":
-				list.Add(new MercenaryRenownRewardData((int)rewardData));
-				break;
-			}
-			Assets.Achieve.RewardTiming rewardTiming = item.RewardTiming;
-			int num = 0;
-			int num2 = 0;
-			string parentAch = item.ParentAch;
-			string linkTo = item.LinkTo;
-			int i = 0;
-			for (int count = records.Count; i < count; i++)
-			{
-				string noteDesc = records[i].NoteDesc;
-				if (num == 0 && noteDesc == parentAch)
-				{
-					num = records[i].ID;
-				}
-				if (num2 == 0 && noteDesc == linkTo)
-				{
-					num2 = records[i].ID;
-				}
-				if (num != 0 && num2 != 0)
-				{
-					break;
-				}
-			}
-			map[iD] = num;
-			Achievement.ClickTriggerType? clickType = null;
-			if (item.Triggered == Assets.Achieve.Trigger.CLICK)
-			{
-				clickType = (Achievement.ClickTriggerType)rewardData;
-			}
-			if (iD == 94)
-			{
-				clickType = Achievement.ClickTriggerType.BUTTON_ARENA;
-			}
-			List<int> list2 = new List<int>();
-			List<AchieveConditionDbfRecord> records3 = GameDbf.AchieveCondition.GetRecords();
-			int j = 0;
-			for (int count2 = records3.Count; j < count2; j++)
-			{
-				AchieveConditionDbfRecord achieveConditionDbfRecord = records3[j];
-				if (achieveConditionDbfRecord.AchieveId == iD)
-				{
-					list2.Add(achieveConditionDbfRecord.ScenarioId);
-				}
-			}
-			CharacterDialogDbfRecord characterDialogDbfRecord = null;
-			int questDialogId = item.QuestDialogId;
-			int k = 0;
-			for (int count3 = records2.Count; k < count3; k++)
-			{
-				if (records2[k].ID == questDialogId)
-				{
-					characterDialogDbfRecord = records2[k];
-					break;
-				}
-			}
-			int num3 = characterDialogDbfRecord?.ID ?? 0;
-			CharacterDialogSequence onReceivedDialogSequence = null;
-			CharacterDialogSequence onCompleteDialogSequence = null;
-			CharacterDialogSequence onProgress1DialogSequence = null;
-			CharacterDialogSequence onProgress2DialogSequence = null;
-			CharacterDialogSequence onDismissDialogSequence = null;
-			if (characterDialogDbfRecord != null)
-			{
-				onReceivedDialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.RECEIVE);
-				onCompleteDialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.COMPLETE);
-				onProgress1DialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.PROGRESS1);
-				onProgress2DialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.PROGRESS2);
-				onDismissDialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.DISMISS);
-			}
-			int onCompleteQuestDialogBannerId = characterDialogDbfRecord?.OnCompleteBannerId ?? 0;
-			Achievement achievement = new Achievement(item, iD, item.AchType, item.AchQuota, num2, item.Triggered, item.GameMode, raceReq, classReward, cardSetReq, myHeroClassReq, clickType, item.Unlocks, list, list2, item.AdventureWingId, item.AdventureId, item.AdventureModeId, rewardTiming, item.Booster, item.UseGenericRewardVisual, item.ShowToReturningPlayer, num3, item.AutoDestroy, item.QuestTilePrefab, onCompleteQuestDialogBannerId, onReceivedDialogSequence, onCompleteDialogSequence, onProgress1DialogSequence, onProgress2DialogSequence, onDismissDialogSequence, isGenericRewardChest, chestVisualPrefabPath, item.CustomVisualWidget, item.EnemyHeroClassId);
-			EventTimingType eventTrigger = EventTimingType.IGNORE;
-			Assets.Achieve.Trigger triggered = item.Triggered;
-			if (triggered == Assets.Achieve.Trigger.FINISH || triggered == Assets.Achieve.Trigger.EVENT_TIMING_ONLY)
-			{
-				AchieveRegionDataDbfRecord currentRegionData = achievement.GetCurrentRegionData();
-				if (currentRegionData != null)
-				{
-					eventTrigger = currentRegionData.ProgressableEvent;
-				}
-			}
-			achievement.SetEventTrigger(eventTrigger);
-			achievement.SetClientFlags(item.ClientFlags);
-			achievement.SetAltTextPredicate(item.AltTextPredicate);
-			achievement.SetName(item.Name, item.AltName);
-			achievement.SetDescription(item.Description, item.AltDescription);
-			InitAchievement(achievement);
-		}
-	}
-
-	private void InitAchievement(Achievement achievement)
-	{
-		if (m_achievements.ContainsKey(achievement.ID))
-		{
-			Debug.LogWarning($"AchieveManager.InitAchievement() - already registered achievement with ID {achievement.ID}");
-		}
-		else
-		{
-			m_achievements.Add(achievement.ID, achievement);
-		}
-	}
-
-	private IEnumerable<Achievement> GetAchieves(Func<Achievement, bool> filter = null)
-	{
-		List<Achievement> list = new List<Achievement>();
-		foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
-		{
-			if (filter == null || filter(achievement.Value))
-			{
-				list.Add(achievement.Value);
-			}
-		}
-		return list;
-	}
-
-	public void OnInitialAchievements(Achieves achievements)
-	{
-		if (achievements != null)
-		{
-			OnAllAchieves(achievements);
-		}
-	}
-
-	private void OnAllAchieves(Achieves allAchievesList)
-	{
-		foreach (PegasusUtil.Achieve item in allAchievesList.List)
-		{
-			Achievement achievement = GetAchievement(item.Id);
-			if (achievement != null)
+            }
+            Assets.Achieve.RewardTiming rewardTiming = item.RewardTiming;
+            int num = 0;
+            int num2 = 0;
+            string parentAch = item.ParentAch;
+            string linkTo = item.LinkTo;
+            int i = 0;
+            for (int count = records.Count; i < count; i++)
+            {
+                string noteDesc = records[i].NoteDesc;
+                if (num == 0 && noteDesc == parentAch)
+                {
+                    num = records[i].ID;
+                }
+                if (num2 == 0 && noteDesc == linkTo)
+                {
+                    num2 = records[i].ID;
+                }
+                if (num != 0 && num2 != 0)
+                {
+                    break;
+                }
+            }
+            map[iD] = num;
+            Achievement.ClickTriggerType? clickType = null;
+			if (item.Triggered == Assets.Achieve.Trigger.CLICK)
+            {
+                clickType = (Achievement.ClickTriggerType)rewardData;
+            }
+            if (iD == 94)
+            {
+                clickType = Achievement.ClickTriggerType.BUTTON_ARENA;
+            }
+            List<int> list2 = new List<int>();
+            List<AchieveConditionDbfRecord> records3 = GameDbf.AchieveCondition.GetRecords();
+            int j = 0;
+            for (int count2 = records3.Count; j < count2; j++)
+            {
+                AchieveConditionDbfRecord achieveConditionDbfRecord = records3[j];
+                if (achieveConditionDbfRecord.AchieveId == iD)
+                {
+                    list2.Add(achieveConditionDbfRecord.ScenarioId);
+                }
+            }
+            CharacterDialogDbfRecord characterDialogDbfRecord = null;
+            int questDialogId = item.QuestDialogId;
+            int k = 0;
+            for (int count3 = records2.Count; k < count3; k++)
+            {
+                if (records2[k].ID == questDialogId)
+                {
+                    characterDialogDbfRecord = records2[k];
+                    break;
+                }
+            }
+            int num3 = characterDialogDbfRecord?.ID ?? 0;
+            CharacterDialogSequence onReceivedDialogSequence = null;
+            CharacterDialogSequence onCompleteDialogSequence = null;
+            CharacterDialogSequence onProgress1DialogSequence = null;
+            CharacterDialogSequence onProgress2DialogSequence = null;
+            CharacterDialogSequence onDismissDialogSequence = null;
+            if (characterDialogDbfRecord != null)
+            {
+                onReceivedDialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.RECEIVE);
+                onCompleteDialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.COMPLETE);
+                onProgress1DialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.PROGRESS1);
+                onProgress2DialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.PROGRESS2);
+                onDismissDialogSequence = new CharacterDialogSequence(num3, CharacterDialogEventType.DISMISS);
+            }
+            int onCompleteQuestDialogBannerId = characterDialogDbfRecord?.OnCompleteBannerId ?? 0;
+            Achievement achievement = new Achievement(item, iD, item.AchType, item.AchQuota, num2, item.Triggered, item.GameMode, raceReq, classReward, cardSetReq, myHeroClassReq, clickType, item.Unlocks, list, list2, item.AdventureWingId, item.AdventureId, item.AdventureModeId, rewardTiming, item.Booster, item.UseGenericRewardVisual, item.ShowToReturningPlayer, num3, item.AutoDestroy, item.QuestTilePrefab, onCompleteQuestDialogBannerId, onReceivedDialogSequence, onCompleteDialogSequence, onProgress1DialogSequence, onProgress2DialogSequence, onDismissDialogSequence, isGenericRewardChest, chestVisualPrefabPath, item.CustomVisualWidget, item.EnemyHeroClassId);
+			EventTimingType eventTrigger = EventTimingType.IGNORE;
+			Assets.Achieve.Trigger triggered = item.Triggered;
+            if (triggered == Assets.Achieve.Trigger.FINISH || triggered == Assets.Achieve.Trigger.EVENT_TIMING_ONLY)
+            {
+                AchieveRegionDataDbfRecord currentRegionData = achievement.GetCurrentRegionData();
+                if (currentRegionData != null)
+                {
+                    eventTrigger = currentRegionData.ProgressableEvent;
+                }
+            }
+            achievement.SetEventTrigger(eventTrigger);
+            achievement.SetClientFlags(item.ClientFlags);
+            achievement.SetAltTextPredicate(item.AltTextPredicate);
+            achievement.SetName(item.Name, item.AltName);
+            achievement.SetDescription(item.Description, item.AltDescription);
+            InitAchievement(achievement);
+        }
+    }
+
+    private void InitAchievement(Achievement achievement)
+    {
+        if (m_achievements.ContainsKey(achievement.ID))
+        {
+            Debug.LogWarning($"AchieveManager.InitAchievement() - already registered achievement with ID {achievement.ID}");
+        }
+        else
+        {
+            m_achievements.Add(achievement.ID, achievement);
+        }
+    }
+
+    private IEnumerable<Achievement> GetAchieves(Func<Achievement, bool> filter = null)
+    {
+        List<Achievement> list = new List<Achievement>();
+        foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
+        {
+            if (filter == null || filter(achievement.Value))
+            {
+                list.Add(achievement.Value);
+            }
+        }
+        return list;
+    }
+
+    public void OnInitialAchievements(Achieves achievements)
+    {
+        if (achievements != null)
+        {
+            OnAllAchieves(achievements);
+        }
+    }
+
+    private void OnAllAchieves(Achieves allAchievesList)
+    {
+        foreach (PegasusUtil.Achieve item in allAchievesList.List)
+        {
+			Achievement achievement = GetAchievement(item.Id);
+			if (achievement != null)
 			{
 				achievement.OnAchieveData(item);
 				if (achievement.IsCompleted())
@@ -936,296 +966,296 @@ public class AchieveManager : IService, IHasUpdate
 					SetSteamAchievementIfNeeded(achievement.DbfRecord);
 				}
 			}
-		}
-		CheckAllCardGainAchieves();
-		m_allNetAchievesReceived = true;
-		UnblockAllNotifications();
-	}
-
-	public void OnAchievementNotifications(List<AchievementNotification> achievementNotifications)
-	{
-		List<Achievement> list = new List<Achievement>();
-		List<Achievement> list2 = new List<Achievement>();
-		bool flag = false;
-		foreach (AchievementNotification achievementNotification in achievementNotifications)
-		{
-			if (m_queueNotifications || !m_allNetAchievesReceived || m_achieveNotificationsToQueue.Contains((int)achievementNotification.AchievementId))
-			{
-				Log.Achievements.Print("Blocking AchievementNotification: ID={0}", achievementNotification.AchievementId);
-				m_blockedAchievementNotifications.Add(achievementNotification);
-				continue;
-			}
-			Achievement achievement = GetAchievement((int)achievementNotification.AchievementId);
-			if (achievement != null)
-			{
+        }
+        CheckAllCardGainAchieves();
+        m_allNetAchievesReceived = true;
+        UnblockAllNotifications();
+    }
+
+    public void OnAchievementNotifications(List<AchievementNotification> achievementNotifications)
+    {
+        List<Achievement> list = new List<Achievement>();
+        List<Achievement> list2 = new List<Achievement>();
+        bool flag = false;
+        foreach (AchievementNotification achievementNotification in achievementNotifications)
+        {
+            if (m_queueNotifications || !m_allNetAchievesReceived || m_achieveNotificationsToQueue.Contains((int)achievementNotification.AchievementId))
+            {
+                Log.Achievements.Print("Blocking AchievementNotification: ID={0}", achievementNotification.AchievementId);
+                m_blockedAchievementNotifications.Add(achievementNotification);
+                continue;
+            }
+            Achievement achievement = GetAchievement((int)achievementNotification.AchievementId);
+            if (achievement != null)
+            {
 				if (PlatformSettings.IsSteam && achievementNotification.Complete)
 				{
 					SetSteamAchievementIfNeeded(achievement.DbfRecord);
 				}
-				if (achievement.AchieveTrigger == Assets.Achieve.Trigger.LICENSEADDED || achievement.AchieveTrigger == Assets.Achieve.Trigger.EVENT_TIMING_ONLY)
-				{
-					flag = true;
-				}
-				achievement.OnAchieveNotification(achievementNotification);
-				if (!achievement.Active && achievementNotification.Complete)
-				{
-					list.Add(achievement);
-				}
-				else
-				{
-					list2.Add(achievement);
-				}
-				Log.Achievements.Print("OnAchievementNotification: Achievement={0}", achievement);
-			}
-		}
-		if (flag)
-		{
-			m_lastEventTimingAndLicenseAchieveCheck = 0L;
-		}
-		AchievesUpdatedListener[] array = m_achievesUpdatedListeners.ToArray();
-		for (int i = 0; i < array.Length; i++)
-		{
-			array[i].Fire(list2, list);
-		}
-	}
-
-	public void BlockAllNotifications()
-	{
-		m_queueNotifications = true;
-	}
-
-	public void UnblockAllNotifications()
-	{
-		m_queueNotifications = false;
-		if (m_blockedAchievementNotifications.Count > 0)
-		{
-			OnAchievementNotifications(m_blockedAchievementNotifications);
-			m_blockedAchievementNotifications.Clear();
-		}
-	}
-
-	private void OnQuestCanceled()
-	{
-		Network.CanceledQuest canceledQuest = Network.Get().GetCanceledQuest();
-		Log.Achievements.Print("OnQuestCanceled: CanceledQuest={0}", canceledQuest);
-		m_disableCancelButtonUntilServerReturns = false;
-		if (canceledQuest.Canceled)
-		{
-			GetAchievement(canceledQuest.AchieveID).OnCancelSuccess();
-			NetCache.NetCacheRewardProgress netObject = NetCache.Get().GetNetObject<NetCache.NetCacheRewardProgress>();
-			if (netObject != null)
-			{
-				netObject.NextQuestCancelDate = canceledQuest.NextQuestCancelDate;
-			}
-		}
-		FireAchieveCanceledEvent(canceledQuest.AchieveID, canceledQuest.Canceled);
-		UnblockAllNotifications();
-	}
-
-	private void OnAchieveValidated()
-	{
-		ValidateAchieveResponse validatedAchieve = Network.Get().GetValidatedAchieve();
-		m_achieveValidationsRequested.Remove(validatedAchieve.Achieve);
-		Log.Achievements.Print("AchieveManager.OnAchieveValidated(): achieve={0} success={1}", validatedAchieve.Achieve, validatedAchieve.Success);
-	}
-
-	private void OnEventTriggered()
-	{
-		Network.Get().GetTriggerEventResponse();
-		m_numEventResponsesNeeded--;
-	}
-
-	private void OnAccountLicenseAchieveResponse()
-	{
-		Network.AccountLicenseAchieveResponse accountLicenseAchieveResponse = Network.Get().GetAccountLicenseAchieveResponse();
-		if (accountLicenseAchieveResponse.Result != Network.AccountLicenseAchieveResponse.AchieveResult.COMPLETE)
-		{
-			FireLicenseAddedAchievesUpdatedEvent();
-			return;
-		}
-		Log.Achievements.Print("AchieveManager.OnAccountLicenseAchieveResponse(): achieve {0} is now complete, refreshing achieves", accountLicenseAchieveResponse.Achieve);
-		OnAccountLicenseAchievesUpdated(accountLicenseAchieveResponse.Achieve);
-	}
-
-	private void OnAccountLicenseAchievesUpdated(object userData)
-	{
-		int num = (int)userData;
-		Log.Achievements.Print("AchieveManager.OnAccountLicenseAchievesUpdated(): refreshing achieves complete, triggered by achieve {0}", num);
-		FireLicenseAddedAchievesUpdatedEvent();
-	}
-
-	private void FireLicenseAddedAchievesUpdatedEvent()
-	{
-		List<Achievement> activeLicenseAddedAchieves = GetActiveLicenseAddedAchieves();
-		LicenseAddedAchievesUpdatedListener[] array = m_licenseAddedAchievesUpdatedListeners.ToArray();
-		for (int i = 0; i < array.Length; i++)
-		{
-			array[i].Fire(activeLicenseAddedAchieves);
-		}
-	}
-
-	private void OnNewNotices(List<NetCache.ProfileNotice> newNotices, bool isInitialNoticeList)
-	{
-		foreach (NetCache.ProfileNotice newNotice in newNotices)
-		{
-			if (NetCache.ProfileNotice.NoticeOrigin.ACHIEVEMENT == newNotice.Origin)
-			{
-				int achieveID = (int)newNotice.OriginData;
-				GetAchievement(achieveID)?.AddRewardNoticeID(newNotice.NoticeID);
-			}
-		}
-	}
-
-	private bool CanCancelQuestNow()
-	{
-		if (Vars.Key("Quests.CanCancelManyTimes").GetBool(def: false))
-		{
-			return true;
-		}
-		NetCache.NetCacheRewardProgress netObject = NetCache.Get().GetNetObject<NetCache.NetCacheRewardProgress>();
-		if (netObject == null)
-		{
-			return false;
-		}
-		long num = DateTime.Now.ToFileTimeUtc();
-		return netObject.NextQuestCancelDate <= num;
-	}
-
-	private void FireAchieveCanceledEvent(int achieveID, bool success)
-	{
-		AchieveCanceledListener[] array = m_achieveCanceledListeners.ToArray();
-		for (int i = 0; i < array.Length; i++)
-		{
-			array[i].Fire(achieveID, success);
-		}
-	}
-
-	private void CheckAllCardGainAchieves()
-	{
-		GetAchieves(delegate(Achievement obj)
-		{
-			if (!obj.Enabled)
-			{
-				return false;
-			}
-			if (obj.IsCompleted())
-			{
-				return false;
-			}
-			Assets.Achieve.Trigger achieveTrigger = obj.AchieveTrigger;
-			return (uint)(achieveTrigger - 6) <= 1u && obj.RaceRequirement.HasValue;
-		});
-		GetAchieves(delegate(Achievement obj)
-		{
-			if (!obj.Enabled)
-			{
-				return false;
-			}
-			if (obj.IsCompleted())
-			{
-				return false;
-			}
-			return obj.AchieveTrigger == Assets.Achieve.Trigger.CARDSET && obj.CardSetRequirement.HasValue;
-		});
-		ValidateAchievesNow();
-	}
-
-	private void CheckTimedEventsAndLicenses(DateTime utcNow)
-	{
-		if (!m_allNetAchievesReceived)
-		{
-			return;
-		}
-		DateTime dateTime = utcNow.ToLocalTime();
-		if (dateTime.Ticks - m_lastEventTimingAndLicenseAchieveCheck < TIMED_AND_LICENSE_ACHIEVE_CHECK_DELAY_TICKS)
-		{
-			return;
-		}
-		m_lastEventTimingAndLicenseAchieveCheck = dateTime.Ticks;
-		int num = 0;
-		foreach (Achievement value in m_achievements.Values)
-		{
+                if (achievement.AchieveTrigger == Assets.Achieve.Trigger.LICENSEADDED || achievement.AchieveTrigger == Assets.Achieve.Trigger.EVENT_TIMING_ONLY)
+                {
+                    flag = true;
+                }
+                achievement.OnAchieveNotification(achievementNotification);
+                if (!achievement.Active && achievementNotification.Complete)
+                {
+                    list.Add(achievement);
+                }
+                else
+                {
+                    list2.Add(achievement);
+                }
+                Log.Achievements.Print("OnAchievementNotification: Achievement={0}", achievement);
+            }
+        }
+        if (flag)
+        {
+            m_lastEventTimingAndLicenseAchieveCheck = 0L;
+        }
+        AchievesUpdatedListener[] array = m_achievesUpdatedListeners.ToArray();
+        for (int i = 0; i < array.Length; i++)
+        {
+            array[i].Fire(list2, list);
+        }
+    }
+
+    public void BlockAllNotifications()
+    {
+        m_queueNotifications = true;
+    }
+
+    public void UnblockAllNotifications()
+    {
+        m_queueNotifications = false;
+        if (m_blockedAchievementNotifications.Count > 0)
+        {
+            OnAchievementNotifications(m_blockedAchievementNotifications);
+            m_blockedAchievementNotifications.Clear();
+        }
+    }
+
+    private void OnQuestCanceled()
+    {
+        Network.CanceledQuest canceledQuest = Network.Get().GetCanceledQuest();
+        Log.Achievements.Print("OnQuestCanceled: CanceledQuest={0}", canceledQuest);
+        m_disableCancelButtonUntilServerReturns = false;
+        if (canceledQuest.Canceled)
+        {
+            GetAchievement(canceledQuest.AchieveID).OnCancelSuccess();
+            NetCache.NetCacheRewardProgress netObject = NetCache.Get().GetNetObject<NetCache.NetCacheRewardProgress>();
+            if (netObject != null)
+            {
+                netObject.NextQuestCancelDate = canceledQuest.NextQuestCancelDate;
+            }
+        }
+        FireAchieveCanceledEvent(canceledQuest.AchieveID, canceledQuest.Canceled);
+        UnblockAllNotifications();
+    }
+
+    private void OnAchieveValidated()
+    {
+        ValidateAchieveResponse validatedAchieve = Network.Get().GetValidatedAchieve();
+        m_achieveValidationsRequested.Remove(validatedAchieve.Achieve);
+        Log.Achievements.Print("AchieveManager.OnAchieveValidated(): achieve={0} success={1}", validatedAchieve.Achieve, validatedAchieve.Success);
+    }
+
+    private void OnEventTriggered()
+    {
+        Network.Get().GetTriggerEventResponse();
+        m_numEventResponsesNeeded--;
+    }
+
+    private void OnAccountLicenseAchieveResponse()
+    {
+        Network.AccountLicenseAchieveResponse accountLicenseAchieveResponse = Network.Get().GetAccountLicenseAchieveResponse();
+        if (accountLicenseAchieveResponse.Result != Network.AccountLicenseAchieveResponse.AchieveResult.COMPLETE)
+        {
+            FireLicenseAddedAchievesUpdatedEvent();
+            return;
+        }
+        Log.Achievements.Print("AchieveManager.OnAccountLicenseAchieveResponse(): achieve {0} is now complete, refreshing achieves", accountLicenseAchieveResponse.Achieve);
+        OnAccountLicenseAchievesUpdated(accountLicenseAchieveResponse.Achieve);
+    }
+
+    private void OnAccountLicenseAchievesUpdated(object userData)
+    {
+        int num = (int)userData;
+        Log.Achievements.Print("AchieveManager.OnAccountLicenseAchievesUpdated(): refreshing achieves complete, triggered by achieve {0}", num);
+        FireLicenseAddedAchievesUpdatedEvent();
+    }
+
+    private void FireLicenseAddedAchievesUpdatedEvent()
+    {
+        List<Achievement> activeLicenseAddedAchieves = GetActiveLicenseAddedAchieves();
+        LicenseAddedAchievesUpdatedListener[] array = m_licenseAddedAchievesUpdatedListeners.ToArray();
+        for (int i = 0; i < array.Length; i++)
+        {
+            array[i].Fire(activeLicenseAddedAchieves);
+        }
+    }
+
+    private void OnNewNotices(List<NetCache.ProfileNotice> newNotices, bool isInitialNoticeList)
+    {
+        foreach (NetCache.ProfileNotice newNotice in newNotices)
+        {
+            if (NetCache.ProfileNotice.NoticeOrigin.ACHIEVEMENT == newNotice.Origin)
+            {
+                int achieveID = (int)newNotice.OriginData;
+                GetAchievement(achieveID)?.AddRewardNoticeID(newNotice.NoticeID);
+            }
+        }
+    }
+
+    private bool CanCancelQuestNow()
+    {
+        if (Vars.Key("Quests.CanCancelManyTimes").GetBool(def: false))
+        {
+            return true;
+        }
+        NetCache.NetCacheRewardProgress netObject = NetCache.Get().GetNetObject<NetCache.NetCacheRewardProgress>();
+        if (netObject == null)
+        {
+            return false;
+        }
+        long num = DateTime.Now.ToFileTimeUtc();
+        return netObject.NextQuestCancelDate <= num;
+    }
+
+    private void FireAchieveCanceledEvent(int achieveID, bool success)
+    {
+        AchieveCanceledListener[] array = m_achieveCanceledListeners.ToArray();
+        for (int i = 0; i < array.Length; i++)
+        {
+            array[i].Fire(achieveID, success);
+        }
+    }
+
+    private void CheckAllCardGainAchieves()
+    {
+        GetAchieves(delegate (Achievement obj)
+        {
+            if (!obj.Enabled)
+            {
+                return false;
+            }
+            if (obj.IsCompleted())
+            {
+                return false;
+            }
+            Assets.Achieve.Trigger achieveTrigger = obj.AchieveTrigger;
+            return (uint)(achieveTrigger - 6) <= 1u && obj.RaceRequirement.HasValue;
+        });
+        GetAchieves(delegate (Achievement obj)
+        {
+            if (!obj.Enabled)
+            {
+                return false;
+            }
+            if (obj.IsCompleted())
+            {
+                return false;
+            }
+            return obj.AchieveTrigger == Assets.Achieve.Trigger.CARDSET && obj.CardSetRequirement.HasValue;
+        });
+        ValidateAchievesNow();
+    }
+
+    private void CheckTimedEventsAndLicenses(DateTime utcNow)
+    {
+        if (!m_allNetAchievesReceived)
+        {
+            return;
+        }
+        DateTime dateTime = utcNow.ToLocalTime();
+        if (dateTime.Ticks - m_lastEventTimingAndLicenseAchieveCheck < TIMED_AND_LICENSE_ACHIEVE_CHECK_DELAY_TICKS)
+        {
+            return;
+        }
+        m_lastEventTimingAndLicenseAchieveCheck = dateTime.Ticks;
+        int num = 0;
+        foreach (Achievement value in m_achievements.Values)
+        {
 			if (value.Enabled && !value.IsCompleted() && value.Active && Assets.Achieve.Trigger.EVENT_TIMING_ONLY == value.AchieveTrigger && EventTimingManager.Get().IsEventActive(value.EventTrigger) && (!m_lastEventTimingValidationByAchieve.ContainsKey(value.ID) || dateTime.Ticks - m_lastEventTimingValidationByAchieve[value.ID] >= TIMED_ACHIEVE_VALIDATION_DELAY_TICKS))
-			{
-				Log.Achievements.Print("AchieveManager.CheckTimedEventsAndLicenses(): checking on timed event achieve {0} time {1}", value.ID, dateTime);
-				m_lastEventTimingValidationByAchieve[value.ID] = dateTime.Ticks;
-				m_achieveValidationsToRequest.Add(value.ID);
-				num++;
-			}
-			if (value.IsActiveLicenseAddedAchieve() && (!m_lastCheckLicenseAddedByAchieve.ContainsKey(value.ID) || utcNow.Ticks - m_lastCheckLicenseAddedByAchieve[value.ID] >= CHECK_LICENSE_ADDED_ACHIEVE_DELAY_TICKS))
-			{
-				Log.Achievements.Print("AchieveManager.CheckTimedEventsAndLicenses(): checking on license added achieve {0} time {1}", value.ID, dateTime);
-				m_lastCheckLicenseAddedByAchieve[value.ID] = utcNow.Ticks;
-				Network.Get().CheckAccountLicenseAchieve(value.ID);
-			}
-		}
-		if (num != 0)
-		{
-			ValidateAchievesNow();
-		}
-	}
-
-	private List<Achievement> GetActiveLicenseAddedAchieves()
-	{
-		List<Achievement> list = new List<Achievement>();
-		foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
-		{
-			Achievement value = achievement.Value;
-			if (value.IsActiveLicenseAddedAchieve())
-			{
-				list.Add(value);
-			}
-		}
-		return list;
-	}
-
-	public List<RewardData> GetRewardsForAdventureAndMode(int adventureId, int modeId, HashSet<Assets.Achieve.RewardTiming> rewardTimings)
-	{
-		List<RewardData> list = new List<RewardData>();
-		foreach (Achievement item in GetAchievesForAdventureAndMode(adventureId, modeId))
-		{
-			list.AddRange(GetRewardsForAchieve(item.ID, rewardTimings));
-		}
-		return list;
-	}
-
-	public List<RewardData> GetRewardsForAdventureWing(int wingID, HashSet<Assets.Achieve.RewardTiming> rewardTimings)
-	{
-		List<RewardData> list = new List<RewardData>();
-		foreach (Achievement item in GetAchievesForAdventureWing(wingID))
-		{
-			list.AddRange(GetRewardsForAchieve(item.ID, rewardTimings));
-		}
-		return list;
-	}
-
-	public List<RewardData> GetRewardsForAdventureScenario(int wingID, int scenarioID, HashSet<Assets.Achieve.RewardTiming> rewardTimings)
-	{
-		List<RewardData> list = new List<RewardData>();
-		foreach (Achievement item in GetAchievesForAdventureWing(wingID))
-		{
-			if (item.Scenarios.Contains(scenarioID))
-			{
-				list.AddRange(GetRewardsForAchieve(item.ID, rewardTimings));
-			}
-		}
-		return list;
-	}
-
-	public List<RewardData> GetRewardsForAchieve(int achieveID, HashSet<Assets.Achieve.RewardTiming> rewardTimings)
-	{
-		List<RewardData> list = new List<RewardData>();
-		Achievement achievement = GetAchievement(achieveID);
-		List<RewardData> rewards = achievement.Rewards;
-		if (rewardTimings.Contains(achievement.RewardTiming))
-		{
-			foreach (RewardData item in rewards)
-			{
-				list.Add(item);
-			}
-		}
-		return list;
-	}
+            {
+                Log.Achievements.Print("AchieveManager.CheckTimedEventsAndLicenses(): checking on timed event achieve {0} time {1}", value.ID, dateTime);
+                m_lastEventTimingValidationByAchieve[value.ID] = dateTime.Ticks;
+                m_achieveValidationsToRequest.Add(value.ID);
+                num++;
+            }
+            if (value.IsActiveLicenseAddedAchieve() && (!m_lastCheckLicenseAddedByAchieve.ContainsKey(value.ID) || utcNow.Ticks - m_lastCheckLicenseAddedByAchieve[value.ID] >= CHECK_LICENSE_ADDED_ACHIEVE_DELAY_TICKS))
+            {
+                Log.Achievements.Print("AchieveManager.CheckTimedEventsAndLicenses(): checking on license added achieve {0} time {1}", value.ID, dateTime);
+                m_lastCheckLicenseAddedByAchieve[value.ID] = utcNow.Ticks;
+                Network.Get().CheckAccountLicenseAchieve(value.ID);
+            }
+        }
+        if (num != 0)
+        {
+            ValidateAchievesNow();
+        }
+    }
+
+    private List<Achievement> GetActiveLicenseAddedAchieves()
+    {
+        List<Achievement> list = new List<Achievement>();
+        foreach (KeyValuePair<int, Achievement> achievement in m_achievements)
+        {
+            Achievement value = achievement.Value;
+            if (value.IsActiveLicenseAddedAchieve())
+            {
+                list.Add(value);
+            }
+        }
+        return list;
+    }
+
+    public List<RewardData> GetRewardsForAdventureAndMode(int adventureId, int modeId, HashSet<Assets.Achieve.RewardTiming> rewardTimings)
+    {
+        List<RewardData> list = new List<RewardData>();
+        foreach (Achievement item in GetAchievesForAdventureAndMode(adventureId, modeId))
+        {
+            list.AddRange(GetRewardsForAchieve(item.ID, rewardTimings));
+        }
+        return list;
+    }
+
+    public List<RewardData> GetRewardsForAdventureWing(int wingID, HashSet<Assets.Achieve.RewardTiming> rewardTimings)
+    {
+        List<RewardData> list = new List<RewardData>();
+        foreach (Achievement item in GetAchievesForAdventureWing(wingID))
+        {
+            list.AddRange(GetRewardsForAchieve(item.ID, rewardTimings));
+        }
+        return list;
+    }
+
+    public List<RewardData> GetRewardsForAdventureScenario(int wingID, int scenarioID, HashSet<Assets.Achieve.RewardTiming> rewardTimings)
+    {
+        List<RewardData> list = new List<RewardData>();
+        foreach (Achievement item in GetAchievesForAdventureWing(wingID))
+        {
+            if (item.Scenarios.Contains(scenarioID))
+            {
+                list.AddRange(GetRewardsForAchieve(item.ID, rewardTimings));
+            }
+        }
+        return list;
+    }
+
+    public List<RewardData> GetRewardsForAchieve(int achieveID, HashSet<Assets.Achieve.RewardTiming> rewardTimings)
+    {
+        List<RewardData> list = new List<RewardData>();
+        Achievement achievement = GetAchievement(achieveID);
+        List<RewardData> rewards = achievement.Rewards;
+        if (rewardTimings.Contains(achievement.RewardTiming))
+        {
+            foreach (RewardData item in rewards)
+            {
+                list.Add(item);
+            }
+        }
+        return list;
+    }
 
 	private void SetSteamAchievementIfNeeded(AchieveDbfRecord achieveRecord)
 	{
diff --git a/Assembly-CSharp/Achievement.cs b/Assembly-CSharp/Achievement.cs
index ebabc8b..380f8aa 100644
--- a/Assembly-CSharp/Achievement.cs
+++ b/Assembly-CSharp/Achievement.cs
@@ -636,7 +636,7 @@ public class Achievement
 		}
 	}
 
-	private void SetRewards(List<RewardData> rewardDataList)
+	internal void SetRewards(List<RewardData> rewardDataList)
 	{
 		m_rewards = new List<RewardData>(rewardDataList);
 		FixUpRewardOrigins(m_rewards);
diff --git a/Assembly-CSharp/Actor.cs b/Assembly-CSharp/Actor.cs
index 0b94bae..83fe101 100644
--- a/Assembly-CSharp/Actor.cs
+++ b/Assembly-CSharp/Actor.cs
@@ -999,11 +999,11 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 			return;
 		}
 		using DefLoader.DisposableCardDef cardDef = card.ShareDisposableCardDef();
-		if (m_cardDefHandle.SetCardDef(cardDef))
-		{
-			LoadArmorSpell();
+			if (m_cardDefHandle.SetCardDef(cardDef))
+			{
+				LoadArmorSpell();
+			}
 		}
-	}
 
 	public void SetCardDef(DefLoader.DisposableCardDef cardDef)
 	{
@@ -1093,11 +1093,11 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 		{
 			return;
 		}
-		string cardId = m_entityDef.GetCardId();
-		m_cardDefHandle.SetCardId(cardId);
+			string cardId = m_entityDef.GetCardId();
+			m_cardDefHandle.SetCardId(cardId);
 		using DefLoader.DisposableCardDef cardDef = DefLoader.Get()?.GetCardDef(cardId);
-		SetCardDef(cardDef);
-	}
+				SetCardDef(cardDef);
+			}
 
 	public virtual void SetPremium(TAG_PREMIUM premium)
 	{
@@ -2035,11 +2035,11 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 			return;
 		}
 		using AssetHandle<Mesh> assetHandle = AssetLoader.Get().LoadAsset<Mesh>(planeRef);
-		if (assetHandle != null)
-		{
-			component.sharedMesh = assetHandle;
+			if (assetHandle != null)
+			{
+				component.sharedMesh = assetHandle;
+			}
 		}
-	}
 
 	public void UpdateDiamondCardArt()
 	{
@@ -2090,14 +2090,14 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 				m_diamondModelShown = diamondModel;
 				if (m_diamondModelObject != null)
 				{
-					m_diamondModelObject.transform.parent = m_rootObject.transform;
-					if ((bool)m_diamondRenderToTexture)
-					{
-						m_diamondRenderToTexture.m_ObjectToRender = m_diamondModelObject;
-						m_diamondRenderToTexture.m_ClearColor = m_cardDefHandle.Get(m_premiumType).m_DiamondPlaneRTT_CearColor;
-					}
-					m_portraitMeshDirty = true;
+				m_diamondModelObject.transform.parent = m_rootObject.transform;
+				if ((bool)m_diamondRenderToTexture)
+				{
+					m_diamondRenderToTexture.m_ObjectToRender = m_diamondModelObject;
+					m_diamondRenderToTexture.m_ClearColor = m_cardDefHandle.Get(m_premiumType).m_DiamondPlaneRTT_CearColor;
 				}
+				m_portraitMeshDirty = true;
+			}
 			}
 			else if ((bool)m_diamondRenderToTexture)
 			{
@@ -2117,11 +2117,11 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 			if (component != null && component.GetSharedMaterial().HasProperty("_MainTex") && assetReference != null)
 			{
 				using AssetHandle<Texture2D> assetHandle = AssetLoader.Get().LoadAsset<Texture2D>(assetReference);
-				if (assetHandle != null)
-				{
-					GetMaterialInstance(component).SetTexture("_MainTex", (Texture2D)assetHandle);
+					if (assetHandle != null)
+					{
+						GetMaterialInstance(component).SetTexture("_MainTex", (Texture2D)assetHandle);
+					}
 				}
-			}
 			HighlightState componentInChildren = GetComponentInChildren<HighlightState>();
 			if (componentInChildren != null && componentInChildren.isActiveAndEnabled)
 			{
@@ -2647,8 +2647,8 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 			}
 			else
 			{
-				SetPortraitMaterial(m_initialPortraitMaterial);
-			}
+			SetPortraitMaterial(m_initialPortraitMaterial);
+		}
 		}
 		UpdatePortraitTexture();
 		UpdateGhostCardEffect(RTTUpdateOnly: true);
@@ -2743,38 +2743,38 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 				}
 			}
 			{
-				foreach (Material material3 in component.GetMaterials())
+			foreach (Material material3 in component.GetMaterials())
+			{
+				if (material3.HasProperty("_LightingBlend"))
 				{
-					if (material3.HasProperty("_LightingBlend"))
-					{
-						material3.SetFloat("_LightingBlend", value);
-					}
-					if (material3.HasProperty("_Seed") && material3.GetFloat("_Seed") == 0f)
-					{
-						material3.SetFloat("_Seed", UnityEngine.Random.Range(0f, 2f));
-					}
+					material3.SetFloat("_LightingBlend", value);
 				}
+				if (material3.HasProperty("_Seed") && material3.GetFloat("_Seed") == 0f)
+				{
+					material3.SetFloat("_Seed", UnityEngine.Random.Range(0f, 2f));
+				}
+			}
 				return;
 			}
 		}
-		if (m_legacyPortraitMaterialIndex < 0)
-		{
-			return;
-		}
-		try
-		{
-			if (m_meshRenderer.GetMaterial(m_legacyPortraitMaterialIndex) == material)
+			if (m_legacyPortraitMaterialIndex < 0)
 			{
 				return;
 			}
+			try
+			{
+				if (m_meshRenderer.GetMaterial(m_legacyPortraitMaterialIndex) == material)
+				{
+					return;
+				}
+			}
+			catch (Exception ex3)
+			{
+				ExceptionReporter.Get()?.ReportCaughtException(new Exception("Error getting currMaterial. Actor game object:" + base.gameObject.name + ",  full path:" + base.gameObject.GetFullPath() + ", Exception:" + ex3.Message, ex3));
+				Log.Gameplay.PrintError("Actor game object:" + base.gameObject.name + ", full path:" + base.gameObject.GetFullPath() + ", Exception:" + ex3.Message, ex3.StackTrace);
+			}
+			m_meshRenderer.SetMaterial(m_legacyPortraitMaterialIndex, material);
 		}
-		catch (Exception ex3)
-		{
-			ExceptionReporter.Get()?.ReportCaughtException(new Exception("Error getting currMaterial. Actor game object:" + base.gameObject.name + ",  full path:" + base.gameObject.GetFullPath() + ", Exception:" + ex3.Message, ex3));
-			Log.Gameplay.PrintError("Actor game object:" + base.gameObject.name + ", full path:" + base.gameObject.GetFullPath() + ", Exception:" + ex3.Message, ex3.StackTrace);
-		}
-		m_meshRenderer.SetMaterial(m_legacyPortraitMaterialIndex, material);
-	}
 
 	public void SetPortraitDesaturation(float desaturation)
 	{
@@ -2893,14 +2893,14 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 		if (!(m_costTextMesh == null))
 		{
 			if (HasHideStats(entityDef) || entityDef.HasTag(GAME_TAG.HIDE_COST) || (entityDef.IsBaconSpell() && m_entity != null && m_entity.GetControllerSide() == Player.Side.FRIENDLY) || (!entityDef.IsBaconSpell() && UseTechLevelManaGem()) || (entityDef.IsCardButton() && entityDef.HasTriggerVisual() && (!GameMgr.Get().IsBattlegrounds() || !entityDef.HasTag(GAME_TAG.HAS_ACTIVATE_POWER))))
-			{
-				m_costTextMesh.Text = "";
-			}
-			else
-			{
-				m_costTextMesh.Text = Convert.ToString(entityDef.GetTag(GAME_TAG.COST));
-			}
+		{
+			m_costTextMesh.Text = "";
 		}
+		else
+		{
+			m_costTextMesh.Text = Convert.ToString(entityDef.GetTag(GAME_TAG.COST));
+		}
+	}
 	}
 
 	public void UpdateAttackTextMesh(EntityDef entityDef)
@@ -2937,16 +2937,16 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 				{
 					m_attackObject.SetActive(value: false);
 				}
-				m_attackTextMesh.Text = "";
+					m_attackTextMesh.Text = "";
 				return;
-			}
-			if (m_attackObject != null && !m_attackObject.activeSelf)
-			{
-				m_attackObject.SetActive(value: true);
-			}
+				}
+				if (m_attackObject != null && !m_attackObject.activeSelf)
+				{
+					m_attackObject.SetActive(value: true);
+				}
 			string text = ((!entityDef.HasTag(GAME_TAG.HIDE_ATTACK_NUMBER)) ? Convert.ToString(num) : string.Empty);
 			m_attackTextMesh.Text = text;
-		}
+			}
 		else
 		{
 			string text2 = ((!entityDef.HasTag(GAME_TAG.HIDE_ATTACK_NUMBER)) ? Convert.ToString(num) : string.Empty);
@@ -3168,7 +3168,7 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 		else
 		{
 			UpdateMinionHealthText(m_entity.GetDefHealth(), m_entity.GetHealth(), m_entity.GetDamage(), allowJiggle: false, m_entity.HasTag(GAME_TAG.HIDE_HEALTH_NUMBER));
-		}
+	}
 	}
 
 	public virtual void UpdateTextComponents(Entity entity)
@@ -3501,23 +3501,13 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 		{
 			return;
 		}
-		if (questEnt.HasTag(GAME_TAG.BACON_MINION_TYPE_REWARD))
+
+		var formattedText = FormatDynamicQuestRewardText(questEnt, m_entityDef);
+		if (formattedText != null)
 		{
-			string cardTextInHand = m_entityDef.GetCardTextInHand();
-			cardTextInHand = string.Format(cardTextInHand, GameStrings.GetRaceNameBattlegrounds((TAG_RACE)questEnt.GetTag(GAME_TAG.BACON_MINION_TYPE_REWARD)));
-			SetCardDefPowerTextOverride(cardTextInHand);
-		}
-		if (questEnt.HasTag(GAME_TAG.BACON_CARD_DBID_REWARD))
-		{
-			string cardTextInHand2 = m_entityDef.GetCardTextInHand();
-			CardDbfRecord record = GameDbf.Card.GetRecord(questEnt.GetTag(GAME_TAG.BACON_CARD_DBID_REWARD));
-			if (record != null)
-			{
-				string arg = record.Name;
-				cardTextInHand2 = string.Format(cardTextInHand2, arg);
-				SetCardDefPowerTextOverride(cardTextInHand2);
-			}
+			SetCardDefPowerTextOverride(formattedText);
 		}
+
 	}
 
 	private bool ShouldUseEntityDefForPowersText()
@@ -3640,11 +3630,11 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 		{
 			int dbId = m_entity.GetTag(GAME_TAG.PENDING_TRANSFORM_TO_CARD);
 			using DefLoader.DisposableFullDef disposableFullDef = DefLoader.Get().GetFullDef(dbId);
-			if (disposableFullDef.EntityDef != null)
-			{
-				text = ((!disposableFullDef.EntityDef.IsQuest() && !disposableFullDef.EntityDef.IsSideQuest() && !disposableFullDef.EntityDef.IsQuestline()) ? "?" : "!");
+				if (disposableFullDef.EntityDef != null)
+				{
+					text = ((!disposableFullDef.EntityDef.IsQuest() && !disposableFullDef.EntityDef.IsSideQuest() && !disposableFullDef.EntityDef.IsQuestline()) ? "?" : "!");
+				}
 			}
-		}
 		if ((bool)UniversalInputManager.UsePhoneUI && m_entity != null)
 		{
 			TransformUtil.SetLocalPosZ(m_secretText, -0.01f);
@@ -4474,19 +4464,19 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 			component.SendEvent("Birth");
 			return;
 		}
-		switch (tagChanged)
-		{
-		case GAME_TAG.TITAN_ABILITY_USED_1:
-			component.SendEvent("DeactivateLeftPip");
-			break;
-		case GAME_TAG.TITAN_ABILITY_USED_2:
-			component.SendEvent("DeactivateCenterPip");
-			break;
-		case GAME_TAG.TITAN_ABILITY_USED_3:
-			component.SendEvent("DeactivateRightPip");
-			break;
+			switch (tagChanged)
+			{
+			case GAME_TAG.TITAN_ABILITY_USED_1:
+				component.SendEvent("DeactivateLeftPip");
+				break;
+			case GAME_TAG.TITAN_ABILITY_USED_2:
+				component.SendEvent("DeactivateCenterPip");
+				break;
+			case GAME_TAG.TITAN_ABILITY_USED_3:
+				component.SendEvent("DeactivateRightPip");
+				break;
+			}
 		}
-	}
 
 	public virtual void UpdateCardRuneBannerComponent()
 	{
@@ -4956,8 +4946,8 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 		else
 		{
 			if (m_tradeableBannerContainer != null)
-			{
-				m_tradeableBannerContainer.gameObject.SetActive(value: false);
+		{
+			m_tradeableBannerContainer.gameObject.SetActive(value: false);
 			}
 			if (m_forgeBannerContainer != null)
 			{
@@ -5182,9 +5172,9 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 				m_cardMesh.GetComponent<Renderer>().GetMaterial(m_cardFrontMatIdx).mainTexture = m_cardColorTex;
 			}
 			if ((cardType == TAG_CARDTYPE.SPELL || cardType == TAG_CARDTYPE.BATTLEGROUND_SPELL || (cardType == TAG_CARDTYPE.WEAPON && colorType == CardColorSwitcher.CardColorType.TYPE_DEATHKNIGHT)) && (bool)m_portraitMesh && m_portraitFrameMatIdx > -1)
-			{
-				m_portraitMesh.GetComponent<Renderer>().GetMaterial(m_portraitFrameMatIdx).mainTexture = m_cardColorTex;
-			}
+				{
+					m_portraitMesh.GetComponent<Renderer>().GetMaterial(m_portraitFrameMatIdx).mainTexture = m_cardColorTex;
+				}
 		}
 		else if (m_legacyCardColorMaterialIndex >= 0 && m_meshRenderer != null)
 		{
@@ -5303,18 +5293,18 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 		{
 			if (reparent)
 			{
-				base.transform.parent = null;
+			base.transform.parent = null;
 			}
 			return;
 		}
 		if (reparent)
 		{
-			base.transform.parent = card.transform;
-			TransformUtil.Identity(base.transform);
-			if (m_rootObject != null)
-			{
-				TransformUtil.Identity(m_rootObject.transform);
-			}
+		base.transform.parent = card.transform;
+		TransformUtil.Identity(base.transform);
+		if (m_rootObject != null)
+		{
+			TransformUtil.Identity(m_rootObject.transform);
+		}
 		}
 		m_entity = card.GetEntity();
 		UpdateTextComponents(m_entity);
@@ -5457,11 +5447,11 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 		bool flag = false;
 		if (GetEntity() != null)
 		{
-			if (GetEntity().IsStealthed() && !Options.Get().GetBool(Option.HAS_SEEN_STEALTH_TAUNTER, defaultVal: false))
-			{
-				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_STEALTH_TAUNT3_22"), "VO_INNKEEPER_STEALTH_TAUNT3_22.prefab:7ec7cc35d1556434ebca64bfe4e770cb");
-				Options.Get().SetBool(Option.HAS_SEEN_STEALTH_TAUNTER, val: true);
-			}
+		if (GetEntity().IsStealthed() && !Options.Get().GetBool(Option.HAS_SEEN_STEALTH_TAUNTER, defaultVal: false))
+		{
+			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_STEALTH_TAUNT3_22"), "VO_INNKEEPER_STEALTH_TAUNT3_22.prefab:7ec7cc35d1556434ebca64bfe4e770cb");
+			Options.Get().SetBool(Option.HAS_SEEN_STEALTH_TAUNTER, val: true);
+		}
 			flag = GetEntity().IsStealthed() || GetEntity().IsTauntIgnored();
 		}
 		switch (m_premiumType)
@@ -5602,8 +5592,8 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 
 	public void DeactivateEvilTwinMustache()
 	{
-		ActivateSpellDeathState(SpellType.EVIL_TWIN_MUSTACHE);
-		ActivateSpellDeathState(SpellType.EVIL_TWIN_MUSTACHE_PREMIUM);
+			ActivateSpellDeathState(SpellType.EVIL_TWIN_MUSTACHE);
+			ActivateSpellDeathState(SpellType.EVIL_TWIN_MUSTACHE_PREMIUM);
 		ActivateSpellDeathState(SpellType.EVIL_TWIN_MUSTACHE_SIGNATURE);
 		ActivateSpellDeathState(SpellType.EVIL_TWIN_MUSTACHE_DIAMOND);
 	}
@@ -5699,19 +5689,19 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 			}
 			return;
 		}
-		if (!(m_localSpellTable != null))
-		{
-			return;
-		}
-		foreach (SpellTableEntry item in m_localSpellTable.m_Table)
-		{
-			Spell spell = item.m_Spell;
-			if (!(spell == null) && spell.IsActive())
+			if (!(m_localSpellTable != null))
+			{
+				return;
+			}
+			foreach (SpellTableEntry item in m_localSpellTable.m_Table)
 			{
-				spell.ActivateState(SpellStateType.DEATH);
+				Spell spell = item.m_Spell;
+				if (!(spell == null) && spell.IsActive())
+				{
+					spell.ActivateState(SpellStateType.DEATH);
+				}
 			}
 		}
-	}
 
 	public void DoCardDeathVisuals()
 	{
@@ -5738,19 +5728,19 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 			}
 			return;
 		}
-		if (!(m_localSpellTable != null))
-		{
-			return;
-		}
-		foreach (SpellTableEntry item2 in m_localSpellTable.m_Table)
-		{
-			Spell spell2 = item2.m_Spell;
-			if (!(spell2 == null))
+			if (!(m_localSpellTable != null))
 			{
-				spell2.Deactivate();
+				return;
+			}
+			foreach (SpellTableEntry item2 in m_localSpellTable.m_Table)
+			{
+				Spell spell2 = item2.m_Spell;
+				if (!(spell2 == null))
+				{
+					spell2.Deactivate();
+				}
 			}
 		}
-	}
 
 	public void ReleaseSpell(SpellType spellType)
 	{
@@ -6351,4 +6341,28 @@ public class Actor : MonoBehaviour, IVisibleWidgetComponent
 	{
 		return m_cardRuneBanner;
 	}
+
+	#region Accessibility
+	internal static string FormatDynamicQuestRewardText(Entity questEnt, EntityDef entityDef)
+	{
+				if (questEnt.HasTag(GAME_TAG.BACON_MINION_TYPE_REWARD))
+		{
+			string cardTextInHand = entityDef.GetCardTextInHand();
+			cardTextInHand = string.Format(cardTextInHand, GameStrings.GetRaceNameBattlegrounds((TAG_RACE)questEnt.GetTag(GAME_TAG.BACON_MINION_TYPE_REWARD)));
+			return cardTextInHand;
+		}
+		if (questEnt.HasTag(GAME_TAG.BACON_CARD_DBID_REWARD))
+		{
+			string cardTextInHand2 = entityDef.GetCardTextInHand();
+			CardDbfRecord record = GameDbf.Card.GetRecord(questEnt.GetTag(GAME_TAG.BACON_CARD_DBID_REWARD));
+			if (record != null)
+			{
+				string arg = record.Name;
+				cardTextInHand2 = string.Format(cardTextInHand2, arg);
+			}
+			return cardTextInHand2;
+		}
+		return null;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/ActorStateType.cs b/Assembly-CSharp/ActorStateType.cs
index d49c743..c36bc1d 100644
--- a/Assembly-CSharp/ActorStateType.cs
+++ b/Assembly-CSharp/ActorStateType.cs
@@ -1,56 +1,57 @@
 public enum ActorStateType
 {
-	NONE,
-	CARD_IDLE,
-	CARD_MOUSE_OVER,
-	CARD_OPPONENT_MOUSE_OVER,
-	CARD_SELECTABLE,
-	CARD_SELECTED,
-	CARD_PLAYABLE,
-	CARD_PLAYABLE_MOUSE_OVER,
-	CARD_OVER_PLAYFIELD,
-	CARD_COMBO,
-	CARD_COMBO_MOUSE_OVER,
-	CARD_TARGETABLE_BAD,
-	CARD_TARGETABLE,
-	ENDTURN_NO_MORE_PLAYS,
-	ENDTURN_YOUR_TURN,
-	ENDTURN_WAITING,
-	CARD_POWERED_UP,
-	zzz_ENDTURN_NO_MORE_PLAYS_MOUSE_OVER_DEPRECATED,
-	zzz_ENDTURN_NMP_MOUSE_OVER_2_NMP_DEPRECATED,
-	zzz_ENDTURN_YT_MOUSE_OVER_2_YT_DEPRECATED,
-	ENDTURN_NMP_2_WAITING,
-	DEPRECATED_ENDTURN_WAITING_2_NMP,
-	ENDTURN_YOUR_TURN_TIMER,
-	ENDTURN_WAITING_TIMER,
-	CARD_RECENTLY_ACQUIRED,
-	CARD_RECENTLY_ACQUIRED_MOUSE_OVER,
-	CARD_VALID_TARGET,
-	CARD_VALID_TARGET_MOUSE_OVER,
-	CARD_HISTORY,
-	HIGHLIGHT_OFF,
-	HIGHLIGHT_PRIMARY_ACTIVE,
-	HIGHLIGHT_PRIMARY_MOUSE_OVER,
-	HIGHLIGHT_PRIMARY_MOUSE_DOWN,
-	HIGHLIGHT_SECONDARY_ACTIVE,
-	HIGHLIGHT_SECONDARY_MOUSE_OVER,
-	HIGHLIGHT_SECONDARY_MOUSE_DOWN,
-	HIGHLIGHT_MOUSE_OVER,
-	ENDTURN_YOUR_TURN_EXPLODE_FX,
-	CARD_HISTORY_ALT_TINT,
-	DEPRECATED_39,
-	EXTRATURN_NO_MORE_PLAYS,
-	EXTRATURN_YOUR_TURN,
-	WAITING_TO_EXTRATURN,
-	CARD_ATTACKABLE_BY_RUSH,
-	CARD_ATTACKABLE_BY_RUSH_MOUSE_OVER,
-	CARD_MOVEABLE,
-	CARD_MOVEABLE_MOUSE_OVER,
-	CARD_AUTO_ATTACKING,
-	CARD_SELECTABLE_BG_QUEST,
-	CARD_MOUSE_OVER_BG_QUEST,
-	CARD_OVER_MOVE_MINION_TARGET,
+    NONE,
+    CARD_IDLE,
+    CARD_MOUSE_OVER,
+    CARD_OPPONENT_MOUSE_OVER,
+    CARD_SELECTABLE,
+    CARD_SELECTED,
+    CARD_PLAYABLE,
+    CARD_PLAYABLE_MOUSE_OVER,
+    CARD_OVER_PLAYFIELD,
+    CARD_COMBO,
+    CARD_COMBO_MOUSE_OVER,
+    CARD_TARGETABLE_BAD,
+    CARD_TARGETABLE,
+    ENDTURN_NO_MORE_PLAYS,
+    ENDTURN_YOUR_TURN,
+    ENDTURN_WAITING,
+    CARD_POWERED_UP,
+    zzz_ENDTURN_NO_MORE_PLAYS_MOUSE_OVER_DEPRECATED,
+    zzz_ENDTURN_NMP_MOUSE_OVER_2_NMP_DEPRECATED,
+    zzz_ENDTURN_YT_MOUSE_OVER_2_YT_DEPRECATED,
+    ENDTURN_NMP_2_WAITING,
+    DEPRECATED_ENDTURN_WAITING_2_NMP,
+    ENDTURN_YOUR_TURN_TIMER,
+    ENDTURN_WAITING_TIMER,
+    CARD_RECENTLY_ACQUIRED,
+    CARD_RECENTLY_ACQUIRED_MOUSE_OVER,
+    CARD_VALID_TARGET,
+    CARD_VALID_TARGET_MOUSE_OVER,
+    CARD_HISTORY,
+    HIGHLIGHT_OFF,
+    HIGHLIGHT_PRIMARY_ACTIVE,
+    HIGHLIGHT_PRIMARY_MOUSE_OVER,
+    HIGHLIGHT_PRIMARY_MOUSE_DOWN,
+    HIGHLIGHT_SECONDARY_ACTIVE,
+    HIGHLIGHT_SECONDARY_MOUSE_OVER,
+    HIGHLIGHT_SECONDARY_MOUSE_DOWN,
+    HIGHLIGHT_MOUSE_OVER,
+    ENDTURN_YOUR_TURN_EXPLODE_FX,
+    CARD_HISTORY_ALT_TINT,
+    DEPRECATED_39,
+    EXTRATURN_NO_MORE_PLAYS,
+    EXTRATURN_YOUR_TURN,
+    WAITING_TO_EXTRATURN,
+    CARD_ATTACKABLE_BY_RUSH,
+    CARD_ATTACKABLE_BY_RUSH_MOUSE_OVER,
+    CARD_MOVEABLE,
+    CARD_MOVEABLE_MOUSE_OVER,
+    CARD_AUTO_ATTACKING,
+    CARD_SELECTABLE_BG_QUEST,
+    CARD_MOUSE_OVER_BG_QUEST,
+    CARD_OVER_MOVE_MINION_TARGET,
 	CARD_TITAN_ABILITY,
-	CARD_TITAN_ABILITY_MOUSE_OVER
+	CARD_TITAN_ABILITY_MOUSE_OVER,
+    EOE
 }
diff --git a/Assembly-CSharp/AddFriendFrame.cs b/Assembly-CSharp/AddFriendFrame.cs
index d5905a5..9531e52 100644
--- a/Assembly-CSharp/AddFriendFrame.cs
+++ b/Assembly-CSharp/AddFriendFrame.cs
@@ -2,8 +2,9 @@ using System;
 using Blizzard.T5.Fonts;
 using Blizzard.T5.Services;
 using UnityEngine;
+using Accessibility;
 
-public class AddFriendFrame : MonoBehaviour
+public class AddFriendFrame : MonoBehaviour, AccessibleUI
 {
 	public AddFriendFrameBones m_Bones;
 
@@ -60,9 +61,11 @@ public class AddFriendFrame : MonoBehaviour
 			m_InputTextField.Text = m_inputText;
 			UpdateInstructions();
 		}
+
+		ReadFrame();
 	}
 
-	private void OnDestroy()
+    private void OnDestroy()
 	{
 		DialogManager.Get().OnDialogShown -= OnDialogShown;
 		DialogManager.Get().OnDialogHidden -= OnDialogHidden;
@@ -235,6 +238,8 @@ public class AddFriendFrame : MonoBehaviour
 
 	private void OnClosed()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (this.Closed != null)
 		{
 			this.Closed();
@@ -262,4 +267,25 @@ public class AddFriendFrame : MonoBehaviour
 	{
 		ShowSavedText();
 	}
+
+    #region Accessibility
+
+    private void ReadFrame()
+    {
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_ADDFRIEND_INSTRUCTION"));
+    }
+
+    public void HandleAccessibleInput()
+    {
+		return;
+    }
+
+    public string GetAccessibleHelp()
+    {
+		// This is actually overridden by the text box for entering BTag or email
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/AdventureBookPageDisplay.cs b/Assembly-CSharp/AdventureBookPageDisplay.cs
index 0936cc7..82f74cf 100644
--- a/Assembly-CSharp/AdventureBookPageDisplay.cs
+++ b/Assembly-CSharp/AdventureBookPageDisplay.cs
@@ -2,13 +2,16 @@ using System.Collections;
 using System.Collections.Generic;
 using Assets;
 using Blizzard.T5.Core;
+using Blizzard.T5.MaterialService.Extensions;
 using Hearthstone.DataModels;
 using Hearthstone.Store;
 using Hearthstone.UI;
 using PegasusUtil;
+using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class AdventureBookPageDisplay : BookPageDisplay
+public class AdventureBookPageDisplay : BookPageDisplay, AccessibleScreen
 {
 	public delegate void PageReadyCallback();
 
@@ -235,9 +238,9 @@ public class AdventureBookPageDisplay : BookPageDisplay
 			return false;
 		}
 		if (m_pageData.PageType == AdventureBookPageType.CHAPTER && m_pageData is ChapterPageData chapterPageData)
-		{
-			return AdventureUtils.DoesBundleIncludeWing(bundle, chapterPageData.WingRecord.ID);
-		}
+			{
+				return AdventureUtils.DoesBundleIncludeWing(bundle, chapterPageData.WingRecord.ID);
+			}
 		return AdventureUtils.DoesBundleIncludeWingForAdventure(bundle, m_pageData.Adventure);
 	}
 
@@ -275,6 +278,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 				yield return null;
 			}
 		}
+		AccessibilityUtils.LogDebug("invoking callback for ready");
 		callback?.Invoke();
 	}
 
@@ -285,6 +289,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 
 	private void SetupPageDataModels(PageData pageData)
 	{
+		AccessibilityUtils.LogDebug("setting page data models");
 		m_adventureBookPageContentsWidget.GetDataModel(2, out var model);
 		m_pageDataModel = model as AdventureBookPageDataModel;
 		if (m_pageDataModel == null)
@@ -332,24 +337,24 @@ public class AdventureBookPageDisplay : BookPageDisplay
 				return;
 			}
 			{
-				foreach (AdventureMissionDataModel mission in m_pageDataModel.ChapterData.Missions)
+			foreach (AdventureMissionDataModel mission in m_pageDataModel.ChapterData.Missions)
+			{
+				bool flag = mission.Rewards != null && mission.Rewards.Items != null && mission.Rewards.Items.Count > 0;
+				if (mission.NewlyCompleted)
 				{
-					bool flag = mission.Rewards != null && mission.Rewards.Items != null && mission.Rewards.Items.Count > 0;
-					if (mission.NewlyCompleted)
-					{
-						m_needToShowMissionCompleteAnim = true;
-						if (flag)
-						{
-							m_needToShowRewardChestAnim = true;
-						}
-					}
-					if (mission.NewlyUnlocked)
+					m_needToShowMissionCompleteAnim = true;
+					if (flag)
 					{
-						m_needToShowMissionUnlockAnim = true;
+						m_needToShowRewardChestAnim = true;
 					}
 				}
-				return;
+				if (mission.NewlyUnlocked)
+				{
+					m_needToShowMissionUnlockAnim = true;
+				}
 			}
+				return;
+		}
 		}
 		if (pageData.PageType == AdventureBookPageType.MAP)
 		{
@@ -513,6 +518,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 		else
 		{
 			AdventureConfig.Get().SetMission(adventureMissionDataModel.ScenarioId);
+			AccessibilityUtils.LogDebug("on boss selected "+adventureMissionDataModel.ScenarioId);
 		}
 	}
 
@@ -725,6 +731,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 
 	public IEnumerator InitializeMapButtonsWhenResolved(Widget bookMapWidget)
 	{
+		AccessibilityUtils.LogDebug("Initialize map buttons when resolved");
 		while (bookMapWidget.IsChangingStates)
 		{
 			yield return null;
@@ -772,6 +779,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 							ButtonName = text
 						};
 						m_chapterButtonClickablesNameMap.Add(text, chapterButton);
+						AccessibilityUtils.LogDebug("Chapter button added :"+text);
 						chapterButton.SetData(data);
 						chapterButton.AddEventListener(UIEventType.RELEASE, OnChapterClickableRelease);
 					}
@@ -829,6 +837,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 
 	private static void UpdateChapterDataModelWithChapterData(AdventureChapterDataModel chapterDataModel, ChapterPageData chapterData)
 	{
+		AccessibilityUtils.LogDebug("update chapter data model with chapter data");
 		WingDbfRecord wingRecord = chapterData.WingRecord;
 		chapterDataModel.Name = wingRecord.Name;
 		chapterDataModel.Description = wingRecord.Description;
@@ -965,6 +974,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 			AdventureMissionDataModel missionDataModel = new AdventureMissionDataModel();
 			missionDataModel.Rewards = new RewardListDataModel();
 			missionDataModel.ScenarioId = (ScenarioDbId)scenarioRecord.ID;
+			AccessibilityUtils.LogDebug("Adding mission id "+(ScenarioDbId)scenarioRecord.ID+" to the data model");
 			missionDataModel.Selected = mission == scenarioRecord.ID;
 			missionDataModel.MissionState = AdventureProgressMgr.Get().AdventureMissionStateForScenario(scenarioRecord.ID);
 			HashSet<Assets.Achieve.RewardTiming> rewardTimings3 = new HashSet<Assets.Achieve.RewardTiming>
@@ -1033,6 +1043,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 
 	private IEnumerator ShowPageUpdateVisualsWhenReady()
 	{
+		AccessibilityUtils.LogDebug("Show page update visuals when ready");
 		while (!m_allInitialTransitionsComplete)
 		{
 			yield return null;
@@ -1051,6 +1062,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 		else if (m_pageData.PageType == AdventureBookPageType.CHAPTER)
 		{
 			StartCoroutine(AnimateChapterRewardsAndCompletionIfNecessary());
+					ReadMissionsMenu();
 		}
 	}
 
@@ -1140,7 +1152,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 			yield return null;
 		}
 		m_adventureBookPageContentsWidget.RemoveEventListener(AdventureNewlyCompletedEventListener);
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureBookPageDisplay.AnimateAdventureComplete"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureBookPageDisplay.AnimateAdventureComplete"))
 		{
 			bool allPopupsShown = false;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
@@ -1157,6 +1169,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 
 	private IEnumerator AnimateChapterRewardsAndCompletionIfNecessary()
 	{
+		AccessibilityUtils.LogDebug("Animate chapter rewards and completion if necessary");
 		if (m_needToShowMissionCompleteAnim)
 		{
 			EnableInteraction(enable: false);
@@ -1179,7 +1192,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 				yield return null;
 			}
 			m_adventureBookPageContentsWidget.RemoveEventListener(RewardChestAnimEventListener);
-			if (UserAttentionManager.CanShowAttentionGrabber("AdventureBookPageDisplay.AnimateChapterRewardsAndCompletionIfNecessary"))
+			if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureBookPageDisplay.AnimateChapterRewardsAndCompletionIfNecessary"))
 			{
 				bool allPopupsShown = false;
 				if (AdventureScene.Get().IsDevMode)
@@ -1288,6 +1301,7 @@ public class AdventureBookPageDisplay : BookPageDisplay
 		{
 			EnableInteraction(enable: true);
 		}
+		ReadBookPageDisplay();
 	}
 
 	private void AckMissionUnlocksOnCurrentPage()
@@ -1559,4 +1573,106 @@ public class AdventureBookPageDisplay : BookPageDisplay
 			}
 		}
 	}
+
+	#region Accessibility
+	        private AccessibleElement m_curMenu;
+			private enum AccessState {MISSION_MENU, CHAPTER_MENU};
+			private AccessState State=AccessState.CHAPTER_MENU;
+			private int ChapterIndex;
+
+private AccessibleHorizontalMenu<AccessibleChapterButton> ChaptersList;
+	private void ReadBookPageDisplay() {
+	State=AccessState.CHAPTER_MENU;
+			AccessibilityUtils.LogDebug("Read book page display");
+
+		var menuTitle = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CHOOSE_CHAPTER_TITLE);
+		ChaptersList = new AccessibleHorizontalMenu<AccessibleChapterButton>(this, menuTitle,GoBack);
+		m_curMenu=ChaptersList;
+		int i=0;
+						AccessibilityMgr.SetScreen(this);
+foreach(var k in m_chapterButtonClickablesNameMap.Keys) {
+			var btn=m_chapterButtonClickablesNameMap[k];
+			ChaptersList.AddOption(new AccessibleChapterButton(this, k, "desc"), () => ClickChapter(btn, i));
+			i++;
+}
+ChaptersList.StartReading();
+	}
+
+	private void ClickChapter(Clickable btn, int index) {
+		btn.GetPegUIElement().TriggerRelease();
+		ChapterIndex=index;
+	}
+	public void HandleInput() {
+			if(State==AccessState.MISSION_MENU) MissionsList.HandleAccessibleInput();
+			if(State==AccessState.CHAPTER_MENU) ChaptersList.HandleAccessibleInput();
+
+	}
+
+            public string GetHelp() {
+			if(State==AccessState.MISSION_MENU) return MissionsList.GetHelp();
+			return ChaptersList.GetHelp();
+			}
+    public void OnGainedFocus()
+    {
+			if(State==AccessState.MISSION_MENU) MissionsList.StartReading();
+			if(State==AccessState.CHAPTER_MENU) ChaptersList.StartReading();
+
+	}
+
+	private void GoBack() {
+		Navigation.GoBack();
+	}
+	AccessibleMenu MissionsList;
+private void ReadMissionsMenu() {
+	State=AccessState.MISSION_MENU;
+		AccessibilityUtils.LogDebug("Read missions menu");
+
+		var menuTitle = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CHOOSE_MISSION_TITLE);
+		MissionsList = new AccessibleMenu(this, menuTitle,GoBack);
+m_curMenu=MissionsList;
+		int i=1;
+		string StateStr="";
+		foreach(var k in m_pageDataModel.ChapterData.Missions) {
+			switch(k.MissionState) {
+				case AdventureMissionState.LOCKED:
+				StateStr=LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_MISSION_LOCKED);
+				break;
+				case AdventureMissionState.UNLOCKED:
+				StateStr=LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_MISSION_AVAILABLE);
+				break;
+				case AdventureMissionState.COMPLETED:
+				StateStr=LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_MISSION_COMPLETED);
+				break;
+			}
+			MissionsList.AddOption(LocalizationUtils.Format(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CHOOSE_MISSION_OPTION,i,StateStr),() => PlayMission(k.ScenarioId,k.MissionState));
+			i++;
+		}
+		AccessibilityMgr.SetScreen(this);
+	}
+	private void PlayMission(ScenarioDbId MissionNum,AdventureMissionState MissionState) {
+		if(MissionState==AdventureMissionState.LOCKED)  {
+			AccessibilityMgr.Output(this,LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_PLAYING_MISSION_LOCKED));
+			return;
+		}
+		AdventureBossDef bossDef = AdventureConfig.Get().GetBossDef(MissionNum);
+		AccessibilityUtils.LogDebug("Play button pressed, playing mission "+MissionNum);
+		if (bossDef != null && bossDef.m_IntroLinePlayTime == AdventureBossDef.IntroLinePlayTime.MissionStart)
+		{
+			AdventureUtils.PlayMissionQuote(bossDef, NotificationManager.DEFAULT_CHARACTER_POS);
+		}
+		if (AdventureConfig.DoesMissionRequireDeck(MissionNum))
+		{
+			AdventureData.Adventuresubscene subscene = ((!GameUtils.DoesAdventureModeUseDungeonCrawlFormat(AdventureConfig.Get().GetSelectedMode()) || AdventureConfig.Get().IsHeroSelectedBeforeDungeonCrawlScreenForSelectedAdventure()) ? AdventureConfig.Get().SubSceneForPickingHeroForCurrentAdventure() : AdventureData.Adventuresubscene.DUNGEON_CRAWL);
+			AdventureConfig.Get().ChangeSubScene(subscene);
+		}
+		else
+		{
+AdventureConfig.Get().SetMission(MissionNum);
+			GameMgr.Get().FindGame(GameType.GT_VS_AI, FormatType.FT_WILD, (int)MissionNum, 0, 0L, null, null, restoreSavedGameState: false, null, null, 0L);
+		}
+	
+
+
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/AdventureChooserTray.cs b/Assembly-CSharp/AdventureChooserTray.cs
index 54bd2ed..9e0431a 100644
--- a/Assembly-CSharp/AdventureChooserTray.cs
+++ b/Assembly-CSharp/AdventureChooserTray.cs
@@ -56,6 +56,7 @@ public class AdventureChooserTray : AccordionMenuTray
 		}
 		Box.Get().AddTransitionFinishedListener(OnBoxTransitionFinished);
 		StartCoroutine(InitTrayWhenReady());
+		Accessibility.AccessibleAdventureScene.Get().OnAdventureChooserTrayAwake(this);
 	}
 
 	private void Start()
@@ -74,6 +75,7 @@ public class AdventureChooserTray : AccordionMenuTray
 
 	protected IEnumerator InitTrayWhenReady()
 	{
+		Accessibility.AccessibleAdventureScene.Get().ClearAdventureButtons();
 		if (m_ChooseFrameScroller == null || m_ChooseFrameScroller.ScrollObject == null)
 		{
 			Debug.LogError("m_ChooseFrameScroller or m_ChooseFrameScroller.m_ScrollObject cannot be null. Unable to create button.", this);
@@ -118,11 +120,14 @@ public class AdventureChooserTray : AccordionMenuTray
 				if (map.ContainsKey(item2.GetAdventureId()))
 				{
 					nestedAdvDefs = map[item2.GetAdventureId()];
+										Accessibility.AccessibleAdventureScene.Get().AddAdventureButton(item2);
+
 				}
 				Widget widget = CreateAdventureChooserButton(item2, nestedAdvDefs);
 				if (widget != null)
 				{
 					buttonWidgets.Add(widget);
+					Accessibility.AccessibleAdventureScene.Get().AddAdventureButton(item2);
 				}
 			}
 		}
@@ -170,7 +175,7 @@ public class AdventureChooserTray : AccordionMenuTray
 	private static bool OnNavigateBack()
 	{
 		DisableTrayButtons();
-		BackToGameModes();
+			BackToGameModes();
 		return true;
 	}
 
diff --git a/Assembly-CSharp/AdventureConfig.cs b/Assembly-CSharp/AdventureConfig.cs
index 5c1cf43..26140f5 100644
--- a/Assembly-CSharp/AdventureConfig.cs
+++ b/Assembly-CSharp/AdventureConfig.cs
@@ -7,6 +7,7 @@ using Hearthstone.DungeonCrawl;
 using Hearthstone.Store;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AdventureConfig : MonoBehaviour
@@ -73,7 +74,7 @@ public class AdventureConfig : MonoBehaviour
 
 	private Map<AdventureDbId, AdventureModeDbId> m_ClientChooserAdventureModes = new Map<AdventureDbId, AdventureModeDbId>();
 
-	private AdventureDbId SelectedAdventure
+	internal AdventureDbId SelectedAdventure
 	{
 		get
 		{
@@ -98,7 +99,7 @@ public class AdventureConfig : MonoBehaviour
 		}
 	}
 
-	private AdventureModeDbId SelectedMode
+	internal AdventureModeDbId SelectedMode
 	{
 		get
 		{
@@ -423,6 +424,7 @@ public class AdventureConfig : MonoBehaviour
 
 	public void SetSelectedAdventureMode(AdventureDbId adventureId, AdventureModeDbId modeId)
 	{
+		AccessibilityUtils.LogDebug($"SetSelectedAdventureMode({adventureId}, {modeId})");
 		SelectedAdventure = adventureId;
 		SelectedMode = modeId;
 		m_ClientChooserAdventureModes[adventureId] = modeId;
@@ -666,6 +668,7 @@ public class AdventureConfig : MonoBehaviour
 
 	public void ChangeSubScene(AdventureData.Adventuresubscene subscene, bool pushToBackStack = true)
 	{
+		AccessibilityUtils.LogDebug($"ChangeSubScene({subscene})");
 		if (subscene == m_CurrentSubScene)
 		{
 			Debug.Log($"Sub scene {subscene} is already set.");
@@ -1001,9 +1004,10 @@ public class AdventureConfig : MonoBehaviour
 
 	public void OnAdventureSceneAwake()
 	{
-		SelectedAdventure = Options.Get().GetEnum(Option.SELECTED_ADVENTURE, AdventureDbId.PRACTICE);
-		SelectedMode = Options.Get().GetEnum(Option.SELECTED_ADVENTURE_MODE, AdventureModeDbId.LINEAR);
-		if (!ShouldDisplayAdventure(SelectedAdventure))
+        SelectedAdventure = Options.Get().GetEnum(Option.SELECTED_ADVENTURE, AdventureDbId.PRACTICE);
+        SelectedMode = Options.Get().GetEnum(Option.SELECTED_ADVENTURE_MODE, AdventureModeDbId.LINEAR);
+
+        if (!ShouldDisplayAdventure(SelectedAdventure))
 		{
 			SelectedAdventure = AdventureDbId.PRACTICE;
 			SelectedMode = AdventureModeDbId.LINEAR;
diff --git a/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs b/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
index 9bd2f29..6751992 100644
--- a/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
+++ b/Assembly-CSharp/AdventureDungeonCrawlDeckTray.cs
@@ -5,7 +5,7 @@ public class AdventureDungeonCrawlDeckTray : BasePhoneDeckTray
 {
 	public PlayMakerFSM DeckTrayGlow;
 
-	private CollectionDeck m_deck;
+	internal CollectionDeck m_deck;
 
 	protected override void Awake()
 	{
diff --git a/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs b/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
index 06e27cf..a189cdd 100644
--- a/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
+++ b/Assembly-CSharp/AdventureDungeonCrawlDisplay.cs
@@ -11,9 +11,10 @@ using PegasusClient;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class AdventureDungeonCrawlDisplay : MonoBehaviour
+public class AdventureDungeonCrawlDisplay : MonoBehaviour, AccessibleScreen
 {
 	[Serializable]
 	public class DungeonCrawlDisplayStyleOverride
@@ -225,6 +226,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 	private DungeonCrawlDeckSelect m_dungeonCrawlDeckSelect;
 
 	private Actor m_heroActor;
+	private DungeonCrawlHeroDetails m_heroDetails;
 
 	private PlayerHeroData m_playerHeroData;
 
@@ -336,15 +338,15 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		m_subsceneController.TransitionComplete += OnSubSceneTransitionComplete;
 		AdventureDbId selectedAdv = m_dungeonCrawlData.GetSelectedAdventure();
 		AdventureModeDbId selectedMode = m_dungeonCrawlData.GetSelectedMode();
-		AdventureDataDbfRecord adventureDataRecord = GameUtils.GetAdventureDataRecord((int)selectedAdv, (int)selectedMode);
+		m_adventureDataRecord = GameUtils.GetAdventureDataRecord((int)selectedAdv, (int)selectedMode);
 		m_playerHeroData = new PlayerHeroData(m_dungeonCrawlData);
 		m_playerHeroData.OnHeroDataChanged += delegate
 		{
 			m_playMat.SetPlayerHeroDbId(m_playerHeroData.HeroCardDbId);
 		};
-		m_AdventureTitle.Text = adventureDataRecord.Name;
-		m_gameSaveDataServerKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataServerKey;
-		m_gameSaveDataClientKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataClientKey;
+		m_AdventureTitle.Text = m_adventureDataRecord.Name;
+		m_gameSaveDataServerKey = (GameSaveKeyId)m_adventureDataRecord.GameSaveDataServerKey;
+		m_gameSaveDataClientKey = (GameSaveKeyId)m_adventureDataRecord.GameSaveDataClientKey;
 		if (m_gameSaveDataServerKey <= (GameSaveKeyId)0)
 		{
 			Debug.LogErrorFormat("Adventure {0} Mode {1} has no GameSaveDataKey set! This mode does not work without defining GAME_SAVE_DATA_SERVER_KEY in ADVENTURE.dbi!", selectedAdv, selectedMode);
@@ -357,12 +359,12 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		{
 			Debug.LogErrorFormat("Adventure {0} Mode {1} has an equal GameSaveDataKey for Client and Server. These keys are not allowed to be equal!", selectedAdv, selectedMode);
 		}
-		m_bossCardBackId = adventureDataRecord.BossCardBack;
+		m_bossCardBackId = m_adventureDataRecord.BossCardBack;
 		if (m_bossCardBackId == 0)
 		{
 			m_bossCardBackId = 0;
 		}
-		m_saveHeroDataUsingHeroId = adventureDataRecord.DungeonCrawlSaveHeroUsingHeroDbId;
+		m_saveHeroDataUsingHeroId = m_adventureDataRecord.DungeonCrawlSaveHeroUsingHeroDbId;
 		if (m_isPVPDR && PvPDungeonRunDisplay.Get().GetPVPDRLobbyDataModel().IsSessionRolledOver)
 		{
 			PvpdrSeasonDbfRecord record = GameDbf.PvpdrSeason.GetRecord(PvPDungeonRunDisplay.Get().GetPVPDRLobbyDataModel().Season);
@@ -402,13 +404,13 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 				Log.Adventures.Print("Owns wing for this Dungeon Run? {0}", AdventureProgressMgr.Get().OwnsWing(scenarioDbfRecord2.WingId));
 			}
 		}
-		m_shouldSkipHeroSelect = adventureDataRecord.DungeonCrawlSkipHeroSelect;
-		m_mustPickShrine = adventureDataRecord.DungeonCrawlMustPickShrine;
-		m_mustSelectChapter = adventureDataRecord.DungeonCrawlSelectChapter;
-		m_anomalyModeCardDbId = adventureDataRecord.AnomalyModeDefaultCardId;
+		m_shouldSkipHeroSelect = m_adventureDataRecord.DungeonCrawlSkipHeroSelect;
+		m_mustPickShrine = m_adventureDataRecord.DungeonCrawlMustPickShrine;
+		m_mustSelectChapter = m_adventureDataRecord.DungeonCrawlSelectChapter;
+		m_anomalyModeCardDbId = m_adventureDataRecord.AnomalyModeDefaultCardId;
 		m_assetLoadingHelper.AddAssetToLoad();
 		m_dungeonCrawlPlayMatReference.RegisterReadyListener<AdventureDungeonCrawlPlayMat>(OnPlayMatReady);
-		bool retireButtonSupported = adventureDataRecord.DungeonCrawlIsRetireSupported;
+		bool retireButtonSupported = m_adventureDataRecord.DungeonCrawlIsRetireSupported;
 		m_assetLoadingHelper.AddAssetToLoad();
 		m_retireButtonReference.RegisterReadyListener(delegate(Widget w)
 		{
@@ -416,24 +418,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			{
 				if (eventName == "Button_Framed_Clicked" && retireButtonSupported)
 				{
-					m_retireButton.SetActive(value: false);
-					AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo
-					{
-						m_headerText = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_HEADER"),
-						m_text = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_BODY"),
-						m_showAlertIcon = true,
-						m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
-						m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL
-					};
-					if (m_isPVPDR)
-					{
-						popupInfo.m_responseCallback = OnPVPDRRetirePopupResponse;
-					}
-					else
-					{
-						popupInfo.m_responseCallback = OnRetirePopupResponse;
-					}
-					DialogManager.Get().ShowPopup(popupInfo);
+					RetireFromAdventure();
 				}
 			});
 			m_retireButton = w.gameObject;
@@ -470,7 +455,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		SetDungeonCrawlDisplayVisualStyle();
 	}
 
-	public void EnablePlayButton()
+    public void EnablePlayButton()
 	{
 		if (m_playMat != null)
 		{
@@ -1185,6 +1170,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			m_retireButton.SetActive(adventureDataRecord.DungeonCrawlIsRetireSupported);
 		}
 		m_assetLoadingHelper.AssetLoadCompleted();
+		ReadScreen();
 	}
 
 	private void OnPlayMatPaperControllerReady(VisualController paperController)
@@ -1240,6 +1226,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 
 	private bool IsNextMissionASpecialEncounter()
 	{
+
 		if (!m_hasReceivedGameSaveDataServerKeyResponse)
 		{
 			Debug.LogError("GetPlayButtonTextForNextMission() - this cannot be called before we've gotten the Game Save Data Server Key response!");
@@ -1305,6 +1292,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		}
 		if (flag && value == 0L && ((values2 != null && values2.Count > 0) || (values3 != null && values3.Count > 0) || (values4 != null && values4.Count > 0)))
 		{
+			IsTreasureRewardChosen = true;
 			m_playMat.ShowLootOptions(values2, values3, values4);
 			return;
 		}
@@ -1707,20 +1695,20 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 					{
 						continue;
 					}
-					string text4 = GameUtils.TranslateDbIdToCardId((int)cardId);
-					List<int> value2;
-					if (text4 == null)
-					{
-						Log.Adventures.PrintWarning("AdventureDungeonCrawlDisplay.SetUpDeckList() - No cardId for dbId {0}!", cardId);
-					}
-					else if (dictionary.TryGetValue(j + 1, out value2))
-					{
-						m_dungeonCrawlDeck.AddCard_DungeonCrawlBuff(text4, premium, value2);
-					}
-					else
-					{
+						string text4 = GameUtils.TranslateDbIdToCardId((int)cardId);
+						List<int> value2;
+						if (text4 == null)
+						{
+							Log.Adventures.PrintWarning("AdventureDungeonCrawlDisplay.SetUpDeckList() - No cardId for dbId {0}!", cardId);
+						}
+						else if (dictionary.TryGetValue(j + 1, out value2))
+						{
+							m_dungeonCrawlDeck.AddCard_DungeonCrawlBuff(text4, premium, value2);
+						}
+						else
+						{
 						m_dungeonCrawlDeck.AddCard(text4, premium, false, null);
-					}
+						}
 					if (sideboardMap != null && sideboardMap.ContainsKey(text4))
 					{
 						List<CardWithPremiumStatus> cardsWithPremiumStatus = sideboardMap[text4].GetCardsWithPremiumStatus();
@@ -1784,17 +1772,17 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			return;
 		}
 		using DefLoader.DisposableFullDef disposableFullDef = DefLoader.Get().GetFullDef(cardID);
-		if (!(disposableFullDef?.CardDef == null) && disposableFullDef.EntityDef != null)
-		{
-			m_heroActor.SetCardDef(disposableFullDef.DisposableCardDef);
-			m_heroActor.SetEntityDef(disposableFullDef.EntityDef);
-			disposableFullDef.CardDef.m_AlwaysRenderPremiumPortrait = true;
-			m_heroActor.SetPremium(premium);
-			m_heroActor.UpdateAllComponents();
-			m_heroActor.Show();
-			m_heroClassIconsControllerReference.RegisterReadyListener<Widget>(OnHeroClassIconsControllerReady);
+			if (!(disposableFullDef?.CardDef == null) && disposableFullDef.EntityDef != null)
+			{
+				m_heroActor.SetCardDef(disposableFullDef.DisposableCardDef);
+				m_heroActor.SetEntityDef(disposableFullDef.EntityDef);
+				disposableFullDef.CardDef.m_AlwaysRenderPremiumPortrait = true;
+				m_heroActor.SetPremium(premium);
+				m_heroActor.UpdateAllComponents();
+				m_heroActor.Show();
+				m_heroClassIconsControllerReference.RegisterReadyListener<Widget>(OnHeroClassIconsControllerReady);
+			}
 		}
-	}
 
 	private void SetHeroPower(string cardID)
 	{
@@ -1935,6 +1923,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 
 	private void OnBackButtonPress(UIEvent e)
 	{
+		PvPDungeonRunScene.ReadMenu = true; // go back
 		EnableBackButton(enabled: false);
 		Navigation.GoBack();
 	}
@@ -2247,6 +2236,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			}
 		}
 		GameMgr.Get().FindGameWithHero(m_dungeonCrawlData.GameType, FormatType.FT_WILD, (int)m_dungeonCrawlData.GetMissionToPlay(), 0, heroCardIdToUse, deckid);
+		PvPDungeonRunScene.ReadMenu = false; // todo
 	}
 
 	private void OnShowDeckButtonPress(UIEvent e)
@@ -2356,6 +2346,16 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		{
 			Navigation.PushUnique(OnNavigateBackFromCurrentLoadoutState);
 		}
+		while (!m_playMat.IsStateInitialized())
+		{
+			yield return null;
+		}
+		if (!AccessibilityMgr.IsCurrentlyFocused(this))
+		{
+			AccessibilityMgr.SetScreen(this);
+		}
+		ChooseTreasure();
+		ReadScreen();
 	}
 
 	private IEnumerator ShowHeroPowerOptionsWhenReady()
@@ -2372,6 +2372,11 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		{
 			Navigation.PushUnique(OnNavigateBackFromCurrentLoadoutState);
 		}
+		if (!AccessibilityMgr.IsCurrentlyFocused(this))
+		{
+			AccessibilityMgr.SetScreen(this);
+		}
+		ChooseHeroPower();
 	}
 
 	private IEnumerator ShowDeckOptionsWhenReady()
@@ -2396,6 +2401,11 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		m_currentLoadoutState = DungeonRunLoadoutState.LOADOUTCOMPLETE;
 		m_playMat.ShowPVPDRActiveRun(GetPlayButtonTextForNextMission());
 		m_playMat.PlayButton.SetText(GetPlayButtonTextForNextMission());
+		if (IsDuels())
+		{
+			ReadDuelsMenu();
+		}
+
 		if ((bool)UniversalInputManager.UsePhoneUI)
 		{
 			m_dungeonCrawlDeckSelect.deckTray.SetDungeonCrawlDeck(m_dungeonCrawlDeck, playGlowAnimation: false);
@@ -2404,9 +2414,9 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 				m_dungeonCrawlDeckSelect.heroDetails.UpdateHeroInfo(m_heroActor.GetEntityDef(), cardDef);
 			}
 			using DefLoader.DisposableCardDef cardDef2 = m_heroPowerActor.ShareDisposableCardDef();
-			m_dungeonCrawlDeckSelect.heroDetails.UpdateHeroPowerInfo(m_heroPowerActor.GetEntityDef(), cardDef2);
+				m_dungeonCrawlDeckSelect.heroDetails.UpdateHeroPowerInfo(m_heroPowerActor.GetEntityDef(), cardDef2);
+			}
 		}
-	}
 
 	private void OnBossFullDefLoaded(string cardId, DefLoader.DisposableFullDef def, object userData)
 	{
@@ -2533,8 +2543,8 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 	{
 		GameUtils.SetParent(m_heroPowerBigCard, bone);
 		using DefLoader.DisposableFullDef heroPowerFullDef = DefLoader.Get().GetFullDef(GameUtils.TranslateDbIdToCardId((int)heroPowerDbId));
-		ShowBigCard(m_heroPowerBigCard, heroPowerFullDef, m_HeroPowerBigCardBone);
-	}
+			ShowBigCard(m_heroPowerBigCard, heroPowerFullDef, m_HeroPowerBigCardBone);
+		}
 
 	private void OnHeroPowerOptionRollout(long heroPowerDbId, GameObject bone)
 	{
@@ -2650,6 +2660,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			StartCoroutine(SetPlayMatStateFromGameSaveDataWhenReady());
 		}
 		PlayRewardSelectVO(optionData);
+		IsTreasureRewardChosen = true;
 	}
 
 	private void PlayRewardSelectVO(AdventureDungeonCrawlRewardOption.OptionData optionData)
@@ -2960,6 +2971,7 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 
 	private void OnDeckCreated(long deckID, string name)
 	{
+		//IsDeckBuilt = true; // not needed anymore
 		if (m_seedDeckCreateRequested)
 		{
 			CollectionDeck deck = CollectionManager.Get().GetDeck(deckID);
@@ -3177,6 +3189,9 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		m_BackButton.SetEnabled(enabled: false);
 		m_BackButton.Flip(faceUp: false);
 		Navigation.PushBlockBackingOut();
+
+		AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.DUELS_HEROIC_RUN_ENDED, AccessibleKey.CONFIRM));
+		m_curAccessibleState = AccessibleState.HEROIC_RUN_COMPLETED;
 	}
 
 	public void EndDuelsSession(long noticeId = 0L)
@@ -3260,6 +3275,8 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 			key = "GLUE_PVPDR_END_OF_RUN_TIER_1_WIN";
 		}
 		PvPDungeonRunScene.ShowDuelsMessagePopup(GameStrings.Format("GLUE_PVPDR_END_OF_RUN_HEADER", lastRunWins), GameStrings.Get(key), GameStrings.Format("GLUE_PVPDR_RATING_CHANGE", text), callback);
+
+		ReadDuelsRetireScreen(GameStrings.Format("GLUE_PVPDR_END_OF_RUN_HEADER", lastRunWins), GameStrings.Get(key), GameStrings.Format("GLUE_PVPDR_RATING_CHANGE", text));
 	}
 
 	private void OnSessionEndComplete()
@@ -3269,4 +3286,691 @@ public class AdventureDungeonCrawlDisplay : MonoBehaviour
 		Navigation.PopBlockBackingOut();
 		Navigation.GoBack();
 	}
+
+	#region Accessibility
+
+	private enum AccessibleState { WAITING, IS_VO_PLAYING, READING_DUELS_MENU, READING_PLAY_MENU, READING_DECK, CHOOSING_HERO_POWER, CHOOSING_TREASURE, CHOOSING_LOOT, RUN_COMPLETED, READING_STATS, CHOOSING_TREASURE_REWARD, HEROIC_RUN_COMPLETED};
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleState m_prevAccessibleState;
+
+	private AccessibleState m_stateAfterVO;
+
+	private AccessibleMenu m_accessibleMenu;
+	private AccessibleMenu m_duelsMenu;
+	private AccessibleMultilineText m_accessibleStats;
+	private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleDeckTray;
+	private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleLootTray;
+
+	private AccessibleHorizontalMenu<AccessibleArenaDraftCard> m_AccessibleHeroPower;
+
+	private AccessibleHorizontalMenu<AccessibleArenaDraftCard> m_AccessibleTreasure;
+	private AccessibleHorizontalMenu<AccessibleArenaDraftCard> m_AccessibleTreasureReward;
+	//private AccessibleHorizontalMenu<AccessibleArenaDraftCard> m_AccessibleLoot;
+	private AccessibleMenu m_AccessibleLoot;
+	private AccessibleHorizontalMenu<AccessibleArenaDraftCard> m_AccessibleLootA;
+
+	private AccessibleHorizontalMenu<AccessibleArenaDraftCard> m_AccessibleLootB;
+
+	private AccessibleHorizontalMenu<AccessibleArenaDraftCard> m_AccessibleLootC;
+
+	private AdventureDataDbfRecord m_adventureDataRecord;
+
+	private Boolean IsTreasureRewardChosen;
+	//private static Boolean IsDeckBuilt;
+	private static int LootToRead = 0;
+	private static int readFirstTime;
+	public static Boolean ReadMenu = true;
+
+
+	private void ReadScreen()
+    {
+		var currentId = Enum.GetName(typeof(AdventureDbId), m_dungeonCrawlData.GetSelectedAdventure());
+		AccessibilityUtils.LogDebug($"AdventureDungeonCrawlDisplay.ReadScreen: current adventure is {currentId}");
+		if (!SupportedAdventure() && !SceneMgr.Get().IsInDuelsMode() && !SceneMgr.Get().IsInTavernBrawlMode())
+        {
+			return;
+        }
+
+		AccessibilityMgr.SetScreen(this);
+
+		if (ShouldShowRunCompletedScreen() && !IsDuels()) // üüü
+        {
+			ReadCompletedScreen();
+        }
+		else if (IsDuels()) {
+			if (m_curAccessibleState == AccessibleState.CHOOSING_HERO_POWER)
+			{
+				return;
+			}
+			else if (m_curAccessibleState == AccessibleState.CHOOSING_TREASURE)
+			{
+				return; // don't read the duels menu after choosing
+			}
+			else if (m_curAccessibleState == AccessibleState.CHOOSING_TREASURE_REWARD)
+			{
+				return;
+			}
+			else if (m_curAccessibleState == AccessibleState.CHOOSING_LOOT)
+			{
+				return;
+			}
+			else if (ShouldShowRunCompletedScreen())
+			{
+				PvPDungeonRunScene.IsRetired = true;
+				if (PvPDungeonRunDisplay.Get().GetPVPDRLobbyDataModel().IsPaidEntry)
+				{
+					AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.DUELS_HEROIC_RUN_ENDED, AccessibleKey.CONFIRM));
+				}
+				return;
+			}
+			else if (m_playMat.GetPlayMatState() != AdventureDungeonCrawlPlayMat.PlayMatState.PVPDR_ACTIVE)
+			{
+				return;
+			}
+			else
+			{
+				ReadDuelsMenu(); // todo can we change this default option in order to stop the menu from appearing we we don't need it?
+				//CreateDuelsMenu();
+			}
+		}
+		else
+        {
+            ReadPlayMenu(); // TODO: Figure out a cleanway to delay this until VO plays that doesn't require refactoring playMat..
+        }
+    }
+
+    private void ReadCompletedScreen()
+    {
+		m_curAccessibleState = AccessibleState.RUN_COMPLETED;
+		m_stateAfterVO = AccessibleState.RUN_COMPLETED;
+
+		AccessibilityMgr.Output(this, GetAdventureCompleteSpeech());
+    }
+
+	private string GetAdventureCompleteSpeech()
+    {
+		var text = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_COMPLETE);
+		return AccessibleSpeechUtils.CombineSentences(text, LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_FINISH, AccessibleKey.CONFIRM));
+    }
+
+    private void ReadDuelsRetireScreen(string header, string message, string ratingchange)
+    {
+		m_curAccessibleState = AccessibleState.RUN_COMPLETED;
+		//m_stateAfterVO = AccessibleState.RUN_COMPLETED; // voiceover? n/a
+		AccessibilityMgr.SetScreen(this);
+		var outputmessage1 = AccessibleSpeechUtils.CombineSentences(header, message);
+		var outputmessage2 = AccessibleSpeechUtils.CombineSentences(ratingchange, LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_FINISH, AccessibleKey.CONFIRM));
+		AccessibilityMgr.Output(this, outputmessage1);
+		AccessibilityMgr.Output(this, outputmessage2);
+    }
+
+    private void ReadPlayMenu()
+    {
+		m_curAccessibleState = AccessibleState.READING_PLAY_MENU;
+		m_stateAfterVO = AccessibleState.READING_PLAY_MENU;
+
+		var numDefeatedBosses = m_playMat.m_numBossesDefeated;
+		var numBossesInRun = m_playMat.m_bossesPerRun;
+
+		AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.SCREEN_ADVENTURE_SCREEN_PROGRESS_MESSAGE, numDefeatedBosses + 1, numBossesInRun));
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_TITLE), () => m_BackButton.TriggerRelease());
+
+		m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_PLAY_OPTION), () => m_playMat.ClickPlayButton());
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION), ReadDeck);
+
+        if (m_adventureDataRecord.DungeonCrawlIsRetireSupported)
+        {
+			m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION), () => RetireFromAdventure());
+        }
+
+		m_accessibleMenu.StartReading();
+    }
+
+    private void ReadDeck()
+	{
+		if (m_dungeonCrawlDeckTray == null || m_dungeonCrawlDeckTray.m_deck == null || m_dungeonCrawlDeckTray.m_deck.GetCards().Count == 0)
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CANT_READ_DECK));
+			return;
+		}
+
+		m_prevAccessibleState = m_curAccessibleState; // return to the previous state, e.g. choosing loot
+		m_curAccessibleState = AccessibleState.READING_DECK;
+
+		var cards = m_dungeonCrawlDeck.GetDeckContents();
+
+		var accessibleCards = new List<AccessibleCollectibleCard>(cards.Cards.Count);
+
+		foreach (var card in cards.Cards)
+        {
+			var cardDbId = card.Def.Asset;
+			var cardId = GameUtils.TranslateDbIdToCardId(cardDbId);
+			var cardQty = card.Qty;
+			var entityDef = DefLoader.Get().GetEntityDef(cardId);
+			var cardRecord = GameUtils.GetCardRecord(cardId);
+			var collectibleCard = new CollectibleCard(cardRecord, entityDef, TAG_PREMIUM.NORMAL);
+			collectibleCard.OwnedCount = cardQty;
+			var accessibleCollectibleCard = new AccessibleCollectibleCard(this, collectibleCard, true);
+
+			accessibleCards.Add(accessibleCollectibleCard);
+        }
+
+		m_accessibleDeckTray = new AccessibleListOfItems<AccessibleCollectibleCard>(this, accessibleCards);
+		m_accessibleDeckTray.StartReading();
+    }
+
+    private bool SupportedAdventure()
+    {
+		return m_dungeonCrawlData.GetSelectedAdventure() == AdventureDbId.BOH||m_dungeonCrawlData.GetSelectedAdventure() == AdventureDbId.BOM;
+    }
+
+	private void ChooseHeroPower()
+	{
+		m_AccessibleHeroPower = new AccessibleHorizontalMenu<AccessibleArenaDraftCard>(this, GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_CHOOSE_HERO_POWER"), () => m_BackButton.TriggerRelease());
+		foreach (var HeroPower in m_playMat.m_heroPowerOptions)
+		{
+			m_AccessibleHeroPower.AddOption(new AccessibleArenaDraftCard(this, HeroPower.GetEntityDef()), () => HeroPower.Select());
+		}
+		m_curAccessibleState = AccessibleState.CHOOSING_HERO_POWER;
+		m_AccessibleHeroPower.StartReading();
+	}
+	private void ChooseTreasure()
+	{
+		m_AccessibleTreasure = new AccessibleHorizontalMenu<AccessibleArenaDraftCard>(this, GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_CHOOSE_TREASURE_SATCHEL"), () => m_BackButton.TriggerRelease());
+		foreach (var Treasure in m_playMat.m_treasureSatchelOptions)
+		{
+			m_AccessibleTreasure.AddOption(new AccessibleArenaDraftCard(this, Treasure.GetEntityDef()), () => Treasure.Select());
+		}
+		m_curAccessibleState = AccessibleState.CHOOSING_TREASURE;
+		m_AccessibleTreasure.StartReading();
+		PvPDungeonRunScene.ReadMenu = true; // todo
+	}
+
+	private void ChooseTreasureReward()
+	{
+		m_AccessibleTreasureReward = new AccessibleHorizontalMenu<AccessibleArenaDraftCard>(this, GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_CHOOSE_TREASURE"), () => m_BackButton.TriggerRelease());
+
+		foreach (var TreasureReward in m_playMat.m_rewardOptions)
+		{
+			var TreasureDatabaseID = TreasureReward.GetTreasureDatabaseID();
+			var TreasureOptionEntity = DefLoader.Get().GetEntityDef(TreasureDatabaseID);
+			m_AccessibleTreasureReward.AddOption(new AccessibleArenaDraftCard(this, TreasureOptionEntity), () => TreasureReward.m_chooseButton.TriggerRelease());
+		}
+		m_curAccessibleState = AccessibleState.CHOOSING_TREASURE_REWARD;
+		m_AccessibleTreasureReward.StartReading();
+	}
+
+
+	private void ChooseLoot() // todo-loot List<long> classLootOptionsA, List<long> classLootOptionsB, List<long> classLootOptionsC // äää
+	{
+		readFirstTime = 0;
+		m_curAccessibleState = AccessibleState.CHOOSING_LOOT;
+
+		List<long> LootOptionsA = null;
+		List<long> LootOptionsB = null;
+		List<long> LootOptionsC = null;
+		GameSaveDataManager.Get().GetSubkeyValue(m_gameSaveDataServerKey, GameSaveKeySubkeyId.DUNGEON_CRAWL_LOOT_OPTION_A, out LootOptionsA);
+		GameSaveDataManager.Get().GetSubkeyValue(m_gameSaveDataServerKey, GameSaveKeySubkeyId.DUNGEON_CRAWL_LOOT_OPTION_B, out LootOptionsB);
+		GameSaveDataManager.Get().GetSubkeyValue(m_gameSaveDataServerKey, GameSaveKeySubkeyId.DUNGEON_CRAWL_LOOT_OPTION_C, out LootOptionsC);
+
+		AccessibilityMgr.SetScreen(this);
+		AccessibilityMgr.Output(this, GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_CHOOSE_LOOT"));
+
+		// create 3 loot crates, only read the first when entering the menu
+		for (int i = 0; i < LootOptionsA.Count; i++)
+		{
+			var Item = DefLoader.Get().GetEntityDef((int)LootOptionsA[i]);
+			var ItemID = Item.GetCardId();
+			var ItemTitle = Item.GetName();
+			var TitleString = "1. " + ItemTitle;
+			if (i == 0) {
+				m_AccessibleLootA = new AccessibleHorizontalMenu<AccessibleArenaDraftCard>(this, TitleString, null); //
+			}
+			else {
+				AccessibleArenaDraftCard newCard=new AccessibleArenaDraftCard(null, Item);
+                m_AccessibleLootA.AddOption(newCard,null);
+			}
+		}
+		//m_AccessibleLootA.StartReading();
+
+		for (int i = 0; i < LootOptionsB.Count; i++)
+		{
+			var Item = DefLoader.Get().GetEntityDef((int)LootOptionsB[i]);
+			var ItemID = Item.GetCardId();
+			var ItemTitle = Item.GetName();
+			var TitleString = "2. " + ItemTitle;
+			if (i == 0) {
+				m_AccessibleLootB = new AccessibleHorizontalMenu<AccessibleArenaDraftCard>(this, TitleString, null);
+			}
+			else {
+				AccessibleArenaDraftCard newCard=new AccessibleArenaDraftCard(null, Item);
+                m_AccessibleLootB.AddOption(newCard,null);
+			}
+		}
+		//m_AccessibleLootB.StartReading();
+
+		for (int i = 0; i < LootOptionsC.Count; i++)
+		{
+			var Item = DefLoader.Get().GetEntityDef((int)LootOptionsC[i]);
+			var ItemID = Item.GetCardId();
+			var ItemTitle = Item.GetName();
+			var TitleString = "3. " + ItemTitle;
+			if (i == 0) {
+				m_AccessibleLootC = new AccessibleHorizontalMenu<AccessibleArenaDraftCard>(this, TitleString, null);
+			}
+			else {
+				AccessibleArenaDraftCard newCard=new AccessibleArenaDraftCard(null, Item);
+                m_AccessibleLootC.AddOption(newCard,null);
+			}
+		}
+		//m_AccessibleLootC.StartReading();
+
+	}
+
+
+	private void ReadDuelsMenu()
+	{
+		m_curAccessibleState = AccessibleState.READING_DUELS_MENU;
+
+		try {
+			m_curAccessibleState = AccessibleState.READING_DUELS_MENU;
+			m_duelsMenu = new AccessibleMenu(this, GameStrings.Get("GLUE_PVPDR"), () => m_BackButton.TriggerRelease());
+			m_duelsMenu.AddOption(GameStrings.Get(m_playMat.m_playButton.m_newPlayButtonText.Text), m_playMat.ClickPlayButton);
+			m_duelsMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION), ReadDeck);
+			m_duelsMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_DUELS_READ_STATS), OnReadStats);
+			if (m_adventureDataRecord.DungeonCrawlIsRetireSupported)
+			{
+				m_duelsMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_RETIRE_OPTION), () => RetireFromAdventure());
+			}
+			m_duelsMenu.AddOption(GameStrings.Get("GLOBAL_BACK"), () => m_BackButton.TriggerRelease());
+			m_duelsMenu.StartReading();
+		}
+		catch (Exception e)
+		{
+			AccessibilityUtils.LogFatalError(e);
+		}
+	}
+
+    public void HandleInput()
+    {
+
+		// Wait for VO to finish
+		if (NotificationManager.Get().IsQuotePlaying)
+		{
+			m_curAccessibleState = AccessibleState.IS_VO_PLAYING;
+
+			if (AccessibleKey.SKIP_NOTIFICATION.IsPressed())
+			{
+				NotificationManager.Get().m_quote.clickOff?.TriggerPress();
+			}
+			return;
+		}
+		else if (m_curAccessibleState == AccessibleState.IS_VO_PLAYING)
+		{
+			if (m_stateAfterVO == AccessibleState.RUN_COMPLETED)
+			{
+				ReadCompletedScreen();
+			}
+			else
+			{
+				// Repeat menu
+				ReadPlayMenu();
+			}
+			return;
+		}
+
+		// Normal flow
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+		{
+			m_accessibleMenu.HandleAccessibleInput();
+		}
+		else if (m_curAccessibleState == AccessibleState.READING_DECK)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				if (IsDuels())
+				{
+					if (m_prevAccessibleState == AccessibleState.CHOOSING_TREASURE_REWARD)
+					{
+						ChooseTreasureReward();
+						m_curAccessibleState = AccessibleState.CHOOSING_TREASURE_REWARD;
+
+					}
+					else if (m_prevAccessibleState == AccessibleState.CHOOSING_LOOT)
+					{
+						ChooseLoot();
+						m_curAccessibleState = AccessibleState.CHOOSING_LOOT;
+
+					}
+					else{
+						m_duelsMenu.StartReading();
+						m_curAccessibleState = AccessibleState.READING_DUELS_MENU;
+					}
+				}
+				else {
+					m_accessibleMenu.StartReading();
+					m_curAccessibleState = AccessibleState.READING_PLAY_MENU;
+				}
+			}
+			else
+			{
+				m_accessibleDeckTray.HandleAccessibleInput();
+				var curCardIdx = m_accessibleDeckTray.GetItemBeingReadIndex();
+				var cardTiles = m_dungeonCrawlDeckTray.GetCardsContent().GetCardTiles();
+				AccessibleInputMgr.MoveMouseTo(cardTiles[curCardIdx]);
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.READING_STATS)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadDuelsMenu();
+				m_curAccessibleState = AccessibleState.READING_DUELS_MENU;
+			}
+			else
+			{
+				m_accessibleStats?.HandleAccessibleInput();
+			}
+		}
+		else if (m_playMat.GetPlayMatState() == AdventureDungeonCrawlPlayMat.PlayMatState.TRANSITIONING_FROM_PREV_STATE && IsTreasureRewardChosen == true )
+		{
+			m_curAccessibleState = AccessibleState.READING_DUELS_MENU; // after chosen loot crate read duels menu again -- todo not needed after first treasure -- but it reads main menu?!
+		}
+		else if (m_curAccessibleState == AccessibleState.RUN_COMPLETED)
+		{
+			PvPDungeonRunScene.IsRetired = true; // close the popup when returning to DungeonRun
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				PvPDungeonRunScene.ReadMenu = true; // next run
+				OnSessionEndComplete();
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.HEROIC_RUN_COMPLETED)
+		{
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				var vaultButton = m_playMat.GetDuelsPlayMat().m_leverButton.GetPegUIElement();
+				vaultButton.TriggerPress();
+				vaultButton.TriggerRelease();
+				m_curAccessibleState = AccessibleState.WAITING;
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_HERO_POWER)
+		{
+			m_AccessibleHeroPower.HandleAccessibleInput();
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_TREASURE)
+		{
+			m_AccessibleTreasure.HandleAccessibleInput();
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_TREASURE_REWARD)
+		{
+			if (AccessibleKey.READ_DECK.IsPressed())
+			{
+				ReadDeck();
+				//m_accessibleDeckTray.StartReading(); // don't read first card twice
+				m_curAccessibleState = AccessibleState.READING_DECK;
+			}
+			else
+			{
+				m_AccessibleTreasureReward.HandleAccessibleInput();
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_LOOT)
+		{
+			readFirstTime += 1;
+
+			if (AccessibleKey.READ_LOOT_BACKWARDS.IsPressed())
+			{
+				LootToRead = LootToRead - 1;
+				if (LootToRead < 0)
+				{
+					LootToRead = 2;
+				}
+				readFirstTime = 0;
+			}
+			else if (AccessibleKey.READ_LOOT_FORWARDS.IsPressed())
+			{
+				LootToRead = LootToRead + 1;
+				if (LootToRead > 2)
+				{
+					LootToRead = 0;
+				}
+				readFirstTime = 0;
+			}
+			else if (AccessibleKey.TAKE_LOOT.IsPressed() || AccessibleKey.TAKE_LOOT_ALT.IsPressed())
+			{
+				m_curAccessibleState = AccessibleState.READING_DUELS_MENU;
+				m_playMat.m_rewardOptions[LootToRead].m_chooseButton.TriggerRelease();
+				ReadDuelsMenu(); // read play menu again after choosing treasure
+				LootToRead = 0; // read first loot crate again in next run, not the one we took
+				return;
+			}
+			else if (AccessibleKey.GLOBAL_BACK.IsPressed())
+			{
+				m_BackButton.TriggerRelease();
+			}
+			else if (AccessibleKey.READ_DECK.IsPressed())
+			{
+				ReadDeck();
+				//m_accessibleDeckTray.StartReading(); // don't read the first card twice
+				m_curAccessibleState = AccessibleState.READING_DECK;
+			}
+
+
+			switch (LootToRead)
+			{
+				case 0:
+					if (readFirstTime == 1)
+					{
+						m_AccessibleLootA?.StartReading();
+					}
+					m_AccessibleLootA.HandleAccessibleInput();
+					break;
+				case 1:
+					if (readFirstTime == 1)
+					{
+						m_AccessibleLootB?.StartReading();
+					}
+					m_AccessibleLootB.HandleAccessibleInput();
+					break;
+				case 2:
+					if (readFirstTime == 1)
+					{
+						m_AccessibleLootC?.StartReading();
+					}
+					m_AccessibleLootC.HandleAccessibleInput();
+					break;
+			}
+		}
+		else if (m_playMat.GetPlayMatState() == AdventureDungeonCrawlPlayMat.PlayMatState.PVPDR_ACTIVE)
+		{
+			if (IsDuels())
+			{
+				m_duelsMenu.HandleAccessibleInput();
+			}
+			else {
+				m_accessibleMenu.HandleAccessibleInput();
+			}
+		}
+		else if (m_playMat.GetPlayMatState() == AdventureDungeonCrawlPlayMat.PlayMatState.SHOWING_OPTIONS)
+		{
+			if (IsTreasureRewardChosen == true)
+			{
+				ChooseLoot();
+			}
+			else {
+				ChooseTreasureReward();
+			}
+		}
+    }
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+			return m_accessibleMenu.GetHelp();
+        }
+		else if (m_curAccessibleState == AccessibleState.READING_DUELS_MENU)
+        {
+			return m_duelsMenu.GetHelp();
+        }
+		else if (m_curAccessibleState == AccessibleState.HEROIC_RUN_COMPLETED)
+		{
+			return LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM);
+		}
+
+		if (m_playMat.GetPlayMatState() == AdventureDungeonCrawlPlayMat.PlayMatState.PVPDR_ACTIVE)
+		{
+			if(IsDuels())
+			{
+				return m_duelsMenu.GetHelp();
+			}
+			else {
+				return m_accessibleMenu.GetHelp();
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.RUN_COMPLETED)
+        {
+			return GetAdventureCompleteSpeech();
+        }
+        else if (m_curAccessibleState == AccessibleState.READING_DECK)
+        {
+			var helpText = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_READING_DECK_HELP);
+			return AccessibleSpeechUtils.CombineSentences(helpText, AccessibleSpeech.PRESS_BACK_ONCE_DONE);
+        }
+		else if (m_curAccessibleState == AccessibleState.IS_VO_PLAYING)
+        {
+			return LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_WAITING_FOR_VO_HELP);
+        }
+
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_HERO_POWER)
+		{
+			return LocalizationUtils.Format(LocalizationKey.DUELS_CHOOSE_HERO_POWER_HELP, AccessibleKey.CONFIRM);
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_TREASURE)
+		{
+			return LocalizationUtils.Format(LocalizationKey.DUELS_CHOOSE_STARTER_TREASURE_HELP, AccessibleKey.CONFIRM);
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_TREASURE_REWARD)
+		{
+			return LocalizationUtils.Format(LocalizationKey.DUELS_CHOOSE_TREASURE_REWARD_HELP, AccessibleKey.CONFIRM, AccessibleKey.READ_DECK);
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_LOOT)
+		{
+			return LocalizationUtils.Format(LocalizationKey.DUELS_CHOOSE_LOOT_HELP, AccessibleKey.READ_LOOT_FORWARDS, AccessibleKey.READ_LOOT_BACKWARDS, AccessibleKey.TAKE_LOOT, AccessibleKey.READ_DECK);
+		}
+		else if (m_curAccessibleState == AccessibleState.READING_STATS)
+		{
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+		}
+		return "";
+    }
+
+    public void OnGainedFocus()
+    {
+		if (m_curAccessibleState == AccessibleState.READING_PLAY_MENU)
+        {
+			m_accessibleMenu.StartReading();
+        }
+		else if(m_curAccessibleState == AccessibleState.CHOOSING_HERO_POWER)
+		{
+			m_AccessibleHeroPower.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_TREASURE)
+		{
+			m_AccessibleTreasure.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_TREASURE_REWARD)
+		{
+			m_AccessibleTreasureReward.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_LOOT)
+		{
+			m_AccessibleLoot.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.READING_STATS)
+		{
+			m_accessibleStats.ReadAllLines();
+		}
+		else if (m_curAccessibleState == AccessibleState.READING_DUELS_MENU)
+        {
+			//m_duelsMenu.StartReading();
+			ReadDuelsMenu(); // refresh menu for play button to be updated
+        }
+		else if (m_playMat.GetPlayMatState() == AdventureDungeonCrawlPlayMat.PlayMatState.PVPDR_ACTIVE)
+		{
+			if (IsDuels() && m_curAccessibleState != AccessibleState.RUN_COMPLETED)
+			{
+				m_duelsMenu?.StartReading();
+			}
+			else {
+				m_accessibleMenu?.StartReading();
+			}
+		}
+		else
+        {
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_TITLE));
+        }
+    }
+
+    private void RetireFromAdventure()
+    {
+        m_retireButton.SetActive(value: false);
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo
+        {
+            m_headerText = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_HEADER"),
+            m_text = GameStrings.Get("GLUE_ADVENTURE_DUNGEON_CRAWL_RETIRE_CONFIRMATION_BODY"),
+            m_showAlertIcon = true,
+            m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
+            m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL
+        };
+        if (m_isPVPDR)
+        {
+            popupInfo.m_responseCallback = OnPVPDRRetirePopupResponse;
+        }
+        else
+        {
+            popupInfo.m_responseCallback = OnRetirePopupResponse;
+        }
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+	public Boolean IsDuels()
+	{
+		if (SceneMgr.Get().IsInDuelsMode())
+		{
+			return true;
+		}
+		else {
+			return false;
+		}
+	}
+
+	private void OnReadStats()
+	{
+		PVPDRLobbyDataModel pVPDRLobbyDataModel = PvPDungeonRunDisplay.Get().GetPVPDRLobbyDataModel();
+		TAG_CLASS tagClassFromCardDbId = GameUtils.GetTagClassFromCardDbId((int)m_dungeonCrawlData.SelectedHeroCardDbId);
+
+		var WinsCount = pVPDRLobbyDataModel.Wins;
+		var LossesCount = pVPDRLobbyDataModel.Losses;
+		var LivesLeft = 3 - LossesCount;
+		//var TotalWinsCount = GetBossWinsForClass(tagClassFromCardDbId);
+		var TotalWinsCount = m_bossKillCounter.m_bossWins;
+		var HeroName = DefLoader.Get().GetEntityDef((int)m_dungeonCrawlData.SelectedHeroCardDbId).GetName();
+
+
+		var lines = new List<string>();
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_PVPDR_LABEL_VAULT_WINS"), $"{WinsCount}"));
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(LocalizationUtils.Get(LocalizationKey.SCREEN_DUELS_LOSSES_COUNT), $"{LossesCount}"));
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Format("GLUE_PVPDR_BEST_WINS_AS_CLASS", HeroName), $"{TotalWinsCount}"));
+		m_accessibleStats = new AccessibleMultilineText(this, lines);
+		m_accessibleStats.ReadAllLines();
+		m_curAccessibleState = AccessibleState.READING_STATS;
+
+	}
+
+    #endregion
 }
diff --git a/Assembly-CSharp/AdventureDungeonCrawlHeroPowerOption.cs b/Assembly-CSharp/AdventureDungeonCrawlHeroPowerOption.cs
index 417febc..1c5e053 100644
--- a/Assembly-CSharp/AdventureDungeonCrawlHeroPowerOption.cs
+++ b/Assembly-CSharp/AdventureDungeonCrawlHeroPowerOption.cs
@@ -145,4 +145,10 @@ public class AdventureDungeonCrawlHeroPowerOption : AdventureOptionWidget
 			}
 		}
 	}
+	#region Accessibility
+    internal EntityDef GetEntityDef()
+    {
+        return DefLoader.Get().GetEntityDef((int)m_databaseId);
+    }
+    #endregion
 }
diff --git a/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs b/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
index fedd698..86c0647 100644
--- a/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
+++ b/Assembly-CSharp/AdventureDungeonCrawlPlayMat.cs
@@ -8,6 +8,7 @@ using Hearthstone.DungeonCrawl;
 using Hearthstone.Progression;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AdventureDungeonCrawlPlayMat : MonoBehaviour
@@ -255,9 +256,9 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 
 	private List<GameObject> m_cardBacks = new List<GameObject>();
 
-	private PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
-	private List<AdventureDungeonCrawlRewardOption> m_rewardOptions;
+	internal List<AdventureDungeonCrawlRewardOption> m_rewardOptions;
 
 	private AdventureDungeonCrawlBossGraveyard m_bossGraveyard;
 
@@ -267,9 +268,9 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 
 	private OptionType m_currentOptionType;
 
-	private int m_numBossesDefeated;
+	internal int m_numBossesDefeated;
 
-	private int m_bossesPerRun;
+	internal int m_bossesPerRun;
 
 	private bool m_allowPlayButtonAnimation;
 
@@ -297,7 +298,7 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 
 	private string m_chooseLootHeaderStringOverride;
 
-	private List<AdventureDungeonCrawlTreasureOption> m_treasureSatchelOptions;
+	internal List<AdventureDungeonCrawlTreasureOption> m_treasureSatchelOptions;
 
 	public Widget m_treasureInspectWidget;
 
@@ -667,12 +668,12 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 			{
 				m_topDefeatedBoss = m_defeatedBossActors[m_defeatedBossActors.Count - 1];
 				using DefLoader.DisposableFullDef disposableFullDef = DefLoader.Get().GetFullDef(text);
-				m_topDefeatedBoss.SetEntityDef(disposableFullDef.EntityDef);
-				m_topDefeatedBoss.SetCardDef(disposableFullDef.DisposableCardDef);
-				m_topDefeatedBoss.SetPremium(TAG_PREMIUM.NORMAL);
-				m_topDefeatedBoss.UpdateAllComponents();
+					m_topDefeatedBoss.SetEntityDef(disposableFullDef.EntityDef);
+					m_topDefeatedBoss.SetCardDef(disposableFullDef.DisposableCardDef);
+					m_topDefeatedBoss.SetPremium(TAG_PREMIUM.NORMAL);
+					m_topDefeatedBoss.UpdateAllComponents();
+				}
 			}
-		}
 		TransformUtil.AttachAndPreserveLocalTransform(m_nextBossBone, m_bossCardBones[Mathf.Min(num, m_bossCardBones.Count - 1)]);
 		if (num == 0)
 		{
@@ -1111,10 +1112,13 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 		}
 		if ((!(m_bossHeroPowerTooltip != null) || m_bossHeroPowerTooltip.IsDying()) && m_shouldShowBossHeroPowerTooltip)
 		{
-			m_bossHeroPowerTooltip = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_bossHeroPowerTooltipBone.transform.localPosition, m_bossHeroPowerTooltipBone.transform.localScale, GameStrings.Get(HERO_POWER_TOOLTIP_STRING));
-			m_bossHeroPowerTooltip.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
-			m_bossHeroPowerTooltip.PulseReminderEveryXSeconds(m_bossHeroPowerTooltipPulseRate);
-		}
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+            {
+                m_bossHeroPowerTooltip = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_bossHeroPowerTooltipBone.transform.localPosition, m_bossHeroPowerTooltipBone.transform.localScale, GameStrings.Get(HERO_POWER_TOOLTIP_STRING));
+                m_bossHeroPowerTooltip.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
+                m_bossHeroPowerTooltip.PulseReminderEveryXSeconds(m_bossHeroPowerTooltipPulseRate);
+            }
+        }
 	}
 
 	public void HideBossHeroPowerTooltip(bool immediate = false)
@@ -1889,4 +1893,23 @@ public class AdventureDungeonCrawlPlayMat : MonoBehaviour
 			}
 		}
 	}
+
+    #region Accessibility
+
+    internal void ClickPlayButton()
+    {
+		m_playButton.TriggerRelease();
+    }
+
+	internal bool IsStateInitialized()
+	{
+		return m_playMatStateInitialized;
+	}
+
+	internal DuelsPlayMat GetDuelsPlayMat()
+	{
+		return m_duelsPlayMat;
+	}
+
+    #endregion
 }
diff --git a/Assembly-CSharp/AdventureDungeonCrawlRewardOption.cs b/Assembly-CSharp/AdventureDungeonCrawlRewardOption.cs
index 2dac6db..4a31478 100644
--- a/Assembly-CSharp/AdventureDungeonCrawlRewardOption.cs
+++ b/Assembly-CSharp/AdventureDungeonCrawlRewardOption.cs
@@ -124,6 +124,7 @@ public class AdventureDungeonCrawlRewardOption : MonoBehaviour
 
 	public void SetRewardData(OptionData optionData)
 	{
+		AdventureDungeonCrawlDisplay.ReadMenu = false;
 		m_optionData = optionData;
 		EnableInteraction();
 		if (m_bigCardActor != null)
@@ -459,4 +460,10 @@ public class AdventureDungeonCrawlRewardOption : MonoBehaviour
 		}
 		m_deckTray.SetDungeonCrawlDeck(collectionDeck, playGlowAnimation: false);
 	}
+	#region Accessibility
+    // internal EntityDef GetEntityDef()
+    // {
+    //     return DefLoader.Get().GetEntityDef((int)m_databaseId);
+    // }
+    #endregion
 }
diff --git a/Assembly-CSharp/AdventureDungeonCrawlTreasureOption.cs b/Assembly-CSharp/AdventureDungeonCrawlTreasureOption.cs
index 5c075c8..d186eb3 100644
--- a/Assembly-CSharp/AdventureDungeonCrawlTreasureOption.cs
+++ b/Assembly-CSharp/AdventureDungeonCrawlTreasureOption.cs
@@ -202,4 +202,10 @@ public class AdventureDungeonCrawlTreasureOption : AdventureOptionWidget
 		Rollout();
 		PlaySpells(m_dataModel.IsSelectedOption ? MoteOutSpellsForSelected : MoteOutSpells);
 	}
+	#region Accessibility
+    internal EntityDef GetEntityDef()
+    {
+        return DefLoader.Get().GetEntityDef((int)m_databaseId);
+    }
+    #endregion
 }
diff --git a/Assembly-CSharp/AdventureLocationSelectBook.cs b/Assembly-CSharp/AdventureLocationSelectBook.cs
index ceca9ca..d2beeb1 100644
--- a/Assembly-CSharp/AdventureLocationSelectBook.cs
+++ b/Assembly-CSharp/AdventureLocationSelectBook.cs
@@ -8,6 +8,7 @@ using Hearthstone.Store;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class AdventureLocationSelectBook : MonoBehaviour
@@ -171,6 +172,7 @@ public class AdventureLocationSelectBook : MonoBehaviour
 			return;
 		}
 		Log.Adventures.Print("Book Cover Opening animation now complete!");
+		AccessibilityUtils.LogDebug("book cover opening complete");
 		PageData pageDataForCurrentPage = m_BookPageManager.GetPageDataForCurrentPage();
 		if (pageDataForCurrentPage != null && pageDataForCurrentPage.PageType == AdventureBookPageType.MAP)
 		{
@@ -706,6 +708,7 @@ public class AdventureLocationSelectBook : MonoBehaviour
 		}
 		ScenarioDbId mission = AdventureConfig.Get().GetMission();
 		AdventureBossDef bossDef = AdventureConfig.Get().GetBossDef(mission);
+		AccessibilityUtils.LogDebug("Play button pressed, playing mission "+mission);
 		if (bossDef != null && bossDef.m_IntroLinePlayTime == AdventureBossDef.IntroLinePlayTime.MissionStart)
 		{
 			AdventureUtils.PlayMissionQuote(bossDef, NotificationManager.DEFAULT_CHARACTER_POS);
diff --git a/Assembly-CSharp/AdventureMissionDisplay.cs b/Assembly-CSharp/AdventureMissionDisplay.cs
index 2e6812b..5885d48 100644
--- a/Assembly-CSharp/AdventureMissionDisplay.cs
+++ b/Assembly-CSharp/AdventureMissionDisplay.cs
@@ -6,9 +6,10 @@ using Blizzard.T5.Core;
 using Blizzard.T5.MaterialService.Extensions;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class AdventureMissionDisplay : AdventureSubSceneDisplay
+public class AdventureMissionDisplay : AdventureSubSceneDisplay, AccessibleScreen
 {
 	protected class BossCreateParams
 	{
@@ -171,8 +172,12 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 		AdventureConfig adventureConfig = AdventureConfig.Get();
 		AdventureDbId selectedAdventure = adventureConfig.GetSelectedAdventure();
 		AdventureModeDbId selectedMode = adventureConfig.GetSelectedMode();
+		#region accessibility
+		UnselectBoss(); //to force the menu to display when loaded
+		#endregion
 		string text = GameUtils.GetAdventureDataRecord((int)selectedAdventure, (int)selectedMode).Name;
 		m_AdventureTitle.Text = text;
+		m_wingMenu=new AccessibleMenu(null,text,()=>OnBackButtonPress());
 		List<WingCreateParams> list = BuildWingCreateParamsList();
 		m_WingsToGiveBigChest.Clear();
 		AdventureDef adventureDef = AdventureScene.Get().GetAdventureDef(selectedAdventure);
@@ -197,6 +202,8 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 				GameUtils.SetParent(m_progressDisplay, m_BossWingContainer);
 			}
 		}
+		list.Sort(WingCreateParamsSortComparison);
+		list.Reverse(); // may not always work.
 		foreach (WingCreateParams item2 in list)
 		{
 			WingDbId wingId = item2.m_WingDef.GetWingId();
@@ -224,7 +231,7 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 			});
 			wing.AddShowRewardsListener(delegate(List<RewardData> r, Vector3 o)
 			{
-				m_RewardsDisplay.ShowRewards(r, o);
+				//m_RewardsDisplay.ShowRewards(r, o); // The rewards should appear when you restart the window maybe.
 			});
 			wing.AddHideRewardsListener(delegate
 			{
@@ -236,6 +243,11 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 			{
 				bool flag = AdventureConfig.IsMissionAvailable((int)bossCreateParam.m_MissionId) || item2.m_WingDef.CoinsStartFaceUp;
 				AdventureBossCoin coin = wing.CreateBoss(wingDef.m_CoinPrefab, wingDef.m_RewardsPrefab, bossCreateParam.m_MissionId, flag);
+				ScenarioDbfRecord scenario=GameDbf.Scenario.GetRecord((int)bossCreateParam.m_MissionId);
+				if(scenario.ID==(int)ScenarioDbId.ICC_01_LICHKING) flag=true; // force show the prologue
+											string completion="";
+											if(AdventureProgressMgr.Get().HasDefeatedScenario((int)bossCreateParam.m_MissionId)) completion=", "+LocalizationUtils.Format(LocalizationKey.SCREEN_ADVENTURE_SCREEN_MISSION_COMPLETED);
+							m_wingMenu.AddOption(wingDef.GetWingName()+": "+scenario.Name.GetString()+completion,() => selectWing(coin));
 				AdventureConfig.Get().LoadBossDef(bossCreateParam.m_MissionId, delegate(AdventureBossDef bossDef, bool y)
 				{
 					if (bossDef != null)
@@ -348,11 +360,15 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 			AddAssetToLoad();
 			GameSaveDataManager.Get().Request((GameSaveKeyId)selectedAdventureDataRecord.GameSaveDataServerKey, OnGameSaveDataReceived);
 		}
+		AccessibilityMgr.SetScreen(this);
+		m_accessibleState=AccessibleMissionState.CHOOSE_MISSION;
+		m_wingMenu.StartReading();
 	}
 
 	private void Start()
 	{
 		Navigation.PushUnique(OnNavigateBack);
+		Log.Accessibility.Print("start adventure mission display");
 		AdventureWing adventureWing = null;
 		foreach (AdventureWing bossWing in m_BossWings)
 		{
@@ -572,7 +588,7 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 		return true;
 	}
 
-	private void OnBackButtonPress(UIEvent e)
+	private void OnBackButtonPress(UIEvent e=null)
 	{
 		foreach (AdventureWing bossWing in m_BossWings)
 		{
@@ -647,9 +663,11 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 		if (m_BossInfoCache.TryGetValue(mission, out var value))
 		{
 			m_BossTitle.Text = value.m_Title;
+			AccessibilityMgr.Output(null,value.m_Title);
 			if (m_BossDescription != null)
 			{
 				m_BossDescription.Text = value.m_Description;
+							AccessibilityMgr.Output(null,value.m_Description);
 			}
 		}
 		if (m_BossPortraitDefCache.TryGetValue(mission, out var value2))
@@ -681,6 +699,7 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 		{
 			m_BossPowerContainer.SetActive(value: false);
 		}
+		m_accessibleState=AccessibleMissionState.MISSION_CHOSEN;
 	}
 
 	private void UnselectBoss()
@@ -693,7 +712,7 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 		{
 			m_BossDescription.Text = string.Empty;
 		}
-		m_BossActor.Hide();
+		m_BossActor?.Hide();
 		if (m_BossPowerContainer != null)
 		{
 			m_BossPowerContainer.SetActive(value: false);
@@ -722,7 +741,9 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 		{
 			m_ChooseButton.Disable();
 			DisableSelection(yes: true);
+//			AccessibilityMgr.Output(null,"This mission requires you to build your own deck, which is not currently accessible.");
 			AdventureConfig.Get().ChangeSubScene(AdventureData.Adventuresubscene.MISSION_DECK_PICKER);
+			m_accessibleState=AccessibleMissionState.CHOOSING_DECK;
 			return;
 		}
 		if (m_advMissionDisplayTray != null)
@@ -893,7 +914,7 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 				wingIds.Add((int)item2.GetWingId());
 			}
 		}
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureMissionDisplay.ShowFixedRewards"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureMissionDisplay.ShowFixedRewards"))
 		{
 			m_WaitingForClassChallengeUnlocks = true;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
@@ -1036,6 +1057,7 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 		DisableSelection(yes: true);
 		AdventureDef adventureDef = AdventureScene.Get().GetAdventureDef(selectedAdventure);
 		AdventureSubDef subDef = adventureDef.GetSubDef(selectedMode);
+		AccessibilityMgr.Output(null,"Show adventure complete popup");
 		switch (adventureDef.m_BannerRewardType)
 		{
 		case AdventureDef.BannerRewardType.AdventureCompleteReward:
@@ -1420,4 +1442,40 @@ public class AdventureMissionDisplay : AdventureSubSceneDisplay
 		}
 		return true;
 	}
+	#region accessibility
+	private enum AccessibleMissionState{CHOOSE_MISSION, MISSION_CHOSEN,CHOOSING_DECK};
+	private AccessibleMissionState m_accessibleState;
+private AccessibleMenu m_wingMenu;
+	public void HandleInput() {
+							if(m_accessibleState==AccessibleMissionState.CHOOSE_MISSION) {
+			m_wingMenu.HandleAccessibleInput();
+		}
+				if(m_accessibleState==AccessibleMissionState.CHOOSING_DECK) {
+			Accessibility.AccessibleAdventureScene.Get().HandleInput();
+		}
+if(m_accessibleState==AccessibleMissionState.MISSION_CHOSEN) {
+			if(AccessibleKey.CONFIRM.IsPressed()) {
+				m_ChooseButton.TriggerRelease();
+				UnselectBoss();
+			}
+		}
+	}
+
+	public string GetHelp() {
+									if(m_accessibleState==AccessibleMissionState.CHOOSE_MISSION) {
+			return m_wingMenu.GetHelp();
+		}
+
+		return "There is no help sucker!";
+	}
+
+	public void OnGainedFocus() {
+
+	}
+
+	private void selectWing(AdventureBossCoin c) {
+		c.TriggerRelease();
+		m_ChooseButton.TriggerRelease();
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/AdventureProductPage.cs b/Assembly-CSharp/AdventureProductPage.cs
index daf37aa..0864e86 100644
--- a/Assembly-CSharp/AdventureProductPage.cs
+++ b/Assembly-CSharp/AdventureProductPage.cs
@@ -5,13 +5,13 @@ using UnityEngine;
 
 public class AdventureProductPage : ProductPage
 {
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
 		if (m_container != null)
 		{
 			m_container.OverrideMusic(MusicPlaylistType.Invalid);
 		}
-		base.Open();
+		base.Open(true);
 	}
 
 	protected override void OnProductSet()
@@ -24,10 +24,10 @@ public class AdventureProductPage : ProductPage
 			return;
 		}
 		using AssetHandle<GameObject> assetHandle = ShopUtils.LoadStoreAdventurePrefab((AdventureDbId)rewardItemDataModel.ItemId);
-		StoreAdventureDef storeAdventureDef = (assetHandle ? assetHandle.Asset.GetComponent<StoreAdventureDef>() : null);
-		if (m_container != null)
-		{
-			m_container.OverrideMusic(storeAdventureDef ? storeAdventureDef.GetPlaylist() : MusicPlaylistType.Invalid);
+			StoreAdventureDef storeAdventureDef = (assetHandle ? assetHandle.Asset.GetComponent<StoreAdventureDef>() : null);
+			if (m_container != null)
+			{
+				m_container.OverrideMusic(storeAdventureDef ? storeAdventureDef.GetPlaylist() : MusicPlaylistType.Invalid);
+			}
 		}
 	}
-}
diff --git a/Assembly-CSharp/AdventureScene.cs b/Assembly-CSharp/AdventureScene.cs
index 559f4a5..87a91c5 100644
--- a/Assembly-CSharp/AdventureScene.cs
+++ b/Assembly-CSharp/AdventureScene.cs
@@ -134,6 +134,7 @@ public class AdventureScene : PegasusScene
 		adventureConfig.AddSelectedModeChangeListener(OnSelectedModeChanged);
 		adventureConfig.AddAdventureModeChangeListener(OnAdventureModeChanged);
 		adventureConfig.AddAdventureMissionSetListener(OnAdventureMissionChanged);
+		Accessibility.AccessibleAdventureScene.Get().OnAdventureSceneShown();
 		m_StartupAssetLoads++;
 		SetCurrentTransitionDirection();
 		if (HearthstoneApplication.IsInternal())
@@ -320,11 +321,11 @@ public class AdventureScene : PegasusScene
 					runCallback((string)subSceneDef.m_Prefab, widgetInstance.Widget.gameObject, callbackData);
 				}
 				UpdateAdventureModeMusic();
-				m_isLoading = false;
+				DoneLoading(subscene);
 			});
 			return;
 		}
-		AssetLoader.Get().InstantiatePrefab((string)subSceneDef.m_Prefab, delegate(AssetReference assetRef, GameObject go, object data)
+		AssetLoader.Get().InstantiatePrefab((string)subSceneDef.m_Prefab, delegate (AssetReference assetRef, GameObject go, object data)
 		{
 			SetUpSubSceneParent(go);
 			if (runCallback != null)
@@ -332,10 +333,11 @@ public class AdventureScene : PegasusScene
 				runCallback(assetRef, go, data);
 			}
 			UpdateAdventureModeMusic();
-			m_isLoading = false;
+			DoneLoading(subscene);
 		}, callbackData, AssetLoadingOptions.IgnorePrefabPosition);
 	}
 
+
 	private void OnSubSceneChange(AdventureData.Adventuresubscene newscene, bool forward)
 	{
 		m_transitionIsGoingBack = !forward;
@@ -672,4 +674,12 @@ public class AdventureScene : PegasusScene
 			m_CurrentTransitionDirection = m_TransitionDirection;
 		}
 	}
+
+	#region Accessibility
+	private void DoneLoading(AdventureData.Adventuresubscene subscene)
+	{
+		m_isLoading = false;
+		Accessibility.AccessibleAdventureScene.Get().OnSubSceneLoaded(subscene);
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs b/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
index f673f12..8eff520 100644
--- a/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
+++ b/Assembly-CSharp/AdventureWingFrozenThroneHelper.cs
@@ -348,7 +348,7 @@ public class AdventureWingFrozenThroneHelper : MonoBehaviour
 		{
 			yield return null;
 		}
-		if (UserAttentionManager.CanShowAttentionGrabber("AdventureMissionDisplay.ShowFixedRewards"))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "AdventureMissionDisplay.ShowFixedRewards"))
 		{
 			waitingForNextStep = true;
 			PopupDisplayManager.Get().ShowAnyOutstandingPopups(delegate
diff --git a/Assembly-CSharp/AlertPopup.cs b/Assembly-CSharp/AlertPopup.cs
index 4dcec76..72a79de 100644
--- a/Assembly-CSharp/AlertPopup.cs
+++ b/Assembly-CSharp/AlertPopup.cs
@@ -3,6 +3,7 @@ using System.Collections.Generic;
 using Blizzard.T5.AssetManager;
 using Blizzard.T5.MaterialService.Extensions;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class AlertPopup : DialogBase
@@ -30,7 +31,8 @@ public class AlertPopup : DialogBase
 		OK,
 		CONFIRM,
 		CANCEL,
-		CONFIRM_CANCEL
+		CONFIRM_CANCEL,
+		EOE
 	}
 
 	public delegate void ResponseCallback(Response response, object userData);
@@ -237,6 +239,8 @@ public class AlertPopup : DialogBase
 		DoShowAnimation();
 		bool systemDialogActive = m_popupInfo == null || !m_popupInfo.m_layerToUse.HasValue || m_popupInfo.m_layerToUse.Value == GameLayer.UI || m_popupInfo.m_layerToUse.Value == GameLayer.HighPriorityUI;
 		UniversalInputManager.Get().SetSystemDialogActive(systemDialogActive);
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -307,9 +311,11 @@ public class AlertPopup : DialogBase
 			break;
 		}
 		m_buttonContainer.UpdateSlices();
+
+		ReadPopupOptions();
 	}
 
-	private void UpdateTexts(PopupInfo popupInfo)
+    private void UpdateTexts(PopupInfo popupInfo)
 	{
 		m_alertText.RichText = m_popupInfo.m_richTextEnabled;
 		m_alertText.Alignment = m_popupInfo.m_alertTextAlignment;
@@ -468,4 +474,84 @@ public class AlertPopup : DialogBase
 			m_header.m_container.UpdateSlices();
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private ResponseDisplay m_lastPopupType; // Keep track of the latest popup type to eat any duplicate updates
+
+	private void ReadPopup()
+    {
+		m_lastPopupType = ResponseDisplay.NONE;
+
+        AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_ALERT_POPUP_TITLE), true);
+
+        ReadPopupOptions();
+    }
+
+    private void ReadPopupOptions()
+    {
+		try
+		{
+
+			var accessibleMenu = new AccessibleMenu(this, m_alertText?.Text, null);
+
+			switch (m_popupInfo.m_responseDisplay)
+			{
+				case ResponseDisplay.OK:
+					AddAccessibleOption(accessibleMenu, m_okayButton);
+					break;
+				case ResponseDisplay.CONFIRM:
+					AddAccessibleOption(accessibleMenu, m_confirmButton);
+					break;
+				case ResponseDisplay.CANCEL:
+					AddAccessibleOption(accessibleMenu, m_cancelButton);
+					break;
+				case ResponseDisplay.CONFIRM_CANCEL:
+					AddAccessibleOption(accessibleMenu, m_confirmButton);
+					AddAccessibleOption(accessibleMenu, m_cancelButton);
+					break;
+				default:
+					// ResponseDisplay will come as part of an update
+					m_lastPopupType = ResponseDisplay.NONE;
+					return;
+			}
+
+			if (m_lastPopupType != m_popupInfo.m_responseDisplay)
+			{
+				m_accessibleMenu = accessibleMenu;
+				if (m_header?.m_text?.Text != null)
+				{
+					AccessibilityMgr.Output(this, m_header.m_text.Text);
+				}
+
+				m_accessibleMenu.StartReading();
+			}
+
+			m_lastPopupType = m_popupInfo.m_responseDisplay;
+		}
+		catch (Exception e)
+		{
+			AccessibilityUtils.LogFatalError(e);
+		}
+    }
+
+    private void AddAccessibleOption(AccessibleMenu menu, UIBButton button)
+    {
+        menu.AddOption(button.GetText(), () => button.TriggerRelease());
+    }
+
+    public override void HandleAccessibleInput()
+    {
+		m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return m_accessibleMenu?.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/ArenaStore.cs b/Assembly-CSharp/ArenaStore.cs
index dc46099..509eff4 100644
--- a/Assembly-CSharp/ArenaStore.cs
+++ b/Assembly-CSharp/ArenaStore.cs
@@ -3,6 +3,7 @@ using Blizzard.T5.Services;
 using Hearthstone.Store;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class ArenaStore : Store
 {
@@ -57,7 +58,7 @@ public class ArenaStore : Store
 			Log.Store.PrintDebug("Arena Ticket Product found. PMT ID = {0}, Name = {1}", productInfo.Id, productInfo.Title);
 			return productInfo;
 		}
-		Log.Store.PrintError("Arena Ticket Product not found!");
+			Log.Store.PrintError("Arena Ticket Product not found!");
 		return null;
 	}
 
diff --git a/Assembly-CSharp/ArenaTrayDisplay.cs b/Assembly-CSharp/ArenaTrayDisplay.cs
index ee4fcd1..42bc75b 100644
--- a/Assembly-CSharp/ArenaTrayDisplay.cs
+++ b/Assembly-CSharp/ArenaTrayDisplay.cs
@@ -338,6 +338,9 @@ public class ArenaTrayDisplay : MonoBehaviour
 		{
 			Debug.LogWarning("ArenaTrayDisplay: PegUIElement missing on the Key!");
 		}
+		else {
+			m_TheKeyMesh.GetComponent<PegUIElement>().TriggerPress();
+		}
 	}
 
 	public void AnimateRewards()
diff --git a/Assembly-CSharp/Assembly-CSharp.csproj b/Assembly-CSharp/Assembly-CSharp.csproj
index f0d02de..85151c2 100644
--- a/Assembly-CSharp/Assembly-CSharp.csproj
+++ b/Assembly-CSharp/Assembly-CSharp.csproj
@@ -1,119 +1,124 @@
-<Project Sdk="Microsoft.NET.Sdk">
-  <PropertyGroup>
-    <AssemblyName>Assembly-CSharp</AssemblyName>
-    <GenerateAssemblyInfo>False</GenerateAssemblyInfo>
-    <TargetFramework>net40</TargetFramework>
-  </PropertyGroup>
-  <PropertyGroup>
-    <LangVersion>9.0</LangVersion>
-    <AllowUnsafeBlocks>True</AllowUnsafeBlocks>
-  </PropertyGroup>
-  <PropertyGroup />
-  <ItemGroup />
-  <ItemGroup>
+﻿<Project Sdk="Microsoft.NET.Sdk">
+	<PropertyGroup>
+		<AssemblyName>Assembly-CSharp</AssemblyName>
+		<GenerateAssemblyInfo>False</GenerateAssemblyInfo>
+		<TargetFramework>net472</TargetFramework>
+	</PropertyGroup>
+	<PropertyGroup>
+		<LangVersion>9.0</LangVersion>
+		<AllowUnsafeBlocks>True</AllowUnsafeBlocks>
+	</PropertyGroup>
+	<PropertyGroup />
+	<ItemGroup>
+		<Reference Include="TolkDotNet">
+			<HintPath>..\..\ManagedOverrides\TolkDotNet.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.dll</HintPath>
+			</Reference>
     <Reference Include="Blizzard.T5.Core">
       <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.Core.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.CoreModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.CoreModule.dll</HintPath>
-    </Reference>
+		</Reference>
+		<Reference Include="UnityEngine.CoreModule">
+			<HintPath>..\..\ManagedOverrides\UnityEngine.CoreModule.dll</HintPath>
+		</Reference>
     <Reference Include="Blizzard.Commerce.Wrapper">
       <HintPath>..\Hearthstone_Data\Managed\Blizzard.Commerce.Wrapper.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.IMGUIModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.IMGUIModule.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.PhysicsModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.PhysicsModule.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.UIModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.UIModule.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Core" />
-    <Reference Include="Blizzard.T5.AssetManager">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.AssetManager.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.AssetLoader">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.AssetLoader.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.AnimationModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.AnimationModule.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.ServiceLocator">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.ServiceLocator.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.JobQueue">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.JobQueue.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.UberText.Runtime">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.UberText.Runtime.dll</HintPath>
-    </Reference>
-    <Reference Include="PlayMaker">
-      <HintPath>..\Hearthstone_Data\Managed\PlayMaker.dll</HintPath>
-    </Reference>
-    <Reference Include="blizzard.bgsclient">
-      <HintPath>..\Hearthstone_Data\Managed\blizzard.bgsclient.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.ParticleSystemModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.ParticleSystemModule.dll</HintPath>
-    </Reference>
+		</Reference>
+		<Reference Include="UnityEngine.IMGUIModule">
+			<HintPath>..\..\ManagedOverrides\UnityEngine.IMGUIModule.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.PhysicsModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.PhysicsModule.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.UIModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.UIModule.dll</HintPath>
+		</Reference>
+		<Reference Include="System.Core" />
+		<Reference Include="Blizzard.T5.AssetManager">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.AssetManager.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.AssetLoader">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.AssetLoader.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.AnimationModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.AnimationModule.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.ServiceLocator">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.ServiceLocator.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.JobQueue">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.JobQueue.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.UberText.Runtime">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.UberText.Runtime.dll</HintPath>
+		</Reference>
+		<Reference Include="PlayMaker">
+			<HintPath>..\Hearthstone_Data\Managed\PlayMaker.dll</HintPath>
+		</Reference>
+		<Reference Include="blizzard.bgsclient">
+			<HintPath>..\Hearthstone_Data\Managed\blizzard.bgsclient.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.ParticleSystemModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.ParticleSystemModule.dll</HintPath>
+		</Reference>
     <Reference Include="Blizzard.T5.Game">
       <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.Game.dll</HintPath>
     </Reference>
-    <Reference Include="Blizzard.T5.iTween">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.iTween.dll</HintPath>
-    </Reference>
-    <Reference Include="blizzard.bgssdk">
-      <HintPath>..\Hearthstone_Data\Managed\blizzard.bgssdk.dll</HintPath>
-    </Reference>
+		<Reference Include="Blizzard.T5.iTween">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.iTween.dll</HintPath>
+		</Reference>
+		<Reference Include="blizzard.bgssdk">
+			<HintPath>..\Hearthstone_Data\Managed\blizzard.bgssdk.dll</HintPath>
+		</Reference>
     <Reference Include="UnityEngine.AudioModule">
       <HintPath>..\Hearthstone_Data\Managed\UnityEngine.AudioModule.dll</HintPath>
     </Reference>
-    <Reference Include="Blizzard.T5.UI.Core">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.UI.Core.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.VideoModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.VideoModule.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.Configuration">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.Configuration.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.TextRenderingModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.TextRenderingModule.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.FontService">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.FontService.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.ErrorInterface">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.ErrorInterface.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.GraphicsManagerInterface">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.GraphicsManagerInterface.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.Logging">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.Logging.dll</HintPath>
-    </Reference>
-    <Reference Include="Unity.RenderPipelines.Universal.Runtime">
-      <HintPath>..\Hearthstone_Data\Managed\Unity.RenderPipelines.Universal.Runtime.dll</HintPath>
-    </Reference>
-    <Reference Include="UniTask">
-      <HintPath>..\Hearthstone_Data\Managed\UniTask.dll</HintPath>
-    </Reference>
+		<Reference Include="Blizzard.T5.UI.Core">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.UI.Core.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.VideoModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.VideoModule.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.Configuration">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.Configuration.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.TextRenderingModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.TextRenderingModule.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.FontService">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.FontService.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.ErrorInterface">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.ErrorInterface.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.GraphicsManagerInterface">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.GraphicsManagerInterface.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.Logging">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.Logging.dll</HintPath>
+		</Reference>
+		<Reference Include="Unity.RenderPipelines.Universal.Runtime">
+			<HintPath>..\Hearthstone_Data\Managed\Unity.RenderPipelines.Universal.Runtime.dll</HintPath>
+		</Reference>
+		<Reference Include="UniTask">
+			<HintPath>..\..\ManagedOverrides\UniTask.dll</HintPath>
+		</Reference>
     <Reference Include="Blizzard.T5.Localization">
       <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.Localization.dll</HintPath>
     </Reference>
-    <Reference Include="UnityEngine.InputLegacyModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.InputLegacyModule.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.AssetBundleModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.AssetBundleModule.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.UnityWebRequestModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.UnityWebRequestModule.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.MiniJSON">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.MiniJSON.dll</HintPath>
-    </Reference>
+		<Reference Include="UnityEngine.InputLegacyModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.InputLegacyModule.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.AssetBundleModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.AssetBundleModule.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.UnityWebRequestModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.UnityWebRequestModule.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.MiniJSON">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.MiniJSON.dll</HintPath>
+		</Reference>
     <Reference Include="Unity.Timeline">
       <HintPath>..\Hearthstone_Data\Managed\Unity.Timeline.dll</HintPath>
     </Reference>
@@ -126,43 +131,43 @@
     <Reference Include="Blizzard.Commerce.Model.CSharp">
       <HintPath>..\Hearthstone_Data\Managed\Blizzard.Commerce.Model.CSharp.dll</HintPath>
     </Reference>
-    <Reference Include="com.blizzard.mobile-unity-auth-sdk">
-      <HintPath>..\Hearthstone_Data\Managed\com.blizzard.mobile-unity-auth-sdk.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.Telemetry.StandardProtos.BlizzPbc">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.Telemetry.StandardProtos.BlizzPbc.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.AndroidJNIModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.AndroidJNIModule.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Xml" />
-    <Reference Include="Blizzard.T5.MaterialService">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.MaterialService.dll</HintPath>
-    </Reference>
-    <Reference Include="Unity.ZombieObjectDetector.Runtime">
-      <HintPath>..\Hearthstone_Data\Managed\Unity.ZombieObjectDetector.Runtime.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.GameStringsInterface">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.GameStringsInterface.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.Telemetry.Sdk">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.Telemetry.Sdk.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.Telemetry.Identity">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.Telemetry.Identity.dll</HintPath>
-    </Reference>
+		<Reference Include="com.blizzard.mobile-unity-auth-sdk">
+			<HintPath>..\Hearthstone_Data\Managed\com.blizzard.mobile-unity-auth-sdk.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.Telemetry.StandardProtos.BlizzPbc">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.Telemetry.StandardProtos.BlizzPbc.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.AndroidJNIModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.AndroidJNIModule.dll</HintPath>
+		</Reference>
+		<Reference Include="System.Xml" />
+		<Reference Include="Blizzard.T5.MaterialService">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.MaterialService.dll</HintPath>
+		</Reference>
+		<Reference Include="Unity.ZombieObjectDetector.Runtime">
+			<HintPath>..\Hearthstone_Data\Managed\Unity.ZombieObjectDetector.Runtime.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.GameStringsInterface">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.GameStringsInterface.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.Telemetry.Sdk">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.Telemetry.Sdk.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.Telemetry.Identity">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.Telemetry.Identity.dll</HintPath>
+		</Reference>
     <Reference Include="Blizzard.T5.FXBuilder">
       <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.FXBuilder.dll</HintPath>
     </Reference>
-    <Reference Include="Unity.RenderPipelines.Core.Runtime">
-      <HintPath>..\Hearthstone_Data\Managed\Unity.RenderPipelines.Core.Runtime.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.UI">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.UI.dll</HintPath>
-    </Reference>
-    <Reference Include="Blizzard.T5.PlayMaker.Runtime">
-      <HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.PlayMaker.Runtime.dll</HintPath>
-    </Reference>
+		<Reference Include="Unity.RenderPipelines.Core.Runtime">
+			<HintPath>..\Hearthstone_Data\Managed\Unity.RenderPipelines.Core.Runtime.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.UI">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.UI.dll</HintPath>
+		</Reference>
+		<Reference Include="Blizzard.T5.PlayMaker.Runtime">
+			<HintPath>..\Hearthstone_Data\Managed\Blizzard.T5.PlayMaker.Runtime.dll</HintPath>
+		</Reference>
     <Reference Include="Assembly-CSharp-firstpass">
       <HintPath>..\Hearthstone_Data\Managed\Assembly-CSharp-firstpass.dll</HintPath>
     </Reference>
@@ -172,34 +177,43 @@
     <Reference Include="System.Net.Http">
       <HintPath>..\Hearthstone_Data\Managed\System.Net.Http.dll</HintPath>
     </Reference>
-    <Reference Include="ICSharpCode.SharpZipLib">
-      <HintPath>..\Hearthstone_Data\Managed\ICSharpCode.SharpZipLib.dll</HintPath>
-    </Reference>
-    <Reference Include="Google.Protobuf">
-      <HintPath>..\Hearthstone_Data\Managed\Google.Protobuf.dll</HintPath>
-    </Reference>
+		<Reference Include="ICSharpCode.SharpZipLib">
+			<HintPath>..\Hearthstone_Data\Managed\ICSharpCode.SharpZipLib.dll</HintPath>
+		</Reference>
+		<Reference Include="Google.Protobuf">
+			<HintPath>..\Hearthstone_Data\Managed\Google.Protobuf.dll</HintPath>
+		</Reference>
     <Reference Include="Unity.Mathematics">
       <HintPath>..\Hearthstone_Data\Managed\Unity.Mathematics.dll</HintPath>
     </Reference>
     <Reference Include="Appboy">
       <HintPath>..\Hearthstone_Data\Managed\Appboy.dll</HintPath>
     </Reference>
-    <Reference Include="UnityEngine.JSONSerializeModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.JSONSerializeModule.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Xml.Linq" />
-    <Reference Include="UnityEngine.ImageConversionModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.ImageConversionModule.dll</HintPath>
-    </Reference>
-    <Reference Include="UnityEngine.UnityWebRequestTextureModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.UnityWebRequestTextureModule.dll</HintPath>
-    </Reference>
+		<Reference Include="UnityEngine.JSONSerializeModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.JSONSerializeModule.dll</HintPath>
+		</Reference>
+		<Reference Include="System.Xml.Linq" />
+		<Reference Include="UnityEngine.ImageConversionModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.ImageConversionModule.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.UnityWebRequestTextureModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.UnityWebRequestTextureModule.dll</HintPath>
+		</Reference>
     <Reference Include="QRCoderUnity">
       <HintPath>..\Hearthstone_Data\Managed\QRCoderUnity.dll</HintPath>
     </Reference>
-    <Reference Include="UnityEngine.ScreenCaptureModule">
-      <HintPath>..\Hearthstone_Data\Managed\UnityEngine.ScreenCaptureModule.dll</HintPath>
-    </Reference>
+		<Reference Include="UnityEngine.ScreenCaptureModule">
+			<HintPath>..\Hearthstone_Data\Managed\UnityEngine.ScreenCaptureModule.dll</HintPath>
+		</Reference>
+		<Reference Include="UnityEngine.UnityWebRequestAudioModule">
+			<HintPath>..\..\ManagedOverrides\UnityEngine.UnityWebRequestAudioModule.dll</HintPath>
+		</Reference>
     <Reference Include="System.Net.Http" />
-  </ItemGroup>
-</Project>
\ No newline at end of file
+	<PackageReference Include="Microsoft.Win32.Registry" Version="5.0.0" />
+	<PackageReference Include="System.Memory" Version="4.5.5" />
+<PackageReference Include="System.Runtime" Version="4.3.1" />
+	</ItemGroup>
+	<Target Name="PostBuild" AfterTargets="PostBuildEvent">
+		<Exec Command="xcopy /y &quot;bin\Release\net472\Assembly-CSharp.dll&quot; &quot;..\..\Hearthstone\Hearthstone_Data\Managed\&quot; &amp;&amp; ^&#xD;&#xA;xcopy /y &quot;bin\Release\net472\TolkDotNet.dll&quot; &quot;..\..\Hearthstone\Hearthstone_Data\Managed\&quot; &amp;&amp; ^&#xD;&#xA;xcopy /y &quot;..\..\ManagedOverrides\Tolk.dll&quot; &quot;..\..\Hearthstone\Hearthstone_Data\Managed\&quot; &amp;&amp; ^&#xD;&#xA;xcopy /y &quot;..\..\ManagedOverrides\Accessibility\*&quot; &quot;..\..\Hearthstone\Hearthstone_Data\Managed\Accessibility\*&quot; &amp;&amp; ^&#xD;&#xA;xcopy /y &quot;..\..\Localization\enUS\ACCESSIBILITY.txt&quot; &quot;..\..\Hearthstone\Strings\enUS\&quot; &amp;&amp; ^&#xD;&#xA;xcopy /y &quot;..\..\ManagedOverrides\*&quot; &quot;..\..\Hearthstone\Hearthstone_Data\Managed\*&quot; &amp;&amp; ^&#xD;&#xA;if exist &quot;..\..\Hearthstone\Accessibility\Speeches&quot; (del /s /q &quot;..\..\Hearthstone\Accessibility\Speeches\*&quot;) else (echo &quot;initializing accessibility&quot;) &amp;&amp; ^&#xD;&#xA;xcopy /y /i &quot;..\..\Speeches\*&quot; &quot;..\..\Hearthstone\Accessibility\Speeches\*&quot;" />
+	</Target>
+</Project>
diff --git a/Assembly-CSharp/Assembly-CSharp.sln b/Assembly-CSharp/Assembly-CSharp.sln
new file mode 100644
index 0000000..c169962
--- /dev/null
+++ b/Assembly-CSharp/Assembly-CSharp.sln
@@ -0,0 +1,22 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+VisualStudioVersion = 16.0.31229.75
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Assembly-CSharp", "Assembly-CSharp.csproj", "{079BD5DF-AAE5-4BB9-BC07-8763F4F4D845}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{079BD5DF-AAE5-4BB9-BC07-8763F4F4D845}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{079BD5DF-AAE5-4BB9-BC07-8763F4F4D845}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {1D2A0AA4-C77E-4CD8-A97B-528080E67A89}
+	EndGlobalSection
+EndGlobal
diff --git a/Assembly-CSharp/AssetDownloadDialog.cs b/Assembly-CSharp/AssetDownloadDialog.cs
index 649dcf7..c5625d2 100644
--- a/Assembly-CSharp/AssetDownloadDialog.cs
+++ b/Assembly-CSharp/AssetDownloadDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using Hearthstone.Streaming;
 
-public class AssetDownloadDialog : DialogBase
+public class AssetDownloadDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Assembly-CSharp/AssetLoader.cs b/Assembly-CSharp/AssetLoader.cs
index 36d4b00..1cece6f 100644
--- a/Assembly-CSharp/AssetLoader.cs
+++ b/Assembly-CSharp/AssetLoader.cs
@@ -410,7 +410,7 @@ public class AssetLoader : IAssetLoader, IService, IAssetBundleError
 		if (!gameObject)
 		{
 			string text = GameStrings.Format("GLOBAL_ERROR_ASSET_INCORRECT_DATA", guid);
-			Debug.LogError($"AssetLoader.WaitThenCallGameObjectCallback() - {text} (prefab={obj})");
+			UnityEngine.Debug.LogError($"AssetLoader.WaitThenCallGameObjectCallback() - {text} (prefab={obj})");
 			Error.AddFatal(FatalErrorReason.ASSET_INCORRECT_DATA, text);
 		}
 		return gameObject;
@@ -521,8 +521,8 @@ public class AssetLoader : IAssetLoader, IService, IAssetBundleError
 	public GameObject InstantiatePrefab(AssetReference assetRef, AssetLoadingOptions options)
 	{
 		using AssetHandle<GameObject> prefabAsset = LoadAsset<GameObject>(assetRef, options);
-		return m_prefabInstantiator.InstantiatePrefab(prefabAsset, options);
-	}
+			return m_prefabInstantiator.InstantiatePrefab(prefabAsset, options);
+		}
 
 	public bool InstantiatePrefab(AssetReference assetRef, PrefabCallback<GameObject> callback, object callbackData, AssetLoadingOptions options)
 	{
@@ -539,8 +539,8 @@ public class AssetLoader : IAssetLoader, IService, IAssetBundleError
 	public AssetHandle<GameObject> GetOrInstantiateSharedPrefab(AssetReference assetRef, AssetLoadingOptions options = AssetLoadingOptions.None)
 	{
 		using AssetHandle<GameObject> prefabAsset = LoadAsset<GameObject>(assetRef, options);
-		return m_prefabInstantiator.GetOrInstantiateSharedPrefab(prefabAsset, options);
-	}
+			return m_prefabInstantiator.GetOrInstantiateSharedPrefab(prefabAsset, options);
+		}
 
 	private void OnPrefabLoaded(AssetReference prefabRef, AssetHandle<GameObject> prefabHandle, object callbackData)
 	{
diff --git a/Assembly-CSharp/Assets/AdventureData.cs b/Assembly-CSharp/Assets/AdventureData.cs
index 3728674..b574aac 100644
--- a/Assembly-CSharp/Assets/AdventureData.cs
+++ b/Assembly-CSharp/Assets/AdventureData.cs
@@ -26,7 +26,9 @@ namespace Assets
 			[Description("Bonus_Challenge")]
 			BONUS_CHALLENGE,
 			[Description("Location_Select")]
-			LOCATION_SELECT
+			LOCATION_SELECT,
+			[Description("EOE")]
+			EOE
 		}
 
 		public enum Adventurebooklocation
diff --git a/Assembly-CSharp/Assets/Global.cs b/Assembly-CSharp/Assets/Global.cs
index c82343d..1a7fcc6 100644
--- a/Assembly-CSharp/Assets/Global.cs
+++ b/Assembly-CSharp/Assets/Global.cs
@@ -368,7 +368,8 @@ namespace Assets
 			TUTORIAL,
 			PRESENCE,
 			MISSION,
-			ZILLIAX_DELUXE_3000
+			ZILLIAX_DELUXE_3000,
+			ACCESSIBILITY
 		}
 
 		public enum MercenariesPremium
diff --git a/Assembly-CSharp/Assets/QuestPool.cs b/Assembly-CSharp/Assets/QuestPool.cs
index 19d6d2e..f7ea061 100644
--- a/Assembly-CSharp/Assets/QuestPool.cs
+++ b/Assembly-CSharp/Assets/QuestPool.cs
@@ -14,7 +14,9 @@ namespace Assets
 			[Description("weekly")]
 			WEEKLY,
 			[Description("event")]
-			EVENT
+			EVENT,
+			[Description("eoe")]
+			EOE
 		}
 
 		public enum RewardTrackType
diff --git a/Assembly-CSharp/AttackSpellController.cs b/Assembly-CSharp/AttackSpellController.cs
index e8459e6..a0e0242 100644
--- a/Assembly-CSharp/AttackSpellController.cs
+++ b/Assembly-CSharp/AttackSpellController.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using Blizzard.T5.Game.Spells;
 using UnityEngine;
+using Accessibility;
 
 public class AttackSpellController : SpellController
 {
@@ -43,6 +44,8 @@ public class AttackSpellController : SpellController
 
 	private bool m_repeatProposed;
 
+	private AccessibleAttackSpellController m_accController;
+
 	protected override bool AddPowerSourceAndTargets(PowerTaskList taskList)
 	{
 		m_attackType = taskList.GetAttackType();
@@ -61,6 +64,7 @@ public class AttackSpellController : SpellController
 		{
 			AddTarget(defender.GetCard());
 		}
+		m_accController = new AccessibleAttackSpellController(taskList);
 		return true;
 	}
 
@@ -226,6 +230,7 @@ public class AttackSpellController : SpellController
 
 	protected void LaunchAttack()
 	{
+		m_accController.OnLaunchAttack();
 		Card source = GetSource();
 		Entity entity = source.GetEntity();
 		Card target = GetTarget();
@@ -340,7 +345,7 @@ public class AttackSpellController : SpellController
 		}
 		if (!entity.IsCutsceneEntity())
 		{
-			source.SetDoNotSort(on: false);
+		source.SetDoNotSort(on: false);
 			Zone zone = source.GetZone();
 			if (zone != null)
 			{
@@ -368,8 +373,8 @@ public class AttackSpellController : SpellController
 	{
 		if (m_taskList != null)
 		{
-			GameUtils.DoDamageTasks(m_taskList, sourceCard, targetCard);
-		}
+		GameUtils.DoDamageTasks(m_taskList, sourceCard, targetCard);
+	}
 	}
 
 	private void MoveSourceHeroBack(Card sourceCard)
@@ -448,6 +453,8 @@ public class AttackSpellController : SpellController
 
 	private void OnBattlegroundsFinisherFinished(Spell spell, object favoriteFinisherRecordObject)
 	{
+		m_accController.OnBattlegroundsFinisherFinished();
+
 		if (m_finisherTrackingCoroutine != null)
 		{
 			StopCoroutine(m_finisherTrackingCoroutine);
diff --git a/Assembly-CSharp/BaconCollectionDisplay.cs b/Assembly-CSharp/BaconCollectionDisplay.cs
index 3a0e193..5a8a900 100644
--- a/Assembly-CSharp/BaconCollectionDisplay.cs
+++ b/Assembly-CSharp/BaconCollectionDisplay.cs
@@ -8,6 +8,7 @@ using Hearthstone.Progression;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class BaconCollectionDisplay : CollectibleDisplay
@@ -175,7 +176,7 @@ public class BaconCollectionDisplay : CollectibleDisplay
 
 	protected override void OnDestroy()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
@@ -276,38 +277,40 @@ public class BaconCollectionDisplay : CollectibleDisplay
 				}
 				EntityDef entityDef = DefLoader.Get().GetEntityDef(collectibleCard.CardId);
 				using DefLoader.DisposableCardDef cardDef = DefLoader.Get().GetCardDef(collectibleCard.CardId, collectibleCard.PremiumType);
-				string text = ((m_currentViewMode == CollectionUtils.ViewMode.BATTLEGROUNDS_GUIDE_SKINS) ? "Card_Guide_Skin.prefab:cf2cadaa8c6f7244fb9500edb2046c8b" : "Card_Bacon_Hero_Skin.prefab:7b4af2ee64cfdf24e8ebc8fc817b9761");
-				GameObject gameObject = AssetLoader.Get().InstantiatePrefab(text, AssetLoadingOptions.IgnorePrefabPosition);
-				if (gameObject == null)
-				{
-					Debug.LogError("Unable to load card actor.");
-					continue;
-				}
-				Actor component = gameObject.GetComponent<Actor>();
-				if (component == null)
-				{
-					Debug.LogError("Actor object does not contain Actor component.");
-					continue;
-				}
-				component.SetEntityDef(entityDef);
-				component.SetCardDef(cardDef);
-				component.SetPremium(collectibleCard.PremiumType);
-				component.CreateBannedRibbon();
-				BaconCollectionHeroSkin component2 = gameObject.GetComponent<BaconCollectionHeroSkin>();
-				if (component2 != null)
-				{
-					component2.SetCardStateDisplay(collectibleCard, entityDef, playerHasEarlyAccessHeroes);
-				}
-				BaconCollectionGuideSkin component3 = gameObject.GetComponent<BaconCollectionGuideSkin>();
-				if (component3 != null)
-				{
-					component3.SetCardStateDisplay(collectibleCard);
+					string text = ((m_currentViewMode == CollectionUtils.ViewMode.BATTLEGROUNDS_GUIDE_SKINS) ? "Card_Guide_Skin.prefab:cf2cadaa8c6f7244fb9500edb2046c8b" : "Card_Bacon_Hero_Skin.prefab:7b4af2ee64cfdf24e8ebc8fc817b9761");
+					GameObject gameObject = AssetLoader.Get().InstantiatePrefab(text, AssetLoadingOptions.IgnorePrefabPosition);
+					if (gameObject == null)
+					{
+						Debug.LogError("Unable to load card actor.");
+						continue;
+					}
+					Actor component = gameObject.GetComponent<Actor>();
+					if (component == null)
+					{
+						Debug.LogError("Actor object does not contain Actor component.");
+						continue;
+					}
+					component.SetEntityDef(entityDef);
+					component.SetCardDef(cardDef);
+					component.SetPremium(collectibleCard.PremiumType);
+					component.CreateBannedRibbon();
+					BaconCollectionHeroSkin component2 = gameObject.GetComponent<BaconCollectionHeroSkin>();
+					if (component2 != null)
+					{
+						component2.SetCardStateDisplay(collectibleCard, entityDef, playerHasEarlyAccessHeroes);
+					}
+					BaconCollectionGuideSkin component3 = gameObject.GetComponent<BaconCollectionGuideSkin>();
+					if (component3 != null)
+					{
+						component3.SetCardStateDisplay(collectibleCard);
+					}
+					component.UpdateAllComponents();
+					m_cardActors.Add(new CollectionCardActors(component));
 				}
-				component.UpdateAllComponents();
-				m_cardActors.Add(new CollectionCardActors(component));
-			}
 			callback?.Invoke(m_cardActors, list, callbackData);
 		}
+
+		AccessibleCollectionManager.Get().OnPageChanged(m_pageManager.CurrentPageNum, collectiblesToDisplay, m_cardActors);
 	}
 
 	private bool OnBackOutOfCollectionScreen()
@@ -564,6 +567,8 @@ public class BaconCollectionDisplay : CollectibleDisplay
 			yield return null;
 		}
 		m_isReady = true;
+
+		AccessibleCollectionManager.Get().OnCollectibleDisplayReady();
 	}
 
 	private IEnumerator InitCollectionWhenReady()
diff --git a/Assembly-CSharp/BaconCollectionPageDisplay.cs b/Assembly-CSharp/BaconCollectionPageDisplay.cs
index d1c297b..54eff15 100644
--- a/Assembly-CSharp/BaconCollectionPageDisplay.cs
+++ b/Assembly-CSharp/BaconCollectionPageDisplay.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Hearthstone;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
@@ -208,7 +209,7 @@ public class BaconCollectionPageDisplay : CollectiblePageDisplay
 		return model as BattlegroundsBoardSkinCollectionPageDataModel;
 	}
 
-	private BattlegroundsFinisherCollectionPageDataModel GetOrCreateFinisherCollectionPageDataModel()
+	internal BattlegroundsFinisherCollectionPageDataModel GetOrCreateFinisherCollectionPageDataModel()
 	{
 		if (!m_FinishersWidget.GetDataModel(568, out var model))
 		{
@@ -421,6 +422,11 @@ public class BaconCollectionPageDisplay : CollectiblePageDisplay
 		m_noMatchFoundObject.SetActive(show);
 		string key = "GLUE_COLLECTION_NO_RESULTS";
 		m_noMatchExplanationText.Text = GameStrings.Get(key);
+
+		if (show)
+		{
+			AccessibleCollectionManager.Get().OnShowNoMatchesFound(m_noMatchExplanationText.Text);
+		}
 	}
 
 	public override void SetPageType(FormatType inputFormatType)
@@ -509,23 +515,8 @@ public class BaconCollectionPageDisplay : CollectiblePageDisplay
 			}
 			return;
 		}
-		BattlegroundsFinisherCollectionPageDataModel orCreateFinisherCollectionPageDataModel = GetOrCreateFinisherCollectionPageDataModel();
-		BaconCollectionDisplay baconCollectionDisplay = CollectionManager.Get().GetCollectibleDisplay() as BaconCollectionDisplay;
-		if (baconCollectionDisplay == null)
-		{
-			Log.CollectionManager.PrintError("BaconCollectionPageDisplay.FINISHER_clicked - BaconCollectionDisplay is null!");
-			return;
-		}
-		if (!string.IsNullOrEmpty(battlegroundsFinisherDataModel.DetailsRenderConfig))
-		{
-			baconCollectionDisplay.ShowFinisherDetailsRendered(battlegroundsFinisherDataModel, orCreateFinisherCollectionPageDataModel);
-		}
-		else
-		{
-			TelemetryManager.Client()?.SendCosmeticsRenderingFallback($"BaconCollectionPageDisplay::Finisher[{battlegroundsFinisherDataModel.FinisherDbiId}]");
-			baconCollectionDisplay.ShowFinisherDetailsDisplay(battlegroundsFinisherDataModel, orCreateFinisherCollectionPageDataModel);
-		}
-		MarkFinisherSeen(battlegroundsFinisherDataModel);
+
+		OnFinisherClicked(battlegroundsFinisherDataModel);
 	}
 
 	private void EmoteDisplayEventListener(string eventName)
@@ -756,4 +747,27 @@ public class BaconCollectionPageDisplay : CollectiblePageDisplay
 			CollectiblePageDisplay.SetPageFlavorTextures(header, new UnityEngine.Vector2(x, y));
 		}
 	}
+
+	#region Accessibility
+	internal void OnFinisherClicked(BattlegroundsFinisherDataModel battlegroundsFinisherDataModel)
+	{
+		BattlegroundsFinisherCollectionPageDataModel orCreateFinisherCollectionPageDataModel = GetOrCreateFinisherCollectionPageDataModel();
+		BaconCollectionDisplay baconCollectionDisplay = CollectionManager.Get().GetCollectibleDisplay() as BaconCollectionDisplay;
+		if (baconCollectionDisplay == null)
+		{
+			Log.CollectionManager.PrintError("BaconCollectionPageDisplay.FINISHER_clicked - BaconCollectionDisplay is null!");
+			return;
+		}
+		if (!string.IsNullOrEmpty(battlegroundsFinisherDataModel.DetailsRenderConfig))
+		{
+			baconCollectionDisplay.ShowFinisherDetailsRendered(battlegroundsFinisherDataModel, orCreateFinisherCollectionPageDataModel);
+		}
+		else
+		{
+			TelemetryManager.Client()?.SendCosmeticsRenderingFallback($"BaconCollectionPageDisplay::Finisher[{battlegroundsFinisherDataModel.FinisherDbiId}]");
+			baconCollectionDisplay.ShowFinisherDetailsDisplay(battlegroundsFinisherDataModel, orCreateFinisherCollectionPageDataModel);
+		}
+		MarkFinisherSeen(battlegroundsFinisherDataModel);
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/BaconCollectionPageManager.cs b/Assembly-CSharp/BaconCollectionPageManager.cs
index 9160f90..7693e1f 100644
--- a/Assembly-CSharp/BaconCollectionPageManager.cs
+++ b/Assembly-CSharp/BaconCollectionPageManager.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using Hearthstone;
 using UnityEngine;
 
@@ -697,11 +698,15 @@ public class BaconCollectionPageManager : CollectiblePageManager
 	public void OnFavoriteBattlegroundsHeroSkinChanged(int baseHeroCardId, int battlegroundsHeroSkinId)
 	{
 		PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteHeroSkins(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
+
+		AccessibleCollectionManager.Get().OnFavoriteHeroSkinChanged();
 	}
 
 	public void OnFavoriteBattlegroundsGuideSkinChanged(BattlegroundsGuideSkinId? newFavoriteBattlegroundsGuideSkin)
 	{
 		PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteGuideSkins(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
+
+		AccessibleCollectionManager.Get().OnFavoriteBattlegroundsGuideSkinChanged();
 	}
 
 	public void OnFavoriteBattlegroundsBoardSkinChanged(BattlegroundsBoardSkinId? newFavoriteBattlegroundsBoardSkin)
@@ -716,6 +721,9 @@ public class BaconCollectionPageManager : CollectiblePageManager
 	public void OnFavoriteBattlegroundsFinisherChanged(BattlegroundsFinisherId? newFavoriteBattlegroundsFinisher)
 	{
 		PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteFinisherSkins(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
+
+		AccessibleCollectionManager.Get().OnFavoriteBattlegroundsFinisherChanged();
+
 		if (PartyManager.Get().IsInBattlegroundsParty())
 		{
 			PartyManager.Get().UpdateBattlegroundsStrikeMemberAttribute();
diff --git a/Assembly-CSharp/BaconDisplay.cs b/Assembly-CSharp/BaconDisplay.cs
index f89ed44..4708f2c 100644
--- a/Assembly-CSharp/BaconDisplay.cs
+++ b/Assembly-CSharp/BaconDisplay.cs
@@ -74,7 +74,7 @@ public class BaconDisplay : AbsSceneDisplay
 
 	private Dictionary<int, Widget> m_duosSlotWidgets = new Dictionary<int, Widget>();
 
-	private PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
 	private UIBButton m_statsButton;
 
@@ -152,6 +152,12 @@ public class BaconDisplay : AbsSceneDisplay
 
 	private const string STATS_PANEL_SLIDE_COMPLETE = "CODE_STATS_SLIDE_FINISHED";
 
+	#region Accessibility
+
+	internal UIBButton m_backButton;
+
+	#endregion
+
 	private const string STATS_PANEL_PHONE_SLIDE_COMPLETE = "CODE_STATS_PHONE_SLIDE_FINISHED";
 
 	private static bool m_hasSeenLowMemoryWarningThisSession;
@@ -180,10 +186,10 @@ public class BaconDisplay : AbsSceneDisplay
 		m_luckyDrawButtonReference.RegisterReadyListener<WidgetInstance>(OnLuckyDrawButtonReady);
 		if ((bool)UniversalInputManager.UsePhoneUI)
 		{
-			m_PlayButtonPhoneReference.RegisterReadyListener<VisualController>(OnPlayButtonReady);
-			m_BackButtonPhoneReference.RegisterReadyListener<VisualController>(OnBackButtonReady);
-			m_StatsButtonPhoneReference.RegisterReadyListener<VisualController>(OnStatsButtonReady);
-			m_StatsPagePhoneReference.RegisterReadyListener<VisualController>(OnStatsPagePhoneReady);
+		m_PlayButtonPhoneReference.RegisterReadyListener<VisualController>(OnPlayButtonReady);
+		m_BackButtonPhoneReference.RegisterReadyListener<VisualController>(OnBackButtonReady);
+		m_StatsButtonPhoneReference.RegisterReadyListener<VisualController>(OnStatsButtonReady);
+		m_StatsPagePhoneReference.RegisterReadyListener<VisualController>(OnStatsPagePhoneReady);
 			m_LobbyPhoneReference.RegisterReadyListener<Widget>(OnLobbyReady);
 			m_PartyPhoneReference.RegisterReadyListener<Widget>(OnPartyReady);
 		}
@@ -369,7 +375,9 @@ public class BaconDisplay : AbsSceneDisplay
 			Error.AddDevWarning("UI Error!", "BackButton could not be found! You will not be able to click 'Back'!");
 			return;
 		}
-		buttonVisualController.gameObject.GetComponent<UIBButton>().AddEventListener(UIEventType.RELEASE, BackButtonRelease);
+		m_backButton = buttonVisualController.gameObject.GetComponent<UIBButton>();
+		m_backButton.AddEventListener(UIEventType.RELEASE, BackButtonRelease);
+
 		m_backButtonFinishedLoading = true;
 	}
 
@@ -506,7 +514,7 @@ public class BaconDisplay : AbsSceneDisplay
 			return;
 		}
 		NotificationManager notificationManager = NotificationManager.Get();
-		m_luckyDrawFTUENotification = notificationManager.CreatePopupText(UserAttentionBlocker.NONE, gameObject.transform.position, gameObject.transform.localScale, GameStrings.Get(key));
+			m_luckyDrawFTUENotification = notificationManager.CreatePopupText(UserAttentionBlocker.NONE, gameObject.transform.position, gameObject.transform.localScale, GameStrings.Get(key));
 		m_luckyDrawFTUENotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Up);
 	}
 
@@ -655,26 +663,26 @@ public class BaconDisplay : AbsSceneDisplay
 		}
 		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
 		bool flag = !netObject.Games.BattlegroundsTutorial;
-		PresenceMgr.Get().SetStatus(Global.PresenceStatus.BATTLEGROUNDS_QUEUE);
+			PresenceMgr.Get().SetStatus(Global.PresenceStatus.BATTLEGROUNDS_QUEUE);
 		if (BaconLobbyMgr.Get().GetBattlegroundsGameMode() == "duos" && !netObject.Games.BattlegroundsDuos)
 		{
 			DisplayDuosDisabledMessage();
 			return;
 		}
-		GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.BACON, GameSaveKeySubkeyId.BACON_HAS_SEEN_TUTORIAL, out long value);
-		PartyManager partyManager = PartyManager.Get();
-		if (partyManager.IsInParty() && partyManager.IsInBattlegroundsParty() && partyManager.IsPartyLeader())
-		{
-			partyManager.FindGame();
-		}
-		else if (value == 0L && !flag)
-		{
-			PlayBaconTutorial();
-		}
+			GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.BACON, GameSaveKeySubkeyId.BACON_HAS_SEEN_TUTORIAL, out long value);
+			PartyManager partyManager = PartyManager.Get();
+			if (partyManager.IsInParty() && partyManager.IsInBattlegroundsParty() && partyManager.IsPartyLeader())
+			{
+				partyManager.FindGame();
+			}
+			else if (value == 0L && !flag)
+			{
+				PlayBaconTutorial();
+			}
 		else if (BaconLobbyMgr.Get().GetBattlegroundsGameMode() == "solo")
-		{
-			GameMgr.Get().FindGame(GameType.GT_BATTLEGROUNDS, FormatType.FT_WILD, 3459, 0, 0L, null, null, restoreSavedGameState: false, null, null, 0L);
-		}
+			{
+				GameMgr.Get().FindGame(GameType.GT_BATTLEGROUNDS, FormatType.FT_WILD, 3459, 0, 0L, null, null, restoreSavedGameState: false, null, null, 0L);
+			}
 		else if (BaconLobbyMgr.Get().GetBattlegroundsGameMode() == "duos")
 		{
 			GameMgr.Get().FindGame(GameType.GT_BATTLEGROUNDS_DUO, FormatType.FT_WILD, 5173, 0, 0L, null, null, restoreSavedGameState: false, null, null, 0L);
@@ -764,15 +772,15 @@ public class BaconDisplay : AbsSceneDisplay
 	}
 
 	private void OnLobbyReady(Widget widget)
-	{
-		if (widget == null)
 		{
-			Error.AddDevWarning("UI Error!", "LobbyReference could not be found!");
+			if (widget == null)
+			{
+				Error.AddDevWarning("UI Error!", "LobbyReference could not be found!");
 			return;
-		}
+			}
 		m_lobbyFinishedLoading = true;
 		m_lobbyWidget = widget;
-		widget.RegisterEventListener(BaconDisplayEventListener);
+				widget.RegisterEventListener(BaconDisplayEventListener);
 		UpdateDuosToggleButtonBasedOnPartyInfo();
 	}
 
@@ -878,12 +886,12 @@ public class BaconDisplay : AbsSceneDisplay
 	{
 		if (Shop.Get() != null)
 		{
-			Shop.Get().Close();
+		Shop.Get().Close();
 		}
 		if (DialogManager.Get() != null)
 		{
-			DialogManager.Get().ClearAllImmediately();
-		}
+		DialogManager.Get().ClearAllImmediately();
+	}
 	}
 
 	private void ShowLowMemoryAlertMessage()
@@ -1071,7 +1079,7 @@ public class BaconDisplay : AbsSceneDisplay
 				pastGame.TeammateHeroBuddy = cardDataModel6;
 				pastGame.TeammateHeroBuddyDatabaseID = (int)heroBuddyDatabaseIDList[num];
 				pastGame.TeammateHeroBuddyCost = (int)heroBuddyCostList[num];
-			}
+		}
 			else
 			{
 				pastGame.Hero = cardDataModel;
@@ -1416,10 +1424,10 @@ public class BaconDisplay : AbsSceneDisplay
 			return;
 		}
 		if (!service.HasProductsAvailable())
-		{
-			ShowBattlegroundsStoreEmptyPopup();
+			{
+				ShowBattlegroundsStoreEmptyPopup();
 			return;
-		}
+			}
 		StoreManager.Get().StartGeneralTransaction("battlegrounds", OnStoreBackButtonPressed);
 		Shop shop = Shop.Get();
 		if (shop != null)
@@ -1509,7 +1517,7 @@ public class BaconDisplay : AbsSceneDisplay
 		}
 	}
 
-	private void OpenBattlegroundsCollection()
+	internal void OpenBattlegroundsCollection()
 	{
 		CollectionManager.Get().NotifyOfBoxTransitionStart();
 		SceneMgr.Get().SetNextMode(SceneMgr.Mode.BACON_COLLECTION);
@@ -1716,30 +1724,30 @@ public class BaconDisplay : AbsSceneDisplay
 				text = GameStrings.Get("GLUE_BACON_INCOMPLETE_TEAM");
 			}
 		}
-		m_playButton.SetText(text);
-		int readyPartyMemberCount = PartyManager.Get().GetReadyPartyMemberCount();
-		int currentPartySize = PartyManager.Get().GetCurrentPartySize();
-		string secondaryText = "";
+			m_playButton.SetText(text);
+			int readyPartyMemberCount = PartyManager.Get().GetReadyPartyMemberCount();
+			int currentPartySize = PartyManager.Get().GetCurrentPartySize();
+			string secondaryText = "";
 		string tertiaryText = "";
-		if (PartyManager.Get().IsInBattlegroundsParty() && PartyManager.Get().IsPartyLeader() && !GameMgr.Get().IsFindingGame() && readyPartyMemberCount < currentPartySize)
-		{
-			secondaryText = $"{readyPartyMemberCount}/{currentPartySize}";
-		}
+			if (PartyManager.Get().IsInBattlegroundsParty() && PartyManager.Get().IsPartyLeader() && !GameMgr.Get().IsFindingGame() && readyPartyMemberCount < currentPartySize)
+			{
+				secondaryText = $"{readyPartyMemberCount}/{currentPartySize}";
+			}
 		if (PartyManager.Get().IsInBattlegroundsParty() && PartyManager.Get().IsPartyLeader() && PartyManager.Get().IsPartySizeValidForCurrentGameMode())
 		{
 			tertiaryText = ((currentPartySize > PartyManager.Get().GetBattlegroundsMaxRankedPartySize()) ? GameStrings.Get("GLUE_BACON_PRIVATE_GAME") : GameStrings.Get("GLUE_BACON_RANKED_GAME"));
 		}
-		m_playButton.SetSecondaryText(secondaryText);
+			m_playButton.SetSecondaryText(secondaryText);
 		m_playButton.SetTertiaryText(tertiaryText);
 		if (PartyManager.Get().IsInBattlegroundsParty() && (!PartyManager.Get().IsPartyLeader() || readyPartyMemberCount < currentPartySize || !PartyManager.Get().IsPartySizeValidForCurrentGameMode()))
-		{
-			m_playButton.Disable(keepLabelTextVisible: true);
-		}
-		else
-		{
-			m_playButton.Enable();
+			{
+				m_playButton.Disable(keepLabelTextVisible: true);
+			}
+			else
+			{
+				m_playButton.Enable();
+			}
 		}
-	}
 
 	private void OnStoreStatusChanged(bool isOpen)
 	{
diff --git a/Assembly-CSharp/BaconFinisherCollectionDetails.cs b/Assembly-CSharp/BaconFinisherCollectionDetails.cs
index 1836b03..fdc03c4 100644
--- a/Assembly-CSharp/BaconFinisherCollectionDetails.cs
+++ b/Assembly-CSharp/BaconFinisherCollectionDetails.cs
@@ -2,8 +2,9 @@ using Hearthstone;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
-public class BaconFinisherCollectionDetails : BaconVideoCollectionDetails
+public class BaconFinisherCollectionDetails : BaconVideoCollectionDetails, AccessibleUI
 {
 	[SerializeField]
 	private VisualController m_favoriteButtonController;
@@ -27,6 +28,8 @@ public class BaconFinisherCollectionDetails : BaconVideoCollectionDetails
 	{
 		base.Show();
 		ToggleFavoriteButton();
+
+		ReadMenu();
 	}
 
 	public override void Hide()
@@ -37,19 +40,23 @@ public class BaconFinisherCollectionDetails : BaconVideoCollectionDetails
 		{
 			Captions.OnClose();
 		}
+
+		GetComponent<Widget>()?.TriggerEvent("StopCosmetic");
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void ToggleFavoriteButton()
 	{
 		if (CanToggleFavoriteBattlegroundsStrike(m_dataModel))
-		{
-			EventFunctions.TriggerEvent(m_favoriteButtonController.transform, "ENABLE_FAVORITE_BUTTON", TriggerEventParameters.Standard);
-		}
-		else
-		{
-			EventFunctions.TriggerEvent(m_favoriteButtonController.transform, "DISABLE_FAVORITE_BUTTON", TriggerEventParameters.Standard);
+			{
+				EventFunctions.TriggerEvent(m_favoriteButtonController.transform, "ENABLE_FAVORITE_BUTTON", TriggerEventParameters.Standard);
+			}
+			else
+			{
+				EventFunctions.TriggerEvent(m_favoriteButtonController.transform, "DISABLE_FAVORITE_BUTTON", TriggerEventParameters.Standard);
+			}
 		}
-	}
 
 	private bool CanToggleFavoriteBattlegroundsStrike(BattlegroundsFinisherDataModel dataModel)
 	{
@@ -83,13 +90,16 @@ public class BaconFinisherCollectionDetails : BaconVideoCollectionDetails
 		{
 			BattlegroundsFinisherId battlegroundsFinisherId = BattlegroundsFinisherId.FromTrustedValue(m_dataModel.FinisherDbiId);
 			if (m_dataModel.IsFavorite)
-			{
+		{
 				ClearFavorite(battlegroundsFinisherId);
-			}
-			else
-			{
+		}
+		else
+		{
 				MakeFavorite(battlegroundsFinisherId);
-			}
+		}
+		AccessibleCollectionManager.Get().WaitingForServerResponse();
+		Hide();
+
 		}
 	}
 
@@ -152,4 +162,32 @@ public class BaconFinisherCollectionDetails : BaconVideoCollectionDetails
 			Hide();
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadMenu()
+	{
+		m_accessibleMenu = new AccessibleMenu(this, m_dataModel.DetailsDisplayName, Hide);
+		m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR), () => AccessibilityMgr.Output(this, m_dataModel.Description));
+		if (CanToggleFavoriteBattlegroundsStrike(m_dataModel))
+		{
+			m_accessibleMenu.AddOption(GameStrings.Get("GLUE_COLLECTION_MANAGER_FAVORITE_BUTTON_MULTIPLE"), ToggleFavorite);
+		}
+
+		AccessibilityMgr.ShowUI(this);
+		m_accessibleMenu.StartReading();
+	}
+
+    public void HandleAccessibleInput()
+    {
+        m_accessibleMenu.HandleAccessibleInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+        return m_accessibleMenu.GetHelp();
+    }
+	#endregion
 }
diff --git a/Assembly-CSharp/BaconGuideSkinInfoManager.cs b/Assembly-CSharp/BaconGuideSkinInfoManager.cs
index fd4edcd..0329819 100644
--- a/Assembly-CSharp/BaconGuideSkinInfoManager.cs
+++ b/Assembly-CSharp/BaconGuideSkinInfoManager.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using System.Text;
+using Accessibility;
 using Blizzard.T5.AssetManager;
 using Hearthstone.UI;
 using UnityEngine;
@@ -164,11 +165,14 @@ public class BaconGuideSkinInfoManager : BaconBaseSkinInfoManager
 			if (CollectionManager.Get().OwnsBattlegroundsGuideSkin(skinCardId))
 			{
 				Network.Get().SetBattlegroundsFavoriteGuideSkin(skinId);
+
+				AccessibleCollectionManager.Get().WaitingForServerResponse();
 			}
 		}
 		else
 		{
 			Network.Get().ClearBattlegroundsFavoriteGuideSkin();
+			AccessibleCollectionManager.Get().WaitingForServerResponse();
 		}
 	}
 
diff --git a/Assembly-CSharp/BaconHeroSkinInfoManager.cs b/Assembly-CSharp/BaconHeroSkinInfoManager.cs
index a9bcdc5..40b57f7 100644
--- a/Assembly-CSharp/BaconHeroSkinInfoManager.cs
+++ b/Assembly-CSharp/BaconHeroSkinInfoManager.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using System.Text;
+using Accessibility;
 using Blizzard.T5.AssetManager;
 using Hearthstone.UI;
 using UnityEngine;
@@ -289,11 +290,13 @@ public class BaconHeroSkinInfoManager : BaconBaseSkinInfoManager
 			{
 				Log.CollectionManager.PrintWarning($"BaconHeroSkinInfoManager.ToggleFavoriteSkin() - Could not find BattlegroundsHeroSkinDBFRecord for ID: {cardDbid}");
 				return;
-			}
+		}
 			battlegroundsHeroSkinId = record.ID;
 		}
 		bool flag = BaconHeroSkinUtils.IsBattlegroundsHeroSkinFavorited(m_currentEntityDef);
 		Network.Get().UpdateFavoriteBattlegroundsHeroSkin(baseHeroCardDbid, battlegroundsHeroSkinId, !flag);
+
+		AccessibleCollectionManager.Get().WaitingForServerResponse();
 	}
 
 	protected override bool CanToggleFavorite()
diff --git a/Assembly-CSharp/BaconParty.cs b/Assembly-CSharp/BaconParty.cs
index 28f6ee5..f20f8b3 100644
--- a/Assembly-CSharp/BaconParty.cs
+++ b/Assembly-CSharp/BaconParty.cs
@@ -5,10 +5,11 @@ using Blizzard.GameService.SDK.Client.Integration;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
-public class BaconParty : MonoBehaviour
+public class BaconParty : MonoBehaviour, AccessibleUI
 {
-	private class BaconPartyMemberInfo
+	public class BaconPartyMemberInfo
 	{
 		public Status status;
 
@@ -177,6 +178,8 @@ public class BaconParty : MonoBehaviour
 		BnetPresenceMgr.Get().AddPlayersChangedListener(OnPresenceUpdated);
 		BnetNearbyPlayerMgr.Get().AddChangeListener(OnNearbyPlayersUpdated);
 		SpectatorManager.Get().OnSpectateRejected += OnSpectateRejected;
+
+		GameMgr.Get().RegisterFindGameEvent(OnFindGame);
 		BaconLobbyMgr.Get().AddBattlegroundsGameModeChangedListener(OnBattlegroundsGameModeChanged);
 		StartCoroutine(ReconcileWhenReady());
 	}
@@ -201,6 +204,11 @@ public class BaconParty : MonoBehaviour
 		{
 			SpectatorManager.Get().OnSpectateRejected -= OnSpectateRejected;
 		}
+
+		if (GameMgr.Get() != null)
+		{
+			GameMgr.Get().UnregisterFindGameEvent(OnFindGame);
+		}
 		if (BaconLobbyMgr.Get() != null)
 		{
 			BaconLobbyMgr.Get().RemoveBattlegroundsGameModeChangedListener(OnBattlegroundsGameModeChanged);
@@ -241,6 +249,7 @@ public class BaconParty : MonoBehaviour
 	private void OnPartyChanged(PartyManager.PartyInviteEvent inviteEvent, BnetGameAccountId playerGameAccountId, PartyManager.PartyData data, object userData)
 	{
 		Log.Party.PrintDebug("BaconParty.OnPartyChanged(): Event={0}, gameAccountId={1}", inviteEvent, playerGameAccountId);
+		AccessibleBattlegroundsPartyAnnouncements.AnnounceEvent(inviteEvent, playerGameAccountId, data, userData);
 		switch (inviteEvent)
 		{
 		case PartyManager.PartyInviteEvent.I_SENT_INVITE:
@@ -315,11 +324,11 @@ public class BaconParty : MonoBehaviour
 		{
 			return;
 		}
-		Status readyStatusForPartyMember = GetReadyStatusForPartyMember(playerGameAccountId);
-		if (baconPartyMemberInfo.status != Status.Waiting || readyStatusForPartyMember != Status.NotReady)
-		{
+			Status readyStatusForPartyMember = GetReadyStatusForPartyMember(playerGameAccountId);
+			if (baconPartyMemberInfo.status != Status.Waiting || readyStatusForPartyMember != Status.NotReady)
+			{
 			bool num = readyStatusForPartyMember != baconPartyMemberInfo.status;
-			baconPartyMemberInfo.status = readyStatusForPartyMember;
+				baconPartyMemberInfo.status = readyStatusForPartyMember;
 			if (num && PartyManager.Get().IsPartyLeader())
 			{
 				RefreshVisuals();
@@ -888,8 +897,8 @@ public class BaconParty : MonoBehaviour
 		{
 			if (IsLoadedAndReady())
 			{
-				AddPartyMember(playerGameAccountId, isReady: true);
-			}
+			AddPartyMember(playerGameAccountId, isReady: true);
+		}
 		}
 		else if (num > 0 && num < PartyManager.BATTLEGROUNDS_PARTY_LIMIT)
 		{
@@ -913,7 +922,7 @@ public class BaconParty : MonoBehaviour
 				}
 				m_members[i].transform.Find("BaconPartyMember/Root/Name").gameObject.GetComponent<UberText>().Text = partyMemberName;
 				m_members[i].transform.Find("BaconPartyMember/Root/Divider").gameObject.GetComponent<VisualController>().SetState(((i % 2 == 0 && flag) || i == m_memberInfo.Count - 1) ? "ODD" : "DEFAULT");
-				if (PartyManager.Get().IsPartyLeader() && BattleNet.GetMyGameAccountId() != m_memberInfo[i].playerGameAccountId)
+				if (CanKick(m_memberInfo[i].playerGameAccountId))
 				{
 					m_members[i].TriggerEvent("ShowKickButton");
 				}
@@ -927,6 +936,13 @@ public class BaconParty : MonoBehaviour
 				m_members[i].TriggerEvent("HideKickButton");
 			}
 		}
+
+		UpdateAccessibleMembers();
+	}
+
+	private static bool CanKick(BnetGameAccountId gameAccountId)
+	{
+		return PartyManager.Get().IsPartyLeader() && BattleNet.GetMyGameAccountId() != gameAccountId;
 	}
 
 	public static Status GetReadyStatusForPartyMember(BnetGameAccountId playerGameAccountId)
@@ -1065,4 +1081,126 @@ public class BaconParty : MonoBehaviour
 		int num = ((count % 2 == 1) ? (count + 1) : count);
 		return index < num;
 	}
-}
+
+	#region Accessibility
+
+	private enum AccessibleState
+	{
+		VIEWING_MEMBERS,
+		MEMBER_MENU
+	}
+
+	private AccessibleState m_curState = AccessibleState.VIEWING_MEMBERS;
+
+	private AccessibleListOfItems<AccessibleBattlegroundsPartyMember> m_accessibleMembers;
+
+	private AccessibleMenu m_memberMenu;
+
+	internal void ReadParty()
+	{
+		m_curState = AccessibleState.VIEWING_MEMBERS;
+		AccessibilityMgr.ShowUI(this);
+		if (m_accessibleMembers == null)
+		{
+			m_accessibleMembers = new AccessibleListOfItems<AccessibleBattlegroundsPartyMember>(this, new List<AccessibleBattlegroundsPartyMember>());
+			m_accessibleMembers.SetGoBackAction(OnGoBack);
+		}
+		UpdateAccessibleMembers();
+		m_accessibleMembers.StartReading();
+	}
+
+	private void UpdateAccessibleMembers()
+	{
+		if (m_accessibleMembers == null)
+		{
+			return;
+		}
+		var list = new List<AccessibleBattlegroundsPartyMember>();
+		foreach (var member in m_memberInfo)
+		{
+			if (member.status != Status.Inactive)
+			{
+				list.Add(new AccessibleBattlegroundsPartyMember(this, member));
+			}
+		}
+		m_accessibleMembers.UpdateItems(list, preserveFocus: true);
+	}
+
+	private bool OnFindGame(FindGameEventData evt, object userData)
+	{
+		if (evt.m_state == FindGameState.CLIENT_STARTED)
+		{
+			AccessibilityMgr.HideUI(this);
+		}
+		return false;
+	}
+
+	private void OnGoBack()
+	{
+		if (m_curState == AccessibleState.MEMBER_MENU)
+		{
+			m_curState = AccessibleState.VIEWING_MEMBERS;
+			m_accessibleMembers.StartReading();
+		}
+		else
+		{
+			AccessibilityMgr.HideUI(this);
+		}
+	}
+
+	private void SetupMenuForMember(BaconPartyMemberInfo member)
+	{
+		if (member == null)
+		{
+			return;
+		}
+		m_memberMenu = new AccessibleMenu(this, null, OnGoBack);
+		if (member.status == Status.Spectate)
+		{
+			m_memberMenu.AddOption(GameStrings.Get("GLOBAL_SPECTATE"), () => StartCoroutine(SpectatePlayerWithAnimations(member.playerGameAccountId)));
+		}
+		if (CanKick(member.playerGameAccountId))
+		{
+			m_memberMenu.AddOption(GameStrings.Get("GLOBAL_FRIENDLIST_BATTLEGROUNDS_PARTY_KICK"), () => PartyManager.Get().KickPlayerFromParty(member.playerGameAccountId));
+		}
+		if (m_memberMenu.GetNumItems() > 0)
+		{
+			m_curState = AccessibleState.MEMBER_MENU;
+			m_memberMenu.StartReading();
+		}
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (m_curState == AccessibleState.VIEWING_MEMBERS)
+		{
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				SetupMenuForMember(m_accessibleMembers.GetItemBeingRead().GetMemberInfo());
+			}
+			else
+			{
+				m_accessibleMembers.HandleAccessibleInput();
+			}
+		}
+		else if (m_curState == AccessibleState.MEMBER_MENU)
+		{
+			m_memberMenu.HandleAccessibleInput();
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_curState == AccessibleState.VIEWING_MEMBERS)
+		{
+			return m_accessibleMembers.GetHelp(true);
+		}
+		else if (m_curState == AccessibleState.MEMBER_MENU)
+		{
+			return m_memberMenu.GetHelp();
+		}
+		return "";
+	}
+	#endregion
+	}
+
diff --git a/Assembly-CSharp/BaconScene.cs b/Assembly-CSharp/BaconScene.cs
index ccea649..4a8722e 100644
--- a/Assembly-CSharp/BaconScene.cs
+++ b/Assembly-CSharp/BaconScene.cs
@@ -2,9 +2,11 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 [CustomEditClass]
-public class BaconScene : BasicScene
+public class BaconScene : BasicScene, AccessibleScreen
 {
 	private bool m_ratingInfoReceived;
 
@@ -57,6 +59,169 @@ public class BaconScene : BasicScene
 		{
 			yield return null;
 		}
+
 		yield return base.NotifySceneLoadedWhenReady();
+
+		ReadScreen();
+  }
+
+	#region Accessibility
+
+	private enum State { LOADING, MAIN_MENU, READING_STATS, OPTIONS_MENU }; // TODO: Help, tutorial, full stats maybe
+
+	private State m_curState = State.LOADING;
+
+	private AccessibleMenu m_curMenu;
+
+	private AccessibleMultilineText m_accessibleStats;
+
+	private AccessibleMenu m_optionsMenu;
+
+	private void ReadScreen()
+	{
+		AccessibilityMgr.SetScreen(this);
+
+		m_curMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_BATTLEGROUNDS), OnGoBackToHub);
+		m_curMenu.AddOption(GetBaconDisplay().m_playButton.m_newPlayButtonText.Text, OnClickPlay);
+		if (PartyManager.Get().IsInBattlegroundsParty())
+		{
+			m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_SEE_PARTY), () => BaconParty.Get().ReadParty());
+		}
+		m_curMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_READ_STATS), OnReadStats);
+		m_curMenu.AddOption(GameStrings.Get("GLOBAL_OPTIONS"), OnClickOptions);
+		if (!PartyManager.Get().IsInBattlegroundsParty())
+		{
+			m_curMenu.AddOption(LocalizedText.HUB_MY_COLLECTION_OPTION, GetBaconDisplay().OpenBattlegroundsCollection);
+			m_curMenu.AddOption(GameStrings.Get("GLUE_BACON_INFO_POPUP_PLAY_TUTORIAL"), GetBaconDisplay().PlayBaconTutorial);
+		}
+
+		ReadMainMenu();
+	}
+
+	private void ReadMainMenu()
+	{
+		m_curState = State.MAIN_MENU;
+		m_curMenu.StartReading();
+	}
+
+	private void OnReadStats()
+	{
+		var baconLobbyDataModel = GetBaconDisplay().GetBaconLobbyDataModel();
+
+		var firstPlaceCount = baconLobbyDataModel.FirstPlaceFinishes;
+		var top4Count = baconLobbyDataModel.Top4Finishes;
+		var rating = baconLobbyDataModel.Rating;
+
+		var lines = new List<string>();
+
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_BACON_FIRST_PLACE_LABEL"), $"{firstPlaceCount}"));
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_BACON_TOP_4_LABEL"), $"{top4Count}"));
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_BACON_RATING_LABEL"), $"{rating}"));
+
+		m_accessibleStats = new AccessibleMultilineText(this, lines);
+		m_accessibleStats.ReadAllLines();
+		m_curState = State.READING_STATS;
+	}
+
+	private void OnClickOptions()
+	{
+		m_optionsMenu = new AccessibleMenu(this, "", ReadMainMenu);
+        m_optionsMenu.AddOption(LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_CHECKBOX_LABEL, LocalizationUtils.Get(LocalizationKey.SCREEN_BATTLEGROUNDS_OPTIONS_NARRATE_ATTACKS)), OnToggleNarrateAttacks);
+
+		m_curState = State.OPTIONS_MENU;
+		m_optionsMenu.StartReading();
+	}
+
+	private void OnToggleNarrateAttacks()
+	{
+		var state = AccessibleGameplayUtils.ToggleBattlegroundsAttackPhaseNarration();
+
+		if (state)
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_CHECKED));
+		}
+		else
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_CHECKBOX_NOT_CHECKED));
+		}
 	}
+
+	private void OnClickPlay()
+	{
+		var btn=GetBaconDisplay().m_playButton;
+		if(!btn.enabled) {
+			AccessibilityMgr.Output(this,btn.m_playButtonSecondaryText.Text);
+			return;
+		}
+		btn.TriggerRelease();
+	}
+
+	private void OnGoBackToHub()
+	{
+		GetBaconDisplay().m_backButton.TriggerRelease();
+	}
+
+	public void HandleInput()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_curMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.OPTIONS_MENU)
+		{
+			m_optionsMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_STATS)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadMainMenu();
+			}
+			else
+			{
+				m_accessibleStats?.HandleAccessibleInput();
+			}
+		}
+	}
+
+	public string GetHelp()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			return m_curMenu?.GetHelp();
+		}
+		else if (m_curState == State.OPTIONS_MENU)
+		{
+			return m_optionsMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_STATS)
+		{
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+		}
+
+		return "";
+	}
+
+	public void OnGainedFocus()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_curMenu?.StartReading();
+		}
+		else if (m_curState == State.OPTIONS_MENU)
+		{
+			m_optionsMenu?.StartReading();
+		}
+		else if (m_curState == State.READING_STATS)
+		{
+			m_accessibleStats.ReadAllLines();
+		}
+	}
+
+	private BaconDisplay GetBaconDisplay()
+	{
+		return (BaconDisplay) m_sceneDisplay;
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/BaconTwoScoop.cs b/Assembly-CSharp/BaconTwoScoop.cs
index ba09abd..f9cc7d4 100644
--- a/Assembly-CSharp/BaconTwoScoop.cs
+++ b/Assembly-CSharp/BaconTwoScoop.cs
@@ -1,5 +1,7 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
+using System;
 
 public class BaconTwoScoop : VictoryTwoScoop
 {
@@ -45,6 +47,12 @@ public class BaconTwoScoop : VictoryTwoScoop
 
 	private int m_ratingChange;
 
+	#region Accessibility
+
+	private bool m_ratingChangeDisabled;
+
+	#endregion
+
 	protected override void ShowImpl()
 	{
 		StartCoroutine(ShowWhenReady());
@@ -75,7 +83,7 @@ public class BaconTwoScoop : VictoryTwoScoop
 		bool ratingChangeDisabled = GameMgr.Get().IsFriendlyBattlegrounds() || GameMgr.Get().IsAI();
 		if (GameState.Get().GetBooleanGameOption(GameEntityOption.WAIT_FOR_RATING_INFO))
 		{
-			while (baconGameEntity != null && baconGameEntity.RatingChangeData == null && !ratingChangeDisabled && m_waitForRatingTimeoutTimer < 5f)
+			while (baconGameEntity != null && baconGameEntity.RatingChangeData == null && !m_ratingChangeDisabled && m_waitForRatingTimeoutTimer < 5f)
 			{
 				m_waitForRatingTimeoutTimer += Time.unscaledDeltaTime;
 				yield return null;
@@ -121,8 +129,8 @@ public class BaconTwoScoop : VictoryTwoScoop
 			.GetRealTimePlayerLeaderboardPlace();
 		if (GameMgr.Get().IsBattlegroundDuoGame())
 		{
-			if (realTimePlayerLeaderboardPlace <= 1)
-			{
+		if (realTimePlayerLeaderboardPlace <= 1)
+		{
 				m_Top1DuoVisual.SetActive(value: true);
 				SoundManager.Get().Play(m_Top1Sound);
 			}
@@ -152,6 +160,8 @@ public class BaconTwoScoop : VictoryTwoScoop
 			m_Bottom4Visual.SetActive(value: true);
 			SoundManager.Get().Play(m_Bottom4Sound);
 		}
+
+		ReadPlace();
 	}
 
 	private IEnumerator PlayRatingChangeAnimation()
@@ -179,6 +189,12 @@ public class BaconTwoScoop : VictoryTwoScoop
 			yield return null;
 		}
 		m_RatingText.Text = m_newRating.ToString();
+
+		// e.g. friendly BGs don't influence rating
+		if (!m_ratingChangeDisabled)
+		{
+			ReadRatingChange(m_ratingChange, m_newRating);
+		}
 	}
 
 	private void SetupTeammateHeroActor()
@@ -194,4 +210,36 @@ public class BaconTwoScoop : VictoryTwoScoop
 			m_teammateHeroActor.TurnOffCollider();
 		}
 	}
+
+	#region Accessibility
+
+	private void ReadPlace()
+	{
+		AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), m_bannerLabel.Text);
+	}
+
+	private void ReadRatingChange(int ratingChange, int newRating)
+	{
+		// Actual change
+		if (ratingChange > 0)
+		{
+			AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_RATING_CHANGE_INCREASED, ratingChange));
+		}
+		else if (ratingChange < 0)
+		{
+			AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_RATING_CHANGE_DECREASED, ratingChange));
+		}
+
+		// New (or old) rating
+		if (ratingChange == 0)
+		{
+			AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_RATING_NO_CHANGE, newRating));
+		}
+		else
+		{
+			AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), LocalizationUtils.Format(LocalizationKey.UI_BATTLEGROUNDS_RATING_CHANGE_NEW_RATING, newRating));
+		}
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/Banner.cs b/Assembly-CSharp/Banner.cs
index 27512b9..5cb2dfe 100644
--- a/Assembly-CSharp/Banner.cs
+++ b/Assembly-CSharp/Banner.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using Blizzard.T5.Core.Utils;
 using UnityEngine;
+using Accessibility;
 
 public class Banner : MonoBehaviour
 {
@@ -263,8 +264,8 @@ public class Banner : MonoBehaviour
 		{
 			return;
 		}
-		AssetReference assetRef = ActorNames.GetNameWithPremiumType(ActorNames.ACTOR_ASSET.BIG_CARD_BG_ANOMALY, TAG_PREMIUM.NORMAL);
-		AssetLoader.Get().InstantiatePrefab(assetRef, OnHandBGAnomalyActorLoaded, anomalyDBID, AssetLoadingOptions.IgnorePrefabPosition);
+			AssetReference assetRef = ActorNames.GetNameWithPremiumType(ActorNames.ACTOR_ASSET.BIG_CARD_BG_ANOMALY, TAG_PREMIUM.NORMAL);
+			AssetLoader.Get().InstantiatePrefab(assetRef, OnHandBGAnomalyActorLoaded, anomalyDBID, AssetLoadingOptions.IgnorePrefabPosition);
 		m_pendingLoadingAnomalyCards++;
 		using (DefLoader.DisposableFullDef disposableFullDef = DefLoader.Get().GetFullDef(anomalyDBID))
 		{
@@ -282,11 +283,11 @@ public class Banner : MonoBehaviour
 				}
 			}
 		}
-		AssetReference assetRef2 = ActorNames.GetNameWithPremiumType(ActorNames.ACTOR_ASSET.PLAY_BATTLEGROUND_ANOMALY, TAG_PREMIUM.NORMAL);
-		AssetLoader.Get().InstantiatePrefab(assetRef2, OnPlayBGAnomalyActorLoaded, anomalyDBID, AssetLoadingOptions.IgnorePrefabPosition);
+			AssetReference assetRef2 = ActorNames.GetNameWithPremiumType(ActorNames.ACTOR_ASSET.PLAY_BATTLEGROUND_ANOMALY, TAG_PREMIUM.NORMAL);
+			AssetLoader.Get().InstantiatePrefab(assetRef2, OnPlayBGAnomalyActorLoaded, anomalyDBID, AssetLoadingOptions.IgnorePrefabPosition);
 		m_pendingLoadingAnomalyCards++;
-		m_initializedBGAnomalies = true;
-	}
+			m_initializedBGAnomalies = true;
+		}
 
 	private void OnHandBGAnomalyActorLoaded(AssetReference assetRef, GameObject go, object callbackData)
 	{
@@ -422,5 +423,7 @@ public class Banner : MonoBehaviour
 			yield return null;
 		}
 		m_medallionHearthstoneAnomaly.SetAnimating(isAnimating: false);
+
+		AccessibleGameplay.Get().ReadAnomalies(true);
 	}
 }
diff --git a/Assembly-CSharp/BannerPopup.cs b/Assembly-CSharp/BannerPopup.cs
index 0c2aa7b..9743962 100644
--- a/Assembly-CSharp/BannerPopup.cs
+++ b/Assembly-CSharp/BannerPopup.cs
@@ -1,8 +1,9 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class BannerPopup : MonoBehaviour
+public class BannerPopup : MonoBehaviour, AccessibleUI
 {
 	public GameObject m_root;
 
@@ -58,6 +59,8 @@ public class BannerPopup : MonoBehaviour
 				m_onCloseBannerPopup();
 			}
 		}
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	public void Show(string headerText, string bannerText, BannerManager.DelOnCloseBanner onCloseCallback = null)
@@ -92,6 +95,8 @@ public class BannerPopup : MonoBehaviour
 			m_dismissButton.AddEventListener(UIEventType.RELEASE, CloseBannerPopup);
 		}
 		m_showSpellComplete = false;
+
+		ReadPopup();
 	}
 
 	private void FadeEffectsIn()
@@ -182,4 +187,46 @@ public class BannerPopup : MonoBehaviour
 			m_HideSpell.Activate();
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+
+		if (m_header != null && m_header.Text != null)
+		{
+			AccessibilityMgr.Output(this, GameStrings.Format(m_header.Text));
+		}
+
+		if (m_text != null && m_text.Text != null)
+		{
+			AccessibilityMgr.Output(this, GameStrings.Format(m_text.Text));
+		}
+
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			if (m_dismissButton != null)
+            {
+                m_dismissButton?.TriggerRelease();
+            }
+			else
+            {
+				AccessibleInputMgr.ClickCenterOfScreen();
+            }
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+        return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/BaseHeroSkinInfoManager.cs b/Assembly-CSharp/BaseHeroSkinInfoManager.cs
index d37f0bd..65b9f94 100644
--- a/Assembly-CSharp/BaseHeroSkinInfoManager.cs
+++ b/Assembly-CSharp/BaseHeroSkinInfoManager.cs
@@ -7,9 +7,10 @@ using Hearthstone.DataModels;
 using Hearthstone.Store;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
+public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore, AccessibleUI
 {
 	protected const string STATE_SHOW_VANILLA_HERO = "SHOW_VANILLA_HERO";
 
@@ -219,7 +220,7 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 		{
 			if (m_currentHeroDef.m_collectionManagerPreviewEmote != 0)
 			{
-				GameUtils.LoadCardDefEmoteSound(cardVisual.GetActor().EmoteDefs, m_currentHeroDef.m_collectionManagerPreviewEmote, delegate(CardSoundSpell cardSpell)
+				GameUtils.LoadCardDefEmoteSound(cardVisual.GetActor().EmoteDefs, m_currentHeroDef.m_collectionManagerPreviewEmote, delegate (CardSoundSpell cardSpell)
 				{
 					m_previewEmoteCardSoundSpell = cardSpell;
 					if (cardSpell != null)
@@ -341,10 +342,13 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 		ScreenEffectParameters blurVignetteDesaturatePerspective = ScreenEffectParameters.BlurVignetteDesaturatePerspective;
 		blurVignetteDesaturatePerspective.Time = m_animationTime;
 		m_screenEffectsHandle.StartEffect(blurVignetteDesaturatePerspective);
+
+		ReadHeroSkinPreview();
 	}
 
 	public virtual void CancelPreview()
 	{
+		HideThis();
 		RemoveNavigateBack();
 		if (!m_animating && m_hasEnteredHeroSkinPreview)
 		{
@@ -430,7 +434,7 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 	protected void UpdateFavoriteButton()
 	{
 		bool flag = CanToggleFavorite();
-		UIBButton uIBButton = ((m_desiredVisibilityState == "SHOW_VANILLA_HERO") ? m_vanillaHeroFavoriteButton : m_newHeroFavoriteButton);
+		UIBButton uIBButton = GetDesiredFavoriteButton();
 		if (uIBButton.IsEnabled() != flag)
 		{
 			uIBButton.SetEnabled(flag);
@@ -457,6 +461,7 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 			PriceDataModel collectionManagerHeroSkinPriceDataModel = HeroSkinUtils.GetCollectionManagerHeroSkinPriceDataModel(m_currentEntityDef.GetCardId());
 			if (collectionManagerHeroSkinPriceDataModel != null)
 			{
+
 				if (collectionManagerHeroSkinPriceDataModel.Currency != 0 && collectionManagerHeroSkinPriceDataModel.Currency != CurrencyType.REAL_MONEY)
 				{
 					m_activeHeroCardCurrencyTypes.Add(collectionManagerHeroSkinPriceDataModel.Currency);
@@ -483,7 +488,7 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 		}
 		BnetBar.Get()?.RefreshCurrency();
 		UpdateFavoriteButton();
-		UIBButton obj = ((m_desiredVisibilityState == "SHOW_VANILLA_HERO") ? m_vanillaHeroBuyButton : m_newHeroBuyButton);
+		UIBButton obj = GetDesiredBuyButton();
 		obj.SetEnabled(flag);
 		obj.Flip(faceUp: true);
 	}
@@ -672,8 +677,8 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 	{
 		if (MusicManager.Get() != null && m_prevPlaylist != 0)
 		{
-			MusicManager.Get().StartPlaylist(m_prevPlaylist);
-		}
+		MusicManager.Get().StartPlaylist(m_prevPlaylist);
+	}
 	}
 
 	private void BlockInputs(bool blocked)
@@ -853,4 +858,77 @@ public abstract class BaseHeroSkinInfoManager : MonoBehaviour, IStore
 		m_activeHeroCardCurrencyTypes.Add(CurrencyType.GOLD);
 		return m_activeHeroCardCurrencyTypes;
 	}
+
+	#region Accessibility
+
+	protected AccessibleMenu m_accessibleMenu;
+
+	protected UIBButton GetDesiredFavoriteButton()
+	{
+		return ((m_desiredVisibilityState == "SHOW_VANILLA_HERO") ? m_vanillaHeroFavoriteButton : m_newHeroFavoriteButton);
+	}
+
+	protected UIBButton GetDesiredBuyButton()
+	{
+		return (m_desiredVisibilityState == "SHOW_VANILLA_HERO") ? m_vanillaHeroBuyButton : m_newHeroBuyButton;
+	}
+
+	protected virtual void ReadHeroSkinPreview()
+	{
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleMenu = new AccessibleMenu(this, m_currentEntityDef.GetName(), CancelPreview);
+		m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR), () => AccessibilityMgr.Output(this, m_currentHeroRecord.Description));
+
+		AddFavoriteAndBuyButtons(m_accessibleMenu);
+
+		m_accessibleMenu.StartReading();
+	}
+
+	protected void AddFavoriteAndBuyButtons(AccessibleMenu menu)
+	{
+		// The logic around favorite and buy buttons is pretty tangled so there's no great way of doing this. This is covered by tests anyways so should be fine
+		if (CanToggleFavorite())
+		{
+			AddButton(menu, GetDesiredFavoriteButton());
+		}
+
+		var buyBtn = GetDesiredBuyButton();
+
+		if (m_userActionVisualController.State == INSUFFICIENT_CURRENCY_STATE)
+		{
+			menu.AddOption(FormatBuyMessage(buyBtn), () => AccessibilityMgr.Output(this, GameStrings.Get("GAMEPLAY_PlayErrors_REQ_ENOUGH_COIN")));
+		}
+		else if (m_userActionVisualController.State == SUFFICIENT_CURRENCY_STATE)
+		{
+			menu.AddOption(FormatBuyMessage(buyBtn), buyBtn.TriggerRelease);
+		}
+	}
+
+	protected string FormatBuyMessage(UIBButton btn)
+	{
+		return LocalizationUtils.Format(LocalizationKey.UI_SHOP_ITEM_BUY_FOR_N_GOLD, btn.GetText());
+	}
+
+	protected void AddButton(AccessibleMenu menu, UIBButton btn)
+	{
+		menu.AddOption(btn.GetText(), btn.TriggerRelease);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public string GetAccessibleHelp()
+	{
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	protected virtual void HideThis()
+	{
+		AccessibilityMgr.HideUI(this);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/BaseUI.cs b/Assembly-CSharp/BaseUI.cs
index a970347..c714217 100644
--- a/Assembly-CSharp/BaseUI.cs
+++ b/Assembly-CSharp/BaseUI.cs
@@ -3,6 +3,7 @@ using System.Collections;
 using System.IO;
 using Blizzard.T5.Services;
 using UnityEngine;
+using Accessibility;
 
 public class BaseUI : MonoBehaviour
 {
@@ -171,7 +172,11 @@ public class BaseUI : MonoBehaviour
 		if ((InputCollection.GetKey(KeyCode.LeftControl) || InputCollection.GetKey(KeyCode.RightControl) || InputCollection.GetKey(KeyCode.LeftMeta) || InputCollection.GetKey(KeyCode.RightMeta)) && (InputCollection.GetKey(KeyCode.LeftShift) || InputCollection.GetKey(KeyCode.RightShift)) && InputCollection.GetKeyDown(KeyCode.S) && Options.Get() != null)
 		{
 			bool @bool = Options.Get().GetBool(Option.STREAMER_MODE);
-			Options.Get().SetBool(Option.STREAMER_MODE, !@bool);
+			var streamerModeOn = !@bool;
+			Options.Get().SetBool(Option.STREAMER_MODE, streamerModeOn);
+
+			var key = streamerModeOn ? LocalizationKey.GLOBAL_STREAMER_MODE_ON : LocalizationKey.GLOBAL_STREAMER_MODE_OFF;
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Get(key));
 		}
 		if (InputCollection.GetKeyUp(KeyCode.Print) || InputCollection.GetKeyUp(KeyCode.SysReq) || InputCollection.GetKeyUp(KeyCode.F13))
 		{
diff --git a/Assembly-CSharp/BasicPopup.cs b/Assembly-CSharp/BasicPopup.cs
index 8a8d3a7..94aabdd 100644
--- a/Assembly-CSharp/BasicPopup.cs
+++ b/Assembly-CSharp/BasicPopup.cs
@@ -1,3 +1,5 @@
+using Accessibility;
+using System;
 using System.Collections.Generic;
 using UnityEngine;
 
@@ -27,6 +29,13 @@ public class BasicPopup : DialogBase
 		public bool m_disableBnetBar;
 
 		public bool m_blurWhenShown;
+
+		public string m_accessibleText;
+
+		public PopupInfo(string accessibleText)
+        {
+			m_accessibleText = accessibleText;
+        }
 	}
 
 	public UIBButton m_cancelButton;
@@ -45,6 +54,10 @@ public class BasicPopup : DialogBase
 
 	protected PopupInfo m_popupInfo;
 
+	#region Accessibility
+	private string m_accessibleText;
+	#endregion
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -101,6 +114,8 @@ public class BasicPopup : DialogBase
 		{
 			SoundManager.Get().LoadAndPlay(m_showAnimationSound);
 		}
+
+		ReadBasicPopup();
 	}
 
 	public override void Hide()
@@ -126,7 +141,7 @@ public class BasicPopup : DialogBase
 	{
 		if (m_popupInfo == null)
 		{
-			m_popupInfo = new PopupInfo();
+			m_popupInfo = new PopupInfo(LocalizationUtils.Get(LocalizationKey.UI_UNKNOWN_POPUP));
 		}
 		if (m_headerText != null && m_popupInfo.m_headerText != null)
 		{
@@ -136,6 +151,8 @@ public class BasicPopup : DialogBase
 		{
 			m_bodyText.Text = m_popupInfo.m_bodyText;
 		}
+
+		m_accessibleText = m_popupInfo.m_accessibleText;
 	}
 
 	private void ButtonPress(Response response)
@@ -146,4 +163,41 @@ public class BasicPopup : DialogBase
 		}
 		Hide();
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    protected void ReadBasicPopup()
+    {
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null, true);
+
+		if (m_customButton != null)
+        {
+			m_accessibleMenu.AddOption(m_customButton.GetText(), () => m_customButton.TriggerRelease());
+        }
+
+		if (m_cancelButton != null)
+        {
+			m_accessibleMenu.AddOption(m_cancelButton.GetText(), () => m_cancelButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, m_accessibleText);
+
+		m_accessibleMenu.StartReading();
+    }
+
+	public override void HandleAccessibleInput()
+    {
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return m_accessibleMenu?.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/BattlegroundsInviteDialog.cs b/Assembly-CSharp/BattlegroundsInviteDialog.cs
index 2abeeef..f32ca02 100644
--- a/Assembly-CSharp/BattlegroundsInviteDialog.cs
+++ b/Assembly-CSharp/BattlegroundsInviteDialog.cs
@@ -1,5 +1,6 @@
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(Widget))]
 public class BattlegroundsInviteDialog : DialogBase
@@ -65,6 +66,8 @@ public class BattlegroundsInviteDialog : DialogBase
 		UniversalInputManager.Get().SetSystemDialogActive(active: true);
 		SoundManager.Get().LoadAndPlay("friendly_challenge.prefab:649e070117bcd0d45bac691a03bf2dec");
 		DialogBase.DoBlur();
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -73,4 +76,32 @@ public class BattlegroundsInviteDialog : DialogBase
 		SoundManager.Get().LoadAndPlay("banner_shrink.prefab:d9de7386a7f2017429d126e972232123");
 		DialogBase.EndBlur();
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadPopup()
+	{
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, $"{GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_BODY_BACON")} {m_challengerName.Text}");
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null);
+		m_accessibleMenu.AddOption(m_acceptButton.GetText(), m_acceptButton.TriggerRelease);
+		m_accessibleMenu.AddOption(m_denyButton.GetText(), m_denyButton.TriggerRelease);
+		m_accessibleMenu.StartReading();
+	}
+
+	public override void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public override string GetAccessibleHelp()
+	{
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/BattlegroundsSuggestDialog.cs b/Assembly-CSharp/BattlegroundsSuggestDialog.cs
index 222659a..a435f8b 100644
--- a/Assembly-CSharp/BattlegroundsSuggestDialog.cs
+++ b/Assembly-CSharp/BattlegroundsSuggestDialog.cs
@@ -1,6 +1,7 @@
 using Blizzard.GameService.SDK.Client.Integration;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(Widget))]
 public class BattlegroundsSuggestDialog : DialogBase
@@ -110,6 +111,8 @@ public class BattlegroundsSuggestDialog : DialogBase
 		UniversalInputManager.Get().SetSystemDialogActive(active: true);
 		SoundManager.Get().LoadAndPlay("friendly_challenge.prefab:649e070117bcd0d45bac691a03bf2dec");
 		DialogBase.DoBlur();
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -118,4 +121,32 @@ public class BattlegroundsSuggestDialog : DialogBase
 		SoundManager.Get().LoadAndPlay("banner_shrink.prefab:d9de7386a7f2017429d126e972232123");
 		DialogBase.EndBlur();
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadPopup()
+	{
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, $"{m_suggestionText.Text} {m_playerToInviteName.Text}");
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null);
+		m_accessibleMenu.AddOption(m_acceptButton.GetText(), m_acceptButton.TriggerRelease);
+		m_accessibleMenu.AddOption(m_denyButton.GetText(), m_denyButton.TriggerRelease);
+		m_accessibleMenu.StartReading();
+	}
+
+	public override void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public override string GetAccessibleHelp()
+	{
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/BenchmarkRunner.cs b/Assembly-CSharp/BenchmarkRunner.cs
index e9c787a..57ee742 100644
--- a/Assembly-CSharp/BenchmarkRunner.cs
+++ b/Assembly-CSharp/BenchmarkRunner.cs
@@ -16,9 +16,6 @@ public class BenchmarkRunner
 
 	private bool m_benchmarkRun;
 
-	[CompilerGenerated]
-	private BenchmarkSpec <BenchmarkSpec>k__BackingField = BenchmarkSpec.Low;
-
 	public int AverageFrameMSResult { get; set; }
 
 	public bool Valid => AverageFrameMSResult != 0;
diff --git a/Assembly-CSharp/BigCard.cs b/Assembly-CSharp/BigCard.cs
index 799a352..d2ce574 100644
--- a/Assembly-CSharp/BigCard.cs
+++ b/Assembly-CSharp/BigCard.cs
@@ -111,7 +111,7 @@ public class BigCard : MonoBehaviour
 
 	private readonly PlatformDependentValue<float> PLATFORM_SCALING_FACTOR;
 
-	private EnchantmentBanner m_enchantmentBanner;
+	internal EnchantmentBanner m_enchantmentBanner;
 
 	private Actor m_extraBigCardActor;
 
@@ -277,18 +277,18 @@ public class BigCard : MonoBehaviour
 		if (CanUseBonesForBigCardPlacement())
 		{
 			try
-			{
-				DisplayBigCardWithBones();
+		{
+			DisplayBigCardWithBones();
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				LogUncaughtBigCardException(e);
 				return;
 			}
 		}
-		LogDisplayBigCardError();
-	}
+			LogDisplayBigCardError();
+		}
 
 	private void LogUncaughtBigCardException(Exception e)
 	{
@@ -338,25 +338,25 @@ public class BigCard : MonoBehaviour
 			return;
 		}
 		using DefLoader.DisposableFullDef disposableFullDef = DefLoader.Get().GetFullDef(num);
-		string evolvingActorPrefab = GetEvolvingActorPrefab(disposableFullDef);
-		GameObject gameObject2 = AssetLoader.Get().InstantiatePrefab(evolvingActorPrefab, AssetLoadingOptions.IgnorePrefabPosition);
-		m_extraBigCardActor = gameObject2.GetComponent<Actor>();
-		SetupActor(m_card, m_extraBigCardActor);
-		m_extraBigCardActor.SetEntity(null);
-		m_extraBigCardActor.transform.parent = m_bigCardActor.transform;
-		m_extraBigCardActor.transform.localScale = Vector3.one;
-		GameObject gameObject3 = GameObjectUtils.FindChildBySubstring(gameObject2, "EvolutionVFX");
-		if (gameObject3 != null)
-		{
-			gameObject3.SetActive(value: true);
-		}
-		m_extraBigCardActor.SetFullDef(disposableFullDef);
-		m_extraBigCardActor.SetPremium(m_card.GetEntity().GetPremiumType());
-		m_extraBigCardActor.SetCardBackSideOverride(m_card.GetEntity().GetControllerSide());
-		m_extraBigCardActor.SetWatermarkCardSetOverride(m_card.GetEntity().GetWatermarkCardSetOverride());
-		m_extraBigCardActor.UpdateAllComponents();
-		ActivateBigCardStateSpells(m_card.GetEntity(), m_extraBigCardActor, m_extraBigCardActor, disposableFullDef?.EntityDef);
-	}
+			string evolvingActorPrefab = GetEvolvingActorPrefab(disposableFullDef);
+			GameObject gameObject2 = AssetLoader.Get().InstantiatePrefab(evolvingActorPrefab, AssetLoadingOptions.IgnorePrefabPosition);
+			m_extraBigCardActor = gameObject2.GetComponent<Actor>();
+			SetupActor(m_card, m_extraBigCardActor);
+			m_extraBigCardActor.SetEntity(null);
+			m_extraBigCardActor.transform.parent = m_bigCardActor.transform;
+			m_extraBigCardActor.transform.localScale = Vector3.one;
+			GameObject gameObject3 = GameObjectUtils.FindChildBySubstring(gameObject2, "EvolutionVFX");
+			if (gameObject3 != null)
+			{
+				gameObject3.SetActive(value: true);
+			}
+			m_extraBigCardActor.SetFullDef(disposableFullDef);
+			m_extraBigCardActor.SetPremium(m_card.GetEntity().GetPremiumType());
+			m_extraBigCardActor.SetCardBackSideOverride(m_card.GetEntity().GetControllerSide());
+			m_extraBigCardActor.SetWatermarkCardSetOverride(m_card.GetEntity().GetWatermarkCardSetOverride());
+			m_extraBigCardActor.UpdateAllComponents();
+			ActivateBigCardStateSpells(m_card.GetEntity(), m_extraBigCardActor, m_extraBigCardActor, disposableFullDef?.EntityDef);
+		}
 
 	private string GetEvolvingActorPrefab(DefLoader.DisposableFullDef evolvingCardDef)
 	{
@@ -416,9 +416,9 @@ public class BigCard : MonoBehaviour
 		{
 			BigCardDisplayBones componentInChildren = actor.GetComponentInChildren<BigCardDisplayBones>();
 			if (componentInChildren == null)
-			{
-				return false;
-			}
+		{
+			return false;
+		}
 			if (!componentInChildren.HasBonesForCurrentPlatform())
 			{
 				return false;
@@ -503,7 +503,7 @@ public class BigCard : MonoBehaviour
 	}
 
 	private BigCardDisplay_RelativeBoardPosition GetBoardPositionOfPlayZoneCard()
-	{
+		{
 		if (m_card.GetZone() is ZonePlay && !m_card.GetEntity().IsLocation() && !m_card.GetEntity().IsMinion() && !m_card.GetEntity().IsBaconSpell())
 		{
 			return BigCardDisplay_RelativeBoardPosition.IRRELEVANT;
@@ -556,7 +556,7 @@ public class BigCard : MonoBehaviour
 			if (entity.IsMinion())
 			{
 				result = platformScale.m_BigCardScale_Minion;
-			}
+		}
 			else if (entity.IsLettuceAbility())
 			{
 				result = platformScale.m_BigCardScale_LettuceAbility;
@@ -710,25 +710,25 @@ public class BigCard : MonoBehaviour
 		{
 			return;
 		}
-		GameObject bone;
-		GameObject bone2;
-		switch (GetBoardPositionOfSourceCard())
-		{
-		case BigCardDisplay_RelativeBoardPosition.LEFT:
-			bone = component.m_InnerRightBone;
-			bone2 = component.m_OuterRightBone;
+			GameObject bone;
+			GameObject bone2;
+			switch (GetBoardPositionOfSourceCard())
+			{
+			case BigCardDisplay_RelativeBoardPosition.LEFT:
+				bone = component.m_InnerRightBone;
+				bone2 = component.m_OuterRightBone;
 			tooltipBoneSource = TooltipPanelManager.TooltipBoneSource.TOP_LEFT;
-			break;
-		case BigCardDisplay_RelativeBoardPosition.RIGHT:
-			bone = component.m_InnerLeftBone;
-			bone2 = component.m_OuterLeftBone;
+				break;
+			case BigCardDisplay_RelativeBoardPosition.RIGHT:
+				bone = component.m_InnerLeftBone;
+				bone2 = component.m_OuterLeftBone;
 			tooltipBoneSource = TooltipPanelManager.TooltipBoneSource.TOP_RIGHT;
-			break;
-		case BigCardDisplay_RelativeBoardPosition.MIDDLE:
-			bone = component.m_InnerLeftBone;
-			bone2 = component.m_InnerRightBone;
+				break;
+			case BigCardDisplay_RelativeBoardPosition.MIDDLE:
+				bone = component.m_InnerLeftBone;
+				bone2 = component.m_InnerRightBone;
 			tooltipBoneSource = TooltipPanelManager.TooltipBoneSource.TOP_LEFT;
-			break;
+				break;
 		case BigCardDisplay_RelativeBoardPosition.IRRELEVANT:
 			if (m_card.GetEntity().IsWeapon())
 			{
@@ -753,38 +753,38 @@ public class BigCard : MonoBehaviour
 			}
 			Log.Gameplay.PrintError($"Unknown card type ({m_card.GetEntity().GetCardType()}) used in {MethodBase.GetCurrentMethod().Name} while trying to display big cards.");
 			return;
-		default:
-			Log.Gameplay.PrintError("Unknown value for BigCardDisplay_RelativeBoardPosition.");
-			return;
-		}
+			default:
+				Log.Gameplay.PrintError("Unknown value for BigCardDisplay_RelativeBoardPosition.");
+				return;
+			}
 		CheckIfTooltipSideShouldBeFlipped(ref tooltipBoneSource);
-		Transform parent = rig.transform.parent;
-		Vector3 localScale = rig.transform.localScale;
-		rig.transform.parent = null;
-		rig.transform.localScale = Vector3.one;
+			Transform parent = rig.transform.parent;
+			Vector3 localScale = rig.transform.localScale;
+			rig.transform.parent = null;
+			rig.transform.localScale = Vector3.one;
 		Zone zone = m_card.GetZone();
 		bool flag = zone is ZonePlay || zone is ZoneSecret || zone is ZoneTeammatePlay;
 		bool flag2 = GameMgr.Get().IsBattlegrounds() || flag;
 		Zone zone2 = m_bigCardActor.GetCard().GetZone();
-		if (m_bigCardActor != null)
-		{
+			if (m_bigCardActor != null)
+			{
 			float scaleForCard = GetScaleForCard(scale, m_bigCardActor.GetCard(), queryForSelf: true);
 			Vector3 scale2 = Vector3.one * scaleForCard;
 			BigCardBones_ScaleAndPlaceBigCard(m_bigCardActor, zone2, scale2, bone, flag);
 			if (flag)
 			{
-				BigCardBones_UpdateEnchantmentBanner(scale.m_EnchantmentBannerScale * scaleForCard);
+			BigCardBones_UpdateEnchantmentBanner(scale.m_EnchantmentBannerScale * scaleForCard);
 			}
 		}
 		if (m_extraBigCardActor != null && flag2)
-		{
+			{
 			float scaleForCard2 = GetScaleForCard(scale, m_extraBigCardActor.GetCard(), queryForSelf: false);
 			Vector3 scale3 = Vector3.one * scaleForCard2;
 			BigCardBones_ScaleAndPlaceBigCard(m_extraBigCardActor, zone2, scale3, bone2, flag);
+			}
+			rig.transform.localScale = localScale;
+			rig.transform.parent = parent;
 		}
-		rig.transform.localScale = localScale;
-		rig.transform.parent = parent;
-	}
 
 	private void CheckIfTooltipSideShouldBeFlipped(ref TooltipPanelManager.TooltipBoneSource boneSource)
 	{
@@ -1096,9 +1096,9 @@ public class BigCard : MonoBehaviour
 				bigCardActor.ActivateSpellBirthState(SpellType.COIN_MANA_GEM_BACON_SPELL);
 			}
 			else
-			{
-				bigCardActor.ActivateSpellBirthState(SpellType.COIN_MANA_GEM);
-			}
+		{
+			bigCardActor.ActivateSpellBirthState(SpellType.COIN_MANA_GEM);
+		}
 		}
 	}
 
@@ -1593,26 +1593,26 @@ public class BigCard : MonoBehaviour
 			{
 				if (!flag2)
 				{
-					GameObject gameObject = GameObjectUtils.FindChildBySubstring(m_bigCardActor.gameObject, "GhostCard");
-					GameObject gameObject2 = GameObjectUtils.FindChildBySubstring(m_bigCardActor.gameObject, "RootObject");
-					if (gameObject != null && gameObject2 != null)
-					{
-						GhostCard component = gameObject.GetComponent<GhostCard>();
-						component.enabled = true;
-						component.SetGhostType(GhostCard.Type.DORMANT);
-						component.RenderGhostCard(forceRender: true);
-						actor.GhostCardEffect(GhostCard.Type.DORMANT);
-					}
-					GameObject gameObject3 = GameObjectUtils.FindChildBySubstring(actor.gameObject, "GhostedCard_Bottom");
-					if (gameObject3 != null)
-					{
-						bool active = entity.GetTag(GAME_TAG.TAG_SCRIPT_DATA_ENT_2) != 0;
-						gameObject3.SetActive(active);
-					}
-					else
-					{
-						Debug.LogWarning("BigCard.SetupActor - Bottom ghost card is missing");
-					}
+				GameObject gameObject = GameObjectUtils.FindChildBySubstring(m_bigCardActor.gameObject, "GhostCard");
+				GameObject gameObject2 = GameObjectUtils.FindChildBySubstring(m_bigCardActor.gameObject, "RootObject");
+				if (gameObject != null && gameObject2 != null)
+				{
+					GhostCard component = gameObject.GetComponent<GhostCard>();
+					component.enabled = true;
+					component.SetGhostType(GhostCard.Type.DORMANT);
+					component.RenderGhostCard(forceRender: true);
+					actor.GhostCardEffect(GhostCard.Type.DORMANT);
+				}
+				GameObject gameObject3 = GameObjectUtils.FindChildBySubstring(actor.gameObject, "GhostedCard_Bottom");
+				if (gameObject3 != null)
+				{
+					bool active = entity.GetTag(GAME_TAG.TAG_SCRIPT_DATA_ENT_2) != 0;
+					gameObject3.SetActive(active);
+				}
+				else
+				{
+					Debug.LogWarning("BigCard.SetupActor - Bottom ghost card is missing");
+				}
 				}
 				else
 				{
diff --git a/Assembly-CSharp/Blizzard/BlizzardErrorMobile/ReportBuilder.cs b/Assembly-CSharp/Blizzard/BlizzardErrorMobile/ReportBuilder.cs
index 2a35f30..031522d 100644
--- a/Assembly-CSharp/Blizzard/BlizzardErrorMobile/ReportBuilder.cs
+++ b/Assembly-CSharp/Blizzard/BlizzardErrorMobile/ReportBuilder.cs
@@ -12,12 +12,6 @@ namespace Blizzard.BlizzardErrorMobile
 {
 	public class ReportBuilder
 	{
-		[CompilerGenerated]
-		private bool <CaptureLogs>k__BackingField;
-
-		[CompilerGenerated]
-		private bool <CaptureConfig>k__BackingField;
-
 		private static ExceptionSettings s_settings;
 
 		public static string ApplicationUnityVersion { get; set; }
@@ -56,23 +50,9 @@ namespace Blizzard.BlizzardErrorMobile
 
 		public string DebugModules { get; set; }
 
-		public bool CaptureLogs
-		{
-			[CompilerGenerated]
-			set
-			{
-				<CaptureLogs>k__BackingField = value;
-			}
-		}
+		public bool CaptureLogs {get; set;}
 
-		public bool CaptureConfig
-		{
-			[CompilerGenerated]
-			set
-			{
-				<CaptureConfig>k__BackingField = value;
-			}
-		}
+		public bool CaptureConfig { get; set; }
 
 		public bool HappenedBefore { get; set; }
 
diff --git a/Assembly-CSharp/BnetBar.cs b/Assembly-CSharp/BnetBar.cs
index 9941540..3b095a7 100644
--- a/Assembly-CSharp/BnetBar.cs
+++ b/Assembly-CSharp/BnetBar.cs
@@ -252,9 +252,9 @@ public class BnetBar : MonoBehaviour
 		{
 			if (SpectatorManager.Get() != null)
 			{
-				SpectatorManager.Get().OnInviteReceived -= SpectatorManager_OnInviteReceived;
-				SpectatorManager.Get().OnSpectatorToMyGame -= SpectatorManager_OnSpectatorToMyGame;
-				SpectatorManager.Get().OnSpectatorModeChanged -= SpectatorManager_OnSpectatorModeChanged;
+			SpectatorManager.Get().OnInviteReceived -= SpectatorManager_OnInviteReceived;
+			SpectatorManager.Get().OnSpectatorToMyGame -= SpectatorManager_OnSpectatorToMyGame;
+			SpectatorManager.Get().OnSpectatorModeChanged -= SpectatorManager_OnSpectatorModeChanged;
 			}
 			Network.Get()?.RemoveNetHandler(GetServerTimeResponse.PacketID.ID, OnRequestGetServerTimeResponse);
 			HearthstoneApplication hearthstoneApplication = HearthstoneApplication.Get();
@@ -282,7 +282,7 @@ public class BnetBar : MonoBehaviour
 		Network.Get()?.RegisterNetHandler(GetServerTimeResponse.PacketID.ID, OnRequestGetServerTimeResponse);
 		if (HearthstoneApplication.Get() != null)
 		{
-			HearthstoneApplication.Get().WillReset += WillReset;
+		HearthstoneApplication.Get().WillReset += WillReset;
 		}
 		m_friendButton.gameObject.SetActive(value: false);
 		if (m_friendButton != null)
@@ -958,7 +958,7 @@ public class BnetBar : MonoBehaviour
 		m_isLoggedIn = false;
 	}
 
-	private bool HandleEscapeKey()
+	internal bool HandleEscapeKey()
 	{
 		if (m_gameMenu != null && m_gameMenu.GameMenuIsShown())
 		{
@@ -1146,13 +1146,13 @@ public class BnetBar : MonoBehaviour
 		{
 			num = ((mode != SceneMgr.Mode.FATAL_ERROR) ? 1 : 0);
 			if (num != 0)
+		{
+			if (SpectatorManager.Get().IsInSpectatorMode())
 			{
-				if (SpectatorManager.Get().IsInSpectatorMode())
-				{
-					SpectatorManager_OnSpectatorModeChanged(OnlineEventType.ADDED, null);
-				}
-				goto IL_0061;
+				SpectatorManager_OnSpectatorModeChanged(OnlineEventType.ADDED, null);
 			}
+				goto IL_0061;
+		}
 		}
 		else
 		{
diff --git a/Assembly-CSharp/BnetFriendMgr.cs b/Assembly-CSharp/BnetFriendMgr.cs
index 8f6ce1e..b2452bb 100644
--- a/Assembly-CSharp/BnetFriendMgr.cs
+++ b/Assembly-CSharp/BnetFriendMgr.cs
@@ -6,6 +6,7 @@ using Hearthstone;
 using PegasusClient;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class BnetFriendMgr
 {
@@ -39,7 +40,7 @@ public class BnetFriendMgr
 
 	private bool m_isRegisteredToFriendHandler;
 
-	private bool m_isFriendInviteFeatureEnabled;
+	private bool m_isFriendInviteFeatureEnabled = true;
 
 	private static ulong nextIdToken;
 
@@ -350,6 +351,15 @@ public class BnetFriendMgr
 
 	public bool RemoveFriend(BnetPlayer friend)
 	{
+		if (friend.IsCheatPlayer)
+		{
+			var changeList = new BnetFriendChangelist();
+			changeList.AddRemovedFriend(friend);
+			m_friends.Remove(friend);
+			ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+
+			return true;
+		}
 		bool flag = false;
 		for (int i = 0; i < m_friends.Count; i++)
 		{
@@ -425,6 +435,7 @@ public class BnetFriendMgr
 			{
 				flag = true;
 				m_friends.Add(friend);
+				DebugAddFriend(friend);
 			}
 		}
 		if (flag)
@@ -453,6 +464,7 @@ public class BnetFriendMgr
 				if (bnetPlayer.IsDisplayable())
 				{
 					m_friends.Add(bnetPlayer);
+							DebugAddFriend(bnetPlayer);
 					bnetFriendChangelist.AddAddedFriend(bnetPlayer);
 				}
 				else
@@ -642,4 +654,220 @@ public class BnetFriendMgr
 		}
 		return num;
 	}
+
+	#region Accessibility Testing
+
+	public int GetMaxFriends()
+	{
+		return m_maxFriends;
+	}
+
+	public int GetMaxSentInvites()
+	{
+		return m_maxSentInvites;
+	}
+
+	public List<BnetInvitation> GetSentInvites()
+	{
+		return m_sentInvites;
+	}
+
+	public BnetInvitation Cheat_CreateReceivedInvite(/*ref ulong nextIdToken,*/BnetPlayer myself, string fullName, ulong creationTime, ulong expirationTime)
+	{
+		BnetInvitationId id = new BnetInvitationId(nextIdToken++);
+		BnetAccountId bnetAccountId = new BnetAccountId(nextIdToken++, nextIdToken++);
+		BnetInvitation bnetInvitation = new BnetInvitation();
+		bnetInvitation.SetId(id);
+		bnetInvitation.SetInviterId(bnetAccountId);
+		bnetInvitation.SetInviterName(fullName);
+		bnetInvitation.SetInviteeId(myself.GetAccountId());
+		bnetInvitation.SetInviteeName(myself.GetFullName());
+		bnetInvitation.SetCreationTimeMicrosec(creationTime);
+		bnetInvitation.SetExpirationTimeMicroSec(expirationTime);
+		bnetInvitation.m_isCheatInvite = true;
+		m_receivedInvites.Add(bnetInvitation);
+		return bnetInvitation;
+	}
+
+	public void Cheat_RemoveReceivedInvites()
+	{
+		var changeList = new BnetFriendChangelist();
+		foreach (var invite in m_receivedInvites)
+		{
+			changeList.AddRemovedReceivedInvite(invite);
+		}
+		ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+	}
+
+	public void Cheat_AddReceivedInvites()
+	{
+		var changeList = new BnetFriendChangelist();
+		foreach (var invite in m_receivedInvites)
+		{
+			changeList.AddAddedReceivedInvite(invite);
+		}
+		ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+	}
+
+	public void Cheat_AcceptInvite(BnetInvitation invitation)
+	{
+    BnetInvitationId bnetInvitationId = invitation.GetId();
+		var changeList = new BnetFriendChangelist();
+		foreach (var invite in m_receivedInvites)
+		{
+			if (invite.GetId() == bnetInvitationId)
+			{
+				changeList.AddRemovedReceivedInvite(invite);
+				changeList.AddAddedFriend(Cheat_HSACreatePlayer("InvFr#717", "Invited Friend", 0, 0, BnetProgramId.BNET, false, false));
+			}
+		}
+		m_receivedInvites.RemoveAll(i => i.GetId() == bnetInvitationId);
+		ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+	}
+
+	public void Cheat_DeclineInvite(BnetInvitationId bnetInvitationId)
+	{
+		var changeList = new BnetFriendChangelist();
+		foreach (var invite in m_receivedInvites)
+		{
+			if (invite.GetId() == bnetInvitationId)
+			{
+				changeList.AddRemovedReceivedInvite(invite);
+			}
+		}
+		m_receivedInvites.RemoveAll(i => i.GetId() == bnetInvitationId);
+		ChatMgr.Get().FriendListFrame.OnFriendsChanged(changeList, null);
+	}
+
+	public BnetInvitation Cheat_CreateSentInvite(ref ulong nextIdToken, BnetPlayer myself, string fullName, ulong creationTime, ulong expirationTime)
+	{
+		BnetInvitationId id = new BnetInvitationId(nextIdToken++);
+		BnetAccountId bnetAccountId = new BnetAccountId(nextIdToken++, nextIdToken++);
+		BnetInvitation bnetInvitation = new BnetInvitation();
+		bnetInvitation.SetId(id);
+		bnetInvitation.SetInviterId(myself.GetAccountId());
+		bnetInvitation.SetInviterName(myself.GetFullName());
+		bnetInvitation.SetInviteeId(bnetAccountId);
+		bnetInvitation.SetInviteeName(fullName);
+		bnetInvitation.SetCreationTimeMicrosec(creationTime);
+		bnetInvitation.SetExpirationTimeMicroSec(expirationTime);
+		m_sentInvites.Add(bnetInvitation);
+		return bnetInvitation;
+	}
+
+
+    public BnetPlayer Cheat_HSAAddFriend(string battleTag, string fullName, int leagueId, int starLevel, BnetProgramId programId, bool isOnline, bool isAvailable)
+	{
+		var alreadyExistingFriend = HSAGetFriend(battleTag);
+		if (alreadyExistingFriend != null)
+		{
+			return alreadyExistingFriend;
+		}
+
+		var bnetPlayer = Cheat_HSACreatePlayer(battleTag, fullName, leagueId, starLevel, programId, isOnline, isAvailable);
+		m_friends.Add(bnetPlayer);
+		DebugAddFriend(bnetPlayer);
+		return bnetPlayer;
+	}
+
+	private BnetPlayer HSAGetFriend(string battleTag)
+	{
+		foreach (var friend in m_friends)
+		{
+			if (friend.GetBattleTag().GetString().Equals(battleTag))
+			{
+				return friend;
+			}
+		}
+
+		return null;
+	}
+
+	public BnetPlayer Cheat_HSACreatePlayer(string battleTag, string fullName, int leagueId, int starLevel, BnetProgramId programId, bool isOnline, bool isAvailable)
+	{
+		BnetBattleTag bnetBattleTag = new BnetBattleTag();
+		bnetBattleTag.SetString(battleTag);
+		BnetAccountId bnetAccountId = new BnetAccountId(nextIdToken++, nextIdToken++);
+		BnetAccount bnetAccount = new BnetAccount();
+		bnetAccount.SetId(bnetAccountId);
+		bnetAccount.SetFullName(fullName);
+		bnetAccount.SetBattleTag(bnetBattleTag);
+		BnetGameAccountId bnetGameAccountId = new BnetGameAccountId(nextIdToken++, nextIdToken++);
+		BnetGameAccount bnetGameAccount = new BnetGameAccount();
+		bnetGameAccount.SetId(bnetGameAccountId);
+		bnetGameAccount.SetBattleTag(bnetBattleTag);
+		bnetGameAccount.SetOnline(isOnline);
+		bnetGameAccount.SetProgramId(programId);
+		GamePresenceRank gamePresenceRank = new GamePresenceRank();
+		foreach (FormatType value in Enum.GetValues(typeof(FormatType)))
+		{
+			if (value != 0)
+			{
+				GamePresenceRankData item = new GamePresenceRankData
+				{
+					FormatType = value,
+					LeagueId = leagueId,
+					StarLevel = starLevel,
+					LegendRank = 327
+				};
+				gamePresenceRank.Values.Add(item);
+			}
+		}
+		byte[] val = ProtobufUtil.ToByteArray(gamePresenceRank);
+
+		if (isAvailable)
+		{
+			bnetGameAccount.SetGameField(1u, true);
+		}
+
+		if (isOnline)
+		{
+			bnetGameAccount.SetGameField(18u, val);
+		}
+
+		BnetPlayer bnetPlayer = new BnetPlayer(BnetPlayerSource.CREATED_BY_CHEAT);
+		bnetPlayer.SetAccount(bnetAccount);
+		bnetPlayer.AddGameAccount(bnetGameAccount);
+		bnetPlayer.IsCheatPlayer = true;
+
+		return bnetPlayer;
+	}
+
+    private void DebugAddFriend(BnetPlayer friend)
+    {
+        if (!HearthstoneAccessConstants.DEV_MODE)
+        {
+			return;
+        }
+
+		var bnetAccount = friend.GetAccount();
+		var gameAccounts = friend.GetGameAccounts();
+
+		AccessibilityUtils.LogDebug($"DebugAddFriend({friend.GetBestName()})");
+
+		AccessibilityUtils.LogDebug($"BnetAccount FullName({bnetAccount.GetFullName()})");
+		AccessibilityUtils.LogDebug($"BnetAccount BattleTag({bnetAccount.GetBattleTag()})");
+
+		AccessibilityUtils.LogDebug($"GameAccounts:");
+
+		foreach (var gameAccount in gameAccounts)
+        {
+            AccessibilityUtils.LogDebug($"AccountId: {gameAccount.Key}");
+
+			var val = gameAccount.Value;
+
+            AccessibilityUtils.LogDebug($"ProgramId: {val.GetProgramId()}");
+            AccessibilityUtils.LogDebug($"IsOnline: {val.IsOnline()}");
+            AccessibilityUtils.LogDebug($"IsAvailable: {val.GetGameFieldBool(1u)}");
+            var bytes = val.GetGameFieldBytes(18u);
+            AccessibilityUtils.LogDebug($"18u: {bytes}");
+        }
+    }
+
+	internal ulong Cheat_HSAGetNextIdToken()
+	{
+		return nextIdToken++;
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/BnetInvitation.cs b/Assembly-CSharp/BnetInvitation.cs
index 7a804d8..d242d4c 100644
--- a/Assembly-CSharp/BnetInvitation.cs
+++ b/Assembly-CSharp/BnetInvitation.cs
@@ -18,6 +18,11 @@ public class BnetInvitation
 
 	private ulong m_expirationTimeMicrosec;
 
+	#region Accessibility Testing
+	internal bool m_isCheatInvite;
+	#endregion
+
+
 	public static BnetInvitation CreateFromFriendsUpdate(FriendsUpdate src)
 	{
 		BnetInvitation bnetInvitation = new BnetInvitation();
@@ -89,6 +94,11 @@ public class BnetInvitation
 		return a.m_id == b.m_id;
 	}
 
+	public static bool operator !=(BnetInvitation a, BnetInvitation b)
+	{
+		return !(a == b);
+	}
+
 	public override string ToString()
 	{
 		if (m_id == null)
@@ -97,4 +107,68 @@ public class BnetInvitation
 		}
 		return $"[id={m_id} inviterId={m_inviterId} inviterName={m_inviterName} inviteeId={m_inviteeId} inviteeName={m_inviteeName} message={m_message}]";
 	}
+
+	#region Accessibility Testing
+
+	public void SetId(BnetInvitationId id)
+	{
+		m_id = id;
+	}
+
+	public void SetInviterId(BnetEntityId id)
+	{
+		m_inviterId = id;
+	}
+
+	public void SetInviterName(string name)
+	{
+		m_inviterName = name;
+	}
+
+	public BnetEntityId GetInviteeId()
+	{
+		return m_inviteeId;
+	}
+
+	public void SetInviteeId(BnetEntityId id)
+	{
+		m_inviteeId = id;
+	}
+
+	public string GetInviteeName()
+	{
+		return m_inviteeName;
+	}
+
+	public void SetInviteeName(string name)
+	{
+		m_inviteeName = name;
+	}
+
+	public string GetMessage()
+	{
+		return m_message;
+	}
+
+	public void SetMessage(string message)
+	{
+		m_message = message;
+	}
+
+	public void SetCreationTimeMicrosec(ulong microsec)
+	{
+		m_creationTimeMicrosec = microsec;
+	}
+
+	public ulong GetExpirationTimeMicrosec()
+	{
+		return m_expirationTimeMicrosec;
+	}
+
+	public void SetExpirationTimeMicroSec(ulong microsec)
+	{
+		m_expirationTimeMicrosec = microsec;
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/BnetInvitationId.cs b/Assembly-CSharp/BnetInvitationId.cs
index 4d103a5..67317da 100644
--- a/Assembly-CSharp/BnetInvitationId.cs
+++ b/Assembly-CSharp/BnetInvitationId.cs
@@ -52,6 +52,11 @@ public class BnetInvitationId
 		return a.m_val == b.m_val;
 	}
 
+	public static bool operator !=(BnetInvitationId a, BnetInvitationId b)
+	{
+		return !(a == b);
+	}
+
 	public override string ToString()
 	{
 		return m_val.ToString();
diff --git a/Assembly-CSharp/BnetNearbyPlayerMgr.cs b/Assembly-CSharp/BnetNearbyPlayerMgr.cs
index 30ede04..744addf 100644
--- a/Assembly-CSharp/BnetNearbyPlayerMgr.cs
+++ b/Assembly-CSharp/BnetNearbyPlayerMgr.cs
@@ -342,7 +342,7 @@ public class BnetNearbyPlayerMgr
 		try
 		{
 			array = u.EndReceive(ar, ref remoteEP);
-			u.BeginReceive(OnUdpReceive, ar.AsyncState);
+		u.BeginReceive(OnUdpReceive, ar.AsyncState);
 		}
 		catch
 		{
@@ -1035,4 +1035,35 @@ public class BnetNearbyPlayerMgr
 		FireChangeEvent(changelist);
 		return num;
 	}
+
+	public BnetPlayer Cheat_CreateHSANearbyPlayer(string battleTag, string fullName, int leagueId, int starLevel, BnetProgramId programId, bool isFriend, bool isOnline, bool isAvailable)
+	{
+		BnetPlayer bnetPlayer;
+
+		if (isFriend)
+		{
+			bnetPlayer = BnetFriendMgr.Get().Cheat_HSAAddFriend(battleTag, fullName, leagueId, starLevel, programId, isOnline, isAvailable);
+		}
+		else
+		{
+			bnetPlayer = BnetFriendMgr.Get().Cheat_HSACreatePlayer(battleTag, fullName, leagueId, starLevel, programId, isOnline, isAvailable);
+		}
+
+		BnetRecentOrNearbyPlayerChangelist bnetNearbyPlayerChangelist = new BnetRecentOrNearbyPlayerChangelist();
+		if (isFriend)
+		{
+			bnetNearbyPlayerChangelist.AddAddedFriend(bnetPlayer);
+		}
+		else
+		{
+			bnetNearbyPlayerChangelist.AddAddedPlayer(bnetPlayer);
+		}
+		NearbyPlayer nearbyPlayer = new NearbyPlayer();
+		nearbyPlayer.m_bnetPlayer = bnetPlayer;
+		nearbyPlayer.m_availability = true;
+		nearbyPlayer.m_partyId = BnetPartyId.Empty;
+		m_nearbyAdds.Add(nearbyPlayer);
+		ProcessAddedPlayers(bnetNearbyPlayerChangelist);
+		return bnetPlayer;
+	}
 }
diff --git a/Assembly-CSharp/BnetRecentPlayerMgr.cs b/Assembly-CSharp/BnetRecentPlayerMgr.cs
index cae8938..4ee3070 100644
--- a/Assembly-CSharp/BnetRecentPlayerMgr.cs
+++ b/Assembly-CSharp/BnetRecentPlayerMgr.cs
@@ -394,4 +394,11 @@ public class BnetRecentPlayerMgr
 		FireChangeEvent(changelist);
 		return num;
 	}
+
+	public BnetPlayer Cheat_CreateHSARecentPlayer(string battleTag, string fullName, int leagueId, int starLevel, BnetProgramId programId, bool isFriend, bool isOnline, bool isAvailable)
+	{
+		BnetPlayer bnetPlayer = BnetFriendMgr.Get().Cheat_HSACreatePlayer(battleTag, fullName, leagueId, starLevel, programId, isFriend, isOnline);
+		AddRecentPlayer(bnetPlayer, RecentReason.CHEAT);
+		return bnetPlayer;
+	}
 }
diff --git a/Assembly-CSharp/BnetWhisperMgr.cs b/Assembly-CSharp/BnetWhisperMgr.cs
index f70f334..dd740fb 100644
--- a/Assembly-CSharp/BnetWhisperMgr.cs
+++ b/Assembly-CSharp/BnetWhisperMgr.cs
@@ -78,6 +78,12 @@ public class BnetWhisperMgr
 
 	public bool SendWhisper(BnetPlayer player, string message)
 	{
+		if (player.IsCheatPlayer)
+		{
+			// TODO: mock flow
+			return true;
+		}
+
 		if (player == null)
 		{
 			return false;
diff --git a/Assembly-CSharp/BoH_Guldan_01.cs b/Assembly-CSharp/BoH_Guldan_01.cs
index 86c8924..e41df61 100644
--- a/Assembly-CSharp/BoH_Guldan_01.cs
+++ b/Assembly-CSharp/BoH_Guldan_01.cs
@@ -53,8 +53,6 @@ public class BoH_Guldan_01 : BoH_Guldan_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -260,45 +258,19 @@ public class BoH_Guldan_01 : BoH_Guldan_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
-
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		InitTurnCounterVisuals(
+			turnCounterKey: "BOH_GULDAN_01",
+			fsmRunningManVal: true,
+			fsmMineCartVal: false,
+			fsmAirshipVal: false,
+			fsmDestroyerVal: false
+		);
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		if (change.tag == 48 && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -307,31 +279,4 @@ public class BoH_Guldan_01 : BoH_Guldan_Dungeon
 			.GetActor();
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_GULDAN_01", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
 }
diff --git a/Assembly-CSharp/BoH_Guldan_06.cs b/Assembly-CSharp/BoH_Guldan_06.cs
index 33a16e9..abffab6 100644
--- a/Assembly-CSharp/BoH_Guldan_06.cs
+++ b/Assembly-CSharp/BoH_Guldan_06.cs
@@ -57,8 +57,6 @@ public class BoH_Guldan_06 : BoH_Guldan_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private MineCartRushArt m_mineCartArt;
 
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
@@ -267,45 +265,19 @@ public class BoH_Guldan_06 : BoH_Guldan_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
-
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		InitTurnCounterVisuals(
+			turnCounterKey: "BOH_GULDAN_01",
+			fsmRunningManVal: true,
+			fsmMineCartVal: false,
+			fsmAirshipVal: false,
+			fsmDestroyerVal: false
+		);
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		if (change.tag == 48 && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	private void UpdateMineCartArt()
@@ -314,31 +286,4 @@ public class BoH_Guldan_06 : BoH_Guldan_Dungeon
 			.GetActor();
 		m_mineCartArt.DoPortraitSwap(actor);
 	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_GULDAN_01", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
-	}
 }
diff --git a/Assembly-CSharp/BoH_Illidan_08.cs b/Assembly-CSharp/BoH_Illidan_08.cs
index f5d4149..b4074cf 100644
--- a/Assembly-CSharp/BoH_Illidan_08.cs
+++ b/Assembly-CSharp/BoH_Illidan_08.cs
@@ -81,8 +81,6 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
 	{
 		return new Map<GameEntityOption, bool> { 
@@ -190,7 +188,13 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 			yield return MissionPlayVOOnce(enemyActor, m_InGame_BossUsesHeroPowerLines);
 			break;
 		case 105:
-			InitVisuals();
+			InitTurnCounterVisuals(
+				turnCounterKey: "BOH_ILLIDAN_08",
+				fsmRunningManVal: false,
+				fsmMineCartVal: false,
+				fsmAirshipVal: false,
+				fsmDestroyerVal: true
+			);
 			GameState.Get().GetOpposingSidePlayer().UpdateDisplayInfo();
 			Gameplay.Get().GetNameBannerForSide(Player.Side.OPPOSING).UpdateHeroNameBanner();
 			break;
@@ -338,68 +342,9 @@ public class BoH_Illidan_08 : BoH_Illidan_Dungeon
 		}
 	}
 
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
-	}
-
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		if (change.tag == 48 && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = false;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = true;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
-	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_ILLIDAN_08", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 }
diff --git a/Assembly-CSharp/BoH_Jaina_06.cs b/Assembly-CSharp/BoH_Jaina_06.cs
index 87d7e18..1b7a3b7 100644
--- a/Assembly-CSharp/BoH_Jaina_06.cs
+++ b/Assembly-CSharp/BoH_Jaina_06.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using Blizzard.T5.Core;
 using UnityEngine;
+using Accessibility;
 
 public class BoH_Jaina_06 : BoH_Jaina_Dungeon
 {
@@ -297,7 +298,7 @@ public class BoH_Jaina_06 : BoH_Jaina_Dungeon
 		switch (turn)
 		{
 		case 1:
-			yield return PlayLineAlways(friendlyActor, VO_Story_Hero_Jaina_Human_Female_Story_Jaina_Mission6ExchangeA_01);
+            yield return PlayLineAlways(friendlyActor, VO_Story_Hero_Jaina_Human_Female_Story_Jaina_Mission6ExchangeA_01);
 			yield return PlayLineAlways(enemyActor, VO_Story_Hero_Garrosh_Male_Orc_Story_Jaina_Mission6ExchangeA_01);
 			break;
 		case 5:
diff --git a/Assembly-CSharp/BoH_Uther_08.cs b/Assembly-CSharp/BoH_Uther_08.cs
index 1fb02b8..96490d8 100644
--- a/Assembly-CSharp/BoH_Uther_08.cs
+++ b/Assembly-CSharp/BoH_Uther_08.cs
@@ -47,8 +47,6 @@ public class BoH_Uther_08 : BoH_Uther_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	private static Map<GameEntityOption, bool> InitBooleanOptions()
 	{
 		return new Map<GameEntityOption, bool> { 
@@ -227,72 +225,19 @@ public class BoH_Uther_08 : BoH_Uther_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
-
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		InitTurnCounterVisuals(
+			turnCounterKey: "BOH_UTHER_08",
+			fsmRunningManVal: true,
+			fsmMineCartVal: false,
+			fsmAirshipVal: false,
+			fsmDestroyerVal: false
+		);
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
-		if (change.tag == 48 && change.newValue != change.oldValue)
-		{
-			UpdateVisuals(change.newValue);
-		}
-	}
-
-	private void InitTurnCounter(int cost)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
-		m_turnCounter = gameObject.GetComponent<Notification>();
-		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
-		component.FsmVariables.GetFsmBool("RunningMan").Value = true;
-		component.FsmVariables.GetFsmBool("MineCart").Value = false;
-		component.FsmVariables.GetFsmBool("Airship").Value = false;
-		component.FsmVariables.GetFsmBool("Destroyer").Value = false;
-		component.SendEvent("Birth");
-		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-			.GetActor();
-		m_turnCounter.transform.parent = actor.gameObject.transform;
-		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
-		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
-		UpdateTurnCounterText(cost);
-	}
-
-	private void UpdateVisuals(int cost)
-	{
-		UpdateTurnCounter(cost);
-	}
-
-	private void UpdateTurnCounter(int cost)
-	{
-		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
-		if (cost <= 0)
-		{
-			Object.Destroy(m_turnCounter.gameObject);
-		}
-		else
-		{
-			UpdateTurnCounterText(cost);
-		}
-	}
-
-	private void UpdateTurnCounterText(int cost)
-	{
-		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
-		{
-			new GameStrings.PluralNumber
-			{
-				m_index = 0,
-				m_number = cost
-			}
-		};
-		string headlineString = GameStrings.FormatPlurals("BOH_UTHER_08", pluralNumbers);
-		m_turnCounter.ChangeDialogText(headlineString, cost.ToString(), "", "");
+		UpdateTurnCounterVisualsIfNeeded(change);
 	}
 
 	public override void StartGameplaySoundtracks()
diff --git a/Assembly-CSharp/BoH_Valeera_08.cs b/Assembly-CSharp/BoH_Valeera_08.cs
index 3ad7a6a..eedf469 100644
--- a/Assembly-CSharp/BoH_Valeera_08.cs
+++ b/Assembly-CSharp/BoH_Valeera_08.cs
@@ -48,8 +48,6 @@ public class BoH_Valeera_08 : BoH_Valeera_Dungeon
 
 	private HashSet<string> m_playedLines = new HashSet<string>();
 
-	private Notification m_turnCounter;
-
 	public override void PreloadAssets()
 	{
 		base.PreloadAssets();
@@ -229,18 +227,21 @@ public class BoH_Valeera_08 : BoH_Valeera_Dungeon
 	public override void NotifyOfMulliganEnded()
 	{
 		base.NotifyOfMulliganEnded();
-		InitVisuals();
-	}
 
-	private void InitVisuals()
-	{
-		int cost = GetCost();
-		InitTurnCounter(cost);
+		// Note: This isn't really a turn-based encounter but Blizzard reused most of the componentry.
+		InitTurnCounterVisuals(
+			turnCounterKey: "BOH_VALEERA_08",
+			fsmRunningManVal: true,
+			fsmMineCartVal: false,
+			fsmAirshipVal: false,
+			fsmDestroyerVal: false
+		);
 	}
 
 	public override void OnTagChanged(TagDelta change)
 	{
 		base.OnTagChanged(change);
+		UpdateTurnCounterVisualsIfNeeded(change);
 		if (change.tag == 48 && change.newValue != change.oldValue)
 		{
 			UpdateVisuals(change.newValue);
diff --git a/Assembly-CSharp/Board.cs b/Assembly-CSharp/Board.cs
index 0e48979..af7d29d 100644
--- a/Assembly-CSharp/Board.cs
+++ b/Assembly-CSharp/Board.cs
@@ -128,13 +128,13 @@ public class Board : MonoBehaviour
 	{
 		if (m_pooledDustEffects != null)
 		{
-			m_pooledDustEffects.ReleaseAll();
-			m_pooledDustEffects.Clear();
+		m_pooledDustEffects.ReleaseAll();
+		m_pooledDustEffects.Clear();
 		}
 		m_cachedParticleSystems?.Clear();
 		if (s_instance == this)
 		{
-			s_instance = null;
+		s_instance = null;
 		}
 		AssetHandle.SafeDispose(ref m_friendlyHeroTrayTexture);
 		AssetHandle.SafeDispose(ref m_friendlyHeroPhoneTrayTexture);
@@ -317,6 +317,11 @@ public class Board : MonoBehaviour
 		return Gameplay.Get().GetBoardLayout().FindCollider(name);
 	}
 
+	public Collider GetDeckActionArea()
+	{
+		return FindCollider("DeckActionArea");
+	}
+
 	public GameObject GetMouseClickDustEffectPrefab()
 	{
 		return m_MouseClickDustEffect;
@@ -448,14 +453,14 @@ public class Board : MonoBehaviour
 	{
 		if (!(m_MouseClickDustEffect == null))
 		{
-			m_pooledDustEffects = new Pool<GameObject>();
-			m_pooledDustEffects.SetCreateItemCallback(CreateDustEffect);
-			m_pooledDustEffects.SetDestroyItemCallback(DestroyDustEffect);
-			m_pooledDustEffects.SetExtensionCount(0);
-			m_pooledDustEffects.SetMaxReleasedItemCount(10);
-			m_cachedParticleSystems = new Dictionary<int, ParticleSystem[]>();
-			m_pooledDustEffects.AddFreeItems(10);
-		}
+		m_pooledDustEffects = new Pool<GameObject>();
+		m_pooledDustEffects.SetCreateItemCallback(CreateDustEffect);
+		m_pooledDustEffects.SetDestroyItemCallback(DestroyDustEffect);
+		m_pooledDustEffects.SetExtensionCount(0);
+		m_pooledDustEffects.SetMaxReleasedItemCount(10);
+		m_cachedParticleSystems = new Dictionary<int, ParticleSystem[]>();
+		m_pooledDustEffects.AddFreeItems(10);
+	}
 	}
 
 	private GameObject CreateDustEffect(int i)
diff --git a/Assembly-CSharp/BonusChallengeUnlockData.cs b/Assembly-CSharp/BonusChallengeUnlockData.cs
index cd21f29..4cec181 100644
--- a/Assembly-CSharp/BonusChallengeUnlockData.cs
+++ b/Assembly-CSharp/BonusChallengeUnlockData.cs
@@ -2,19 +2,9 @@ using System.Runtime.CompilerServices;
 
 public class BonusChallengeUnlockData : RewardData
 {
-	[CompilerGenerated]
-	private string <BossCardActorPrefab>k__BackingField;
-
 	public string PrefabToDisplay { get; set; }
 
-	public string BossCardActorPrefab
-	{
-		[CompilerGenerated]
-		set
-		{
-			<BossCardActorPrefab>k__BackingField = value;
-		}
-	}
+	public string BossCardActorPrefab { get;  set; }
 
 	public BonusChallengeUnlockData()
 		: this("", "Card_DungeonCrawl_Boss.prefab:c7f700bb034424e46a7c2321e4621965")
diff --git a/Assembly-CSharp/BookPageManager.cs b/Assembly-CSharp/BookPageManager.cs
index 4308bd0..c3b4583 100644
--- a/Assembly-CSharp/BookPageManager.cs
+++ b/Assembly-CSharp/BookPageManager.cs
@@ -197,7 +197,7 @@ public abstract class BookPageManager : MonoBehaviour
 		m_currentPageIsPageA = !m_currentPageIsPageA;
 	}
 
-	protected BookPageDisplay GetCurrentPage()
+	internal BookPageDisplay GetCurrentPage()
 	{
 		if (!m_currentPageIsPageA)
 		{
diff --git a/Assembly-CSharp/BookTab.cs b/Assembly-CSharp/BookTab.cs
index e9ae9ee..c2f3de4 100644
--- a/Assembly-CSharp/BookTab.cs
+++ b/Assembly-CSharp/BookTab.cs
@@ -96,6 +96,11 @@ public class BookTab : PegUIElement
 		return m_isVisible;
 	}
 
+	public bool IsSelected()
+	{
+		return m_selected;
+	}
+
 	public void SetTargetVisibility(bool visible)
 	{
 		m_shouldBeVisible = visible;
diff --git a/Assembly-CSharp/BoosterDbfRecord.cs b/Assembly-CSharp/BoosterDbfRecord.cs
index 23489d1..4c987e0 100644
--- a/Assembly-CSharp/BoosterDbfRecord.cs
+++ b/Assembly-CSharp/BoosterDbfRecord.cs
@@ -352,4 +352,9 @@ public class BoosterDbfRecord : DbfRecord
 		m_descriptionOverride.StripUnusedLocales();
 		m_leavingSoonText.StripUnusedLocales();
 	}
+
+	#region Accessibility
+	public string NoteDesc => m_noteDesc;
+
+	#endregion
 }
diff --git a/Assembly-CSharp/BoosterProductPage.cs b/Assembly-CSharp/BoosterProductPage.cs
index dc7efd1..8629e33 100644
--- a/Assembly-CSharp/BoosterProductPage.cs
+++ b/Assembly-CSharp/BoosterProductPage.cs
@@ -71,13 +71,13 @@ public class BoosterProductPage : ProductPage
 		}
 	}
 
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
 		if (m_container != null)
 		{
 			m_container.OverrideMusic(MusicPlaylistType.Invalid);
 		}
-		base.Open();
+		base.Open(true);
 	}
 
 	protected override void OnProductSet()
diff --git a/Assembly-CSharp/Box.cs b/Assembly-CSharp/Box.cs
index 8150ae8..f9a6de4 100644
--- a/Assembly-CSharp/Box.cs
+++ b/Assembly-CSharp/Box.cs
@@ -18,6 +18,7 @@ using Hearthstone.Streaming;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class Box : MonoBehaviour
 {
@@ -655,14 +656,14 @@ public class Box : MonoBehaviour
 			UpdateUIEvents();
 			if (m_transitioningToSceneMode)
 			{
-				if ((bool)UniversalInputManager.UsePhoneUI)
-				{
+			if ((bool)UniversalInputManager.UsePhoneUI)
+			{
 					bool show = ShouldBeShowingState(State.HUB_WITH_DRAWER);
 					ToggleRibbonUI(show);
-				}
-				FireTransitionFinishedEvent();
-				m_transitioningToSceneMode = false;
 			}
+			FireTransitionFinishedEvent();
+			m_transitioningToSceneMode = false;
+		}
 		}
 		else
 		{
@@ -1175,10 +1176,10 @@ public class Box : MonoBehaviour
 			m_journalButtonWidget.Show();
 			if (m_ribbonButtons == null)
 			{
-				m_journalButtonWidget.TriggerEvent("ENABLE_INTERACTION");
-			}
+			m_journalButtonWidget.TriggerEvent("ENABLE_INTERACTION");
 		}
 	}
+	}
 
 	private void OnTutorialSceneDestroyed(object userData)
 	{
@@ -1203,12 +1204,12 @@ public class Box : MonoBehaviour
 				bnetBar.HideSkipTutorialButton();
 			}
 		}
-		SceneMgr sceneMgr = SceneMgr.Get();
-		sceneMgr.RegisterScenePreUnloadEvent(OnScenePreUnload);
-		sceneMgr.RegisterSceneLoadedEvent(OnSceneLoaded);
-		ChangeStateToReflectSceneMode(SceneMgr.Get().GetMode(), isSceneActuallyLoaded: false);
-		this.OnTutorialTransitionFinished?.Invoke();
-	}
+			SceneMgr sceneMgr = SceneMgr.Get();
+			sceneMgr.RegisterScenePreUnloadEvent(OnScenePreUnload);
+			sceneMgr.RegisterSceneLoadedEvent(OnSceneLoaded);
+			ChangeStateToReflectSceneMode(SceneMgr.Get().GetMode(), isSceneActuallyLoaded: false);
+			this.OnTutorialTransitionFinished?.Invoke();
+		}
 
 	private void ShutdownState()
 	{
@@ -1232,10 +1233,10 @@ public class Box : MonoBehaviour
 				Log.Box.PrintWarning("Tried to queue state {0}, but the state was overriden by RailroadManager ({1}), so skipping it...", state, m_state);
 			}
 			else
-			{
-				m_stateQueue.Enqueue(state);
-			}
-		}
+		{
+		m_stateQueue.Enqueue(state);
+	}
+	}
 	}
 
 	private void ChangeStateQueued()
@@ -1319,7 +1320,7 @@ public class Box : MonoBehaviour
 			}
 			else
 			{
-				Debug.LogError($"Box.ChangeStateNow() - unhandled state {state}");
+			Debug.LogError($"Box.ChangeStateNow() - unhandled state {state}");
 			}
 			break;
 		}
@@ -1338,14 +1339,14 @@ public class Box : MonoBehaviour
 				if (isSceneActuallyLoaded && m_setRotationIntroCoroutine == null)
 				{
 					m_setRotationIntroCoroutine = StartCoroutine(SetRotation_StartSetRotationIntro());
-				}
 			}
+		}
 			m_railroadManager.ToggleBoxTutorials(setEnabled: false);
 		}
 		else if (mode == SceneMgr.Mode.TOURNAMENT && flag)
 		{
 			ChangeState(State.SET_ROTATION_OPEN);
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 			m_transitioningToSceneMode = true;
 			m_railroadManager.ToggleBoxTutorials(setEnabled: false);
 		}
@@ -1355,10 +1356,10 @@ public class Box : MonoBehaviour
 			if (GameDownloadManagerProvider.Get().IsReadyToPlay)
 			{
 				Log.Box.PrintDebug("The download is done. Set to transitioning.");
-				m_transitioningToSceneMode = true;
-				bool setEnabled = ShouldBeShowingState(State.HUB_WITH_DRAWER);
-				m_railroadManager.ToggleBoxTutorials(setEnabled);
-			}
+			m_transitioningToSceneMode = true;
+			bool setEnabled = ShouldBeShowingState(State.HUB_WITH_DRAWER);
+			m_railroadManager.ToggleBoxTutorials(setEnabled);
+		}
 		}
 		BoxLightStateType stateType = TranslateSceneModeToLightState(mode);
 		m_LightMgr.ChangeState(stateType);
@@ -1379,7 +1380,8 @@ public class Box : MonoBehaviour
 		{
 			yield return null;
 		}
-		BoxCamera.State state = ((!GameUtils.IsAnyTutorialComplete()) ? BoxCamera.State.CLOSED_TUTORIAL : BoxCamera.State.CLOSED);
+		//BoxCamera.State state = ((!GameUtils.IsAnyTutorialComplete()) ? BoxCamera.State.CLOSED_TUTORIAL : BoxCamera.State.CLOSED);
+		BoxCamera.State state = BoxCamera.State.CLOSED;
 		m_Camera.ChangeState(state);
 	}
 
@@ -1860,20 +1862,20 @@ public class Box : MonoBehaviour
 		else
 		{
 			NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-			int totalBoosterCount = BoosterPackUtils.GetTotalBoosterCount();
-			SetPackCount(totalBoosterCount);
-			bool highlightOn = totalBoosterCount > 0 && !Options.Get().GetBool(Option.HAS_SEEN_PACK_OPENING, defaultVal: false);
-			HighlightButton(m_OpenPacksButton, highlightOn);
-			bool num = UpdateModesButton();
+		int totalBoosterCount = BoosterPackUtils.GetTotalBoosterCount();
+		SetPackCount(totalBoosterCount);
+		bool highlightOn = totalBoosterCount > 0 && !Options.Get().GetBool(Option.HAS_SEEN_PACK_OPENING, defaultVal: false);
+		HighlightButton(m_OpenPacksButton, highlightOn);
+		bool num = UpdateModesButton();
 			UpdateTavernBrawlButton();
 			bool flag = (!num && CollectionManager.Get().ShouldSeeTwistModeNotification()) || RewardTrackManager.Get().DidJustCompleteApprentice;
 			HighlightButton(m_PlayButton, flag);
 			bool flag2 = GameModeUtils.HasPlayedAPracticeMatch() && !Options.Get().GetBool(Option.HAS_SEEN_COLLECTIONMANAGER_AFTER_PRACTICE, defaultVal: false);
 			bool highlightOn2 = !num && !flag && netObject.Collection.Manager && flag2;
-			HighlightButton(m_CollectionButton, highlightOn2);
-			ToggleDrawerButtonState(netObject.Collection.Manager, m_CollectionButton);
-			SetupNewPlayerBanner();
-		}
+		HighlightButton(m_CollectionButton, highlightOn2);
+		ToggleDrawerButtonState(netObject.Collection.Manager, m_CollectionButton);
+		SetupNewPlayerBanner();
+	}
 	}
 
 	private void SetupNewPlayerBanner()
@@ -1912,7 +1914,7 @@ public class Box : MonoBehaviour
 		{
 			string eventName = (GameModeDisplay.ShouldSeeNewTavernBrawlBanner() ? "SHOW_NEW_TAVERN_BRAWL_BADGE" : "HIDE_NEW_TAVERN_BRAWL_BADGE");
 			m_boxWidget.TriggerEvent(eventName);
-		}
+	}
 	}
 
 	private void BoxWidgetIsReady(Widget widget)
@@ -2101,7 +2103,7 @@ public class Box : MonoBehaviour
 	private IEnumerator SetRotation_StartSetRotationIntro()
 	{
 		ResetSetRotationPopupProgress();
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StartBlocking(true, UserAttentionBlocker.SET_ROTATION_INTRO);
 		NotificationManager.Get().DestroyAllPopUps();
 		PopupDisplayManager.Get().ReadyToShowPopups();
 		yield return StartCoroutine(PopupDisplayManager.Get().WaitForAllPopups());
@@ -2146,7 +2148,7 @@ public class Box : MonoBehaviour
 		}
 		else
 		{
-			SpecialEventDataModel specialEventDataModel = SpecialEventManager.Get()?.GetEventDataModelForCurrentEvent();
+		SpecialEventDataModel specialEventDataModel = SpecialEventManager.Get()?.GetEventDataModelForCurrentEvent();
 			if (specialEventDataModel != null)
 			{
 				boxDressingDataModel.Type = specialEventDataModel.SpecialEventType.ToString();
@@ -2467,47 +2469,47 @@ public class Box : MonoBehaviour
 		BoxMenuButton boxMenuButton = (BoxMenuButton)element;
 		if (!OnPressDisabledButtons.Contains(boxMenuButton) && (IsInStateWithButtons() || (!(element == m_PlayButton) && !(element == m_BattleGroundsButton) && !(element == m_TavernBrawlButton) && !(element == m_GameModesButton))))
 		{
-			NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-			bool flag = false;
-			bool flag2 = false;
-			if (netObject != null)
-			{
-				flag = netObject.Games.Tournament;
-				flag2 = netObject.Collection.Manager;
-			}
-			if (m_newPlayerModeBanner.activeSelf && boxMenuButton != m_TavernBrawlButton)
-			{
-				m_newPlayerModeBanner.SetActive(value: false);
-			}
-			if (boxMenuButton == m_PlayButton && flag)
-			{
-				OnTraditionalModeButtonPressed(e);
-			}
-			else if (boxMenuButton == m_BattleGroundsButton)
-			{
-				OnBattleGroundsButtonPressed(e);
-			}
-			else if (boxMenuButton == m_GameModesButton)
-			{
-				OnModesButtonPressed(e);
-			}
-			else if (boxMenuButton == m_TavernBrawlButton)
-			{
-				OnTavernBrawlButtonPressed(e);
-			}
-			else if (boxMenuButton == m_OpenPacksButton)
-			{
-				OnOpenPacksButtonPressed(e);
-			}
-			else if (boxMenuButton == m_CollectionButton && flag2)
-			{
-				OnCollectionButtonPressed(e);
-			}
-			else if (boxMenuButton == m_setRotationButton)
-			{
-				OnSetRotationButtonPressed(e);
-			}
+		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+		bool flag = false;
+		bool flag2 = false;
+		if (netObject != null)
+		{
+			flag = netObject.Games.Tournament;
+			flag2 = netObject.Collection.Manager;
+		}
+		if (m_newPlayerModeBanner.activeSelf && boxMenuButton != m_TavernBrawlButton)
+		{
+			m_newPlayerModeBanner.SetActive(value: false);
+		}
+		if (boxMenuButton == m_PlayButton && flag)
+		{
+			OnTraditionalModeButtonPressed(e);
+		}
+		else if (boxMenuButton == m_BattleGroundsButton)
+		{
+			OnBattleGroundsButtonPressed(e);
+		}
+		else if (boxMenuButton == m_GameModesButton)
+		{
+			OnModesButtonPressed(e);
 		}
+		else if (boxMenuButton == m_TavernBrawlButton)
+		{
+			OnTavernBrawlButtonPressed(e);
+		}
+		else if (boxMenuButton == m_OpenPacksButton)
+		{
+			OnOpenPacksButtonPressed(e);
+		}
+		else if (boxMenuButton == m_CollectionButton && flag2)
+		{
+			OnCollectionButtonPressed(e);
+		}
+		else if (boxMenuButton == m_setRotationButton)
+		{
+			OnSetRotationButtonPressed(e);
+		}
+	}
 	}
 
 	private void OnButtonMouseOver(UIEvent e)
@@ -2521,16 +2523,16 @@ public class Box : MonoBehaviour
 		if (tooltipZone == null || (m_tutorialPreviewController != null && m_tutorialPreviewController.IsPlayingPreview))
 		{
 			return;
-		}
+			}
 		string text = "";
 		string key = "GLUE_TOOLTIP_BUTTON_DISABLED_DESC";
 		if (tooltipZone.targetObject == m_PlayButton.gameObject)
-		{
+			{
 			text = "GLUE_TOOLTIP_BUTTON_TRADITIONAL_HEADLINE";
 			key = "GLUE_TOOLTIP_BUTTON_TRADITIONAL_DESC";
-		}
+			}
 		else if (tooltipZone.targetObject == m_BattleGroundsButton.gameObject)
-		{
+			{
 			text = "GLUE_TOOLTIP_BUTTON_BACON_HEADLINE";
 			if (!m_BattleGroundsButton.CanDownloadMode() || DownloadManager.IsModuleReadyToPlay(DownloadTags.Content.Bgs))
 			{
@@ -2545,14 +2547,14 @@ public class Box : MonoBehaviour
 				long moduleDownloadSize = DownloadManager.GetModuleDownloadSize(DownloadTags.Content.Bgs);
 				key = GameStrings.Format("GLUE_TOOLTIP_BUTTON_BACON_DESC_DOWNLOAD_REQUIRED", DownloadUtils.FormatBytesAsHumanReadable(moduleDownloadSize));
 			}
-		}
+			}
 		else if (tooltipZone.targetObject == m_GameModesButton.gameObject)
-		{
-			text = "GLUE_TOOLTIP_BUTTON_GAME_MODES_HEADLINE";
+			{
+				text = "GLUE_TOOLTIP_BUTTON_GAME_MODES_HEADLINE";
 			key = ((!GameModeUtils.CanAccessGameModes()) ? "GLUE_TOOLTIP_BUTTON_GAME_MODES_LOCKED_DESC" : "GLUE_TOOLTIP_BUTTON_GAME_MODES_DESC");
-		}
+			}
 		else if (tooltipZone.targetObject == m_TavernBrawlButton.gameObject)
-		{
+			{
 			text = "GLUE_TOOLTIP_BUTTON_TAVERN_BRAWL_HEADLINE";
 			key = "GLUE_TOOLTIP_BUTTON_TAVERN_BRAWL_DESC";
 			if (!TavernBrawlManager.Get().CanEnterStandardTavernBrawl(out var reason))
@@ -2561,17 +2563,17 @@ public class Box : MonoBehaviour
 			}
 		}
 		else if (tooltipZone.targetObject == m_OpenPacksButton.gameObject)
-		{
+			{
 			text = "GLUE_TOOLTIP_BUTTON_PACKOPEN_HEADLINE";
 			key = "GLUE_TOOLTIP_BUTTON_PACKOPEN_DESC";
-		}
+			}
 		else if (tooltipZone.targetObject == m_CollectionButton.gameObject)
-		{
+			{
 			text = "GLUE_TOOLTIP_BUTTON_COLLECTION_HEADLINE";
 			key = "GLUE_TOOLTIP_BUTTON_COLLECTION_DESC";
-		}
+			}
 		if (text != "")
-		{
+			{
 			tooltipZone.ShowBoxTooltip(GameStrings.Get(text), GameStrings.Get(key));
 		}
 	}
@@ -2582,12 +2584,12 @@ public class Box : MonoBehaviour
 		if (!OnHoverDisabledButtons.Contains(element))
 		{
 			TooltipZone component = element.gameObject.GetComponent<TooltipZone>();
-			if (!(component == null))
-			{
-				component.HideTooltip();
-			}
+		if (!(component == null))
+		{
+			component.HideTooltip();
 		}
 	}
+	}
 
 	public virtual void OnStartButtonPressed(UIEvent e)
 	{
@@ -2631,6 +2633,8 @@ public class Box : MonoBehaviour
 
 	public virtual void OnSetRotationButtonPressed(UIEvent e)
 	{
+		// Disallow this in case someone misclicks using OCR as they would be in trouble
+		return;
 		Log.Box.Print("Set Rotation Button Pressed!");
 		if (!ServiceManager.IsAvailable<SceneMgr>())
 		{
@@ -2760,11 +2764,11 @@ public class Box : MonoBehaviour
 		{
 			SceneMgr.Get().SetNextMode(SceneMgr.Mode.TAVERN_BRAWL);
 			if (TavernBrawlManager.Get().IsFirstTimeSeeingThisFeature)
-			{
+		{
 				DoTavernBrawlIntroVO();
-			}
-			else
-			{
+		}
+		else
+		{
 				PlayTavernBrawlCrowdSFX();
 			}
 		}
@@ -2778,8 +2782,8 @@ public class Box : MonoBehaviour
 		}
 		else if (SceneMgr.Get() != null && !DialogManager.Get().ShowingDialog())
 		{
-			FireButtonPressEvent(ButtonType.GAME_MODES);
-		}
+				FireButtonPressEvent(ButtonType.GAME_MODES);
+			}
 	}
 
 	private void ShowTraditionalPreviewVideo()
@@ -2843,7 +2847,7 @@ public class Box : MonoBehaviour
 		DownloadConfirmationPopup.DownloadConfirmationPopupData confirmationPopupData = new DownloadConfirmationPopup.DownloadConfirmationPopupData(moduleTag, OnDownloadPopupYesClicked, OnDownloadPopupNoClicked);
 		if (downloadPromptTextOverride == "")
 		{
-			m_downloadConfirmationPopup.Init(confirmationPopupData);
+		m_downloadConfirmationPopup.Init(confirmationPopupData);
 		}
 		else
 		{
@@ -2933,6 +2937,7 @@ public class Box : MonoBehaviour
 		if (!IsShopButtonReadyToOpen(out var unableToOpenReason, out var reasonLogLevel))
 		{
 			Log.Store.Print(reasonLogLevel, verbose: false, unableToOpenReason);
+			AccessibilityMgr.Output(AccessibleHub.Get(), GameStrings.Get("GLUE_SHOP_CLOSED_ALERT_HEADER"));
 			return;
 		}
 		FireButtonPressEvent(ButtonType.STORE);
@@ -3346,13 +3351,13 @@ public class Box : MonoBehaviour
 		bool flag4 = m_railroadManager.ShouldHideButtonType(ButtonType.JOURNAL);
 		bool flag5 = m_railroadManager.ShouldDisableButtonType(ButtonType.JOURNAL);
 		if (num2 || flag3 || flag4)
-		{
+			{
 			m_journalButtonWidget.Hide();
 			m_journalButtonWidget.TriggerEvent("DISABLE_INTERACTION");
 			DisableButton(m_QuestLogButton);
 			return;
 		}
-		m_journalButtonWidget.Show();
+				m_journalButtonWidget.Show();
 		if (flag5)
 		{
 			DisableButton(m_QuestLogButton);
@@ -3366,18 +3371,18 @@ public class Box : MonoBehaviour
 	}
 
 	private void DisableAllBoxButtons(bool updateText)
-	{
-		DisableButton(m_PlayButton);
-		DisableButton(m_BattleGroundsButton);
-		DisableButton(m_TavernBrawlButton);
-		DisableButton(m_GameModesButton);
+			{
+				DisableButton(m_PlayButton);
+				DisableButton(m_BattleGroundsButton);
+				DisableButton(m_TavernBrawlButton);
+				DisableButton(m_GameModesButton);
 		DisableButton(m_OpenPacksButton);
 		DisableButton(m_CollectionButton);
 		if (updateText)
 		{
-			ToggleButtonTextureState(enabled: false, m_PlayButton);
-			ToggleButtonTextureState(enabled: false, m_BattleGroundsButton);
-			ToggleButtonTextureState(enabled: false, m_TavernBrawlButton);
+				ToggleButtonTextureState(enabled: false, m_PlayButton);
+				ToggleButtonTextureState(enabled: false, m_BattleGroundsButton);
+				ToggleButtonTextureState(enabled: false, m_TavernBrawlButton);
 			ToggleButtonTextureState(enabled: false, m_GameModesButton);
 		}
 	}
diff --git a/Assembly-CSharp/ButtonListMenu.cs b/Assembly-CSharp/ButtonListMenu.cs
index 6048edb..9c50500 100644
--- a/Assembly-CSharp/ButtonListMenu.cs
+++ b/Assembly-CSharp/ButtonListMenu.cs
@@ -12,7 +12,7 @@ public abstract class ButtonListMenu : MonoBehaviour
 
 	private bool m_isShown;
 
-	private List<UIBButton> m_allButtons = new List<UIBButton>();
+	protected List<UIBButton> m_allButtons = new List<UIBButton>();
 
 	private List<GameObject> m_horizontalDividers = new List<GameObject>();
 
diff --git a/Assembly-CSharp/Card.cs b/Assembly-CSharp/Card.cs
index 90267db..e1d2b8d 100644
--- a/Assembly-CSharp/Card.cs
+++ b/Assembly-CSharp/Card.cs
@@ -11,6 +11,7 @@ using Hearthstone.Progression;
 using HutongGames.PlayMaker;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class Card : MonoBehaviour
 {
@@ -493,8 +494,8 @@ public class Card : MonoBehaviour
 		}
 		else
 		{
-			this.ActivateLegendaryHeroAnimEvent(LegendaryHeroAnimations.HeroPower);
-		}
+		this.ActivateLegendaryHeroAnimEvent(LegendaryHeroAnimations.HeroPower);
+	}
 	}
 
 	public void OnDestroy()
@@ -551,10 +552,10 @@ public class Card : MonoBehaviour
 				SoundManager.Get().LoadAndPlay("collection_manager_card_mouse_over.prefab:0d4e20bc78956bc48b5e2963ec39211c", base.gameObject);
 			}
 		}
-		if (ShouldShowCardsInTooltip())
-		{
-			m_cardsInTooltip.NotifyMousedOver();
-		}
+			if (ShouldShowCardsInTooltip())
+			{
+				m_cardsInTooltip.NotifyMousedOver();
+			}
 		if (m_entity.IsControlledByFriendlySidePlayer() && (m_entity.IsHero() || m_zone is ZonePlay) && !m_transitioningZones)
 		{
 			bool flag = m_entity.HasSpellPower() || m_entity.HasSpellPowerDouble();
@@ -642,60 +643,60 @@ public class Card : MonoBehaviour
 						m_evolutionCardActor.Destroy();
 					}
 					using DefLoader.DisposableCardDef disposableCardDef = DefLoader.Get().GetCardDef(text);
-					if (disposableCardDef == null)
-					{
-						Log.Gameplay.PrintError("Card.NotifyMousedOver(): Unable to load CardDef for card ID {0}.", text);
-						return;
-					}
-					EntityDef entityDef = DefLoader.Get().GetEntityDef(text);
-					if (entityDef == null)
-					{
-						Log.Gameplay.PrintError("Card.NotifyMousedOver(): Unable to load EntityDef for card ID {0}.", text);
-						return;
-					}
-					GameObject gameObject = AssetLoader.Get().InstantiatePrefab(ActorNames.GetHandActor(entityDef, GetEntity().GetPremiumType()), AssetLoadingOptions.IgnorePrefabPosition);
-					if (gameObject == null)
-					{
-						Log.Gameplay.PrintError("Card.NotifyMousedOver(): Unable to load Hand Actor for entity def {0}.", entityDef);
-						return;
-					}
-					LayerUtils.SetLayer(gameObject, base.gameObject.layer);
-					gameObject.transform.parent = base.gameObject.transform;
-					TransformUtil.Identity(gameObject);
-					m_evolutionCardActor = gameObject.GetComponentInChildren<Actor>();
-					m_evolutionCardActor.SetEntityDef(entityDef);
-					m_evolutionCardActor.SetCardDef(disposableCardDef);
-					m_evolutionCardActor.SetPremium(GetEntity().GetPremiumType());
-					m_evolutionCardActor.SetWatermarkCardSetOverride(GetEntity().GetWatermarkCardSetOverride());
-					m_evolutionCardActor.UpdateDynamicTextFromQuestEntity(GetEntity());
-					if (m_evolutionCardActor.UseTechLevelManaGem())
-					{
-						Spell spell = m_evolutionCardActor.GetSpell(SpellType.TECH_LEVEL_MANA_GEM);
-						if (spell != null)
+						if (disposableCardDef == null)
 						{
-							spell.GetComponent<PlayMakerFSM>().FsmVariables.GetFsmInt("TechLevel").Value = entityDef.GetTechLevel();
-							spell.ActivateState(SpellStateType.BIRTH);
+							Log.Gameplay.PrintError("Card.NotifyMousedOver(): Unable to load CardDef for card ID {0}.", text);
+							return;
 						}
+						EntityDef entityDef = DefLoader.Get().GetEntityDef(text);
+						if (entityDef == null)
+						{
+							Log.Gameplay.PrintError("Card.NotifyMousedOver(): Unable to load EntityDef for card ID {0}.", text);
+							return;
+						}
+						GameObject gameObject = AssetLoader.Get().InstantiatePrefab(ActorNames.GetHandActor(entityDef, GetEntity().GetPremiumType()), AssetLoadingOptions.IgnorePrefabPosition);
+						if (gameObject == null)
+						{
+							Log.Gameplay.PrintError("Card.NotifyMousedOver(): Unable to load Hand Actor for entity def {0}.", entityDef);
+							return;
+						}
+						LayerUtils.SetLayer(gameObject, base.gameObject.layer);
+						gameObject.transform.parent = base.gameObject.transform;
+						TransformUtil.Identity(gameObject);
+						m_evolutionCardActor = gameObject.GetComponentInChildren<Actor>();
+						m_evolutionCardActor.SetEntityDef(entityDef);
+						m_evolutionCardActor.SetCardDef(disposableCardDef);
+						m_evolutionCardActor.SetPremium(GetEntity().GetPremiumType());
+						m_evolutionCardActor.SetWatermarkCardSetOverride(GetEntity().GetWatermarkCardSetOverride());
+						m_evolutionCardActor.UpdateDynamicTextFromQuestEntity(GetEntity());
+						if (m_evolutionCardActor.UseTechLevelManaGem())
+						{
+							Spell spell = m_evolutionCardActor.GetSpell(SpellType.TECH_LEVEL_MANA_GEM);
+							if (spell != null)
+							{
+								spell.GetComponent<PlayMakerFSM>().FsmVariables.GetFsmInt("TechLevel").Value = entityDef.GetTechLevel();
+								spell.ActivateState(SpellStateType.BIRTH);
+							}
+						}
+						else if (m_evolutionCardActor.UseCoinManaGem())
+						{
+							m_evolutionCardActor.ActivateSpellBirthState(SpellType.COIN_MANA_GEM);
+						}
+						GameObject gameObject2 = GameObjectUtils.FindChildBySubstring(gameObject, "EvolutionVFX");
+						if (gameObject2 != null)
+						{
+							gameObject2.SetActive(value: true);
+						}
+						if (m_actor.IsOnRightSideOfZonePlay())
+						{
+							m_evolutionCardActor.transform.localPosition = EVOLUTION_CARD_OFFSET_LEFT;
+						}
+						else
+						{
+							m_evolutionCardActor.transform.localPosition = EVOLUTION_CARD_OFFSET_RIGHT;
+						}
+						m_evolutionCardActor.UpdateAllComponents();
 					}
-					else if (m_evolutionCardActor.UseCoinManaGem())
-					{
-						m_evolutionCardActor.ActivateSpellBirthState(SpellType.COIN_MANA_GEM);
-					}
-					GameObject gameObject2 = GameObjectUtils.FindChildBySubstring(gameObject, "EvolutionVFX");
-					if (gameObject2 != null)
-					{
-						gameObject2.SetActive(value: true);
-					}
-					if (m_actor.IsOnRightSideOfZonePlay())
-					{
-						m_evolutionCardActor.transform.localPosition = EVOLUTION_CARD_OFFSET_LEFT;
-					}
-					else
-					{
-						m_evolutionCardActor.transform.localPosition = EVOLUTION_CARD_OFFSET_RIGHT;
-					}
-					m_evolutionCardActor.UpdateAllComponents();
-				}
 				else if (m_evolutionCardActor != null)
 				{
 					m_evolutionCardActor.gameObject.SetActive(value: true);
@@ -1947,14 +1948,14 @@ public class Card : MonoBehaviour
 	}
 
 	private EmoteEntry GetEmoteEntryExact(EmoteType emoteType)
-	{
-		foreach (EmoteEntry emote in m_emotes)
-		{
-			if (emote.GetEmoteType() == emoteType)
 			{
-				return emote;
-			}
-		}
+				foreach (EmoteEntry emote in m_emotes)
+				{
+			if (emote.GetEmoteType() == emoteType)
+					{
+						return emote;
+					}
+				}
 		return null;
 	}
 
@@ -2098,8 +2099,8 @@ public class Card : MonoBehaviour
 	{
 		if (!m_suppressDeathEffects && !IsHeroUsingDeathSpellOverride())
 		{
-			if (!m_suppressDeathSounds)
-			{
+		if (!m_suppressDeathSounds)
+		{
 				ForceActivateDeathSoundSpells();
 			}
 			m_suppressDeathSounds = false;
@@ -2109,15 +2110,15 @@ public class Card : MonoBehaviour
 
 	public void ForceActivateDeathSoundSpells()
 	{
-		if (((m_emotes == null) ? (-1) : m_emotes.FindIndex((EmoteEntry e) => e != null && e.GetEmoteType() == EmoteType.DEATH_LINE)) >= 0)
-		{
-			PlayEmote(EmoteType.DEATH_LINE);
-		}
-		else
-		{
-			ActivateSoundSpellList(m_deathEffect.GetSoundSpells());
+			if (((m_emotes == null) ? (-1) : m_emotes.FindIndex((EmoteEntry e) => e != null && e.GetEmoteType() == EmoteType.DEATH_LINE)) >= 0)
+			{
+				PlayEmote(EmoteType.DEATH_LINE);
+			}
+			else
+			{
+				ActivateSoundSpellList(m_deathEffect.GetSoundSpells());
+			}
 		}
-	}
 
 	private bool IsHeroUsingDeathSpellOverride()
 	{
@@ -2235,10 +2236,10 @@ public class Card : MonoBehaviour
 		if (gameState != null)
 		{
 			gameEntity = gameState.GetGameEntity();
-			if (gameEntity == null)
-			{
-				return false;
-			}
+		if (gameEntity == null)
+		{
+			return false;
+		}
 		}
 		if (gameEntity != null && gameEntity.GetGameOptions().GetBooleanOption(GameEntityOption.DELAY_CARD_SOUND_SPELLS))
 		{
@@ -2385,10 +2386,10 @@ public class Card : MonoBehaviour
 					if (delaySec > 0f)
 					{
 						yield return new WaitForSeconds(delaySec);
-					}
 				}
+			}
 				if ((bool)emoteSoundSpell)
-				{
+		{
 					AudioSource activeAudioSource = emoteSoundSpell.GetActiveAudioSource();
 					if ((bool)activeAudioSource && (bool)activeAudioSource.clip && waitTime < activeAudioSource.clip.length)
 					{
@@ -2670,11 +2671,11 @@ public class Card : MonoBehaviour
 	{
 		SpellManager spellManager = SpellManager.Get();
 		if (asset != null && spellManager != null && asset is Spell spell)
-		{
-			spellManager.ReleaseSpell(spell);
+			{
+				spellManager.ReleaseSpell(spell);
 			asset = null;
+			}
 		}
-	}
 
 	private void DestroyEmoteList()
 	{
@@ -2901,7 +2902,7 @@ public class Card : MonoBehaviour
 			}
 			if (m_actor != null)
 			{
-				m_actor.UpdateAllComponents();
+			m_actor.UpdateAllComponents();
 			}
 			break;
 		case GAME_TAG.LETTUCE_IS_COMBAT_ACTION_TAKEN:
@@ -2946,7 +2947,7 @@ public class Card : MonoBehaviour
 			if (m_entity != null && (m_entity.IsControlledByOpposingSidePlayer() || (GameMgr.Get() != null && GameMgr.Get().IsSpectator())))
 			{
 				StartCoroutine(WaitAndForgeCard());
-			}
+		}
 			break;
 		case GAME_TAG.EXHAUSTED:
 			if (m_actor != null)
@@ -3533,16 +3534,16 @@ public class Card : MonoBehaviour
 		while (true)
 		{
 			if (m_actor == null || m_actor.gameObject == null)
-			{
-				yield break;
-			}
+		{
+			yield break;
+		}
 			MinionShake componentInChildren = m_actor.gameObject.GetComponentInChildren<MinionShake>();
 			if (componentInChildren == null)
-			{
-				yield break;
-			}
+		{
+			yield break;
+		}
 			if (!componentInChildren.isShaking())
-			{
+		{
 				break;
 			}
 			yield return null;
@@ -3572,13 +3573,13 @@ public class Card : MonoBehaviour
 			}
 			if (flag)
 			{
-				string text = (exhausted ? "hero_power_icon_flip_off.prefab:621ead6ff672f5b4bbfd6578ee217a42" : "hero_power_icon_flip_on.prefab:e1491b367801f6b4395dc63ce0b08f0a");
-				SoundManager.Get().LoadAndPlay(text);
-			}
+			string text = (exhausted ? "hero_power_icon_flip_off.prefab:621ead6ff672f5b4bbfd6578ee217a42" : "hero_power_icon_flip_on.prefab:e1491b367801f6b4395dc63ce0b08f0a");
+			SoundManager.Get().LoadAndPlay(text);
+		}
 		}
 		if (m_actor.GetComponent<Animation>() != null)
 		{
-			m_actor.GetComponent<Animation>().Play(animationName);
+		m_actor.GetComponent<Animation>().Play(animationName);
 		}
 		Spell playSpell;
 		while (true)
@@ -3588,8 +3589,8 @@ public class Card : MonoBehaviour
 			{
 				break;
 			}
-			yield return null;
-		}
+				yield return null;
+			}
 		SetInputEnabled(enabled: true);
 		if (exhausted && (GameState.Get()?.IsValidOption(m_entity) ?? false) && !m_entity.HasSubCards() && playSpell != null)
 		{
@@ -3639,7 +3640,7 @@ public class Card : MonoBehaviour
 		}
 		if (m_actor.GetComponent<Animation>() != null)
 		{
-			m_actor.GetComponent<Animation>().Play(animationName);
+		m_actor.GetComponent<Animation>().Play(animationName);
 		}
 		Spell spell = GetPlaySpell(0);
 		if (spell != null)
@@ -4114,7 +4115,7 @@ public class Card : MonoBehaviour
 			{
 				if (fallbackToDefault)
 				{
-					ActivateDefaultSpawnSpell(OnSpellFinished_DefaultPlaySpawn);
+				ActivateDefaultSpawnSpell(OnSpellFinished_DefaultPlaySpawn);
 				}
 				return;
 			}
@@ -4139,17 +4140,17 @@ public class Card : MonoBehaviour
 		if (m_zone is ZoneHand)
 		{
 			if (m_entity.HasTag(GAME_TAG.GHOSTLY))
-			{
-				spellType = SpellType.GHOSTLY_SUMMON_IN;
-			}
+		{
+			spellType = SpellType.GHOSTLY_SUMMON_IN;
+		}
 			else if (m_entity.HasTag(GAME_TAG.CREATED_BY_TWINSPELL) && m_entity.HasTag(GAME_TAG.CREATOR))
+		{
+			Entity entity = GameState.Get().GetEntity(m_entity.GetTag(GAME_TAG.CREATOR));
+			if (entity != null && entity.IsTwinspell() && entity.GetTag(GAME_TAG.TWINSPELL_COPY) == GameUtils.TranslateCardIdToDbId(m_entity.GetCardId()))
 			{
-				Entity entity = GameState.Get().GetEntity(m_entity.GetTag(GAME_TAG.CREATOR));
-				if (entity != null && entity.IsTwinspell() && entity.GetTag(GAME_TAG.TWINSPELL_COPY) == GameUtils.TranslateCardIdToDbId(m_entity.GetCardId()))
-				{
-					spellType = ((GameState.Get().GetGameEntity().GetTag(GAME_TAG.USE_FAST_ACTOR_TRANSITION_ANIMATIONS) > 0) ? SpellType.TWINSPELL_SUMMON_IN_FAST : SpellType.TWINSPELL_SUMMON_IN);
-				}
+				spellType = ((GameState.Get().GetGameEntity().GetTag(GAME_TAG.USE_FAST_ACTOR_TRANSITION_ANIMATIONS) > 0) ? SpellType.TWINSPELL_SUMMON_IN_FAST : SpellType.TWINSPELL_SUMMON_IN);
 			}
+		}
 			else if (m_entity.HasTag(GAME_TAG.CREATED_BY_MINIATURIZE))
 			{
 				Entity entity2 = GameState.Get().GetEntity(m_entity.GetTag(GAME_TAG.CREATED_BY_MINIATURIZE));
@@ -4574,19 +4575,19 @@ public class Card : MonoBehaviour
 			else if (m_entity.IsPassable())
 			{
 				ShowPassableHover();
-			}
+		}
 			ManaCrystalMgr.Get().ProposeManaCrystalUsage(m_entity, fromDeckAction: true);
 		}
 		else
 		{
 			if (m_entity.IsTradeable())
-			{
-				HideTradeableHover();
-			}
-			else if (m_entity.IsForgeable())
-			{
-				HideForgeableHover();
-			}
+		{
+			HideTradeableHover();
+		}
+		else if (m_entity.IsForgeable())
+		{
+			HideForgeableHover();
+		}
 			else if (m_entity.IsPassable())
 			{
 				HidePassableHover();
@@ -4695,17 +4696,17 @@ public class Card : MonoBehaviour
 			m_actor.SetDeckActionHighlightState(DeckActionHighlightState.None);
 		}
 		else if (!m_overPlayfield)
-		{
+			{
 			m_actor.SetDeckActionHighlightState(DeckActionHighlightState.Green);
 		}
 		else
-		{
+				{
 			if (IsInDeckActionArea())
 			{
 				m_actor.SetDeckActionHighlightState(DeckActionHighlightState.Blue);
-				m_actor.SetActorState(ActorStateType.CARD_OVER_PLAYFIELD);
-				return true;
-			}
+					m_actor.SetActorState(ActorStateType.CARD_OVER_PLAYFIELD);
+					return true;
+				}
 			m_actor.SetDeckActionHighlightState(DeckActionHighlightState.None);
 		}
 		if (m_entity.HasTag(GAME_TAG.FORCE_GREEN_GLOW_ACTIVE) && m_entity.IsControlledByFriendlySidePlayer())
@@ -4782,28 +4783,28 @@ public class Card : MonoBehaviour
 		if (!flag4)
 		{
 			if (m_mousedOver)
+		{
+			if (m_entity.GetRealTimeAttackableByRush())
 			{
-				if (m_entity.GetRealTimeAttackableByRush())
-				{
-					m_actor.SetActorState(ActorStateType.CARD_ATTACKABLE_BY_RUSH_MOUSE_OVER);
-				}
+				m_actor.SetActorState(ActorStateType.CARD_ATTACKABLE_BY_RUSH_MOUSE_OVER);
+			}
 				else if (m_entity.GetRealTimeTitanAbilityUsable())
 				{
 					m_actor.SetActorState(ActorStateType.CARD_TITAN_ABILITY_MOUSE_OVER);
 				}
-				else
-				{
-					m_actor.SetActorState(ActorStateType.CARD_PLAYABLE_MOUSE_OVER);
-				}
-				return true;
+			else
+			{
+				m_actor.SetActorState(ActorStateType.CARD_PLAYABLE_MOUSE_OVER);
 			}
+			return true;
+		}
 			if (!m_mousedOver)
 			{
-				if (m_entity.GetRealTimeAttackableByRush())
-				{
-					m_actor.SetActorState(ActorStateType.CARD_ATTACKABLE_BY_RUSH);
-					return true;
-				}
+		if (m_entity.GetRealTimeAttackableByRush())
+		{
+			m_actor.SetActorState(ActorStateType.CARD_ATTACKABLE_BY_RUSH);
+			return true;
+		}
 				if (m_entity.GetRealTimeTitanAbilityUsable())
 				{
 					m_actor.SetActorState(ActorStateType.CARD_TITAN_ABILITY);
@@ -5515,11 +5516,11 @@ public class Card : MonoBehaviour
 		if (!m_alwaysShowCardsInTooltip)
 		{
 			if (m_zone is ZoneHand)
-			{
-				return m_entity.IsControlledByFriendlySidePlayer();
-			}
-			return false;
+		{
+			return m_entity.IsControlledByFriendlySidePlayer();
 		}
+		return false;
+	}
 		return true;
 	}
 
@@ -5816,10 +5817,10 @@ public class Card : MonoBehaviour
 				m_actor.Hide();
 				if (!GameMgr.Get().IsBattlegrounds() || m_entity == null || m_entity.GetRealTimeZone() == TAG_ZONE.HAND)
 				{
-					ActivateActorSpell(SpellType.SUMMON_IN, OnSpellFinished_DefaultHandSpawn);
-				}
+				ActivateActorSpell(SpellType.SUMMON_IN, OnSpellFinished_DefaultHandSpawn);
 			}
 		}
+		}
 		else if ((m_prevZone is ZoneGraveyard || m_prevZone is ZoneDeck) && m_zone.m_ServerTag == TAG_ZONE.PLAY)
 		{
 			ShowCard();
@@ -5957,7 +5958,7 @@ public class Card : MonoBehaviour
 					}
 					if (m_entity.HasTag(GAME_TAG.LINKED_ENTITY))
 					{
-						if (m_customSpawnSpellOverride != null)
+							if (m_customSpawnSpellOverride != null)
 						{
 							ActivateMinionSpawnEffects();
 						}
@@ -6029,23 +6030,23 @@ public class Card : MonoBehaviour
 		}
 		else if (m_prevZone is ZoneHand && (m_zone is ZonePlay || m_zone is ZoneHero))
 		{
-			ActivateActorSpells_HandToPlay(oldActor);
-			if (m_cardDef.CardDef.m_SuppressPlaySoundsOnSummon || m_entity.HasTag(GAME_TAG.CARD_DOES_NOTHING))
-			{
-				SuppressPlaySounds(suppress: true);
-			}
-			ActivateCharacterPlayEffects();
-			m_actor.Hide();
-			flag = true;
-			if (CardTypeBanner.Get() != null && CardTypeBanner.Get().HasCardDef && CardTypeBanner.Get().HasSameCardDef(m_cardDef.CardDef))
-			{
-				CardTypeBanner.Get().Hide();
-			}
-			if (m_entity.IsMinion())
-			{
-				m_prevZone.GetController().GetHeroCard().ActivateLegendaryHeroAnimEvent(LegendaryHeroAnimations.SummonMinion);
+				ActivateActorSpells_HandToPlay(oldActor);
+				if (m_cardDef.CardDef.m_SuppressPlaySoundsOnSummon || m_entity.HasTag(GAME_TAG.CARD_DOES_NOTHING))
+				{
+					SuppressPlaySounds(suppress: true);
+				}
+				ActivateCharacterPlayEffects();
+				m_actor.Hide();
+				flag = true;
+				if (CardTypeBanner.Get() != null && CardTypeBanner.Get().HasCardDef && CardTypeBanner.Get().HasSameCardDef(m_cardDef.CardDef))
+				{
+					CardTypeBanner.Get().Hide();
+				}
+				if (m_entity.IsMinion())
+				{
+					m_prevZone.GetController().GetHeroCard().ActivateLegendaryHeroAnimEvent(LegendaryHeroAnimations.SummonMinion);
+				}
 			}
-		}
 		else if (m_prevZone is ZoneHand && m_zone is ZoneWeapon)
 		{
 			if (ActivateActorSpells_HandToWeapon(oldActor))
@@ -6292,10 +6293,10 @@ public class Card : MonoBehaviour
 			if (m_prevZone != null && m_prevZone.m_Side != m_zone.m_Side)
 			{
 				if (m_prevZone is ZoneSecret && m_zone is ZoneSecret)
-				{
-					StartCoroutine(SwitchSecretSides());
-					flag = true;
-				}
+			{
+				StartCoroutine(SwitchSecretSides());
+				flag = true;
+			}
 				else if (m_prevZone is ZonePlay && m_zone is ZonePlay)
 				{
 					ActivateStateSpells();
@@ -6326,8 +6327,8 @@ public class Card : MonoBehaviour
 			ShowSecretQuestBirth();
 			flag = true;
 			m_actorReady = true;
-			ActivateStateSpells();
-		}
+				ActivateStateSpells();
+			}
 		if (!flag)
 		{
 			if ((bool)oldActor)
@@ -6512,6 +6513,7 @@ public class Card : MonoBehaviour
 		m_actor.Show();
 		m_actor.TurnOffCollider();
 		srcDeck.UpdateLayout();
+		AccessibleGameplay.Get().OnDrawCard(this);
 		PowerTask powerTaskToBlockCardDraw = GetPowerTaskToBlockCardDraw();
 		PowerTask cardDrawBlockingTask = powerTaskToBlockCardDraw;
 		while (iTween.Count(base.gameObject) > 0)
@@ -6608,6 +6610,7 @@ public class Card : MonoBehaviour
 	private IEnumerator DrawUnknownOpponentCard(ZoneHand handZone, ZoneDeck srcDeck)
 	{
 		SoundManager.Get().LoadAndPlay("draw_card_and_add_to_hand_opp_1.prefab:5a05fbb2c5833a94182e1b454647d5c8", base.gameObject);
+		AccessibleGameplay.Get().OnDrawUnknownOpponentCard(this);
 		base.gameObject.transform.rotation = IN_DECK_HIDDEN_ROTATION;
 		DetermineIfOverrideDrawTimeScale();
 		Transform pathStartTransform = GetPathStartTransform(srcDeck, revealOnDrawn: false);
@@ -6698,6 +6701,7 @@ public class Card : MonoBehaviour
 	private IEnumerator RevealDrawnOpponentCard(string handActorPath, Actor handActor, ZoneHand handZone, ZoneDeck srcDeck)
 	{
 		SoundManager.Get().LoadAndPlay("draw_card_1.prefab:19dd221ebfed9754e85ef1f104e0fddb", base.gameObject);
+		AccessibleGameplay.Get().OnRevealDrawnOpponentCard(this);
 		handActor.transform.parent = m_actor.transform.parent;
 		TransformUtil.CopyLocal(handActor, m_actor);
 		m_actor.Hide();
@@ -7522,6 +7526,7 @@ public class Card : MonoBehaviour
 	public IEnumerator AnimatePlayToDeck(GameObject mover, ZoneDeck deckZone, bool hideBackSide = false, float timeScale = 1f)
 	{
 		SoundManager.Get().LoadAndPlay("MinionToDeck_transition.prefab:8063f1b133f28e34aaeade8fcabe250c");
+		AccessibleGameplay.Get().OnCardToDeck(this);
 		Vector3 vector = deckZone.GetThicknessForLayout().GetMeshRenderer().bounds.center + IN_DECK_OFFSET;
 		if (m_entity != null && m_entity.IsMercenary())
 		{
@@ -8079,19 +8084,19 @@ public class Card : MonoBehaviour
 		Spell chosenSpell = GetBestDeathSpell() as Spell;
 		if (!(chosenSpell == null))
 		{
-			if (chosenSpell.DoesBlockServerEvents())
-			{
-				GameState.Get().AddServerBlockingSpell(chosenSpell);
-			}
-			yield return new WaitForSeconds(predelay);
-			ActivateSpell(chosenSpell, null);
-			CleanUpCustomSpell(chosenSpell, ref m_customDiscardSpell);
-			CleanUpCustomSpell(chosenSpell, ref m_customDiscardSpellOverride);
-			yield return new WaitForSeconds(postdelay);
-			m_doNotSort = false;
-			m_actor.SetBlockTextComponentUpdate(block: false);
-			finishedCallback?.Invoke();
+		if (chosenSpell.DoesBlockServerEvents())
+		{
+			GameState.Get().AddServerBlockingSpell(chosenSpell);
 		}
+		yield return new WaitForSeconds(predelay);
+		ActivateSpell(chosenSpell, null);
+		CleanUpCustomSpell(chosenSpell, ref m_customDiscardSpell);
+		CleanUpCustomSpell(chosenSpell, ref m_customDiscardSpellOverride);
+		yield return new WaitForSeconds(postdelay);
+		m_doNotSort = false;
+		m_actor.SetBlockTextComponentUpdate(block: false);
+		finishedCallback?.Invoke();
+	}
 	}
 
 	private bool HandlePlayActorDeath(Actor oldActor)
@@ -8249,41 +8254,41 @@ public class Card : MonoBehaviour
 		Spell spell = actor.GetSpell(SpellType.FORGEABLE_HAMMER_IMPACT);
 		if (!(spell == null))
 		{
-			bool value = false;
+		bool value = false;
 			if (m_entity != null && (m_entity.IsControlledByOpposingSidePlayer() || GameMgr.Get().IsSpectator()))
-			{
+		{
 				ZoneDeck zoneDeck = (m_entity.IsControlledByOpposingSidePlayer() ? ZoneMgr.Get().FindZoneOfType<ZoneDeck>(Player.Side.OPPOSING) : ZoneMgr.Get().FindZoneOfType<ZoneDeck>(Player.Side.FRIENDLY));
-				Vector3 position = base.gameObject.transform.position;
-				position.x = zoneDeck.gameObject.transform.position.x;
-				position.y = 1.2f;
-				position.z = zoneDeck.gameObject.transform.position.z;
-				base.gameObject.transform.position = position;
-				Vector3 eulerAngles = base.gameObject.transform.rotation.eulerAngles;
-				eulerAngles.y = 0f;
-				eulerAngles.z = 0f;
-				base.gameObject.transform.rotation = Quaternion.Euler(eulerAngles);
-				value = true;
-				iTween.Stop(base.gameObject);
-			}
-			spell.gameObject.transform.parent = null;
-			SetDoNotSort(on: true);
-			FsmBool fsmBool = spell.GetComponent<PlayMakerFSM>().FsmVariables.FindFsmBool("isOpponent");
-			if (fsmBool != null)
-			{
-				fsmBool.Value = value;
-			}
-			SpellUtils.ActivateStateIfNecessary(spell, SpellStateType.ACTION);
-			yield return new WaitForSeconds(1f);
-			SetDoNotSort(on: false);
-			ZoneHand zoneHand = GetZone() as ZoneHand;
-			if (zoneHand != null)
-			{
+			Vector3 position = base.gameObject.transform.position;
+			position.x = zoneDeck.gameObject.transform.position.x;
+			position.y = 1.2f;
+			position.z = zoneDeck.gameObject.transform.position.z;
+			base.gameObject.transform.position = position;
+			Vector3 eulerAngles = base.gameObject.transform.rotation.eulerAngles;
+			eulerAngles.y = 0f;
+			eulerAngles.z = 0f;
+			base.gameObject.transform.rotation = Quaternion.Euler(eulerAngles);
+			value = true;
+			iTween.Stop(base.gameObject);
+		}
+		spell.gameObject.transform.parent = null;
+		SetDoNotSort(on: true);
+		FsmBool fsmBool = spell.GetComponent<PlayMakerFSM>().FsmVariables.FindFsmBool("isOpponent");
+		if (fsmBool != null)
+		{
+			fsmBool.Value = value;
+		}
+		SpellUtils.ActivateStateIfNecessary(spell, SpellStateType.ACTION);
+		yield return new WaitForSeconds(1f);
+		SetDoNotSort(on: false);
+		ZoneHand zoneHand = GetZone() as ZoneHand;
+		if (zoneHand != null)
+		{
 				zoneHand.ClearDeckActionEntity();
-				zoneHand.UpdateLayout(null, forced: true);
-			}
-			yield return new WaitForSeconds(1f);
-			SpellManager.Get().ReleaseSpell(spell);
+			zoneHand.UpdateLayout(null, forced: true);
 		}
+		yield return new WaitForSeconds(1f);
+		SpellManager.Get().ReleaseSpell(spell);
+	}
 	}
 
 	private Spell GetBestNullZoneSpell()
@@ -8332,7 +8337,7 @@ public class Card : MonoBehaviour
 		{
 			return false;
 		}
-		Collider collider = Board.Get().FindCollider("DeckActionArea");
+		Collider collider = Board.Get().GetDeckActionArea();
 		if (collider == null)
 		{
 			return false;
diff --git a/Assembly-CSharp/CardBackInfoManager.cs b/Assembly-CSharp/CardBackInfoManager.cs
index a03fe27..908031c 100644
--- a/Assembly-CSharp/CardBackInfoManager.cs
+++ b/Assembly-CSharp/CardBackInfoManager.cs
@@ -5,579 +5,620 @@ using Hearthstone.DataModels;
 using Hearthstone.Store;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class CardBackInfoManager : MonoBehaviour, IStore
+public class CardBackInfoManager : MonoBehaviour, IStore, AccessibleUI
 {
-	private const string STATE_MAKE_FAVORITE = "MAKE_FAVORITE";
+    private const string STATE_MAKE_FAVORITE = "MAKE_FAVORITE";
 
-	private const string STATE_SUFFICIENT_CURRENCY = "SUFFICIENT_CURRENCY";
+    private const string STATE_SUFFICIENT_CURRENCY = "SUFFICIENT_CURRENCY";
 
-	private const string STATE_INSUFFICIENT_CURRENCY = "INSUFFICIENT_CURRENCY";
+    private const string STATE_INSUFFICIENT_CURRENCY = "INSUFFICIENT_CURRENCY";
 
-	private const string STATE_DISABLED = "DISABLED";
+    private const string STATE_DISABLED = "DISABLED";
 
-	private const string STATE_VISIBLE = "VISIBLE";
+    private const string STATE_VISIBLE = "VISIBLE";
 
-	private const string STATE_HIDDEN = "HIDDEN";
+    private const string STATE_HIDDEN = "HIDDEN";
 
-	private const string STATE_BLOCK_SCREEN = "BLOCK_SCREEN";
+    private const string STATE_BLOCK_SCREEN = "BLOCK_SCREEN";
 
-	private const string STATE_UNBLOCK_SCREEN = "UNBLOCK_SCREEN";
+    private const string STATE_UNBLOCK_SCREEN = "UNBLOCK_SCREEN";
 
-	public GameObject m_previewPane;
+    public GameObject m_previewPane;
 
-	public GameObject m_cardBackContainer;
+    public GameObject m_cardBackContainer;
 
-	public UberText m_title;
+    public UberText m_title;
 
-	public UberText m_description;
+    public UberText m_description;
 
-	public UIBButton m_buyButton;
+    public UIBButton m_buyButton;
 
-	public UIBButton m_favoriteButton;
+    public UIBButton m_favoriteButton;
 
-	public PegUIElement m_offClicker;
+    public PegUIElement m_offClicker;
 
-	public float m_animationTime = 0.5f;
+    public float m_animationTime = 0.5f;
 
-	public AsyncReference m_userActionVisualControllerReference;
+    public AsyncReference m_userActionVisualControllerReference;
 
-	public AsyncReference m_visibilityVisualControllerReference;
+    public AsyncReference m_visibilityVisualControllerReference;
 
-	public AsyncReference m_fullScreenBlockerWidgetReference;
+    public AsyncReference m_fullScreenBlockerWidgetReference;
 
-	[CustomEditField(T = EditType.SOUND_PREFAB)]
-	public string m_enterPreviewSound;
+    [CustomEditField(T = EditType.SOUND_PREFAB)]
+    public string m_enterPreviewSound;
 
-	[CustomEditField(T = EditType.SOUND_PREFAB)]
-	public string m_exitPreviewSound;
+    [CustomEditField(T = EditType.SOUND_PREFAB)]
+    public string m_exitPreviewSound;
 
-	private int? m_currentCardBackIdx;
+    private int? m_currentCardBackIdx;
 
-	private GameObject m_currentCardBack;
+    private GameObject m_currentCardBack;
 
-	private bool m_animating;
+    private bool m_animating;
 
-	private VisualController m_userActionVisualController;
+    private VisualController m_userActionVisualController;
 
-	private VisualController m_visibilityVisualController;
+    private VisualController m_visibilityVisualController;
 
-	private Widget m_fullScreenBlockerWidget;
+    private Widget m_fullScreenBlockerWidget;
 
-	private bool m_isStoreOpen;
+    private bool m_isStoreOpen;
 
-	private bool m_isStoreTransactionActive;
+    private bool m_isStoreTransactionActive;
 
-	private static CardBackInfoManager s_instance;
+    private static CardBackInfoManager s_instance;
 
-	private static bool s_isReadyingInstance;
+    private static bool s_isReadyingInstance;
 
-	private ScreenEffectsHandle m_screenEffectsHandle;
+    private ScreenEffectsHandle m_screenEffectsHandle;
 
-	public bool IsPreviewing { get; private set; }
+    public bool IsPreviewing { get; private set; }
 
-	public event Action OnOpened;
+    public event Action OnOpened;
 
-	public event Action<StoreClosedArgs> OnClosed;
+    public event Action<StoreClosedArgs> OnClosed;
 
-	public event Action OnReady;
+    public event Action OnReady;
 
-	public event Action<BuyProductEventArgs> OnProductPurchaseAttempt;
+    public event Action<BuyProductEventArgs> OnProductPurchaseAttempt;
 
-	public event Action OnProductOpened;
+    public event Action OnProductOpened;
 
-	public static CardBackInfoManager Get()
-	{
-		return s_instance;
-	}
+    public static CardBackInfoManager Get()
+    {
+        return s_instance;
+    }
 
-	public static void EnterPreviewWhenReady(CollectionCardVisual cardVisual)
-	{
-		CardBackInfoManager cardBackInfoManager = Get();
-		if (cardBackInfoManager != null)
-		{
-			cardBackInfoManager.EnterPreview(cardVisual);
-			return;
-		}
-		if (s_isReadyingInstance)
-		{
-			Debug.LogWarning("CardBackInfoManager:EnterPreviewWhenReady called while the info manager instance was being readied");
-			return;
-		}
-		string assetString = "CardBackInfoManager.prefab:d53d863de659e4cce97ba2ce0107fb49";
-		Widget widget = WidgetInstance.Create(assetString);
-		if (widget == null)
-		{
-			Debug.LogError("CardBackInfoManager:EnterPreviewWhenReady failed to create widget instance");
-			return;
-		}
-		s_isReadyingInstance = true;
-		widget.RegisterReadyListener(delegate
-		{
-			s_instance = widget.GetComponentInChildren<CardBackInfoManager>();
-			s_isReadyingInstance = false;
-			if (s_instance == null)
-			{
-				Debug.LogError("CardBackInfoManager:EnterPreviewWhenReady created widget instance but failed to get CardBackInfoManager component");
-			}
-			else
-			{
-				s_instance.EnterPreview(cardVisual);
-			}
-		});
-	}
-
-	public static bool IsLoadedAndShowingPreview()
-	{
-		if (!s_instance)
-		{
-			return false;
-		}
-		return s_instance.IsPreviewing;
-	}
-
-	private void Awake()
-	{
-		m_previewPane.SetActive(value: false);
-		SetupUI();
-	}
-
-	private void Start()
-	{
-		m_userActionVisualControllerReference.RegisterReadyListener<VisualController>(OnUserActionVisualControllerReady);
-		m_visibilityVisualControllerReference.RegisterReadyListener<VisualController>(OnVisibilityVisualControllerReady);
-		m_fullScreenBlockerWidgetReference.RegisterReadyListener<Widget>(OnFullScreenBlockerWidgetReady);
-		m_screenEffectsHandle = new ScreenEffectsHandle(this);
-	}
-
-	private void OnDestroy()
-	{
-		if (CardBackManager.Get() != null)
-		{
-			CardBackManager.Get().OnFavoriteCardBacksChanged -= OnFavoriteCardBackChanged;
-		}
-		s_instance = null;
-	}
-
-	public void EnterPreview(CollectionCardVisual cardVisual)
-	{
-		this.OnProductOpened?.Invoke();
-		Actor actor = cardVisual.GetActor();
-		if (actor == null)
-		{
-			Debug.LogError("Unable to obtain actor from card visual.");
-			return;
-		}
-		CollectionCardBack component = actor.GetComponent<CollectionCardBack>();
-		if (component == null)
-		{
-			Debug.LogError("Actor does not contain a CollectionCardBack component!");
-		}
-		else
-		{
-			EnterPreview(component.GetCardBackId(), cardVisual);
-		}
-	}
-
-	public void EnterPreview(int cardBackIdx, CollectionCardVisual cardVisual)
-	{
-		if (!m_animating)
-		{
-			if (m_currentCardBack != null)
-			{
-				UnityEngine.Object.Destroy(m_currentCardBack);
-				m_currentCardBack = null;
-			}
-			m_animating = true;
-			CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get()?.GetCollectibleDisplay() as CollectionManagerDisplay;
-			if (collectionManagerDisplay != null)
-			{
-				collectionManagerDisplay.HideCardBackTips();
-			}
-			CardBackDbfRecord record = GameDbf.CardBack.GetRecord(cardBackIdx);
-			m_title.Text = record.Name;
-			m_description.Text = record.Description;
-			m_currentCardBackIdx = cardBackIdx;
-			IsPreviewing = true;
-			SetupCardBackStore();
-			UpdateView();
-			if (!CardBackManager.Get().LoadCardBackByIndex(cardBackIdx, delegate(CardBackManager.LoadCardBackData cardBackData)
-			{
-				GameObject gameObject = cardBackData.m_GameObject;
-				gameObject.name = "CARD_BACK_" + cardBackIdx;
-				LayerUtils.SetLayer(gameObject, m_cardBackContainer.gameObject.layer);
-				GameUtils.SetParent(gameObject, m_cardBackContainer);
-				m_currentCardBack = gameObject;
-				if ((bool)UniversalInputManager.UsePhoneUI)
-				{
-					m_currentCardBack.transform.localPosition = Vector3.zero;
-				}
-				else
-				{
-					m_currentCardBack.transform.position = cardVisual.transform.position;
-					Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
-					tweenHashTable.Add("name", "FinishBigCardMove");
-					tweenHashTable.Add("position", m_cardBackContainer.transform.position);
-					tweenHashTable.Add("time", m_animationTime);
-					iTween.MoveTo(m_currentCardBack.gameObject, tweenHashTable);
-					Hashtable tweenHashTable2 = iTweenManager.Get().GetTweenHashTable();
-					tweenHashTable2.Add("scale", Vector3.one);
-					tweenHashTable2.Add("time", m_animationTime);
+    public static void EnterPreviewWhenReady(CollectionCardVisual cardVisual)
+    {
+        CardBackInfoManager cardBackInfoManager = Get();
+        if (cardBackInfoManager != null)
+        {
+            cardBackInfoManager.EnterPreview(cardVisual);
+            return;
+        }
+        if (s_isReadyingInstance)
+        {
+            Debug.LogWarning("CardBackInfoManager:EnterPreviewWhenReady called while the info manager instance was being readied");
+            return;
+        }
+        string assetString = "CardBackInfoManager.prefab:d53d863de659e4cce97ba2ce0107fb49";
+        Widget widget = WidgetInstance.Create(assetString);
+        if (widget == null)
+        {
+            Debug.LogError("CardBackInfoManager:EnterPreviewWhenReady failed to create widget instance");
+            return;
+        }
+        s_isReadyingInstance = true;
+        widget.RegisterReadyListener(delegate
+        {
+            s_instance = widget.GetComponentInChildren<CardBackInfoManager>();
+            s_isReadyingInstance = false;
+            if (s_instance == null)
+            {
+                Debug.LogError("CardBackInfoManager:EnterPreviewWhenReady created widget instance but failed to get CardBackInfoManager component");
+            }
+            else
+            {
+                s_instance.EnterPreview(cardVisual);
+            }
+        });
+    }
+
+    public static bool IsLoadedAndShowingPreview()
+    {
+        if (!s_instance)
+        {
+            return false;
+        }
+        return s_instance.IsPreviewing;
+    }
+
+    private void Awake()
+    {
+        m_previewPane.SetActive(value: false);
+        SetupUI();
+    }
+
+    private void Start()
+    {
+        m_userActionVisualControllerReference.RegisterReadyListener<VisualController>(OnUserActionVisualControllerReady);
+        m_visibilityVisualControllerReference.RegisterReadyListener<VisualController>(OnVisibilityVisualControllerReady);
+        m_fullScreenBlockerWidgetReference.RegisterReadyListener<Widget>(OnFullScreenBlockerWidgetReady);
+        m_screenEffectsHandle = new ScreenEffectsHandle(this);
+    }
+
+    private void OnDestroy()
+    {
+        HideThis();
+        if (CardBackManager.Get() != null)
+        {
+            CardBackManager.Get().OnFavoriteCardBacksChanged -= OnFavoriteCardBackChanged;
+        }
+        s_instance = null;
+    }
+
+    public void EnterPreview(CollectionCardVisual cardVisual)
+    {
+        this.OnProductOpened?.Invoke();
+        Actor actor = cardVisual.GetActor();
+        if (actor == null)
+        {
+            Debug.LogError("Unable to obtain actor from card visual.");
+            return;
+        }
+        CollectionCardBack component = actor.GetComponent<CollectionCardBack>();
+        if (component == null)
+        {
+            Debug.LogError("Actor does not contain a CollectionCardBack component!");
+        }
+        else
+        {
+            EnterPreview(component.GetCardBackId(), cardVisual);
+        }
+    }
+
+    public void EnterPreview(int cardBackIdx, CollectionCardVisual cardVisual)
+    {
+        if (!m_animating)
+        {
+            if (m_currentCardBack != null)
+            {
+                UnityEngine.Object.Destroy(m_currentCardBack);
+                m_currentCardBack = null;
+            }
+            m_animating = true;
+            CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get()?.GetCollectibleDisplay() as CollectionManagerDisplay;
+            if (collectionManagerDisplay != null)
+            {
+                collectionManagerDisplay.HideCardBackTips();
+            }
+            CardBackDbfRecord record = GameDbf.CardBack.GetRecord(cardBackIdx);
+            m_title.Text = record.Name;
+            m_description.Text = record.Description;
+            m_currentCardBackIdx = cardBackIdx;
+            IsPreviewing = true;
+            SetupCardBackStore();
+            UpdateView();
+            if (!CardBackManager.Get().LoadCardBackByIndex(cardBackIdx, delegate (CardBackManager.LoadCardBackData cardBackData)
+            {
+                GameObject gameObject = cardBackData.m_GameObject;
+                gameObject.name = "CARD_BACK_" + cardBackIdx;
+                LayerUtils.SetLayer(gameObject, m_cardBackContainer.gameObject.layer);
+                GameUtils.SetParent(gameObject, m_cardBackContainer);
+                m_currentCardBack = gameObject;
+                if ((bool)UniversalInputManager.UsePhoneUI)
+                {
+                    m_currentCardBack.transform.localPosition = Vector3.zero;
+                }
+                else
+                {
+                    m_currentCardBack.transform.position = cardVisual.transform.position;
+                    Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
+                    tweenHashTable.Add("name", "FinishBigCardMove");
+                    tweenHashTable.Add("position", m_cardBackContainer.transform.position);
+                    tweenHashTable.Add("time", m_animationTime);
+                    iTween.MoveTo(m_currentCardBack.gameObject, tweenHashTable);
+                    Hashtable tweenHashTable2 = iTweenManager.Get().GetTweenHashTable();
+                    tweenHashTable2.Add("scale", Vector3.one);
+                    tweenHashTable2.Add("time", m_animationTime);
 					tweenHashTable2.Add("easetype", iTween.EaseType.easeOutQuad);
-					iTween.ScaleTo(m_currentCardBack.gameObject, tweenHashTable2);
-					Hashtable tweenHashTable3 = iTweenManager.Get().GetTweenHashTable();
-					tweenHashTable3.Add("amount", new Vector3(0f, 0f, 75f));
-					tweenHashTable3.Add("time", 2.5f);
+                    iTween.ScaleTo(m_currentCardBack.gameObject, tweenHashTable2);
+                    Hashtable tweenHashTable3 = iTweenManager.Get().GetTweenHashTable();
+                    tweenHashTable3.Add("amount", new Vector3(0f, 0f, 75f));
+                    tweenHashTable3.Add("time", 2.5f);
 					iTween.PunchRotation(m_currentCardBack, tweenHashTable3);
-				}
-				m_currentCardBack.transform.localScale = Vector3.one;
-				m_currentCardBack.transform.localRotation = Quaternion.identity;
-				m_previewPane.SetActive(value: true);
-				m_offClicker.gameObject.SetActive(value: true);
-				Hashtable tweenHashTable4 = iTweenManager.Get().GetTweenHashTable();
-				tweenHashTable4.Add("scale", new Vector3(0.01f, 0.01f, 0.01f));
-				tweenHashTable4.Add("time", m_animationTime);
+                }
+                m_currentCardBack.transform.localScale = Vector3.one;
+                m_currentCardBack.transform.localRotation = Quaternion.identity;
+                m_previewPane.SetActive(value: true);
+                m_offClicker.gameObject.SetActive(value: true);
+                Hashtable tweenHashTable4 = iTweenManager.Get().GetTweenHashTable();
+                tweenHashTable4.Add("scale", new Vector3(0.01f, 0.01f, 0.01f));
+                tweenHashTable4.Add("time", m_animationTime);
 				tweenHashTable4.Add("easetype", iTween.EaseType.easeOutCirc);
-				tweenHashTable4.Add("oncomplete", (Action<object>)delegate
-				{
-					m_animating = false;
-				});
-				iTween.ScaleFrom(m_previewPane, tweenHashTable4);
-			}))
-			{
-				Debug.LogError($"Unable to load card back ID {cardBackIdx} for preview.");
-				m_animating = false;
-			}
-			if (!string.IsNullOrEmpty(m_enterPreviewSound))
-			{
-				SoundManager.Get().LoadAndPlay(m_enterPreviewSound);
-			}
-			ScreenEffectParameters blurVignetteDesaturatePerspective = ScreenEffectParameters.BlurVignetteDesaturatePerspective;
-			blurVignetteDesaturatePerspective.Time = m_animationTime;
-			m_screenEffectsHandle.StartEffect(blurVignetteDesaturatePerspective);
-		}
-	}
-
-	public void CancelPreview()
-	{
-		if (!m_animating)
-		{
-			ShutDownCardBackStore();
-			Vector3 origScale = m_previewPane.transform.localScale;
-			IsPreviewing = false;
-			m_animating = true;
+                tweenHashTable4.Add("oncomplete", (Action<object>)delegate
+                {
+                    m_animating = false;
+                });
+                iTween.ScaleFrom(m_previewPane, tweenHashTable4);
+            }))
+            {
+                Debug.LogError($"Unable to load card back ID {cardBackIdx} for preview.");
+                m_animating = false;
+            }
+            if (!string.IsNullOrEmpty(m_enterPreviewSound))
+            {
+                SoundManager.Get().LoadAndPlay(m_enterPreviewSound);
+            }
+            ReadCardBackPreview();
+            ScreenEffectParameters blurVignetteDesaturatePerspective = ScreenEffectParameters.BlurVignetteDesaturatePerspective;
+            blurVignetteDesaturatePerspective.Time = m_animationTime;
+            m_screenEffectsHandle.StartEffect(blurVignetteDesaturatePerspective);
+        }
+    }
+
+    public void CancelPreview()
+    {
+        if (!m_animating)
+        {
+            ShutDownCardBackStore();
+            Vector3 origScale = m_previewPane.transform.localScale;
+            IsPreviewing = false;
+            m_animating = true;
 			iTween.ScaleTo(m_previewPane, iTween.Hash("scale", new Vector3(0.01f, 0.01f, 0.01f), "time", m_animationTime, "easetype", iTween.EaseType.easeOutCirc, "oncomplete", (Action<object>)delegate
-			{
-				m_animating = false;
-				m_previewPane.transform.localScale = origScale;
-				m_previewPane.SetActive(value: false);
-				m_offClicker.gameObject.SetActive(value: false);
-			}));
+            {
+                m_animating = false;
+                m_previewPane.transform.localScale = origScale;
+                m_previewPane.SetActive(value: false);
+                m_offClicker.gameObject.SetActive(value: false);
+            }));
 			iTween.ScaleTo(m_currentCardBack, iTween.Hash("scale", new Vector3(0.01f, 0.01f, 0.01f), "time", m_animationTime, "easetype", iTween.EaseType.easeOutCirc, "oncomplete", (Action<object>)delegate
-			{
-				m_currentCardBack.SetActive(value: false);
-			}));
-			if (!string.IsNullOrEmpty(m_exitPreviewSound))
-			{
-				SoundManager.Get().LoadAndPlay(m_exitPreviewSound);
-			}
-			m_screenEffectsHandle.StopEffect();
-		}
-	}
-
-	private void OnUserActionVisualControllerReady(VisualController visualController)
-	{
-		m_userActionVisualController = visualController;
-		UpdateView();
-		if (this.OnReady != null)
-		{
-			this.OnReady();
-		}
-	}
-
-	private void OnVisibilityVisualControllerReady(VisualController visualController)
-	{
-		m_visibilityVisualController = visualController;
-		UpdateView();
-	}
-
-	private void OnFullScreenBlockerWidgetReady(Widget fullScreenBlockerWidget)
-	{
-		m_fullScreenBlockerWidget = fullScreenBlockerWidget;
-		UpdateView();
-	}
-
-	private void SetupUI()
-	{
-		m_buyButton.AddEventListener(UIEventType.RELEASE, delegate
-		{
-			OnBuyButtonReleased();
-		});
-		m_favoriteButton.GetComponentInChildren<UberText>(includeInactive: true).Text = (CardBackManager.Get().MultipleFavoriteCardBacksEnabled() ? "GLUE_COLLECTION_MANAGER_FAVORITE_BUTTON_MULTIPLE" : "GLUE_COLLECTION_MANAGER_FAVORITE_BUTTON");
-		m_favoriteButton.AddEventListener(UIEventType.RELEASE, delegate
-		{
-			if (!m_currentCardBackIdx.HasValue)
-			{
-				Debug.LogError("CardBackInfoManager:FavoriteButtonRelease: m_currentCardBackIdx did not have a value");
-			}
-			else
-			{
-				CardBackManager.Get().HandleFavoriteToggle(m_currentCardBackIdx.Value);
-				CancelPreview();
-			}
-		});
-		m_offClicker.AddEventListener(UIEventType.RELEASE, delegate
-		{
-			CancelPreview();
-		});
-		m_offClicker.AddEventListener(UIEventType.RIGHTCLICK, delegate
-		{
-			CancelPreview();
-		});
-		CardBackManager.Get().OnFavoriteCardBacksChanged += OnFavoriteCardBackChanged;
-	}
-
-	public void OnFavoriteCardBackChanged(int cardBackId, bool isFavorite)
-	{
-		UpdateView();
-	}
-
-	private void OnBuyButtonReleased()
-	{
-		if (!m_currentCardBackIdx.HasValue)
-		{
-			Debug.LogError("CardBackInfoManager:OnBuyButtonReleased: m_currentCardBackIdx did not have a value");
-			return;
-		}
-		m_visibilityVisualController.SetState("HIDDEN");
-		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-		popupInfo.m_headerText = GameStrings.Format("GLUE_CARD_BACK_PURCHASE_CONFIRMATION_HEADER");
-		popupInfo.m_text = GameStrings.Format("GLUE_CARD_BACK_PURCHASE_CONFIRMATION_MESSAGE", m_title.Text);
-		popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL;
-		popupInfo.m_alertTextAlignment = UberText.AlignmentOptions.Center;
+            {
+                m_currentCardBack.SetActive(value: false);
+            }));
+            if (!string.IsNullOrEmpty(m_exitPreviewSound))
+            {
+                SoundManager.Get().LoadAndPlay(m_exitPreviewSound);
+            }
+            m_screenEffectsHandle.StopEffect();
+        }
+
+        HideThis();
+    }
+
+    private void OnUserActionVisualControllerReady(VisualController visualController)
+    {
+        m_userActionVisualController = visualController;
+        UpdateView();
+        if (this.OnReady != null)
+        {
+            this.OnReady();
+        }
+    }
+
+    private void OnVisibilityVisualControllerReady(VisualController visualController)
+    {
+        m_visibilityVisualController = visualController;
+        UpdateView();
+    }
+
+    private void OnFullScreenBlockerWidgetReady(Widget fullScreenBlockerWidget)
+    {
+        m_fullScreenBlockerWidget = fullScreenBlockerWidget;
+        UpdateView();
+    }
+
+    private void SetupUI()
+    {
+        m_buyButton.AddEventListener(UIEventType.RELEASE, delegate
+        {
+            OnBuyButtonReleased();
+        });
+        m_favoriteButton.GetComponentInChildren<UberText>(includeInactive: true).Text = (CardBackManager.Get().MultipleFavoriteCardBacksEnabled() ? "GLUE_COLLECTION_MANAGER_FAVORITE_BUTTON_MULTIPLE" : "GLUE_COLLECTION_MANAGER_FAVORITE_BUTTON");
+        m_favoriteButton.AddEventListener(UIEventType.RELEASE, delegate
+        {
+            if (!m_currentCardBackIdx.HasValue)
+            {
+                Debug.LogError("CardBackInfoManager:FavoriteButtonRelease: m_currentCardBackIdx did not have a value");
+            }
+            else
+            {
+                CardBackManager.Get().HandleFavoriteToggle(m_currentCardBackIdx.Value);
+                CancelPreview();
+            }
+        });
+        m_offClicker.AddEventListener(UIEventType.RELEASE, delegate
+        {
+            CancelPreview();
+        });
+        m_offClicker.AddEventListener(UIEventType.RIGHTCLICK, delegate
+        {
+            CancelPreview();
+        });
+        CardBackManager.Get().OnFavoriteCardBacksChanged += OnFavoriteCardBackChanged;
+    }
+
+    public void OnFavoriteCardBackChanged(int cardBackId, bool isFavorite)
+    {
+        UpdateView();
+    }
+
+    private void OnBuyButtonReleased()
+    {
+        if (!m_currentCardBackIdx.HasValue)
+        {
+            Debug.LogError("CardBackInfoManager:OnBuyButtonReleased: m_currentCardBackIdx did not have a value");
+            return;
+        }
+        m_visibilityVisualController.SetState("HIDDEN");
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+        popupInfo.m_headerText = GameStrings.Format("GLUE_CARD_BACK_PURCHASE_CONFIRMATION_HEADER");
+        popupInfo.m_text = GameStrings.Format("GLUE_CARD_BACK_PURCHASE_CONFIRMATION_MESSAGE", m_title.Text);
+        popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL;
+        popupInfo.m_alertTextAlignment = UberText.AlignmentOptions.Center;
 		AlertPopup.ResponseCallback responseCallback = delegate(AlertPopup.Response response, object userdata)
-		{
-			if (response == AlertPopup.Response.CONFIRM)
-			{
-				StartPurchaseTransaction();
-			}
-			else
-			{
-				m_visibilityVisualController.SetState("VISIBLE");
-			}
+        {
+            if (response == AlertPopup.Response.CONFIRM)
+            {
+                StartPurchaseTransaction();
+            }
+            else
+            {
+                m_visibilityVisualController.SetState("VISIBLE");
+            }
 		};
 		popupInfo.m_responseCallback = responseCallback;
-		DialogManager.Get().ShowPopup(popupInfo);
-	}
-
-	private void UpdateView()
-	{
-		if (m_userActionVisualController == null || m_visibilityVisualController == null || m_fullScreenBlockerWidget == null || !m_currentCardBackIdx.HasValue)
-		{
-			return;
-		}
-		CardBackManager cardBackManager = CardBackManager.Get();
-		bool flag = false;
-		if (cardBackManager.IsCardBackOwned(m_currentCardBackIdx.Value))
-		{
-			m_userActionVisualController.SetState("MAKE_FAVORITE");
-		}
-		else if (!cardBackManager.IsCardBackPurchasableFromCollectionManager(m_currentCardBackIdx.Value))
-		{
-			m_userActionVisualController.SetState("DISABLED");
-		}
-		else
-		{
-			PriceDataModel collectionManagerCardBackPriceDataModel = cardBackManager.GetCollectionManagerCardBackPriceDataModel(m_currentCardBackIdx.Value);
-			m_userActionVisualController.BindDataModel(collectionManagerCardBackPriceDataModel);
-			if (!cardBackManager.CanBuyCardBackFromCollectionManager(m_currentCardBackIdx.Value))
-			{
-				m_userActionVisualController.SetState("INSUFFICIENT_CURRENCY");
-			}
-			else
-			{
-				m_userActionVisualController.SetState("SUFFICIENT_CURRENCY");
-				flag = true;
-			}
-		}
-		bool faceUp = cardBackManager.CanToggleFavoriteCardBack(m_currentCardBackIdx.Value);
-		m_favoriteButton.SetEnabled(faceUp);
-		m_favoriteButton.Flip(faceUp);
-		m_buyButton.SetEnabled(flag);
-		m_buyButton.Flip(faceUp: true);
-	}
-
-	private void BlockInputs(bool blocked)
-	{
-		if (m_fullScreenBlockerWidget == null)
-		{
-			Debug.LogError("Failed to toggle interface blocker from Duels Popup Manager");
-		}
-		else if (blocked)
-		{
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    private void UpdateView()
+    {
+        if (m_userActionVisualController == null || m_visibilityVisualController == null || m_fullScreenBlockerWidget == null || !m_currentCardBackIdx.HasValue)
+        {
+            return;
+        }
+        CardBackManager cardBackManager = CardBackManager.Get();
+        bool flag = false;
+        if (cardBackManager.IsCardBackOwned(m_currentCardBackIdx.Value))
+        {
+            m_userActionVisualController.SetState("MAKE_FAVORITE");
+        }
+        else if (!cardBackManager.IsCardBackPurchasableFromCollectionManager(m_currentCardBackIdx.Value))
+        {
+            m_userActionVisualController.SetState("DISABLED");
+        }
+        else
+        {
+            PriceDataModel collectionManagerCardBackPriceDataModel = cardBackManager.GetCollectionManagerCardBackPriceDataModel(m_currentCardBackIdx.Value);
+            m_userActionVisualController.BindDataModel(collectionManagerCardBackPriceDataModel);
+            if (!cardBackManager.CanBuyCardBackFromCollectionManager(m_currentCardBackIdx.Value))
+            {
+                m_userActionVisualController.SetState("INSUFFICIENT_CURRENCY");
+            }
+            else
+            {
+                m_userActionVisualController.SetState("SUFFICIENT_CURRENCY");
+                flag = true;
+            }
+        }
+        bool faceUp = cardBackManager.CanToggleFavoriteCardBack(m_currentCardBackIdx.Value);
+        m_favoriteButton.SetEnabled(faceUp);
+        m_favoriteButton.Flip(faceUp);
+        m_buyButton.SetEnabled(flag);
+        m_buyButton.Flip(faceUp: true);
+    }
+
+    private void BlockInputs(bool blocked)
+    {
+        if (m_fullScreenBlockerWidget == null)
+        {
+            Debug.LogError("Failed to toggle interface blocker from Duels Popup Manager");
+        }
+        else if (blocked)
+        {
 			m_fullScreenBlockerWidget.TriggerEvent("BLOCK_SCREEN", TriggerEventParameters.StandardPropagateDownward);
-		}
-		else
-		{
+        }
+        else
+        {
 			m_fullScreenBlockerWidget.TriggerEvent("UNBLOCK_SCREEN", TriggerEventParameters.StandardPropagateDownward);
-		}
-	}
-
-	private void SetupCardBackStore()
-	{
-		if (m_isStoreOpen)
-		{
-			Debug.LogError("CardBackInfoManager:SetupCardBackStore called when the store was already open");
-			return;
-		}
-		if (!m_currentCardBackIdx.HasValue)
-		{
-			Debug.LogError("CardBackInfoManager:SetupCardBackStore: m_currentCardBackIdx did not have a value");
-			return;
-		}
-		StoreManager storeManager = StoreManager.Get();
-		if (storeManager.IsOpen())
-		{
-			storeManager.SetupCardBackStore(this, m_currentCardBackIdx.Value);
-			storeManager.RegisterSuccessfulPurchaseListener(OnSuccessfulPurchase);
-			storeManager.RegisterSuccessfulPurchaseAckListener(OnSuccessfulPurchaseAck);
-			storeManager.RegisterFailedPurchaseAckListener(OnFailedPurchaseAck);
-			BnetBar.Get()?.RefreshCurrency();
-		}
-	}
-
-	private void ShutDownCardBackStore()
-	{
-		if (m_isStoreOpen)
-		{
-			CancelPurchaseTransaction();
-			this.OnClosed?.Invoke(new StoreClosedArgs());
-			StoreManager storeManager = StoreManager.Get();
-			storeManager.RemoveFailedPurchaseAckListener(OnFailedPurchaseAck);
-			storeManager.RemoveSuccessfulPurchaseListener(OnSuccessfulPurchase);
-			storeManager.RemoveSuccessfulPurchaseAckListener(OnSuccessfulPurchaseAck);
-			storeManager.ShutDownCardBackStore();
-			this.OnProductPurchaseAttempt = null;
-			BnetBar.Get()?.RefreshCurrency();
-			BlockInputs(blocked: false);
-			m_isStoreOpen = false;
-		}
-	}
+        }
+    }
+
+    private void SetupCardBackStore()
+    {
+        if (m_isStoreOpen)
+        {
+            Debug.LogError("CardBackInfoManager:SetupCardBackStore called when the store was already open");
+            return;
+        }
+        if (!m_currentCardBackIdx.HasValue)
+        {
+            Debug.LogError("CardBackInfoManager:SetupCardBackStore: m_currentCardBackIdx did not have a value");
+            return;
+        }
+        StoreManager storeManager = StoreManager.Get();
+        if (storeManager.IsOpen())
+        {
+            storeManager.SetupCardBackStore(this, m_currentCardBackIdx.Value);
+            storeManager.RegisterSuccessfulPurchaseListener(OnSuccessfulPurchase);
+            storeManager.RegisterSuccessfulPurchaseAckListener(OnSuccessfulPurchaseAck);
+            storeManager.RegisterFailedPurchaseAckListener(OnFailedPurchaseAck);
+            BnetBar.Get()?.RefreshCurrency();
+        }
+    }
+
+    private void ShutDownCardBackStore()
+    {
+        if (m_isStoreOpen)
+        {
+            CancelPurchaseTransaction();
+            this.OnClosed?.Invoke(new StoreClosedArgs());
+            StoreManager storeManager = StoreManager.Get();
+            storeManager.RemoveFailedPurchaseAckListener(OnFailedPurchaseAck);
+            storeManager.RemoveSuccessfulPurchaseListener(OnSuccessfulPurchase);
+            storeManager.RemoveSuccessfulPurchaseAckListener(OnSuccessfulPurchaseAck);
+            storeManager.ShutDownCardBackStore();
+            this.OnProductPurchaseAttempt = null;
+            BnetBar.Get()?.RefreshCurrency();
+            BlockInputs(blocked: false);
+            m_isStoreOpen = false;
+        }
+    }
 
 	private void OnSuccessfulPurchase(ProductInfo bundle, PaymentMethod paymentMethod)
-	{
-	}
+    {
+    }
 
 	private void OnSuccessfulPurchaseAck(ProductInfo bundle, PaymentMethod paymentMethod)
-	{
-		EndPurchaseTransaction();
-		CardBackManager.Get().AddNewCardBack(m_currentCardBackIdx.Value);
-		CollectionManager.Get().RefreshCurrentPageContents();
-		m_visibilityVisualController.SetState("VISIBLE");
-		UpdateView();
-	}
+    {
+        EndPurchaseTransaction();
+        CardBackManager.Get().AddNewCardBack(m_currentCardBackIdx.Value);
+        CollectionManager.Get().RefreshCurrentPageContents();
+        m_visibilityVisualController.SetState("VISIBLE");
+        UpdateView();
+    }
 
 	private void OnFailedPurchaseAck(ProductInfo bundle, PaymentMethod paymentMethod)
-	{
-		EndPurchaseTransaction();
-		m_visibilityVisualController.SetState("VISIBLE");
-		UpdateView();
-	}
-
-	private void StartPurchaseTransaction()
-	{
-		if (!m_currentCardBackIdx.HasValue)
-		{
-			Debug.LogError("CardBackInfoManager:StartPurchaseTransaction: m_currentCardBackIdx did not have a value");
-		}
-		else if (m_isStoreTransactionActive)
-		{
-			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-			popupInfo.m_headerText = GameStrings.Get("GLUE_CARD_BACK_PURCHASE_ERROR_HEADER");
-			popupInfo.m_text = GameStrings.Get("GLUE_CHECKOUT_ERROR_GENERIC_FAILURE");
-			popupInfo.m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle;
-			popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-			DialogManager.Get().ShowPopup(popupInfo);
-			Debug.LogWarning("CardBackInfoManager:StartPurchaseTransaction: Attempted to start a card back transaction while an existing transaction was in progress");
-		}
-		else if (this.OnProductPurchaseAttempt == null)
-		{
-			Debug.LogError("CardBackInfoManager:StartPurchaseTransaction: Attempted to start a card back purchase transaction while OnProductPurchaseAttempt was null");
-		}
-		else
-		{
-			m_isStoreTransactionActive = true;
+    {
+        EndPurchaseTransaction();
+        m_visibilityVisualController.SetState("VISIBLE");
+        UpdateView();
+    }
+
+    private void StartPurchaseTransaction()
+    {
+        if (!m_currentCardBackIdx.HasValue)
+        {
+            Debug.LogError("CardBackInfoManager:StartPurchaseTransaction: m_currentCardBackIdx did not have a value");
+        }
+        else if (m_isStoreTransactionActive)
+        {
+            AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+            popupInfo.m_headerText = GameStrings.Get("GLUE_CARD_BACK_PURCHASE_ERROR_HEADER");
+            popupInfo.m_text = GameStrings.Get("GLUE_CHECKOUT_ERROR_GENERIC_FAILURE");
+            popupInfo.m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle;
+            popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+            DialogManager.Get().ShowPopup(popupInfo);
+            Debug.LogWarning("CardBackInfoManager:StartPurchaseTransaction: Attempted to start a card back transaction while an existing transaction was in progress");
+        }
+        else if (this.OnProductPurchaseAttempt == null)
+        {
+            Debug.LogError("CardBackInfoManager:StartPurchaseTransaction: Attempted to start a card back purchase transaction while OnProductPurchaseAttempt was null");
+        }
+        else
+        {
+            m_isStoreTransactionActive = true;
 			ProductInfo collectionManagerCardBackProductBundle = CardBackManager.Get().GetCollectionManagerCardBackProductBundle(m_currentCardBackIdx.Value);
-			if (collectionManagerCardBackProductBundle == null)
-			{
-				Debug.LogError("CardBackInfoManager:StartPurchaseTransaction: Attempted to start a card back purchase transaction with a null product bundle for card back " + m_currentCardBackIdx.Value);
-			}
-			else
-			{
-				this.OnProductPurchaseAttempt(new BuyPmtProductEventArgs(collectionManagerCardBackProductBundle, CurrencyType.GOLD, 1));
-			}
-		}
-	}
-
-	private void CancelPurchaseTransaction()
-	{
-		EndPurchaseTransaction();
-	}
-
-	private void EndPurchaseTransaction()
-	{
-		if (m_isStoreTransactionActive)
-		{
-			m_isStoreTransactionActive = false;
-		}
-	}
-
-	void IStore.Open()
-	{
-		Shop.Get().RefreshDataModel();
-		m_isStoreOpen = true;
-		this.OnOpened?.Invoke();
-		BnetBar bnetBar = BnetBar.Get();
-		if (bnetBar != null)
-		{
-			bnetBar.RefreshCurrency();
-		}
-		else
-		{
-			Debug.LogError("CardBackInfoManager:IStore.Open: Could not get the Bnet bar to reflect the required currency");
-		}
-	}
-
-	void IStore.Close()
-	{
-		if (m_isStoreTransactionActive)
-		{
-			CancelPurchaseTransaction();
-		}
-	}
-
-	void IStore.BlockInterface(bool blocked)
-	{
-		BlockInputs(blocked);
-	}
-
-	bool IStore.IsReady()
-	{
-		return true;
-	}
-
-	bool IStore.IsOpen()
-	{
-		return m_isStoreOpen;
-	}
-
-	void IStore.Unload()
-	{
-	}
-
-	IEnumerable<CurrencyType> IStore.GetVisibleCurrencies()
-	{
-		return new CurrencyType[1] { CurrencyType.GOLD };
-	}
+            if (collectionManagerCardBackProductBundle == null)
+            {
+                Debug.LogError("CardBackInfoManager:StartPurchaseTransaction: Attempted to start a card back purchase transaction with a null product bundle for card back " + m_currentCardBackIdx.Value);
+            }
+            else
+            {
+                this.OnProductPurchaseAttempt(new BuyPmtProductEventArgs(collectionManagerCardBackProductBundle, CurrencyType.GOLD, 1));
+            }
+        }
+    }
+
+    private void CancelPurchaseTransaction()
+    {
+        EndPurchaseTransaction();
+    }
+
+    private void EndPurchaseTransaction()
+    {
+        if (m_isStoreTransactionActive)
+        {
+            m_isStoreTransactionActive = false;
+        }
+    }
+
+    void IStore.Open()
+    {
+        Shop.Get().RefreshDataModel();
+        m_isStoreOpen = true;
+        this.OnOpened?.Invoke();
+        BnetBar bnetBar = BnetBar.Get();
+        if (bnetBar != null)
+        {
+            bnetBar.RefreshCurrency();
+        }
+        else
+        {
+            Debug.LogError("CardBackInfoManager:IStore.Open: Could not get the Bnet bar to reflect the required currency");
+        }
+    }
+
+    void IStore.Close()
+    {
+        if (m_isStoreTransactionActive)
+        {
+            CancelPurchaseTransaction();
+        }
+    }
+
+    void IStore.BlockInterface(bool blocked)
+    {
+        BlockInputs(blocked);
+    }
+
+    bool IStore.IsReady()
+    {
+        return true;
+    }
+
+    bool IStore.IsOpen()
+    {
+        return m_isStoreOpen;
+    }
+
+    void IStore.Unload()
+    {
+    }
+
+    IEnumerable<CurrencyType> IStore.GetVisibleCurrencies()
+    {
+        return new CurrencyType[1] { CurrencyType.GOLD };
+    }
+
+    #region Accessibility
+
+    private AccessibleMenu m_accessibleMenu;
+
+    private void ReadCardBackPreview()
+    {
+        AccessibilityMgr.ShowUI(this);
+
+        m_accessibleMenu = new AccessibleMenu(this, m_title.Text, CancelPreview);
+        m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR), () => AccessibilityMgr.Output(this, m_description.Text));
+
+        if (m_favoriteButton.IsEnabled())
+        {
+            m_accessibleMenu.AddOption(m_favoriteButton.GetText(), m_favoriteButton.TriggerRelease);
+        }
+
+        m_accessibleMenu.StartReading();
+    }
+
+    private void HideThis()
+    {
+        AccessibilityMgr.HideUI(this);
+    }
+
+    public void HandleAccessibleInput()
+    {
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+        return m_accessibleMenu?.GetHelp();
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/CardBackManager.cs b/Assembly-CSharp/CardBackManager.cs
index 8e2c0f0..c64aa53 100644
--- a/Assembly-CSharp/CardBackManager.cs
+++ b/Assembly-CSharp/CardBackManager.cs
@@ -16,1506 +16,1510 @@ using Hearthstone.DataModels;
 using Hearthstone.Store;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class CardBackManager : IService
 {
-	public class LoadCardBackData
-	{
-		public delegate void LoadCardBackCallback(LoadCardBackData cardBackData);
-
-		public int m_CardBackIndex;
-
-		public GameObject m_GameObject;
-
-		public CardBack m_CardBack;
-
-		public LoadCardBackCallback m_Callback;
-
-		public string m_Name;
-
-		public string m_Path;
-
-		public CardBackSlot m_Slot;
-
-		public bool m_Unlit;
-
-		public bool m_ShadowActive;
-
-		public object callbackData;
-	}
-
-	public class OwnedCardBack
-	{
-		public int m_cardBackId;
-
-		public string m_name;
-
-		public bool m_owned;
-
-		public bool m_favorited;
-
-		public bool m_canBuy;
-
-		public int m_sortOrder;
-
-		public int m_sortCategory;
-
-		public long m_seasonId = -1L;
-	}
-
-	public enum CardBackSlot
-	{
-		DEFAULT,
-		FRIENDLY,
-		OPPONENT,
-		FAVORITE
-	}
-
-	public delegate void UpdateCardbacksCallback();
-
-	public delegate void FavoriteCardBacksChangedCallback(int cardBackId, bool isFavorite);
-
-	private class CardBackSlotData
-	{
-		public CardBack m_cardBack;
-
-		public string m_cardBackAssetString;
-
-		public bool m_isLoading;
-	}
+    public class LoadCardBackData
+    {
+        public delegate void LoadCardBackCallback(LoadCardBackData cardBackData);
 
-	private class UpdateCardbacksListener : EventListener<UpdateCardbacksCallback>
-	{
-		public void Fire()
-		{
-			m_callback();
-		}
-	}
-
-	private GameObject m_sceneObject;
-
-	private const int CARD_BACK_PRIMARY_MATERIAL_INDEX = 0;
-
-	private const int CARD_BACK_SECONDARY_MATERIAL_INDEX = 1;
-
-	private Map<int, CardBackData> m_cardBackData;
+        public int m_CardBackIndex;
 
-	private Map<string, CardBack> m_LoadedCardBacks;
+        public GameObject m_GameObject;
 
-	private Map<CardBackSlot, CardBackSlotData> m_LoadedCardBacksBySlot;
+        public CardBack m_CardBack;
 
-	private string m_searchText;
+        public LoadCardBackCallback m_Callback;
 
-	private List<UpdateCardbacksListener> m_updateCardbacksListeners = new List<UpdateCardbacksListener>();
+        public string m_Name;
 
-	private readonly object cardbackListenerCollectionLock = new object();
+        public string m_Path;
 
-	private bool m_shouldSort = true;
+        public CardBackSlot m_Slot;
 
-	private List<OwnedCardBack> m_sortedCardBacks;
+        public bool m_Unlit;
 
-	private GameObject SceneObject
-	{
-		get
-		{
-			if (m_sceneObject == null)
-			{
-				m_sceneObject = new GameObject("CardBackManagerSceneObject", typeof(HSDontDestroyOnLoad));
-			}
-			return m_sceneObject;
-		}
-	}
-
-	public int TheRandomCardBackID { get; private set; }
-
-	public event FavoriteCardBacksChangedCallback OnFavoriteCardBacksChanged;
-
-	public IEnumerator<IAsyncJobResult> Initialize(ServiceLocator serviceLocator)
-	{
-		HearthstoneApplication.Get().Resetting += Resetting;
-		NetCache netCache = serviceLocator.Get<NetCache>();
-		netCache.FavoriteCardBackChanged += OnFavoriteCardBackChanged;
-		netCache.RegisterUpdatedListener(typeof(NetCache.NetCacheCardBacks), NetCache_OnNetCacheCardBacksUpdated);
-		InitCardBackData();
-		Options.Get().RegisterChangedListener(Option.CARD_BACK, OnCheatOptionChanged);
-		Options.Get().RegisterChangedListener(Option.CARD_BACK2, OnCheatOptionChanged);
-		serviceLocator.Get<SceneMgr>().RegisterSceneLoadedEvent(OnSceneLoaded);
-		InitCardBackSlots();
-		yield break;
-	}
+        public bool m_ShadowActive;
 
-	public Type[] GetDependencies()
-	{
-		return new Type[4]
-		{
-			typeof(GameDbf),
-			typeof(IAssetLoader),
-			typeof(NetCache),
-			typeof(SceneMgr)
-		};
-	}
+        public object callbackData;
+    }
 
-	public void Shutdown()
-	{
-		if (ServiceManager.TryGet<NetCache>(out var service))
-		{
-			service.FavoriteCardBackChanged -= OnFavoriteCardBackChanged;
-		}
-		HearthstoneApplication hearthstoneApplication = HearthstoneApplication.Get();
-		if (hearthstoneApplication != null)
-		{
-			hearthstoneApplication.Resetting -= Resetting;
-		}
-	}
+    public class OwnedCardBack
+    {
+        public int m_cardBackId;
 
-	private void Resetting()
-	{
-		InitCardBackData();
-	}
+        public string m_name;
 
-	public static CardBackManager Get()
-	{
-		return ServiceManager.Get<CardBackManager>();
-	}
+        public bool m_owned;
 
-	public bool RegisterUpdateCardbacksListener(UpdateCardbacksCallback callback)
-	{
-		UpdateCardbacksListener updateCardbacksListener = new UpdateCardbacksListener();
-		updateCardbacksListener.SetCallback(callback);
-		if (m_updateCardbacksListeners.Contains(updateCardbacksListener))
-		{
-			return false;
-		}
-		lock (cardbackListenerCollectionLock)
-		{
-			m_updateCardbacksListeners.Add(updateCardbacksListener);
-		}
-		return true;
-	}
+        public bool m_favorited;
 
-	public bool UnregisterUpdateCardbacksListener(UpdateCardbacksCallback callback)
-	{
-		UpdateCardbacksListener updateCardbacksListener = new UpdateCardbacksListener();
-		updateCardbacksListener.SetCallback(callback);
-		bool flag = false;
-		lock (cardbackListenerCollectionLock)
-		{
-			return m_updateCardbacksListeners.Remove(updateCardbacksListener);
-		}
-	}
+        public bool m_canBuy;
 
-	public void SetSearchText(string searchText)
-	{
-		m_searchText = searchText?.ToLower();
-	}
+        public int m_sortOrder;
 
-	public CardBack GetFriendlyCardBack()
-	{
-		return GetCardBackBySlot(CardBackSlot.FRIENDLY);
-	}
+        public int m_sortCategory;
 
-	public CardBack GetOpponentCardBack()
-	{
-		return GetCardBackBySlot(CardBackSlot.OPPONENT);
-	}
+        public long m_seasonId = -1L;
+    }
 
-	public CardBack GetCardBackForActor(Actor actor)
-	{
-		if (IsActorFriendly(actor))
-		{
-			return GetFriendlyCardBack();
-		}
-		return GetOpponentCardBack();
-	}
+    public enum CardBackSlot
+    {
+        DEFAULT,
+        FRIENDLY,
+        OPPONENT,
+        FAVORITE
+    }
 
-	public CardBack GetCardBackBySlot(CardBackSlot slot)
-	{
-		if (m_LoadedCardBacksBySlot.TryGetValue(slot, out var value))
-		{
-			return value.m_cardBack;
-		}
-		return null;
-	}
+    public delegate void UpdateCardbacksCallback();
 
-	public bool IsCardBackLoading(CardBackSlot slot)
-	{
-		if (m_LoadedCardBacksBySlot.TryGetValue(slot, out var value))
-		{
-			return value.m_isLoading;
-		}
-		return false;
-	}
+    public delegate void FavoriteCardBacksChangedCallback(int cardBackId, bool isFavorite);
 
-	public void UpdateAllCardBacksInSceneWhenReady()
-	{
-		Processor.RunCoroutine(UpdateAllCardBacksInSceneWhenReadyImpl());
-	}
+    private class CardBackSlotData
+    {
+        public CardBack m_cardBack;
 
-	public void SetGameCardBackIDs(int friendlyCardBackID, int opponentCardBackID)
-	{
-		int validCardBackID = GetValidCardBackID(friendlyCardBackID);
-		LoadCardBackPrefabIntoSlot(m_cardBackData[validCardBackID].PrefabName, CardBackSlot.FRIENDLY);
-		int validCardBackID2 = GetValidCardBackID(opponentCardBackID);
-		LoadCardBackPrefabIntoSlot(m_cardBackData[validCardBackID2].PrefabName, CardBackSlot.OPPONENT);
-		UpdateAllCardBacksInSceneWhenReady();
-	}
+        public string m_cardBackAssetString;
 
-	public bool LoadCardBackByIndex(int cardBackIdx, LoadCardBackData.LoadCardBackCallback callback, object callbackData = null)
-	{
-		string actorName = "Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9";
-		return LoadCardBackByIndex(cardBackIdx, callback, unlit: false, actorName, callbackData);
-	}
+        public bool m_isLoading;
+    }
 
-	public bool LoadCardBackByIndex(int cardBackIdx, LoadCardBackData.LoadCardBackCallback callback, string actorName, object callbackData = null)
-	{
-		return LoadCardBackByIndex(cardBackIdx, callback, unlit: false, actorName, callbackData);
-	}
+    private class UpdateCardbacksListener : EventListener<UpdateCardbacksCallback>
+    {
+        public void Fire()
+        {
+            m_callback();
+        }
+    }
 
-	public bool LoadCardBackByIndex(int cardBackIdx, LoadCardBackData.LoadCardBackCallback callback, bool unlit, string actorName = "Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9", object callbackData = null)
-	{
-		if (!m_cardBackData.ContainsKey(cardBackIdx))
-		{
-			Log.CardbackMgr.Print("CardBackManager.LoadCardBackByIndex() - wrong cardBackIdx {0}", cardBackIdx);
-			return false;
-		}
-		LoadCardBackData loadCardBackData = new LoadCardBackData();
-		loadCardBackData.m_CardBackIndex = cardBackIdx;
-		loadCardBackData.m_Callback = callback;
-		loadCardBackData.m_Unlit = unlit;
-		loadCardBackData.m_Name = m_cardBackData[cardBackIdx].Name;
-		loadCardBackData.callbackData = callbackData;
-		AssetLoader.Get().InstantiatePrefab(actorName, OnHiddenActorLoaded, loadCardBackData, AssetLoadingOptions.IgnorePrefabPosition);
-		return true;
-	}
+    private GameObject m_sceneObject;
 
-	public LoadCardBackData LoadCardBackByIndex(int cardBackIdx, bool unlit = false, string actorName = "Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9", bool shadowActive = false)
-	{
-		if (!m_cardBackData.ContainsKey(cardBackIdx))
-		{
-			Log.CardbackMgr.Print("CardBackManager.LoadCardBackByIndex() - wrong cardBackIdx {0}", cardBackIdx);
-			return null;
-		}
-		LoadCardBackData loadCardBackData = new LoadCardBackData();
-		loadCardBackData.m_CardBackIndex = cardBackIdx;
-		loadCardBackData.m_Unlit = unlit;
-		loadCardBackData.m_Name = m_cardBackData[cardBackIdx].Name;
-		loadCardBackData.m_GameObject = AssetLoader.Get().InstantiatePrefab(actorName, AssetLoadingOptions.IgnorePrefabPosition);
-		if (loadCardBackData.m_GameObject == null)
-		{
-			Log.CardbackMgr.Print("CardBackManager.LoadCardBackByIndex() - failed to load Actor {0}", actorName);
-			return null;
-		}
-		string prefabName = m_cardBackData[cardBackIdx].PrefabName;
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab(prefabName);
-		if (gameObject == null)
-		{
-			Log.CardbackMgr.Print("CardBackManager.LoadCardBackByIndex() - failed to load CardBack {0}", prefabName);
-			return null;
-		}
-		CardBack componentInChildren = gameObject.GetComponentInChildren<CardBack>();
-		if (componentInChildren == null)
-		{
-			Debug.LogWarning("CardBackManager.LoadCardBackByIndex() - cardback=null");
-			return null;
-		}
-		loadCardBackData.m_CardBack = componentInChildren;
-		Actor component = loadCardBackData.m_GameObject.GetComponent<Actor>();
-		SetCardBack(component.m_cardMesh, loadCardBackData.m_CardBack, loadCardBackData.m_Unlit, shadowActive);
-		component.SetCardbackUpdateIgnore(ignoreUpdate: true);
-		loadCardBackData.m_CardBack.gameObject.transform.parent = loadCardBackData.m_GameObject.transform;
-		return loadCardBackData;
-	}
+    private const int CARD_BACK_PRIMARY_MATERIAL_INDEX = 0;
 
-	public static Actor LoadCardBackActorByPrefab(string cardBackPrefab, bool unlit = false, string actorName = "Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9", bool shadowActive = false)
-	{
-		if (AssetLoader.Get() == null)
-		{
-			Debug.LogWarning("CardBackManager.LoadCardBackActorByPrefab() - AssetLoader not available");
-			return null;
-		}
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab(cardBackPrefab);
-		if (gameObject == null)
-		{
-			Log.CardbackMgr.Print("CardBackManager.LoadCardBackActorByPrefab() - failed to load CardBack {0}", cardBackPrefab);
-			return null;
-		}
-		GameObject gameObject2 = AssetLoader.Get().InstantiatePrefab(actorName, AssetLoadingOptions.IgnorePrefabPosition);
-		if (gameObject2 == null)
-		{
-			Log.CardbackMgr.Print("CardBackManager.LoadCardBackActorByPrefab() - failed to load Actor {0}", actorName);
-			return null;
-		}
-		Actor component = gameObject2.GetComponent<Actor>();
-		CardBack componentInChildren = gameObject.GetComponentInChildren<CardBack>();
-		if (componentInChildren == null)
-		{
-			Debug.LogWarning("CardBackManager.LoadCardBackActorByPrefab() - cardback=null");
-			return null;
-		}
-		SetCardBack(component.m_cardMesh, componentInChildren, unlit, shadowActive);
-		component.SetCardbackUpdateIgnore(ignoreUpdate: true);
-		componentInChildren.gameObject.transform.parent = gameObject2.transform;
-		return component;
-	}
+    private const int CARD_BACK_SECONDARY_MATERIAL_INDEX = 1;
 
-	public void AddNewCardBack(int cardBackID)
-	{
-		NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
-		if (cardBacks == null)
-		{
-			Debug.LogWarning($"CollectionManager.AddNewCardBack({cardBackID}): trying to access NetCacheCardBacks before it's been loaded");
-			return;
-		}
-		cardBacks.CardBacks.Add(cardBackID);
-		SetCollectionCardBackOwned(cardBackID);
-	}
+    private Map<int, CardBackData> m_cardBackData;
 
-	public void SetCollectionCardBackOwned(int cardBackId)
-	{
-		if (m_sortedCardBacks != null)
-		{
-			OwnedCardBack ownedCardBack = m_sortedCardBacks.Find((OwnedCardBack back) => back.m_cardBackId == cardBackId);
-			if (ownedCardBack != null)
-			{
-				ownedCardBack.m_owned = true;
-			}
-		}
-	}
+    private Map<string, CardBack> m_LoadedCardBacks;
 
-	public void HandleFavoriteToggle(int cardBackId)
-	{
-		if (MultipleFavoriteCardBacksEnabled())
-		{
-			RequestSetFavoriteCardBack(cardBackId, !IsCardBackFavorited(cardBackId));
-			return;
-		}
-		foreach (int favoriteCardBack in GetCardBacks().FavoriteCardBacks)
-		{
-			RequestSetFavoriteCardBack(favoriteCardBack, isFavorite: false);
-		}
-		RequestSetFavoriteCardBack(cardBackId);
-	}
+    private Map<CardBackSlot, CardBackSlotData> m_LoadedCardBacksBySlot;
 
-	public void RequestSetFavoriteCardBack(int cardBackID, bool isFavorite = true)
-	{
-		Network.Get().SetFavoriteCardBack(cardBackID, isFavorite);
-	}
+    private string m_searchText;
 
-	public string GetCardBackName(int cardBackId)
-	{
-		if (m_cardBackData.TryGetValue(cardBackId, out var value))
-		{
-			return value.Name;
-		}
-		return null;
-	}
+    private List<UpdateCardbacksListener> m_updateCardbacksListeners = new List<UpdateCardbacksListener>();
 
-	public int GetNumCardBacksOwned()
-	{
-		NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
-		if (cardBacks == null)
-		{
-			Debug.LogWarning("CardBackManager.GetNumCardBacksOwned(): trying to access NetCacheCardBacks before it's been loaded");
-			return 0;
-		}
-		return cardBacks.CardBacks.Count;
-	}
+    private readonly object cardbackListenerCollectionLock = new object();
 
-	public HashSet<int> GetCardBacksOwned()
-	{
-		NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
-		if (cardBacks == null)
-		{
-			Debug.LogWarning("CardBackManager.GetCardBacksOwned(): trying to access NetCacheCardBacks before it's been loaded");
-			return null;
-		}
-		return cardBacks.CardBacks;
-	}
+    private bool m_shouldSort = true;
 
-	public NetCache.NetCacheCardBacks GetCardBacks()
-	{
-		NetCache.NetCacheCardBacks netObject = NetCache.Get().GetNetObject<NetCache.NetCacheCardBacks>();
-		if (netObject == null)
-		{
-			return GetCardBacksFromOfflineData();
-		}
-		return netObject;
-	}
+    private List<OwnedCardBack> m_sortedCardBacks;
 
-	public NetCache.NetCacheCardBacks GetCardBacksFromOfflineData()
-	{
-		CardBacks cardBacksFromCache = OfflineDataCache.GetCardBacksFromCache();
-		if (cardBacksFromCache == null)
-		{
-			return null;
-		}
-		return new NetCache.NetCacheCardBacks
-		{
-			CardBacks = new HashSet<int>(cardBacksFromCache.CardBacks_),
-			FavoriteCardBacks = new HashSet<int>(cardBacksFromCache.FavoriteCardBacks)
-		};
-	}
+    private GameObject SceneObject
+    {
+        get
+        {
+            if (m_sceneObject == null)
+            {
+                m_sceneObject = new GameObject("CardBackManagerSceneObject", typeof(HSDontDestroyOnLoad));
+            }
+            return m_sceneObject;
+        }
+    }
+
+    public int TheRandomCardBackID { get; private set; }
+
+    public event FavoriteCardBacksChangedCallback OnFavoriteCardBacksChanged;
+
+    public IEnumerator<IAsyncJobResult> Initialize(ServiceLocator serviceLocator)
+    {
+        HearthstoneApplication.Get().Resetting += Resetting;
+        NetCache netCache = serviceLocator.Get<NetCache>();
+        netCache.FavoriteCardBackChanged += OnFavoriteCardBackChanged;
+        netCache.RegisterUpdatedListener(typeof(NetCache.NetCacheCardBacks), NetCache_OnNetCacheCardBacksUpdated);
+        InitCardBackData();
+        Options.Get().RegisterChangedListener(Option.CARD_BACK, OnCheatOptionChanged);
+        Options.Get().RegisterChangedListener(Option.CARD_BACK2, OnCheatOptionChanged);
+        serviceLocator.Get<SceneMgr>().RegisterSceneLoadedEvent(OnSceneLoaded);
+        InitCardBackSlots();
+        yield break;
+    }
+
+    public Type[] GetDependencies()
+    {
+        return new Type[4]
+        {
+            typeof(GameDbf),
+            typeof(IAssetLoader),
+            typeof(NetCache),
+            typeof(SceneMgr)
+        };
+    }
+
+    public void Shutdown()
+    {
+        if (ServiceManager.TryGet<NetCache>(out var service))
+        {
+            service.FavoriteCardBackChanged -= OnFavoriteCardBackChanged;
+        }
+        HearthstoneApplication hearthstoneApplication = HearthstoneApplication.Get();
+        if (hearthstoneApplication != null)
+        {
+            hearthstoneApplication.Resetting -= Resetting;
+        }
+    }
+
+    private void Resetting()
+    {
+        InitCardBackData();
+    }
+
+    public static CardBackManager Get()
+    {
+        return ServiceManager.Get<CardBackManager>();
+    }
+
+    public bool RegisterUpdateCardbacksListener(UpdateCardbacksCallback callback)
+    {
+        UpdateCardbacksListener updateCardbacksListener = new UpdateCardbacksListener();
+        updateCardbacksListener.SetCallback(callback);
+        if (m_updateCardbacksListeners.Contains(updateCardbacksListener))
+        {
+            return false;
+        }
+        lock (cardbackListenerCollectionLock)
+        {
+            m_updateCardbacksListeners.Add(updateCardbacksListener);
+        }
+        return true;
+    }
+
+    public bool UnregisterUpdateCardbacksListener(UpdateCardbacksCallback callback)
+    {
+        UpdateCardbacksListener updateCardbacksListener = new UpdateCardbacksListener();
+        updateCardbacksListener.SetCallback(callback);
+        bool flag = false;
+        lock (cardbackListenerCollectionLock)
+        {
+            return m_updateCardbacksListeners.Remove(updateCardbacksListener);
+        }
+    }
+
+    public void SetSearchText(string searchText)
+    {
+        m_searchText = searchText?.ToLower();
+    }
+
+    public CardBack GetFriendlyCardBack()
+    {
+        return GetCardBackBySlot(CardBackSlot.FRIENDLY);
+    }
+
+    public CardBack GetOpponentCardBack()
+    {
+        return GetCardBackBySlot(CardBackSlot.OPPONENT);
+    }
+
+    public CardBack GetCardBackForActor(Actor actor)
+    {
+        if (IsActorFriendly(actor))
+        {
+            return GetFriendlyCardBack();
+        }
+        return GetOpponentCardBack();
+    }
+
+    public CardBack GetCardBackBySlot(CardBackSlot slot)
+    {
+        if (m_LoadedCardBacksBySlot.TryGetValue(slot, out var value))
+        {
+            return value.m_cardBack;
+        }
+        return null;
+    }
+
+    public bool IsCardBackLoading(CardBackSlot slot)
+    {
+        if (m_LoadedCardBacksBySlot.TryGetValue(slot, out var value))
+        {
+            return value.m_isLoading;
+        }
+        return false;
+    }
+
+    public void UpdateAllCardBacksInSceneWhenReady()
+    {
+        Processor.RunCoroutine(UpdateAllCardBacksInSceneWhenReadyImpl());
+    }
+
+    public void SetGameCardBackIDs(int friendlyCardBackID, int opponentCardBackID)
+    {
+        int validCardBackID = GetValidCardBackID(friendlyCardBackID);
+        LoadCardBackPrefabIntoSlot(m_cardBackData[validCardBackID].PrefabName, CardBackSlot.FRIENDLY);
+        int validCardBackID2 = GetValidCardBackID(opponentCardBackID);
+        LoadCardBackPrefabIntoSlot(m_cardBackData[validCardBackID2].PrefabName, CardBackSlot.OPPONENT);
+        UpdateAllCardBacksInSceneWhenReady();
+    }
+
+    public bool LoadCardBackByIndex(int cardBackIdx, LoadCardBackData.LoadCardBackCallback callback, object callbackData = null)
+    {
+        string actorName = "Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9";
+        return LoadCardBackByIndex(cardBackIdx, callback, unlit: false, actorName, callbackData);
+    }
+
+    public bool LoadCardBackByIndex(int cardBackIdx, LoadCardBackData.LoadCardBackCallback callback, string actorName, object callbackData = null)
+    {
+        return LoadCardBackByIndex(cardBackIdx, callback, unlit: false, actorName, callbackData);
+    }
+
+    public bool LoadCardBackByIndex(int cardBackIdx, LoadCardBackData.LoadCardBackCallback callback, bool unlit, string actorName = "Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9", object callbackData = null)
+    {
+        if (!m_cardBackData.ContainsKey(cardBackIdx))
+        {
+            Log.CardbackMgr.Print("CardBackManager.LoadCardBackByIndex() - wrong cardBackIdx {0}", cardBackIdx);
+            return false;
+        }
+        LoadCardBackData loadCardBackData = new LoadCardBackData();
+        loadCardBackData.m_CardBackIndex = cardBackIdx;
+        loadCardBackData.m_Callback = callback;
+        loadCardBackData.m_Unlit = unlit;
+        loadCardBackData.m_Name = m_cardBackData[cardBackIdx].Name;
+        loadCardBackData.callbackData = callbackData;
+        AssetLoader.Get().InstantiatePrefab(actorName, OnHiddenActorLoaded, loadCardBackData, AssetLoadingOptions.IgnorePrefabPosition);
+        return true;
+    }
+
+    public LoadCardBackData LoadCardBackByIndex(int cardBackIdx, bool unlit = false, string actorName = "Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9", bool shadowActive = false)
+    {
+        if (!m_cardBackData.ContainsKey(cardBackIdx))
+        {
+            Log.CardbackMgr.Print("CardBackManager.LoadCardBackByIndex() - wrong cardBackIdx {0}", cardBackIdx);
+            return null;
+        }
+        LoadCardBackData loadCardBackData = new LoadCardBackData();
+        loadCardBackData.m_CardBackIndex = cardBackIdx;
+        loadCardBackData.m_Unlit = unlit;
+        loadCardBackData.m_Name = m_cardBackData[cardBackIdx].Name;
+        loadCardBackData.m_GameObject = AssetLoader.Get().InstantiatePrefab(actorName, AssetLoadingOptions.IgnorePrefabPosition);
+        if (loadCardBackData.m_GameObject == null)
+        {
+            Log.CardbackMgr.Print("CardBackManager.LoadCardBackByIndex() - failed to load Actor {0}", actorName);
+            return null;
+        }
+        string prefabName = m_cardBackData[cardBackIdx].PrefabName;
+        GameObject gameObject = AssetLoader.Get().InstantiatePrefab(prefabName);
+        if (gameObject == null)
+        {
+            Log.CardbackMgr.Print("CardBackManager.LoadCardBackByIndex() - failed to load CardBack {0}", prefabName);
+            return null;
+        }
+        CardBack componentInChildren = gameObject.GetComponentInChildren<CardBack>();
+        if (componentInChildren == null)
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager.LoadCardBackByIndex() - cardback=null");
+            return null;
+        }
+        loadCardBackData.m_CardBack = componentInChildren;
+        Actor component = loadCardBackData.m_GameObject.GetComponent<Actor>();
+        SetCardBack(component.m_cardMesh, loadCardBackData.m_CardBack, loadCardBackData.m_Unlit, shadowActive);
+        component.SetCardbackUpdateIgnore(ignoreUpdate: true);
+        loadCardBackData.m_CardBack.gameObject.transform.parent = loadCardBackData.m_GameObject.transform;
+        return loadCardBackData;
+    }
+
+    public static Actor LoadCardBackActorByPrefab(string cardBackPrefab, bool unlit = false, string actorName = "Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9", bool shadowActive = false)
+    {
+        if (AssetLoader.Get() == null)
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager.LoadCardBackActorByPrefab() - AssetLoader not available");
+            return null;
+        }
+        GameObject gameObject = AssetLoader.Get().InstantiatePrefab(cardBackPrefab);
+        if (gameObject == null)
+        {
+            Log.CardbackMgr.Print("CardBackManager.LoadCardBackActorByPrefab() - failed to load CardBack {0}", cardBackPrefab);
+            return null;
+        }
+        GameObject gameObject2 = AssetLoader.Get().InstantiatePrefab(actorName, AssetLoadingOptions.IgnorePrefabPosition);
+        if (gameObject2 == null)
+        {
+            Log.CardbackMgr.Print("CardBackManager.LoadCardBackActorByPrefab() - failed to load Actor {0}", actorName);
+            return null;
+        }
+        Actor component = gameObject2.GetComponent<Actor>();
+        CardBack componentInChildren = gameObject.GetComponentInChildren<CardBack>();
+        if (componentInChildren == null)
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager.LoadCardBackActorByPrefab() - cardback=null");
+            return null;
+        }
+        SetCardBack(component.m_cardMesh, componentInChildren, unlit, shadowActive);
+        component.SetCardbackUpdateIgnore(ignoreUpdate: true);
+        componentInChildren.gameObject.transform.parent = gameObject2.transform;
+        return component;
+    }
+
+    public void AddNewCardBack(int cardBackID)
+    {
+        NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
+        if (cardBacks == null)
+        {
+            UnityEngine.Debug.LogWarning($"CollectionManager.AddNewCardBack({cardBackID}): trying to access NetCacheCardBacks before it's been loaded");
+            return;
+        }
+        cardBacks.CardBacks.Add(cardBackID);
+        SetCollectionCardBackOwned(cardBackID);
+    }
+
+    public void SetCollectionCardBackOwned(int cardBackId)
+    {
+        if (m_sortedCardBacks != null)
+        {
+            OwnedCardBack ownedCardBack = m_sortedCardBacks.Find((OwnedCardBack back) => back.m_cardBackId == cardBackId);
+            if (ownedCardBack != null)
+            {
+                ownedCardBack.m_owned = true;
+            }
+        }
+    }
+
+    public void HandleFavoriteToggle(int cardBackId)
+    {
+        if (MultipleFavoriteCardBacksEnabled())
+        {
+            RequestSetFavoriteCardBack(cardBackId, !IsCardBackFavorited(cardBackId));
+            return;
+        }
+
+        foreach (int favoriteCardBack in GetCardBacks().FavoriteCardBacks)
+        {
+            RequestSetFavoriteCardBack(favoriteCardBack, isFavorite: false);
+        }
+        RequestSetFavoriteCardBack(cardBackId);
+
+        AccessibleCollectionManager.Get().WaitingForServerResponse();
+    }
+
+    public void RequestSetFavoriteCardBack(int cardBackID, bool isFavorite = true)
+    {
+        Network.Get().SetFavoriteCardBack(cardBackID, isFavorite);
+    }
+
+    public string GetCardBackName(int cardBackId)
+    {
+        if (m_cardBackData.TryGetValue(cardBackId, out var value))
+        {
+            return value.Name;
+        }
+        return null;
+    }
+
+    public int GetNumCardBacksOwned()
+    {
+        NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
+        if (cardBacks == null)
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager.GetNumCardBacksOwned(): trying to access NetCacheCardBacks before it's been loaded");
+            return 0;
+        }
+        return cardBacks.CardBacks.Count;
+    }
+
+    public HashSet<int> GetCardBacksOwned()
+    {
+        NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
+        if (cardBacks == null)
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager.GetCardBacksOwned(): trying to access NetCacheCardBacks before it's been loaded");
+            return null;
+        }
+        return cardBacks.CardBacks;
+    }
+
+    public NetCache.NetCacheCardBacks GetCardBacks()
+    {
+        NetCache.NetCacheCardBacks netObject = NetCache.Get().GetNetObject<NetCache.NetCacheCardBacks>();
+        if (netObject == null)
+        {
+            return GetCardBacksFromOfflineData();
+        }
+        return netObject;
+    }
+
+    public NetCache.NetCacheCardBacks GetCardBacksFromOfflineData()
+    {
+        CardBacks cardBacksFromCache = OfflineDataCache.GetCardBacksFromCache();
+        if (cardBacksFromCache == null)
+        {
+            return null;
+        }
+        return new NetCache.NetCacheCardBacks
+        {
+            CardBacks = new HashSet<int>(cardBacksFromCache.CardBacks_),
+            FavoriteCardBacks = new HashSet<int>(cardBacksFromCache.FavoriteCardBacks)
+        };
+    }
 
 	public HashSet<int> GetCardBackIds(bool requireOwned = false)
-	{
-		HashSet<int> hashSet = new HashSet<int>();
-		GetCardBacksOwned();
-		foreach (KeyValuePair<int, CardBackData> cardBackDatum in m_cardBackData)
-		{
+    {
+        HashSet<int> hashSet = new HashSet<int>();
+        GetCardBacksOwned();
+        foreach (KeyValuePair<int, CardBackData> cardBackDatum in m_cardBackData)
+        {
 			if (ShouldIncludeCardBack(cardBackDatum.Value, requireOwned))
-			{
-				hashSet.Add(cardBackDatum.Key);
-			}
-		}
-		return hashSet;
-	}
-
-	public bool IsCardBackOwned(int cardBackID)
-	{
-		NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
-		if (cardBacks == null)
-		{
-			Debug.LogWarning($"CardBackManager.IsCardBackOwned({cardBackID}): trying to access NetCacheCardBacks before it's been loaded");
-			return false;
-		}
-		return cardBacks.CardBacks.Contains(cardBackID);
-	}
-
-	public bool IsCardBackFavorited(int cardBackID)
-	{
-		NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
-		if (cardBacks == null)
-		{
-			Debug.LogWarning($"CardBackManager.IsCardBackFavorited({cardBackID}): trying to access NetCacheCardBacks before it's been loaded");
-			return false;
-		}
-		return cardBacks.FavoriteCardBacks.Contains(cardBackID);
-	}
-
-	public int TotalFavoriteCardBacks()
-	{
-		NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
-		if (cardBacks == null)
-		{
-			Debug.LogWarning($"CardBackManager.TotalFavoriteCardBacks(): trying to access NetCacheCardBacks before it's been loaded");
-			return 0;
-		}
-		return cardBacks.FavoriteCardBacks.Count;
-	}
-
-	public bool CanToggleFavoriteCardBack(int cardBackId)
-	{
-		bool flag = IsCardBackOwned(cardBackId);
-		bool flag2 = IsCardBackFavorited(cardBackId);
-		bool flag3 = TotalFavoriteCardBacks() > 1;
-		if (!MultipleFavoriteCardBacksEnabled())
-		{
-			if (flag)
-			{
-				return !flag2;
-			}
-			return false;
-		}
-		if (flag)
-		{
-			return !flag2 || flag3;
-		}
-		return false;
-	}
-
-	public int GetCollectionManagerCardBackPurchaseProductId(int cardBackId)
-	{
-		CardBackDbfRecord record = GameDbf.CardBack.GetRecord(cardBackId);
-		if (record == null)
-		{
-			Debug.LogError("CardBackManager:GetCollectionManagerCardBackPurchaseProductId failed to find card back " + cardBackId + " in the CardBack database");
-			return 0;
-		}
-		return record.CollectionManagerPurchaseProductId;
-	}
-
-	public bool CanBuyCardBackFromCollectionManager(int cardBackId)
-	{
-		if (IsCardBackOwned(cardBackId))
-		{
-			return false;
-		}
-		if (!IsCardBackPurchasableFromCollectionManager(cardBackId))
-		{
-			return false;
-		}
-		if (NetCache.Get().GetGoldBalance() < GetCollectionManagerCardBackGoldCost(cardBackId))
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public bool IsCardBackPurchasableFromCollectionManager(int cardBackId)
-	{
+            {
+                hashSet.Add(cardBackDatum.Key);
+            }
+        }
+        return hashSet;
+    }
+
+    public bool IsCardBackOwned(int cardBackID)
+    {
+        NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
+        if (cardBacks == null)
+        {
+            UnityEngine.Debug.LogWarning($"CardBackManager.IsCardBackOwned({cardBackID}): trying to access NetCacheCardBacks before it's been loaded");
+            return false;
+        }
+        return cardBacks.CardBacks.Contains(cardBackID);
+    }
+
+    public bool IsCardBackFavorited(int cardBackID)
+    {
+        NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
+        if (cardBacks == null)
+        {
+            UnityEngine.Debug.LogWarning($"CardBackManager.IsCardBackFavorited({cardBackID}): trying to access NetCacheCardBacks before it's been loaded");
+            return false;
+        }
+        return cardBacks.FavoriteCardBacks.Contains(cardBackID);
+    }
+
+    public int TotalFavoriteCardBacks()
+    {
+        NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
+        if (cardBacks == null)
+        {
+            UnityEngine.Debug.LogWarning($"CardBackManager.TotalFavoriteCardBacks(): trying to access NetCacheCardBacks before it's been loaded");
+            return 0;
+        }
+        return cardBacks.FavoriteCardBacks.Count;
+    }
+
+    public bool CanToggleFavoriteCardBack(int cardBackId)
+    {
+        bool flag = IsCardBackOwned(cardBackId);
+        bool flag2 = IsCardBackFavorited(cardBackId);
+        bool flag3 = TotalFavoriteCardBacks() > 1;
+        if (!MultipleFavoriteCardBacksEnabled())
+        {
+            if (flag)
+            {
+                return !flag2;
+            }
+            return false;
+        }
+        if (flag)
+        {
+            return !flag2 || flag3;
+        }
+        return false;
+    }
+
+    public int GetCollectionManagerCardBackPurchaseProductId(int cardBackId)
+    {
+        CardBackDbfRecord record = GameDbf.CardBack.GetRecord(cardBackId);
+        if (record == null)
+        {
+            UnityEngine.Debug.LogError("CardBackManager:GetCollectionManagerCardBackPurchaseProductId failed to find card back " + cardBackId + " in the CardBack database");
+            return 0;
+        }
+        return record.CollectionManagerPurchaseProductId;
+    }
+
+    public bool CanBuyCardBackFromCollectionManager(int cardBackId)
+    {
+        if (IsCardBackOwned(cardBackId))
+        {
+            return false;
+        }
+        if (!IsCardBackPurchasableFromCollectionManager(cardBackId))
+        {
+            return false;
+        }
+        if (NetCache.Get().GetGoldBalance() < GetCollectionManagerCardBackGoldCost(cardBackId))
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public bool IsCardBackPurchasableFromCollectionManager(int cardBackId)
+    {
 		if (!StoreManager.Get().IsOpen())
-		{
-			return false;
-		}
-		if (!StoreManager.Get().IsBuyCardBacksFromCollectionManagerEnabled())
-		{
-			return false;
-		}
-		if (GetCollectionManagerCardBackPurchaseProductId(cardBackId) <= 0)
-		{
-			return false;
-		}
-		if (GetCollectionManagerCardBackPriceDataModel(cardBackId) == null)
-		{
-			Debug.LogError("CardBackManager:IsCardBackPurchasableFromCollectionManager failed to get the price data model for Card Back " + cardBackId);
-			return false;
-		}
-		return true;
-	}
+        {
+            return false;
+        }
+        if (!StoreManager.Get().IsBuyCardBacksFromCollectionManagerEnabled())
+        {
+            return false;
+        }
+        if (GetCollectionManagerCardBackPurchaseProductId(cardBackId) <= 0)
+        {
+            return false;
+        }
+        if (GetCollectionManagerCardBackPriceDataModel(cardBackId) == null)
+        {
+            UnityEngine.Debug.LogError("CardBackManager:IsCardBackPurchasableFromCollectionManager failed to get the price data model for Card Back " + cardBackId);
+            return false;
+        }
+        return true;
+    }
 
 	public ProductInfo GetCollectionManagerCardBackProductBundle(int cardBackId)
-	{
-		int collectionManagerCardBackPurchaseProductId = GetCollectionManagerCardBackPurchaseProductId(cardBackId);
+    {
+        int collectionManagerCardBackPurchaseProductId = GetCollectionManagerCardBackPurchaseProductId(cardBackId);
 		if (!ProductId.IsValid(collectionManagerCardBackPurchaseProductId) || !ServiceManager.TryGet<IProductDataService>(out var service))
-		{
-			return null;
-		}
+        {
+            return null;
+        }
 		if (!service.TryGetProduct(collectionManagerCardBackPurchaseProductId, out var product))
-		{
-			Debug.LogError("CardBackManager:GetCollectionManagerCardBackProductBundle: Did not find a bundle with pmtProductId " + collectionManagerCardBackPurchaseProductId + " for Card Back " + cardBackId);
-			return null;
-		}
+        {
+            UnityEngine.Debug.LogError("CardBackManager:GetCollectionManagerCardBackProductBundle: Did not find a bundle with pmtProductId " + collectionManagerCardBackPurchaseProductId + " for Card Back " + cardBackId);
+            return null;
+        }
 		if (product.Items == null && !product.Items.Any((Network.BundleItem x) => x.ItemType == ProductType.PRODUCT_TYPE_CARD_BACK && x.ProductData == cardBackId))
-		{
-			Debug.LogError("CardBackManager:GetCollectionManagerCardBackProductBundle: Did not find any items with type PRODUCT_TYPE_CARD_BACK for bundle with pmtProductId " + collectionManagerCardBackPurchaseProductId + " for Card Back " + cardBackId);
-			return null;
-		}
+        {
+            UnityEngine.Debug.LogError("CardBackManager:GetCollectionManagerCardBackProductBundle: Did not find any items with type PRODUCT_TYPE_CARD_BACK for bundle with pmtProductId " + collectionManagerCardBackPurchaseProductId + " for Card Back " + cardBackId);
+            return null;
+        }
 		return product;
-	}
+    }
 
-	public PriceDataModel GetCollectionManagerCardBackPriceDataModel(int cardBackId)
-	{
+    public PriceDataModel GetCollectionManagerCardBackPriceDataModel(int cardBackId)
+    {
 		ProductInfo collectionManagerCardBackProductBundle = GetCollectionManagerCardBackProductBundle(cardBackId);
-		if (collectionManagerCardBackProductBundle == null)
-		{
-			Debug.LogError("CardBackManager:GetCollectionManagerCardBackPriceDataModel failed to get bundle for Card Back " + cardBackId);
-			return null;
-		}
+        if (collectionManagerCardBackProductBundle == null)
+        {
+            UnityEngine.Debug.LogError("CardBackManager:GetCollectionManagerCardBackPriceDataModel failed to get bundle for Card Back " + cardBackId);
+            return null;
+        }
 		if (!collectionManagerCardBackProductBundle.HasCurrency(CurrencyType.GOLD))
-		{
-			Debug.LogError("CardBackManager:GetCollectionManagerCardBackPriceDataModel bundle for Card Back " + cardBackId + " has no GTAPP gold cost");
-			return null;
-		}
+        {
+            UnityEngine.Debug.LogError("CardBackManager:GetCollectionManagerCardBackPriceDataModel bundle for Card Back " + cardBackId + " has no GTAPP gold cost");
+            return null;
+        }
 		return collectionManagerCardBackProductBundle.GetPriceDataModel(CurrencyType.GOLD);
-	}
+    }
 
-	private long GetCollectionManagerCardBackGoldCost(int cardBackId)
-	{
+    private long GetCollectionManagerCardBackGoldCost(int cardBackId)
+    {
 		ProductInfo collectionManagerCardBackProductBundle = GetCollectionManagerCardBackProductBundle(cardBackId);
-		if (collectionManagerCardBackProductBundle == null)
-		{
-			Debug.LogError("CardBackManager:GetCollectionManagerCardBackGoldCost called for a card back with no valid product bundle. Card Back Id = " + cardBackId);
-			return 0L;
-		}
+        if (collectionManagerCardBackProductBundle == null)
+        {
+            UnityEngine.Debug.LogError("CardBackManager:GetCollectionManagerCardBackGoldCost called for a card back with no valid product bundle. Card Back Id = " + cardBackId);
+            return 0L;
+        }
 		if (!collectionManagerCardBackProductBundle.TryGetVCPrice(CurrencyType.GOLD, out var price))
-		{
-			Debug.LogError("CardBackManager:GetCollectionManagerCardBackGoldCost called for a card back with no gold cost. Card Back Id = " + cardBackId);
-			return 0L;
-		}
+        {
+            UnityEngine.Debug.LogError("CardBackManager:GetCollectionManagerCardBackGoldCost called for a card back with no gold cost. Card Back Id = " + cardBackId);
+            return 0L;
+        }
 		return price;
-	}
-
-	public List<OwnedCardBack> GetPageOfCardBacks(bool requireOwned, int currentPage)
-	{
-		int maxCardsPerPage = CollectiblePageDisplay.GetMaxCardsPerPage();
-		return GetFilteredCardBacks(requireOwned).Skip(maxCardsPerPage * (currentPage - 1)).Take(maxCardsPerPage).ToList();
-	}
+    }
+
+    public List<OwnedCardBack> GetPageOfCardBacks(bool requireOwned, int currentPage)
+    {
+        int maxCardsPerPage = CollectiblePageDisplay.GetMaxCardsPerPage();
+        return GetFilteredCardBacks(requireOwned).Skip(maxCardsPerPage * (currentPage - 1)).Take(maxCardsPerPage).ToList();
+    }
+
+    public List<OwnedCardBack> GetFilteredCardBacks(bool requireOwned)
+    {
+        return (from cardBack in GetAllOrderedCardBacks()
+                where ShouldIncludeCardBack(cardBack, requireOwned)
+                select cardBack).ToList();
+    }
+
+    public List<OwnedCardBack> GetAllOrderedCardBacks()
+    {
+        CollectibleDisplay collectibleDisplay = CollectionManager.Get()?.GetCollectibleDisplay();
+        bool flag = collectibleDisplay != null && collectibleDisplay.ViewModeChangedListenerExists(OnSwitchViewMode);
+        if (!m_shouldSort && m_sortedCardBacks != null && flag)
+        {
+            return m_sortedCardBacks;
+        }
+        List<OwnedCardBack> list = new List<OwnedCardBack>();
+        foreach (CardBackData value in m_cardBackData.Values)
+        {
+            if (value.Enabled)
+            {
+                CardBackDbfRecord record = GameDbf.CardBack.GetRecord(value.ID);
+                long seasonId = -1L;
+                if (record.Source == Assets.CardBack.Source.SEASON)
+                {
+                    seasonId = record.Data1;
+                }
+                list.Add(new OwnedCardBack
+                {
+                    m_cardBackId = value.ID,
+                    m_name = value.Name,
+                    m_owned = IsCardBackOwned(value.ID),
+                    m_favorited = IsCardBackFavorited(value.ID),
+                    m_canBuy = CanBuyCardBackFromCollectionManager(value.ID),
+                    m_sortOrder = record.SortOrder,
+                    m_sortCategory = (int)record.SortCategory,
+                    m_seasonId = seasonId
+                });
+            }
+        }
+        list.Sort(delegate (OwnedCardBack lhs, OwnedCardBack rhs)
+        {
+            if (MultipleFavoriteCardBacksEnabled() && lhs.m_favorited != rhs.m_favorited)
+            {
+                if (!lhs.m_favorited)
+                {
+                    return 1;
+                }
+                return -1;
+            }
+            if (lhs.m_owned != rhs.m_owned)
+            {
+                if (!lhs.m_owned)
+                {
+                    return 1;
+                }
+                return -1;
+            }
+            if (lhs.m_canBuy != rhs.m_canBuy)
+            {
+                if (!lhs.m_canBuy)
+                {
+                    return 1;
+                }
+                return -1;
+            }
+            if (lhs.m_sortCategory != rhs.m_sortCategory)
+            {
+                if (lhs.m_sortCategory >= rhs.m_sortCategory)
+                {
+                    return 1;
+                }
+                return -1;
+            }
+            if (lhs.m_sortOrder != rhs.m_sortOrder)
+            {
+                if (lhs.m_sortOrder >= rhs.m_sortOrder)
+                {
+                    return 1;
+                }
+                return -1;
+            }
+            return (lhs.m_seasonId != rhs.m_seasonId) ? ((lhs.m_seasonId <= rhs.m_seasonId) ? 1 : (-1)) : Mathf.Clamp(lhs.m_cardBackId - rhs.m_cardBackId, -1, 1);
+        });
+        m_sortedCardBacks = list;
+        SetShouldSort(shouldSort: false);
+        if (collectibleDisplay != null && !flag)
+        {
+            collectibleDisplay.OnViewModeChanged += OnSwitchViewMode;
+        }
+        return m_sortedCardBacks;
+    }
+
+    private void OnSwitchViewMode(CollectionUtils.ViewMode prevMode, CollectionUtils.ViewMode mode, CollectionUtils.ViewModeData userdata, bool triggerResponse)
+    {
+        if (mode != CollectionUtils.ViewMode.CARD_BACKS)
+        {
+            SetShouldSort(shouldSort: true);
+        }
+    }
+
+    public void SetShouldSort(bool shouldSort)
+    {
+        m_shouldSort = shouldSort;
+    }
+
+    public void SetCardBackTexture(Renderer renderer, int matIdx, CardBackSlot slot)
+    {
+        if (IsCardBackLoading(slot))
+        {
+            Processor.RunCoroutine(SetTextureWhenLoaded(renderer, matIdx, slot));
+        }
+        else
+        {
+            SetTexture(renderer, matIdx, slot);
+        }
+    }
+
+    public void SetCardBackMaterial(Renderer renderer, int matIdx, CardBackSlot slot)
+    {
+        if (IsCardBackLoading(slot))
+        {
+            Processor.RunCoroutine(SetMaterialWhenLoaded(renderer, matIdx, slot));
+        }
+        else
+        {
+            SetMaterial(renderer, matIdx, slot);
+        }
+    }
+
+    public void UpdateCardBack(Actor actor, CardBack cardBack)
+    {
+        if (!(actor.gameObject == null) && !(actor.m_cardMesh == null) && !(cardBack == null))
+        {
+            SetCardBack(actor.m_cardMesh, cardBack);
+        }
+    }
+
+    public void UpdateCardBackWithInternalCardBack(Actor actor)
+    {
+        if (!(actor.gameObject == null) && !(actor.m_cardMesh == null))
+        {
+            CardBack componentInChildren = actor.gameObject.GetComponentInChildren<CardBack>();
+            if (!(componentInChildren == null))
+            {
+                SetCardBack(actor.m_cardMesh, componentInChildren);
+            }
+        }
+    }
+
+    public void UpdateCardBack(GameObject go, CardBackSlot slot)
+    {
+        if (!(go == null))
+        {
+            if (IsCardBackLoading(slot))
+            {
+                Processor.RunCoroutine(SetCardBackWhenLoaded(go, slot));
+            }
+            else
+            {
+                SetCardBack(go, slot);
+            }
+        }
+    }
+
+    public void UpdateDeck(GameObject go, CardBackSlot slot)
+    {
+        if (!(go == null))
+        {
+            Processor.RunCoroutine(SetDeckCardBackWhenLoaded(go, slot));
+        }
+    }
+
+    public void UpdateDragEffect(GameObject go, CardBackSlot slot)
+    {
+        if (!(go == null))
+        {
+            if (IsCardBackLoading(slot))
+            {
+                Processor.RunCoroutine(SetDragEffectsWhenLoaded(go, slot));
+            }
+            else
+            {
+                SetDragEffects(go, slot);
+            }
+        }
+    }
+
+    public bool IsActorFriendly(Actor actor)
+    {
+        if (actor == null)
+        {
+            Log.CardbackMgr.Print("CardBack IsActorFriendly: actor is null!");
+            return true;
+        }
+        Entity entity = actor.GetEntity();
+        if (entity != null)
+        {
+            Player controller = entity.GetController();
+            if (controller != null && controller.GetSide() == Player.Side.OPPOSING)
+            {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public int GetRandomCardBackIdOwnedByPlayer(bool shouldLimitToFavorites = false)
+    {
+        NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
+        if (cardBacks == null)
+        {
+            UnityEngine.Debug.LogWarning($"CardBackMaanager.GetRandomCardBackIdOwnedByPlayer({shouldLimitToFavorites}): trying to access NetCacheCardBacks before it's been loaded");
+            return 0;
+        }
+        HashSet<int> obj = (shouldLimitToFavorites ? cardBacks.FavoriteCardBacks : cardBacks.CardBacks);
+        List<int> list = new List<int>();
+        foreach (int item in obj)
+        {
+            CardBackDbfRecord record = GameDbf.CardBack.GetRecord(item);
+            if (record.Enabled && !record.IsRandomCardBack)
+            {
+                list.Add(item);
+            }
+        }
+        int result = 0;
+        if (list.Count > 0)
+        {
+            int index = UnityEngine.Random.Range(0, list.Count);
+            result = list[index];
+        }
+        return result;
+    }
+
+    public void FindCardBackToUse(long deckId, out int cardBackToUse, out int? deckCardBack)
+    {
+        CollectionDeck collectionDeck = CollectionManager.Get()?.GetDeck(deckId);
+        deckCardBack = collectionDeck?.CardBackID;
+        if (collectionDeck == null)
+        {
+            bool shouldLimitToFavorites = !GameUtils.IsGSDFlagSet(GameSaveKeyId.COLLECTION_MANAGER, GameSaveKeySubkeyId.COLLECTION_MANAGER_RANDOM_CARD_BACK_USE_ALL_OWNED);
+            cardBackToUse = GetRandomCardBackIdOwnedByPlayer(shouldLimitToFavorites);
+        }
+        else if (!deckCardBack.HasValue)
+        {
+            cardBackToUse = GetRandomCardBackIdOwnedByPlayer(shouldLimitToFavorites: true);
+        }
+        else
+        {
+            cardBackToUse = deckCardBack.Value;
+        }
+        CardBackDbfRecord record = GameDbf.CardBack.GetRecord(cardBackToUse);
+        if (record.IsRandomCardBack && record.Enabled)
+        {
+            cardBackToUse = GetRandomCardBackIdOwnedByPlayer();
+        }
+    }
+
+    public void LoadRandomCardBackIntoFavoriteSlot(bool updateScene)
+    {
+        if (!ServiceManager.TryGet<GameMgr>(out var service) || !service.IsSpectator())
+        {
+            bool shouldLimitToFavorites = !GameUtils.IsGSDFlagSet(GameSaveKeyId.COLLECTION_MANAGER, GameSaveKeySubkeyId.COLLECTION_MANAGER_RANDOM_CARD_BACK_USE_ALL_OWNED);
+            int randomCardBackIdOwnedByPlayer = GetRandomCardBackIdOwnedByPlayer(shouldLimitToFavorites);
+            LoadCardBackIdIntoSlot(randomCardBackIdOwnedByPlayer, CardBackSlot.FAVORITE);
+            if (updateScene)
+            {
+                UpdateAllCardBacksInSceneWhenReady();
+            }
+        }
+    }
+
+    public bool MultipleFavoriteCardBacksEnabled()
+    {
+        return NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().Collection.MultipleFavoriteCardBacks;
+    }
+
+    private void InitCardBackSlots()
+    {
+        CardBackData cardBackData = m_cardBackData[0];
+        LoadCardBackPrefabIntoSlot(cardBackData.PrefabName, CardBackSlot.DEFAULT);
+        if (!Application.isEditor)
+        {
+            return;
+        }
+        if (Options.Get().HasOption(Option.CARD_BACK))
+        {
+            int @int = Options.Get().GetInt(Option.CARD_BACK);
+            if (m_cardBackData.ContainsKey(@int))
+            {
+                LoadCardBackPrefabIntoSlot(m_cardBackData[@int].PrefabName, CardBackSlot.FRIENDLY);
+            }
+        }
+        if (Options.Get().HasOption(Option.CARD_BACK2))
+        {
+            int int2 = Options.Get().GetInt(Option.CARD_BACK2);
+            if (m_cardBackData.ContainsKey(int2))
+            {
+                LoadCardBackPrefabIntoSlot(m_cardBackData[int2].PrefabName, CardBackSlot.OPPONENT);
+            }
+        }
+    }
+
+    public void InitCardBackData()
+    {
+        List<CardBackData> list = new List<CardBackData>();
+        foreach (CardBackDbfRecord record in GameDbf.CardBack.GetRecords())
+        {
+            if (record.IsRandomCardBack)
+            {
+                TheRandomCardBackID = record.ID;
+            }
+            else
+            {
+                list.Add(new CardBackData(record.ID, record.Source, record.Data1, record.Name, record.Enabled, record.PrefabName));
+            }
+        }
+        m_cardBackData = new Map<int, CardBackData>();
+        foreach (CardBackData item in list)
+        {
+            m_cardBackData[item.ID] = item;
+        }
+        m_LoadedCardBacks = new Map<string, CardBack>();
+        m_LoadedCardBacksBySlot = new Map<CardBackSlot, CardBackSlotData>();
+    }
+
+    private IEnumerator SetTextureWhenLoaded(Renderer renderer, int matIdx, CardBackSlot slot)
+    {
+        while (IsCardBackLoading(slot))
+        {
+            yield return null;
+        }
+        SetTexture(renderer, matIdx, slot);
+    }
+
+    private void SetTexture(Renderer renderer, int matIdx, CardBackSlot slot)
+    {
+        if (renderer == null)
+        {
+            return;
+        }
+        int count = renderer.GetMaterials().Count;
+        if (matIdx < 0 || matIdx >= count)
+        {
+            UnityEngine.Debug.LogWarningFormat("CardBackManager SetTexture(): matIdx {0} is not within the bounds of renderer's materials (count {1})", matIdx, count);
+            return;
+        }
+        CardBack cardBackBySlot = GetCardBackBySlot(slot);
+        if (!(cardBackBySlot == null))
+        {
+            Texture cardBackTexture = cardBackBySlot.m_CardBackTexture;
+            if (cardBackTexture == null)
+            {
+                UnityEngine.Debug.LogWarning($"CardBackManager SetTexture(): texture is null!   obj: {renderer.gameObject.name}  slot: {slot}");
+            }
+            else
+            {
+                renderer.GetMaterial(matIdx).mainTexture = cardBackTexture;
+            }
+        }
+    }
+
+    private IEnumerator SetMaterialWhenLoaded(Renderer renderer, int matIdx, CardBackSlot slot)
+    {
+        while (IsCardBackLoading(slot))
+        {
+            yield return null;
+        }
+        SetMaterial(renderer, matIdx, slot);
+    }
+
+    private void SetMaterial(Renderer renderer, int matIdx, CardBackSlot slot)
+    {
+        if (renderer == null)
+        {
+            return;
+        }
+        int count = renderer.GetMaterials().Count;
+        if (matIdx < 0 || matIdx >= count)
+        {
+            UnityEngine.Debug.LogWarningFormat("CardBackManager SetMaterial(): matIdx {0} is not within the bounds of renderer's materials (count {1})", matIdx, count);
+            return;
+        }
+        CardBack cardBackBySlot = GetCardBackBySlot(slot);
+        if (!(cardBackBySlot == null))
+        {
+            Material cardBackMaterial2D = cardBackBySlot.m_CardBackMaterial2D;
+            if (cardBackMaterial2D == null)
+            {
+                SetTexture(renderer, matIdx, slot);
+            }
+            else
+            {
+                renderer.SetSharedMaterial(matIdx, cardBackMaterial2D);
+            }
+        }
+    }
 
-	public List<OwnedCardBack> GetFilteredCardBacks(bool requireOwned)
-	{
-		return (from cardBack in GetAllOrderedCardBacks()
-			where ShouldIncludeCardBack(cardBack, requireOwned)
-			select cardBack).ToList();
-	}
-
-	public List<OwnedCardBack> GetAllOrderedCardBacks()
+	public Material GetCardBackMaterialFromSlot(CardBackSlot slot)
 	{
-		CollectibleDisplay collectibleDisplay = CollectionManager.Get()?.GetCollectibleDisplay();
-		bool flag = collectibleDisplay != null && collectibleDisplay.ViewModeChangedListenerExists(OnSwitchViewMode);
-		if (!m_shouldSort && m_sortedCardBacks != null && flag)
+		CardBack cardBackBySlot = GetCardBackBySlot(slot);
+		if (cardBackBySlot == null)
 		{
-			return m_sortedCardBacks;
-		}
-		List<OwnedCardBack> list = new List<OwnedCardBack>();
-		foreach (CardBackData value in m_cardBackData.Values)
-		{
-			if (value.Enabled)
-			{
-				CardBackDbfRecord record = GameDbf.CardBack.GetRecord(value.ID);
-				long seasonId = -1L;
-				if (record.Source == Assets.CardBack.Source.SEASON)
-				{
-					seasonId = record.Data1;
-				}
-				list.Add(new OwnedCardBack
-				{
-					m_cardBackId = value.ID,
-					m_name = value.Name,
-					m_owned = IsCardBackOwned(value.ID),
-					m_favorited = IsCardBackFavorited(value.ID),
-					m_canBuy = CanBuyCardBackFromCollectionManager(value.ID),
-					m_sortOrder = record.SortOrder,
-					m_sortCategory = (int)record.SortCategory,
-					m_seasonId = seasonId
-				});
-			}
-		}
-		list.Sort(delegate(OwnedCardBack lhs, OwnedCardBack rhs)
-		{
-			if (MultipleFavoriteCardBacksEnabled() && lhs.m_favorited != rhs.m_favorited)
-			{
-				if (!lhs.m_favorited)
-				{
-					return 1;
-				}
-				return -1;
-			}
-			if (lhs.m_owned != rhs.m_owned)
-			{
-				if (!lhs.m_owned)
-				{
-					return 1;
-				}
-				return -1;
-			}
-			if (lhs.m_canBuy != rhs.m_canBuy)
-			{
-				if (!lhs.m_canBuy)
-				{
-					return 1;
-				}
-				return -1;
-			}
-			if (lhs.m_sortCategory != rhs.m_sortCategory)
-			{
-				if (lhs.m_sortCategory >= rhs.m_sortCategory)
-				{
-					return 1;
-				}
-				return -1;
-			}
-			if (lhs.m_sortOrder != rhs.m_sortOrder)
-			{
-				if (lhs.m_sortOrder >= rhs.m_sortOrder)
-				{
-					return 1;
-				}
-				return -1;
-			}
-			return (lhs.m_seasonId != rhs.m_seasonId) ? ((lhs.m_seasonId <= rhs.m_seasonId) ? 1 : (-1)) : Mathf.Clamp(lhs.m_cardBackId - rhs.m_cardBackId, -1, 1);
-		});
-		m_sortedCardBacks = list;
-		SetShouldSort(shouldSort: false);
-		if (collectibleDisplay != null && !flag)
-		{
-			collectibleDisplay.OnViewModeChanged += OnSwitchViewMode;
-		}
-		return m_sortedCardBacks;
-	}
-
-	private void OnSwitchViewMode(CollectionUtils.ViewMode prevMode, CollectionUtils.ViewMode mode, CollectionUtils.ViewModeData userdata, bool triggerResponse)
-	{
-		if (mode != CollectionUtils.ViewMode.CARD_BACKS)
-		{
-			SetShouldSort(shouldSort: true);
-		}
-	}
-
-	public void SetShouldSort(bool shouldSort)
-	{
-		m_shouldSort = shouldSort;
-	}
-
-	public void SetCardBackTexture(Renderer renderer, int matIdx, CardBackSlot slot)
-	{
-		if (IsCardBackLoading(slot))
-		{
-			Processor.RunCoroutine(SetTextureWhenLoaded(renderer, matIdx, slot));
-		}
-		else
-		{
-			SetTexture(renderer, matIdx, slot);
-		}
-	}
-
-	public void SetCardBackMaterial(Renderer renderer, int matIdx, CardBackSlot slot)
-	{
-		if (IsCardBackLoading(slot))
-		{
-			Processor.RunCoroutine(SetMaterialWhenLoaded(renderer, matIdx, slot));
-		}
-		else
-		{
-			SetMaterial(renderer, matIdx, slot);
-		}
-	}
-
-	public void UpdateCardBack(Actor actor, CardBack cardBack)
-	{
-		if (!(actor.gameObject == null) && !(actor.m_cardMesh == null) && !(cardBack == null))
-		{
-			SetCardBack(actor.m_cardMesh, cardBack);
-		}
-	}
-
-	public void UpdateCardBackWithInternalCardBack(Actor actor)
-	{
-		if (!(actor.gameObject == null) && !(actor.m_cardMesh == null))
-		{
-			CardBack componentInChildren = actor.gameObject.GetComponentInChildren<CardBack>();
-			if (!(componentInChildren == null))
-			{
-				SetCardBack(actor.m_cardMesh, componentInChildren);
-			}
-		}
-	}
-
-	public void UpdateCardBack(GameObject go, CardBackSlot slot)
-	{
-		if (!(go == null))
-		{
-			if (IsCardBackLoading(slot))
-			{
-				Processor.RunCoroutine(SetCardBackWhenLoaded(go, slot));
-			}
-			else
-			{
-				SetCardBack(go, slot);
-			}
-		}
-	}
-
-	public void UpdateDeck(GameObject go, CardBackSlot slot)
-	{
-		if (!(go == null))
-		{
-			Processor.RunCoroutine(SetDeckCardBackWhenLoaded(go, slot));
-		}
-	}
-
-	public void UpdateDragEffect(GameObject go, CardBackSlot slot)
-	{
-		if (!(go == null))
-		{
-			if (IsCardBackLoading(slot))
-			{
-				Processor.RunCoroutine(SetDragEffectsWhenLoaded(go, slot));
-			}
-			else
-			{
-				SetDragEffects(go, slot);
-			}
-		}
-	}
-
-	public bool IsActorFriendly(Actor actor)
-	{
-		if (actor == null)
-		{
-			Log.CardbackMgr.Print("CardBack IsActorFriendly: actor is null!");
-			return true;
-		}
-		Entity entity = actor.GetEntity();
-		if (entity != null)
-		{
-			Player controller = entity.GetController();
-			if (controller != null && controller.GetSide() == Player.Side.OPPOSING)
-			{
-				return false;
-			}
-		}
-		return true;
-	}
-
-	public int GetRandomCardBackIdOwnedByPlayer(bool shouldLimitToFavorites = false)
-	{
-		NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
-		if (cardBacks == null)
-		{
-			Debug.LogWarning($"CardBackMaanager.GetRandomCardBackIdOwnedByPlayer({shouldLimitToFavorites}): trying to access NetCacheCardBacks before it's been loaded");
-			return 0;
-		}
-		HashSet<int> obj = (shouldLimitToFavorites ? cardBacks.FavoriteCardBacks : cardBacks.CardBacks);
-		List<int> list = new List<int>();
-		foreach (int item in obj)
-		{
-			CardBackDbfRecord record = GameDbf.CardBack.GetRecord(item);
-			if (record.Enabled && !record.IsRandomCardBack)
-			{
-				list.Add(item);
-			}
-		}
-		int result = 0;
-		if (list.Count > 0)
-		{
-			int index = UnityEngine.Random.Range(0, list.Count);
-			result = list[index];
-		}
-		return result;
-	}
-
-	public void FindCardBackToUse(long deckId, out int cardBackToUse, out int? deckCardBack)
-	{
-		CollectionDeck collectionDeck = CollectionManager.Get()?.GetDeck(deckId);
-		deckCardBack = collectionDeck?.CardBackID;
-		if (collectionDeck == null)
-		{
-			bool shouldLimitToFavorites = !GameUtils.IsGSDFlagSet(GameSaveKeyId.COLLECTION_MANAGER, GameSaveKeySubkeyId.COLLECTION_MANAGER_RANDOM_CARD_BACK_USE_ALL_OWNED);
-			cardBackToUse = GetRandomCardBackIdOwnedByPlayer(shouldLimitToFavorites);
-		}
-		else if (!deckCardBack.HasValue)
-		{
-			cardBackToUse = GetRandomCardBackIdOwnedByPlayer(shouldLimitToFavorites: true);
-		}
-		else
-		{
-			cardBackToUse = deckCardBack.Value;
-		}
-		CardBackDbfRecord record = GameDbf.CardBack.GetRecord(cardBackToUse);
-		if (record.IsRandomCardBack && record.Enabled)
-		{
-			cardBackToUse = GetRandomCardBackIdOwnedByPlayer();
-		}
-	}
-
-	public void LoadRandomCardBackIntoFavoriteSlot(bool updateScene)
-	{
-		if (!ServiceManager.TryGet<GameMgr>(out var service) || !service.IsSpectator())
-		{
-			bool shouldLimitToFavorites = !GameUtils.IsGSDFlagSet(GameSaveKeyId.COLLECTION_MANAGER, GameSaveKeySubkeyId.COLLECTION_MANAGER_RANDOM_CARD_BACK_USE_ALL_OWNED);
-			int randomCardBackIdOwnedByPlayer = GetRandomCardBackIdOwnedByPlayer(shouldLimitToFavorites);
-			LoadCardBackIdIntoSlot(randomCardBackIdOwnedByPlayer, CardBackSlot.FAVORITE);
-			if (updateScene)
-			{
-				UpdateAllCardBacksInSceneWhenReady();
-			}
-		}
-	}
-
-	public bool MultipleFavoriteCardBacksEnabled()
-	{
-		return NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().Collection.MultipleFavoriteCardBacks;
-	}
-
-	private void InitCardBackSlots()
-	{
-		CardBackData cardBackData = m_cardBackData[0];
-		LoadCardBackPrefabIntoSlot(cardBackData.PrefabName, CardBackSlot.DEFAULT);
-		if (!Application.isEditor)
-		{
-			return;
-		}
-		if (Options.Get().HasOption(Option.CARD_BACK))
-		{
-			int @int = Options.Get().GetInt(Option.CARD_BACK);
-			if (m_cardBackData.ContainsKey(@int))
-			{
-				LoadCardBackPrefabIntoSlot(m_cardBackData[@int].PrefabName, CardBackSlot.FRIENDLY);
-			}
-		}
-		if (Options.Get().HasOption(Option.CARD_BACK2))
-		{
-			int int2 = Options.Get().GetInt(Option.CARD_BACK2);
-			if (m_cardBackData.ContainsKey(int2))
-			{
-				LoadCardBackPrefabIntoSlot(m_cardBackData[int2].PrefabName, CardBackSlot.OPPONENT);
-			}
-		}
-	}
-
-	public void InitCardBackData()
-	{
-		List<CardBackData> list = new List<CardBackData>();
-		foreach (CardBackDbfRecord record in GameDbf.CardBack.GetRecords())
-		{
-			if (record.IsRandomCardBack)
-			{
-				TheRandomCardBackID = record.ID;
-			}
-			else
-			{
-				list.Add(new CardBackData(record.ID, record.Source, record.Data1, record.Name, record.Enabled, record.PrefabName));
-			}
-		}
-		m_cardBackData = new Map<int, CardBackData>();
-		foreach (CardBackData item in list)
-		{
-			m_cardBackData[item.ID] = item;
-		}
-		m_LoadedCardBacks = new Map<string, CardBack>();
-		m_LoadedCardBacksBySlot = new Map<CardBackSlot, CardBackSlotData>();
-	}
-
-	private IEnumerator SetTextureWhenLoaded(Renderer renderer, int matIdx, CardBackSlot slot)
-	{
-		while (IsCardBackLoading(slot))
-		{
-			yield return null;
-		}
-		SetTexture(renderer, matIdx, slot);
-	}
-
-	private void SetTexture(Renderer renderer, int matIdx, CardBackSlot slot)
-	{
-		if (renderer == null)
-		{
-			return;
-		}
-		int count = renderer.GetMaterials().Count;
-		if (matIdx < 0 || matIdx >= count)
-		{
-			Debug.LogWarningFormat("CardBackManager SetTexture(): matIdx {0} is not within the bounds of renderer's materials (count {1})", matIdx, count);
-			return;
-		}
-		CardBack cardBackBySlot = GetCardBackBySlot(slot);
-		if (!(cardBackBySlot == null))
-		{
-			Texture cardBackTexture = cardBackBySlot.m_CardBackTexture;
-			if (cardBackTexture == null)
-			{
-				Debug.LogWarning($"CardBackManager SetTexture(): texture is null!   obj: {renderer.gameObject.name}  slot: {slot}");
-			}
-			else
-			{
-				renderer.GetMaterial(matIdx).mainTexture = cardBackTexture;
-			}
-		}
-	}
-
-	private IEnumerator SetMaterialWhenLoaded(Renderer renderer, int matIdx, CardBackSlot slot)
-	{
-		while (IsCardBackLoading(slot))
-		{
-			yield return null;
-		}
-		SetMaterial(renderer, matIdx, slot);
-	}
-
-	private void SetMaterial(Renderer renderer, int matIdx, CardBackSlot slot)
-	{
-		if (renderer == null)
-		{
-			return;
-		}
-		int count = renderer.GetMaterials().Count;
-		if (matIdx < 0 || matIdx >= count)
-		{
-			Debug.LogWarningFormat("CardBackManager SetMaterial(): matIdx {0} is not within the bounds of renderer's materials (count {1})", matIdx, count);
-			return;
-		}
-		CardBack cardBackBySlot = GetCardBackBySlot(slot);
-		if (!(cardBackBySlot == null))
-		{
-			Material cardBackMaterial2D = cardBackBySlot.m_CardBackMaterial2D;
-			if (cardBackMaterial2D == null)
-			{
-				SetTexture(renderer, matIdx, slot);
-			}
-			else
-			{
-				renderer.SetSharedMaterial(matIdx, cardBackMaterial2D);
-			}
-		}
-	}
-
-	public Material GetCardBackMaterialFromSlot(CardBackSlot slot)
-	{
-		CardBack cardBackBySlot = GetCardBackBySlot(slot);
-		if (cardBackBySlot == null)
-		{
-			return null;
+			return null;
 		}
 		return cardBackBySlot.m_CardBackMaterial;
 	}
 
-	private IEnumerator SetCardBackWhenLoaded(GameObject go, CardBackSlot slot)
-	{
-		while (IsCardBackLoading(slot))
-		{
-			yield return null;
-		}
-		SetCardBack(go, slot);
-	}
-
-	private void SetCardBack(GameObject go, CardBackSlot slot)
-	{
-		CardBack cardBackBySlot = GetCardBackBySlot(slot);
-		if (cardBackBySlot == null)
-		{
-			Debug.LogWarningFormat("CardBackManager SetCardBack(): cardback not loaded for Slot: {0}", slot);
-			cardBackBySlot = GetCardBackBySlot(CardBackSlot.DEFAULT);
-			if (cardBackBySlot == null)
-			{
-				Debug.LogWarning("CardBackManager SetCardBack(): default cardback not loaded");
-				return;
-			}
-		}
-		SetCardBack(go, cardBackBySlot);
-	}
-
-	public static void SetCardBack(GameObject go, CardBack cardBack)
-	{
-		SetCardBack(go, cardBack, unlit: false, shadowActive: false);
-	}
-
-	public static void SetCardBack(GameObject go, CardBack cardBack, bool unlit, bool shadowActive)
-	{
-		if (cardBack == null)
-		{
-			Debug.LogWarning("CardBackManager SetCardBack() cardback=null");
-			return;
-		}
-		if (go == null)
-		{
-			StackTrace stackTrace = new StackTrace();
-			Debug.LogWarningFormat("CardBackManager SetCardBack() go=null, cardBack.name={0}, stacktrace=\n{1}", cardBack.name, stackTrace.ToString());
-			return;
-		}
-		Mesh cardBackMesh = cardBack.m_CardBackMesh;
-		if (cardBackMesh != null)
-		{
-			MeshFilter component = go.GetComponent<MeshFilter>();
-			if (component != null)
-			{
-				component.mesh = cardBackMesh;
-			}
-		}
-		else
-		{
-			Debug.LogWarning("CardBackManager SetCardBack() mesh=null");
-		}
-		float value = 0f;
-		if (!unlit && SceneMgr.Get() != null && SceneMgr.Get().GetMode() == SceneMgr.Mode.GAMEPLAY)
-		{
-			value = 1f;
-		}
-		Material cardBackMaterial = cardBack.m_CardBackMaterial;
-		Material cardBackMaterial2 = cardBack.m_CardBackMaterial1;
-		Material[] array = new Material[(!(cardBackMaterial2 != null)) ? 1 : 2];
-		array[0] = cardBackMaterial;
-		if (cardBackMaterial2 != null)
-		{
-			array[1] = cardBackMaterial2;
-		}
-		if (array.Length != 0 && array[0] != null)
-		{
-			Renderer component2 = go.GetComponent<Renderer>();
-			component2.SetSharedMaterials(array);
-			List<Material> materials = component2.GetMaterials();
-			float value2 = UnityEngine.Random.Range(0f, 1f);
-			foreach (Material item in materials)
-			{
-				if (!(item == null))
-				{
-					if (item.HasProperty("_Seed") && item.GetFloat("_Seed") == 0f)
-					{
-						item.SetFloat("_Seed", value2);
-					}
-					if (item.HasProperty("_LightingBlend"))
-					{
-						item.SetFloat("_LightingBlend", value);
-					}
-				}
-			}
-		}
-		else
-		{
-			Debug.LogWarning("CardBackManager SetCardBack() material=null");
-		}
-		if (cardBack.cardBackHelper == CardBack.cardBackHelpers.None)
-		{
-			RemoveCardBackHelper<CardBackHelperBubbleLevel>(go);
-		}
-		else if (cardBack.cardBackHelper == CardBack.cardBackHelpers.CardBackHelperBubbleLevel)
-		{
-			AddCardBackHelper<CardBackHelperBubbleLevel>(go);
-		}
-		Actor actor = GameObjectUtils.FindComponentInThisOrParents<Actor>(go);
-		if (actor != null)
-		{
-			actor.UpdateMissingCardArt();
-			actor.EnableCardbackShadow(shadowActive);
-			HighlightState componentInChildren = actor.GetComponentInChildren<HighlightState>();
-			if ((bool)componentInChildren)
-			{
-				componentInChildren.m_StaticSilouetteOverride = cardBack.m_CardBackHighlightTexture;
-			}
-		}
-	}
-
-	private bool ShouldIncludeCardBack(CardBackData cardBackData, bool requireOwned)
-	{
-		if (!cardBackData.Enabled)
-		{
-			return false;
-		}
-		return ShouldIncludeCardBack(cardBackData.ID, cardBackData.Name, requireOwned);
-	}
-
-	private bool ShouldIncludeCardBack(OwnedCardBack ownedCardBack, bool requireOwned)
-	{
-		return ShouldIncludeCardBack(ownedCardBack.m_cardBackId, ownedCardBack.m_name, requireOwned);
-	}
-
-	private bool ShouldIncludeCardBack(int cardBackId, string cardBackName, bool requireOwned)
-	{
-		if (requireOwned && !IsCardBackOwned(cardBackId))
-		{
-			return false;
-		}
-		if (!string.IsNullOrEmpty(m_searchText))
-		{
-			string text = GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_FAVORITE");
-			string text2 = GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_MISSING");
-			string text3 = GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_EXTRA");
-			string[] source = new string[3] { text, text2, text3 };
-			string[] array = m_searchText.ToLower().Split(CollectibleFilteredSet<ICollectible>.SearchTokenDelimiters, StringSplitOptions.RemoveEmptyEntries);
-			if (array.Contains(text3))
-			{
-				return false;
-			}
-			if (MultipleFavoriteCardBacksEnabled() && array.Contains(text))
-			{
-				bool flag = GetCardBacks().FavoriteCardBacks.Count == 0;
-				if (!IsCardBackFavorited(cardBackId) && (!flag || cardBackId != 0))
-				{
-					return false;
-				}
-			}
-			if (array.Contains(text2) && IsCardBackOwned(cardBackId))
-			{
-				return false;
-			}
-			foreach (string value in array)
-			{
-				if (!source.Contains(value) && !cardBackName.ToLower().Contains(value))
-				{
-					return false;
-				}
-			}
-		}
-		return true;
-	}
-
-	public static T AddCardBackHelper<T>(GameObject go) where T : MonoBehaviour
-	{
-		RemoveCardBackHelper<T>(go);
-		return go.AddComponent<T>();
-	}
-
-	public static bool RemoveCardBackHelper<T>(GameObject go) where T : MonoBehaviour
-	{
-		T[] components = go.GetComponents<T>();
-		if (components != null)
-		{
-			T[] array = components;
-			for (int i = 0; i < array.Length; i++)
-			{
-				UnityEngine.Object.Destroy(array[i]);
-			}
-			return true;
-		}
-		return false;
-	}
-
-	private IEnumerator SetDragEffectsWhenLoaded(GameObject go, CardBackSlot slot)
-	{
-		while (IsCardBackLoading(slot))
-		{
-			yield return null;
-		}
-		SetDragEffects(go, slot);
-	}
-
-	private void SetDragEffects(GameObject go, CardBackSlot slot)
-	{
-		if (go == null)
-		{
-			return;
-		}
-		CardBackDragEffect componentInChildren = go.GetComponentInChildren<CardBackDragEffect>();
-		if (componentInChildren == null)
-		{
-			return;
-		}
-		CardBack cardBackBySlot = GetCardBackBySlot(slot);
-		if (!(cardBackBySlot == null))
-		{
-			if (componentInChildren.m_EffectsRoot != null)
-			{
-				UnityEngine.Object.Destroy(componentInChildren.m_EffectsRoot);
-			}
-			if (!(cardBackBySlot.m_DragEffect == null))
-			{
-				GameObject gameObject = (componentInChildren.m_EffectsRoot = UnityEngine.Object.Instantiate(cardBackBySlot.m_DragEffect));
-				gameObject.transform.parent = componentInChildren.gameObject.transform;
-				gameObject.transform.localPosition = Vector3.zero;
-				gameObject.transform.localRotation = Quaternion.identity;
-				gameObject.transform.localScale = Vector3.one;
-			}
-		}
-	}
-
-	private IEnumerator SetDeckCardBackWhenLoaded(GameObject cardBackDeckDisplay, CardBackSlot slot)
-	{
-		while (IsCardBackLoading(slot))
-		{
-			yield return null;
-		}
-		SetDeckCardBack(cardBackDeckDisplay, slot);
-	}
-
-	private void SetDeckCardBack(GameObject cardBackDeckDisplay, CardBackSlot slot)
-	{
-		if (cardBackDeckDisplay == null)
-		{
-			Debug.LogWarning("CardBackManager SetDeckCardBack(): cardBackDeckDisplay GameObject is null! GameObject could have been destroyed while card back was loading.");
-			return;
-		}
-		CardBack cardBackBySlot = GetCardBackBySlot(slot);
-		if (cardBackBySlot == null)
-		{
-			Debug.LogWarning("CardBackManager SetDeckCardBack(): cardBack is null!");
-			return;
-		}
-		ZoneDeck componentInParent = cardBackDeckDisplay.GetComponentInParent<ZoneDeck>();
-		if (componentInParent != null)
-		{
-			if (cardBackBySlot.GetCustomDeckMeshes(out var meshes))
-			{
-				componentInParent.UpdateToCustomDeckMeshes(meshes);
-			}
-			else
-			{
-				componentInParent.TryRestoreOriginalDeckMeshes();
-			}
-		}
-		Texture cardBackTexture = cardBackBySlot.m_CardBackTexture;
-		if (cardBackTexture == null)
-		{
-			Debug.LogWarning("CardBackManager SetDeckCardBack(): texture is null!");
-			return;
-		}
-		Renderer[] componentsInChildren = cardBackDeckDisplay.GetComponentsInChildren<Renderer>();
-		for (int i = 0; i < componentsInChildren.Length; i++)
-		{
-			componentsInChildren[i].GetMaterial().mainTexture = cardBackTexture;
-		}
-	}
-
-	private void OnCheatOptionChanged(Option option, object prevValue, bool existed, object userData)
-	{
-		Log.CardbackMgr.Print("Cheat Option Change Called");
-		int @int = Options.Get().GetInt(option, 0);
-		if (m_cardBackData.ContainsKey(@int))
-		{
-			CardBackSlot slot = CardBackSlot.FRIENDLY;
-			if (option == Option.CARD_BACK2)
-			{
-				slot = CardBackSlot.OPPONENT;
-			}
-			LoadCardBackPrefabIntoSlot(m_cardBackData[@int].PrefabName, slot);
-			UpdateAllCardBacksInSceneWhenReady();
-		}
-	}
-
-	private void NetCache_OnNetCacheCardBacksUpdated()
-	{
-		Processor.RunCoroutine(HandleNetCacheCardBacksWhenReady());
-	}
-
-	private IEnumerator HandleNetCacheCardBacksWhenReady()
-	{
-		while (m_cardBackData == null || FixedRewardsMgr.Get() == null || !FixedRewardsMgr.Get().IsStartupFinished())
-		{
-			yield return null;
-		}
-		NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
-		AddNewCardBack(0);
-		bool flag = false;
-		foreach (int favoriteCardBack in cardBacks.FavoriteCardBacks)
-		{
-			if (m_cardBackData.ContainsKey(favoriteCardBack))
-			{
-				flag = true;
-				break;
-			}
-		}
-		if (!flag)
-		{
-			Log.CardbackMgr.Print("No valid favorite card backs found, set to CardBackDbId.CLASSIC");
-			cardBacks.FavoriteCardBacks = new HashSet<int> { 0 };
-		}
-		LoadRandomCardBackIntoFavoriteSlot(updateScene: false);
-	}
-
-	private IEnumerator UpdateAllCardBacksInSceneWhenReadyImpl()
-	{
-		while (IsCardBackLoading(CardBackSlot.FRIENDLY) || IsCardBackLoading(CardBackSlot.OPPONENT) || IsCardBackLoading(CardBackSlot.FAVORITE))
-		{
-			yield return null;
-		}
-		lock (cardbackListenerCollectionLock)
-		{
-			foreach (UpdateCardbacksListener updateCardbacksListener in m_updateCardbacksListeners)
-			{
-				updateCardbacksListener.Fire();
-			}
-		}
-	}
-
-	private void LoadCardBackPrefabIntoSlot(AssetReference assetRef, CardBackSlot slot)
-	{
-		string text = assetRef.ToString();
-		if (!m_LoadedCardBacksBySlot.TryGetValue(slot, out var value))
-		{
-			value = new CardBackSlotData();
-			m_LoadedCardBacksBySlot[slot] = value;
-		}
-		if (m_LoadedCardBacks.ContainsKey(text))
-		{
-			if (!(m_LoadedCardBacks[text] == null))
-			{
-				value.m_isLoading = false;
-				value.m_cardBackAssetString = text;
-				value.m_cardBack = m_LoadedCardBacks[text];
-				return;
-			}
-			m_LoadedCardBacks.Remove(text);
-		}
-		if (!(value.m_cardBackAssetString == text))
-		{
-			value.m_isLoading = true;
-			value.m_cardBackAssetString = text;
-			value.m_cardBack = null;
-			LoadCardBackData loadCardBackData = new LoadCardBackData();
-			loadCardBackData.m_Slot = slot;
-			loadCardBackData.m_Path = text;
-			AssetLoader.Get().InstantiatePrefab(text, OnCardBackLoaded, loadCardBackData);
-		}
-	}
-
-	private void OnCardBackLoaded(AssetReference assetRef, GameObject go, object callbackData)
-	{
-		LoadCardBackData loadCardBackData = callbackData as LoadCardBackData;
-		if (go == null)
-		{
-			Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): Failed to load CardBack: {0} For: {1}", assetRef, loadCardBackData.m_Slot);
-			m_LoadedCardBacksBySlot.Remove(loadCardBackData.m_Slot);
-			return;
-		}
-		go.transform.parent = SceneObject.transform;
-		go.transform.position = new Vector3(1000f, -1000f, -1000f);
-		CardBack component = go.GetComponent<CardBack>();
-		if (component == null)
-		{
-			Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): Failed to find CardBack component: {0} slot: {1}", loadCardBackData.m_Path, loadCardBackData.m_Slot);
-			return;
-		}
-		if (component.m_CardBackMesh == null)
-		{
-			Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): cardBack.m_CardBackMesh in null! - {0}", loadCardBackData.m_Path);
-			return;
-		}
-		if (component.m_CardBackMaterial == null)
-		{
-			Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): cardBack.m_CardBackMaterial in null! - {0}", loadCardBackData.m_Path);
-			return;
-		}
-		if (component.m_CardBackTexture == null)
-		{
-			Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): cardBack.m_CardBackTexture in null! - {0}", loadCardBackData.m_Path);
-			return;
-		}
-		m_LoadedCardBacks[loadCardBackData.m_Path] = component;
-		if (m_LoadedCardBacksBySlot.TryGetValue(loadCardBackData.m_Slot, out var value))
-		{
-			value.m_isLoading = false;
-			value.m_cardBack = component;
-		}
-	}
-
-	private void OnHiddenActorLoaded(AssetReference assetRef, GameObject go, object callbackData)
-	{
-		LoadCardBackData obj = (LoadCardBackData)callbackData;
-		int cardBackIndex = obj.m_CardBackIndex;
-		string prefabName = m_cardBackData[cardBackIndex].PrefabName;
-		obj.m_GameObject = go;
-		AssetLoader.Get().InstantiatePrefab(prefabName, OnHiddenActorCardBackLoaded, callbackData);
-	}
-
-	private void OnHiddenActorCardBackLoaded(AssetReference assetRef, GameObject go, object callbackData)
-	{
-		if (go == null)
-		{
-			Error.AddDevWarning("Error", "CardBackManager OnHiddenActorCardBackLoaded() path={0}, gameobject=null", assetRef);
-			return;
-		}
-		CardBack componentInChildren = go.GetComponentInChildren<CardBack>();
-		if (componentInChildren == null)
-		{
-			Debug.LogWarningFormat("CardBackManager OnHiddenActorCardBackLoaded() path={0}, gameobject={1}, cardback=null", assetRef, go.name);
-		}
-		else
-		{
-			LoadCardBackData loadCardBackData = (LoadCardBackData)callbackData;
-			loadCardBackData.m_CardBack = componentInChildren;
-			Processor.RunCoroutine(HiddenActorCardBackLoadedSetup(loadCardBackData));
-		}
-	}
-
-	private IEnumerator HiddenActorCardBackLoadedSetup(LoadCardBackData data)
-	{
-		yield return null;
-		yield return null;
-		if (data != null && !(data.m_GameObject == null))
-		{
-			SetCardBack(data.m_GameObject.GetComponent<Actor>().m_cardMesh, data.m_CardBack, data.m_Unlit, data.m_ShadowActive);
-			data.m_CardBack.gameObject.transform.parent = data.m_GameObject.transform;
-			data.m_Callback(data);
-		}
-	}
-
-	private int GetValidCardBackID(int cardBackID)
-	{
-		if (!m_cardBackData.ContainsKey(cardBackID))
-		{
-			Log.CardbackMgr.Print("Cardback ID {0} not found, defaulting to Classic", cardBackID);
-			return 0;
-		}
-		return cardBackID;
-	}
-
-	public void OnFavoriteCardBackChanged(int newFavoriteCardBackID, bool isFavorite)
-	{
-		LoadRandomCardBackIntoFavoriteSlot(updateScene: false);
-		this.OnFavoriteCardBacksChanged?.Invoke(newFavoriteCardBackID, isFavorite);
-	}
-
-	private void OnSceneLoaded(SceneMgr.Mode mode, PegasusScene scene, object userData)
-	{
-		if (GetCardBackBySlot(CardBackSlot.FRIENDLY) == null)
-		{
-			LoadCardBackIdIntoSlot(0, CardBackSlot.FRIENDLY);
-		}
-	}
-
-	private void LoadCardBackIdIntoSlot(int cardBackId, CardBackSlot slot)
-	{
-		int validCardBackID = GetValidCardBackID(cardBackId);
-		if (m_cardBackData.TryGetValue(validCardBackID, out var value))
-		{
-			LoadCardBackPrefabIntoSlot(value.PrefabName, slot);
-		}
-	}
+    private IEnumerator SetCardBackWhenLoaded(GameObject go, CardBackSlot slot)
+    {
+        while (IsCardBackLoading(slot))
+        {
+            yield return null;
+        }
+        SetCardBack(go, slot);
+    }
+
+    private void SetCardBack(GameObject go, CardBackSlot slot)
+    {
+        CardBack cardBackBySlot = GetCardBackBySlot(slot);
+        if (cardBackBySlot == null)
+        {
+            UnityEngine.Debug.LogWarningFormat("CardBackManager SetCardBack(): cardback not loaded for Slot: {0}", slot);
+            cardBackBySlot = GetCardBackBySlot(CardBackSlot.DEFAULT);
+            if (cardBackBySlot == null)
+            {
+                UnityEngine.Debug.LogWarning("CardBackManager SetCardBack(): default cardback not loaded");
+                return;
+            }
+        }
+        SetCardBack(go, cardBackBySlot);
+    }
+
+    public static void SetCardBack(GameObject go, CardBack cardBack)
+    {
+        SetCardBack(go, cardBack, unlit: false, shadowActive: false);
+    }
+
+    public static void SetCardBack(GameObject go, CardBack cardBack, bool unlit, bool shadowActive)
+    {
+        if (cardBack == null)
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager SetCardBack() cardback=null");
+            return;
+        }
+        if (go == null)
+        {
+            StackTrace stackTrace = new StackTrace();
+            UnityEngine.Debug.LogWarningFormat("CardBackManager SetCardBack() go=null, cardBack.name={0}, stacktrace=\n{1}", cardBack.name, stackTrace.ToString());
+            return;
+        }
+        Mesh cardBackMesh = cardBack.m_CardBackMesh;
+        if (cardBackMesh != null)
+        {
+            MeshFilter component = go.GetComponent<MeshFilter>();
+            if (component != null)
+            {
+                component.mesh = cardBackMesh;
+            }
+        }
+        else
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager SetCardBack() mesh=null");
+        }
+        float value = 0f;
+        if (!unlit && SceneMgr.Get() != null && SceneMgr.Get().GetMode() == SceneMgr.Mode.GAMEPLAY)
+        {
+            value = 1f;
+        }
+        Material cardBackMaterial = cardBack.m_CardBackMaterial;
+        Material cardBackMaterial2 = cardBack.m_CardBackMaterial1;
+        Material[] array = new Material[(!(cardBackMaterial2 != null)) ? 1 : 2];
+        array[0] = cardBackMaterial;
+        if (cardBackMaterial2 != null)
+        {
+            array[1] = cardBackMaterial2;
+        }
+        if (array.Length != 0 && array[0] != null)
+        {
+            Renderer component2 = go.GetComponent<Renderer>();
+            component2.SetSharedMaterials(array);
+            List<Material> materials = component2.GetMaterials();
+            float value2 = UnityEngine.Random.Range(0f, 1f);
+            foreach (Material item in materials)
+            {
+                if (!(item == null))
+                {
+                    if (item.HasProperty("_Seed") && item.GetFloat("_Seed") == 0f)
+                    {
+                        item.SetFloat("_Seed", value2);
+                    }
+                    if (item.HasProperty("_LightingBlend"))
+                    {
+                        item.SetFloat("_LightingBlend", value);
+                    }
+                }
+            }
+        }
+        else
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager SetCardBack() material=null");
+        }
+        if (cardBack.cardBackHelper == CardBack.cardBackHelpers.None)
+        {
+            RemoveCardBackHelper<CardBackHelperBubbleLevel>(go);
+        }
+        else if (cardBack.cardBackHelper == CardBack.cardBackHelpers.CardBackHelperBubbleLevel)
+        {
+            AddCardBackHelper<CardBackHelperBubbleLevel>(go);
+        }
+        Actor actor = GameObjectUtils.FindComponentInThisOrParents<Actor>(go);
+        if (actor != null)
+        {
+            actor.UpdateMissingCardArt();
+            actor.EnableCardbackShadow(shadowActive);
+            HighlightState componentInChildren = actor.GetComponentInChildren<HighlightState>();
+            if ((bool)componentInChildren)
+            {
+                componentInChildren.m_StaticSilouetteOverride = cardBack.m_CardBackHighlightTexture;
+            }
+        }
+    }
+
+    private bool ShouldIncludeCardBack(CardBackData cardBackData, bool requireOwned)
+    {
+        if (!cardBackData.Enabled)
+        {
+            return false;
+        }
+        return ShouldIncludeCardBack(cardBackData.ID, cardBackData.Name, requireOwned);
+    }
+
+    private bool ShouldIncludeCardBack(OwnedCardBack ownedCardBack, bool requireOwned)
+    {
+        return ShouldIncludeCardBack(ownedCardBack.m_cardBackId, ownedCardBack.m_name, requireOwned);
+    }
+
+    private bool ShouldIncludeCardBack(int cardBackId, string cardBackName, bool requireOwned)
+    {
+        if (requireOwned && !IsCardBackOwned(cardBackId))
+        {
+            return false;
+        }
+        if (!string.IsNullOrEmpty(m_searchText))
+        {
+            string text = GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_FAVORITE");
+            string text2 = GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_MISSING");
+            string text3 = GameStrings.Get("GLUE_COLLECTION_MANAGER_SEARCH_EXTRA");
+            string[] source = new string[3] { text, text2, text3 };
+            string[] array = m_searchText.ToLower().Split(CollectibleFilteredSet<ICollectible>.SearchTokenDelimiters, StringSplitOptions.RemoveEmptyEntries);
+            if (array.Contains(text3))
+            {
+                return false;
+            }
+            if (MultipleFavoriteCardBacksEnabled() && array.Contains(text))
+            {
+                bool flag = GetCardBacks().FavoriteCardBacks.Count == 0;
+                if (!IsCardBackFavorited(cardBackId) && (!flag || cardBackId != 0))
+                {
+                    return false;
+                }
+            }
+            if (array.Contains(text2) && IsCardBackOwned(cardBackId))
+            {
+                return false;
+            }
+            foreach (string value in array)
+            {
+                if (!source.Contains(value) && !cardBackName.ToLower().Contains(value))
+                {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    public static T AddCardBackHelper<T>(GameObject go) where T : MonoBehaviour
+    {
+        RemoveCardBackHelper<T>(go);
+        return go.AddComponent<T>();
+    }
+
+    public static bool RemoveCardBackHelper<T>(GameObject go) where T : MonoBehaviour
+    {
+        T[] components = go.GetComponents<T>();
+        if (components != null)
+        {
+            T[] array = components;
+            for (int i = 0; i < array.Length; i++)
+            {
+                UnityEngine.Object.Destroy(array[i]);
+            }
+            return true;
+        }
+        return false;
+    }
+
+    private IEnumerator SetDragEffectsWhenLoaded(GameObject go, CardBackSlot slot)
+    {
+        while (IsCardBackLoading(slot))
+        {
+            yield return null;
+        }
+        SetDragEffects(go, slot);
+    }
+
+    private void SetDragEffects(GameObject go, CardBackSlot slot)
+    {
+        if (go == null)
+        {
+            return;
+        }
+        CardBackDragEffect componentInChildren = go.GetComponentInChildren<CardBackDragEffect>();
+        if (componentInChildren == null)
+        {
+            return;
+        }
+        CardBack cardBackBySlot = GetCardBackBySlot(slot);
+        if (!(cardBackBySlot == null))
+        {
+            if (componentInChildren.m_EffectsRoot != null)
+            {
+                UnityEngine.Object.Destroy(componentInChildren.m_EffectsRoot);
+            }
+            if (!(cardBackBySlot.m_DragEffect == null))
+            {
+                GameObject gameObject = (componentInChildren.m_EffectsRoot = UnityEngine.Object.Instantiate(cardBackBySlot.m_DragEffect));
+                gameObject.transform.parent = componentInChildren.gameObject.transform;
+                gameObject.transform.localPosition = Vector3.zero;
+                gameObject.transform.localRotation = Quaternion.identity;
+                gameObject.transform.localScale = Vector3.one;
+            }
+        }
+    }
+
+    private IEnumerator SetDeckCardBackWhenLoaded(GameObject cardBackDeckDisplay, CardBackSlot slot)
+    {
+        while (IsCardBackLoading(slot))
+        {
+            yield return null;
+        }
+        SetDeckCardBack(cardBackDeckDisplay, slot);
+    }
+
+    private void SetDeckCardBack(GameObject cardBackDeckDisplay, CardBackSlot slot)
+    {
+        if (cardBackDeckDisplay == null)
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager SetDeckCardBack(): cardBackDeckDisplay GameObject is null! GameObject could have been destroyed while card back was loading.");
+            return;
+        }
+        CardBack cardBackBySlot = GetCardBackBySlot(slot);
+        if (cardBackBySlot == null)
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager SetDeckCardBack(): cardBack is null!");
+            return;
+        }
+        ZoneDeck componentInParent = cardBackDeckDisplay.GetComponentInParent<ZoneDeck>();
+        if (componentInParent != null)
+        {
+            if (cardBackBySlot.GetCustomDeckMeshes(out var meshes))
+            {
+                componentInParent.UpdateToCustomDeckMeshes(meshes);
+            }
+            else
+            {
+                componentInParent.TryRestoreOriginalDeckMeshes();
+            }
+        }
+        Texture cardBackTexture = cardBackBySlot.m_CardBackTexture;
+        if (cardBackTexture == null)
+        {
+            UnityEngine.Debug.LogWarning("CardBackManager SetDeckCardBack(): texture is null!");
+            return;
+        }
+        Renderer[] componentsInChildren = cardBackDeckDisplay.GetComponentsInChildren<Renderer>();
+        for (int i = 0; i < componentsInChildren.Length; i++)
+        {
+            componentsInChildren[i].GetMaterial().mainTexture = cardBackTexture;
+        }
+    }
+
+    private void OnCheatOptionChanged(Option option, object prevValue, bool existed, object userData)
+    {
+        Log.CardbackMgr.Print("Cheat Option Change Called");
+        int @int = Options.Get().GetInt(option, 0);
+        if (m_cardBackData.ContainsKey(@int))
+        {
+            CardBackSlot slot = CardBackSlot.FRIENDLY;
+            if (option == Option.CARD_BACK2)
+            {
+                slot = CardBackSlot.OPPONENT;
+            }
+            LoadCardBackPrefabIntoSlot(m_cardBackData[@int].PrefabName, slot);
+            UpdateAllCardBacksInSceneWhenReady();
+        }
+    }
+
+    private void NetCache_OnNetCacheCardBacksUpdated()
+    {
+        Processor.RunCoroutine(HandleNetCacheCardBacksWhenReady());
+    }
+
+    private IEnumerator HandleNetCacheCardBacksWhenReady()
+    {
+        while (m_cardBackData == null || FixedRewardsMgr.Get() == null || !FixedRewardsMgr.Get().IsStartupFinished())
+        {
+            yield return null;
+        }
+        NetCache.NetCacheCardBacks cardBacks = GetCardBacks();
+        AddNewCardBack(0);
+        bool flag = false;
+        foreach (int favoriteCardBack in cardBacks.FavoriteCardBacks)
+        {
+            if (m_cardBackData.ContainsKey(favoriteCardBack))
+            {
+                flag = true;
+                break;
+            }
+        }
+        if (!flag)
+        {
+            Log.CardbackMgr.Print("No valid favorite card backs found, set to CardBackDbId.CLASSIC");
+            cardBacks.FavoriteCardBacks = new HashSet<int> { 0 };
+        }
+        LoadRandomCardBackIntoFavoriteSlot(updateScene: false);
+    }
+
+    private IEnumerator UpdateAllCardBacksInSceneWhenReadyImpl()
+    {
+        while (IsCardBackLoading(CardBackSlot.FRIENDLY) || IsCardBackLoading(CardBackSlot.OPPONENT) || IsCardBackLoading(CardBackSlot.FAVORITE))
+        {
+            yield return null;
+        }
+        lock (cardbackListenerCollectionLock)
+        {
+            foreach (UpdateCardbacksListener updateCardbacksListener in m_updateCardbacksListeners)
+            {
+                updateCardbacksListener.Fire();
+            }
+        }
+    }
+
+    private void LoadCardBackPrefabIntoSlot(AssetReference assetRef, CardBackSlot slot)
+    {
+        string text = assetRef.ToString();
+        if (!m_LoadedCardBacksBySlot.TryGetValue(slot, out var value))
+        {
+            value = new CardBackSlotData();
+            m_LoadedCardBacksBySlot[slot] = value;
+        }
+        if (m_LoadedCardBacks.ContainsKey(text))
+        {
+            if (!(m_LoadedCardBacks[text] == null))
+            {
+                value.m_isLoading = false;
+                value.m_cardBackAssetString = text;
+                value.m_cardBack = m_LoadedCardBacks[text];
+                return;
+            }
+            m_LoadedCardBacks.Remove(text);
+        }
+        if (!(value.m_cardBackAssetString == text))
+        {
+            value.m_isLoading = true;
+            value.m_cardBackAssetString = text;
+            value.m_cardBack = null;
+            LoadCardBackData loadCardBackData = new LoadCardBackData();
+            loadCardBackData.m_Slot = slot;
+            loadCardBackData.m_Path = text;
+            AssetLoader.Get().InstantiatePrefab(text, OnCardBackLoaded, loadCardBackData);
+        }
+    }
+
+    private void OnCardBackLoaded(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        LoadCardBackData loadCardBackData = callbackData as LoadCardBackData;
+        if (go == null)
+        {
+            UnityEngine.Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): Failed to load CardBack: {0} For: {1}", assetRef, loadCardBackData.m_Slot);
+            m_LoadedCardBacksBySlot.Remove(loadCardBackData.m_Slot);
+            return;
+        }
+        go.transform.parent = SceneObject.transform;
+        go.transform.position = new Vector3(1000f, -1000f, -1000f);
+        CardBack component = go.GetComponent<CardBack>();
+        if (component == null)
+        {
+            UnityEngine.Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): Failed to find CardBack component: {0} slot: {1}", loadCardBackData.m_Path, loadCardBackData.m_Slot);
+            return;
+        }
+        if (component.m_CardBackMesh == null)
+        {
+            UnityEngine.Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): cardBack.m_CardBackMesh in null! - {0}", loadCardBackData.m_Path);
+            return;
+        }
+        if (component.m_CardBackMaterial == null)
+        {
+            UnityEngine.Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): cardBack.m_CardBackMaterial in null! - {0}", loadCardBackData.m_Path);
+            return;
+        }
+        if (component.m_CardBackTexture == null)
+        {
+            UnityEngine.Debug.LogWarningFormat("CardBackManager OnCardBackLoaded(): cardBack.m_CardBackTexture in null! - {0}", loadCardBackData.m_Path);
+            return;
+        }
+        m_LoadedCardBacks[loadCardBackData.m_Path] = component;
+        if (m_LoadedCardBacksBySlot.TryGetValue(loadCardBackData.m_Slot, out var value))
+        {
+            value.m_isLoading = false;
+            value.m_cardBack = component;
+        }
+    }
+
+    private void OnHiddenActorLoaded(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        LoadCardBackData obj = (LoadCardBackData)callbackData;
+        int cardBackIndex = obj.m_CardBackIndex;
+        string prefabName = m_cardBackData[cardBackIndex].PrefabName;
+        obj.m_GameObject = go;
+        AssetLoader.Get().InstantiatePrefab(prefabName, OnHiddenActorCardBackLoaded, callbackData);
+    }
+
+    private void OnHiddenActorCardBackLoaded(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (go == null)
+        {
+            Error.AddDevWarning("Error", "CardBackManager OnHiddenActorCardBackLoaded() path={0}, gameobject=null", assetRef);
+            return;
+        }
+        CardBack componentInChildren = go.GetComponentInChildren<CardBack>();
+        if (componentInChildren == null)
+        {
+            UnityEngine.Debug.LogWarningFormat("CardBackManager OnHiddenActorCardBackLoaded() path={0}, gameobject={1}, cardback=null", assetRef, go.name);
+        }
+        else
+        {
+            LoadCardBackData loadCardBackData = (LoadCardBackData)callbackData;
+            loadCardBackData.m_CardBack = componentInChildren;
+            Processor.RunCoroutine(HiddenActorCardBackLoadedSetup(loadCardBackData));
+        }
+    }
+
+    private IEnumerator HiddenActorCardBackLoadedSetup(LoadCardBackData data)
+    {
+        yield return null;
+        yield return null;
+        if (data != null && !(data.m_GameObject == null))
+        {
+            SetCardBack(data.m_GameObject.GetComponent<Actor>().m_cardMesh, data.m_CardBack, data.m_Unlit, data.m_ShadowActive);
+            data.m_CardBack.gameObject.transform.parent = data.m_GameObject.transform;
+            data.m_Callback(data);
+        }
+    }
+
+    private int GetValidCardBackID(int cardBackID)
+    {
+        if (!m_cardBackData.ContainsKey(cardBackID))
+        {
+            Log.CardbackMgr.Print("Cardback ID {0} not found, defaulting to Classic", cardBackID);
+            return 0;
+        }
+        return cardBackID;
+    }
+
+    public void OnFavoriteCardBackChanged(int newFavoriteCardBackID, bool isFavorite)
+    {
+        LoadRandomCardBackIntoFavoriteSlot(updateScene: false);
+        this.OnFavoriteCardBacksChanged?.Invoke(newFavoriteCardBackID, isFavorite);
+    }
+
+    private void OnSceneLoaded(SceneMgr.Mode mode, PegasusScene scene, object userData)
+    {
+        if (GetCardBackBySlot(CardBackSlot.FRIENDLY) == null)
+        {
+            LoadCardBackIdIntoSlot(0, CardBackSlot.FRIENDLY);
+        }
+    }
+
+    private void LoadCardBackIdIntoSlot(int cardBackId, CardBackSlot slot)
+    {
+        int validCardBackID = GetValidCardBackID(cardBackId);
+        if (m_cardBackData.TryGetValue(validCardBackID, out var value))
+        {
+            LoadCardBackPrefabIntoSlot(value.PrefabName, slot);
+        }
+    }
 }
diff --git a/Assembly-CSharp/CardListPanel.cs b/Assembly-CSharp/CardListPanel.cs
index 9fc04ef..c6638f0 100644
--- a/Assembly-CSharp/CardListPanel.cs
+++ b/Assembly-CSharp/CardListPanel.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CardListPanel : MonoBehaviour
@@ -18,11 +19,11 @@ public class CardListPanel : MonoBehaviour
 
 	private UIBButton m_rightArrow;
 
-	private const int MAX_CARDS_PER_PAGE = 3;
+	internal const int MAX_CARDS_PER_PAGE = 3;
 
 	private int m_numPages = 1;
 
-	private int m_pageNum;
+	internal int m_pageNum;
 
 	private List<int> m_cards = new List<int>();
 
@@ -61,7 +62,7 @@ public class CardListPanel : MonoBehaviour
 			m_changes = changes;
 		}
 		SetupPagingArrows();
-		m_numPages = (m_cards.Count + 3 - 1) / 3;
+		m_numPages = (m_cards.Count + MAX_CARDS_PER_PAGE - 1) / MAX_CARDS_PER_PAGE;
 		ShowPage(0);
 	}
 
@@ -72,10 +73,10 @@ public class CardListPanel : MonoBehaviour
 			Log.All.PrintWarning("CardListPanel.ShowPage: attempting to show invalid pageNum=" + pageNum + " numPages=" + m_numPages);
 			return;
 		}
-		m_pageNum = pageNum;
-		StopCoroutine("TransitionPage");
-		StartCoroutine("TransitionPage");
-	}
+			m_pageNum = pageNum;
+			StopCoroutine("TransitionPage");
+			StartCoroutine("TransitionPage");
+		}
 
 	private IEnumerator TransitionPage()
 	{
@@ -94,35 +95,35 @@ public class CardListPanel : MonoBehaviour
 		}
 		m_cardActors.Clear();
 		list.Clear();
-		int num = m_pageNum * 3;
-		int num2 = Mathf.Min(3, m_cards.Count - num);
+		int num = m_pageNum * MAX_CARDS_PER_PAGE;
+		int num2 = Mathf.Min(MAX_CARDS_PER_PAGE, m_cards.Count - num);
 		for (int i = 0; i < num2; i++)
 		{
 			int num3 = m_cards[num + i];
 			using DefLoader.DisposableFullDef disposableFullDef = DefLoader.Get().GetFullDef(GameUtils.TranslateDbIdToCardId(num3));
-			Actor component = AssetLoader.Get().InstantiatePrefab(ActorNames.GetHandActor(disposableFullDef.EntityDef, TAG_PREMIUM.NORMAL), AssetLoadingOptions.IgnorePrefabPosition).GetComponent<Actor>();
-			component.SetCardDef(disposableFullDef.DisposableCardDef);
-			component.SetEntityDef(disposableFullDef.EntityDef);
-			GameUtils.SetParent(component, base.gameObject);
-			LayerUtils.SetLayer(component, base.gameObject.layer);
-			List<CardChangeDbfRecord> glowsForCard = m_changes[num3];
-			GameObject gameObject = AssetLoader.Get().InstantiatePrefab(ActorNames.GetNerfGlowsActor(disposableFullDef.EntityDef.GetCardType()));
-			if (gameObject != null)
-			{
-				CardNerfGlows component2 = gameObject.GetComponent<CardNerfGlows>();
-				if (component2 != null)
+				Actor component = AssetLoader.Get().InstantiatePrefab(ActorNames.GetHandActor(disposableFullDef.EntityDef, TAG_PREMIUM.NORMAL), AssetLoadingOptions.IgnorePrefabPosition).GetComponent<Actor>();
+				component.SetCardDef(disposableFullDef.DisposableCardDef);
+				component.SetEntityDef(disposableFullDef.EntityDef);
+				GameUtils.SetParent(component, base.gameObject);
+				LayerUtils.SetLayer(component, base.gameObject.layer);
+				List<CardChangeDbfRecord> glowsForCard = m_changes[num3];
+				GameObject gameObject = AssetLoader.Get().InstantiatePrefab(ActorNames.GetNerfGlowsActor(disposableFullDef.EntityDef.GetCardType()));
+				if (gameObject != null)
 				{
-					TransformUtil.AttachAndPreserveLocalTransform(gameObject.transform, component.transform);
-					LayerUtils.SetLayer(component2, component.gameObject.layer);
-					component2.SetGlowsForCard(glowsForCard);
-				}
-				else
-				{
-					Debug.LogError("CardListPanel.cs: Nerf Glows GameObject " + gameObject?.ToString() + " does not have a CardNerfGlows script attached.");
+					CardNerfGlows component2 = gameObject.GetComponent<CardNerfGlows>();
+					if (component2 != null)
+					{
+						TransformUtil.AttachAndPreserveLocalTransform(gameObject.transform, component.transform);
+						LayerUtils.SetLayer(component2, component.gameObject.layer);
+						component2.SetGlowsForCard(glowsForCard);
+					}
+					else
+					{
+						Debug.LogError("CardListPanel.cs: Nerf Glows GameObject " + gameObject?.ToString() + " does not have a CardNerfGlows script attached.");
+					}
 				}
+				m_cardActors.Add(component);
 			}
-			m_cardActors.Add(component);
-		}
 		UpdateCardPositions();
 		foreach (Actor cardActor2 in m_cardActors)
 		{
@@ -141,7 +142,7 @@ public class CardListPanel : MonoBehaviour
 		}
 	}
 
-	private void UpdateCardPositions()
+    private void UpdateCardPositions()
 	{
 		int count = m_cardActors.Count;
 		for (int i = 0; i < count; i++)
@@ -156,7 +157,7 @@ public class CardListPanel : MonoBehaviour
 
 	private void SetupPagingArrows()
 	{
-		if (m_cards.Count > 3)
+		if (m_cards.Count > MAX_CARDS_PER_PAGE)
 		{
 			m_leftArrowNested.gameObject.SetActive(value: true);
 			m_rightArrowNested.gameObject.SetActive(value: true);
@@ -187,7 +188,7 @@ public class CardListPanel : MonoBehaviour
 		}
 	}
 
-	private void TurnPage(bool right)
+	internal void TurnPage(bool right)
 	{
 		HighlightState componentInChildren = m_rightArrow.GetComponentInChildren<HighlightState>();
 		if ((bool)componentInChildren)
diff --git a/Assembly-CSharp/CardListPopup.cs b/Assembly-CSharp/CardListPopup.cs
index 3166411..dcfa012 100644
--- a/Assembly-CSharp/CardListPopup.cs
+++ b/Assembly-CSharp/CardListPopup.cs
@@ -1,4 +1,7 @@
+using System;
 using System.Collections.Generic;
+using Accessibility;
+using UnityEngine;
 
 [CustomEditClass]
 public class CardListPopup : DialogBase
@@ -33,7 +36,12 @@ public class CardListPopup : DialogBase
 
 	private Info m_info = new Info();
 
-	protected override void Awake()
+    #region Accessibility
+    private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleCards;
+	private CardListPanel m_curCardsContainer;
+    #endregion
+
+    protected override void Awake()
 	{
 		base.Awake();
 		m_okayButton.AddEventListener(UIEventType.RELEASE, delegate
@@ -68,18 +76,83 @@ public class CardListPopup : DialogBase
 		{
 			m_CardsContainer_MultiLineDescription.Show(m_info.m_cards, m_info.m_changes);
 			m_descriptionMultiLine.Text = m_info.m_description;
+			m_curCardsContainer = m_CardsContainer_MultiLineDescription;
 		}
 		else
 		{
 			m_CardsContainer_SingleLineDescription.Show(m_info.m_cards, m_info.m_changes);
 			m_descriptionSingleLine.Text = m_info.m_description;
+			m_curCardsContainer = m_CardsContainer_SingleLineDescription;
 		}
 		UniversalInputManager.Get().SetSystemDialogActive(active: true);
-	}
 
-	public override void Hide()
+		ReadPopup();
+    }
+
+    public override void Hide()
 	{
 		base.Hide();
 		DialogBase.EndBlur();
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+        var accessibleCards = new List<AccessibleCollectibleCard>();
+        foreach (var cardDbId in m_info.m_cards)
+        {
+			var cardId = GameUtils.TranslateDbIdToCardId(cardDbId);
+			CollectibleCard card = CollectionManager.Get().GetCard(cardId, TAG_PREMIUM.NORMAL);
+            accessibleCards.Add(new AccessibleCollectibleCard(this, card, false, true));
+        }
+
+        m_accessibleCards = new AccessibleListOfItems<AccessibleCollectibleCard>(this, accessibleCards);
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, m_info.m_description);
+		m_accessibleCards.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+            m_okayButton.TriggerRelease();
+        }
+        else
+        {
+			if (m_accessibleCards.HandleAccessibleInput())
+			{
+				ChangePageIfNeeded();
+			}
+        }
+    }
+
+    private void ChangePageIfNeeded()
+    {
+		int curCardIndex = m_accessibleCards.GetItemBeingReadIndex();
+		int cardsPerPage = CardListPanel.MAX_CARDS_PER_PAGE;
+		int curPage = m_curCardsContainer.m_pageNum;
+
+		int realPage = curCardIndex / cardsPerPage;
+
+		if (curPage < realPage)
+        {
+            m_curCardsContainer.TurnPage(true);
+        }
+		else if (curPage > realPage)
+        {
+			m_curCardsContainer.TurnPage(false);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		var helpText = LocalizationUtils.Get(LocalizationKey.UI_CARD_LIST_POPUP_HELP);
+		return AccessibleSpeechUtils.CombineSentences(helpText, AccessibleSpeech.PRESS_CONFIRM_ONCE_DONE);
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/CardPopups.cs b/Assembly-CSharp/CardPopups.cs
index ccb684c..1e58038 100644
--- a/Assembly-CSharp/CardPopups.cs
+++ b/Assembly-CSharp/CardPopups.cs
@@ -30,7 +30,7 @@ public class CardPopups : IDisposable
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowChangedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowChangedCards"))
 		{
 			return false;
 		}
@@ -50,11 +50,11 @@ public class CardPopups : IDisposable
 
 	public bool ShowFeaturedCards(EventTimingType featuredCardsEvent, string headerText, DialogBase.HideCallback callbackOnHide = null, UserAttentionBlocker ignoredAttentionBlockers = UserAttentionBlocker.NONE)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(ignoredAttentionBlockers, "ShowFeaturedCards"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, ignoredAttentionBlockers, "ShowFeaturedCards"))
 		{
 			return false;
 		}
-		MultiPagePopup.Info info = new MultiPagePopup.Info
+		MultiPagePopup.Info info = new MultiPagePopup.Info(true)
 		{
 			m_callbackOnHide = callbackOnHide,
 			m_blurWhenShown = true
@@ -62,7 +62,7 @@ public class CardPopups : IDisposable
 		List<int> cards = (from r in GameDbf.GetIndex().GetCardsWithFeaturedCardsEvent()
 			where r.FeaturedCardsEvent == featuredCardsEvent
 			select r.ID).ToList();
-		MultiPagePopup.PageInfo item = new MultiPagePopup.PageInfo
+		MultiPagePopup.PageInfo item = new MultiPagePopup.PageInfo(true)
 		{
 			m_pageType = MultiPagePopup.PageType.CARD_LIST,
 			m_cards = cards,
diff --git a/Assembly-CSharp/CastSpellCardFromHandSepll.cs b/Assembly-CSharp/CastSpellCardFromHandSepll.cs
index c483a4d..851f193 100644
--- a/Assembly-CSharp/CastSpellCardFromHandSepll.cs
+++ b/Assembly-CSharp/CastSpellCardFromHandSepll.cs
@@ -70,7 +70,7 @@ public class CastSpellCardFromHandSepll : Spell
 		targetCard.HideCard();
 		Entity entity = targetCard.GetEntity();
 		UpdateTags(entity);
-		HistoryManager.Get().CreatePlayedBigCard(entity, delegate
+		HistoryManager.Get().CreatePlayedBigCard(m_taskList, entity, delegate
 		{
 		}, delegate
 		{
@@ -94,12 +94,12 @@ public class CastSpellCardFromHandSepll : Spell
 			}
 			entity.LoadCard(entity2.CardID);
 			{
-				foreach (Network.Entity.Tag tag in entity2.Tags)
-				{
-					entity.SetTag(tag.Name, tag.Value);
-				}
-				return;
+			foreach (Network.Entity.Tag tag in entity2.Tags)
+			{
+				entity.SetTag(tag.Name, tag.Value);
 			}
+			return;
+		}
 		}
 		foreach (PowerTask task2 in m_taskList.GetTaskList())
 		{
@@ -128,7 +128,7 @@ public class CastSpellCardFromHandSepll : Spell
 		iTween.RotateTo(targetCard.gameObject, transform.rotation.eulerAngles, m_BigCardDisplayTime);
 		iTween.ScaleTo(targetCard.gameObject, new Vector3(1f, 1f, 1f), m_BigCardDisplayTime);
 		SoundManager.Get().LoadAndPlay("play_card_from_hand_1.prefab:ac4be75e319a97947a68308a08e54e88");
-		yield return new WaitForSeconds(m_BigCardDisplayTime);
+        yield return new WaitForSeconds(m_BigCardDisplayTime);
 	}
 
 	private IEnumerator PlayPowerUpSpell()
diff --git a/Assembly-CSharp/ChatBubbleFrame.cs b/Assembly-CSharp/ChatBubbleFrame.cs
index 5149e88..a936b66 100644
--- a/Assembly-CSharp/ChatBubbleFrame.cs
+++ b/Assembly-CSharp/ChatBubbleFrame.cs
@@ -1,5 +1,6 @@
 using Blizzard.GameService.SDK.Client.Integration;
 using UnityEngine;
+using Accessibility;
 
 public class ChatBubbleFrame : MonoBehaviour
 {
@@ -72,7 +73,8 @@ public class ChatBubbleFrame : MonoBehaviour
 			m_MyDecoration.SetActive(value: true);
 			m_TheirDecoration.SetActive(value: false);
 			BnetPlayer receiver = WhisperUtil.GetReceiver(m_whisper);
-			m_NameText.Text = GameStrings.Format("GLOBAL_CHAT_BUBBLE_RECEIVER_NAME", receiver.GetBestName());
+			m_receiverName = receiver.GetBestName();
+			m_NameText.Text = GameStrings.Format("GLOBAL_CHAT_BUBBLE_RECEIVER_NAME", m_receiverName);
 		}
 		else
 		{
@@ -87,17 +89,40 @@ public class ChatBubbleFrame : MonoBehaviour
 			{
 				m_NameText.TextColor = GameColors.PLAYER_NAME_OFFLINE;
 			}
-			m_NameText.Text = speaker.GetBestName();
+			m_speakerName = speaker.GetBestName();
+			m_NameText.Text = m_speakerName;
 		}
 		string message = ChatUtils.GetMessage(m_whisper);
 		if (ChatUtils.TryGetFormattedDeckcodeMessage(message, showHint: false, out var formattedDeckcodeMessage))
 		{
-			m_MessageText.Text = formattedDeckcodeMessage;
+			m_messageText = formattedDeckcodeMessage;
+			m_MessageText.Text = m_messageText;
 		}
 		else
 		{
-			m_MessageText.Text = message;
+			m_messageText = message;
+			m_MessageText.Text = m_messageText;
 		}
 		m_MessageText.Text += " ";
 	}
+
+	#region Accessibility
+
+	private string m_receiverName = "";
+	private string m_speakerName = "";
+	private string m_messageText = "";
+
+	internal void ReadMessage()
+	{
+		if (m_receiverName.Length > 0)
+		{
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_SOCIAL_CHAT_MESSAGE_SENT, m_receiverName, m_messageText));
+		}
+		else if (m_speakerName.Length > 0)
+		{
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_SOCIAL_CHAT_MESSAGE_RECEIVED, m_speakerName, m_messageText));
+		}
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/ChatMgr.cs b/Assembly-CSharp/ChatMgr.cs
index 0557776..b89db1c 100644
--- a/Assembly-CSharp/ChatMgr.cs
+++ b/Assembly-CSharp/ChatMgr.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using Blizzard.GameService.SDK.Client.Integration;
 using Blizzard.T5.Core;
 using Blizzard.T5.Services;
@@ -61,7 +62,7 @@ public class ChatMgr : MonoBehaviour
 
 	private bool m_chatLogFrameShown;
 
-	private bool m_isChatFeatureEnabled;
+	private bool m_isChatFeatureEnabled = true;
 
 	private PrivacyFeaturesPopup m_chatPrivacyPopup;
 
@@ -669,6 +670,15 @@ public class ChatMgr : MonoBehaviour
 
 	public void HandleGUIInput()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Chat is not implemented yet
+			return;
+        }
+
+		// Players were running into issues due to pressing Enter while using OCR so we'll disable this for now and rethink it later
+		return;
+
 		if (!m_fatalErrorMgr.HasError() && !IsMobilePlatform())
 		{
 			HandleGUIInputForQuickChat();
@@ -904,6 +914,7 @@ public class ChatMgr : MonoBehaviour
 		chatBubbleFrame.transform.parent = m_ChatBubbleInfo.m_Parent.transform;
 		chatBubbleFrame.transform.localScale = chatBubbleFrame.m_ScaleOverride;
 		SoundManager.Get().LoadAndPlay("receive_message.prefab:8e90a827cd4a0e849953158396cd1ee1");
+		chatBubbleFrame.ReadMessage();
 		Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
 		tweenHashTable.Add("scale", chatBubbleFrame.m_VisualRoot.transform.localScale);
 		tweenHashTable.Add("time", m_ChatBubbleInfo.m_ScaleInSec);
diff --git a/Assembly-CSharp/ChatUtils.cs b/Assembly-CSharp/ChatUtils.cs
index 3463a50..e169214 100644
--- a/Assembly-CSharp/ChatUtils.cs
+++ b/Assembly-CSharp/ChatUtils.cs
@@ -1,5 +1,6 @@
 using System;
 using Blizzard.GameService.SDK.Client.Integration;
+using Accessibility;
 
 public static class ChatUtils
 {
@@ -74,6 +75,7 @@ public static class ChatUtils
 			m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL,
 			m_responseCallback = delegate(AlertPopup.Response response, object userData)
 			{
+				AccessibilityMgr.AllowTextInput();
 				if (response == AlertPopup.Response.CONFIRM)
 				{
 					onConfirmationCallback(deckCodeMessage);
@@ -81,6 +83,7 @@ public static class ChatUtils
 				ClipboardUtils.CopyToClipboard(string.Empty);
 			}
 		};
+		AccessibilityMgr.DisallowTextInput();
 		DialogManager.Get().ShowPopup(info);
 	}
 }
diff --git a/Assembly-CSharp/CheatMgr.cs b/Assembly-CSharp/CheatMgr.cs
index d9ecf75..545c3b6 100644
--- a/Assembly-CSharp/CheatMgr.cs
+++ b/Assembly-CSharp/CheatMgr.cs
@@ -7,6 +7,7 @@ using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
 using Hearthstone;
 using UnityEngine;
+using Accessibility;
 
 public class CheatMgr : IService
 {
@@ -114,7 +115,7 @@ public class CheatMgr : IService
 		{
 			return false;
 		}
-		if (!InputCollection.GetKeyUp(KeyCode.BackQuote))
+		if (!InputCollection.GetKeyUp(KeyCode.Backslash))
 		{
 			return false;
 		}
@@ -145,9 +146,10 @@ public class CheatMgr : IService
 			m_showBackground = true
 		};
 		UniversalInputManager.Get().UseTextInput(parms);
-	}
+        AccessibilityMgr.AllowTextInput();
+    }
 
-	public void HideConsole()
+    public void HideConsole()
 	{
 		UniversalInputManager.Get().CancelTextInput(SceneObject);
 	}
@@ -539,6 +541,9 @@ public class CheatMgr : IService
 		{
 			return "\"" + text + "\" cheat command executed, but failed!";
 		}
+
+		AccessibilityUtils.LogDebug($"Processed cheat: {inputCommand}");
+
 		return null;
 	}
 
diff --git a/Assembly-CSharp/Cheats.cs b/Assembly-CSharp/Cheats.cs
index 5f56045..e971968 100644
--- a/Assembly-CSharp/Cheats.cs
+++ b/Assembly-CSharp/Cheats.cs
@@ -250,9 +250,9 @@ public class Cheats : IService
 
 	private static readonly Map<ScenarioDbId, GameType> s_scenarioToGameTypeMap = new Map<ScenarioDbId, GameType>
 	{
-		{
-			ScenarioDbId.TB_BACONSHOP_VS_AI,
-			GameType.GT_BATTLEGROUNDS_PLAYER_VS_AI
+	{
+		ScenarioDbId.TB_BACONSHOP_VS_AI,
+		GameType.GT_BATTLEGROUNDS_PLAYER_VS_AI
 		},
 		{
 			ScenarioDbId.TB_BACONSHOP_DUOS_VS_AI,
@@ -3933,7 +3933,7 @@ public class Cheats : IService
 
 	private bool OnProcessCheat_setRotationRotatedBoostersPopup(string func, string[] args, string rawArgs)
 	{
-		SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo info = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo();
+		SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo info = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo(null);
 		DialogManager.Get().ShowSetRotationTutorialPopup(UserAttentionBlocker.SET_ROTATION_INTRO, info);
 		return true;
 	}
@@ -4452,7 +4452,7 @@ public class Cheats : IService
 						}
 						continue;
 					}
-					IEnumerable<BnetPlayer> enumerable2 = source.Where((BnetPlayer p) => p.GetBattleTag().ToString().Contains(arg, StringComparison.OrdinalIgnoreCase) || (p.GetFullName() != null && p.GetFullName().Contains(arg, StringComparison.OrdinalIgnoreCase)));
+					IEnumerable<BnetPlayer> enumerable2 = source.Where((BnetPlayer p) => p.GetBattleTag().ToString().Contains(arg) || (p.GetFullName() != null && p.GetFullName().Contains(arg)));
 					if (!enumerable2.Any())
 					{
 						errorMsg = "party invite: no online Hearthstone friend matching name " + arg + " (arg index " + num3 + ")";
@@ -6727,148 +6727,148 @@ public class Cheats : IService
 				}
 				}
 				break;
-			case "ranked":
-				if (text3 == "medal" || text3 == "seasonroll")
-				{
-					flag = flag && (!debugCommandResponse.HasResponse || !debugCommandResponse.Response.StartsWith("Error"));
-					if (flag)
+				case "ranked":
+					if (text3 == "medal" || text3 == "seasonroll")
 					{
-						text = "Success";
-						delay = 0.5f;
+						flag = flag && (!debugCommandResponse.HasResponse || !debugCommandResponse.Response.StartsWith("Error"));
+						if (flag)
+						{
+							text = "Success";
+							delay = 0.5f;
+						}
+						else if (debugCommandResponse.HasResponse)
+						{
+							text = debugCommandResponse.Response;
+						}
 					}
-					else if (debugCommandResponse.HasResponse)
+					switch (text3)
 					{
-						text = debugCommandResponse.Response;
+					case "set":
+					case "win":
+					case "lose":
+					case "games":
+						NetCache.Get().RefreshNetObject<NetCache.NetCacheMedalInfo>();
+						break;
 					}
-				}
-				switch (text3)
-				{
-				case "set":
-				case "win":
-				case "lose":
-				case "games":
-					NetCache.Get().RefreshNetObject<NetCache.NetCacheMedalInfo>();
 					break;
-				}
-				break;
-			case "hero":
-				if (text3 == "addxp")
-				{
-					NetCache.Get().RefreshNetObject<NetCache.NetCacheHeroLevels>();
-				}
-				break;
-			case "banner":
-			{
-				if (!(text3 == "reset"))
-				{
+				case "hero":
+					if (text3 == "addxp")
+					{
+						NetCache.Get().RefreshNetObject<NetCache.NetCacheHeroLevels>();
+					}
 					break;
-				}
-				NetCache.Get().ReloadNetObject<NetCache.NetCacheProfileProgress>();
+				case "banner":
+				{
+					if (!(text3 == "reset"))
+					{
+						break;
+					}
+					NetCache.Get().ReloadNetObject<NetCache.NetCacheProfileProgress>();
 				bool flag3 = false;
 				int result2 = 0;
-				string[] array2 = array;
-				for (int i = 0; i < array2.Length; i++)
-				{
+					string[] array2 = array;
+					for (int i = 0; i < array2.Length; i++)
+					{
 					string[] array4 = array2[i]?.Split('=');
 					if (array4 != null && array4.Length >= 2 && (array4[0].Equals("banner", StringComparison.InvariantCultureIgnoreCase) || array4[0].Equals("bannerId", StringComparison.InvariantCultureIgnoreCase)))
-					{
+						{
 						flag3 = true;
 						int.TryParse(array4[1], out result2);
+						}
 					}
-				}
 				if (flag3)
-				{
-					BannerManager.Get().Cheat_ClearSeenBannersNewerThan(result2);
-				}
-				else
-				{
-					BannerManager.Get().Cheat_ClearSeenBanners();
-				}
-				break;
-			}
-			case "logrelay":
-				if (text3 == "*")
-				{
-					flag2 = false;
-				}
-				break;
-			case "prog":
-				switch (text3)
-				{
-				case "achieve":
-				case "quest":
-				case "task":
-				{
-					if (!(text4 == "listen"))
 					{
-						break;
+					BannerManager.Get().Cheat_ClearSeenBannersNewerThan(result2);
 					}
-					if (array.Length < 3)
+					else
 					{
-						return;
+						BannerManager.Get().Cheat_ClearSeenBanners();
 					}
-					string text5 = array[2].ToLower();
-					LuaLogs luaLogs = ServiceManager.Get<LuaLogs>();
-					if (luaLogs == null)
+					break;
+				}
+				case "logrelay":
+					if (text3 == "*")
 					{
-						return;
+						flag2 = false;
 					}
-					int playerId = (int)SceneDebugger.Get().GetPlayerId_DebugOnly().GetValueOrDefault();
-					if (text5 == "all")
+					break;
+				case "prog":
+					switch (text3)
 					{
-						luaLogs.ClearListenOnGameServer(playerId);
-						return;
-					}
-					int result = 0;
-					string[] array2 = array;
-					for (int i = 0; i < array2.Length; i++)
+					case "achieve":
+					case "quest":
+					case "task":
 					{
+						if (!(text4 == "listen"))
+						{
+							break;
+						}
+						if (array.Length < 3)
+						{
+							return;
+						}
+						string text5 = array[2].ToLower();
+						LuaLogs luaLogs = ServiceManager.Get<LuaLogs>();
+						if (luaLogs == null)
+						{
+							return;
+						}
+						int playerId = (int)SceneDebugger.Get().GetPlayerId_DebugOnly().GetValueOrDefault();
+						if (text5 == "all")
+						{
+							luaLogs.ClearListenOnGameServer(playerId);
+							return;
+						}
+					int result = 0;
+						string[] array2 = array;
+						for (int i = 0; i < array2.Length; i++)
+						{
 						string[] array3 = array2[i]?.Split('=');
 						if (array3 != null && array3.Length >= 2 && array3[0].Equals("id", StringComparison.InvariantCultureIgnoreCase))
-						{
+							{
 							int.TryParse(array3[1], out result);
+							}
 						}
-					}
-					try
-					{
-						LuaLogs.ListenableScriptType @enum = EnumUtils.GetEnum<LuaLogs.ListenableScriptType>(text3.ToUpper());
+						try
+						{
+							LuaLogs.ListenableScriptType @enum = EnumUtils.GetEnum<LuaLogs.ListenableScriptType>(text3.ToUpper());
 						luaLogs.ListenOnGameServer(playerId, result, @enum);
+						}
+						catch (ArgumentException arg)
+						{
+							Error.AddWarning("Prog listen Cheat Error", $"Type is not configured to be listenable {text3.ToUpper()}. Error Message: {arg}");
+						}
+						break;
 					}
-					catch (ArgumentException arg)
-					{
-						Error.AddWarning("Prog listen Cheat Error", $"Type is not configured to be listenable {text3.ToUpper()}. Error Message: {arg}");
 					}
 					break;
-				}
-				}
-				break;
-			case "bgemote":
-				NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsEmotes>();
-				break;
-			case "bgheroskin":
-			case "bgguideskin":
-			case "bgboardskin":
-			case "bgfinisher":
-				if (text3 != null && text3.Contains("seen"))
-				{
-					switch (text2)
+				case "bgemote":
+					NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsEmotes>();
+					break;
+				case "bgheroskin":
+				case "bgguideskin":
+				case "bgboardskin":
+				case "bgfinisher":
+					if (text3 != null && text3.Contains("seen"))
 					{
-					case "bgheroskin":
-						NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsHeroSkins>();
-						break;
-					case "bgguideskin":
-						NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsGuideSkins>();
-						break;
-					case "bgboardskin":
-						NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsBoardSkins>();
-						break;
-					case "bgfinisher":
-						NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsFinishers>();
-						break;
+						switch (text2)
+						{
+						case "bgheroskin":
+							NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsHeroSkins>();
+							break;
+						case "bgguideskin":
+							NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsGuideSkins>();
+							break;
+						case "bgboardskin":
+							NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsBoardSkins>();
+							break;
+						case "bgfinisher":
+							NetCache.Get().RefreshNetObject<NetCache.NetCacheBattlegroundsFinishers>();
+							break;
+						}
 					}
+					break;
 				}
-				break;
-			}
 			if ((text2 == "ranked" || text2 == "arena") && text3 == "reward")
 			{
 				flag = flag && (!debugCommandResponse.HasResponse || !debugCommandResponse.Response.StartsWith("Error"));
@@ -8037,11 +8037,11 @@ public class Cheats : IService
 			}
 		}
 		else if (string.Equals(a, "get") && args.Length > 1)
-		{
-			string text3 = args[1];
+			{
+				string text3 = args[1];
 			string @string = CloudStorageManager.GetString(text3);
-			UIStatus.Get().AddInfo("Cloud Storage Get: Value for " + text3 + " is " + ((@string == null) ? "NULL" : @string));
-		}
+				UIStatus.Get().AddInfo("Cloud Storage Get: Value for " + text3 + " is " + ((@string == null) ? "NULL" : @string));
+			}
 		return true;
 	}
 
@@ -8140,19 +8140,19 @@ public class Cheats : IService
 		else if (string.Equals(a, "data"))
 		{
 			if (args.Length > 1 && string.Equals(args[1].ToLower(), "clear"))
-			{
-				TemporaryAccountManager.Get().DeleteTemporaryAccountData();
-				UIStatus.Get().AddInfo("Temporary Account Data Deleted");
+				{
+					TemporaryAccountManager.Get().DeleteTemporaryAccountData();
+					UIStatus.Get().AddInfo("Temporary Account Data Deleted");
+				}
 			}
-		}
 		else if (string.Equals(a, "nag"))
 		{
 			if (args.Length > 1 && string.Equals(args[1].ToLower(), "clear"))
-			{
-				Options.Get().DeleteOption(Option.LAST_HEAL_UP_EVENT_DATE);
-				UIStatus.Get().AddInfo("Last Heal Up Event Time Cleared!");
+				{
+					Options.Get().DeleteOption(Option.LAST_HEAL_UP_EVENT_DATE);
+					UIStatus.Get().AddInfo("Last Heal Up Event Time Cleared!");
+				}
 			}
-		}
 		else if (string.Equals(a, "lazy"))
 		{
 			ServiceManager.Get<ILoginService>()?.ClearAuthentication();
@@ -8304,7 +8304,7 @@ public class Cheats : IService
 			{
 				text2 = text.Substring(6);
 			}
-			Func<string, string, bool> fnSubstringMatch = (string evtName, string userInput) => evtName.Contains(userInput, StringComparison.InvariantCultureIgnoreCase);
+			Func<string, string, bool> fnSubstringMatch = (string evtName, string userInput) => evtName.Contains(userInput);
 			Func<string, string, bool> fnStartsWithMatch = (string evtName, string userInput) => evtName.StartsWith(userInput, StringComparison.InvariantCultureIgnoreCase);
 			Func<string, string, bool> fnEndsWithMatch = (string evtName, string userInput) => evtName.EndsWith(userInput, StringComparison.InvariantCultureIgnoreCase);
 			Func<string, string, bool> fnExactMatch = (string evtName, string userInput) => evtName.Equals(userInput, StringComparison.InvariantCultureIgnoreCase);
@@ -9831,128 +9831,128 @@ public class Cheats : IService
 			ScenarioDbId[] array = ((adventureDbId == AdventureDbId.BOH) ? (wingIdFromMissionId switch
 			{
 				WingDbId.BOH_REXXAR => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOH_REXXAR_01,
-					ScenarioDbId.BOH_REXXAR_02,
-					ScenarioDbId.BOH_REXXAR_03,
-					ScenarioDbId.BOH_REXXAR_04,
-					ScenarioDbId.BOH_REXXAR_05,
-					ScenarioDbId.BOH_REXXAR_06,
-					ScenarioDbId.BOH_REXXAR_07,
-					ScenarioDbId.BOH_REXXAR_08
+					{
+						ScenarioDbId.BOH_REXXAR_01,
+						ScenarioDbId.BOH_REXXAR_02,
+						ScenarioDbId.BOH_REXXAR_03,
+						ScenarioDbId.BOH_REXXAR_04,
+						ScenarioDbId.BOH_REXXAR_05,
+						ScenarioDbId.BOH_REXXAR_06,
+						ScenarioDbId.BOH_REXXAR_07,
+						ScenarioDbId.BOH_REXXAR_08
 				}, 
 				WingDbId.BOH_GARROSH => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOH_GARROSH_01,
-					ScenarioDbId.BOH_GARROSH_02,
-					ScenarioDbId.BOH_GARROSH_03,
-					ScenarioDbId.BOH_GARROSH_04,
-					ScenarioDbId.BOH_GARROSH_05,
-					ScenarioDbId.BOH_GARROSH_06,
-					ScenarioDbId.BOH_GARROSH_07,
-					ScenarioDbId.BOH_GARROSH_08
+					{
+						ScenarioDbId.BOH_GARROSH_01,
+						ScenarioDbId.BOH_GARROSH_02,
+						ScenarioDbId.BOH_GARROSH_03,
+						ScenarioDbId.BOH_GARROSH_04,
+						ScenarioDbId.BOH_GARROSH_05,
+						ScenarioDbId.BOH_GARROSH_06,
+						ScenarioDbId.BOH_GARROSH_07,
+						ScenarioDbId.BOH_GARROSH_08
 				}, 
 				WingDbId.BOH_UTHER => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOH_UTHER_01,
-					ScenarioDbId.BOH_UTHER_02,
-					ScenarioDbId.BOH_UTHER_03,
-					ScenarioDbId.BOH_UTHER_04,
-					ScenarioDbId.BOH_UTHER_05,
-					ScenarioDbId.BOH_UTHER_06,
-					ScenarioDbId.BOH_UTHER_07,
-					ScenarioDbId.BOH_UTHER_08
+					{
+						ScenarioDbId.BOH_UTHER_01,
+						ScenarioDbId.BOH_UTHER_02,
+						ScenarioDbId.BOH_UTHER_03,
+						ScenarioDbId.BOH_UTHER_04,
+						ScenarioDbId.BOH_UTHER_05,
+						ScenarioDbId.BOH_UTHER_06,
+						ScenarioDbId.BOH_UTHER_07,
+						ScenarioDbId.BOH_UTHER_08
 				}, 
 				WingDbId.BOH_ANDUIN => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOH_ANDUIN_01,
-					ScenarioDbId.BOH_ANDUIN_02,
-					ScenarioDbId.BOH_ANDUIN_03,
-					ScenarioDbId.BOH_ANDUIN_04,
-					ScenarioDbId.BOH_ANDUIN_05,
-					ScenarioDbId.BOH_ANDUIN_06,
-					ScenarioDbId.BOH_ANDUIN_07,
-					ScenarioDbId.BOH_ANDUIN_08
+					{
+						ScenarioDbId.BOH_ANDUIN_01,
+						ScenarioDbId.BOH_ANDUIN_02,
+						ScenarioDbId.BOH_ANDUIN_03,
+						ScenarioDbId.BOH_ANDUIN_04,
+						ScenarioDbId.BOH_ANDUIN_05,
+						ScenarioDbId.BOH_ANDUIN_06,
+						ScenarioDbId.BOH_ANDUIN_07,
+						ScenarioDbId.BOH_ANDUIN_08
 				}, 
 				WingDbId.BOH_VALEERA => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOH_VALEERA_01,
-					ScenarioDbId.BOH_VALEERA_02,
-					ScenarioDbId.BOH_VALEERA_03,
-					ScenarioDbId.BOH_VALEERA_04,
-					ScenarioDbId.BOH_VALEERA_05,
-					ScenarioDbId.BOH_VALEERA_06,
-					ScenarioDbId.BOH_VALEERA_07,
-					ScenarioDbId.BOH_VALEERA_08
+					{
+						ScenarioDbId.BOH_VALEERA_01,
+						ScenarioDbId.BOH_VALEERA_02,
+						ScenarioDbId.BOH_VALEERA_03,
+						ScenarioDbId.BOH_VALEERA_04,
+						ScenarioDbId.BOH_VALEERA_05,
+						ScenarioDbId.BOH_VALEERA_06,
+						ScenarioDbId.BOH_VALEERA_07,
+						ScenarioDbId.BOH_VALEERA_08
 				}, 
 				WingDbId.BOH_THRALL => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOH_THRALL_01,
-					ScenarioDbId.BOH_THRALL_02,
-					ScenarioDbId.BOH_THRALL_03,
-					ScenarioDbId.BOH_THRALL_04,
-					ScenarioDbId.BOH_THRALL_05,
-					ScenarioDbId.BOH_THRALL_06,
-					ScenarioDbId.BOH_THRALL_07,
-					ScenarioDbId.BOH_THRALL_08
+					{
+						ScenarioDbId.BOH_THRALL_01,
+						ScenarioDbId.BOH_THRALL_02,
+						ScenarioDbId.BOH_THRALL_03,
+						ScenarioDbId.BOH_THRALL_04,
+						ScenarioDbId.BOH_THRALL_05,
+						ScenarioDbId.BOH_THRALL_06,
+						ScenarioDbId.BOH_THRALL_07,
+						ScenarioDbId.BOH_THRALL_08
 				}, 
 				WingDbId.BOH_MALFURION => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOH_MALFURION_01,
-					ScenarioDbId.BOH_MALFURION_02,
-					ScenarioDbId.BOH_MALFURION_03,
-					ScenarioDbId.BOH_MALFURION_04,
-					ScenarioDbId.BOH_MALFURION_05,
-					ScenarioDbId.BOH_MALFURION_06,
-					ScenarioDbId.BOH_MALFURION_07,
-					ScenarioDbId.BOH_MALFURION_08
+					{
+						ScenarioDbId.BOH_MALFURION_01,
+						ScenarioDbId.BOH_MALFURION_02,
+						ScenarioDbId.BOH_MALFURION_03,
+						ScenarioDbId.BOH_MALFURION_04,
+						ScenarioDbId.BOH_MALFURION_05,
+						ScenarioDbId.BOH_MALFURION_06,
+						ScenarioDbId.BOH_MALFURION_07,
+						ScenarioDbId.BOH_MALFURION_08
 				}, 
 				WingDbId.BOH_GULDAN => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOH_GULDAN_01,
-					ScenarioDbId.BOH_GULDAN_02,
-					ScenarioDbId.BOH_GULDAN_03,
-					ScenarioDbId.BOH_GULDAN_04,
-					ScenarioDbId.BOH_GULDAN_05,
-					ScenarioDbId.BOH_GULDAN_06,
-					ScenarioDbId.BOH_GULDAN_07,
-					ScenarioDbId.BOH_GULDAN_08
+					{
+						ScenarioDbId.BOH_GULDAN_01,
+						ScenarioDbId.BOH_GULDAN_02,
+						ScenarioDbId.BOH_GULDAN_03,
+						ScenarioDbId.BOH_GULDAN_04,
+						ScenarioDbId.BOH_GULDAN_05,
+						ScenarioDbId.BOH_GULDAN_06,
+						ScenarioDbId.BOH_GULDAN_07,
+						ScenarioDbId.BOH_GULDAN_08
 				}, 
 				WingDbId.BOH_ILLIDAN => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOH_ILLIDAN_01,
-					ScenarioDbId.BOH_ILLIDAN_02,
-					ScenarioDbId.BOH_ILLIDAN_03,
-					ScenarioDbId.BOH_ILLIDAN_04,
-					ScenarioDbId.BOH_ILLIDAN_05,
-					ScenarioDbId.BOH_ILLIDAN_06,
-					ScenarioDbId.BOH_ILLIDAN_07,
-					ScenarioDbId.BOH_ILLIDAN_08
+					{
+						ScenarioDbId.BOH_ILLIDAN_01,
+						ScenarioDbId.BOH_ILLIDAN_02,
+						ScenarioDbId.BOH_ILLIDAN_03,
+						ScenarioDbId.BOH_ILLIDAN_04,
+						ScenarioDbId.BOH_ILLIDAN_05,
+						ScenarioDbId.BOH_ILLIDAN_06,
+						ScenarioDbId.BOH_ILLIDAN_07,
+						ScenarioDbId.BOH_ILLIDAN_08
 				}, 
 				WingDbId.BOH_FAELIN => new ScenarioDbId[19]
-				{
-					ScenarioDbId.BOH_FAELIN_01,
-					ScenarioDbId.BOH_FAELIN_02,
-					ScenarioDbId.BOH_FAELIN_03,
-					ScenarioDbId.BOH_FAELIN_04,
-					ScenarioDbId.BOH_FAELIN_05A,
-					ScenarioDbId.BOH_FAELIN_05B,
-					ScenarioDbId.BOH_FAELIN_06,
-					ScenarioDbId.BOH_FAELIN_07,
-					ScenarioDbId.BOH_FAELIN_08,
-					ScenarioDbId.BOH_FAELIN_09A,
-					ScenarioDbId.BOH_FAELIN_09B,
-					ScenarioDbId.BOH_FAELIN_10A,
-					ScenarioDbId.BOH_FAELIN_10B,
-					ScenarioDbId.BOH_FAELIN_11,
-					ScenarioDbId.BOH_FAELIN_12,
-					ScenarioDbId.BOH_FAELIN_13,
-					ScenarioDbId.BOH_FAELIN_14,
-					ScenarioDbId.BOH_FAELIN_15,
-					ScenarioDbId.BOH_FAELIN_16
+					{
+						ScenarioDbId.BOH_FAELIN_01,
+						ScenarioDbId.BOH_FAELIN_02,
+						ScenarioDbId.BOH_FAELIN_03,
+						ScenarioDbId.BOH_FAELIN_04,
+						ScenarioDbId.BOH_FAELIN_05A,
+						ScenarioDbId.BOH_FAELIN_05B,
+						ScenarioDbId.BOH_FAELIN_06,
+						ScenarioDbId.BOH_FAELIN_07,
+						ScenarioDbId.BOH_FAELIN_08,
+						ScenarioDbId.BOH_FAELIN_09A,
+						ScenarioDbId.BOH_FAELIN_09B,
+						ScenarioDbId.BOH_FAELIN_10A,
+						ScenarioDbId.BOH_FAELIN_10B,
+						ScenarioDbId.BOH_FAELIN_11,
+						ScenarioDbId.BOH_FAELIN_12,
+						ScenarioDbId.BOH_FAELIN_13,
+						ScenarioDbId.BOH_FAELIN_14,
+						ScenarioDbId.BOH_FAELIN_15,
+						ScenarioDbId.BOH_FAELIN_16
 				}, 
 				_ => new ScenarioDbId[8]
-				{
+			{
 					ScenarioDbId.BOH_JAINA_01,
 					ScenarioDbId.BOH_JAINA_02,
 					ScenarioDbId.BOH_JAINA_03,
@@ -9963,105 +9963,105 @@ public class Cheats : IService
 					ScenarioDbId.BOH_JAINA_08
 				}, 
 			}) : (wingIdFromMissionId switch
-			{
-				WingDbId.BOM_Xyrella => new ScenarioDbId[8]
 				{
-					ScenarioDbId.BOM_02_Xyrella_01,
-					ScenarioDbId.BOM_02_Xyrella_02,
-					ScenarioDbId.BOM_02_Xyrella_03,
-					ScenarioDbId.BOM_02_Xyrella_04,
-					ScenarioDbId.BOM_02_Xyrella_05,
-					ScenarioDbId.BOM_02_Xyrella_06,
-					ScenarioDbId.BOM_02_Xyrella_07,
-					ScenarioDbId.BOM_02_Xyrella_08
+				WingDbId.BOM_Xyrella => new ScenarioDbId[8]
+					{
+						ScenarioDbId.BOM_02_Xyrella_01,
+						ScenarioDbId.BOM_02_Xyrella_02,
+						ScenarioDbId.BOM_02_Xyrella_03,
+						ScenarioDbId.BOM_02_Xyrella_04,
+						ScenarioDbId.BOM_02_Xyrella_05,
+						ScenarioDbId.BOM_02_Xyrella_06,
+						ScenarioDbId.BOM_02_Xyrella_07,
+						ScenarioDbId.BOM_02_Xyrella_08
 				}, 
 				WingDbId.BOM_Guff => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOM_03_Guff_01,
-					ScenarioDbId.BOM_03_Guff_02,
-					ScenarioDbId.BOM_03_Guff_03,
-					ScenarioDbId.BOM_03_Guff_04,
-					ScenarioDbId.BOM_03_Guff_05,
-					ScenarioDbId.BOM_03_Guff_06,
-					ScenarioDbId.BOM_03_Guff_07,
-					ScenarioDbId.BOM_03_Guff_08
+					{
+						ScenarioDbId.BOM_03_Guff_01,
+						ScenarioDbId.BOM_03_Guff_02,
+						ScenarioDbId.BOM_03_Guff_03,
+						ScenarioDbId.BOM_03_Guff_04,
+						ScenarioDbId.BOM_03_Guff_05,
+						ScenarioDbId.BOM_03_Guff_06,
+						ScenarioDbId.BOM_03_Guff_07,
+						ScenarioDbId.BOM_03_Guff_08
 				}, 
 				WingDbId.BOM_Kurtrus => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOM_04_Kurtrus_01,
-					ScenarioDbId.BOM_04_Kurtrus_02,
-					ScenarioDbId.BOM_04_Kurtrus_03,
-					ScenarioDbId.BOM_04_Kurtrus_04,
-					ScenarioDbId.BOM_04_Kurtrus_05,
-					ScenarioDbId.BOM_04_Kurtrus_06,
-					ScenarioDbId.BOM_04_Kurtrus_07,
-					ScenarioDbId.BOM_04_Kurtrus_08
+					{
+						ScenarioDbId.BOM_04_Kurtrus_01,
+						ScenarioDbId.BOM_04_Kurtrus_02,
+						ScenarioDbId.BOM_04_Kurtrus_03,
+						ScenarioDbId.BOM_04_Kurtrus_04,
+						ScenarioDbId.BOM_04_Kurtrus_05,
+						ScenarioDbId.BOM_04_Kurtrus_06,
+						ScenarioDbId.BOM_04_Kurtrus_07,
+						ScenarioDbId.BOM_04_Kurtrus_08
 				}, 
 				WingDbId.BOM_Tamsin => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOM_05_Tamsin_001,
-					ScenarioDbId.BOM_05_Tamsin_002,
-					ScenarioDbId.BOM_05_Tamsin_003,
-					ScenarioDbId.BOM_05_Tamsin_004,
-					ScenarioDbId.BOM_05_Tamsin_005,
-					ScenarioDbId.BOM_05_Tamsin_006,
-					ScenarioDbId.BOM_05_Tamsin_007,
-					ScenarioDbId.BOM_05_Tamsin_008
+					{
+						ScenarioDbId.BOM_05_Tamsin_001,
+						ScenarioDbId.BOM_05_Tamsin_002,
+						ScenarioDbId.BOM_05_Tamsin_003,
+						ScenarioDbId.BOM_05_Tamsin_004,
+						ScenarioDbId.BOM_05_Tamsin_005,
+						ScenarioDbId.BOM_05_Tamsin_006,
+						ScenarioDbId.BOM_05_Tamsin_007,
+						ScenarioDbId.BOM_05_Tamsin_008
 				}, 
 				WingDbId.BOM_Cariel => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOM_06_Cariel_001,
-					ScenarioDbId.BOM_06_Cariel_002,
-					ScenarioDbId.BOM_06_Cariel_003,
-					ScenarioDbId.BOM_06_Cariel_004,
-					ScenarioDbId.BOM_06_Cariel_005,
-					ScenarioDbId.BOM_06_Cariel_006,
-					ScenarioDbId.BOM_06_Cariel_007,
-					ScenarioDbId.BOM_06_Cariel_008
+					{
+						ScenarioDbId.BOM_06_Cariel_001,
+						ScenarioDbId.BOM_06_Cariel_002,
+						ScenarioDbId.BOM_06_Cariel_003,
+						ScenarioDbId.BOM_06_Cariel_004,
+						ScenarioDbId.BOM_06_Cariel_005,
+						ScenarioDbId.BOM_06_Cariel_006,
+						ScenarioDbId.BOM_06_Cariel_007,
+						ScenarioDbId.BOM_06_Cariel_008
 				}, 
 				WingDbId.BOM_Scabbs => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOM_07_Scabbs_Fight_001,
-					ScenarioDbId.BOM_07_Scabbs_Fight_002,
-					ScenarioDbId.BOM_07_Scabbs_Fight_003,
-					ScenarioDbId.BOM_07_Scabbs_Fight_004,
-					ScenarioDbId.BOM_07_Scabbs_Fight_005,
-					ScenarioDbId.BOM_07_Scabbs_Fight_006,
-					ScenarioDbId.BOM_07_Scabbs_Fight_007,
-					ScenarioDbId.BOM_07_Scabbs_Fight_008
+					{
+						ScenarioDbId.BOM_07_Scabbs_Fight_001,
+						ScenarioDbId.BOM_07_Scabbs_Fight_002,
+						ScenarioDbId.BOM_07_Scabbs_Fight_003,
+						ScenarioDbId.BOM_07_Scabbs_Fight_004,
+						ScenarioDbId.BOM_07_Scabbs_Fight_005,
+						ScenarioDbId.BOM_07_Scabbs_Fight_006,
+						ScenarioDbId.BOM_07_Scabbs_Fight_007,
+						ScenarioDbId.BOM_07_Scabbs_Fight_008
 				}, 
 				WingDbId.BOM_Tavish => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOM_08_Tavish_Fight_001,
-					ScenarioDbId.BOM_08_Tavish_Fight_002,
-					ScenarioDbId.BOM_08_Tavish_Fight_003,
-					ScenarioDbId.BOM_08_Tavish_Fight_004,
-					ScenarioDbId.BOM_08_Tavish_Fight_005,
-					ScenarioDbId.BOM_08_Tavish_Fight_006,
-					ScenarioDbId.BOM_08_Tavish_Fight_007,
-					ScenarioDbId.BOM_08_Tavish_Fight_008
+					{
+						ScenarioDbId.BOM_08_Tavish_Fight_001,
+						ScenarioDbId.BOM_08_Tavish_Fight_002,
+						ScenarioDbId.BOM_08_Tavish_Fight_003,
+						ScenarioDbId.BOM_08_Tavish_Fight_004,
+						ScenarioDbId.BOM_08_Tavish_Fight_005,
+						ScenarioDbId.BOM_08_Tavish_Fight_006,
+						ScenarioDbId.BOM_08_Tavish_Fight_007,
+						ScenarioDbId.BOM_08_Tavish_Fight_008
 				}, 
 				WingDbId.BOM_Brukan => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOM_09_Brukan_Fight_001,
-					ScenarioDbId.BOM_09_Brukan_Fight_002,
-					ScenarioDbId.BOM_09_Brukan_Fight_003,
-					ScenarioDbId.BOM_09_Brukan_Fight_004,
-					ScenarioDbId.BOM_09_Brukan_Fight_005,
-					ScenarioDbId.BOM_09_Brukan_Fight_006,
-					ScenarioDbId.BOM_09_Brukan_Fight_007,
-					ScenarioDbId.BOM_09_Brukan_Fight_008
+					{
+						ScenarioDbId.BOM_09_Brukan_Fight_001,
+						ScenarioDbId.BOM_09_Brukan_Fight_002,
+						ScenarioDbId.BOM_09_Brukan_Fight_003,
+						ScenarioDbId.BOM_09_Brukan_Fight_004,
+						ScenarioDbId.BOM_09_Brukan_Fight_005,
+						ScenarioDbId.BOM_09_Brukan_Fight_006,
+						ScenarioDbId.BOM_09_Brukan_Fight_007,
+						ScenarioDbId.BOM_09_Brukan_Fight_008
 				}, 
 				WingDbId.BOM_Dawngrasp => new ScenarioDbId[8]
-				{
-					ScenarioDbId.BOM_10_Dawngrasp_Fight_001,
-					ScenarioDbId.BOM_10_Dawngrasp_Fight_002,
-					ScenarioDbId.BOM_10_Dawngrasp_Fight_003,
-					ScenarioDbId.BOM_10_Dawngrasp_Fight_004,
-					ScenarioDbId.BOM_10_Dawngrasp_Fight_005,
-					ScenarioDbId.BOM_10_Dawngrasp_Fight_006,
-					ScenarioDbId.BOM_10_Dawngrasp_Fight_007,
-					ScenarioDbId.BOM_10_Dawngrasp_Fight_008
+					{
+						ScenarioDbId.BOM_10_Dawngrasp_Fight_001,
+						ScenarioDbId.BOM_10_Dawngrasp_Fight_002,
+						ScenarioDbId.BOM_10_Dawngrasp_Fight_003,
+						ScenarioDbId.BOM_10_Dawngrasp_Fight_004,
+						ScenarioDbId.BOM_10_Dawngrasp_Fight_005,
+						ScenarioDbId.BOM_10_Dawngrasp_Fight_006,
+						ScenarioDbId.BOM_10_Dawngrasp_Fight_007,
+						ScenarioDbId.BOM_10_Dawngrasp_Fight_008
 				}, 
 				_ => new ScenarioDbId[8]
 				{
@@ -10743,8 +10743,8 @@ public class Cheats : IService
 			UIStatus.Get().AddInfo(message, 10f);
 			return true;
 		}
-		List<string> personalizedShopPageAndRefreshCatalog = args[0].Split(",").ToList();
-		StoreManager.Get().SetPersonalizedShopPageAndRefreshCatalog(personalizedShopPageAndRefreshCatalog);
+		List<string> personalizedShopPageAndRefreshCatalog = args[0].Split(',').ToList();
+			StoreManager.Get().SetPersonalizedShopPageAndRefreshCatalog(personalizedShopPageAndRefreshCatalog);
 		return true;
 	}
 
@@ -11247,56 +11247,56 @@ public class Cheats : IService
 	{
 		using FileStream stream = File.Open(path, FileMode.Create);
 		using StreamWriter streamWriter = new StreamWriter(stream);
-		IMaterialService materialService = ServiceManager.Get<IMaterialService>();
-		streamWriter.WriteLine("Renderer,Materials Count,PathToRoot");
-		foreach (KeyValuePair<int, RegisteredRenderer> registeredRenderer in materialService.GetRegisteredRenderers())
-		{
-			RegisteredRenderer value = registeredRenderer.Value;
-			Transform transform = value.Renderer.transform;
-			if (transform != null)
-			{
-				streamWriter.Write(transform.name);
-			}
-			else
-			{
-				streamWriter.Write("null");
-			}
-			streamWriter.Write(",");
-			streamWriter.Write(value.Materials.Count);
-			streamWriter.Write(",");
-			while (transform != null)
-			{
-				streamWriter.Write(transform.name);
-				streamWriter.Write("->");
-				transform = transform.parent;
+				IMaterialService materialService = ServiceManager.Get<IMaterialService>();
+				streamWriter.WriteLine("Renderer,Materials Count,PathToRoot");
+				foreach (KeyValuePair<int, RegisteredRenderer> registeredRenderer in materialService.GetRegisteredRenderers())
+				{
+					RegisteredRenderer value = registeredRenderer.Value;
+					Transform transform = value.Renderer.transform;
+					if (transform != null)
+					{
+						streamWriter.Write(transform.name);
+					}
+					else
+					{
+						streamWriter.Write("null");
+					}
+					streamWriter.Write(",");
+					streamWriter.Write(value.Materials.Count);
+					streamWriter.Write(",");
+					while (transform != null)
+					{
+						streamWriter.Write(transform.name);
+						streamWriter.Write("->");
+						transform = transform.parent;
+					}
+					streamWriter.WriteLine("null");
+				}
 			}
-			streamWriter.WriteLine("null");
-		}
-	}
 
 	private void DumpMaterialsToCsv(string path)
 	{
 		using FileStream stream = File.Open(path, FileMode.Create);
 		using StreamWriter streamWriter = new StreamWriter(stream);
-		IMaterialService materialService = ServiceManager.Get<IMaterialService>();
-		streamWriter.WriteLine("Material,HashCode,TimesUsed");
-		foreach (KeyValuePair<int, MaterialUsages> registeredMaterial in materialService.GetRegisteredMaterials())
-		{
-			MaterialUsages value = registeredMaterial.Value;
-			streamWriter.WriteLine(string.Format("{0},{1},{2},{3}", value.Material ? value.Material.name : "NULL", value.HashCode, value.TimesUsed, value.TimeToRemove));
-		}
-	}
+				IMaterialService materialService = ServiceManager.Get<IMaterialService>();
+				streamWriter.WriteLine("Material,HashCode,TimesUsed");
+				foreach (KeyValuePair<int, MaterialUsages> registeredMaterial in materialService.GetRegisteredMaterials())
+				{
+					MaterialUsages value = registeredMaterial.Value;
+					streamWriter.WriteLine(string.Format("{0},{1},{2},{3}", value.Material ? value.Material.name : "NULL", value.HashCode, value.TimesUsed, value.TimeToRemove));
+				}
+			}
 
 	private void DumpMaterialStatsToCsv(string path)
 	{
 		using FileStream stream = File.Open(path, FileMode.Create);
 		using StreamWriter streamWriter = new StreamWriter(stream);
-		IMaterialService materialService = ServiceManager.Get<IMaterialService>();
-		Dictionary<int, RegisteredRenderer> registeredRenderers = materialService.GetRegisteredRenderers();
-		Dictionary<int, MaterialUsages> registeredMaterials = materialService.GetRegisteredMaterials();
-		streamWriter.WriteLine("Custom Renderer Count,Custom Material Count,Unused Materials,Unused Renderers");
-		streamWriter.WriteLine($"{registeredRenderers.Count},{registeredMaterials.Count},{materialService.GetUnusedMaterials().Count},{materialService.GetUnusedRenderers().Count}");
-	}
+				IMaterialService materialService = ServiceManager.Get<IMaterialService>();
+				Dictionary<int, RegisteredRenderer> registeredRenderers = materialService.GetRegisteredRenderers();
+				Dictionary<int, MaterialUsages> registeredMaterials = materialService.GetRegisteredMaterials();
+				streamWriter.WriteLine("Custom Renderer Count,Custom Material Count,Unused Materials,Unused Renderers");
+				streamWriter.WriteLine($"{registeredRenderers.Count},{registeredMaterials.Count},{materialService.GetUnusedMaterials().Count},{materialService.GetUnusedRenderers().Count}");
+			}
 
 	private bool OnProcessCheat_LogZombies(string func, string[] args, string rawArgs)
 	{
diff --git a/Assembly-CSharp/ChestRewardDisplay.cs b/Assembly-CSharp/ChestRewardDisplay.cs
index dbee850..3bf3a67 100644
--- a/Assembly-CSharp/ChestRewardDisplay.cs
+++ b/Assembly-CSharp/ChestRewardDisplay.cs
@@ -1,266 +1,304 @@
 using System;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public class ChestRewardDisplay : MonoBehaviour
+public class ChestRewardDisplay : MonoBehaviour, AccessibleUI
 {
-	public const string DEFAULT_PREFAB = "RewardChest_Lock.prefab:06ffa33e82036694e8cacb96aa7b48e8";
+    public const string DEFAULT_PREFAB = "RewardChest_Lock.prefab:06ffa33e82036694e8cacb96aa7b48e8";
 
-	public const string MERCENARIES_PREFAB = "RewardChest_Mercenaries.prefab:7ba36254f98c8914e9b9931bbede3c88";
+    public const string MERCENARIES_PREFAB = "RewardChest_Mercenaries.prefab:7ba36254f98c8914e9b9931bbede3c88";
 
-	public const string MERCENARIES_CONSOLATION_PREFAB = "LettuceConsolationPrize.prefab:8c837b1ecf3fe184eadfca1a3d661f6f";
+    public const string MERCENARIES_CONSOLATION_PREFAB = "LettuceConsolationPrize.prefab:8c837b1ecf3fe184eadfca1a3d661f6f";
 
-	public const string MERCENARIES_AUTO_RETIRE_PREFAB = "LettuceAutorunPrize.prefab:05f50ccdbe9c5994e9dd5b2d19860822";
+    public const string MERCENARIES_AUTO_RETIRE_PREFAB = "LettuceAutorunPrize.prefab:05f50ccdbe9c5994e9dd5b2d19860822";
 
-	public const string MERCENARY_FULLY_UPGRADED_PREFAB = "MercenariesMaxedOutReward.prefab:57fbf1dc798a43547b597a5d63e18271";
+    public const string MERCENARY_FULLY_UPGRADED_PREFAB = "MercenariesMaxedOutReward.prefab:57fbf1dc798a43547b597a5d63e18271";
 
-	public PegUIElement m_rewardChest;
+    public PegUIElement m_rewardChest;
 
-	public PlayMakerFSM m_FSM;
+    public PlayMakerFSM m_FSM;
 
-	public Transform m_parent;
+    public Transform m_parent;
 
-	public GameObject m_descText;
+    public GameObject m_descText;
 
-	public GameObject m_bannerObject;
+    public GameObject m_bannerObject;
 
-	public UberText m_bannerUberText;
+    public UberText m_bannerUberText;
 
-	public Transform m_rewardBoxBone;
+    public Transform m_rewardBoxBone;
 
-	public Transform m_rewardBoxBonePackOpening;
+    public Transform m_rewardBoxBonePackOpening;
 
 	[SerializeField]
 	private float m_showRewardChestDimAmount = 0.5f;
 
-	private List<RewardData> m_rewards = new List<RewardData>();
-
-	private List<RewardData> m_bonusRewards = new List<RewardData>();
-
-	private List<RewardData> m_rewardsAfterBoxes = new List<RewardData>();
-
-	private List<Reward> m_rewardsAfterBoxesObjects = new List<Reward>();
-
-	private List<Action> m_doneCallbacks = new List<Action>();
-
-	private bool m_fromNotice;
-
-	private long m_noticeID = -1L;
-
-	private int m_wins;
-
-	private int m_leagueId;
-
-	private ScreenEffectsHandle m_screenEffectsHandle;
-
-	public bool ShowRewards_TavernBrawl(int wins, List<RewardData> rewards, Transform rewardBone, bool fromNotice = false, long noticeID = -1L)
-	{
-		if (rewards == null || rewards.Count < 1)
-		{
-			Debug.LogErrorFormat("rewards is null!");
-			return false;
-		}
-		m_wins = wins;
-		m_rewards = rewards;
-		m_fromNotice = fromNotice;
-		m_noticeID = noticeID;
-		m_descText.SetActive(fromNotice);
-		ShowRewardChest_TavernBrawl();
-		return true;
-	}
-
-	public bool ShowRewards_LeaguePromotion(int leagueId, List<RewardData> rewards, Transform rewardBone, bool fromNotice = false, long noticeID = -1L)
-	{
-		if (rewards == null || rewards.Count < 1)
-		{
-			Debug.LogErrorFormat("rewards is null!");
-			return false;
-		}
-		m_leagueId = leagueId;
-		m_rewards = rewards;
-		m_fromNotice = fromNotice;
-		m_noticeID = noticeID;
-		ShowRewardChest_LeaguePromotion();
-		return true;
-	}
-
-	public bool ShowRewards_Quest(List<RewardData> rewards, Transform rewardBone, string title, string desc, bool fromNotice, int noticeId)
-	{
-		if (rewards == null || rewards.Count < 1)
-		{
-			Debug.LogErrorFormat("rewards is null!");
-			return false;
-		}
-		m_rewards = rewards;
-		m_fromNotice = fromNotice;
-		m_noticeID = noticeId;
-		m_bannerUberText.Text = title;
-		m_descText.SetActive(value: true);
-		m_descText.GetComponent<UberText>().Text = desc;
-		ShowRewardChest();
-		return true;
-	}
-
-	public bool ShowRewards_Mercenaries(List<RewardData> rewards, List<RewardData> bonusRewards, bool autoOpenChest, bool fromNotice, int noticeId)
-	{
-		m_rewards = rewards;
-		m_bonusRewards = bonusRewards;
-		return ShowRewards_MercenariesShared(autoOpenChest, fromNotice, noticeId);
-	}
-
-	private bool ShowRewards_MercenariesShared(bool autoOpenChest, bool fromNotice, int noticeId)
-	{
-		m_fromNotice = fromNotice;
-		m_noticeID = noticeId;
-		if (m_bannerObject != null)
-		{
-			UnityEngine.Object.Destroy(m_bannerObject);
-		}
-		m_descText?.SetActive(value: false);
-		ShowRewardChest();
-		if (autoOpenChest)
-		{
-			ShowRewardBags(null);
-		}
-		return true;
-	}
-
-	public void RegisterDoneCallback(Action action)
-	{
-		m_doneCallbacks.Add(action);
-	}
-
-	private void Awake()
-	{
-		m_screenEffectsHandle = new ScreenEffectsHandle(this);
-	}
-
-	private void ShowRewardChest()
-	{
+    private List<RewardData> m_rewards = new List<RewardData>();
+
+    private List<RewardData> m_bonusRewards = new List<RewardData>();
+
+    private List<RewardData> m_rewardsAfterBoxes = new List<RewardData>();
+
+    private List<Reward> m_rewardsAfterBoxesObjects = new List<Reward>();
+
+    private List<Action> m_doneCallbacks = new List<Action>();
+
+    private bool m_fromNotice;
+
+    private long m_noticeID = -1L;
+
+    private int m_wins;
+
+    private int m_leagueId;
+
+    private ScreenEffectsHandle m_screenEffectsHandle;
+
+    public bool ShowRewards_TavernBrawl(int wins, List<RewardData> rewards, Transform rewardBone, bool fromNotice = false, long noticeID = -1L)
+    {
+        if (rewards == null || rewards.Count < 1)
+        {
+            Debug.LogErrorFormat("rewards is null!");
+            return false;
+        }
+        m_wins = wins;
+        m_rewards = rewards;
+        m_fromNotice = fromNotice;
+        m_noticeID = noticeID;
+        m_descText.SetActive(fromNotice);
+        ShowRewardChest_TavernBrawl();
+        return true;
+    }
+
+    public bool ShowRewards_LeaguePromotion(int leagueId, List<RewardData> rewards, Transform rewardBone, bool fromNotice = false, long noticeID = -1L)
+    {
+        if (rewards == null || rewards.Count < 1)
+        {
+            Debug.LogErrorFormat("rewards is null!");
+            return false;
+        }
+        m_leagueId = leagueId;
+        m_rewards = rewards;
+        m_fromNotice = fromNotice;
+        m_noticeID = noticeID;
+        ShowRewardChest_LeaguePromotion();
+        return true;
+    }
+
+    public bool ShowRewards_Quest(List<RewardData> rewards, Transform rewardBone, string title, string desc, bool fromNotice, int noticeId)
+    {
+        if (rewards == null || rewards.Count < 1)
+        {
+            Debug.LogErrorFormat("rewards is null!");
+            return false;
+        }
+        m_rewards = rewards;
+        m_fromNotice = fromNotice;
+        m_noticeID = noticeId;
+        m_bannerUberText.Text = title;
+        m_descText.SetActive(value: true);
+        m_descText.GetComponent<UberText>().Text = desc;
+        ShowRewardChest(true);
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_CHEST_REWARD_DISPLAY_TITLE), true);
+        AccessibilityMgr.Output(this, title);
+        AccessibilityMgr.Output(this, desc);
+        AccessibilityMgr.Output(this, GetAccessibleHelp());
+        return true;
+    }
+
+    public bool ShowRewards_Mercenaries(List<RewardData> rewards, List<RewardData> bonusRewards, bool autoOpenChest, bool fromNotice, int noticeId)
+    {
+        m_rewards = rewards;
+        m_bonusRewards = bonusRewards;
+        return ShowRewards_MercenariesShared(autoOpenChest, fromNotice, noticeId);
+    }
+
+    private bool ShowRewards_MercenariesShared(bool autoOpenChest, bool fromNotice, int noticeId)
+    {
+        m_fromNotice = fromNotice;
+        m_noticeID = noticeId;
+        if (m_bannerObject != null)
+        {
+            UnityEngine.Object.Destroy(m_bannerObject);
+        }
+        m_descText?.SetActive(value: false);
+        ShowRewardChest(false);
+        if (autoOpenChest)
+        {
+            ShowRewardBags(null);
+        }
+        return true;
+    }
+
+    public void RegisterDoneCallback(Action action)
+    {
+        m_doneCallbacks.Add(action);
+    }
+
+    private void Awake()
+    {
+        m_screenEffectsHandle = new ScreenEffectsHandle(this);
+    }
+
+    private void ShowRewardChest(bool accessible)
+    {
 		ScreenEffectParameters blurVignetteDesaturatePerspective = ScreenEffectParameters.BlurVignetteDesaturatePerspective;
 		blurVignetteDesaturatePerspective.Type |= ScreenEffectType.BLENDTOCOLOR;
 		blurVignetteDesaturatePerspective.BlendToColor.BlendColor = Color.black;
 		blurVignetteDesaturatePerspective.BlendToColor.Amount = m_showRewardChestDimAmount;
 		m_screenEffectsHandle.StartEffect(blurVignetteDesaturatePerspective);
-		m_FSM.SendEvent("SummonIn");
-		LayerUtils.SetLayer(m_rewardChest.gameObject, GameLayer.IgnoreFullScreenEffects);
-		m_rewardChest.AddEventListener(UIEventType.RELEASE, ShowRewardBags);
-	}
-
-	private void ShowRewardChest_TavernBrawl()
-	{
-		ShowRewardChest();
-		string text = ((m_wins != 0) ? GameStrings.Format("GLUE_BRAWLISEUM_REWARDS_WIN_BANNER_TEXT", m_wins, m_wins) : GameStrings.Get("GLUE_BRAWLISEUM_NO_WINS_REWARD_PACK_TEXT"));
-		m_bannerUberText.Text = text;
-	}
-
-	private void ShowRewardChest_LeaguePromotion()
-	{
-		ShowRewardChest();
+        m_FSM.SendEvent("SummonIn");
+        LayerUtils.SetLayer(m_rewardChest.gameObject, GameLayer.IgnoreFullScreenEffects);
+        m_rewardChest.AddEventListener(UIEventType.RELEASE, ShowRewardBags);
+    }
+
+    private void ShowRewardChest_TavernBrawl()
+    {
+        ShowRewardChest(true);
+        string text = ((m_wins != 0) ? GameStrings.Format("GLUE_BRAWLISEUM_REWARDS_WIN_BANNER_TEXT", m_wins, m_wins) : GameStrings.Get("GLUE_BRAWLISEUM_NO_WINS_REWARD_PACK_TEXT"));
+        m_bannerUberText.Text = text;
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_CHEST_REWARD_DISPLAY_TITLE), true);
+        AccessibilityMgr.Output(this, text);
+        AccessibilityMgr.Output(this, GetAccessibleHelp());
+    }
+
+    private void ShowRewardChest_LeaguePromotion()
+    {
+		ShowRewardChest(true);
 		GameDbf.LeagueRank.GetRecord((LeagueRankDbfRecord r) => r.LeagueId == m_leagueId && r.StarLevel == 1);
 		m_bannerUberText.Text = GameStrings.Get("GLUE_NEW_PLAYER_PROMOTION_CHEST_TITLE");
-		m_descText.GetComponent<UberText>().Text = GameStrings.Get("GLUE_NEW_PLAYER_PROMOTION_CHEST_DESC");
-	}
-
-	private void OnRollover(UIEvent e)
-	{
-		m_FSM.SendEvent("Hover");
-	}
-
-	private void OnRollout(UIEvent e)
-	{
-		m_FSM.SendEvent("Idle");
-	}
-
-	private void ShowRewardBags(UIEvent e)
-	{
-		m_rewardChest.RemoveEventListener(UIEventType.RELEASE, ShowRewardBags);
-		m_rewardChest.RemoveEventListener(UIEventType.ROLLOVER, OnRollover);
-		m_rewardChest.RemoveEventListener(UIEventType.ROLLOUT, OnRollout);
-		m_FSM.SendEvent("StartAnim");
-	}
-
-	private void OpenRewards()
-	{
-		if (m_rewards == null || m_rewards.Count == 0)
-		{
-			OnRewardBoxesDone();
-			return;
-		}
-		PrefabCallback<GameObject> callback = delegate(AssetReference assetRef, GameObject go, object callbackData)
-		{
-			if (SoundManager.Get() != null)
-			{
-				SoundManager.Get().LoadAndPlay("card_turn_over_legendary.prefab:a8140f686bff601459e954bc23de35e0");
-			}
-			RewardBoxesDisplay component = go.GetComponent<RewardBoxesDisplay>();
-			component.SetRewards(m_rewards, m_bonusRewards);
-			component.m_playBoxFlyoutSound = false;
-			component.SetLayer(GameLayer.IgnoreFullScreenEffects);
-			component.UseDarkeningClickCatcher(value: true);
-			component.RegisterDoneCallback(OnRewardBoxesDone);
-			if (!UniversalInputManager.UsePhoneUI)
-			{
-				LayerUtils.SetLayer(m_rewardChest.gameObject, GameLayer.Default);
-			}
-			Transform rewardBoxBoneForScene = GetRewardBoxBoneForScene();
-			component.transform.position = rewardBoxBoneForScene.position;
-			component.transform.localRotation = rewardBoxBoneForScene.localRotation;
-			component.transform.localScale = rewardBoxBoneForScene.localScale;
-			component.AnimateRewards();
-		};
-		AssetLoader.Get().InstantiatePrefab(RewardBoxesDisplay.GetPrefab(m_rewards), callback);
-	}
-
-	private void OnRewardBoxesDone()
-	{
-		if (m_rewardsAfterBoxes.Count == 0)
-		{
-			OnAllChestRewardsDone();
-		}
-		else
-		{
-			DisplayRewardsAfterRewardBoxes();
-		}
-	}
-
-	private void DisplayRewardsAfterRewardBoxes()
-	{
-		RewardUtils.LoadAndDisplayRewards(m_rewardsAfterBoxes, OnAllChestRewardsDone);
-	}
-
-	private void OnAllChestRewardsDone()
-	{
-		m_screenEffectsHandle.StopEffect(RewardUtils.MercRewardEndBlurTime);
-		m_FSM.SendEvent("SummonOut");
-		m_descText.SetActive(value: false);
-		if (m_fromNotice)
-		{
-			Network.Get().AckNotice(m_noticeID);
-		}
-	}
-
-	public void OnSummonInAnimationDone()
-	{
-		m_rewardChest.AddEventListener(UIEventType.ROLLOVER, OnRollover);
-		m_rewardChest.AddEventListener(UIEventType.ROLLOUT, OnRollout);
-	}
-
-	public void OnSummonOutAnimationDone()
-	{
-		foreach (Action doneCallback in m_doneCallbacks)
-		{
-			doneCallback?.Invoke();
-		}
-		UnityEngine.Object.Destroy(m_parent.gameObject);
-	}
-
-	private Transform GetRewardBoxBoneForScene()
-	{
+        var desc = m_descText.GetComponent<UberText>();
+		desc.Text = GameStrings.Get("GLUE_NEW_PLAYER_PROMOTION_CHEST_DESC");
+
+                AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_CHEST_REWARD_DISPLAY_TITLE), true);
+        AccessibilityMgr.Output(this, m_bannerUberText.Text);
+        AccessibilityMgr.Output(this, desc.Text);
+        AccessibilityMgr.Output(this, GetAccessibleHelp());
+    }
+
+    private void OnRollover(UIEvent e)
+    {
+        m_FSM.SendEvent("Hover");
+    }
+
+    private void OnRollout(UIEvent e)
+    {
+        m_FSM.SendEvent("Idle");
+    }
+
+    private void ShowRewardBags(UIEvent e)
+    {
+        m_rewardChest.RemoveEventListener(UIEventType.RELEASE, ShowRewardBags);
+        m_rewardChest.RemoveEventListener(UIEventType.ROLLOVER, OnRollover);
+        m_rewardChest.RemoveEventListener(UIEventType.ROLLOUT, OnRollout);
+        m_FSM.SendEvent("StartAnim");
+    }
+
+    private void OpenRewards()
+    {
+        if (m_rewards == null || m_rewards.Count == 0)
+        {
+            OnRewardBoxesDone();
+            return;
+        }
+        PrefabCallback<GameObject> callback = delegate (AssetReference assetRef, GameObject go, object callbackData)
+        {
+            if (SoundManager.Get() != null)
+            {
+                SoundManager.Get().LoadAndPlay("card_turn_over_legendary.prefab:a8140f686bff601459e954bc23de35e0");
+            }
+            RewardBoxesDisplay component = go.GetComponent<RewardBoxesDisplay>();
+            component.SetRewards(m_rewards, m_bonusRewards);
+            component.m_playBoxFlyoutSound = false;
+            component.SetLayer(GameLayer.IgnoreFullScreenEffects);
+            component.UseDarkeningClickCatcher(value: true);
+            component.RegisterDoneCallback(OnRewardBoxesDone);
+            if (!UniversalInputManager.UsePhoneUI)
+            {
+                LayerUtils.SetLayer(m_rewardChest.gameObject, GameLayer.Default);
+            }
+            Transform rewardBoxBoneForScene = GetRewardBoxBoneForScene();
+            component.transform.position = rewardBoxBoneForScene.position;
+            component.transform.localRotation = rewardBoxBoneForScene.localRotation;
+            component.transform.localScale = rewardBoxBoneForScene.localScale;
+            component.AnimateRewards();
+        };
+        AssetLoader.Get().InstantiatePrefab(RewardBoxesDisplay.GetPrefab(m_rewards), callback);
+    }
+
+    private void OnRewardBoxesDone()
+    {
+        if (m_rewardsAfterBoxes.Count == 0)
+        {
+            OnAllChestRewardsDone();
+        }
+        else
+        {
+            DisplayRewardsAfterRewardBoxes();
+        }
+    }
+
+    private void DisplayRewardsAfterRewardBoxes()
+    {
+        RewardUtils.LoadAndDisplayRewards(m_rewardsAfterBoxes, OnAllChestRewardsDone);
+    }
+
+    private void OnAllChestRewardsDone()
+    {
+        m_screenEffectsHandle.StopEffect(RewardUtils.MercRewardEndBlurTime);
+        m_FSM.SendEvent("SummonOut");
+        m_descText.SetActive(value: false);
+        if (m_fromNotice)
+        {
+            Network.Get().AckNotice(m_noticeID);
+        }
+    }
+
+    public void OnSummonInAnimationDone()
+    {
+        m_rewardChest.AddEventListener(UIEventType.ROLLOVER, OnRollover);
+        m_rewardChest.AddEventListener(UIEventType.ROLLOUT, OnRollout);
+    }
+
+    public void OnSummonOutAnimationDone()
+    {
+        AccessibilityMgr.HideUI(this);
+
+        foreach (Action doneCallback in m_doneCallbacks)
+        {
+            doneCallback?.Invoke();
+        }
+        UnityEngine.Object.Destroy(m_parent.gameObject);
+    }
+
+    private Transform GetRewardBoxBoneForScene()
+    {
 		if (SceneMgr.Get().GetMode() == SceneMgr.Mode.PACKOPENING)
-		{
-			return m_rewardBoxBonePackOpening;
-		}
-		return m_rewardBoxBone;
-	}
+        {
+            return m_rewardBoxBonePackOpening;
+        }
+        return m_rewardBoxBone;
+    }
+
+    #region Accessibility
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+            m_rewardChest.TriggerRelease();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+        return LocalizationUtils.Format(LocalizationKey.UI_CHEST_REWARD_DISPLAY_HELP, AccessibleKey.CONFIRM);
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/ChoiceCardMgr.cs b/Assembly-CSharp/ChoiceCardMgr.cs
index 207fec6..e716f8c 100644
--- a/Assembly-CSharp/ChoiceCardMgr.cs
+++ b/Assembly-CSharp/ChoiceCardMgr.cs
@@ -719,7 +719,7 @@ public class ChoiceCardMgr : MonoBehaviour
 		}
 		if (GameState.Get()?.GameScenarioAllowsPowerPrinting() ?? true)
 		{
-			Log.Power.Print("ChoiceCardMgr.WaitThenShowChoices() - id={0} BEGIN", choices.ID);
+		Log.Power.Print("ChoiceCardMgr.WaitThenShowChoices() - id={0} BEGIN", choices.ID);
 		}
 		List<Card> linkedChoiceCards = new List<Card>();
 		Entity entity2 = GameState.Get().GetEntity(state.m_sourceEntityId);
@@ -1042,6 +1042,11 @@ public class ChoiceCardMgr : MonoBehaviour
 	private void ShowChoiceCards(ChoiceState state, bool friendly)
 	{
 		StartCoroutine(PlayCardAnimation(state, friendly));
+
+		if (friendly)
+		{
+			Accessibility.AccessibleGameplay.Get().OnChoice(state.m_cards, m_choiceBanner, m_confirmChoiceButton);
+		}
 	}
 
 	private void GetDeckTransform(ZoneDeck deckZone, out Vector3 startPos, out Vector3 startRot, out Vector3 startScale)
@@ -1144,11 +1149,11 @@ public class ChoiceCardMgr : MonoBehaviour
 			}
 			return;
 		}
-		Spell spell3 = SpellManager.Get().GetSpell(choiceEffectDataForCard.m_Spell);
-		spell3.AddStateFinishedCallback(callback);
-		spell3.Activate();
-		state.m_choiceEffectSpells.Add(spell3);
-	}
+			Spell spell3 = SpellManager.Get().GetSpell(choiceEffectDataForCard.m_Spell);
+			spell3.AddStateFinishedCallback(callback);
+			spell3.Activate();
+			state.m_choiceEffectSpells.Add(spell3);
+		}
 
 	private void ActivateChoiceCardStateSpells(Card card)
 	{
@@ -1346,7 +1351,7 @@ public class ChoiceCardMgr : MonoBehaviour
 			{
 				if (allowedToPrintPowers)
 				{
-					Log.Power.Print("ChoiceCardMgr.WaitThenHideChoicesFromPacket() - id={0} BEGIN WAIT for EntityChoice", chosen.ID);
+				Log.Power.Print("ChoiceCardMgr.WaitThenHideChoicesFromPacket() - id={0} BEGIN WAIT for EntityChoice", chosen.ID);
 				}
 				while (choiceState.m_waitingToStart)
 				{
@@ -1382,7 +1387,7 @@ public class ChoiceCardMgr : MonoBehaviour
 		}
 		if (allowedToPrintPowers)
 		{
-			Log.Power.Print("ChoiceCardMgr.WaitThenHideChoicesFromPacket() - id={0} END WAIT", chosen.ID);
+		Log.Power.Print("ChoiceCardMgr.WaitThenHideChoicesFromPacket() - id={0} END WAIT", chosen.ID);
 		}
 		ConcealChoicesFromPacket(playerId, choiceState, chosen);
 	}
@@ -1420,7 +1425,7 @@ public class ChoiceCardMgr : MonoBehaviour
 			GameState gameState = GameState.Get();
 			if (gameState == null || gameState.GameScenarioAllowsPowerPrinting())
 			{
-				Log.Power.Print($"ChoiceCardMgr.DoesLocalChoiceMatchPacket(): Null list passed in! localChoices={localChoices}, packetChoices={packetChoices}.");
+			Log.Power.Print($"ChoiceCardMgr.DoesLocalChoiceMatchPacket(): Null list passed in! localChoices={localChoices}, packetChoices={packetChoices}.");
 			}
 			return false;
 		}
@@ -1574,18 +1579,18 @@ public class ChoiceCardMgr : MonoBehaviour
 		HideChoiceBanner();
 		if (!choiceState.m_isSubOptionChoice || choiceState.m_isTitanAbility)
 		{
-			Transform transform = Board.Get().FindBone(m_ChoiceData.m_BannerBoneName);
-			m_choiceBanner = UnityEngine.Object.Instantiate(m_ChoiceData.m_BannerPrefab, transform.position, transform.rotation);
+		Transform transform = Board.Get().FindBone(m_ChoiceData.m_BannerBoneName);
+		m_choiceBanner = UnityEngine.Object.Instantiate(m_ChoiceData.m_BannerPrefab, transform.position, transform.rotation);
 			m_choiceBanner.SetupBanner(choiceState.m_sourceEntityId, choiceState.m_cards, choiceState.m_isSubOptionChoice);
 			if (!(GameState.Get().GetEntity(choiceState.m_sourceEntityId).GetCardId() != "TTN_717t"))
 			{
-				Vector3 localScale = m_choiceBanner.transform.localScale;
-				m_choiceBanner.transform.localScale = INVISIBLE_SCALE;
-				Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
-				tweenHashTable.Add("scale", localScale);
-				tweenHashTable.Add("time", m_ChoiceData.m_UiShowTime);
-				iTween.ScaleTo(m_choiceBanner.gameObject, tweenHashTable);
-			}
+		Vector3 localScale = m_choiceBanner.transform.localScale;
+		m_choiceBanner.transform.localScale = INVISIBLE_SCALE;
+		Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
+		tweenHashTable.Add("scale", localScale);
+		tweenHashTable.Add("time", m_ChoiceData.m_UiShowTime);
+		iTween.ScaleTo(m_choiceBanner.gameObject, tweenHashTable);
+	}
 		}
 	}
 
@@ -1611,7 +1616,7 @@ public class ChoiceCardMgr : MonoBehaviour
 		}
 		else
 		{
-			m_toggleChoiceButton = CreateChoiceButton(text, ChoiceButton_OnPress, ToggleChoiceButton_OnRelease, GameStrings.Get("GLOBAL_HIDE"));
+		m_toggleChoiceButton = CreateChoiceButton(text, ChoiceButton_OnPress, ToggleChoiceButton_OnRelease, GameStrings.Get("GLOBAL_HIDE"));
 		}
 		Network.EntityChoices friendlyEntityChoices = GameState.Get().GetFriendlyEntityChoices();
 		if (friendlyEntityChoices != null && !friendlyEntityChoices.IsSingleChoice())
@@ -1699,6 +1704,8 @@ public class ChoiceCardMgr : MonoBehaviour
 			m_toggleChoiceButton.SetText(GameStrings.Get("GLOBAL_SHOW"));
 			HideChoiceCards(state);
 			m_friendlyChoicesShown = false;
+
+			Accessibility.AccessibleGameplay.Get().OnChoicesHidden();
 		}
 		else
 		{
@@ -1812,30 +1819,30 @@ public class ChoiceCardMgr : MonoBehaviour
 		}
 		if (spell != null)
 		{
-			for (int i = 0; i < subCardIDs.Count; i++)
-			{
-				int id = subCardIDs[i];
+		for (int i = 0; i < subCardIDs.Count; i++)
+		{
+			int id = subCardIDs[i];
 				Card card = gameState.GetEntity(id).GetCard();
 				if (!(card == null))
-				{
+			{
 					choiceState.m_cards.Add(card);
-					m_subOptionState.m_cards.Add(card);
-					card.ForceLoadHandActor();
+			m_subOptionState.m_cards.Add(card);
+			card.ForceLoadHandActor();
 					card.GetActor().Hide();
-					card.transform.position = parentCard.transform.position;
-					Vector3 position = default(Vector3);
-					position.x = x + (float)i * friendlyCardWidth;
-					position.y = transform.position.y;
-					position.z = transform.position.z;
-					iTween.MoveTo(card.gameObject, position, m_SubOptionData.m_CardShowTime);
-					Vector3 localScale = transform.localScale;
-					if (subCardIDs.Count > m_CommonData.m_MaxCardsBeforeAdjusting)
-					{
-						float scaleForCardCount = GetScaleForCardCount(subCardIDs.Count);
-						localScale.x *= scaleForCardCount;
-						localScale.y *= scaleForCardCount;
-						localScale.z *= scaleForCardCount;
-					}
+			card.transform.position = parentCard.transform.position;
+			Vector3 position = default(Vector3);
+			position.x = x + (float)i * friendlyCardWidth;
+			position.y = transform.position.y;
+			position.z = transform.position.z;
+			iTween.MoveTo(card.gameObject, position, m_SubOptionData.m_CardShowTime);
+			Vector3 localScale = transform.localScale;
+			if (subCardIDs.Count > m_CommonData.m_MaxCardsBeforeAdjusting)
+			{
+				float scaleForCardCount = GetScaleForCardCount(subCardIDs.Count);
+				localScale.x *= scaleForCardCount;
+				localScale.y *= scaleForCardCount;
+				localScale.z *= scaleForCardCount;
+			}
 					card.transform.localScale = localScale;
 				}
 			}
@@ -1889,6 +1896,7 @@ public class ChoiceCardMgr : MonoBehaviour
 			ShowChoiceUi(choiceState);
 		}
 		HideEnlargedHand();
+		Accessibility.AccessibleGameplay.Get().OnSubOption(m_subOptionState.m_cards);
 	}
 
 	private void HideSubOptions(Entity chosenEntity = null)
@@ -1989,6 +1997,11 @@ public class ChoiceCardMgr : MonoBehaviour
 		}
 		PlayChoiceEffects(choiceState, choiceState.m_isFriendly);
 		choiceState.m_hasBeenRevealed = true;
+
+		if (choiceState.m_isFriendly)
+		{
+			Accessibility.AccessibleGameplay.Get().OnChoice(choiceState.m_cards, m_choiceBanner, m_confirmChoiceButton);
+		}
 	}
 
 	private void ConcealChoiceCardsUsingCustomSpell(ISpell customChoiceConcealSpell, ChoiceState choiceState, Network.EntitiesChosen chosen)
@@ -2014,4 +2027,11 @@ public class ChoiceCardMgr : MonoBehaviour
 		OnFinishedConcealChoices(entitiesChosen.PlayerId);
 		GameState.Get().OnEntitiesChosenProcessed(entitiesChosen);
 	}
+
+	#region Accessibility
+	internal bool IsShowingFriendlyCards()
+	{
+		return m_friendlyChoicesShown;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/ChooseDeckReward.cs b/Assembly-CSharp/ChooseDeckReward.cs
index 06b8195..88ae771 100644
--- a/Assembly-CSharp/ChooseDeckReward.cs
+++ b/Assembly-CSharp/ChooseDeckReward.cs
@@ -1,8 +1,9 @@
 using System.Collections.Generic;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
+using Accessibility;
 
-public class ChooseDeckReward : CustomVisualReward
+public class ChooseDeckReward : CustomVisualReward, AccessibleUI
 {
 	public AsyncReference m_chooseDeckReference;
 
@@ -20,10 +21,15 @@ public class ChooseDeckReward : CustomVisualReward
 
 	private int m_selectedDeckTemplateId;
 
+	#region Accessibility
+	private int m_numButtonsLoading;
+	#endregion
+
 	public override void Start()
 	{
 		m_classButtonWidgets = new Widget[m_classButtonReferences.Length];
 		m_buttonDataModels = new DeckChoiceDataModel[m_classButtonReferences.Length];
+		m_numButtonsLoading = m_classButtonReferences.Length;
 		for (int i = 0; i < m_classButtonReferences.Length; i++)
 		{
 			int classIndex = i;
@@ -91,5 +97,65 @@ public class ChooseDeckReward : CustomVisualReward
 		m_classButtonWidgets[index] = w;
 		m_buttonDataModels[index] = deckChoiceDataModel;
 		w.BindDataModel(deckChoiceDataModel);
+
+		// Accessibility
+		m_numButtonsLoading--;
+
+		if (m_numButtonsLoading == 0)
+        {
+			ReadChooseDeckUI();
+        }
 	}
+
+	#region Accessibility
+
+	private enum State { LOADING, CHOOSING };
+
+	private AccessibleMenu m_chooseDeckMenu;
+	private State m_curState = State.LOADING;
+
+	private void ReadChooseDeckUI()
+    {
+		m_curState = State.LOADING;
+
+		m_chooseDeckMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.UI_CHOOSE_FREE_DECK_TITLE), null);
+
+		for (int i = 0; i < m_buttonDataModels.Length; i++)
+        {
+			var classIndex = i;
+			m_chooseDeckMenu.AddOption(GameStrings.GetClassName(GameUtils.ORDERED_HERO_CLASSES[i]), () => ChooseDeck(classIndex));
+        }
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		m_chooseDeckMenu.StartReading();
+		m_curState = State.CHOOSING;
+    }
+
+    private void ChooseDeck(int index)
+    {
+		SetSelectedButtonIndex(index);
+		ChoiceConfirmed();
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (m_curState == State.LOADING)
+        {
+			return;
+        }
+		m_chooseDeckMenu?.HandleAccessibleInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_curState == State.CHOOSING)
+        {
+			return m_chooseDeckMenu?.GetHelp();
+        }
+
+		return "";
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/ClientOption.cs b/Assembly-CSharp/ClientOption.cs
index 0900485..dae999f 100644
--- a/Assembly-CSharp/ClientOption.cs
+++ b/Assembly-CSharp/ClientOption.cs
@@ -131,6 +131,13 @@ public enum ClientOption
 	APKINSTALL_START,
 	APKINSTALL_FAILURE_REPORTED,
 	INTERNET_UNREACHABLE,
+	#region Accessibility
+	ACCESSIBILITY_GAME_SPEED,
+	ACCESSIBILITY_BACKGROUND_SPEECH,
+	ACCESSIBILITY_AUTO_ATTACK_SPEED,
+	ACCESSIBILITY_SAVE_BATTLE_LOGS,
+	ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS,
+	#endregion
 	DEBUG_SHOW_BATTLEGROUND_SKIN_IDS,
 	AADC_LOCAL_SAVE_TIME_STAMP,
 	AADC_SERVER_SAVE_TIME_STAMP,
diff --git a/Assembly-CSharp/CollectibleBattlegroundsBoard.cs b/Assembly-CSharp/CollectibleBattlegroundsBoard.cs
index b624300..cb14d2d 100644
--- a/Assembly-CSharp/CollectibleBattlegroundsBoard.cs
+++ b/Assembly-CSharp/CollectibleBattlegroundsBoard.cs
@@ -49,9 +49,9 @@ public class CollectibleBattlegroundsBoard : ICollectible, IComparable
 		}
 		BattlegroundsBoardSkinDbfRecord battlegroundsBoardSkinDbfRecord = obj as BattlegroundsBoardSkinDbfRecord;
 		if (battlegroundsBoardSkinDbfRecord == null && obj is CollectibleBattlegroundsBoard collectibleBattlegroundsBoard)
-		{
-			battlegroundsBoardSkinDbfRecord = collectibleBattlegroundsBoard.DbfRecord;
-		}
+			{
+				battlegroundsBoardSkinDbfRecord = collectibleBattlegroundsBoard.DbfRecord;
+			}
 		if (battlegroundsBoardSkinDbfRecord == null)
 		{
 			return -1;
@@ -106,4 +106,12 @@ public class CollectibleBattlegroundsBoard : ICollectible, IComparable
 		}
 		return battlegroundsBoardSkinDataModel;
 	}
+
+	#region Accessibility
+	public bool IsAccessible()
+	{
+		// TODO
+		return false;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/CollectibleBattlegroundsEmote.cs b/Assembly-CSharp/CollectibleBattlegroundsEmote.cs
index a897ff5..ecef2b1 100644
--- a/Assembly-CSharp/CollectibleBattlegroundsEmote.cs
+++ b/Assembly-CSharp/CollectibleBattlegroundsEmote.cs
@@ -49,9 +49,9 @@ public class CollectibleBattlegroundsEmote : ICollectible, IComparable
 		}
 		BattlegroundsEmoteDbfRecord battlegroundsEmoteDbfRecord = obj as BattlegroundsEmoteDbfRecord;
 		if (battlegroundsEmoteDbfRecord == null && obj is CollectibleBattlegroundsEmote collectibleBattlegroundsEmote)
-		{
-			battlegroundsEmoteDbfRecord = collectibleBattlegroundsEmote.DbfRecord;
-		}
+			{
+				battlegroundsEmoteDbfRecord = collectibleBattlegroundsEmote.DbfRecord;
+			}
 		if (battlegroundsEmoteDbfRecord == null)
 		{
 			return -1;
@@ -102,4 +102,12 @@ public class CollectibleBattlegroundsEmote : ICollectible, IComparable
 		}
 		return battlegroundsEmoteDataModel;
 	}
+
+	#region Accessibility
+	public bool IsAccessible()
+	{
+		// TODO
+		return false;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/CollectibleBattlegroundsFinisher.cs b/Assembly-CSharp/CollectibleBattlegroundsFinisher.cs
index ffbd4d7..e43079c 100644
--- a/Assembly-CSharp/CollectibleBattlegroundsFinisher.cs
+++ b/Assembly-CSharp/CollectibleBattlegroundsFinisher.cs
@@ -49,9 +49,9 @@ public class CollectibleBattlegroundsFinisher : ICollectible, IComparable
 		}
 		BattlegroundsFinisherDbfRecord battlegroundsFinisherDbfRecord = obj as BattlegroundsFinisherDbfRecord;
 		if (battlegroundsFinisherDbfRecord == null && obj is CollectibleBattlegroundsFinisher collectibleBattlegroundsFinisher)
-		{
-			battlegroundsFinisherDbfRecord = collectibleBattlegroundsFinisher.DbfRecord;
-		}
+			{
+				battlegroundsFinisherDbfRecord = collectibleBattlegroundsFinisher.DbfRecord;
+			}
 		if (battlegroundsFinisherDbfRecord == null)
 		{
 			return -1;
@@ -108,4 +108,12 @@ public class CollectibleBattlegroundsFinisher : ICollectible, IComparable
 		}
 		return battlegroundsFinisherDataModel;
 	}
+
+	#region Accessibility
+	public bool IsAccessible()
+	{
+		// TODO
+		return false;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/CollectibleCard.cs b/Assembly-CSharp/CollectibleCard.cs
index 8149820..ad659c9 100644
--- a/Assembly-CSharp/CollectibleCard.cs
+++ b/Assembly-CSharp/CollectibleCard.cs
@@ -356,4 +356,11 @@ public class CollectibleCard : ICollectible, IComparable
 	{
 		return m_EntityDef.GetTag(tag) > 0;
 	}
+
+	#region Accessibility
+	public bool IsAccessible()
+	{
+		return true;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/CollectibleDisplay.cs b/Assembly-CSharp/CollectibleDisplay.cs
index 6dcddc6..defe321 100644
--- a/Assembly-CSharp/CollectibleDisplay.cs
+++ b/Assembly-CSharp/CollectibleDisplay.cs
@@ -6,6 +6,7 @@ using Blizzard.T5.Services;
 using PegasusShared;
 using UnityEngine;
 using UnityEngine.Serialization;
+using Accessibility;
 
 public abstract class CollectibleDisplay : AbsSceneDisplay
 {
@@ -96,7 +97,7 @@ public abstract class CollectibleDisplay : AbsSceneDisplay
 
 	protected CraftingTrayBase m_craftingTray;
 
-	protected SetFilterTray m_setFilterTray;
+	internal SetFilterTray m_setFilterTray;
 
 	protected RelatedCardsTray m_relatedCardsTray;
 
@@ -159,6 +160,8 @@ public abstract class CollectibleDisplay : AbsSceneDisplay
 		}
 		LoadAllTextures();
 		EnableInput(enable: true);
+
+		AccessibleCollectionManager.Get().OnCollectionManagerOpened();
 	}
 
 	protected virtual void OnDestroy()
@@ -167,6 +170,8 @@ public abstract class CollectibleDisplay : AbsSceneDisplay
 		{
 			CollectionManager.Get().SetCollectibleDisplay(null);
 		}
+
+		AccessibleCollectionManager.Get().OnCollectionManagerClosed();
 	}
 
 	public Material GetGoldenCardNotOwnedMeshMaterial()
@@ -227,7 +232,11 @@ public abstract class CollectibleDisplay : AbsSceneDisplay
 
 	public void SetViewMode(CollectionUtils.ViewMode mode, CollectionUtils.ViewModeData userdata = null)
 	{
+		var modeBeforeSet = m_currentViewMode;
+
 		SetViewMode(mode, triggerResponse: true, userdata);
+
+		AccessibleCollectionManager.Get().OnChangeViewMode(modeBeforeSet, mode);
 	}
 
 	public CollectionUtils.ViewMode GetViewMode()
diff --git a/Assembly-CSharp/CollectiblePageManager.cs b/Assembly-CSharp/CollectiblePageManager.cs
index 405ce09..6289055 100644
--- a/Assembly-CSharp/CollectiblePageManager.cs
+++ b/Assembly-CSharp/CollectiblePageManager.cs
@@ -341,4 +341,11 @@ public abstract class CollectiblePageManager : TabbedBookPageManager
 	protected abstract void AssembleEmptyPageUI(CollectiblePageDisplay page, bool displayNoMatchesText);
 
 	protected abstract void OnCollectionManagerViewModeChanged(CollectionUtils.ViewMode prevMode, CollectionUtils.ViewMode mode, CollectionUtils.ViewModeData userdata, bool triggerResponse);
+
+	#region Accessibility
+	internal CollectionPageDisplay GetCollectionPageDisplay()
+	{
+		return GetCurrentCollectiblePage() as CollectionPageDisplay;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/CollectionDeck.cs b/Assembly-CSharp/CollectionDeck.cs
index 22a64d8..dc188c6 100644
--- a/Assembly-CSharp/CollectionDeck.cs
+++ b/Assembly-CSharp/CollectionDeck.cs
@@ -7,197 +7,197 @@ using UnityEngine;
 
 public class CollectionDeck
 {
-	public enum SlotStatus
-	{
-		UNKNOWN,
-		VALID,
-		NOT_VALID,
-		MISSING
-	}
-
-	public enum ChangeSource
-	{
-		Unknown,
-		ClickToFixMissingAndInvalidCards,
-		MarkDeckAsSeen,
-		PocoSetDeckName,
-		OnScenePreUnload,
-		SaveCurrentDeck,
-		NavigateToSceneForPartyChallenge,
-		StartChallengeProcess,
-		StopDragToReorder,
-		ReconcileCardOwnership,
-		ClickToFixExtraCards,
-		Cheat
-	}
-
-	public class CardCountByStatus
-	{
+    public enum SlotStatus
+    {
+        UNKNOWN,
+        VALID,
+        NOT_VALID,
+        MISSING
+    }
+
+    public enum ChangeSource
+    {
+        Unknown,
+        ClickToFixMissingAndInvalidCards,
+        MarkDeckAsSeen,
+        PocoSetDeckName,
+        OnScenePreUnload,
+        SaveCurrentDeck,
+        NavigateToSceneForPartyChallenge,
+        StartChallengeProcess,
+        StopDragToReorder,
+        ReconcileCardOwnership,
+        ClickToFixExtraCards,
+        Cheat
+    }
+
+    public class CardCountByStatus
+    {
 		public int Min;
 
-		public int Max;
+        public int Max;
 
-		public int Total;
+        public int Total;
 
-		public int Valid;
+        public int Valid;
 
-		public int Invalid;
+        public int Invalid;
 
-		public int Missing;
+        public int Missing;
 
-		public int MissingPlusInvalid;
+        public int MissingPlusInvalid;
 
-		public int Extra;
-	}
+        public int Extra;
+    }
 
-	public static int DefaultMaxDeckNameCharacters = 24;
+    public static int DefaultMaxDeckNameCharacters = 24;
 
-	public static List<DeckRule.RuleType> DefaultIgnoreRules = new List<DeckRule.RuleType>
-	{
-		DeckRule.RuleType.PLAYER_OWNS_EACH_COPY,
-		DeckRule.RuleType.IS_CARD_PLAYABLE,
-		DeckRule.RuleType.HAS_TAG_VALUE
-	};
+    public static List<DeckRule.RuleType> DefaultIgnoreRules = new List<DeckRule.RuleType>
+    {
+        DeckRule.RuleType.PLAYER_OWNS_EACH_COPY,
+        DeckRule.RuleType.IS_CARD_PLAYABLE,
+        DeckRule.RuleType.HAS_TAG_VALUE
+    };
 
-	private int m_changeNumber;
+    private int m_changeNumber;
 
-	private string m_name;
+    private string m_name;
 
-	private List<CollectionDeckSlot> m_slots = new List<CollectionDeckSlot>();
+    private List<CollectionDeckSlot> m_slots = new List<CollectionDeckSlot>();
 
-	private bool m_netContentsLoaded;
+    private bool m_netContentsLoaded;
 
-	private bool m_isSavingContentChanges;
+    private bool m_isSavingContentChanges;
 
-	private bool m_isSavingNameChanges;
+    private bool m_isSavingNameChanges;
 
-	private bool m_isBeingDeleted;
+    private bool m_isBeingDeleted;
 
-	private string m_randomHeroCardId = "None";
+    private string m_randomHeroCardId = "None";
 
-	private string m_currentDisplayHeroCardId = "None";
+    private string m_currentDisplayHeroCardId = "None";
 
-	private ShareableDeck m_createdFromShareableDeck;
+    private ShareableDeck m_createdFromShareableDeck;
 
 	private readonly SideboardManager m_sideboardManager;
 
-	public long ID;
+    public long ID;
 
-	public bool IsLoanerDeck;
+    public bool IsLoanerDeck;
 
-	public bool HeroOverridden;
+    public bool HeroOverridden;
 
-	public bool RandomHeroUseFavorite = true;
+    public bool RandomHeroUseFavorite = true;
 
-	public int? CardBackID;
+    public int? CardBackID;
 
 	public int? CosmeticCoinID;
 
 	public bool RandomCoinUseFavorite = true;
 
-	public int SeasonId;
+    public int SeasonId;
 
-	public int BrawlLibraryItemId;
+    public int BrawlLibraryItemId;
 
 	private ChangeSource m_pendingChangeSource;
 
-	public bool NeedsName;
+    public bool NeedsName;
 
-	public long SortOrder;
+    public long SortOrder;
 
-	public ulong CreateDate;
+    public ulong CreateDate;
 
-	public bool Locked;
+    public bool Locked;
 
-	public DeckSourceType SourceType;
+    public DeckSourceType SourceType;
 
-	public string HeroPowerCardID = string.Empty;
+    public string HeroPowerCardID = string.Empty;
 
-	public string UIHeroOverrideCardID = string.Empty;
+    public string UIHeroOverrideCardID = string.Empty;
 
-	public TAG_PREMIUM UIHeroOverridePremium;
+    public TAG_PREMIUM UIHeroOverridePremium;
 
-	public int DeckTemplateId;
+    public int DeckTemplateId;
 
-	private readonly RuneType[] m_runeOrder = new RuneType[DeckRule_DeathKnightRuneLimit.MaxRuneSlots];
+    private readonly RuneType[] m_runeOrder = new RuneType[DeckRule_DeathKnightRuneLimit.MaxRuneSlots];
 
 	public virtual DeckType Type { get; set; } = DeckType.NORMAL_DECK;
 
 
-	public string Name
-	{
-		get
-		{
-			return m_name;
-		}
-		set
-		{
-			if (value == null)
-			{
-				Debug.LogError($"CollectionDeck.SetName() - null name given for deck {this}");
-			}
-			else if (!value.Equals(m_name, StringComparison.InvariantCultureIgnoreCase))
-			{
-				m_name = value;
-			}
-		}
-	}
+    public string Name
+    {
+        get
+        {
+            return m_name;
+        }
+        set
+        {
+            if (value == null)
+            {
+                Debug.LogError($"CollectionDeck.SetName() - null name given for deck {this}");
+            }
+            else if (!value.Equals(m_name, StringComparison.InvariantCultureIgnoreCase))
+            {
+                m_name = value;
+            }
+        }
+    }
 
 	public virtual string HeroCardID { get; set; } = string.Empty;
 
 
-	public RunePattern Runes { get; private set; }
+    public RunePattern Runes { get; private set; }
 
 	public virtual FormatType FormatType { get; set; }
 
-	public bool IsShared { get; set; }
+    public bool IsShared { get; set; }
 
-	public bool IsCreatedWithDeckComplete { get; set; }
+    public bool IsCreatedWithDeckComplete { get; set; }
 
-	public bool IsBrawlDeck => TavernBrawlManager.IsBrawlDeckType(Type);
+    public bool IsBrawlDeck => TavernBrawlManager.IsBrawlDeckType(Type);
 
-	public bool IsDuelsDeck
-	{
-		get
-		{
-			if (Type != DeckType.PVPDR_DECK)
-			{
-				return Type == DeckType.PVPDR_DISPLAY_DECK;
-			}
-			return true;
-		}
-	}
+    public bool IsDuelsDeck
+    {
+        get
+        {
+            if (Type != DeckType.PVPDR_DECK)
+            {
+                return Type == DeckType.PVPDR_DISPLAY_DECK;
+            }
+            return true;
+        }
+    }
 
-	public bool IsConstructedDeck => Type == DeckType.NORMAL_DECK;
+    public bool IsConstructedDeck => Type == DeckType.NORMAL_DECK;
 
 	public bool IsTwistDeck => FormatType == FormatType.FT_TWIST;
 
-	public bool IsValidForRuleset
-	{
-		get
-		{
-			if (IsShared)
-			{
-				return true;
-			}
-			if (!m_netContentsLoaded && Type != DeckType.CLIENT_ONLY_DECK && Type != DeckType.PVPDR_DISPLAY_DECK && !IsLoanerDeck)
-			{
-				return false;
-			}
-			DeckRuleset ruleset = GetRuleset();
-			if (ruleset != null)
-			{
-				if (IsLoanerDeck)
-				{
-					return ruleset.IsDeckValid(this, DeckRule.RuleType.PLAYER_OWNS_EACH_COPY);
-				}
-				return ruleset.IsDeckValid(this);
-			}
-			return false;
-		}
-	}
-
-	public ShareableDeck CreatedFromShareableDeck => m_createdFromShareableDeck;
+    public bool IsValidForRuleset
+    {
+        get
+        {
+            if (IsShared)
+            {
+                return true;
+            }
+            if (!m_netContentsLoaded && Type != DeckType.CLIENT_ONLY_DECK && Type != DeckType.PVPDR_DISPLAY_DECK && !IsLoanerDeck)
+            {
+                return false;
+            }
+            DeckRuleset ruleset = GetRuleset();
+            if (ruleset != null)
+            {
+                if (IsLoanerDeck)
+                {
+                    return ruleset.IsDeckValid(this, DeckRule.RuleType.PLAYER_OWNS_EACH_COPY);
+                }
+                return ruleset.IsDeckValid(this);
+            }
+            return false;
+        }
+    }
+
+    public ShareableDeck CreatedFromShareableDeck => m_createdFromShareableDeck;
 
 	public bool HasSideboardCards => m_sideboardManager.HasSideboardCards();
 
@@ -206,130 +206,130 @@ public class CollectionDeck
 		m_sideboardManager = new SideboardManager(this);
 	}
 
-	public override string ToString()
-	{
-		return $"Deck [id={ID} name=\"{Name}\" heroCardId={HeroCardID} cardBackId={CardBackID} " + $"heroOverridden={HeroOverridden} slotCount={GetSlotCount()} needsName={NeedsName} sortOrder={SortOrder}]";
-	}
-
-	public void SetRuneAtIndex(int index, RuneType runeType)
-	{
-		if (index < 0 || index >= m_runeOrder.Length)
-		{
-			Debug.LogWarning($"CollectionDeck: SetRuneAtIndex: index {index} is out of range of {m_runeOrder.Length}");
-			return;
-		}
-		m_runeOrder[index] = runeType;
-		Runes = new RunePattern(m_runeOrder);
+    public override string ToString()
+    {
+        return $"Deck [id={ID} name=\"{Name}\" heroCardId={HeroCardID} cardBackId={CardBackID} " + $"heroOverridden={HeroOverridden} slotCount={GetSlotCount()} needsName={NeedsName} sortOrder={SortOrder}]";
+    }
+
+    public void SetRuneAtIndex(int index, RuneType runeType)
+    {
+        if (index < 0 || index >= m_runeOrder.Length)
+        {
+            Debug.LogWarning($"CollectionDeck: SetRuneAtIndex: index {index} is out of range of {m_runeOrder.Length}");
+            return;
+        }
+        m_runeOrder[index] = runeType;
+        Runes = new RunePattern(m_runeOrder);
 		foreach (KeyValuePair<string, SideboardDeck> allSideboard in m_sideboardManager.GetAllSideboards())
 		{
 			allSideboard.Value.SetRuneAtIndex(index, runeType);
 		}
-	}
-
-	public RuneType GetRuneAtIndex(int index)
-	{
-		if (index < 0 || index >= m_runeOrder.Length)
-		{
-			Debug.LogWarning($"CollectionDeck: GetRuneAtIndex: index {index} is out of range of {m_runeOrder.Length}");
-			return RuneType.RT_NONE;
-		}
-		return m_runeOrder[index];
-	}
-
-	public RuneType[] GetRuneOrder()
-	{
-		RuneType[] array = new RuneType[m_runeOrder.Length];
-		for (int i = 0; i < m_runeOrder.Length; i++)
-		{
-			array[i] = m_runeOrder[i];
-		}
-		return array;
-	}
-
-	public bool IsRuneOrderEqual(RuneType[] otherRuneOrder)
-	{
-		if (otherRuneOrder == null)
-		{
-			Debug.LogError("IsRuneOrderEqual() - other rune order is null.");
-			return false;
-		}
-		int maxRuneSlots = DeckRule_DeathKnightRuneLimit.MaxRuneSlots;
-		if (m_runeOrder.Length != otherRuneOrder.Length)
-		{
-			Debug.LogError("IsRuneOrderEqual() - rune orders are not the same length.");
-			return false;
-		}
-		if (otherRuneOrder.Length < maxRuneSlots || m_runeOrder.Length < maxRuneSlots)
-		{
-			Debug.LogError("IsRuneOrderEqual() - rune order is less than MaxRuneSlots size");
-			return false;
-		}
-		for (int i = 0; i < maxRuneSlots; i++)
-		{
-			if (m_runeOrder[i] != otherRuneOrder[i])
-			{
-				return false;
-			}
-		}
-		return true;
-	}
-
-	public void SetRuneOrder(params RuneType[] runeTypes)
-	{
-		if (runeTypes == null)
-		{
-			Debug.LogError("SetRuneOrder() - rune types is null.");
-			return;
-		}
-		int num = Math.Min(m_runeOrder.Length, runeTypes.Length);
-		for (int i = 0; i < num; i++)
-		{
-			m_runeOrder[i] = runeTypes[i];
-		}
-		Runes = new RunePattern(m_runeOrder);
-	}
-
-	public void ClearRuneOrder()
-	{
-		SetRuneOrder(default(RuneType), default(RuneType), default(RuneType));
-	}
-
-	public bool HasUIHeroOverride()
-	{
-		return !string.IsNullOrEmpty(UIHeroOverrideCardID);
-	}
-
-	public string GetDisplayHeroCardID(bool rerollFavoriteHero)
-	{
-		if (HasUIHeroOverride())
-		{
-			m_currentDisplayHeroCardId = UIHeroOverrideCardID;
-		}
-		else if (HeroOverridden || IsDuelsDeck)
-		{
-			m_currentDisplayHeroCardId = HeroCardID;
-		}
-		else if (rerollFavoriteHero || m_randomHeroCardId == "None")
-		{
-			int value = GameUtils.TranslateCardIdToDbId(m_currentDisplayHeroCardId);
-			int randomHeroIdOwnedByPlayer = CollectionManager.Get().GetRandomHeroIdOwnedByPlayer(GetClass(), RandomHeroUseFavorite, value);
-			if (randomHeroIdOwnedByPlayer > 0)
-			{
-				m_randomHeroCardId = GameUtils.TranslateDbIdToCardId(randomHeroIdOwnedByPlayer);
-			}
-			m_currentDisplayHeroCardId = m_randomHeroCardId;
-		}
-		return m_currentDisplayHeroCardId;
-	}
-
-	public TAG_PREMIUM? GetDisplayHeroPremiumOverride()
-	{
-		if (HasUIHeroOverride())
-		{
-			return UIHeroOverridePremium;
-		}
-		return null;
-	}
+    }
+
+    public RuneType GetRuneAtIndex(int index)
+    {
+        if (index < 0 || index >= m_runeOrder.Length)
+        {
+            Debug.LogWarning($"CollectionDeck: GetRuneAtIndex: index {index} is out of range of {m_runeOrder.Length}");
+            return RuneType.RT_NONE;
+        }
+        return m_runeOrder[index];
+    }
+
+    public RuneType[] GetRuneOrder()
+    {
+        RuneType[] array = new RuneType[m_runeOrder.Length];
+        for (int i = 0; i < m_runeOrder.Length; i++)
+        {
+            array[i] = m_runeOrder[i];
+        }
+        return array;
+    }
+
+    public bool IsRuneOrderEqual(RuneType[] otherRuneOrder)
+    {
+        if (otherRuneOrder == null)
+        {
+            Debug.LogError("IsRuneOrderEqual() - other rune order is null.");
+            return false;
+        }
+        int maxRuneSlots = DeckRule_DeathKnightRuneLimit.MaxRuneSlots;
+        if (m_runeOrder.Length != otherRuneOrder.Length)
+        {
+            Debug.LogError("IsRuneOrderEqual() - rune orders are not the same length.");
+            return false;
+        }
+        if (otherRuneOrder.Length < maxRuneSlots || m_runeOrder.Length < maxRuneSlots)
+        {
+            Debug.LogError("IsRuneOrderEqual() - rune order is less than MaxRuneSlots size");
+            return false;
+        }
+        for (int i = 0; i < maxRuneSlots; i++)
+        {
+            if (m_runeOrder[i] != otherRuneOrder[i])
+            {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public void SetRuneOrder(params RuneType[] runeTypes)
+    {
+        if (runeTypes == null)
+        {
+            Debug.LogError("SetRuneOrder() - rune types is null.");
+            return;
+        }
+        int num = Math.Min(m_runeOrder.Length, runeTypes.Length);
+        for (int i = 0; i < num; i++)
+        {
+            m_runeOrder[i] = runeTypes[i];
+        }
+        Runes = new RunePattern(m_runeOrder);
+    }
+
+    public void ClearRuneOrder()
+    {
+        SetRuneOrder(default(RuneType), default(RuneType), default(RuneType));
+    }
+
+    public bool HasUIHeroOverride()
+    {
+        return !string.IsNullOrEmpty(UIHeroOverrideCardID);
+    }
+
+    public string GetDisplayHeroCardID(bool rerollFavoriteHero)
+    {
+        if (HasUIHeroOverride())
+        {
+            m_currentDisplayHeroCardId = UIHeroOverrideCardID;
+        }
+        else if (HeroOverridden || IsDuelsDeck)
+        {
+            m_currentDisplayHeroCardId = HeroCardID;
+        }
+        else if (rerollFavoriteHero || m_randomHeroCardId == "None")
+        {
+            int value = GameUtils.TranslateCardIdToDbId(m_currentDisplayHeroCardId);
+            int randomHeroIdOwnedByPlayer = CollectionManager.Get().GetRandomHeroIdOwnedByPlayer(GetClass(), RandomHeroUseFavorite, value);
+            if (randomHeroIdOwnedByPlayer > 0)
+            {
+                m_randomHeroCardId = GameUtils.TranslateDbIdToCardId(randomHeroIdOwnedByPlayer);
+            }
+            m_currentDisplayHeroCardId = m_randomHeroCardId;
+        }
+        return m_currentDisplayHeroCardId;
+    }
+
+    public TAG_PREMIUM? GetDisplayHeroPremiumOverride()
+    {
+        if (HasUIHeroOverride())
+        {
+            return UIHeroOverridePremium;
+        }
+        return null;
+    }
 
 	public List<int> GetCards()
 	{
@@ -346,97 +346,97 @@ public class CollectionDeck
 		return list;
 	}
 
-	public List<string> GetCardsWithCardID()
-	{
-		List<string> list = new List<string>();
-		for (int i = 0; i < m_slots.Count; i++)
-		{
-			for (int j = 0; j < m_slots[i].Count; j++)
-			{
-				list.Add(m_slots[i].CardID);
-			}
-		}
-		return list;
-	}
-
-	public List<CardWithPremiumStatus> GetCardsWithPremiumStatus()
-	{
-		List<CardWithPremiumStatus> list = new List<CardWithPremiumStatus>();
-		for (int i = 0; i < m_slots.Count; i++)
-		{
-			long id = GameUtils.TranslateCardIdToDbId(m_slots[i].CardID);
-			int count = m_slots[i].GetCount(TAG_PREMIUM.DIAMOND);
-			int count2 = m_slots[i].GetCount(TAG_PREMIUM.SIGNATURE);
-			int count3 = m_slots[i].GetCount(TAG_PREMIUM.GOLDEN);
-			int count4 = m_slots[i].GetCount(TAG_PREMIUM.NORMAL);
-			for (int j = 0; j < count; j++)
-			{
-				CardWithPremiumStatus item = new CardWithPremiumStatus(id, TAG_PREMIUM.DIAMOND);
-				list.Add(item);
-			}
-			for (int k = 0; k < count2; k++)
-			{
-				CardWithPremiumStatus item2 = new CardWithPremiumStatus(id, TAG_PREMIUM.SIGNATURE);
-				list.Add(item2);
-			}
-			for (int l = 0; l < count3; l++)
-			{
-				CardWithPremiumStatus item3 = new CardWithPremiumStatus(id, TAG_PREMIUM.GOLDEN);
-				list.Add(item3);
-			}
-			for (int m = 0; m < count4; m++)
-			{
-				CardWithPremiumStatus item4 = new CardWithPremiumStatus(id, TAG_PREMIUM.NORMAL);
-				list.Add(item4);
-			}
-		}
-		return list;
-	}
-
-	public void MarkNetworkContentsLoaded()
-	{
-		m_netContentsLoaded = true;
-	}
-
-	public bool NetworkContentsLoaded()
-	{
-		return m_netContentsLoaded;
-	}
-
-	public void MarkBeingDeleted()
-	{
-		m_isBeingDeleted = true;
-	}
-
-	public bool IsBeingDeleted()
-	{
-		return m_isBeingDeleted;
-	}
-
-	public bool IsSavingChanges()
-	{
-		if (!m_isSavingNameChanges)
-		{
-			return m_isSavingContentChanges;
-		}
-		return true;
-	}
-
-	public bool IsBeingEdited()
-	{
-		return this == CollectionManager.Get().GetEditedDeck();
-	}
-
-	public int GetMaxCardCount()
-	{
+    public List<string> GetCardsWithCardID()
+    {
+        List<string> list = new List<string>();
+        for (int i = 0; i < m_slots.Count; i++)
+        {
+            for (int j = 0; j < m_slots[i].Count; j++)
+            {
+                list.Add(m_slots[i].CardID);
+            }
+        }
+        return list;
+    }
+
+    public List<CardWithPremiumStatus> GetCardsWithPremiumStatus()
+    {
+        List<CardWithPremiumStatus> list = new List<CardWithPremiumStatus>();
+        for (int i = 0; i < m_slots.Count; i++)
+        {
+            long id = GameUtils.TranslateCardIdToDbId(m_slots[i].CardID);
+            int count = m_slots[i].GetCount(TAG_PREMIUM.DIAMOND);
+            int count2 = m_slots[i].GetCount(TAG_PREMIUM.SIGNATURE);
+            int count3 = m_slots[i].GetCount(TAG_PREMIUM.GOLDEN);
+            int count4 = m_slots[i].GetCount(TAG_PREMIUM.NORMAL);
+            for (int j = 0; j < count; j++)
+            {
+                CardWithPremiumStatus item = new CardWithPremiumStatus(id, TAG_PREMIUM.DIAMOND);
+                list.Add(item);
+            }
+            for (int k = 0; k < count2; k++)
+            {
+                CardWithPremiumStatus item2 = new CardWithPremiumStatus(id, TAG_PREMIUM.SIGNATURE);
+                list.Add(item2);
+            }
+            for (int l = 0; l < count3; l++)
+            {
+                CardWithPremiumStatus item3 = new CardWithPremiumStatus(id, TAG_PREMIUM.GOLDEN);
+                list.Add(item3);
+            }
+            for (int m = 0; m < count4; m++)
+            {
+                CardWithPremiumStatus item4 = new CardWithPremiumStatus(id, TAG_PREMIUM.NORMAL);
+                list.Add(item4);
+            }
+        }
+        return list;
+    }
+
+    public void MarkNetworkContentsLoaded()
+    {
+        m_netContentsLoaded = true;
+    }
+
+    public bool NetworkContentsLoaded()
+    {
+        return m_netContentsLoaded;
+    }
+
+    public void MarkBeingDeleted()
+    {
+        m_isBeingDeleted = true;
+    }
+
+    public bool IsBeingDeleted()
+    {
+        return m_isBeingDeleted;
+    }
+
+    public bool IsSavingChanges()
+    {
+        if (!m_isSavingNameChanges)
+        {
+            return m_isSavingContentChanges;
+        }
+        return true;
+    }
+
+    public bool IsBeingEdited()
+    {
+        return this == CollectionManager.Get().GetEditedDeck();
+    }
+
+    public int GetMaxCardCount()
+    {
 		DeckRuleset ruleset = GetRuleset();
 		if (ruleset != null)
-		{
+        {
 			return ruleset.GetDeckSize(this);
-		}
-		Debug.LogError("GetMaxCardCount() - unable to get correct count, ruleset was unavailable");
-		return 0;
-	}
+        }
+        Debug.LogError("GetMaxCardCount() - unable to get correct count, ruleset was unavailable");
+        return 0;
+    }
 
 	public bool GetCardCountRange(out int min, out int max)
 	{
@@ -453,68 +453,68 @@ public class CollectionDeck
 		return false;
 	}
 
-	public int GetTotalCardCount()
-	{
-		int num = 0;
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			num += slot.Count;
-		}
-		return num;
-	}
-
-	public CardCountByStatus CountCardsByStatus(FormatType? formatTypeToValidateAgainst = null)
-	{
-		CardCountByStatus cardCountByStatus = new CardCountByStatus();
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			cardCountByStatus.Total += slot.Count;
-			if (IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true, formatTypeToValidateAgainst))
-			{
-				cardCountByStatus.Valid += slot.Count;
-			}
-			else
-			{
-				cardCountByStatus.Invalid += slot.Count;
-			}
-		}
+    public int GetTotalCardCount()
+    {
+        int num = 0;
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            num += slot.Count;
+        }
+        return num;
+    }
+
+    public CardCountByStatus CountCardsByStatus(FormatType? formatTypeToValidateAgainst = null)
+    {
+        CardCountByStatus cardCountByStatus = new CardCountByStatus();
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            cardCountByStatus.Total += slot.Count;
+            if (IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true, formatTypeToValidateAgainst))
+            {
+                cardCountByStatus.Valid += slot.Count;
+            }
+            else
+            {
+                cardCountByStatus.Invalid += slot.Count;
+            }
+        }
 		GetCardCountRange(out cardCountByStatus.Min, out cardCountByStatus.Max);
-		cardCountByStatus.Max = GetMaxCardCount();
+        cardCountByStatus.Max = GetMaxCardCount();
 		cardCountByStatus.Missing = Mathf.Max(0, cardCountByStatus.Min - cardCountByStatus.Total);
-		cardCountByStatus.Extra = Mathf.Max(0, cardCountByStatus.Total - cardCountByStatus.Max);
-		cardCountByStatus.MissingPlusInvalid = cardCountByStatus.Missing + cardCountByStatus.Invalid;
-		return cardCountByStatus;
-	}
-
-	public int GetTotalValidCardCount(FormatType? formatTypeToValidateAgainst = null)
-	{
-		int num = 0;
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			if (IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true, formatTypeToValidateAgainst))
-			{
-				num += slot.Count;
-			}
-		}
-		return num;
-	}
+        cardCountByStatus.Extra = Mathf.Max(0, cardCountByStatus.Total - cardCountByStatus.Max);
+        cardCountByStatus.MissingPlusInvalid = cardCountByStatus.Missing + cardCountByStatus.Invalid;
+        return cardCountByStatus;
+    }
+
+    public int GetTotalValidCardCount(FormatType? formatTypeToValidateAgainst = null)
+    {
+        int num = 0;
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            if (IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true, formatTypeToValidateAgainst))
+            {
+                num += slot.Count;
+            }
+        }
+        return num;
+    }
 
 	public virtual int GetTotalInvalidCardCount(FormatType? formatTypeToValidateAgainst = null, bool includeInvalidRuneCards = false)
-	{
-		int num = 0;
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			if (!IsValidSlot(slot, IsLoanerDeck, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true, formatTypeToValidateAgainst))
-			{
-				num += slot.Count;
-			}
-		}
+    {
+        int num = 0;
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            if (!IsValidSlot(slot, IsLoanerDeck, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true, formatTypeToValidateAgainst))
+            {
+                num += slot.Count;
+            }
+        }
 		if (includeInvalidRuneCards)
 		{
 			num += GetTotalInvalidRuneCardCount();
 		}
-		return num;
-	}
+        return num;
+    }
 
 	public int GetTotalInvalidRuneCardCount()
 	{
@@ -560,10 +560,10 @@ public class CollectionDeck
 		return num;
 	}
 
-	public List<CollectionDeckSlot> GetSlots()
-	{
-		return m_slots;
-	}
+    public List<CollectionDeckSlot> GetSlots()
+    {
+        return m_slots;
+    }
 
 	public int GetTotalDeckSizeIncludingSideboards()
 	{
@@ -588,10 +588,10 @@ public class CollectionDeck
 		return num + num2;
 	}
 
-	public int GetSlotCount()
-	{
-		return m_slots.Count;
-	}
+    public int GetSlotCount()
+    {
+        return m_slots.Count;
+    }
 
 	public int GetNumberOfCardsWithSideboards()
 	{
@@ -599,384 +599,384 @@ public class CollectionDeck
 	}
 
 	public virtual bool IsValidSlot(CollectionDeckSlot slot, bool ignoreOwnership = false, bool ignoreGameplayEvent = false, bool enforceRemainingDeckRuleset = false, FormatType? formatTypeToValidateAgainst = null)
-	{
+    {
 		EntityDef entityDef = slot.GetEntityDef();
 		return IsEntityDefValid(entityDef, slot, ignoreOwnership, ignoreGameplayEvent, enforceRemainingDeckRuleset, formatTypeToValidateAgainst);
 	}
 
 	public bool IsEntityDefValid(EntityDef entityDef, CollectionDeckSlot slot = null, bool ignoreOwnership = false, bool ignoreGameplayEvent = false, bool enforceRemainingDeckRuleset = false, FormatType? formatTypeToValidateAgainst = null)
 	{
-		if (Locked)
-		{
-			return true;
-		}
-		FormatType formatType = formatTypeToValidateAgainst ?? FormatType;
+        if (Locked)
+        {
+            return true;
+        }
+        FormatType formatType = formatTypeToValidateAgainst ?? FormatType;
 		if (formatType != FormatType.FT_WILD && formatType != FormatType.FT_TWIST && GameUtils.IsWildCard(entityDef.GetCardId()))
-		{
-			return false;
-		}
+        {
+            return false;
+        }
 		if (FormatType == FormatType.FT_TWIST && !RankMgr.IsCurrentTwistSeasonActive())
 		{
 			return false;
 		}
-		if (GetRuleset() == null)
-		{
-			Debug.LogError("IsValidSlot() - Unable to find ruleset");
-			return false;
-		}
+        if (GetRuleset() == null)
+        {
+            Debug.LogError("IsValidSlot() - Unable to find ruleset");
+            return false;
+        }
 		if (GetRuleset().HasIsPlayableRule() && !ignoreGameplayEvent && !GameUtils.IsCardGameplayEventActive(entityDef.GetCardId()))
-		{
-			return false;
-		}
+        {
+            return false;
+        }
 		if (DuelsConfig.IsCardLoadoutTreasure(entityDef.GetCardId()))
-		{
-			return true;
-		}
+        {
+            return true;
+        }
 		if (slot != null && !ignoreOwnership && !slot.Owned)
+        {
+            return false;
+        }
+        if (formatType != 0 && GameUtils.IsBanned(this, entityDef))
+        {
+            return false;
+        }
+        if (enforceRemainingDeckRuleset && entityDef != null)
+        {
+            List<DeckRule.RuleType> list = new List<DeckRule.RuleType>();
+            if (ignoreOwnership)
+            {
+                list.Add(DeckRule.RuleType.PLAYER_OWNS_EACH_COPY);
+            }
+            if (ignoreGameplayEvent)
+            {
+                list.Add(DeckRule.RuleType.IS_CARD_PLAYABLE);
+            }
+            if (SceneMgr.Get().IsInDuelsMode() && !PvPDungeonRunScene.IsEditingDeck())
+            {
+                list.Add(DeckRule.RuleType.DEATHKNIGHT_RUNE_LIMIT);
+            }
+            if (!GetRuleset(formatTypeToValidateAgainst).Filter(entityDef, this, (list.Count == 0) ? null : list.ToArray()))
+            {
+                return false;
+            }
+        }
+        return true;
+    }
+
+	public virtual SlotStatus GetSlotStatus(CollectionDeckSlot slot)
+    {
+        if (slot == null)
+        {
+            return SlotStatus.UNKNOWN;
+        }
+        if (ShouldSplitSlotsByOwnershipOrFormatValidity() && !DuelsConfig.IsCardLoadoutTreasure(slot.CardID))
+        {
+            if (!GameUtils.IsCardCollectible(slot.CardID))
+            {
+                return SlotStatus.NOT_VALID;
+            }
+			if (!GameUtils.IsCardGameplayEventEverActive(slot.CardID))
+			{
+				return SlotStatus.NOT_VALID;
+			}
+            if (!slot.Owned)
+            {
+                return SlotStatus.MISSING;
+            }
+            if (!IsValidSlot(slot, ignoreOwnership: true, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true))
+            {
+                return SlotStatus.NOT_VALID;
+            }
+        }
+        return SlotStatus.VALID;
+    }
+
+    public bool HasReplaceableSlot()
+    {
+        for (int i = 0; i < m_slots.Count; i++)
+        {
+            if (!IsValidSlot(m_slots[i]))
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public CollectionDeckSlot GetSlotByIndex(int slotIndex)
+    {
+        if (slotIndex < 0 || slotIndex >= GetSlotCount())
+        {
+            return null;
+        }
+        return m_slots[slotIndex];
+    }
+
+    public CollectionDeckSlot GetExistingSlot(CollectionDeckSlot searchSlot)
+    {
+        if (ShouldSplitSlotsByOwnershipOrFormatValidity())
+        {
+            foreach (CollectionDeckSlot slot in m_slots)
+            {
+                if (slot.CardID == searchSlot.CardID && slot.Owned == searchSlot.Owned)
+                {
+                    return slot;
+                }
+            }
+        }
+        else
+        {
+            foreach (CollectionDeckSlot slot2 in m_slots)
+            {
+                if (slot2.CardID == searchSlot.CardID)
+                {
+                    return slot2;
+                }
+            }
+        }
+        return null;
+    }
+
+    public DeckRuleset GetRuleset(FormatType? formatTypeToValidateAgainst = null)
+    {
+        DeckRuleset deckRuleset = null;
+        switch (Type)
+        {
+            case DeckType.PVPDR_DECK:
+                deckRuleset = DeckRuleset.GetPVPDRRuleset();
+                break;
+            case DeckType.PVPDR_DISPLAY_DECK:
+                deckRuleset = DeckRuleset.GetPVPDRDisplayRuleset();
+                break;
+            case DeckType.NORMAL_DECK:
+            case DeckType.PRECON_DECK:
+                deckRuleset = DeckRuleset.GetRuleset(formatTypeToValidateAgainst.HasValue ? formatTypeToValidateAgainst.Value : FormatType);
+                break;
+            case DeckType.TAVERN_BRAWL_DECK:
+            case DeckType.FSG_BRAWL_DECK:
+                deckRuleset = TavernBrawlManager.Get().GetCurrentDeckRuleset();
+                break;
+        }
+        if (deckRuleset == null)
+        {
+            deckRuleset = DeckRuleset.GetRuleset(FormatType.FT_WILD);
+        }
+        return deckRuleset;
+    }
+
+    public bool IsValidForFormat(FormatType formatType)
+    {
+        if (formatType == FormatType.FT_WILD && FormatType == FormatType.FT_STANDARD)
+        {
+            return true;
+        }
+        return FormatType == formatType;
+    }
+
+    public static bool DoesModeRequireSpecificFormat(SceneMgr.Mode mode, bool isRanked)
+    {
+        if (mode == SceneMgr.Mode.TOURNAMENT && isRanked)
+        {
+            return true;
+        }
+		if (mode == SceneMgr.Mode.FRIENDLY)
+                {
+                    return true;
+                }
+        return false;
+    }
+
+    public bool IsValidForModeAndFormat(SceneMgr.Mode mode, bool isRanked, FormatType formatType)
+    {
+		if (!GameUtils.HasUnlockedClass(GetClass()))
+        {
+            return false;
+        }
+		bool flag = FormatType != FormatType.FT_CLASSIC && FormatType != FormatType.FT_TWIST;
+		if (mode == SceneMgr.Mode.ADVENTURE && !flag)
+            {
+                return false;
+            }
+		if (FormatType == FormatType.FT_CLASSIC && !GameUtils.CLASSIC_ORDERED_HERO_CLASSES.Contains(GetClass()))
+            {
+                return false;
+            }
+		if (FormatType == FormatType.FT_TWIST && (mode == SceneMgr.Mode.TOURNAMENT || mode == SceneMgr.Mode.FRIENDLY))
 		{
-			return false;
-		}
-		if (formatType != 0 && GameUtils.IsBanned(this, entityDef))
+			if (RankMgr.IsTwistDeckWithNoSeason(this))
 		{
 			return false;
 		}
-		if (enforceRemainingDeckRuleset && entityDef != null)
-		{
-			List<DeckRule.RuleType> list = new List<DeckRule.RuleType>();
-			if (ignoreOwnership)
-			{
-				list.Add(DeckRule.RuleType.PLAYER_OWNS_EACH_COPY);
-			}
-			if (ignoreGameplayEvent)
-			{
-				list.Add(DeckRule.RuleType.IS_CARD_PLAYABLE);
-			}
-			if (SceneMgr.Get().IsInDuelsMode() && !PvPDungeonRunScene.IsEditingDeck())
-			{
-				list.Add(DeckRule.RuleType.DEATHKNIGHT_RUNE_LIMIT);
-			}
-			if (!GetRuleset(formatTypeToValidateAgainst).Filter(entityDef, this, (list.Count == 0) ? null : list.ToArray()))
+			if (RankMgr.IsClassLockedForTwist(GetClass()))
 			{
 				return false;
 			}
 		}
-		return true;
-	}
-
-	public virtual SlotStatus GetSlotStatus(CollectionDeckSlot slot)
-	{
-		if (slot == null)
+        if (DoesModeRequireSpecificFormat(mode, isRanked) && !IsValidForFormat(formatType))
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public void CopyFrom(CollectionDeck otherDeck)
+    {
+        ID = otherDeck.ID;
+        Type = otherDeck.Type;
+        m_name = otherDeck.m_name;
+        HeroCardID = otherDeck.HeroCardID;
+        HeroOverridden = otherDeck.HeroOverridden;
+		CosmeticCoinID = otherDeck.CosmeticCoinID;
+		RandomCoinUseFavorite = otherDeck.RandomCoinUseFavorite;
+        CardBackID = otherDeck.CardBackID;
+        NeedsName = otherDeck.NeedsName;
+        SeasonId = otherDeck.SeasonId;
+        BrawlLibraryItemId = otherDeck.BrawlLibraryItemId;
+        FormatType = otherDeck.FormatType;
+        SortOrder = otherDeck.SortOrder;
+        SourceType = otherDeck.SourceType;
+        UIHeroOverrideCardID = otherDeck.UIHeroOverrideCardID;
+        UIHeroOverridePremium = otherDeck.UIHeroOverridePremium;
+        RuneType[] runeOrder = otherDeck.GetRuneOrder();
+        SetRuneOrder(runeOrder);
+        m_slots.Clear();
+        for (int i = 0; i < otherDeck.GetSlotCount(); i++)
+        {
+            CollectionDeckSlot slotByIndex = otherDeck.GetSlotByIndex(i);
+            CollectionDeckSlot collectionDeckSlot = new CollectionDeckSlot();
+            collectionDeckSlot.CopyFrom(slotByIndex);
+            m_slots.Add(collectionDeckSlot);
+        }
+		m_sideboardManager.ClearSideboards();
+		foreach (KeyValuePair<string, SideboardDeck> allSideboard in otherDeck.GetAllSideboards())
 		{
-			return SlotStatus.UNKNOWN;
+			SideboardDeck value = allSideboard.Value;
+			m_sideboardManager.CopySideboard(value);
 		}
-		if (ShouldSplitSlotsByOwnershipOrFormatValidity() && !DuelsConfig.IsCardLoadoutTreasure(slot.CardID))
-		{
-			if (!GameUtils.IsCardCollectible(slot.CardID))
-			{
-				return SlotStatus.NOT_VALID;
-			}
-			if (!GameUtils.IsCardGameplayEventEverActive(slot.CardID))
-			{
-				return SlotStatus.NOT_VALID;
-			}
-			if (!slot.Owned)
-			{
-				return SlotStatus.MISSING;
-			}
-			if (!IsValidSlot(slot, ignoreOwnership: true, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true))
-			{
-				return SlotStatus.NOT_VALID;
-			}
-		}
-		return SlotStatus.VALID;
-	}
-
-	public bool HasReplaceableSlot()
-	{
-		for (int i = 0; i < m_slots.Count; i++)
-		{
-			if (!IsValidSlot(m_slots[i]))
-			{
-				return true;
-			}
-		}
-		return false;
-	}
-
-	public CollectionDeckSlot GetSlotByIndex(int slotIndex)
-	{
-		if (slotIndex < 0 || slotIndex >= GetSlotCount())
-		{
-			return null;
-		}
-		return m_slots[slotIndex];
-	}
-
-	public CollectionDeckSlot GetExistingSlot(CollectionDeckSlot searchSlot)
-	{
-		if (ShouldSplitSlotsByOwnershipOrFormatValidity())
-		{
-			foreach (CollectionDeckSlot slot in m_slots)
-			{
-				if (slot.CardID == searchSlot.CardID && slot.Owned == searchSlot.Owned)
-				{
-					return slot;
-				}
-			}
-		}
-		else
-		{
-			foreach (CollectionDeckSlot slot2 in m_slots)
-			{
-				if (slot2.CardID == searchSlot.CardID)
-				{
-					return slot2;
-				}
-			}
-		}
-		return null;
-	}
-
-	public DeckRuleset GetRuleset(FormatType? formatTypeToValidateAgainst = null)
-	{
-		DeckRuleset deckRuleset = null;
-		switch (Type)
-		{
-		case DeckType.PVPDR_DECK:
-			deckRuleset = DeckRuleset.GetPVPDRRuleset();
-			break;
-		case DeckType.PVPDR_DISPLAY_DECK:
-			deckRuleset = DeckRuleset.GetPVPDRDisplayRuleset();
-			break;
-		case DeckType.NORMAL_DECK:
-		case DeckType.PRECON_DECK:
-			deckRuleset = DeckRuleset.GetRuleset(formatTypeToValidateAgainst.HasValue ? formatTypeToValidateAgainst.Value : FormatType);
-			break;
-		case DeckType.TAVERN_BRAWL_DECK:
-		case DeckType.FSG_BRAWL_DECK:
-			deckRuleset = TavernBrawlManager.Get().GetCurrentDeckRuleset();
-			break;
-		}
-		if (deckRuleset == null)
-		{
-			deckRuleset = DeckRuleset.GetRuleset(FormatType.FT_WILD);
-		}
-		return deckRuleset;
-	}
-
-	public bool IsValidForFormat(FormatType formatType)
-	{
-		if (formatType == FormatType.FT_WILD && FormatType == FormatType.FT_STANDARD)
-		{
-			return true;
-		}
-		return FormatType == formatType;
-	}
-
-	public static bool DoesModeRequireSpecificFormat(SceneMgr.Mode mode, bool isRanked)
-	{
-		if (mode == SceneMgr.Mode.TOURNAMENT && isRanked)
-		{
-			return true;
-		}
-		if (mode == SceneMgr.Mode.FRIENDLY)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public bool IsValidForModeAndFormat(SceneMgr.Mode mode, bool isRanked, FormatType formatType)
-	{
-		if (!GameUtils.HasUnlockedClass(GetClass()))
-		{
-			return false;
-		}
-		bool flag = FormatType != FormatType.FT_CLASSIC && FormatType != FormatType.FT_TWIST;
-		if (mode == SceneMgr.Mode.ADVENTURE && !flag)
-		{
-			return false;
-		}
-		if (FormatType == FormatType.FT_CLASSIC && !GameUtils.CLASSIC_ORDERED_HERO_CLASSES.Contains(GetClass()))
-		{
-			return false;
-		}
-		if (FormatType == FormatType.FT_TWIST && (mode == SceneMgr.Mode.TOURNAMENT || mode == SceneMgr.Mode.FRIENDLY))
-		{
-			if (RankMgr.IsTwistDeckWithNoSeason(this))
-			{
-				return false;
-			}
-			if (RankMgr.IsClassLockedForTwist(GetClass()))
-			{
-				return false;
-			}
-		}
-		if (DoesModeRequireSpecificFormat(mode, isRanked) && !IsValidForFormat(formatType))
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public void CopyFrom(CollectionDeck otherDeck)
-	{
-		ID = otherDeck.ID;
-		Type = otherDeck.Type;
-		m_name = otherDeck.m_name;
-		HeroCardID = otherDeck.HeroCardID;
-		HeroOverridden = otherDeck.HeroOverridden;
-		CosmeticCoinID = otherDeck.CosmeticCoinID;
-		RandomCoinUseFavorite = otherDeck.RandomCoinUseFavorite;
-		CardBackID = otherDeck.CardBackID;
-		NeedsName = otherDeck.NeedsName;
-		SeasonId = otherDeck.SeasonId;
-		BrawlLibraryItemId = otherDeck.BrawlLibraryItemId;
-		FormatType = otherDeck.FormatType;
-		SortOrder = otherDeck.SortOrder;
-		SourceType = otherDeck.SourceType;
-		UIHeroOverrideCardID = otherDeck.UIHeroOverrideCardID;
-		UIHeroOverridePremium = otherDeck.UIHeroOverridePremium;
-		RuneType[] runeOrder = otherDeck.GetRuneOrder();
-		SetRuneOrder(runeOrder);
-		m_slots.Clear();
-		for (int i = 0; i < otherDeck.GetSlotCount(); i++)
-		{
-			CollectionDeckSlot slotByIndex = otherDeck.GetSlotByIndex(i);
-			CollectionDeckSlot collectionDeckSlot = new CollectionDeckSlot();
-			collectionDeckSlot.CopyFrom(slotByIndex);
-			m_slots.Add(collectionDeckSlot);
-		}
-		m_sideboardManager.ClearSideboards();
-		foreach (KeyValuePair<string, SideboardDeck> allSideboard in otherDeck.GetAllSideboards())
-		{
-			SideboardDeck value = allSideboard.Value;
-			m_sideboardManager.CopySideboard(value);
-		}
-	}
-
-	public void CopyContents(CollectionDeck otherDeck)
-	{
-		HeroCardID = otherDeck.HeroCardID;
-		UIHeroOverrideCardID = otherDeck.UIHeroOverrideCardID;
-		UIHeroOverridePremium = otherDeck.UIHeroOverridePremium;
-		RuneType[] runeOrder = otherDeck.GetRuneOrder();
-		SetRuneOrder(runeOrder);
-		m_slots.Clear();
-		for (int i = 0; i < otherDeck.GetSlotCount(); i++)
-		{
-			CollectionDeckSlot slotByIndex = otherDeck.GetSlotByIndex(i);
-			foreach (TAG_PREMIUM value in Enum.GetValues(typeof(TAG_PREMIUM)))
-			{
-				for (int j = 0; j < slotByIndex.GetCount(value); j++)
-				{
-					AddCard(slotByIndex.CardID, value, false, null);
-				}
-			}
-		}
-	}
-
-	public bool FillFromShareableDeck(ShareableDeck shareableDeck)
-	{
-		HeroCardID = GameUtils.TranslateDbIdToCardId(shareableDeck.HeroCardDbId);
-		FormatType = shareableDeck.FormatType;
-		bool result = true;
-		m_slots.Clear();
-		for (int i = 0; i < shareableDeck.DeckContents.Cards.Count; i++)
-		{
-			string cardID = GameUtils.TranslateDbIdToCardId(shareableDeck.DeckContents.Cards[i].Def.Asset);
-			TAG_PREMIUM premium = (TAG_PREMIUM)shareableDeck.DeckContents.Cards[i].Def.Premium;
-			int qty = shareableDeck.DeckContents.Cards[i].Qty;
-			for (int j = 0; j < qty; j++)
-			{
-				if (!AddCard(cardID, premium, false, null))
-				{
-					result = false;
-				}
-			}
-		}
-		foreach (SideBoardCardData sideboardCard in shareableDeck.DeckContents.SideboardCards)
+    }
+
+    public void CopyContents(CollectionDeck otherDeck)
+    {
+        HeroCardID = otherDeck.HeroCardID;
+        UIHeroOverrideCardID = otherDeck.UIHeroOverrideCardID;
+        UIHeroOverridePremium = otherDeck.UIHeroOverridePremium;
+        RuneType[] runeOrder = otherDeck.GetRuneOrder();
+        SetRuneOrder(runeOrder);
+        m_slots.Clear();
+        for (int i = 0; i < otherDeck.GetSlotCount(); i++)
+        {
+            CollectionDeckSlot slotByIndex = otherDeck.GetSlotByIndex(i);
+            foreach (TAG_PREMIUM value in Enum.GetValues(typeof(TAG_PREMIUM)))
+            {
+                for (int j = 0; j < slotByIndex.GetCount(value); j++)
+                {
+					AddCard(slotByIndex.CardID, value, false, null);
+                }
+            }
+        }
+    }
+
+    public bool FillFromShareableDeck(ShareableDeck shareableDeck)
+    {
+        HeroCardID = GameUtils.TranslateDbIdToCardId(shareableDeck.HeroCardDbId);
+        FormatType = shareableDeck.FormatType;
+        bool result = true;
+        m_slots.Clear();
+        for (int i = 0; i < shareableDeck.DeckContents.Cards.Count; i++)
+        {
+            string cardID = GameUtils.TranslateDbIdToCardId(shareableDeck.DeckContents.Cards[i].Def.Asset);
+            TAG_PREMIUM premium = (TAG_PREMIUM)shareableDeck.DeckContents.Cards[i].Def.Premium;
+            int qty = shareableDeck.DeckContents.Cards[i].Qty;
+            for (int j = 0; j < qty; j++)
+            {
+				if (!AddCard(cardID, premium, false, null))
+                {
+                    result = false;
+                }
+            }
+        }
+		foreach (SideBoardCardData sideboardCard in shareableDeck.DeckContents.SideboardCards)
 		{
 			string ownerCardId = GameUtils.TranslateDbIdToCardId(sideboardCard.LinkedCardDbId);
 			SideboardDeck orCreateSideboard = m_sideboardManager.GetOrCreateSideboard(ownerCardId, (TAG_PREMIUM)sideboardCard.Def.Premium, setEdited: false);
 			string cardID2 = GameUtils.TranslateDbIdToCardId(sideboardCard.Def.Asset);
 			orCreateSideboard.AddCard(cardID2, (TAG_PREMIUM)sideboardCard.Def.Premium, false, null);
 		}
-		return result;
-	}
-
-	public void FillFromTemplateDeck(CollectionManager.TemplateDeck tplDeck)
-	{
-		ClearSlotContents();
-		Name = tplDeck.m_title;
-		SetRuneOrder(tplDeck.m_rune1, tplDeck.m_rune2, tplDeck.m_rune3);
-		foreach (KeyValuePair<string, int> cardId in tplDeck.m_cardIds)
-		{
-			CollectionManager.Get().GetOwnedCardCount(cardId.Key, out var _, out var golden, out var signature, out var diamond);
-			int num = cardId.Value;
-			while (num > 0 && diamond > 0)
-			{
+        return result;
+    }
+
+    public void FillFromTemplateDeck(CollectionManager.TemplateDeck tplDeck)
+    {
+        ClearSlotContents();
+        Name = tplDeck.m_title;
+        SetRuneOrder(tplDeck.m_rune1, tplDeck.m_rune2, tplDeck.m_rune3);
+        foreach (KeyValuePair<string, int> cardId in tplDeck.m_cardIds)
+        {
+            CollectionManager.Get().GetOwnedCardCount(cardId.Key, out var _, out var golden, out var signature, out var diamond);
+            int num = cardId.Value;
+            while (num > 0 && diamond > 0)
+            {
 				AddCard(cardId.Key, TAG_PREMIUM.DIAMOND, false, null);
-				diamond--;
-				num--;
-			}
-			while (num > 0 && signature > 0)
-			{
+                diamond--;
+                num--;
+            }
+            while (num > 0 && signature > 0)
+            {
 				AddCard(cardId.Key, TAG_PREMIUM.SIGNATURE, false, null);
-				diamond--;
-				num--;
-			}
-			while (num > 0 && golden > 0)
-			{
+                diamond--;
+                num--;
+            }
+            while (num > 0 && golden > 0)
+            {
 				AddCard(cardId.Key, TAG_PREMIUM.GOLDEN, false, null);
-				golden--;
-				num--;
-			}
-			while (num > 0)
-			{
+                golden--;
+                num--;
+            }
+            while (num > 0)
+            {
 				AddCard(cardId.Key, TAG_PREMIUM.NORMAL, false, null);
-				num--;
-			}
-		}
-		SetRuneOrder(tplDeck.m_rune1, tplDeck.m_rune2, tplDeck.m_rune3);
-	}
-
-	public void FillFromCardList(IEnumerable<DeckMaker.DeckFill> fillCards, ChangeSource changeSource)
-	{
-		if (fillCards == null)
-		{
-			return;
-		}
-		foreach (DeckMaker.DeckFill fillCard in fillCards)
-		{
-			if (GetTotalCardCount() >= GetMaxCardCount())
-			{
-				break;
-			}
-			if (fillCard.m_addCard != null)
-			{
-				TAG_PREMIUM? preferredPremiumThatCanBeAdded = GetPreferredPremiumThatCanBeAdded(fillCard.m_addCard.GetCardId());
-				if (preferredPremiumThatCanBeAdded.HasValue)
-				{
+                num--;
+            }
+        }
+        SetRuneOrder(tplDeck.m_rune1, tplDeck.m_rune2, tplDeck.m_rune3);
+    }
+
+    public void FillFromCardList(IEnumerable<DeckMaker.DeckFill> fillCards, ChangeSource changeSource)
+    {
+        if (fillCards == null)
+        {
+            return;
+        }
+        foreach (DeckMaker.DeckFill fillCard in fillCards)
+        {
+            if (GetTotalCardCount() >= GetMaxCardCount())
+            {
+                break;
+            }
+            if (fillCard.m_addCard != null)
+            {
+                TAG_PREMIUM? preferredPremiumThatCanBeAdded = GetPreferredPremiumThatCanBeAdded(fillCard.m_addCard.GetCardId());
+                if (preferredPremiumThatCanBeAdded.HasValue)
+                {
 					AddCard(fillCard.m_addCard.GetCardId(), preferredPremiumThatCanBeAdded.Value, false, null);
-				}
-			}
-		}
-		SendChanges(changeSource);
-	}
-
-	public void ReconcileOwnershipOnCollectionCardRemoved(string cardID, TAG_PREMIUM premium)
-	{
+                }
+            }
+        }
+        SendChanges(changeSource);
+    }
+
+    public void ReconcileOwnershipOnCollectionCardRemoved(string cardID, TAG_PREMIUM premium)
+    {
 		int num = ReconcileOwnershipOnRemoval(cardID, premium);
 		foreach (KeyValuePair<string, SideboardDeck> allSideboard in m_sideboardManager.GetAllSideboards())
-		{
+        {
 			num += allSideboard.Value.ReconcileOwnershipOnRemoval(cardID, premium, num);
-		}
-		if (!IsBeingEdited())
-		{
+            }
+            if (!IsBeingEdited())
+            {
 			m_pendingChangeSource = ChangeSource.ReconcileCardOwnership;
-		}
-	}
+            }
+        }
 
 	private int ReconcileOwnershipOnRemoval(string cardID, TAG_PREMIUM premium, int numAlreadySlotted = 0)
 	{
@@ -1004,10 +1004,10 @@ public class CollectionDeck
 			num2--;
 		}
 		return collectionDeckSlot.GetCount(premium);
-	}
+    }
 
-	public void ReconcileOwnershipOnCollectionCardAdded(string cardID)
-	{
+    public void ReconcileOwnershipOnCollectionCardAdded(string cardID)
+    {
 		bool flag = ReconcileOwnershipOnAdd(cardID);
 		foreach (KeyValuePair<string, SideboardDeck> allSideboard in m_sideboardManager.GetAllSideboards())
 		{
@@ -1024,26 +1024,26 @@ public class CollectionDeck
 
 	private bool ReconcileOwnershipOnAdd(string cardID)
 	{
-		CollectionDeckSlot collectionDeckSlot = FindFirstOwnedSlotByCardId(cardID, owned: false);
-		if (collectionDeckSlot == null)
-		{
+        CollectionDeckSlot collectionDeckSlot = FindFirstOwnedSlotByCardId(cardID, owned: false);
+        if (collectionDeckSlot == null)
+        {
 			return false;
-		}
+        }
 		bool result = false;
-		for (int num = collectionDeckSlot.Count; num > 0; num--)
-		{
-			TAG_PREMIUM? preferredPremiumThatCanBeAdded = GetPreferredPremiumThatCanBeAdded(cardID);
-			if (!preferredPremiumThatCanBeAdded.HasValue)
-			{
-				break;
-			}
+        for (int num = collectionDeckSlot.Count; num > 0; num--)
+        {
+            TAG_PREMIUM? preferredPremiumThatCanBeAdded = GetPreferredPremiumThatCanBeAdded(cardID);
+            if (!preferredPremiumThatCanBeAdded.HasValue)
+            {
+                break;
+            }
 			if (AddCard(cardID, preferredPremiumThatCanBeAdded.Value, false, null))
-			{
+            {
 				result = true;
-			}
-		}
+            }
+        }
 		return result;
-	}
+    }
 
 	public void SendChangesIfPending()
 	{
@@ -1054,119 +1054,119 @@ public class CollectionDeck
 		}
 	}
 
-	public CollectionDeckSlot FindInvalidSlot()
-	{
-		return GetSlots().Find((CollectionDeckSlot slot) => !IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true));
-	}
-
-	public List<CollectionDeckSlot> FindInvalidSlots(FormatType? formatTypeToValidateAgainst = null)
-	{
-		return GetSlots().FindAll((CollectionDeckSlot slot) => !IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true, formatTypeToValidateAgainst));
-	}
-
-	public void RemoveInvalidCards(FormatType? formatTypeToValidateAgainst = null)
-	{
-		foreach (CollectionDeckSlot item in FindInvalidSlots(formatTypeToValidateAgainst))
-		{
-			RemoveSlot(item);
-		}
-	}
-
-	public void RemoveExtraCards(FormatType? formatTypeToValidateAgainst = null)
-	{
-		CardCountByStatus cardCountByStatus = CountCardsByStatus(formatTypeToValidateAgainst);
-		if (cardCountByStatus.Extra <= 0)
-		{
-			return;
-		}
-		foreach (CollectionDeckSlot item in FindInvalidSlots(formatTypeToValidateAgainst))
-		{
-			while (cardCountByStatus.Extra > 0 && item.Count > 0)
-			{
-				item.RemoveCard(1, item.UnPreferredPremium);
-				cardCountByStatus.Extra--;
-			}
-		}
-		cardCountByStatus = CountCardsByStatus(formatTypeToValidateAgainst);
-		if (cardCountByStatus.Extra <= 0)
-		{
-			return;
-		}
-		List<CollectionDeckSlot> list = m_slots.Where((CollectionDeckSlot slot) => !slot.GetEntityDef().HasTag(GAME_TAG.DECK_RULE_MOD_DECK_SIZE)).ToList();
-		while (cardCountByStatus.Extra > 0 && list.Count > 0)
-		{
-			int index = UnityEngine.Random.Range(0, list.Count);
-			CollectionDeckSlot collectionDeckSlot = list[index];
-			collectionDeckSlot.RemoveCard(1, collectionDeckSlot.UnPreferredPremium);
-			if (collectionDeckSlot.Count == 0)
-			{
-				list.RemoveAt(index);
-			}
-			cardCountByStatus.Extra--;
-		}
-	}
+    public CollectionDeckSlot FindInvalidSlot()
+    {
+        return GetSlots().Find((CollectionDeckSlot slot) => !IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true));
+    }
+
+    public List<CollectionDeckSlot> FindInvalidSlots(FormatType? formatTypeToValidateAgainst = null)
+    {
+        return GetSlots().FindAll((CollectionDeckSlot slot) => !IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true, formatTypeToValidateAgainst));
+    }
+
+    public void RemoveInvalidCards(FormatType? formatTypeToValidateAgainst = null)
+    {
+        foreach (CollectionDeckSlot item in FindInvalidSlots(formatTypeToValidateAgainst))
+        {
+            RemoveSlot(item);
+        }
+    }
+
+    public void RemoveExtraCards(FormatType? formatTypeToValidateAgainst = null)
+    {
+        CardCountByStatus cardCountByStatus = CountCardsByStatus(formatTypeToValidateAgainst);
+        if (cardCountByStatus.Extra <= 0)
+        {
+            return;
+        }
+        foreach (CollectionDeckSlot item in FindInvalidSlots(formatTypeToValidateAgainst))
+        {
+            while (cardCountByStatus.Extra > 0 && item.Count > 0)
+            {
+                item.RemoveCard(1, item.UnPreferredPremium);
+                cardCountByStatus.Extra--;
+            }
+        }
+        cardCountByStatus = CountCardsByStatus(formatTypeToValidateAgainst);
+        if (cardCountByStatus.Extra <= 0)
+        {
+            return;
+        }
+        List<CollectionDeckSlot> list = m_slots.Where((CollectionDeckSlot slot) => !slot.GetEntityDef().HasTag(GAME_TAG.DECK_RULE_MOD_DECK_SIZE)).ToList();
+        while (cardCountByStatus.Extra > 0 && list.Count > 0)
+        {
+            int index = UnityEngine.Random.Range(0, list.Count);
+            CollectionDeckSlot collectionDeckSlot = list[index];
+            collectionDeckSlot.RemoveCard(1, collectionDeckSlot.UnPreferredPremium);
+            if (collectionDeckSlot.Count == 0)
+            {
+                list.RemoveAt(index);
+            }
+            cardCountByStatus.Extra--;
+        }
+    }
 
 	public int GetCardIdCount(string cardID, bool includeUnowned = true, bool includeSideboards = true)
-	{
-		int num = 0;
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			if (slot.CardID.Equals(cardID) && (includeUnowned || slot.Owned))
-			{
-				num += slot.Count;
-			}
-		}
+    {
+        int num = 0;
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            if (slot.CardID.Equals(cardID) && (includeUnowned || slot.Owned))
+            {
+                num += slot.Count;
+            }
+        }
 		if (includeSideboards && HasSideboardCards)
 		{
 			num += m_sideboardManager.GetCardIdCount(cardID, includeUnowned);
 		}
-		return num;
-	}
-
-	public int GetCardCountAllMatchingSlots(string cardID)
-	{
-		int num = 0;
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			if (slot.CardID.Equals(cardID))
-			{
-				num += slot.Count;
-			}
-		}
-		return num;
-	}
-
-	public int GetCardCountAllMatchingSlots(string cardID, TAG_PREMIUM premium)
-	{
-		int num = 0;
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			if (slot.CardID.Equals(cardID))
-			{
-				num += slot.GetCount(premium);
-			}
-		}
+        return num;
+    }
+
+    public int GetCardCountAllMatchingSlots(string cardID)
+    {
+        int num = 0;
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            if (slot.CardID.Equals(cardID))
+            {
+                num += slot.Count;
+            }
+        }
+        return num;
+    }
+
+    public int GetCardCountAllMatchingSlots(string cardID, TAG_PREMIUM premium)
+    {
+        int num = 0;
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            if (slot.CardID.Equals(cardID))
+            {
+                num += slot.GetCount(premium);
+            }
+        }
 		foreach (KeyValuePair<string, SideboardDeck> allSideboard in m_sideboardManager.GetAllSideboards())
 		{
 			num += allSideboard.Value.GetCardCountAllMatchingSlots(cardID, premium);
 		}
-		return num;
-	}
-
-	public int GetOwnedCardCountInDeck(string cardID, TAG_PREMIUM premium, bool owned = true)
-	{
-		if (!ShouldSplitSlotsByOwnershipOrFormatValidity())
-		{
-			return GetCardCountAllMatchingSlots(cardID);
-		}
-		int num = 0;
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			if (slot.CardID.Equals(cardID) && slot.Owned == owned)
-			{
-				num += slot.GetCount(premium);
-			}
-		}
+        return num;
+    }
+
+    public int GetOwnedCardCountInDeck(string cardID, TAG_PREMIUM premium, bool owned = true)
+    {
+        if (!ShouldSplitSlotsByOwnershipOrFormatValidity())
+        {
+            return GetCardCountAllMatchingSlots(cardID);
+        }
+        int num = 0;
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            if (slot.CardID.Equals(cardID) && slot.Owned == owned)
+            {
+                num += slot.GetCount(premium);
+            }
+        }
 		foreach (KeyValuePair<string, SideboardDeck> allSideboard in m_sideboardManager.GetAllSideboards())
 		{
 			bool owned2 = owned;
@@ -1176,71 +1176,71 @@ public class CollectionDeck
 			}
 			num += allSideboard.Value.GetOwnedCardCountInDeck(cardID, premium, owned2);
 		}
-		return num;
-	}
-
-	public int GetCardCountInSet(HashSet<string> set, bool isNot)
-	{
-		int num = 0;
-		for (int i = 0; i < m_slots.Count; i++)
-		{
-			CollectionDeckSlot collectionDeckSlot = m_slots[i];
-			if (set.Contains(collectionDeckSlot.CardID) == !isNot)
-			{
-				num += collectionDeckSlot.Count;
-			}
-		}
-		return num;
-	}
-
-	public void ClearSlotContents()
-	{
-		m_slots.Clear();
-	}
-
-	public TAG_PREMIUM? GetPreferredPremiumThatCanBeAdded(string cardId)
-	{
-		if (CanCardBeAddedAsOwned(cardId, TAG_PREMIUM.DIAMOND))
-		{
-			return TAG_PREMIUM.DIAMOND;
-		}
-		if (CanCardBeAddedAsOwned(cardId, TAG_PREMIUM.SIGNATURE))
-		{
-			return TAG_PREMIUM.SIGNATURE;
-		}
-		if (CanCardBeAddedAsOwned(cardId, TAG_PREMIUM.GOLDEN))
-		{
-			return TAG_PREMIUM.GOLDEN;
-		}
-		if (CanCardBeAddedAsOwned(cardId, TAG_PREMIUM.NORMAL))
-		{
-			return TAG_PREMIUM.NORMAL;
-		}
-		return null;
-	}
-
-	public bool CanCardBeAddedAsOwned(string cardID, TAG_PREMIUM premium)
-	{
+        return num;
+    }
+
+    public int GetCardCountInSet(HashSet<string> set, bool isNot)
+    {
+        int num = 0;
+        for (int i = 0; i < m_slots.Count; i++)
+        {
+            CollectionDeckSlot collectionDeckSlot = m_slots[i];
+            if (set.Contains(collectionDeckSlot.CardID) == !isNot)
+            {
+                num += collectionDeckSlot.Count;
+            }
+        }
+        return num;
+    }
+
+    public void ClearSlotContents()
+    {
+        m_slots.Clear();
+    }
+
+    public TAG_PREMIUM? GetPreferredPremiumThatCanBeAdded(string cardId)
+    {
+        if (CanCardBeAddedAsOwned(cardId, TAG_PREMIUM.DIAMOND))
+        {
+            return TAG_PREMIUM.DIAMOND;
+        }
+        if (CanCardBeAddedAsOwned(cardId, TAG_PREMIUM.SIGNATURE))
+        {
+            return TAG_PREMIUM.SIGNATURE;
+        }
+        if (CanCardBeAddedAsOwned(cardId, TAG_PREMIUM.GOLDEN))
+        {
+            return TAG_PREMIUM.GOLDEN;
+        }
+        if (CanCardBeAddedAsOwned(cardId, TAG_PREMIUM.NORMAL))
+        {
+            return TAG_PREMIUM.NORMAL;
+        }
+        return null;
+    }
+
+    public bool CanCardBeAddedAsOwned(string cardID, TAG_PREMIUM premium)
+    {
 		int num = ((!(this is SideboardDeck sideboardDeck)) ? GetOwnedCardCountInDeck(cardID, premium) : sideboardDeck.MainDeck.GetOwnedCardCountInDeck(cardID, premium));
 		return CollectionManager.Get().GetOwnedCount(cardID, premium) > num;
-	}
+    }
 
 	public virtual bool AddCard(string cardID, TAG_PREMIUM premium, bool allowInvalid = false, EntityDef entityDef = null, params DeckRule.RuleType[] ignoreRules)
-	{
-		bool flag = false;
-		if (ShouldSplitSlotsByOwnershipOrFormatValidity())
-		{
-			flag = CanCardBeAddedAsOwned(cardID, premium);
+    {
+        bool flag = false;
+        if (ShouldSplitSlotsByOwnershipOrFormatValidity())
+        {
+            flag = CanCardBeAddedAsOwned(cardID, premium);
 			if (GameUtils.IsCardCollectible(cardID) && !flag)
-			{
-				premium = TAG_PREMIUM.NORMAL;
-			}
-		}
-		CollectionDeckSlot collectionDeckSlot = FindFirstOwnedSlotByCardId(cardID, owned: false);
-		CollectionDeckSlot collectionDeckSlot2;
-		if (flag)
-		{
-			collectionDeckSlot2 = FindFirstOwnedSlotByCardId(cardID, owned: true);
+            {
+                premium = TAG_PREMIUM.NORMAL;
+            }
+        }
+        CollectionDeckSlot collectionDeckSlot = FindFirstOwnedSlotByCardId(cardID, owned: false);
+        CollectionDeckSlot collectionDeckSlot2;
+        if (flag)
+        {
+            collectionDeckSlot2 = FindFirstOwnedSlotByCardId(cardID, owned: true);
 			if (collectionDeckSlot != null)
 			{
 				collectionDeckSlot.RemoveCard(1, collectionDeckSlot.UnPreferredPremium);
@@ -1249,146 +1249,146 @@ public class CollectionDeck
 					RemoveSideboard(cardID);
 				}
 			}
-		}
-		else
-		{
-			collectionDeckSlot2 = collectionDeckSlot;
-		}
-		if (!allowInvalid)
-		{
+        }
+        else
+        {
+            collectionDeckSlot2 = collectionDeckSlot;
+        }
+        if (!allowInvalid)
+        {
 			EntityDef entityDef2 = entityDef ?? DefLoader.Get().GetEntityDef(cardID);
 			if (!CanAddCard(entityDef2, premium, ignoreRules))
-			{
-				return false;
-			}
-		}
-		bool flag2;
-		if (collectionDeckSlot2 == null)
-		{
-			collectionDeckSlot2 = InsertSlotWithCard(cardID, premium, flag, 1);
-			flag2 = collectionDeckSlot2 != null;
-		}
-		else
-		{
-			collectionDeckSlot2.AddCard(1, premium);
-			flag2 = true;
-		}
+            {
+                return false;
+            }
+        }
+        bool flag2;
+        if (collectionDeckSlot2 == null)
+        {
+            collectionDeckSlot2 = InsertSlotWithCard(cardID, premium, flag, 1);
+            flag2 = collectionDeckSlot2 != null;
+        }
+        else
+        {
+            collectionDeckSlot2.AddCard(1, premium);
+            flag2 = true;
+        }
 		if (flag2 && !(this is SideboardDeck))
-		{
+        {
 			EntityDef entityDef3 = collectionDeckSlot2.GetEntityDef();
-			UpdateDeckRunes(entityDef3);
-			if (entityDef3.HasSideboard)
-			{
-				m_sideboardManager.GetOrCreateSideboard(entityDef3.GetCardId(), premium, setEdited: false);
-			}
-		}
-		return flag2;
-	}
-
-	private void UpdateDeckRunes(EntityBase entity)
-	{
-		if (entity == null)
-		{
-			return;
-		}
-		RuneType[] array = Runes.CombineRunes(entity.GetRuneCost(), DeckRule_DeathKnightRuneLimit.MaxRuneSlots).ToArray();
-		int num = 0;
-		for (int i = 0; i < m_runeOrder.Length; i++)
-		{
-			if (m_runeOrder[i] == RuneType.RT_NONE && num < array.Length)
-			{
-				SetRuneAtIndex(i, array[num]);
-				num++;
-			}
-		}
-	}
-
-	public CollectionDeckSlot InsertSlotWithCard(string cardID, TAG_PREMIUM premium, bool owned, int count)
-	{
-		CollectionDeckSlot collectionDeckSlot = new CollectionDeckSlot
-		{
-			CardID = cardID,
-			Owned = owned
-		};
-		collectionDeckSlot.SetCount(count, premium);
-		int insertionIdxByDefaultSort = GetInsertionIdxByDefaultSort(collectionDeckSlot);
-		if (InsertSlot(insertionIdxByDefaultSort, collectionDeckSlot))
-		{
-			return collectionDeckSlot;
-		}
-		return null;
-	}
-
-	public bool AddCard_DungeonCrawlBuff(string cardId, TAG_PREMIUM premium, List<int> enchantments)
-	{
-		CollectionDeckSlot collectionDeckSlot = InsertSlotWithCard(cardId, premium, owned: true, 1);
-		if (collectionDeckSlot == null)
-		{
-			return false;
-		}
-		collectionDeckSlot.CreateEntityDefOverride();
-		foreach (int enchantment in enchantments)
-		{
-			EntityDef entityDef = DefLoader.Get().GetEntityDef(enchantment);
-			int tag = entityDef.GetTag(GAME_TAG.UI_BUFF_ATK_UP);
-			if (tag != 0)
-			{
-				int tag2 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.ATK);
-				collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.ATK, tag2 + tag);
-			}
-			int tag3 = entityDef.GetTag(GAME_TAG.UI_BUFF_HEALTH_UP);
-			if (tag3 != 0)
-			{
-				int tag4 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.HEALTH);
-				collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.HEALTH, tag4 + tag3);
-			}
-			int tag5 = entityDef.GetTag(GAME_TAG.UI_BUFF_DURABILITY_UP);
-			if (tag5 != 0)
-			{
-				int tag6 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.DURABILITY);
-				collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.DURABILITY, tag6 + tag5);
-			}
-			int tag7 = entityDef.GetTag(GAME_TAG.UI_BUFF_COST_UP);
-			if (tag7 != 0)
-			{
-				int tag8 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.COST);
-				collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.COST, tag8 + tag7);
-			}
-			int tag9 = entityDef.GetTag(GAME_TAG.UI_BUFF_COST_DOWN);
-			if (tag9 != 0)
-			{
-				int tag10 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.COST);
-				collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.COST, Math.Max(tag10 - tag9, 0));
-			}
-			if (entityDef.GetTag(GAME_TAG.UI_BUFF_SET_COST_ZERO) != 0)
+			UpdateDeckRunes(entityDef3);
+			if (entityDef3.HasSideboard)
 			{
-				collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.COST, 0);
+				m_sideboardManager.GetOrCreateSideboard(entityDef3.GetCardId(), premium, setEdited: false);
 			}
-		}
-		return true;
-	}
+        }
+        return flag2;
+    }
+
+    private void UpdateDeckRunes(EntityBase entity)
+    {
+        if (entity == null)
+        {
+            return;
+        }
+        RuneType[] array = Runes.CombineRunes(entity.GetRuneCost(), DeckRule_DeathKnightRuneLimit.MaxRuneSlots).ToArray();
+        int num = 0;
+        for (int i = 0; i < m_runeOrder.Length; i++)
+        {
+            if (m_runeOrder[i] == RuneType.RT_NONE && num < array.Length)
+            {
+                SetRuneAtIndex(i, array[num]);
+                num++;
+            }
+        }
+    }
+
+    public CollectionDeckSlot InsertSlotWithCard(string cardID, TAG_PREMIUM premium, bool owned, int count)
+    {
+        CollectionDeckSlot collectionDeckSlot = new CollectionDeckSlot
+        {
+            CardID = cardID,
+            Owned = owned
+        };
+        collectionDeckSlot.SetCount(count, premium);
+        int insertionIdxByDefaultSort = GetInsertionIdxByDefaultSort(collectionDeckSlot);
+        if (InsertSlot(insertionIdxByDefaultSort, collectionDeckSlot))
+        {
+            return collectionDeckSlot;
+        }
+        return null;
+    }
+
+    public bool AddCard_DungeonCrawlBuff(string cardId, TAG_PREMIUM premium, List<int> enchantments)
+    {
+        CollectionDeckSlot collectionDeckSlot = InsertSlotWithCard(cardId, premium, owned: true, 1);
+        if (collectionDeckSlot == null)
+        {
+            return false;
+        }
+        collectionDeckSlot.CreateEntityDefOverride();
+        foreach (int enchantment in enchantments)
+        {
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(enchantment);
+            int tag = entityDef.GetTag(GAME_TAG.UI_BUFF_ATK_UP);
+            if (tag != 0)
+            {
+                int tag2 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.ATK);
+                collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.ATK, tag2 + tag);
+            }
+            int tag3 = entityDef.GetTag(GAME_TAG.UI_BUFF_HEALTH_UP);
+            if (tag3 != 0)
+            {
+                int tag4 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.HEALTH);
+                collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.HEALTH, tag4 + tag3);
+            }
+            int tag5 = entityDef.GetTag(GAME_TAG.UI_BUFF_DURABILITY_UP);
+            if (tag5 != 0)
+            {
+                int tag6 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.DURABILITY);
+                collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.DURABILITY, tag6 + tag5);
+            }
+            int tag7 = entityDef.GetTag(GAME_TAG.UI_BUFF_COST_UP);
+            if (tag7 != 0)
+            {
+                int tag8 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.COST);
+                collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.COST, tag8 + tag7);
+            }
+            int tag9 = entityDef.GetTag(GAME_TAG.UI_BUFF_COST_DOWN);
+            if (tag9 != 0)
+            {
+                int tag10 = collectionDeckSlot.m_entityDefOverride.GetTag(GAME_TAG.COST);
+                collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.COST, Math.Max(tag10 - tag9, 0));
+            }
+            if (entityDef.GetTag(GAME_TAG.UI_BUFF_SET_COST_ZERO) != 0)
+            {
+                collectionDeckSlot.m_entityDefOverride.SetTag(GAME_TAG.COST, 0);
+            }
+        }
+        return true;
+    }
 
 	public virtual bool RemoveCard(string cardID, TAG_PREMIUM premium, bool valid, bool enforceRemainingDeckRuleset)
-	{
-		CollectionDeckSlot collectionDeckSlot = FindFirstSlotByCardIdAndValidity(cardID, valid, ignoreGameplayEvent: false, enforceRemainingDeckRuleset);
-		if (collectionDeckSlot == null)
-		{
-			return false;
-		}
-		collectionDeckSlot.RemoveCard(1, premium);
-		UpdateUIHeroOverrideCardRemoval(cardID);
-		return true;
-	}
-
-	public void RemoveAllCards()
-	{
-		m_slots = new List<CollectionDeckSlot>();
-	}
-
-	private void UpdateUIHeroOverrideCardRemoval(string cardID)
-	{
-		if (GameDbf.GetIndex().HasCardPlayerDeckOverride(cardID) && (CollectionDeckTray.Get() == null || !CollectionDeckTray.Get().IsShowingDeckContents()))
-		{
+    {
+        CollectionDeckSlot collectionDeckSlot = FindFirstSlotByCardIdAndValidity(cardID, valid, ignoreGameplayEvent: false, enforceRemainingDeckRuleset);
+        if (collectionDeckSlot == null)
+        {
+            return false;
+        }
+        collectionDeckSlot.RemoveCard(1, premium);
+        UpdateUIHeroOverrideCardRemoval(cardID);
+        return true;
+    }
+
+    public void RemoveAllCards()
+    {
+        m_slots = new List<CollectionDeckSlot>();
+    }
+
+    private void UpdateUIHeroOverrideCardRemoval(string cardID)
+    {
+        if (GameDbf.GetIndex().HasCardPlayerDeckOverride(cardID) && (CollectionDeckTray.Get() == null || !CollectionDeckTray.Get().IsShowingDeckContents()))
+        {
 			ClearUIHeroOverride();
 			CollectionManager.Get().OnUIHeroOverrideCardRemoved();
 		}
@@ -1396,43 +1396,43 @@ public class CollectionDeck
 
 	public void ClearUIHeroOverride()
 	{
-		UIHeroOverrideCardID = string.Empty;
-		UIHeroOverridePremium = TAG_PREMIUM.NORMAL;
-		Name = GameStrings.Format("GLOBAL_BASIC_DECK_NAME", GameStrings.GetClassName(GetClass()));
+            UIHeroOverrideCardID = string.Empty;
+            UIHeroOverridePremium = TAG_PREMIUM.NORMAL;
+            Name = GameStrings.Format("GLOBAL_BASIC_DECK_NAME", GameStrings.GetClassName(GetClass()));
 		m_currentDisplayHeroCardId = HeroCardID;
-	}
-
-	public void OnContentChangesComplete()
-	{
-		m_isSavingContentChanges = false;
-	}
-
-	public void OnNameChangeComplete()
-	{
-		m_isSavingNameChanges = false;
-	}
-
-	public void SendChanges(ChangeSource changeSource)
-	{
-		CollectionDeck baseDeck = CollectionManager.Get().GetBaseDeck(ID);
-		if (this == baseDeck)
-		{
-			Debug.LogError($"CollectionDeck.Send() - {baseDeck} is a base deck. You cannot send a base deck to the network.");
-			return;
-		}
-		if (baseDeck == null)
-		{
-			Log.CollectionManager.PrintError("CollectionDeck.SendChanges() - No base deck with id=" + ID);
-			return;
-		}
-		GenerateNameDiff(baseDeck, out var deckName);
+    }
+
+    public void OnContentChangesComplete()
+    {
+        m_isSavingContentChanges = false;
+    }
+
+    public void OnNameChangeComplete()
+    {
+        m_isSavingNameChanges = false;
+    }
+
+    public void SendChanges(ChangeSource changeSource)
+    {
+        CollectionDeck baseDeck = CollectionManager.Get().GetBaseDeck(ID);
+        if (this == baseDeck)
+        {
+            Debug.LogError($"CollectionDeck.Send() - {baseDeck} is a base deck. You cannot send a base deck to the network.");
+            return;
+        }
+        if (baseDeck == null)
+        {
+            Log.CollectionManager.PrintError("CollectionDeck.SendChanges() - No base deck with id=" + ID);
+            return;
+        }
+        GenerateNameDiff(baseDeck, out var deckName);
 		List<Network.CardUserData> list = GenerateContentChanges(baseDeck, this);
 		List<Network.SideboardCardUserData> list2 = GenerateSideboardContentChanges(baseDeck, this);
-		int heroAssetID;
-		bool? heroOverrideStatus;
-		int overrideHeroAssetID;
-		TAG_PREMIUM overrideHeroPremium;
-		bool flag = GenerateHeroDiff(baseDeck, out heroAssetID, out heroOverrideStatus, out overrideHeroAssetID, out overrideHeroPremium);
+        int heroAssetID;
+        bool? heroOverrideStatus;
+        int overrideHeroAssetID;
+        TAG_PREMIUM overrideHeroPremium;
+        bool flag = GenerateHeroDiff(baseDeck, out heroAssetID, out heroOverrideStatus, out overrideHeroAssetID, out overrideHeroPremium);
 		int? cosmeticCoinId;
 		bool flag2 = GenerateCosmeticCoinDiff(baseDeck, out cosmeticCoinId);
 		bool? randomCoinUseFavorite = null;
@@ -1441,138 +1441,138 @@ public class CollectionDeck
 		{
 			randomCoinUseFavorite = RandomCoinUseFavorite;
 		}
-		int? cardBackID;
+        int? cardBackID;
 		bool flag4 = GenerateCardBackDiff(baseDeck, out cardBackID);
 		bool flag5 = baseDeck.FormatType != FormatType;
 		bool flag6 = baseDeck.SortOrder != SortOrder;
-		RuneType[] runeOrder = baseDeck.GetRuneOrder();
+        RuneType[] runeOrder = baseDeck.GetRuneOrder();
 		bool flag7 = !IsRuneOrderEqual(runeOrder);
-		bool? randomHeroUseFavorite = null;
+        bool? randomHeroUseFavorite = null;
 		bool flag8 = baseDeck.RandomHeroUseFavorite != RandomHeroUseFavorite;
 		if (flag8)
-		{
-			randomHeroUseFavorite = RandomHeroUseFavorite;
-		}
-		Network network = Network.Get();
-		if (deckName != null)
-		{
-			m_isSavingNameChanges = true;
-			network.RenameDeck(ID, deckName);
-		}
-		string pastedDeckHash = null;
-		if (m_createdFromShareableDeck != null)
-		{
-			pastedDeckHash = m_createdFromShareableDeck.Serialize(includeComments: false);
-		}
+        {
+            randomHeroUseFavorite = RandomHeroUseFavorite;
+        }
+        Network network = Network.Get();
+        if (deckName != null)
+        {
+            m_isSavingNameChanges = true;
+            network.RenameDeck(ID, deckName);
+        }
+        string pastedDeckHash = null;
+        if (m_createdFromShareableDeck != null)
+        {
+            pastedDeckHash = m_createdFromShareableDeck.Serialize(includeComments: false);
+        }
 		if (list.Count > 0 || list2.Count > 0 || flag || flag8 || flag2 || flag3 || flag4 || flag5 || flag6 || flag7)
-		{
-			m_isSavingContentChanges = true;
-			m_changeNumber++;
+        {
+            m_isSavingContentChanges = true;
+            m_changeNumber++;
 			Network.Get().SendDeckData(changeSource, m_changeNumber, ID, list, list2, heroAssetID, heroOverrideStatus, overrideHeroAssetID, overrideHeroPremium, cosmeticCoinId, randomCoinUseFavorite, cardBackID, FormatType, SortOrder, randomHeroUseFavorite, m_runeOrder, pastedDeckHash);
-		}
-		if (!Network.IsLoggedIn())
-		{
-			OnContentChangesComplete();
-			OnNameChangeComplete();
-		}
-	}
+        }
+        if (!Network.IsLoggedIn())
+        {
+            OnContentChangesComplete();
+            OnNameChangeComplete();
+        }
+    }
 
 	public Dictionary<string, SideboardDeck> GetAllSideboards()
 	{
 		return m_sideboardManager.GetAllSideboards();
 	}
 
-	public static string GetUserFriendlyCopyErrorMessageFromDeckRuleViolation(DeckRuleViolation violation)
-	{
-		if (violation == null || violation.Rule == null)
-		{
-			return string.Empty;
-		}
-		switch (violation.Rule.Type)
-		{
-		case DeckRule.RuleType.PLAYER_OWNS_EACH_COPY:
-		case DeckRule.RuleType.DECK_SIZE:
-			return GameStrings.Get("GLUE_COLLECTION_DECK_COPY_TOOLTIP_INCOMPLETE");
+    public static string GetUserFriendlyCopyErrorMessageFromDeckRuleViolation(DeckRuleViolation violation)
+    {
+        if (violation == null || violation.Rule == null)
+        {
+            return string.Empty;
+        }
+        switch (violation.Rule.Type)
+        {
+            case DeckRule.RuleType.PLAYER_OWNS_EACH_COPY:
+            case DeckRule.RuleType.DECK_SIZE:
+                return GameStrings.Get("GLUE_COLLECTION_DECK_COPY_TOOLTIP_INCOMPLETE");
 		case DeckRule.RuleType.IS_IN_ANY_SUBSET:
-		case DeckRule.RuleType.IS_NOT_ROTATED:
-			return GameStrings.Get("GLUE_COLLECTION_DECK_COPY_TOOLTIP_FORMAT");
-		case DeckRule.RuleType.IS_CARD_PLAYABLE:
-			return GameStrings.Get("GLUE_COLLECTION_DECK_COPY_TOOLTIP_UNPLAYABLE");
-		default:
-			return violation.DisplayError;
-		}
-	}
-
-	public void SetShareableDeckCreatedFrom(ShareableDeck shareableDeck)
-	{
-		m_createdFromShareableDeck = shareableDeck;
-	}
-
-	public bool CanAddCard(EntityDef entityDef, TAG_PREMIUM premium, params DeckRule.RuleType[] ignoreRules)
-	{
+            case DeckRule.RuleType.IS_NOT_ROTATED:
+                return GameStrings.Get("GLUE_COLLECTION_DECK_COPY_TOOLTIP_FORMAT");
+            case DeckRule.RuleType.IS_CARD_PLAYABLE:
+                return GameStrings.Get("GLUE_COLLECTION_DECK_COPY_TOOLTIP_UNPLAYABLE");
+            default:
+                return violation.DisplayError;
+        }
+    }
+
+    public void SetShareableDeckCreatedFrom(ShareableDeck shareableDeck)
+    {
+        m_createdFromShareableDeck = shareableDeck;
+    }
+
+    public bool CanAddCard(EntityDef entityDef, TAG_PREMIUM premium, params DeckRule.RuleType[] ignoreRules)
+    {
 		return CanAddCard(entityDef, premium, this, ignoreRules);
 	}
 
 	public bool CanAddCard(EntityDef entityDef, TAG_PREMIUM premium, CollectionDeck validationDeck, params DeckRule.RuleType[] ignoreRules)
 	{
-		if (entityDef == null)
-		{
-			return false;
-		}
-		if (DeckType.DRAFT_DECK == Type || DeckType.CLIENT_ONLY_DECK == Type)
-		{
-			return true;
-		}
-		DeckRuleset deckRuleset = CollectionManager.Get().GetDeckRuleset();
-		if (deckRuleset == null)
-		{
-			return true;
-		}
-		if (Type == DeckType.PVPDR_DISPLAY_DECK && DuelsConfig.IsCardLoadoutTreasure(entityDef.GetCardId()))
-		{
-			return true;
-		}
-		List<DeckRule.RuleType> list = new List<DeckRule.RuleType>(ignoreRules);
-		list.AddRange(DefaultIgnoreRules);
-		RuleInvalidReason reason;
-		DeckRule brokenRule;
+        if (entityDef == null)
+        {
+            return false;
+        }
+        if (DeckType.DRAFT_DECK == Type || DeckType.CLIENT_ONLY_DECK == Type)
+        {
+            return true;
+        }
+        DeckRuleset deckRuleset = CollectionManager.Get().GetDeckRuleset();
+        if (deckRuleset == null)
+        {
+            return true;
+        }
+        if (Type == DeckType.PVPDR_DISPLAY_DECK && DuelsConfig.IsCardLoadoutTreasure(entityDef.GetCardId()))
+        {
+            return true;
+        }
+        List<DeckRule.RuleType> list = new List<DeckRule.RuleType>(ignoreRules);
+        list.AddRange(DefaultIgnoreRules);
+        RuleInvalidReason reason;
+        DeckRule brokenRule;
 		return deckRuleset.CanAddToDeck(entityDef, premium, validationDeck, out reason, out brokenRule, list.ToArray());
-	}
-
-	private bool InsertSlot(int slotIndex, CollectionDeckSlot slot)
-	{
-		if (slotIndex < 0 || slotIndex > GetSlotCount())
-		{
-			return false;
-		}
-		slot.OnSlotEmptied = (CollectionDeckSlot.DelOnSlotEmptied)Delegate.Combine(slot.OnSlotEmptied, new CollectionDeckSlot.DelOnSlotEmptied(OnSlotEmptied));
-		slot.Index = slotIndex;
-		m_slots.Insert(slotIndex, slot);
-		UpdateSlotIndices(slotIndex, GetSlotCount() - 1);
-		return true;
-	}
-
-	private void RemoveSlot(CollectionDeckSlot slot)
-	{
-		slot.OnSlotEmptied = (CollectionDeckSlot.DelOnSlotEmptied)Delegate.Remove(slot.OnSlotEmptied, new CollectionDeckSlot.DelOnSlotEmptied(OnSlotEmptied));
-		int index = slot.Index;
-		m_slots.RemoveAt(index);
-		slot.m_entityDefOverride = null;
-		UpdateSlotIndices(index, GetSlotCount() - 1);
-		UpdateUIHeroOverrideCardRemoval(slot.CardID);
-	}
-
-	private void OnSlotEmptied(CollectionDeckSlot slot)
-	{
-		if (GetExistingSlot(slot) == null)
-		{
-			Log.Decks.Print($"CollectionDeck.OnSlotCountUpdated(): Trying to remove slot {slot}, but it does not exist in deck {this}");
-		}
-		else
-		{
-			RemoveSlot(slot);
-		}
-	}
+    }
+
+    private bool InsertSlot(int slotIndex, CollectionDeckSlot slot)
+    {
+        if (slotIndex < 0 || slotIndex > GetSlotCount())
+        {
+            return false;
+        }
+        slot.OnSlotEmptied = (CollectionDeckSlot.DelOnSlotEmptied)Delegate.Combine(slot.OnSlotEmptied, new CollectionDeckSlot.DelOnSlotEmptied(OnSlotEmptied));
+        slot.Index = slotIndex;
+        m_slots.Insert(slotIndex, slot);
+        UpdateSlotIndices(slotIndex, GetSlotCount() - 1);
+        return true;
+    }
+
+    private void RemoveSlot(CollectionDeckSlot slot)
+    {
+        slot.OnSlotEmptied = (CollectionDeckSlot.DelOnSlotEmptied)Delegate.Remove(slot.OnSlotEmptied, new CollectionDeckSlot.DelOnSlotEmptied(OnSlotEmptied));
+        int index = slot.Index;
+        m_slots.RemoveAt(index);
+        slot.m_entityDefOverride = null;
+        UpdateSlotIndices(index, GetSlotCount() - 1);
+        UpdateUIHeroOverrideCardRemoval(slot.CardID);
+    }
+
+    private void OnSlotEmptied(CollectionDeckSlot slot)
+    {
+        if (GetExistingSlot(slot) == null)
+        {
+            Log.Decks.Print($"CollectionDeck.OnSlotCountUpdated(): Trying to remove slot {slot}, but it does not exist in deck {this}");
+        }
+        else
+        {
+            RemoveSlot(slot);
+        }
+    }
 
 	public void ForceUpdateSlotPosition(CollectionDeckSlot slotToUpdate)
 	{
@@ -1587,89 +1587,89 @@ public class CollectionDeck
 		}
 	}
 
-	private void UpdateSlotIndices(int indexA, int indexB)
-	{
-		if (GetSlotCount() != 0)
-		{
-			int val;
-			int val2;
-			if (indexA < indexB)
-			{
-				val = indexA;
-				val2 = indexB;
-			}
-			else
-			{
-				val = indexB;
-				val2 = indexA;
-			}
-			val = Math.Max(0, val);
-			val2 = Math.Min(val2, GetSlotCount() - 1);
-			for (int i = val; i <= val2; i++)
-			{
-				GetSlotByIndex(i).Index = i;
-			}
-		}
-	}
-
-	public CollectionDeckSlot FindFirstSlotByCardId(string cardID)
-	{
-		return m_slots.Find((CollectionDeckSlot slot) => slot.CardID.Equals(cardID));
-	}
-
-	public CollectionDeckSlot FindFirstOwnedSlotByCardId(string cardID, bool owned)
-	{
-		if (!ShouldSplitSlotsByOwnershipOrFormatValidity())
-		{
-			return FindFirstSlotByCardId(cardID);
-		}
-		return m_slots.Find((CollectionDeckSlot slot) => slot.CardID.Equals(cardID) && slot.Owned == owned);
-	}
-
-	public CollectionDeckSlot FindFirstSlotByCardIdAndValidity(string cardID, bool valid, bool ignoreGameplayEvent, bool enforceRemainingDeckRuleset)
-	{
-		if (!ShouldSplitSlotsByOwnershipOrFormatValidity())
-		{
-			Log.Decks.PrintWarning("Your deck doesn't care about Validity.  Why are you using 'FindFirstValidSlot' as opposed to 'FindFirstOwnedSlot'? This may be a bug!");
-			return FindFirstSlotByCardId(cardID);
-		}
-		return m_slots.Find((CollectionDeckSlot slot) => slot.CardID == cardID && valid == IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent, enforceRemainingDeckRuleset));
-	}
-
-	private void GenerateNameDiff(CollectionDeck baseDeck, out string deckName)
-	{
-		deckName = null;
-		if (!Name.Equals(baseDeck.Name))
-		{
-			deckName = Name;
-		}
-	}
-
-	private bool GenerateHeroDiff(CollectionDeck baseDeck, out int heroAssetID, out bool? heroOverrideStatus, out int overrideHeroAssetID, out TAG_PREMIUM overrideHeroPremium)
-	{
-		heroAssetID = -1;
-		overrideHeroAssetID = -1;
-		overrideHeroPremium = TAG_PREMIUM.NORMAL;
-		heroOverrideStatus = HeroOverridden;
-		bool result = false;
-		if (HeroOverridden != baseDeck.HeroOverridden)
-		{
-			result = true;
-		}
-		bool flag = HeroCardID == baseDeck.HeroCardID;
-		if (HeroOverridden && !flag)
-		{
-			heroAssetID = GameUtils.TranslateCardIdToDbId(HeroCardID);
-			result = true;
-		}
-		if (!(UIHeroOverrideCardID == baseDeck.UIHeroOverrideCardID) || UIHeroOverridePremium != baseDeck.UIHeroOverridePremium)
-		{
-			overrideHeroAssetID = ((!string.IsNullOrEmpty(UIHeroOverrideCardID)) ? GameUtils.TranslateCardIdToDbId(UIHeroOverrideCardID) : 0);
-			overrideHeroPremium = UIHeroOverridePremium;
-			result = true;
-		}
-		return result;
-	}
+    private void UpdateSlotIndices(int indexA, int indexB)
+    {
+        if (GetSlotCount() != 0)
+        {
+            int val;
+            int val2;
+            if (indexA < indexB)
+            {
+                val = indexA;
+                val2 = indexB;
+            }
+            else
+            {
+                val = indexB;
+                val2 = indexA;
+            }
+            val = Math.Max(0, val);
+            val2 = Math.Min(val2, GetSlotCount() - 1);
+            for (int i = val; i <= val2; i++)
+            {
+                GetSlotByIndex(i).Index = i;
+            }
+        }
+    }
+
+    public CollectionDeckSlot FindFirstSlotByCardId(string cardID)
+    {
+        return m_slots.Find((CollectionDeckSlot slot) => slot.CardID.Equals(cardID));
+    }
+
+    public CollectionDeckSlot FindFirstOwnedSlotByCardId(string cardID, bool owned)
+    {
+        if (!ShouldSplitSlotsByOwnershipOrFormatValidity())
+        {
+            return FindFirstSlotByCardId(cardID);
+        }
+        return m_slots.Find((CollectionDeckSlot slot) => slot.CardID.Equals(cardID) && slot.Owned == owned);
+    }
+
+    public CollectionDeckSlot FindFirstSlotByCardIdAndValidity(string cardID, bool valid, bool ignoreGameplayEvent, bool enforceRemainingDeckRuleset)
+    {
+        if (!ShouldSplitSlotsByOwnershipOrFormatValidity())
+        {
+            Log.Decks.PrintWarning("Your deck doesn't care about Validity.  Why are you using 'FindFirstValidSlot' as opposed to 'FindFirstOwnedSlot'? This may be a bug!");
+            return FindFirstSlotByCardId(cardID);
+        }
+        return m_slots.Find((CollectionDeckSlot slot) => slot.CardID == cardID && valid == IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent, enforceRemainingDeckRuleset));
+    }
+
+    private void GenerateNameDiff(CollectionDeck baseDeck, out string deckName)
+    {
+        deckName = null;
+        if (!Name.Equals(baseDeck.Name))
+        {
+            deckName = Name;
+        }
+    }
+
+    private bool GenerateHeroDiff(CollectionDeck baseDeck, out int heroAssetID, out bool? heroOverrideStatus, out int overrideHeroAssetID, out TAG_PREMIUM overrideHeroPremium)
+    {
+        heroAssetID = -1;
+        overrideHeroAssetID = -1;
+        overrideHeroPremium = TAG_PREMIUM.NORMAL;
+        heroOverrideStatus = HeroOverridden;
+        bool result = false;
+        if (HeroOverridden != baseDeck.HeroOverridden)
+        {
+            result = true;
+        }
+        bool flag = HeroCardID == baseDeck.HeroCardID;
+        if (HeroOverridden && !flag)
+        {
+            heroAssetID = GameUtils.TranslateCardIdToDbId(HeroCardID);
+            result = true;
+        }
+        if (!(UIHeroOverrideCardID == baseDeck.UIHeroOverrideCardID) || UIHeroOverridePremium != baseDeck.UIHeroOverridePremium)
+        {
+            overrideHeroAssetID = ((!string.IsNullOrEmpty(UIHeroOverrideCardID)) ? GameUtils.TranslateCardIdToDbId(UIHeroOverrideCardID) : 0);
+            overrideHeroPremium = UIHeroOverridePremium;
+            result = true;
+        }
+        return result;
+    }
 
 	private bool GenerateCosmeticCoinDiff(CollectionDeck baseDeck, out int? cosmeticCoinId)
 	{
@@ -1682,50 +1682,50 @@ public class CollectionDeck
 		return true;
 	}
 
-	private bool GenerateCardBackDiff(CollectionDeck baseDeck, out int? cardBackID)
-	{
-		cardBackID = -1;
-		if (CardBackID == baseDeck.CardBackID)
-		{
-			return false;
-		}
-		cardBackID = CardBackID;
-		return true;
-	}
+    private bool GenerateCardBackDiff(CollectionDeck baseDeck, out int? cardBackID)
+    {
+        cardBackID = -1;
+        if (CardBackID == baseDeck.CardBackID)
+        {
+            return false;
+        }
+        cardBackID = CardBackID;
+        return true;
+    }
 
 	private static List<Network.CardUserData> GetCardUserDataFromSlot(CollectionDeckSlot deckSlot, bool deleted)
-	{
-		List<Network.CardUserData> list = new List<Network.CardUserData>();
-		Network.CardUserData cardUserData = new Network.CardUserData
-		{
-			DbId = GameUtils.TranslateCardIdToDbId(deckSlot.CardID),
-			Count = ((!deleted) ? deckSlot.GetCount(TAG_PREMIUM.NORMAL) : 0),
-			Premium = TAG_PREMIUM.NORMAL
-		};
-		Network.CardUserData item = new Network.CardUserData
-		{
-			DbId = cardUserData.DbId,
-			Count = ((!deleted) ? deckSlot.GetCount(TAG_PREMIUM.GOLDEN) : 0),
-			Premium = TAG_PREMIUM.GOLDEN
-		};
-		Network.CardUserData item2 = new Network.CardUserData
-		{
-			DbId = cardUserData.DbId,
-			Count = ((!deleted) ? deckSlot.GetCount(TAG_PREMIUM.SIGNATURE) : 0),
-			Premium = TAG_PREMIUM.SIGNATURE
-		};
-		Network.CardUserData item3 = new Network.CardUserData
-		{
-			DbId = cardUserData.DbId,
-			Count = ((!deleted) ? deckSlot.GetCount(TAG_PREMIUM.DIAMOND) : 0),
-			Premium = TAG_PREMIUM.DIAMOND
-		};
-		list.Add(cardUserData);
-		list.Add(item);
-		list.Add(item2);
-		list.Add(item3);
-		return list;
-	}
+    {
+        List<Network.CardUserData> list = new List<Network.CardUserData>();
+        Network.CardUserData cardUserData = new Network.CardUserData
+        {
+            DbId = GameUtils.TranslateCardIdToDbId(deckSlot.CardID),
+            Count = ((!deleted) ? deckSlot.GetCount(TAG_PREMIUM.NORMAL) : 0),
+            Premium = TAG_PREMIUM.NORMAL
+        };
+        Network.CardUserData item = new Network.CardUserData
+        {
+            DbId = cardUserData.DbId,
+            Count = ((!deleted) ? deckSlot.GetCount(TAG_PREMIUM.GOLDEN) : 0),
+            Premium = TAG_PREMIUM.GOLDEN
+        };
+        Network.CardUserData item2 = new Network.CardUserData
+        {
+            DbId = cardUserData.DbId,
+            Count = ((!deleted) ? deckSlot.GetCount(TAG_PREMIUM.SIGNATURE) : 0),
+            Premium = TAG_PREMIUM.SIGNATURE
+        };
+        Network.CardUserData item3 = new Network.CardUserData
+        {
+            DbId = cardUserData.DbId,
+            Count = ((!deleted) ? deckSlot.GetCount(TAG_PREMIUM.DIAMOND) : 0),
+            Premium = TAG_PREMIUM.DIAMOND
+        };
+        list.Add(cardUserData);
+        list.Add(item);
+        list.Add(item2);
+        list.Add(item3);
+        return list;
+    }
 
 	private static List<Network.SideboardCardUserData> GetSideboardCardUserDataFromSlot(int linkedCardDbId, CollectionDeckSlot deckSlot, bool deleted)
 	{
@@ -1742,86 +1742,86 @@ public class CollectionDeck
 	}
 
 	private static List<Network.CardUserData> GenerateContentChanges(CollectionDeck originalDeck, CollectionDeck editedDeck)
-	{
-		SortedDictionary<string, CollectionDeckSlot> sortedDictionary = new SortedDictionary<string, CollectionDeckSlot>();
+    {
+        SortedDictionary<string, CollectionDeckSlot> sortedDictionary = new SortedDictionary<string, CollectionDeckSlot>();
 		foreach (CollectionDeckSlot slot in originalDeck.GetSlots())
-		{
-			CollectionDeckSlot value = null;
-			if (sortedDictionary.TryGetValue(slot.CardID, out value))
-			{
-				foreach (TAG_PREMIUM value7 in Enum.GetValues(typeof(TAG_PREMIUM)))
-				{
-					value.AddCard(slot.GetCount(value7), value7);
-				}
-			}
-			else
-			{
-				value = new CollectionDeckSlot();
-				value.CopyFrom(slot);
-				sortedDictionary.Add(value.CardID, value);
-			}
-		}
-		SortedDictionary<string, CollectionDeckSlot> sortedDictionary2 = new SortedDictionary<string, CollectionDeckSlot>();
+        {
+            CollectionDeckSlot value = null;
+            if (sortedDictionary.TryGetValue(slot.CardID, out value))
+            {
+                foreach (TAG_PREMIUM value7 in Enum.GetValues(typeof(TAG_PREMIUM)))
+                {
+                    value.AddCard(slot.GetCount(value7), value7);
+                }
+            }
+            else
+            {
+                value = new CollectionDeckSlot();
+                value.CopyFrom(slot);
+                sortedDictionary.Add(value.CardID, value);
+            }
+        }
+        SortedDictionary<string, CollectionDeckSlot> sortedDictionary2 = new SortedDictionary<string, CollectionDeckSlot>();
 		foreach (CollectionDeckSlot slot2 in editedDeck.GetSlots())
-		{
-			CollectionDeckSlot value2 = null;
-			if (sortedDictionary2.TryGetValue(slot2.CardID, out value2))
-			{
-				foreach (TAG_PREMIUM value8 in Enum.GetValues(typeof(TAG_PREMIUM)))
-				{
-					value2.AddCard(slot2.GetCount(value8), value8);
-				}
-			}
-			else
-			{
-				value2 = new CollectionDeckSlot();
-				value2.CopyFrom(slot2);
-				sortedDictionary2.Add(value2.CardID, value2);
-			}
-		}
-		SortedDictionary<string, CollectionDeckSlot>.Enumerator enumerator3 = sortedDictionary.GetEnumerator();
-		SortedDictionary<string, CollectionDeckSlot>.Enumerator enumerator4 = sortedDictionary2.GetEnumerator();
-		List<Network.CardUserData> list = new List<Network.CardUserData>();
-		bool flag = enumerator3.MoveNext();
-		bool flag2 = enumerator4.MoveNext();
-		while (flag && flag2)
-		{
-			CollectionDeckSlot value3 = enumerator3.Current.Value;
-			CollectionDeckSlot value4 = enumerator4.Current.Value;
-			if (value3.CardID == value4.CardID)
-			{
+        {
+            CollectionDeckSlot value2 = null;
+            if (sortedDictionary2.TryGetValue(slot2.CardID, out value2))
+            {
+                foreach (TAG_PREMIUM value8 in Enum.GetValues(typeof(TAG_PREMIUM)))
+                {
+                    value2.AddCard(slot2.GetCount(value8), value8);
+                }
+            }
+            else
+            {
+                value2 = new CollectionDeckSlot();
+                value2.CopyFrom(slot2);
+                sortedDictionary2.Add(value2.CardID, value2);
+            }
+        }
+        SortedDictionary<string, CollectionDeckSlot>.Enumerator enumerator3 = sortedDictionary.GetEnumerator();
+        SortedDictionary<string, CollectionDeckSlot>.Enumerator enumerator4 = sortedDictionary2.GetEnumerator();
+        List<Network.CardUserData> list = new List<Network.CardUserData>();
+        bool flag = enumerator3.MoveNext();
+        bool flag2 = enumerator4.MoveNext();
+        while (flag && flag2)
+        {
+            CollectionDeckSlot value3 = enumerator3.Current.Value;
+            CollectionDeckSlot value4 = enumerator4.Current.Value;
+            if (value3.CardID == value4.CardID)
+            {
 				if (value3.GetCount(TAG_PREMIUM.NORMAL) != value4.GetCount(TAG_PREMIUM.NORMAL) || value3.GetCount(TAG_PREMIUM.GOLDEN) != value4.GetCount(TAG_PREMIUM.GOLDEN) || value3.GetCount(TAG_PREMIUM.SIGNATURE) != value4.GetCount(TAG_PREMIUM.SIGNATURE) || value3.GetCount(TAG_PREMIUM.DIAMOND) != value4.GetCount(TAG_PREMIUM.DIAMOND) || value3.Owned != value4.Owned)
-				{
+                {
 					list.AddRange(GetCardUserDataFromSlot(value4, value4.Count == 0));
-				}
-				flag = enumerator3.MoveNext();
-				flag2 = enumerator4.MoveNext();
-			}
-			else if (value3.CardID.CompareTo(value4.CardID) < 0)
-			{
+                }
+                flag = enumerator3.MoveNext();
+                flag2 = enumerator4.MoveNext();
+            }
+            else if (value3.CardID.CompareTo(value4.CardID) < 0)
+            {
 				list.AddRange(GetCardUserDataFromSlot(value3, deleted: true));
-				flag = enumerator3.MoveNext();
-			}
-			else
-			{
+                flag = enumerator3.MoveNext();
+            }
+            else
+            {
 				list.AddRange(GetCardUserDataFromSlot(value4, deleted: false));
-				flag2 = enumerator4.MoveNext();
-			}
-		}
-		while (flag)
-		{
-			CollectionDeckSlot value5 = enumerator3.Current.Value;
+                flag2 = enumerator4.MoveNext();
+            }
+        }
+        while (flag)
+        {
+            CollectionDeckSlot value5 = enumerator3.Current.Value;
 			list.AddRange(GetCardUserDataFromSlot(value5, deleted: true));
-			flag = enumerator3.MoveNext();
-		}
-		while (flag2)
-		{
-			CollectionDeckSlot value6 = enumerator4.Current.Value;
+            flag = enumerator3.MoveNext();
+        }
+        while (flag2)
+        {
+            CollectionDeckSlot value6 = enumerator4.Current.Value;
 			list.AddRange(GetCardUserDataFromSlot(value6, deleted: false));
-			flag2 = enumerator4.MoveNext();
-		}
-		return list;
-	}
+            flag2 = enumerator4.MoveNext();
+        }
+        return list;
+    }
 
 	private static List<Network.SideboardCardUserData> GenerateSideboardContentChanges(CollectionDeck originalDeck, CollectionDeck editedDeck)
 	{
@@ -1849,137 +1849,137 @@ public class CollectionDeck
 					}
 					continue;
 				}
-				foreach (CollectionDeckSlot slot in value.GetSlots())
-				{
-					foreach (Network.CardUserData item3 in GetCardUserDataFromSlot(slot, deleted: false))
+					foreach (CollectionDeckSlot slot in value.GetSlots())
 					{
-						list.Add(new Network.SideboardCardUserData
+						foreach (Network.CardUserData item3 in GetCardUserDataFromSlot(slot, deleted: false))
 						{
-							Card = item3,
-							LinkedCardDbId = value.OwnerCardDbId
-						});
+							list.Add(new Network.SideboardCardUserData
+							{
+								Card = item3,
+								LinkedCardDbId = value.OwnerCardDbId
+							});
+						}
 					}
 				}
 			}
-		}
 		else
 		{
-			foreach (KeyValuePair<string, SideboardDeck> item4 in allSideboards)
-			{
-				foreach (CollectionDeckSlot slot2 in item4.Value.GetSlots())
-				{
-					list.AddRange(GetSideboardCardUserDataFromSlot(item4.Value.OwnerCardDbId, slot2, deleted: true));
-				}
-			}
-		}
-		return list;
-	}
-
-	private int GetInsertionIdxByDefaultSort(CollectionDeckSlot slot)
-	{
-		EntityDef entityDef = slot.GetEntityDef();
-		if (entityDef == null)
-		{
-			Log.Decks.Print($"CollectionDeck.GetInsertionIdxByDefaultSort(): could not get entity def for {slot.CardID}");
-			return -1;
-		}
-		int i;
-		for (i = 0; i < GetSlotCount(); i++)
+		foreach (KeyValuePair<string, SideboardDeck> item4 in allSideboards)
 		{
-			CollectionDeckSlot slotByIndex = GetSlotByIndex(i);
-			EntityDef entityDef2 = slotByIndex.GetEntityDef();
-			if (entityDef2 == null)
-			{
-				Log.Decks.Print($"CollectionDeck.GetInsertionIdxByDefaultSort(): entityDef is null at slot index {i}");
-				break;
-			}
-			int num = CollectionManager.EntityDefSortComparison(entityDef, entityDef2);
-			if (num < 0 || (num <= 0 && (!ShouldSplitSlotsByOwnershipOrFormatValidity() || slot.Owned == slotByIndex.Owned)))
+			foreach (CollectionDeckSlot slot2 in item4.Value.GetSlots())
 			{
-				break;
+				list.AddRange(GetSideboardCardUserDataFromSlot(item4.Value.OwnerCardDbId, slot2, deleted: true));
 			}
 		}
-		return i;
-	}
-
-	public TAG_CLASS GetClass()
-	{
-		return DefLoader.Get().GetEntityDef(HeroCardID)?.GetClass() ?? TAG_CLASS.INVALID;
-	}
-
-	public List<TAG_CLASS> GetClasses()
-	{
-		EntityDef entityDef = DefLoader.Get().GetEntityDef(HeroCardID);
-		List<TAG_CLASS> list = new List<TAG_CLASS>();
-		if (entityDef == null)
-		{
-			list.Clear();
-			list.Add(TAG_CLASS.INVALID);
-			return list;
 		}
-		entityDef.GetClasses(list);
 		return list;
 	}
 
-	public bool HasClass(TAG_CLASS tagClass)
-	{
-		foreach (TAG_CLASS @class in GetClasses())
-		{
-			if (@class == tagClass)
-			{
-				return true;
-			}
-		}
-		return false;
-	}
-
-	public ShareableDeck GetShareableDeck()
-	{
-		DeckContents deckContents = GetDeckContents();
-		int heroCardDbId = GameUtils.TranslateCardIdToDbId(HeroCardID);
-		return new ShareableDeck(Name, heroCardDbId, deckContents, FormatType, Type == DeckType.DRAFT_DECK);
-	}
-
-	public bool CanCopyAsShareableDeck(out DeckRuleViolation topViolation)
-	{
-		topViolation = null;
-		if (GetRuleset() != null)
-		{
-			if (!GetRuleset().IsDeckValid(this, out var violations) && violations != null && violations.Count > 0)
-			{
-				topViolation = violations[0];
-				return false;
-			}
-			return true;
-		}
-		return false;
-	}
-
-	public void LogDeckStringInformation()
-	{
-		Log.Decks.PrintInfo(string.Format("{0} {1}", "###", Name));
-		Log.Decks.PrintInfo(string.Format("{0}Deck ID: {1}", "# ", ID));
-		Log.Decks.PrintInfo(GetShareableDeck().Serialize(includeComments: false));
-	}
-
-	public DeckContents GetDeckContents()
-	{
-		DeckContents deckContents = new DeckContents
-		{
-			DeckId = ID
-		};
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			DeckCardData item = new DeckCardData
-			{
-				Def = new PegasusShared.CardDef
-				{
-					Asset = GameUtils.TranslateCardIdToDbId(slot.CardID),
-					Premium = (int)slot.PreferredPremium
-				},
-				Qty = slot.Count
-			};
-			deckContents.Cards.Add(item);
+    private int GetInsertionIdxByDefaultSort(CollectionDeckSlot slot)
+    {
+        EntityDef entityDef = slot.GetEntityDef();
+        if (entityDef == null)
+        {
+            Log.Decks.Print($"CollectionDeck.GetInsertionIdxByDefaultSort(): could not get entity def for {slot.CardID}");
+            return -1;
+        }
+        int i;
+        for (i = 0; i < GetSlotCount(); i++)
+        {
+            CollectionDeckSlot slotByIndex = GetSlotByIndex(i);
+            EntityDef entityDef2 = slotByIndex.GetEntityDef();
+            if (entityDef2 == null)
+            {
+                Log.Decks.Print($"CollectionDeck.GetInsertionIdxByDefaultSort(): entityDef is null at slot index {i}");
+                break;
+            }
+            int num = CollectionManager.EntityDefSortComparison(entityDef, entityDef2);
+            if (num < 0 || (num <= 0 && (!ShouldSplitSlotsByOwnershipOrFormatValidity() || slot.Owned == slotByIndex.Owned)))
+            {
+                break;
+            }
+        }
+        return i;
+    }
+
+    public TAG_CLASS GetClass()
+    {
+        return DefLoader.Get().GetEntityDef(HeroCardID)?.GetClass() ?? TAG_CLASS.INVALID;
+    }
+
+    public List<TAG_CLASS> GetClasses()
+    {
+        EntityDef entityDef = DefLoader.Get().GetEntityDef(HeroCardID);
+        List<TAG_CLASS> list = new List<TAG_CLASS>();
+        if (entityDef == null)
+        {
+            list.Clear();
+            list.Add(TAG_CLASS.INVALID);
+            return list;
+        }
+        entityDef.GetClasses(list);
+        return list;
+    }
+
+    public bool HasClass(TAG_CLASS tagClass)
+    {
+        foreach (TAG_CLASS @class in GetClasses())
+        {
+            if (@class == tagClass)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public ShareableDeck GetShareableDeck()
+    {
+        DeckContents deckContents = GetDeckContents();
+        int heroCardDbId = GameUtils.TranslateCardIdToDbId(HeroCardID);
+        return new ShareableDeck(Name, heroCardDbId, deckContents, FormatType, Type == DeckType.DRAFT_DECK);
+    }
+
+    public bool CanCopyAsShareableDeck(out DeckRuleViolation topViolation)
+    {
+        topViolation = null;
+        if (GetRuleset() != null)
+        {
+            if (!GetRuleset().IsDeckValid(this, out var violations) && violations != null && violations.Count > 0)
+            {
+                topViolation = violations[0];
+                return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public void LogDeckStringInformation()
+    {
+        Log.Decks.PrintInfo(string.Format("{0} {1}", "###", Name));
+        Log.Decks.PrintInfo(string.Format("{0}Deck ID: {1}", "# ", ID));
+        Log.Decks.PrintInfo(GetShareableDeck().Serialize(includeComments: false));
+    }
+
+    public DeckContents GetDeckContents()
+    {
+        DeckContents deckContents = new DeckContents
+        {
+            DeckId = ID
+        };
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            DeckCardData item = new DeckCardData
+            {
+                Def = new PegasusShared.CardDef
+                {
+                    Asset = GameUtils.TranslateCardIdToDbId(slot.CardID),
+                    Premium = (int)slot.PreferredPremium
+                },
+                Qty = slot.Count
+            };
+            deckContents.Cards.Add(item);
 			SideboardDeck sideboard = m_sideboardManager.GetSideboard(slot.CardID);
 			if (sideboard == null)
 			{
@@ -1999,52 +1999,52 @@ public class CollectionDeck
 				sideBoardCardData.LinkedCardDbId = GameUtils.TranslateCardIdToDbId(slot.CardID);
 				deckContents.SideboardCards.Add(sideBoardCardData);
 			}
-		}
-		return deckContents;
-	}
-
-	public bool ShouldSplitSlotsByOwnershipOrFormatValidity()
-	{
-		if (Locked)
-		{
-			return false;
-		}
-		switch (Type)
-		{
-		case DeckType.CLIENT_ONLY_DECK:
-		case DeckType.DRAFT_DECK:
-			return false;
-		case DeckType.TAVERN_BRAWL_DECK:
-		case DeckType.FSG_BRAWL_DECK:
-			if (TavernBrawlManager.Get().IsCurrentBrawlTypeActive && TavernBrawlManager.Get().GetCurrentDeckRuleset() != null && TavernBrawlManager.Get().GetCurrentDeckRuleset().HasOwnershipOrRotatedRule())
-			{
-				return true;
-			}
-			return false;
-		default:
-			return true;
-		}
-	}
-
-	public bool CanAddRunes(RunePattern runesToAdd, int maxRuneSlots)
-	{
-		return Runes.CanAddRunes(runesToAdd, maxRuneSlots);
-	}
-
-	public bool ContainsDeathKnightRuneCards()
-	{
-		RunePattern runePattern = default(RunePattern);
-		foreach (CollectionDeckSlot slot in m_slots)
-		{
-			EntityDef entityDef = DefLoader.Get().GetEntityDef(slot.CardID);
-			runePattern.SetCostsFromEntity(entityDef);
-			if (runePattern.HasRunes)
-			{
-				return true;
-			}
-		}
-		return false;
-	}
+        }
+        return deckContents;
+    }
+
+    public bool ShouldSplitSlotsByOwnershipOrFormatValidity()
+    {
+        if (Locked)
+        {
+            return false;
+        }
+        switch (Type)
+        {
+            case DeckType.CLIENT_ONLY_DECK:
+            case DeckType.DRAFT_DECK:
+                return false;
+            case DeckType.TAVERN_BRAWL_DECK:
+            case DeckType.FSG_BRAWL_DECK:
+                if (TavernBrawlManager.Get().IsCurrentBrawlTypeActive && TavernBrawlManager.Get().GetCurrentDeckRuleset() != null && TavernBrawlManager.Get().GetCurrentDeckRuleset().HasOwnershipOrRotatedRule())
+                {
+                    return true;
+                }
+                return false;
+            default:
+                return true;
+        }
+    }
+
+    public bool CanAddRunes(RunePattern runesToAdd, int maxRuneSlots)
+    {
+        return Runes.CanAddRunes(runesToAdd, maxRuneSlots);
+    }
+
+    public bool ContainsDeathKnightRuneCards()
+    {
+        RunePattern runePattern = default(RunePattern);
+        foreach (CollectionDeckSlot slot in m_slots)
+        {
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(slot.CardID);
+            runePattern.SetCostsFromEntity(entityDef);
+            if (runePattern.HasRunes)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
 
 	public void AddSlots(List<CollectionDeckSlot> slots)
 	{
diff --git a/Assembly-CSharp/CollectionDeckBoxVisual.cs b/Assembly-CSharp/CollectionDeckBoxVisual.cs
index d7fdacb..9307250 100644
--- a/Assembly-CSharp/CollectionDeckBoxVisual.cs
+++ b/Assembly-CSharp/CollectionDeckBoxVisual.cs
@@ -6,6 +6,7 @@ using Blizzard.T5.MaterialService.Extensions;
 using Blizzard.T5.Services;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionDeckBoxVisual : PegUIElement, IDraggableCollectionVisual
@@ -186,7 +187,7 @@ public class CollectionDeckBoxVisual : PegUIElement, IDraggableCollectionVisual
 
 	private bool m_showBanner = true;
 
-	private bool m_isShowingInvalidCardCount;
+	internal bool m_isShowingInvalidCardCount;
 
 	private CollectionDeck.CardCountByStatus m_cardCountByStatus;
 
@@ -1288,6 +1289,10 @@ public class CollectionDeckBoxVisual : PegUIElement, IDraggableCollectionVisual
 				DecksContent.DeleteDeck(GetDeckID());
 			}
 		}
+		else
+        {
+			AccessibleCollectionManager.Get().OnDeleteDeckCanceled();
+        }
 	}
 
 	private void PlayPopAnimation(string animationName)
@@ -1836,4 +1841,11 @@ public class CollectionDeckBoxVisual : PegUIElement, IDraggableCollectionVisual
 		}
 		return true;
 	}
+
+	#region Accessibility
+	public TAG_CLASS GetClass()
+	{
+		return (m_fullDef?.EntityDef)?.GetClass() ?? TAG_CLASS.INVALID;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/CollectionDeckTray.cs b/Assembly-CSharp/CollectionDeckTray.cs
index e11a7d2..b01ac51 100644
--- a/Assembly-CSharp/CollectionDeckTray.cs
+++ b/Assembly-CSharp/CollectionDeckTray.cs
@@ -6,6 +6,7 @@ using Cysharp.Threading.Tasks;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class CollectionDeckTray : EditableDeckTray
 {
@@ -381,15 +382,16 @@ public class CollectionDeckTray : EditableDeckTray
 				pageManager.UpdateVisibleTabs();
 				pageManager.FlipToPage(1, null, null);
 			}
-			if (!UniversalInputManager.UsePhoneUI && m_scrollbar != null)
-			{
-				m_scrollbar.EnableIfNeeded();
-			}
+		if (!UniversalInputManager.UsePhoneUI && m_scrollbar != null)
+		{
+			m_scrollbar.EnableIfNeeded();
+		}
 			CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks(playSound: true);
+		AccessibleCollectionManager.Get().OnSideboardOpenedOrClosed(false);
 		}
 	}
 
-	private void OnDeckTileSideboardButtonPressed(CollectionDeckTileActor deckTile)
+	internal void OnDeckTileSideboardButtonPressed(CollectionDeckTileActor deckTile)
 	{
 		EntityDef entityDef = deckTile.GetEntityDef();
 		if (entityDef == null)
@@ -412,12 +414,13 @@ public class CollectionDeckTray : EditableDeckTray
 				SideboardDeck sideboardDeck2 = editedDeck.SetEditedSideboard(entityDef.GetCardId(), deckTile.GetPremium());
 				sideboardDeck2.DataModel.HighlightEditButton = false;
 				m_ETCsideboardTray.Show(sideboardDeck2);
-				CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks(playSound: true);
-				if (!UniversalInputManager.UsePhoneUI && m_scrollbar != null)
-				{
-					m_scrollbar.Enable(enable: false);
-				}
+			CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks(playSound: true);
+			if (!UniversalInputManager.UsePhoneUI && m_scrollbar != null)
+			{
+				m_scrollbar.Enable(enable: false);
 			}
+			AccessibleCollectionManager.Get().OnSideboardOpenedOrClosed(true);
+		}
 			break;
 		case TAG_SIDEBOARD_TYPE.ZILLIAX:
 			if ((bool)m_ZilliaxsideboardTray)
@@ -435,6 +438,8 @@ public class CollectionDeckTray : EditableDeckTray
 				{
 					m_scrollbar.Enable(enable: false);
 				}
+
+				AccessibleCollectionManager.Get().OnSideboardOpenedOrClosed(true);
 			}
 			break;
 		}
@@ -601,6 +606,7 @@ public class CollectionDeckTray : EditableDeckTray
 			m_sideboardCardPopup = notificationManager.CreatePopupText(UserAttentionBlocker.NONE, position, SideboardPopupScale * Vector3.one, popupText);
 			m_sideboardCardPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
 			NotificationManager.Get().DestroyNotification(m_sideboardCardPopup, SideboardPopupDelay);
+			AccessibilityMgr.Output(null, LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_ETC_TUTORIAL));
 		}
 	}
 
@@ -978,16 +984,20 @@ public class CollectionDeckTray : EditableDeckTray
 		m_runeIndicatorVisual.EnableRuneButtons();
 		m_cardsContent.UpdateCardList();
 		CheckNumCardsNeededToBuildDeck(deck);
+		AccessibleCollectionManager.Get().PrepareToEditDeck();
 		CollectionManager.Get().StartEditingDeck(deck, isNewDeck);
 	}
 
 	public void ExitEditDeckModeForTavernBrawl()
 	{
 		UpdateDoneButtonText();
+
+		AccessibleCollectionManager.Get().OnDoneEditingDeck();
 	}
 
 	public void EnterDeckEditForPVPDR(CollectionDeck deck)
 	{
+		AccessibleCollectionManager.Get().PrepareToEditDeck();
 		CollectionManager.Get().SetEditedDeck(deck);
 		CollectionManagerDisplay obj = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
 		obj.ShowDuelsDeckHeader();
@@ -1175,31 +1185,31 @@ public class CollectionDeckTray : EditableDeckTray
 		{
 			return;
 		}
-		if (m_runeIndicatorVisual != null)
-		{
-			if (TavernBrawlDisplay.IsTavernBrawlOpen())
+			if (m_runeIndicatorVisual != null)
 			{
-				m_runeIndicatorVisual.DisableRuneButtons();
+				if (TavernBrawlDisplay.IsTavernBrawlOpen())
+				{
+					m_runeIndicatorVisual.DisableRuneButtons();
+				}
+				else
+				{
+					m_runeIndicatorVisual.Hide();
+					m_cardsContent.SetRuneIndicatorSpacerVisible(visible: false);
+					m_runeIndicatorVisual.EnableRuneButtons();
+				}
 			}
-			else
+			if (!UniversalInputManager.UsePhoneUI && CollectionManager.Get().IsEditingDeathKnightDeck())
 			{
-				m_runeIndicatorVisual.Hide();
-				m_cardsContent.SetRuneIndicatorSpacerVisible(visible: false);
-				m_runeIndicatorVisual.EnableRuneButtons();
-			}
-		}
-		if (!UniversalInputManager.UsePhoneUI && CollectionManager.Get().IsEditingDeathKnightDeck())
-		{
-			CollectionDeckBoxVisual editingDeckBox = GetEditingDeckBox();
-			if ((bool)editingDeckBox)
-			{
-				editingDeckBox.ResetColliderHeight();
+				CollectionDeckBoxVisual editingDeckBox = GetEditingDeckBox();
+				if ((bool)editingDeckBox)
+				{
+					editingDeckBox.ResetColliderHeight();
+				}
 			}
 		}
-	}
 
 	private SideboardDeck GetIncompleteSideboard()
-	{
+		{
 		CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
 		if (editedDeck == null)
 		{
@@ -1264,7 +1274,7 @@ public class CollectionDeckTray : EditableDeckTray
 		{
 			flag = deckRuleset.IsDeckValid(editedDeck);
 		}
-		if (editedDeck.FormatType == FormatType.FT_STANDARD && flag && CollectionManager.Get().ShouldShowWildToStandardTutorial(checkPrevSceneIsPlayMode: false) && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionDeckTray.OnBackOutOfDeckContentsImpl:ShowSetRotationTutorial"))
+		if (editedDeck.FormatType == FormatType.FT_STANDARD && flag && CollectionManager.Get().ShouldShowWildToStandardTutorial(checkPrevSceneIsPlayMode: false) && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionDeckTray.OnBackOutOfDeckContentsImpl:ShowSetRotationTutorial"))
 		{
 			Options.Get().SetBool(Option.NEEDS_TO_MAKE_STANDARD_DECK, val: false);
 			Options.Get().SetLong(Option.LAST_CUSTOM_DECK_CHOSEN, editedDeck.ID);
@@ -1273,7 +1283,7 @@ public class CollectionDeckTray : EditableDeckTray
 			Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, relativePosition, NotificationManager.NOTIFICATITON_WORLD_SCALE, GameStrings.Get("GLUE_COLLECTION_TUTORIAL16"), convertLegacyPosition: false);
 			notification.ShowPopUpArrow(Notification.PopUpArrowDirection.RightDown);
 			notification.PulseReminderEveryXSeconds(3f);
-			UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+			UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 			m_doneButton.GetComponentInChildren<HighlightState>().ChangeState(ActorStateType.HIGHLIGHT_PRIMARY_ACTIVE);
 		}
 		SaveCurrentDeckAndEnterDeckListMode();
@@ -1614,6 +1624,7 @@ public class CollectionDeckTray : EditableDeckTray
 		CollectionManager.Get().GetCollectibleDisplay().EnableInput(enable: true);
 		AllowInput(allowed: true);
 		completedCallback?.Invoke(addedCards, removedCards);
+		AccessibleCollectionManager.Get().OnFinishAutoAddCardsWithTiming();
 	}
 
 	public void PopulateTeam(IEnumerable<LettuceCollectionDisplay.TeamCopyingModule.TeamFill> fillCards, PopuplateDeckCompleteCallback completedCallback)
@@ -1870,11 +1881,13 @@ public class CollectionDeckTray : EditableDeckTray
 			HideDeckBigCard(cardTile);
 			return;
 		}
+		/* This is not accessible at the moment.
 		CollectionDeckSlot slot = cardTile.GetSlot();
 		if (!currentDeckContext.IsValidSlot(slot, ignoreOwnership: false, ignoreGameplayEvent: false, enforceRemainingDeckRuleset: true))
 		{
 			m_cardsContent.ShowDeckHelper(slot, replaceSingleSlotOnly: true);
 		}
+		*/
 		else if (!(CollectionInputMgr.Get() == null) && !TavernBrawlDisplay.IsTavernBrawlViewing())
 		{
 			CollectionDeckTileActor actor = cardTile.GetActor();
@@ -1947,17 +1960,17 @@ public class CollectionDeckTray : EditableDeckTray
 	private void ShowDeckBigCardForCardDef(DefLoader.DisposableCardDef cardDef, EntityDef entityDef, CollectionDeckTileActor actor, DeckTrayDeckTileVisual cardTile, float delay)
 	{
 		GhostCard.Type ghostTypeFromSlot = GhostCard.GetGhostTypeFromSlot(GetCurrentDeckContext(), cardTile.GetSlot());
-		m_deckBigCard.Show(entityDef, actor.GetPremium(), cardDef, actor.gameObject.transform.position, ghostTypeFromSlot, delay);
-		if (UniversalInputManager.Get().IsTouchMode())
-		{
-			cardTile.SetHighlight(highlight: true);
-		}
-		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (collectionManagerDisplay != null && collectionManagerDisplay.m_deckTemplateCardReplacePopup != null)
-		{
-			collectionManagerDisplay.m_deckTemplateCardReplacePopup.Shrink(0.1f);
+			m_deckBigCard.Show(entityDef, actor.GetPremium(), cardDef, actor.gameObject.transform.position, ghostTypeFromSlot, delay);
+			if (UniversalInputManager.Get().IsTouchMode())
+			{
+				cardTile.SetHighlight(highlight: true);
+			}
+			CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+			if (collectionManagerDisplay != null && collectionManagerDisplay.m_deckTemplateCardReplacePopup != null)
+			{
+				collectionManagerDisplay.m_deckTemplateCardReplacePopup.Shrink(0.1f);
+			}
 		}
-	}
 
 	protected override void HideDeckBigCard(DeckTrayDeckTileVisual cardTile, bool force = false)
 	{
@@ -2158,4 +2171,11 @@ public class CollectionDeckTray : EditableDeckTray
 		}
 		return m_ZilliaxsideboardTray.SavedZilliaxVersions;
 	}
+
+	#region Accessibility
+	internal bool IsZilliaxSideboardOpen()
+	{
+		return IsSideboardOpen && m_currentSideboardTray is ZilliaxDeckSideboardTray;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/CollectionHeroPickerButtons.cs b/Assembly-CSharp/CollectionHeroPickerButtons.cs
index 0682793..d290fea 100644
--- a/Assembly-CSharp/CollectionHeroPickerButtons.cs
+++ b/Assembly-CSharp/CollectionHeroPickerButtons.cs
@@ -2,6 +2,7 @@ using System.Collections.Generic;
 using Blizzard.T5.Core;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionHeroPickerButtons : AbsHeroPickerButtons
@@ -29,6 +30,17 @@ public class CollectionHeroPickerButtons : AbsHeroPickerButtons
 		GenerateHeroCounters();
 	}
 
+	public override void Show()
+	{
+		base.Show();
+		AccessibleCollectionManager.Get().OnBrowsingHeroSkinClasses();
+	}
+
+	public override void Hide()
+	{
+		base.Hide();
+	}
+
 	private void GenerateHeroCounters()
 	{
 		m_heroClasses = new List<TAG_CLASS>(GameUtils.ORDERED_HERO_CLASSES);
diff --git a/Assembly-CSharp/CollectionInputMgr.cs b/Assembly-CSharp/CollectionInputMgr.cs
index 0f864ae..185ae9d 100644
--- a/Assembly-CSharp/CollectionInputMgr.cs
+++ b/Assembly-CSharp/CollectionInputMgr.cs
@@ -74,7 +74,7 @@ public class CollectionInputMgr : InputMgr
 		return false;
 	}
 
-	public static void PasteDeckFromClipboard()
+    public static void PasteDeckFromClipboard()
 	{
 		ShareableDeck shareableDeck = ShareableDeck.DeserializeFromClipboard();
 		if (shareableDeck != null)
@@ -392,7 +392,7 @@ public class CollectionInputMgr : InputMgr
 	{
 		if (dataModel == null)
 		{
-			Log.Lettuce.PrintWarning("CollectionInputMgr.SetHeldMercenaryCard - input data model is not valid!");
+			Log.Lettuce.PrintWarning("CollectionInputMgr.SetHeldMercenaryCard - input data model is not valid!", Array.Empty<object>());
 			return;
 		}
 		m_heldType = cardType;
@@ -401,7 +401,7 @@ public class CollectionInputMgr : InputMgr
 		case CollectionUtils.MercenariesModeCardType.Mercenary:
 			if (!(dataModel is LettuceMercenaryDataModel lettuceMercenaryDataModel))
 			{
-				Log.Lettuce.PrintWarning("CollectionInputMgr.SetHeldMercenaryCard - mercenary data model is not valid!");
+				Log.Lettuce.PrintWarning("CollectionInputMgr.SetHeldMercenaryCard - mercenary data model is not valid!", Array.Empty<object>());
 			}
 			else
 			{
@@ -410,17 +410,17 @@ public class CollectionInputMgr : InputMgr
 			break;
 		case CollectionUtils.MercenariesModeCardType.Equipment:
 			if (dataModel is LettuceAbilityDataModel { AbilityTiers: not null } lettuceAbilityDataModel)
+		{
+			LettuceAbilityTierDataModel lettuceAbilityTierDataModel = lettuceAbilityDataModel.AbilityTiers[lettuceAbilityDataModel.CurrentTier - 1];
+			if (lettuceAbilityTierDataModel == null || lettuceAbilityTierDataModel.AbilityTierCard == null)
 			{
-				LettuceAbilityTierDataModel lettuceAbilityTierDataModel = lettuceAbilityDataModel.AbilityTiers[lettuceAbilityDataModel.CurrentTier - 1];
-				if (lettuceAbilityTierDataModel == null || lettuceAbilityTierDataModel.AbilityTierCard == null)
-				{
-					Log.Lettuce.PrintWarning("CollectionInputMgr.SetHeldMercenaryCard - ability tier data model is not valid!");
-				}
-				else
-				{
-					m_heldMercenariesModeCardId = lettuceAbilityTierDataModel.AbilityTierCard.CardId;
-				}
+				Log.Lettuce.PrintWarning("CollectionInputMgr.SetHeldMercenaryCard - ability tier data model is not valid!", Array.Empty<object>());
+			}
+			else
+			{
+				m_heldMercenariesModeCardId = lettuceAbilityTierDataModel.AbilityTierCard.CardId;
 			}
+		}
 			else
 			{
 				Log.Lettuce.PrintWarning("CollectionInputMgr.SetHeldMercenaryCard - ability data model is not valid!");
@@ -822,7 +822,7 @@ public class CollectionInputMgr : InputMgr
 					LettuceCollectionDisplay lettuceCollectionDisplay = CollectionManager.Get().GetCollectibleDisplay() as LettuceCollectionDisplay;
 					if (lettuceCollectionDisplay == null)
 					{
-						Log.Lettuce.PrintWarning("CollectionInputMgr.DropMercenariesModeCard - unable to find LettuceCollectionDisplay!");
+						Log.Lettuce.PrintWarning("CollectionInputMgr.DropMercenariesModeCard - unable to find LettuceCollectionDisplay!", Array.Empty<object>());
 						return;
 					}
 					lettuceCollectionDisplay.SlotEquipmentOnActiveMercenary(m_heldMercenariesModeCardId);
@@ -943,36 +943,7 @@ public class CollectionInputMgr : InputMgr
 		bool flag = CollectionDeckTray.Get().IsShowingDeckContents();
 		if (InputCollection.GetKeyDown(KeyCode.C) && flag)
 		{
-			CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-			if (editedDeck != null && UIStatus.Get() != null)
-			{
-				DeckRuleViolation topViolation = null;
-				bool flag2 = false;
-				if (SceneMgr.Get().IsInDuelsMode())
-				{
-					if (AdventureDungeonCrawlDisplay.Get() != null)
-					{
-						flag2 = AdventureDungeonCrawlDisplay.Get().IsDuelsDeckValid();
-					}
-				}
-				else
-				{
-					flag2 = editedDeck.CanCopyAsShareableDeck(out topViolation);
-				}
-				if (topViolation != null)
-				{
-					string userFriendlyCopyErrorMessageFromDeckRuleViolation = CollectionDeck.GetUserFriendlyCopyErrorMessageFromDeckRuleViolation(topViolation);
-					if (!string.IsNullOrEmpty(userFriendlyCopyErrorMessageFromDeckRuleViolation))
-					{
-						UIStatus.Get().AddInfo(userFriendlyCopyErrorMessageFromDeckRuleViolation);
-					}
-				}
-				if (flag2)
-				{
-					ClipboardUtils.CopyToClipboard(editedDeck.GetShareableDeck().Serialize());
-					UIStatus.Get().AddInfo(GameStrings.Get("GLUE_COLLECTION_DECK_COPIED_TOAST"));
-				}
-			}
+				CopyEditedDeck();
 		}
 		if (!InputCollection.GetKeyDown(KeyCode.V))
 		{
@@ -1020,4 +991,42 @@ public class CollectionInputMgr : InputMgr
 			}
 		}
 	}
+
+    #region Accessibility
+    public void CopyEditedDeck()
+    {
+      // Used to export decks in the accessible menu
+			CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+			if (editedDeck != null && UIStatus.Get() != null)
+			{
+				DeckRuleViolation topViolation = null;
+				bool flag2 = false;
+				if (SceneMgr.Get().IsInDuelsMode())
+				{
+					if (AdventureDungeonCrawlDisplay.Get() != null)
+					{
+						flag2 = AdventureDungeonCrawlDisplay.Get().IsDuelsDeckValid();
+					}
+				}
+				else
+				{
+					flag2 = editedDeck.CanCopyAsShareableDeck(out topViolation);
+				}
+				if (topViolation != null)
+				{
+					string userFriendlyCopyErrorMessageFromDeckRuleViolation = CollectionDeck.GetUserFriendlyCopyErrorMessageFromDeckRuleViolation(topViolation);
+					if (!string.IsNullOrEmpty(userFriendlyCopyErrorMessageFromDeckRuleViolation))
+					{
+						UIStatus.Get().AddInfo(userFriendlyCopyErrorMessageFromDeckRuleViolation);
+					}
+				}
+				if (flag2)
+				{
+					ClipboardUtils.CopyToClipboard(editedDeck.GetShareableDeck().Serialize());
+					UIStatus.Get().AddInfo(GameStrings.Get("GLUE_COLLECTION_DECK_COPIED_TOAST"));
+				}
+			}
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/CollectionManager.cs b/Assembly-CSharp/CollectionManager.cs
index 83bda24..0e68a5c 100644
--- a/Assembly-CSharp/CollectionManager.cs
+++ b/Assembly-CSharp/CollectionManager.cs
@@ -17,6 +17,7 @@ using PegasusLettuce;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class CollectionManager
 {
@@ -421,8 +422,12 @@ public class CollectionManager
 
 	private bool m_accountHasWildCards;
 
+	private bool m_accountHasClassicCards;
+
 	private float m_lastSearchForWildCardsTime;
 
+	private float m_lastSearchForClassicCardsTime;
+
 	private List<Action> m_onNetCacheDecksProcessed = new List<Action>();
 
 	private Dictionary<long, DeckAutoFillCallback> m_smartDeckCallbackByDeckId = new Dictionary<long, DeckAutoFillCallback>();
@@ -1074,6 +1079,10 @@ public class CollectionManager
 		{
 			return netCacheCollection;
 		}
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			collection = AccessibleCraftingTestingUtils.AddFakeCards(collection);
+		}
 		List<string> list = new List<string>();
 		for (int i = 0; i < collection.Stacks.Count; i++)
 		{
@@ -1115,10 +1124,18 @@ public class CollectionManager
 		return netCacheCollection;
 	}
 
-	private void OnCardSale()
+	internal void OnCardSale()
 	{
-		Network.CardSaleResult cardSaleResult = Network.Get().GetCardSaleResult();
-		bool flag;
+		Network.CardSaleResult cardSaleResult;
+		if (AccessibleCraftingTestingUtils.IsTestingCrafting())
+		{
+			cardSaleResult = AccessibleCraftingTestingUtils.GetCardSaleResult();
+		}
+		else
+		{
+			cardSaleResult = Network.Get().GetCardSaleResult();
+		}
+		bool flag = false;
 		switch (cardSaleResult.Action)
 		{
 		case Network.CardSaleResult.SaleResult.CARD_WAS_SOLD:
@@ -1176,9 +1193,19 @@ public class CollectionManager
 		OnCollectionChanged();
 	}
 
-	private void OnMassDisenchantResponse()
+	internal void OnMassDisenchantResponse()
 	{
-		Network.MassDisenchantResponse massDisenchantResponse = Network.Get().GetMassDisenchantResponse();
+		Network.MassDisenchantResponse massDisenchantResponse;
+
+		if (AccessibleCraftingTestingUtils.IsTestingCrafting())
+		{
+			massDisenchantResponse = AccessibleCraftingTestingUtils.GetMassDisenchantResponse();
+		}
+		else
+		{
+			massDisenchantResponse = Network.Get().GetMassDisenchantResponse();
+		}
+
 		if (massDisenchantResponse.Amount == 0)
 		{
 			Debug.LogError("CollectionManager.OnMassDisenchantResponse(): Amount is 0. This means the backend failed to mass disenchant correctly.");
@@ -1204,6 +1231,8 @@ public class CollectionManager
 				array[i].Fire(heroClass, cardDefinition, isFavorite);
 			}
 		}
+
+		AccessibleCollectionManager.Get().OnFavoriteHeroSkinChanged();
 	}
 
 	private void OnPVPDRSessionInfoResponse()
@@ -1247,6 +1276,11 @@ public class CollectionManager
 		m_onNetCacheDecksProcessed.Remove(a);
 	}
 
+	public void OnFavoriteCardBackChanged(int newFavoriteCardBackID, bool isFavorite)
+	{
+		AccessibleCollectionManager.Get().OnFavoriteCardBackChanged(isFavorite);
+	}
+
 	public void OnFavoriteBattlegroundsGuideSkinChanged(BattlegroundsGuideSkinId? newFavoriteBattlegroundsGuideSkinID)
 	{
 	}
@@ -1440,21 +1474,21 @@ public class CollectionManager
 			if (netObject != null && netObject.Decks != null)
 			{
 				NetCache.DeckHeader deckHeader2 = netObject.Decks.Find((NetCache.DeckHeader deckHeader) => deckHeader.ID == deckID);
-				if (deckHeader2 != null)
-				{
-					RuneType[] runeOrder = deck.GetRuneOrder();
-					deckHeader2.HeroOverridden = deck.HeroOverridden;
-					deckHeader2.SeasonId = deck.SeasonId;
-					deckHeader2.BrawlLibraryItemId = deck.BrawlLibraryItemId;
-					deckHeader2.NeedsName = deck.NeedsName;
-					deckHeader2.FormatType = deck.FormatType;
-					deckHeader2.LastModified = DateTime.Now;
-					deckHeader2.Rune1 = runeOrder[0];
-					deckHeader2.Rune2 = runeOrder[1];
-					deckHeader2.Rune3 = runeOrder[2];
-				}
+			if (deckHeader2 != null)
+			{
+				RuneType[] runeOrder = deck.GetRuneOrder();
+				deckHeader2.HeroOverridden = deck.HeroOverridden;
+				deckHeader2.SeasonId = deck.SeasonId;
+				deckHeader2.BrawlLibraryItemId = deck.BrawlLibraryItemId;
+				deckHeader2.NeedsName = deck.NeedsName;
+				deckHeader2.FormatType = deck.FormatType;
+				deckHeader2.LastModified = DateTime.Now;
+				deckHeader2.Rune1 = runeOrder[0];
+				deckHeader2.Rune2 = runeOrder[1];
+				deckHeader2.Rune3 = runeOrder[2];
 			}
 		}
+		}
 		else
 		{
 			Log.CollectionManager.Print($"CollectionManager.OnDBAction(): overwriting deck that failed to update with base deck ({baseDeck.ID}:{baseDeck.Name})");
@@ -1610,14 +1644,14 @@ public class CollectionManager
 		if (netObject != null && netObject.Decks != null)
 		{
 			NetCache.DeckHeader deckHeader2 = netObject.Decks.Find((NetCache.DeckHeader deckHeader) => deckHeader.ID == deckId);
-			if (deckHeader2 != null)
-			{
-				deckHeader2.Name = newName;
-				deckHeader2.LastModified = DateTime.Now;
-			}
-			OfflineDataCache.RenameDeck(deckId, newName);
-			deck.OnNameChangeComplete();
+		if (deckHeader2 != null)
+		{
+			deckHeader2.Name = newName;
+			deckHeader2.LastModified = DateTime.Now;
 		}
+		OfflineDataCache.RenameDeck(deckId, newName);
+		deck.OnNameChangeComplete();
+	}
 	}
 
 	public static void Init()
@@ -1626,6 +1660,7 @@ public class CollectionManager
 		{
 			s_instance = new CollectionManager();
 			HearthstoneApplication.Get().WillReset += s_instance.WillReset;
+			NetCache.Get().FavoriteCardBackChanged += s_instance.OnFavoriteCardBackChanged;
 			NetCache.Get().FavoriteBattlegroundsGuideSkinChanged += s_instance.OnFavoriteBattlegroundsGuideSkinChanged;
 			s_instance.InitImpl();
 		}
@@ -1815,12 +1850,12 @@ public class CollectionManager
 				foreach (CounterpartCardsDbfRecord item6 in cardCounterpartCards)
 				{
 					CollectibleCard card2 = GetCard(GameUtils.TranslateDbIdToCardId(item6.DeckEquivalentCardId), card.PremiumType);
-					if (card2 != null && m_filterCardSet.Contains(card2.Set) && GetOwnedCardCountByFilterMask(card2.CardId, searchFilterMask) + ownedCardCountByFilterMask >= card.DefaultMaxCopiesPerDeck)
-					{
-						return false;
-					}
+				if (card2 != null && m_filterCardSet.Contains(card2.Set) && GetOwnedCardCountByFilterMask(card2.CardId, searchFilterMask) + ownedCardCountByFilterMask >= card.DefaultMaxCopiesPerDeck)
+				{
+					return false;
 				}
 			}
+			}
 			return true;
 		};
 		CollectibleCardFilterFunc item2 = delegate(CollectibleCard card)
@@ -2210,29 +2245,29 @@ public class CollectionManager
 			foreach (CounterpartCardsDbfRecord item in cardCounterpartCards)
 			{
 				CollectibleCard card = GetCard(GameUtils.TranslateDbIdToCardId(item.DeckEquivalentCardId), collectibleCard2.PremiumType);
-				if (card == null)
-				{
-					continue;
-				}
-				string text = null;
+			if (card == null)
+			{
+				continue;
+			}
+			string text = null;
 				if (collectibleCard2.Set == TAG_CARD_SET.CORE && collectibleCard2.OwnedCount == collectibleCard2.DefaultMaxCopiesPerDeck)
-				{
-					text = card.CardId;
-				}
-				else
-				{
+			{
+				text = card.CardId;
+			}
+			else
+			{
 					if ((collectibleCard2.OwnedCount == 1 && card.OwnedCount == 1) || ((collectibleCard2.Set == TAG_CARD_SET.CORE || collectibleCard2.Set == TAG_CARD_SET.WONDERS) && collectibleCard2.OwnedCount < card.OwnedCount) || card.Set == TAG_CARD_SET.CORE)
-					{
-						continue;
-					}
-					text = ((collectibleCard2.OwnedCount >= card.OwnedCount) ? card.CardId : collectibleCard2.CardId);
-				}
-				if (text != null)
 				{
-					hashSet.Add(new CollectibleCardIndex(text, collectibleCard2.PremiumType));
+					continue;
 				}
+				text = ((collectibleCard2.OwnedCount >= card.OwnedCount) ? card.CardId : collectibleCard2.CardId);
+			}
+			if (text != null)
+			{
+				hashSet.Add(new CollectibleCardIndex(text, collectibleCard2.PremiumType));
 			}
 		}
+		}
 		for (int num = collectibleCards.Count - 1; num > -1; num--)
 		{
 			CollectibleCard collectibleCard = collectibleCards[num];
@@ -2754,8 +2789,8 @@ public class CollectionManager
 		{
 			if (ownedCard.PremiumType != TAG_PREMIUM.SIGNATURE)
 			{
-				num += ownedCard.DisenchantCount;
-			}
+			num += ownedCard.DisenchantCount;
+		}
 		}
 		return num;
 	}
@@ -2799,7 +2834,7 @@ public class CollectionManager
 				RemoveCollectionCard(cardChange.cardID, cardChange.premium, cardChange.count);
 				break;
 			}
-		}
+	}
 		SendPendingDeckUpdates();
 		OnCollectionChanged();
 		AchieveManager.Get().ValidateAchievesNow();
@@ -2950,6 +2985,11 @@ public class CollectionManager
 
 	public bool ShouldAccountSeeStandardWild()
 	{
+		if (s_cheatUnlockedWild)
+		{
+			return true;
+		}
+
 		if (!RankMgr.Get().WildCardsAllowedInCurrentLeague())
 		{
 			return false;
@@ -2963,6 +3003,11 @@ public class CollectionManager
 
 	public bool AccountHasUnlockedWild()
 	{
+		if (s_cheatUnlockedWild)
+		{
+			return true;
+		}
+
 		long value = 0L;
 		if (!GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.PLAYER_FLAGS, GameSaveKeySubkeyId.PLAYER_FLAGS_UNLOCKED_WILD, out value))
 		{
@@ -3003,6 +3048,7 @@ public class CollectionManager
 		{
 			return true;
 		}
+
 		if (m_lastSearchForWildCardsTime > m_collectionLastModifiedTime)
 		{
 			return m_accountHasWildCards;
@@ -3012,18 +3058,35 @@ public class CollectionManager
 		return m_accountHasWildCards;
 	}
 
+	// A11y only
+
 	public int GetNumberOfWildDecks()
 	{
+		if (s_cheatFakingNumDecks)
+		{
+			return s_cheatNumWildDecks;
+		}
+
 		return m_decks.Values.Count((CollectionDeck deck) => deck.FormatType == FormatType.FT_WILD);
 	}
 
 	public int GetNumberOfStandardDecks()
 	{
+		if (s_cheatFakingNumDecks)
+		{
+			return s_cheatNumStandardDecks;
+		}
+
 		return m_decks.Values.Count((CollectionDeck deck) => deck.FormatType == FormatType.FT_STANDARD);
 	}
 
 	public int GetNumberOfTwistDecks()
 	{
+		if (s_cheatFakingNumDecks)
+		{
+			return s_cheatNumTwistDecks;
+		}
+
 		return m_decks.Values.Count((CollectionDeck deck) => deck.FormatType == FormatType.FT_TWIST);
 	}
 
@@ -3150,10 +3213,17 @@ public class CollectionManager
 		}
 		SetDeckRuleset(deckRuleset);
 		SetEditedDeck(deck, callbackData);
+
+		bool isNewDeck = callbackData is bool ? (bool)callbackData : false;
+		if (AccessibleCollectionManager.Get().m_willEditDeck) 
+		{
+			AccessibleCollectionManager.Get().OnStartEditingDeck(isNewDeck);
+		}
 	}
 
 	public void DoneEditing()
 	{
+		AccessibleCollectionManager.Get().OnDoneEditingDeck();
 		bool editMode = m_editMode;
 		m_editMode = false;
 		FriendChallengeMgr.Get().UpdateMyAvailability();
@@ -3561,7 +3631,7 @@ public class CollectionManager
 			if (entityDef.HasTag(GAME_TAG.DECK_RULE_MOD_DECK_SIZE))
 			{
 				num = entityDef.GetTag(GAME_TAG.DECK_RULE_MOD_DECK_SIZE);
-			}
+		}
 		}
 		int num3 = deck.GetTotalValidCardCount() + list.Count;
 		int num4 = num - num3;
@@ -3638,6 +3708,9 @@ public class CollectionManager
 
 	public bool ShouldShowWildToStandardTutorial(bool checkPrevSceneIsPlayMode = true)
 	{
+		// Prevent problems when using OCR
+		return false;
+
 		if (!ShouldAccountSeeStandardWild())
 		{
 			return false;
@@ -3785,6 +3858,7 @@ public class CollectionManager
 		}
 		BattlegroundsDataInit();
 		LettuceInitImpl();
+		Get().StartInitialMercenaryLoadIfRequired();
 		NetCache.Get().RegisterCollectionManager(OnNetCacheReady);
 		LoginManager.Get().OnAchievesLoaded += OnAchievesLoaded;
 	}
@@ -3796,6 +3870,7 @@ public class CollectionManager
 		m_collectionLoaded = false;
 		m_duelsSessionInfoLoaded = false;
 		HearthstoneApplication.Get().WillReset -= s_instance.WillReset;
+    NetCache.Get().FavoriteCardBackChanged -= s_instance.OnFavoriteCardBackChanged;
 		NetCache.Get().FavoriteBattlegroundsGuideSkinChanged -= s_instance.OnFavoriteBattlegroundsGuideSkinChanged;
 		NetCache.Get().RemoveUpdatedListener(typeof(NetCache.NetCacheDecks), s_instance.NetCache_OnDecksReceived);
 		if (HearthstoneApplication.IsInternal())
@@ -6167,18 +6242,88 @@ public class CollectionManager
 			{
 				break;
 			}
+			foreach (LettuceMercenary.ArtVariation artVariation in mercenary.m_artVariations)
 			{
-				foreach (LettuceMercenary.ArtVariation artVariation in mercenary.m_artVariations)
+				if (artVariation.m_premium == (TAG_PREMIUM)record.Premium && artVariation.m_record.ID == record.MercenaryArtVariationId)
 				{
-					if (artVariation.m_premium == (TAG_PREMIUM)record.Premium && artVariation.m_record.ID == record.MercenaryArtVariationId)
-					{
-						artVariation.m_acknowledged = true;
-						break;
-					}
+					artVariation.m_acknowledged = true;
+					break;
 				}
-				break;
 			}
 		}
+			break;
 		}
 	}
+
+    #region Accessibility
+    public bool IsDeleteDeckPending()
+    {
+		return m_pendingDeckDeleteList?.Count > 0;
+    }
+
+	public bool AccountCanSeeWild()
+	{
+		// ShouldAccountSeeStandardWild blocks if we're in apprentice as well
+		return ShouldAccountSeeStandardWild();
+	}
+
+	public bool AccountCanSeeTwist()
+	{
+		// ShouldAccountSeeStandardWild blocks if we're in apprentice as well
+		return ShouldAccountSeeStandardWild();
+	}
+
+	public bool AccountHasAnyValidDeck()
+	{
+		foreach (FormatType format in Enum.GetValues(typeof(FormatType)))
+		{
+			if (AccountHasValidDeck(format))
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	#region Accessibility Testing
+	private static bool s_cheatUnlockedWild;
+
+	private static bool s_cheatFakingNumDecks;
+
+	private static int s_cheatNumStandardDecks;
+	private static int s_cheatNumWildDecks;
+	private static int s_cheatNumClassicDecks;
+	private static int s_cheatNumTwistDecks;
+
+	internal static bool Cheat_IsNewPlayer()
+	{
+		// Need this for testing the format selection picker
+		return !s_cheatUnlockedWild;
+	}
+
+	internal static void Cheat_SetWildOverride(bool val)
+	{
+		s_cheatUnlockedWild = val;
+	}
+
+	internal static void Cheat_SetNumDecks(int numStandardDecks, int numWildDecks, int numClassicDecks)
+	{
+		s_cheatFakingNumDecks = true;
+		s_cheatNumStandardDecks = numStandardDecks;
+		s_cheatNumWildDecks = numWildDecks;
+		s_cheatNumClassicDecks = numClassicDecks;
+	}
+
+	internal static void Cheat_ResetNumDecks()
+	{
+		s_cheatNumStandardDecks = 0;
+		s_cheatNumWildDecks = 0;
+		s_cheatNumClassicDecks = 0;
+		s_cheatFakingNumDecks = false;
+	}
+
+	#endregion
+
+	#endregion
 }
diff --git a/Assembly-CSharp/CollectionManagerDisplay.cs b/Assembly-CSharp/CollectionManagerDisplay.cs
index 7f6eafb..701cb62 100644
--- a/Assembly-CSharp/CollectionManagerDisplay.cs
+++ b/Assembly-CSharp/CollectionManagerDisplay.cs
@@ -12,6 +12,7 @@ using Hearthstone;
 using PegasusShared;
 using UnityEngine;
 using UnityEngine.Serialization;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionManagerDisplay : CollectibleDisplay
@@ -233,7 +234,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		}
 		if (CollectionManager.Get().ShouldShowWildToStandardTutorial())
 		{
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		}
 		SetTavernBrawlTexturesIfNecessary();
 		SetDuelsTexturesIfNecessary();
@@ -302,13 +303,13 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			UnityEngine.Object.Destroy(m_deckTemplatePickerPhone.gameObject);
 			m_deckTemplatePickerPhone = null;
 		}
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
 	private void Update()
 	{
-		if (HearthstoneApplication.IsInternal() && !UniversalInputManager.Get().IsTextInputActive())
+		if (HearthstoneApplication.IsInternal() && !UniversalInputManager.Get().IsTextInputActive() && !AccessibilityMgr.IsAccessibilityEnabled())
 		{
 			if (InputCollection.GetKeyDown(KeyCode.Alpha1))
 			{
@@ -480,6 +481,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			component.UpdateAllComponents(needsGhostUpdate: false);
 			m_cardActors.Add(new CollectionCardActors(component));
 		}
+		AccessibleCollectionManager.Get().OnPageChanged(m_pageManager.CurrentPageNum, collectiblesToDisplay, m_cardActors);
 		callback?.Invoke(m_cardActors, list, callbackData);
 	}
 
@@ -525,8 +527,11 @@ public class CollectionManagerDisplay : CollectibleDisplay
 					}
 				}
 			}
-			int num = numCardBacksToLoad - 1;
-			numCardBacksToLoad = num;
+			numCardBacksToLoad--;
+			if (numCardBacksToLoad == 0)
+			{
+				AccessibleCollectionManager.Get().OnCardBacksPageChanged(m_pageManager.CurrentPageNum, result);
+			}
 			if (numCardBacksToLoad == 0 && callback != null)
 			{
 				callback(result, null, null);
@@ -887,10 +892,10 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			}
 			else
 			{
-				ShowSetFilterCards(cardSets, specificCards, transitionPage);
-			}
-			CurrentSetFilterFormatType = formatType;
+			ShowSetFilterCards(cardSets, specificCards, transitionPage);
 		}
+			CurrentSetFilterFormatType = formatType;
+	}
 	}
 
 	private void ShowTwistFilterCards(bool transitionPage, List<TAG_CARD_SET> cardSets)
@@ -1221,6 +1226,8 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		});
 		collectionDeckTray.GetCardsContent().RegisterCardTileRightClickedListener(OnCardTileRightClicked);
 		m_isReady = true;
+
+		AccessibleCollectionManager.Get().OnCollectibleDisplayReady();
 	}
 
 	private IEnumerator InitCollectionWhenReady()
@@ -1274,7 +1281,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 	{
 		if (GetViewMode() != CollectionUtils.ViewMode.DECK_TEMPLATE && !GameUtils.IsZilliaxModule(cardTile.GetActor().GetEntityDef()))
 		{
-			if (!cardTile.GetSlot().Owned && !DuelsConfig.IsCardLoadoutTreasure(cardTile.GetCardID()))
+			if (!DuelsConfig.IsCardLoadoutTreasure(cardTile.GetCardID()))
 			{
 				CraftingManager.Get().EnterCraftMode(cardTile.GetActor());
 			}
@@ -1402,16 +1409,21 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			return;
 		}
-		List<TAG_CLASS> deckHeroClasses = GetDeckHeroClasses(deckID);
-		ShowDeckHelper(deck, deckHeroClasses, isNewDeck, showDeckTemplatePage, setNewViewMode);
-		if (!showDeckTemplatePage)
-		{
+			List<TAG_CLASS> deckHeroClasses = GetDeckHeroClasses(deckID);
+			ShowDeckHelper(deck, deckHeroClasses, isNewDeck, showDeckTemplatePage, setNewViewMode);
+			if (!showDeckTemplatePage)
+			{
 			bool flag = false;
 			if (m_pageManager != null)
 			{
 				flag = m_pageManager.ShouldShowAllClassCards(deck);
 			}
 			SetRuneLockedCheckboxVisible(GameUtils.HasClassTag(TAG_CLASS.DEATHKNIGHT, deckHeroClasses) && !flag);
+
+			if (isNewDeck)
+			{
+				AccessibleCollectionManager.Get().OnEditDeckScreen();
+			}
 		}
 	}
 
@@ -1846,7 +1858,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	private void ShowCraftingTipIfNeeded()
 	{
-		if (!Options.Get().GetBool(Option.TIP_CRAFTING_UNLOCKED, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowCraftingTipIfNeeded"))
+		if (!Options.Get().GetBool(Option.TIP_CRAFTING_UNLOCKED, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowCraftingTipIfNeeded"))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_DISENCHANT_31"), "VO_INNKEEPER_DISENCHANT_31.prefab:4a0246488dc2d8146b1db88de5c603ff");
 			Options.Get().SetBool(Option.TIP_CRAFTING_UNLOCKED, val: true);
@@ -1929,7 +1941,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			yield return null;
 		}
 		int deckCount = CollectionManager.Get().GetDecks(DeckType.NORMAL_DECK).Count;
-		if (UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:ShowSetRotationTutorial") && CollectionManager.Get().ShouldShowWildToStandardTutorial())
+		if (UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:ShowSetRotationTutorial") && CollectionManager.Get().ShouldShowWildToStandardTutorial())
 		{
 			CollectionDeckTray deckTray = CollectionDeckTray.Get();
 			while (deckTray.IsUpdatingTrayMode() || !deckTray.GetDecksContent().IsDoneEntering())
@@ -1955,7 +1967,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_COLLECTIONMANAGER_AFTER_PRACTICE, val: true);
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_COLLECTIONMANAGER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("UserAttentionManager.CanShowAttentionGrabber:" + Option.HAS_SEEN_COLLECTIONMANAGER))
+		if (!Options.Get().GetBool(Option.HAS_SEEN_COLLECTIONMANAGER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "UserAttentionManager.CanShowAttentionGrabber:" + Option.HAS_SEEN_COLLECTIONMANAGER))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_WELCOME"), "VO_INNKEEPER_Male_Dwarf_CM_WELCOME_23.prefab:c8afdeaaf2189eb42aad9d29f6a97994");
 			Options.Get().SetBool(Option.HAS_SEEN_COLLECTIONMANAGER, val: true);
@@ -1965,18 +1977,28 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			yield return new WaitForSeconds(1f);
 		}
-		bool num = UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_STARTED_A_DECK);
+		bool num = UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_STARTED_A_DECK);
 		bool @bool = Options.Get().GetBool(Option.HAS_STARTED_A_DECK, defaultVal: false);
 		if (num && !@bool && deckCount > 0)
 		{
-			m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_editDeckTutorialBone.position, m_editDeckTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL07"));
-			m_deckHelpPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
-			m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+			{
+				// Visual notif - ignore
+				m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_editDeckTutorialBone.position, m_editDeckTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL07"));
+				m_deckHelpPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
+				m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+			}
 		}
 	}
 
 	private void ShowDeckTemplateTipsIfNeeded()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// All of these tips are very visual which is just confusing
+			return;
+        }
+
 		CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
 		bool flag = m_deckHelpPopup != null && m_deckHelpPopup.gameObject != null;
 		Notification deckHelpPopup = collectionDeckTray.GetCardsContent().GetDeckHelpPopup();
@@ -2003,7 +2025,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			}
 			else
 			{
-				if (Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD) || !UserAttentionManager.CanShowAttentionGrabber("CollectionManagerDisplay.ShowDeckTemplateTipsIfNeeded:" + Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD))
+				if (Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD) || !UserAttentionManager.CanShowAttentionGrabber(true, "CollectionManagerDisplay.ShowDeckTemplateTipsIfNeeded:" + Option.HAS_SEEN_DECK_TEMPLATE_GHOST_CARD))
 				{
 					return;
 				}
@@ -2177,7 +2199,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 	private void EnableSetAndManaFiltersByViewMode(CollectionUtils.ViewMode viewMode, CollectionUtils.ViewSubmode viewSubmode)
 	{
 		bool flag = viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES;
-		bool flag2 = viewMode == CollectionUtils.ViewMode.CARDS && !flag;
+		bool flag2 = !flag && (viewMode == CollectionUtils.ViewMode.CARDS || viewMode == CollectionUtils.ViewMode.MASS_DISENCHANT || viewMode == CollectionUtils.ViewMode.COINS || viewMode == CollectionUtils.ViewMode.CARD_BACKS || viewMode == CollectionUtils.ViewMode.HERO_SKINS);
 		m_manaTabManager.Enabled = flag2;
 		if (m_setFilterTray != null)
 		{
@@ -2192,7 +2214,10 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	private void EnableCraftingByViewMode(CollectionUtils.ViewMode viewMode, CollectionUtils.ViewSubmode viewSubmode)
 	{
-		bool flag = (viewMode == CollectionUtils.ViewMode.CARDS || viewMode == CollectionUtils.ViewMode.MASS_DISENCHANT) && viewSubmode != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES;
+		// TODO: Do this properly: the crafting button is hidden since 21.6.0 when browsing cardBacks/coins/skins but we currently rely on it to enter crafting
+    // Note: This was refactored on 22.2.0 but the logic doesn't seem to have changed
+		// bool flag = viewMode == CollectionUtils.ViewMode.CARDS || viewMode == CollectionUtils.ViewMode.MASS_DISENCHANT;
+		bool flag = (viewMode == CollectionUtils.ViewMode.CARDS || viewMode == CollectionUtils.ViewMode.MASS_DISENCHANT || viewMode == CollectionUtils.ViewMode.COINS || viewMode == CollectionUtils.ViewMode.CARD_BACKS || viewMode == CollectionUtils.ViewMode.HERO_SKINS) && viewSubmode != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES;
 		m_craftingModeButton.Enable(flag);
 		bool flag2 = m_viewModeHidingCraftingTray || m_searchTriggeredCraftingInBackground;
 		if (!flag)
@@ -2273,7 +2298,7 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	public void ShowConvertTutorial(UserAttentionBlocker blocker)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "CollectionManagerDisplay.ShowConvertTutorial"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "CollectionManagerDisplay.ShowConvertTutorial"))
 		{
 			m_showConvertTutorialCoroutine = ShowConvertTutorialCoroutine(blocker);
 			StartCoroutine(m_showConvertTutorialCoroutine);
@@ -2319,7 +2344,13 @@ public class CollectionManagerDisplay : CollectibleDisplay
 
 	public void ShowSetFilterTutorial(UserAttentionBlocker blocker)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "CollectionManagerDisplay.ShowSetFilterTutorial"))
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Very visual
+			return;
+		}
+
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "CollectionManagerDisplay.ShowSetFilterTutorial"))
 		{
 			m_showSetFilterTutorialCoroutine = ShowSetFilterTutorialCoroutine(blocker);
 			StartCoroutine(m_showSetFilterTutorialCoroutine);
@@ -2511,10 +2542,10 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		if (shareableDeck.FormatType == PegasusShared.FormatType.FT_TWIST)
 		{
 			if (!CollectionManager.Get().ShouldAccountSeeStandardWild())
-			{
-				alertMessage = GameStrings.Get("GLUE_COLLECTION_DECK_TWIST_NOT_UNLOCKED");
-				return false;
-			}
+		{
+			alertMessage = GameStrings.Get("GLUE_COLLECTION_DECK_TWIST_NOT_UNLOCKED");
+			return false;
+		}
 			if (!RankMgr.IsCurrentTwistSeasonActive())
 			{
 				alertMessage = GameStrings.Get("GLUE_COLLECTION_DECK_TWIST_NOT_ACTIVE");
@@ -2590,18 +2621,19 @@ public class CollectionManagerDisplay : CollectibleDisplay
 			}
 			if (!flag)
 			{
-				DeckRuleset deckRuleset = CollectionManager.Get().GetDeckRuleset() ?? collectionDeck.GetRuleset();
-				if (deckRuleset != null)
-				{
-					return deckRuleset.IsDeckValid(collectionDeck, CollectionDeck.DefaultIgnoreRules.ToArray());
-				}
+			DeckRuleset deckRuleset = CollectionManager.Get().GetDeckRuleset() ?? collectionDeck.GetRuleset();
+			if (deckRuleset != null)
+			{
+				return deckRuleset.IsDeckValid(collectionDeck, CollectionDeck.DefaultIgnoreRules.ToArray());
 			}
 		}
+		}
 		return true;
 	}
 
 	private void CreateDeckFromClipboard(ShareableDeck shareableDeck)
 	{
+		AccessibleCollectionManager.Get().OnCreateDeckFromClipboard();
 		bool flag = SceneMgr.Get().GetMode() == SceneMgr.Mode.COLLECTIONMANAGER;
 		List<TAG_CLASS> list = new List<TAG_CLASS>();
 		DefLoader.Get().GetEntityDef(shareableDeck.HeroCardDbId).GetClasses(list);
@@ -2633,13 +2665,13 @@ public class CollectionManagerDisplay : CollectibleDisplay
 		{
 			if (!(CollectionDeckTray.Get() == null))
 			{
-				CollectionDeckTray.Get().GetDecksContent().CreateNewDeckFromUserSelection(tAG_CLASS, heroCardID, customDeckName, DeckSourceType.DECK_SOURCE_TYPE_PASTED_DECK, shareableDeck.Serialize(includeComments: false));
-				CollectionManager.Get().RegisterDeckCreatedListener(OnDeckCreatedFromClipboard);
-				CollectionManager.Get().RemoveDeckCreatedListener(OnDeckCreatedByPlayer);
-				if (HeroPickerDisplay.Get() != null && HeroPickerDisplay.Get().IsShown())
-				{
-					DeckPickerTrayDisplay.Get().SkipHeroSelectionAndCloseTray();
-				}
+			CollectionDeckTray.Get().GetDecksContent().CreateNewDeckFromUserSelection(tAG_CLASS, heroCardID, customDeckName, DeckSourceType.DECK_SOURCE_TYPE_PASTED_DECK, shareableDeck.Serialize(includeComments: false));
+			CollectionManager.Get().RegisterDeckCreatedListener(OnDeckCreatedFromClipboard);
+			CollectionManager.Get().RemoveDeckCreatedListener(OnDeckCreatedByPlayer);
+			if (HeroPickerDisplay.Get() != null && HeroPickerDisplay.Get().IsShown())
+			{
+				DeckPickerTrayDisplay.Get().SkipHeroSelectionAndCloseTray();
+			}
 			}
 			return;
 		}
diff --git a/Assembly-CSharp/CollectionManagerScene.cs b/Assembly-CSharp/CollectionManagerScene.cs
index 91be04c..85a09e0 100644
--- a/Assembly-CSharp/CollectionManagerScene.cs
+++ b/Assembly-CSharp/CollectionManagerScene.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class CollectionManagerScene : PegasusScene
@@ -27,6 +28,7 @@ public class CollectionManagerScene : PegasusScene
 
 	public override void Unload()
 	{
+		AccessibleCollectionManager.Get().OnCollectionManagerClosed();
 		if ((bool)UniversalInputManager.UsePhoneUI)
 		{
 			BnetBar.Get().ToggleActive(active: true);
diff --git a/Assembly-CSharp/CollectionPageDisplay.cs b/Assembly-CSharp/CollectionPageDisplay.cs
index fa55651..5f519d8 100644
--- a/Assembly-CSharp/CollectionPageDisplay.cs
+++ b/Assembly-CSharp/CollectionPageDisplay.cs
@@ -6,6 +6,7 @@ using Blizzard.T5.Core;
 using Blizzard.T5.MaterialService.Extensions;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class CollectionPageDisplay : CollectiblePageDisplay
 {
@@ -102,7 +103,7 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 
 	public void UpdatePageWithHeroPicker(int[] allHeroCounts, int[] ownedHeroCounts)
 	{
-		CollectionHeroPickerButtons componentInChildren = m_heroPicker.GetComponentInChildren<CollectionHeroPickerButtons>();
+		var componentInChildren = GetCollectionHeroPickerButtons();
 		if (componentInChildren != null)
 		{
 			componentInChildren.LoadHeroButtonsForFavoriteHeroes();
@@ -113,7 +114,7 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 
 	public void HideHeroPicker()
 	{
-		CollectionHeroPickerButtons componentInChildren = m_heroPicker.GetComponentInChildren<CollectionHeroPickerButtons>();
+		var componentInChildren = GetCollectionHeroPickerButtons();
 		if (componentInChildren != null && componentInChildren.IsReady())
 		{
 			componentInChildren.Hide();
@@ -147,10 +148,8 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 				EntityDef entityDef = actor.GetEntityDef();
 				if (entityDef != null)
 				{
-					TAG_CLASS @class = entityDef.GetClass();
-					string cardId = entityDef.GetCardId();
 					component.SetClass(entityDef);
-					bool show = CollectionManager.Get().GetCountOfOwnedHeroesForClass(@class) > 1 && CollectionManager.Get().IsFavoriteHero(cardId);
+					bool show = AccessibleCardUtils.ShouldShowFavoriteHeroText(entityDef);
 					component.ShowFavoriteBanner(show);
 				}
 			}
@@ -296,6 +295,11 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 			}
 		}
 		m_noMatchExplanationText.Text = GameStrings.Get(key);
+
+		if (show)
+		{
+			AccessibleCollectionManager.Get().OnShowNoMatchesFound(key);
+		}
 	}
 
 	public void HideHeroSkinsDecor()
@@ -483,8 +487,8 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 			{
 				if (noClassOverride == "")
 				{
-					m_pageFlavorHeader.SetActive(value: false);
-				}
+				m_pageFlavorHeader.SetActive(value: false);
+			}
 				else
 				{
 					SetPageFlavorTextures(m_pageFlavorHeader, TagClassToHeaderClass(TAG_CLASS.NEUTRAL));
@@ -697,4 +701,11 @@ public class CollectionPageDisplay : CollectiblePageDisplay
 			CollectiblePageDisplay.SetPageFlavorTextures(header, new UnityEngine.Vector2(x, y));
 		}
 	}
+
+	#region Accessibility
+	internal CollectionHeroPickerButtons GetCollectionHeroPickerButtons()
+	{
+		return m_heroPicker.GetComponentInChildren<CollectionHeroPickerButtons>();
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/CollectionPageManager.cs b/Assembly-CSharp/CollectionPageManager.cs
index f600644..f2c11c3 100644
--- a/Assembly-CSharp/CollectionPageManager.cs
+++ b/Assembly-CSharp/CollectionPageManager.cs
@@ -10,195 +10,197 @@ using UnityEngine;
 [CustomEditClass]
 public class CollectionPageManager : CollectiblePageManager
 {
-	public static readonly Map<TAG_CLASS, UnityEngine.Vector2> s_classTextureOffsets = new Map<TAG_CLASS, UnityEngine.Vector2>
-	{
-		{
-			TAG_CLASS.MAGE,
-			new UnityEngine.Vector2(0f, 0f)
-		},
-		{
-			TAG_CLASS.PALADIN,
-			new UnityEngine.Vector2(0.205f, 0f)
-		},
-		{
-			TAG_CLASS.PRIEST,
-			new UnityEngine.Vector2(0.392f, 0f)
-		},
-		{
-			TAG_CLASS.ROGUE,
-			new UnityEngine.Vector2(0.58f, 0f)
-		},
-		{
-			TAG_CLASS.SHAMAN,
-			new UnityEngine.Vector2(0.774f, 0f)
-		},
-		{
-			TAG_CLASS.WARLOCK,
-			new UnityEngine.Vector2(0f, -0.2f)
-		},
-		{
-			TAG_CLASS.WARRIOR,
-			new UnityEngine.Vector2(0.205f, -0.2f)
-		},
-		{
-			TAG_CLASS.DRUID,
-			new UnityEngine.Vector2(0.392f, -0.2f)
-		},
-		{
-			TAG_CLASS.HUNTER,
-			new UnityEngine.Vector2(0.58f, -0.2f)
-		},
-		{
-			TAG_CLASS.NEUTRAL,
-			new UnityEngine.Vector2(0.774f, -0.2f)
-		},
-		{
-			TAG_CLASS.WHIZBANG,
-			new UnityEngine.Vector2(0f, -0.395f)
-		},
-		{
-			TAG_CLASS.DEMONHUNTER,
-			new UnityEngine.Vector2(0.205f, -0.4f)
-		},
-		{
-			TAG_CLASS.DEATHKNIGHT,
-			new UnityEngine.Vector2(0.392f, -0.4f)
-		}
-	};
-
-	private static readonly Map<TAG_CLASS, Color> s_classColors = new Map<TAG_CLASS, Color>
-	{
-		{
-			TAG_CLASS.DEATHKNIGHT,
+    public static readonly Map<TAG_CLASS, UnityEngine.Vector2> s_classTextureOffsets = new Map<TAG_CLASS, UnityEngine.Vector2>
+    {
+        {
+            TAG_CLASS.MAGE,
+            new UnityEngine.Vector2(0f, 0f)
+        },
+        {
+            TAG_CLASS.PALADIN,
+            new UnityEngine.Vector2(0.205f, 0f)
+        },
+        {
+            TAG_CLASS.PRIEST,
+            new UnityEngine.Vector2(0.392f, 0f)
+        },
+        {
+            TAG_CLASS.ROGUE,
+            new UnityEngine.Vector2(0.58f, 0f)
+        },
+        {
+            TAG_CLASS.SHAMAN,
+            new UnityEngine.Vector2(0.774f, 0f)
+        },
+        {
+            TAG_CLASS.WARLOCK,
+            new UnityEngine.Vector2(0f, -0.2f)
+        },
+        {
+            TAG_CLASS.WARRIOR,
+            new UnityEngine.Vector2(0.205f, -0.2f)
+        },
+        {
+            TAG_CLASS.DRUID,
+            new UnityEngine.Vector2(0.392f, -0.2f)
+        },
+        {
+            TAG_CLASS.HUNTER,
+            new UnityEngine.Vector2(0.58f, -0.2f)
+        },
+        {
+            TAG_CLASS.NEUTRAL,
+            new UnityEngine.Vector2(0.774f, -0.2f)
+        },
+        {
+            TAG_CLASS.WHIZBANG,
+            new UnityEngine.Vector2(0f, -0.395f)
+        },
+        {
+            TAG_CLASS.DEMONHUNTER,
+            new UnityEngine.Vector2(0.205f, -0.4f)
+        },
+        {
+            TAG_CLASS.DEATHKNIGHT,
+            new UnityEngine.Vector2(0.392f, -0.4f)
+        }
+    };
+
+    private static readonly Map<TAG_CLASS, Color> s_classColors = new Map<TAG_CLASS, Color>
+    {
+        {
+            TAG_CLASS.DEATHKNIGHT,
 			new Color(1f / 15f, 0.5294118f, 0.58431375f)
-		},
-		{
-			TAG_CLASS.MAGE,
-			new Color(11f / 85f, 4f / 15f, 33f / 85f)
-		},
-		{
-			TAG_CLASS.PALADIN,
+        },
+        {
+            TAG_CLASS.MAGE,
+            new Color(11f / 85f, 4f / 15f, 33f / 85f)
+        },
+        {
+            TAG_CLASS.PALADIN,
 			new Color(0.4392157f, 0.29411766f, 0.09019608f)
-		},
-		{
-			TAG_CLASS.PRIEST,
+        },
+        {
+            TAG_CLASS.PRIEST,
 			new Color(0.52156866f, 0.52156866f, 0.52156866f)
-		},
-		{
-			TAG_CLASS.ROGUE,
+        },
+        {
+            TAG_CLASS.ROGUE,
 			new Color(0.09019608f, 0.07450981f, 0.07450981f)
-		},
-		{
-			TAG_CLASS.SHAMAN,
+        },
+        {
+            TAG_CLASS.SHAMAN,
 			new Color(11f / 85f, 0.17254902f, 19f / 51f)
-		},
-		{
-			TAG_CLASS.WARLOCK,
+        },
+        {
+            TAG_CLASS.WARLOCK,
 			new Color(18f / 85f, 0.10980392f, 24f / 85f)
-		},
-		{
-			TAG_CLASS.WARRIOR,
+        },
+        {
+            TAG_CLASS.WARRIOR,
 			new Color(14f / 51f, 0.050980393f, 7f / 85f)
-		},
-		{
-			TAG_CLASS.DRUID,
+        },
+        {
+            TAG_CLASS.DRUID,
 			new Color(0.23137255f, 0.16078432f, 0.08627451f)
-		},
-		{
-			TAG_CLASS.HUNTER,
+        },
+        {
+            TAG_CLASS.HUNTER,
 			new Color(19f / 85f, 0.4627451f, 0.1764706f)
-		},
-		{
-			TAG_CLASS.NEUTRAL,
-			new Color(0f, 0f, 0f)
-		},
-		{
-			TAG_CLASS.WHIZBANG,
+        },
+        {
+            TAG_CLASS.NEUTRAL,
+            new Color(0f, 0f, 0f)
+        },
+        {
+            TAG_CLASS.WHIZBANG,
 			new Color(48f / 85f, 0.3019608f, 0.5372549f)
-		},
-		{
-			TAG_CLASS.DEMONHUNTER,
+        },
+        {
+            TAG_CLASS.DEMONHUNTER,
 			new Color(0.09019608f, 0.22745098f, 10f / 51f)
-		}
-	};
+        }
+    };
 
-	public static TAG_CLASS[] CLASS_TAB_ORDER = new TAG_CLASS[12]
-	{
-		TAG_CLASS.DEATHKNIGHT,
-		TAG_CLASS.DEMONHUNTER,
-		TAG_CLASS.DRUID,
-		TAG_CLASS.HUNTER,
-		TAG_CLASS.MAGE,
-		TAG_CLASS.PALADIN,
-		TAG_CLASS.PRIEST,
-		TAG_CLASS.ROGUE,
-		TAG_CLASS.SHAMAN,
-		TAG_CLASS.WARLOCK,
-		TAG_CLASS.WARRIOR,
-		TAG_CLASS.NEUTRAL
-	};
+    public static TAG_CLASS[] CLASS_TAB_ORDER = new TAG_CLASS[12]
+    {
+        TAG_CLASS.DEATHKNIGHT,
+        TAG_CLASS.DEMONHUNTER,
+        TAG_CLASS.DRUID,
+        TAG_CLASS.HUNTER,
+        TAG_CLASS.MAGE,
+        TAG_CLASS.PALADIN,
+        TAG_CLASS.PRIEST,
+        TAG_CLASS.ROGUE,
+        TAG_CLASS.SHAMAN,
+        TAG_CLASS.WARLOCK,
+        TAG_CLASS.WARRIOR,
+        TAG_CLASS.NEUTRAL
+    };
 
-	public CollectionClassTab m_heroSkinsTab;
+    public CollectionClassTab m_heroSkinsTab;
 
-	public CollectionClassTab m_cardBacksTab;
+    public CollectionClassTab m_cardBacksTab;
 
-	public CollectionClassTab m_coinsTab;
+    public CollectionClassTab m_coinsTab;
 
-	public ClassFilterHeaderButton m_classFilterHeader;
+    public ClassFilterHeaderButton m_classFilterHeader;
 
-	public CollectionClassTab m_deckTemplateTab;
+    public CollectionClassTab m_deckTemplateTab;
 
 	public BookTab m_ZilliaxModulesTab;
 
 	public BookTab m_ZilliaxBlueprintsTab;
 
-	[CustomEditField(Sections = "Deck Template", T = EditType.GAME_OBJECT)]
-	public string m_deckTemplatePickerPrefab;
+    [CustomEditField(Sections = "Deck Template", T = EditType.GAME_OBJECT)]
+    public string m_deckTemplatePickerPrefab;
 
-	private static CollectionUtils.ViewMode[] TAG_ORDERING = new CollectionUtils.ViewMode[5]
-	{
-		CollectionUtils.ViewMode.CARDS,
-		CollectionUtils.ViewMode.COINS,
-		CollectionUtils.ViewMode.CARD_BACKS,
-		CollectionUtils.ViewMode.HERO_PICKER,
-		CollectionUtils.ViewMode.HERO_SKINS
-	};
+    private static CollectionUtils.ViewMode[] TAG_ORDERING = new CollectionUtils.ViewMode[5]
+    {
+        CollectionUtils.ViewMode.CARDS,
+        CollectionUtils.ViewMode.COINS,
+        CollectionUtils.ViewMode.CARD_BACKS,
+        CollectionUtils.ViewMode.HERO_PICKER,
+        CollectionUtils.ViewMode.HERO_SKINS
+    };
+
+    private static readonly int NUM_PAGE_FLIPS_BEFORE_SET_FILTER_TUTORIAL = 3;
 
-	private static readonly int NUM_PAGE_FLIPS_BEFORE_SET_FILTER_TUTORIAL = 3;
+    private static Map<TAG_CLASS, int> CLASS_TO_TAB_IDX = null;
 
-	private List<CollectionClassTab> m_classTabs = new List<CollectionClassTab>();
+    internal List<CollectionClassTab> m_classTabs = new List<CollectionClassTab>();
 
 	private List<BookTab> m_zilliaxTabs = new List<BookTab>();
 
-	private MassDisenchant m_massDisenchant;
+    private MassDisenchant m_massDisenchant;
 
-	private DeckTemplatePicker m_deckTemplatePicker;
+    private DeckTemplatePicker m_deckTemplatePicker;
 
-	private CollectibleCardHeroesFilter m_heroesCollection = new CollectibleCardHeroesFilter();
+    private CollectibleCardHeroesFilter m_heroesCollection = new CollectibleCardHeroesFilter();
 
-	private Vector3 m_heroSkinsTabPos;
+    private Vector3 m_heroSkinsTabPos;
 
-	private Vector3 m_cardBacksTabPos;
+    private Vector3 m_cardBacksTabPos;
 
-	private Vector3 m_coinsTabPos;
+    private Vector3 m_coinsTabPos;
 
-	private bool m_hideNonDeckTemplateTabs;
+    private bool m_hideNonDeckTemplateTabs;
 
-	private int m_numPageFlipsThisSession;
+    private int m_numPageFlipsThisSession;
 
-	protected CollectionTabInfo m_currentClassContext;
+    public CollectionTabInfo m_currentClassContext;
 
-	protected ICollectible m_lastCollectibleAnchor;
+    protected ICollectible m_lastCollectibleAnchor;
 
-	private readonly List<CollectionCardVisual> m_ghostedRuneCards = new List<CollectionCardVisual>();
+    private readonly List<CollectionCardVisual> m_ghostedRuneCards = new List<CollectionCardVisual>();
 
-	private string m_searchText;
+    private string m_searchText;
 
-	private List<CollectibleCard> m_disenchantCards = new List<CollectibleCard>();
+    private List<CollectibleCard> m_disenchantCards = new List<CollectibleCard>();
 
-	private bool m_deckRunesWereUpdatedOnCurrentPage;
+    private bool m_deckRunesWereUpdatedOnCurrentPage;
 
-	private RunePattern m_originalDeckRunesForCurrentPage;
+    private RunePattern m_originalDeckRunesForCurrentPage;
 
 	private static Comparison<CollectibleCard> OrderedZilliaxModulesSort = delegate(CollectibleCard a, CollectibleCard b)
 	{
@@ -228,116 +230,116 @@ public class CollectionPageManager : CollectiblePageManager
 		return num;
 	};
 
-	private const float DK_TUTORIAL_RUNE_POPUP_OFFSET_X_PC = 13f;
+    private const float DK_TUTORIAL_RUNE_POPUP_OFFSET_X_PC = 13f;
 
-	private const float DK_TUTORIAL_RUNE_POPUP_OFFSET_X_PHONE = 14f;
+    private const float DK_TUTORIAL_RUNE_POPUP_OFFSET_X_PHONE = 14f;
 
-	private const float DK_TUTORIAL_RUNE_POPUP_SCALE = 15f;
+    private const float DK_TUTORIAL_RUNE_POPUP_SCALE = 15f;
 
-	private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_OFFSET_X_PC = -6f;
+    private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_OFFSET_X_PC = -6f;
 
-	private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_OFFSET_X_PHONE = -9f;
+    private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_OFFSET_X_PHONE = -9f;
 
-	private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_SCALE_PC = 7f;
+    private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_SCALE_PC = 7f;
 
-	private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_SCALE_PHONE = 7f;
+    private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_SCALE_PHONE = 7f;
 
-	private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_ROTATION = 90f;
+    private const float DK_TUTORIAL_RUNE_INDICATOR_ARROW_ROTATION = 90f;
 
-	private Notification m_deathKnightRuneTutorialRunePopup;
+    private Notification m_deathKnightRuneTutorialRunePopup;
 
-	private Notification m_runeIndicatorArrow;
+    private Notification m_runeIndicatorArrow;
 
-	private CollectibleCardClassFilter m_classCardsCollection => (CollectibleCardClassFilter)m_cardsCollection;
+    private CollectibleCardClassFilter m_classCardsCollection => (CollectibleCardClassFilter)m_cardsCollection;
 
-	public bool IsManaCostFilterActive
-	{
-		get
-		{
-			if (m_cardsCollection != null)
-			{
-				return m_cardsCollection.IsManaCostFilterActive;
-			}
-			return false;
-		}
-	}
+    public bool IsManaCostFilterActive
+    {
+        get
+        {
+            if (m_cardsCollection != null)
+            {
+                return m_cardsCollection.IsManaCostFilterActive;
+            }
+            return false;
+        }
+    }
 
-	public static bool IsShowingLockedRuneCards { get; private set; }
+    public static bool IsShowingLockedRuneCards { get; private set; }
 
 	public event Action OnZilliaxTabPressed;
 
-	public static Color ColorForClass(TAG_CLASS tagClass)
-	{
-		return s_classColors[tagClass];
-	}
-
-	protected override void Awake()
-	{
-		base.Awake();
-		m_cardsCollection = new CollectibleCardClassFilter();
-		m_classCardsCollection.Init(CollectiblePageDisplay.GetMaxCardsPerPage(CollectionUtils.ViewMode.CARDS));
-		m_heroesCollection.Init(CollectiblePageDisplay.GetMaxCardsPerPage(CollectionUtils.ViewMode.HERO_SKINS));
-		UpdateFilteredCards();
-		m_heroesCollection.UpdateResults();
-		if ((bool)m_massDisenchant)
-		{
-			m_massDisenchant.Hide();
-		}
-		CollectionManager.Get()?.RegisterFavoriteHeroChangedListener(OnFavoriteHeroChanged);
-		IsShowingLockedRuneCards = true;
-		NetCache.Get().FavoriteCardBackChanged += OnFavoriteCardBackChanged;
-		NetCache.Get().FavoriteBattlegroundsGuideSkinChanged += OnFavoriteBattlegroundsGuideSkinChanged;
-		NetCache.Get().FavoriteCoinChanged += OnFavoriteCoinChanged;
-	}
-
-	private void OnEnable()
-	{
-		CollectionManagerDisplay.HideLockedRunesCheckboxToggled += OnHideLockedRunesCheckboxToggled;
-		RuneIndicatorVisual.RunePatternChanged += RuneIndicatorVisualOnRunePatternChanged;
+    public static Color ColorForClass(TAG_CLASS tagClass)
+    {
+        return s_classColors[tagClass];
+    }
+
+    protected override void Awake()
+    {
+        base.Awake();
+        m_cardsCollection = new CollectibleCardClassFilter();
+        m_classCardsCollection.Init(CollectiblePageDisplay.GetMaxCardsPerPage(CollectionUtils.ViewMode.CARDS));
+        m_heroesCollection.Init(CollectiblePageDisplay.GetMaxCardsPerPage(CollectionUtils.ViewMode.HERO_SKINS));
+        UpdateFilteredCards();
+        m_heroesCollection.UpdateResults();
+        if ((bool)m_massDisenchant)
+        {
+            m_massDisenchant.Hide();
+        }
+        CollectionManager.Get()?.RegisterFavoriteHeroChangedListener(OnFavoriteHeroChanged);
+        IsShowingLockedRuneCards = true;
+        NetCache.Get().FavoriteCardBackChanged += OnFavoriteCardBackChanged;
+        NetCache.Get().FavoriteBattlegroundsGuideSkinChanged += OnFavoriteBattlegroundsGuideSkinChanged;
+        NetCache.Get().FavoriteCoinChanged += OnFavoriteCoinChanged;
+    }
+
+    private void OnEnable()
+    {
+        CollectionManagerDisplay.HideLockedRunesCheckboxToggled += OnHideLockedRunesCheckboxToggled;
+        RuneIndicatorVisual.RunePatternChanged += RuneIndicatorVisualOnRunePatternChanged;
 		CollectionDeckTray.DeckTrayRunesAdded += OnDeckTrayRunesAdded;
-		CraftingTray.CraftingTrayShown += OnCraftingTrayShown;
-		CraftingTray.CraftingTrayHidden += OnCraftingTrayHidden;
-	}
-
-	private void OnDisable()
-	{
-		CollectionManagerDisplay.HideLockedRunesCheckboxToggled -= OnHideLockedRunesCheckboxToggled;
-		RuneIndicatorVisual.RunePatternChanged -= RuneIndicatorVisualOnRunePatternChanged;
+        CraftingTray.CraftingTrayShown += OnCraftingTrayShown;
+        CraftingTray.CraftingTrayHidden += OnCraftingTrayHidden;
+    }
+
+    private void OnDisable()
+    {
+        CollectionManagerDisplay.HideLockedRunesCheckboxToggled -= OnHideLockedRunesCheckboxToggled;
+        RuneIndicatorVisual.RunePatternChanged -= RuneIndicatorVisualOnRunePatternChanged;
 		CollectionDeckTray.DeckTrayRunesAdded -= OnDeckTrayRunesAdded;
-		CraftingTray.CraftingTrayShown -= OnCraftingTrayShown;
-		CraftingTray.CraftingTrayHidden -= OnCraftingTrayHidden;
-	}
-
-	public override void OnDestroy()
-	{
-		base.OnDestroy();
-		CollectionManager.Get()?.RemoveFavoriteHeroChangedListener(OnFavoriteHeroChanged);
-		if (NetCache.Get() != null)
-		{
-			NetCache.Get().FavoriteCardBackChanged -= OnFavoriteCardBackChanged;
-			NetCache.Get().FavoriteBattlegroundsGuideSkinChanged -= OnFavoriteBattlegroundsGuideSkinChanged;
-			NetCache.Get().FavoriteCoinChanged -= OnFavoriteCoinChanged;
-		}
-	}
-
-	public bool HideNonDeckTemplateTabs(bool hide, bool updateTabs = false)
-	{
-		if (m_hideNonDeckTemplateTabs == hide)
-		{
-			return false;
-		}
-		m_hideNonDeckTemplateTabs = hide;
-		if (updateTabs)
-		{
-			UpdateVisibleTabs();
-		}
-		return true;
-	}
-
-	public bool IsNonDeckTemplateTabsHidden()
-	{
-		return m_hideNonDeckTemplateTabs;
-	}
+        CraftingTray.CraftingTrayShown -= OnCraftingTrayShown;
+        CraftingTray.CraftingTrayHidden -= OnCraftingTrayHidden;
+    }
+
+    public override void OnDestroy()
+    {
+        base.OnDestroy();
+        CollectionManager.Get()?.RemoveFavoriteHeroChangedListener(OnFavoriteHeroChanged);
+        if (NetCache.Get() != null)
+        {
+            NetCache.Get().FavoriteCardBackChanged -= OnFavoriteCardBackChanged;
+            NetCache.Get().FavoriteBattlegroundsGuideSkinChanged -= OnFavoriteBattlegroundsGuideSkinChanged;
+            NetCache.Get().FavoriteCoinChanged -= OnFavoriteCoinChanged;
+        }
+    }
+
+    public bool HideNonDeckTemplateTabs(bool hide, bool updateTabs = false)
+    {
+        if (m_hideNonDeckTemplateTabs == hide)
+        {
+            return false;
+        }
+        m_hideNonDeckTemplateTabs = hide;
+        if (updateTabs)
+        {
+            UpdateVisibleTabs();
+        }
+        return true;
+    }
+
+    public bool IsNonDeckTemplateTabsHidden()
+    {
+        return m_hideNonDeckTemplateTabs;
+    }
 
 	public bool ShouldShowAllClassCards(CollectionDeck deck)
 	{
@@ -362,1350 +364,1350 @@ public class CollectionPageManager : CollectiblePageManager
 		return result;
 	}
 
-	public void UpdateFiltersForDeck(CollectionDeck deck, List<TAG_CLASS> deckClasses, bool skipPageTurn, DelOnPageTransitionComplete callback = null, object callbackData = null)
-	{
-		m_skipNextPageTurn = skipPageTurn;
-		bool flag = false;
-		bool flag2 = false;
-		if (deck != null && deck.GetRuleset() != null)
-		{
-			DeckRuleset ruleset = deck.GetRuleset();
-			if (ruleset.EntityInDeckIgnoresRuleset(deck))
+    public void UpdateFiltersForDeck(CollectionDeck deck, List<TAG_CLASS> deckClasses, bool skipPageTurn, DelOnPageTransitionComplete callback = null, object callbackData = null)
+    {
+        m_skipNextPageTurn = skipPageTurn;
+        bool flag = false;
+        bool flag2 = false;
+        if (deck != null && deck.GetRuleset() != null)
+        {
+            DeckRuleset ruleset = deck.GetRuleset();
+            if (ruleset.EntityInDeckIgnoresRuleset(deck))
+            {
+                flag = true;
+            }
+            else
+            {
+                IEnumerable<DeckRule> source = ruleset.Rules.Where((DeckRule r) => r.Type == DeckRule.RuleType.IS_CLASS_CARD_OR_NEUTRAL);
+                if (source.Any((DeckRule r) => r.RuleIsNot))
+                {
+                    flag2 = true;
+                }
+                else if (!source.Any())
+                {
+                    flag = true;
+                }
+            }
+        }
+        if (flag)
+        {
+            m_classCardsCollection.FilterTheseClasses(null);
+        }
+        else if (flag2)
+        {
+            m_classCardsCollection.FilterTheseClasses(CLASS_TAB_ORDER.Where((TAG_CLASS tag) => !deckClasses.Contains(tag)).ToArray());
+        }
+        else
+        {
+            List<TAG_CLASS> list = new List<TAG_CLASS>(deckClasses);
+            list.Add(TAG_CLASS.NEUTRAL);
+            m_classCardsCollection.FilterTheseClasses(list.ToArray());
+        }
+        m_heroesCollection.FilterOnlyOwned(owned: true);
+        m_heroesCollection.UpdateResults();
+        UpdateFilteredCards();
+        UpdateVisibleTabs();
+        bool flag3 = true;
+        CollectionUtils.ViewMode viewMode = CollectionManager.Get().GetCollectibleDisplay().GetViewMode();
+        if (viewMode == CollectionUtils.ViewMode.DECK_TEMPLATE || viewMode == CollectionUtils.ViewMode.MASS_DISENCHANT)
+        {
+            flag3 = false;
+        }
+        if (flag3)
+        {
+            switch (viewMode)
+            {
+                case CollectionUtils.ViewMode.CARDS:
+                    JumpToCollectionClassPage(new CollectionTabInfo
+                    {
+                        tagClass = deckClasses.First()
+                    }, callback, callbackData);
+                    break;
+                case CollectionUtils.ViewMode.HERO_SKINS:
+                case CollectionUtils.ViewMode.CARD_BACKS:
+			case CollectionUtils.ViewMode.COINS:
+                    m_currentPageNum = 1;
+                    TransitionPageWhenReady(PageTransitionType.NONE, useCurrentPageNum: false, callback, callbackData);
+                    break;
+            }
+        }
+    }
+
+    public override bool JumpToPageWithCard(string cardID, TAG_PREMIUM premium, DelOnPageTransitionComplete callback, object callbackData)
+    {
+        return JumpToPageWithCard(cardID, premium, callback, callbackData, tryClearFilters: true);
+    }
+
+    private bool JumpToPageWithCard(string cardID, TAG_PREMIUM premium, DelOnPageTransitionComplete callback, object callbackData, bool tryClearFilters)
+    {
+        CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+        CollectionTabInfo collectionTabInfo = default(CollectionTabInfo);
+        collectionTabInfo.tagClass = TAG_CLASS.INVALID;
+        CollectionTabInfo tabInfoContext = collectionTabInfo;
+        if (editedDeck != null)
+        {
+            tabInfoContext.tagClass = editedDeck.GetClass();
+        }
+        if (m_classCardsCollection.GetPageContentsForCard(cardID, premium, out var collectionPage, tabInfoContext).Count == 0)
+        {
+            if (tryClearFilters)
+            {
+                CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+                if (collectionManagerDisplay != null)
+                {
+                    collectionManagerDisplay.ResetFilters(updateVisuals: false);
+                }
+                return JumpToPageWithCard(cardID, premium, callback, callbackData, tryClearFilters: false);
+            }
+            return false;
+        }
+        if (m_currentPageNum == collectionPage)
+        {
+            return false;
+        }
+        FlipToPage(collectionPage, callback, callbackData);
+        return true;
+    }
+
+    public void FilterByManaCost(int cost, bool transitionPage = true)
+    {
+        if (cost == -1)
+        {
+            m_cardsCollection.FilterManaCost(null);
+        }
+        else
+        {
+            m_cardsCollection.FilterManaCost(cost);
+        }
+        UpdateFilteredCards();
+        if (transitionPage)
+        {
+            TransitionPageWhenReady(PageTransitionType.NONE, useCurrentPageNum: false, null, null);
+        }
+    }
+
+    public override void ChangeSearchTextFilter(string newSearchText, DelOnPageTransitionComplete callback, object callbackData, bool transitionPage = true)
+    {
+        if (newSearchText == "")
+        {
+            RemoveSearchTextFilter(callback, callbackData, transitionPage);
+            return;
+        }
+        m_searchText = newSearchText;
+        UpdateNonCardSearchTextFilters();
+        base.ChangeSearchTextFilter(m_searchText, callback, callbackData, transitionPage);
+    }
+
+    public override void RemoveSearchTextFilter(DelOnPageTransitionComplete callback, object callbackData, bool transitionPage = true)
+    {
+        m_searchText = null;
+        UpdateNonCardSearchTextFilters();
+        base.RemoveSearchTextFilter(callback, callbackData, transitionPage);
+    }
+
+    private void UpdateNonCardSearchTextFilters()
+    {
+        CardBackManager.Get().SetSearchText(m_searchText);
+		CosmeticCoinManager.Get().SetSearchText(m_searchText);
+        CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+        if (collectionManagerDisplay != null)
+        {
+            switch (collectionManagerDisplay.GetViewMode())
+            {
+                case CollectionUtils.ViewMode.HERO_SKINS:
+                    if (!IsSearching() && !CollectionManager.Get().IsInEditMode())
+                    {
+                        collectionManagerDisplay.SetViewMode(CollectionUtils.ViewMode.HERO_PICKER, triggerResponse: false);
+                    }
+                    else
+                    {
+                        collectionManagerDisplay.SetHeroSkinClass(null);
+                    }
+                    break;
+                case CollectionUtils.ViewMode.HERO_PICKER:
+                    if (IsSearching())
+                    {
+                        collectionManagerDisplay.SetViewMode(CollectionUtils.ViewMode.HERO_SKINS, triggerResponse: false);
+                    }
+                    break;
+            }
+        }
+        m_heroesCollection.FilterSearchText(m_searchText);
+        m_heroesCollection.UpdateResults();
+    }
+
+    public bool IsSearching()
+    {
+        return m_searchText != null;
+    }
+
+    public string GetSearchText()
+    {
+        return m_searchText;
+    }
+
+    public void UpdateClassTabNewCardCounts()
+    {
+        foreach (CollectionClassTab classTab in m_classTabs)
+        {
+            TAG_CLASS tagClass = classTab.TabInfo.tagClass;
+            int numNewItems = ((classTab.m_tabViewMode != CollectionUtils.ViewMode.DECK_TEMPLATE) ? GetNumNewCardsForClass(tagClass) : 0);
+            classTab.UpdateNewItemCount(numNewItems);
+        }
+    }
+
+    public int GetNumNewCardsForClass(TAG_CLASS tagClass)
+    {
+        return m_classCardsCollection.GetNumNewCardsForTab(new CollectionTabInfo
+        {
+            tagClass = tagClass
+        });
+    }
+
+    public override void NotifyOfCollectionChanged()
+    {
+        UpdateMassDisenchant();
+    }
+
+    public void OnDoneEditingDeck()
+    {
+		FormatType themeShowing = CollectionManager.Get().GetThemeShowing();
+		List<TAG_CLASS> deckClasses = RankMgr.GetExcludedClassesForFormat(themeShowing);
+		m_cardsCollection.FilterTheseClasses(CLASS_TAB_ORDER.Where((TAG_CLASS tag) => !deckClasses.Contains(tag)).ToArray());
+		UpdateFilteredCards();
+		m_heroesCollection.FilterTheseClasses(null);
+		m_heroesCollection.FilterOnlyOwned(owned: false);
+		m_heroesCollection.UpdateResults();
+		PageTransitionType transitionType = ((CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.CARDS) ? PageTransitionType.SINGLE_PAGE_LEFT : PageTransitionType.NONE);
+		TransitionPageWhenReady(transitionType, useCurrentPageNum: false, null, null);
+		UpdateCraftingModeButtonDustBottleVisibility(CollectionManager.Get().GetCardsToMassDisenchantCount());
+        NotificationManager.Get().DestroyNotificationWithText(GameStrings.Get("GLUE_COLLECTION_TUTORIAL_TEMPLATE_REPLACE_1"));
+        NotificationManager.Get().DestroyNotificationWithText(GameStrings.Get("GLUE_COLLECTION_TUTORIAL_TEMPLATE_REPLACE_2"));
+        NotificationManager.Get().DestroyNotificationWithText(GameStrings.Get("GLUE_COLLECTION_TUTORIAL_REPLACE_WILD_CARDS"));
+        NotificationManager.Get().DestroyNotificationWithText(GameStrings.Get("GLUE_COLLECTION_TUTORIAL_REPLACE_WILD_CARDS_NPR"));
+        CollectionDeckTray.Get().GetCardsContent().HideDeckHelpPopup();
+    }
+
+    public void UpdateCraftingModeButtonDustBottleVisibility(int disenchantCount)
+    {
+        CollectibleDisplay collectibleDisplay = CollectionManager.Get().GetCollectibleDisplay();
+        bool flag = collectibleDisplay.GetViewMode() == CollectionUtils.ViewMode.CARDS;
+        bool flag2 = (bool)UniversalInputManager.UsePhoneUI && collectibleDisplay.GetViewMode() == CollectionUtils.ViewMode.MASS_DISENCHANT;
+		bool show = (flag || flag2) && (disenchantCount > 0 || (bool)UniversalInputManager.UsePhoneUI);
+        CollectionManagerDisplay collectionManagerDisplay = collectibleDisplay as CollectionManagerDisplay;
+        if (collectionManagerDisplay != null)
+        {
+            collectionManagerDisplay.m_craftingModeButton.ShowDustBottle(show, flag);
+        }
+    }
+
+    public int GetMassDisenchantAmount()
+    {
+		return CollectionManager.Get().GetCardsToMassDisenchantCount();
+    }
+
+    public void LoadMassDisenchantScreen()
+    {
+        if (!(m_massDisenchant != null))
+        {
+            GameObject gameObject = AssetLoader.Get().InstantiatePrefab("MassDisenchant.prefab:0bfb8a7db15d748b291be3096753ca24");
+            m_massDisenchant = gameObject.GetComponent<MassDisenchant>();
+            m_massDisenchant.Hide();
+        }
+    }
+
+    public bool HasClassCardsAvailable(TAG_CLASS classTag)
+    {
+        return m_classCardsCollection.GetNumPagesForTab(new CollectionTabInfo
+        {
+            tagClass = classTag
+        }) > 0;
+    }
+
+    public bool HasAnyCardsAvailable()
+    {
+        return m_classCardsCollection.GetTotalNumPages() > 0;
+    }
+
+    public void ShowCraftingModeCards(DelOnPageTransitionComplete callback = null, object callbackData = null, bool showUncraftable = false, bool showNormalOwned = false, bool showNormalMissing = false, bool showPremiumOwned = false, bool showPremiumMissing = false, bool updatePage = true, bool toggleChanged = false)
+    {
+        List<CollectibleCardFilter.FilterMask> list = new List<CollectibleCardFilter.FilterMask>();
+        if (showNormalOwned)
+        {
+            list.Add(CollectibleCardFilter.FilterMask.PREMIUM_NORMAL | CollectibleCardFilter.FilterMask.OWNED);
+        }
+        if (showNormalMissing)
+        {
+            list.Add(CollectibleCardFilter.FilterMask.PREMIUM_NORMAL | CollectibleCardFilter.FilterMask.UNOWNED);
+        }
+        if (showPremiumOwned)
+        {
+            list.Add(CollectibleCardFilter.FilterMask.PREMIUM_GOLDEN | CollectibleCardFilter.FilterMask.OWNED);
+            list.Add(CollectibleCardFilter.FilterMask.PREMIUM_DIAMOND | CollectibleCardFilter.FilterMask.OWNED);
+            list.Add(CollectibleCardFilter.FilterMask.PREMIUM_SIGNATURE | CollectibleCardFilter.FilterMask.OWNED);
+        }
+        if (showPremiumMissing)
+        {
+            list.Add(CollectibleCardFilter.FilterMask.PREMIUM_GOLDEN | CollectibleCardFilter.FilterMask.UNOWNED);
+            list.Add(CollectibleCardFilter.FilterMask.PREMIUM_DIAMOND | CollectibleCardFilter.FilterMask.UNOWNED);
+            list.Add(CollectibleCardFilter.FilterMask.PREMIUM_SIGNATURE | CollectibleCardFilter.FilterMask.UNOWNED);
+        }
+        bool? isCraftable = null;
+        if (!showUncraftable)
+        {
+            isCraftable = true;
+        }
+        m_cardsCollection.FilterOnlyOwned(owned: false);
+        m_cardsCollection.FilterByMask(list);
+        m_cardsCollection.FilterByCraftability(isCraftable);
+        m_cardsCollection.FilterLeagueBannedCardsSubset(RankMgr.Get().GetBannedCardsInCurrentLeague());
+        UpdateFilteredCards();
+        if (toggleChanged)
+        {
+            m_lastCollectibleAnchor = null;
+        }
+        if (updatePage)
+        {
+            PageTransitionType transitionType = (toggleChanged ? PageTransitionType.MANY_PAGE_LEFT : PageTransitionType.NONE);
+            TransitionPageWhenReady(transitionType, useCurrentPageNum: false, callback, callbackData);
+        }
+    }
+
+    protected override bool CanUserTurnPages()
+    {
+        if (CraftingManager.GetIsInCraftingMode())
+        {
+            return false;
+        }
+        if (SceneMgr.Get().IsInDuelsMode() && !PvPDungeonRunScene.IsEditingDeck())
+        {
+            return false;
+        }
+        CardBackInfoManager cardBackInfoManager = CardBackInfoManager.Get();
+        if (cardBackInfoManager != null && cardBackInfoManager.IsPreviewing)
+        {
+            return false;
+        }
+        HeroSkinInfoManager heroSkinInfoManager = HeroSkinInfoManager.Get();
+        if (heroSkinInfoManager != null && heroSkinInfoManager.IsShowingPreview)
+        {
+            return false;
+        }
+        return base.CanUserTurnPages();
+    }
+
+    private CollectionPageDisplay PageAsCollectionPage(BookPageDisplay page)
+    {
+        if (!(page is CollectionPageDisplay))
+        {
+            Log.CollectionManager.PrintError("Page in CollectionPageManager is not a CollectionPageDisplay!  This should not happen!");
+        }
+        return page as CollectionPageDisplay;
+    }
+
+    protected override bool ShouldShowTab(BookTab tab)
+    {
+        if (!m_initializedTabPositions)
+        {
+            return true;
+        }
+        if (m_hideNonDeckTemplateTabs)
+        {
+            return tab.m_tabViewMode == CollectionUtils.ViewMode.DECK_TEMPLATE;
+        }
+        CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+        bool flag = editedDeck != null;
+		CollectionUtils.ViewSubmode viewSubmode = CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode();
+        switch (tab.m_tabViewMode)
+        {
+            case CollectionUtils.ViewMode.CARDS:
+                {
+			if (m_zilliaxTabs.Contains(tab))
 			{
-				flag = true;
+				return viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES;
 			}
-			else
+                    CollectionClassTab collectionClassTab = tab as CollectionClassTab;
+                    if (collectionClassTab == null)
+                    {
+                        Log.CollectionManager.PrintError("CollectionPageManager.ShouldShowTab passed a non-CollectionClassTab object.");
+                        return false;
+                    }
+			if (viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
 			{
-				IEnumerable<DeckRule> source = ruleset.Rules.Where((DeckRule r) => r.Type == DeckRule.RuleType.IS_CLASS_CARD_OR_NEUTRAL);
-				if (source.Any((DeckRule r) => r.RuleIsNot))
-				{
-					flag2 = true;
-				}
-				else if (!source.Any())
+				return false;
+			}
+                    TAG_CLASS tagClass = collectionClassTab.TabInfo.tagClass;
+                    if (HasClassCardsAvailable(tagClass))
+                    {
+                        return true;
+                    }
+                    if (flag && !HasAnyCardsAvailable())
+                    {
+                        return editedDeck.GetClasses().Contains(tagClass);
+                    }
+                    return false;
+                }
+            case CollectionUtils.ViewMode.DECK_TEMPLATE:
+                if (flag)
+                {
+                    return !SceneMgr.Get().IsInTavernBrawlMode();
+                }
+                return false;
+            case CollectionUtils.ViewMode.HERO_SKINS:
+		{
+                if (SceneMgr.Get().IsInDuelsMode())
+                {
+                    return false;
+                }
+                if (flag)
+                {
+                    if (editedDeck.HasUIHeroOverride())
+                    {
+                        return false;
+                    }
+				if (viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
 				{
-					flag = true;
+					return false;
 				}
+                    return CollectionManager.Get().GetCountOfOwnedHeroesForClass(editedDeck.GetClass()) > 1;
+                }
+			List<CollectibleCard> allResults = m_heroesCollection.GetAllResults();
+			if (allResults != null && allResults.Count > 0 && !m_classCardsCollection.IsManaCostFilterActive && !m_classCardsCollection.IsSingleSetFilterActive && IsSearching())
+			{
+				return true;
 			}
+                return HasAnyCardsAvailable();
 		}
-		if (flag)
-		{
-			m_classCardsCollection.FilterTheseClasses(null);
-		}
-		else if (flag2)
-		{
-			m_classCardsCollection.FilterTheseClasses(CLASS_TAB_ORDER.Where((TAG_CLASS tag) => !deckClasses.Contains(tag)).ToArray());
-		}
-		else
-		{
-			List<TAG_CLASS> list = new List<TAG_CLASS>(deckClasses);
-			list.Add(TAG_CLASS.NEUTRAL);
-			m_classCardsCollection.FilterTheseClasses(list.ToArray());
-		}
-		m_heroesCollection.FilterOnlyOwned(owned: true);
-		m_heroesCollection.UpdateResults();
-		UpdateFilteredCards();
-		UpdateVisibleTabs();
-		bool flag3 = true;
-		CollectionUtils.ViewMode viewMode = CollectionManager.Get().GetCollectibleDisplay().GetViewMode();
-		if (viewMode == CollectionUtils.ViewMode.DECK_TEMPLATE || viewMode == CollectionUtils.ViewMode.MASS_DISENCHANT)
+            case CollectionUtils.ViewMode.CARD_BACKS:
 		{
-			flag3 = false;
+                if (flag)
+                {
+				if (viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
+				{
+					return false;
+				}
+                    HashSet<int> cardBacksOwned = CardBackManager.Get().GetCardBacksOwned();
+                    if (cardBacksOwned != null)
+                    {
+                        return cardBacksOwned.Count > 1;
+                    }
+                    return false;
+                }
+			HashSet<int> currentDeckTrayModeCardBackIds = GetCurrentDeckTrayModeCardBackIds();
+			if (currentDeckTrayModeCardBackIds != null && currentDeckTrayModeCardBackIds.Count > 0 && !m_classCardsCollection.IsManaCostFilterActive && !m_classCardsCollection.IsSingleSetFilterActive && IsSearching())
+			{
+				return true;
+			}
+                return HasAnyCardsAvailable();
 		}
-		if (flag3)
+            case CollectionUtils.ViewMode.COINS:
 		{
-			switch (viewMode)
-			{
-			case CollectionUtils.ViewMode.CARDS:
-				JumpToCollectionClassPage(new CollectionTabInfo
+                if (SceneMgr.Get().IsInDuelsMode())
+                {
+                    return false;
+                }
+                if (flag)
+                {
+				if (viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
 				{
-					tagClass = deckClasses.First()
-				}, callback, callbackData);
-				break;
-			case CollectionUtils.ViewMode.HERO_SKINS:
-			case CollectionUtils.ViewMode.CARD_BACKS:
-			case CollectionUtils.ViewMode.COINS:
-				m_currentPageNum = 1;
-				TransitionPageWhenReady(PageTransitionType.NONE, useCurrentPageNum: false, callback, callbackData);
-				break;
+                    return false;
+                }
+				return CosmeticCoinManager.Get().GetTotalCoinsOwned() > 1;
 			}
-		}
-	}
+			List<CollectibleCard> currentDeckTrayModeCosmeticCoins = GetCurrentDeckTrayModeCosmeticCoins();
+			if (currentDeckTrayModeCosmeticCoins != null && currentDeckTrayModeCosmeticCoins.Count > 0 && !m_classCardsCollection.IsManaCostFilterActive && !m_classCardsCollection.IsSingleSetFilterActive && IsSearching())
+			{
+				return true;
+			}
+                return HasAnyCardsAvailable();
+		}
+            default:
+                return true;
+        }
+    }
+
+    private void SetupClassTab(CollectionClassTab classTab, TAG_CLASS classTag, string tabName, bool isTouch)
+    {
+        classTab.Init(classTag);
+        classTab.transform.localScale = classTab.m_DeselectedLocalScale;
+        classTab.transform.localEulerAngles = CollectiblePageManager.TAB_LOCAL_EULERS;
+        classTab.AddEventListener(UIEventType.RELEASE, OnClassTabPressed);
+        classTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
+        classTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
+        classTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
+        classTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
+        classTab.SetReceiveReleaseWithoutMouseDown(isTouch);
+        classTab.gameObject.name = tabName;
+    }
 
-	public override bool JumpToPageWithCard(string cardID, TAG_PREMIUM premium, DelOnPageTransitionComplete callback, object callbackData)
+	private void SetupZilliaxTab(BookTab zilliaxTab, string tabName, bool isTouch, UIEvent.Handler onReleaseHandler)
 	{
-		return JumpToPageWithCard(cardID, premium, callback, callbackData, tryClearFilters: true);
+		zilliaxTab.Init();
+		zilliaxTab.transform.localScale = zilliaxTab.m_DeselectedLocalScale;
+		zilliaxTab.transform.localEulerAngles = CollectiblePageManager.TAB_LOCAL_EULERS;
+		zilliaxTab.AddEventListener(UIEventType.RELEASE, onReleaseHandler);
+		zilliaxTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
+		zilliaxTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
+		zilliaxTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
+		zilliaxTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
+		zilliaxTab.SetReceiveReleaseWithoutMouseDown(isTouch);
+		zilliaxTab.gameObject.name = tabName;
+		m_allTabs.Add(zilliaxTab);
+		m_zilliaxTabs.Add(zilliaxTab);
+		m_tabVisibility[zilliaxTab] = false;
 	}
 
-	private bool JumpToPageWithCard(string cardID, TAG_PREMIUM premium, DelOnPageTransitionComplete callback, object callbackData, bool tryClearFilters)
-	{
-		CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-		CollectionTabInfo collectionTabInfo = default(CollectionTabInfo);
-		collectionTabInfo.tagClass = TAG_CLASS.INVALID;
-		CollectionTabInfo tabInfoContext = collectionTabInfo;
-		if (editedDeck != null)
-		{
-			tabInfoContext.tagClass = editedDeck.GetClass();
-		}
-		if (m_classCardsCollection.GetPageContentsForCard(cardID, premium, out var collectionPage, tabInfoContext).Count == 0)
+    protected override void SetUpBookTabs()
+    {
+        if ((bool)UniversalInputManager.UsePhoneUI)
+        {
+            return;
+        }
+        bool flag = UniversalInputManager.Get().IsTouchMode();
+        if (m_deckTemplateTab != null && m_deckTemplateTab.gameObject.activeSelf)
+        {
+            m_allTabs.Add(m_deckTemplateTab);
+            m_classTabs.Add(m_deckTemplateTab);
+            m_deckTemplateTab.AddEventListener(UIEventType.RELEASE, OnDeckTemplateTabPressed);
+            m_deckTemplateTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
+            m_deckTemplateTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
+            m_deckTemplateTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
+            m_deckTemplateTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
+            m_deckTemplateTab.SetReceiveReleaseWithoutMouseDown(flag);
+            m_tabVisibility[m_deckTemplateTab] = true;
+        }
+        for (int i = 0; i < CLASS_TAB_ORDER.Length; i++)
+        {
+            TAG_CLASS classTag = CLASS_TAB_ORDER[i];
+            CollectionClassTab collectionClassTab = (CollectionClassTab)GameUtils.Instantiate(m_tabPrefab, m_tabContainer);
+            SetupClassTab(collectionClassTab, classTag, classTag.ToString(), flag);
+            m_allTabs.Add(collectionClassTab);
+            m_classTabs.Add(collectionClassTab);
+            m_tabVisibility[collectionClassTab] = true;
+            if (i <= 0)
+            {
+                m_deselectedTabHalfWidth = collectionClassTab.GetComponent<BoxCollider>().bounds.extents.x;
+            }
+        }
+		SetupZilliaxTab(m_ZilliaxModulesTab, "ZILLIAX_FUNCTIONAL", flag, OnZilliaxFunctionalTabPressed);
+		SetupZilliaxTab(m_ZilliaxBlueprintsTab, "ZILLIAX_VERSIONS", flag, OnZilliaxSavedVersionsTabPressed);
+        if (m_heroSkinsTab != null)
+        {
+            m_heroSkinsTab.Init(TAG_CLASS.NEUTRAL);
+            m_heroSkinsTab.AddEventListener(UIEventType.RELEASE, OnHeroSkinsTabPressed);
+            m_heroSkinsTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
+            m_heroSkinsTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
+            m_heroSkinsTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
+            m_heroSkinsTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
+            m_heroSkinsTab.SetReceiveReleaseWithoutMouseDown(flag);
+            m_allTabs.Add(m_heroSkinsTab);
+            m_tabVisibility[m_heroSkinsTab] = true;
+            m_heroSkinsTabPos = m_heroSkinsTab.transform.localPosition;
+        }
+        if (m_cardBacksTab != null)
+        {
+            m_cardBacksTab.Init(TAG_CLASS.NEUTRAL);
+            m_cardBacksTab.AddEventListener(UIEventType.RELEASE, OnCardBacksTabPressed);
+            m_cardBacksTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
+            m_cardBacksTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
+            m_cardBacksTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
+            m_cardBacksTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
+            m_cardBacksTab.SetReceiveReleaseWithoutMouseDown(flag);
+            m_allTabs.Add(m_cardBacksTab);
+            m_tabVisibility[m_cardBacksTab] = true;
+            m_cardBacksTabPos = m_cardBacksTab.transform.localPosition;
+        }
+        if (m_coinsTab != null)
+        {
+            m_coinsTab.Init(TAG_CLASS.NEUTRAL);
+            m_coinsTab.AddEventListener(UIEventType.RELEASE, OnCoinsTabPressed);
+            m_coinsTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
+            m_coinsTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
+            m_coinsTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
+            m_coinsTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
+            m_coinsTab.SetReceiveReleaseWithoutMouseDown(flag);
+            m_allTabs.Add(m_coinsTab);
+            m_tabVisibility[m_coinsTab] = true;
+            m_coinsTabPos = m_coinsTab.transform.localPosition;
+        }
+        PositionBookTabs(animate: false);
+        m_initializedTabPositions = true;
+    }
+
+    protected override void PositionBookTabs(bool animate)
+    {
+        Vector3 position = m_tabContainer.transform.position;
+        int num = CLASS_TAB_ORDER.Length;
+        if (m_deckTemplateTab != null && m_deckTemplateTab.gameObject.activeSelf)
+        {
+            num++;
+        }
+        for (int i = 0; i < num; i++)
+        {
+            CollectionClassTab collectionClassTab = m_classTabs[i];
+            Vector3 vector;
+            if (ShouldShowTab(collectionClassTab))
+            {
+                collectionClassTab.SetTargetVisibility(visible: true);
+                position.x += m_spaceBetweenTabs;
+                position.x += m_deselectedTabHalfWidth;
+                vector = m_tabContainer.transform.InverseTransformPoint(position);
+                if (collectionClassTab == m_currentTab)
+                {
+                    vector.y = collectionClassTab.m_SelectedLocalYPos;
+                    vector.z = collectionClassTab.GetOriginalLocalPosition().z;
+                }
+                position.x += m_deselectedTabHalfWidth;
+            }
+            else
+            {
+                collectionClassTab.SetTargetVisibility(visible: false);
+                vector = collectionClassTab.transform.localPosition;
+                vector.z = CollectiblePageManager.HIDDEN_TAB_LOCAL_Z_POS;
+            }
+            if (animate)
+            {
+                collectionClassTab.SetTargetLocalPosition(vector);
+                continue;
+            }
+            collectionClassTab.SetIsVisible(collectionClassTab.ShouldBeVisible());
+            collectionClassTab.transform.localPosition = vector;
+        }
+        bool showTab = ShouldShowTab(m_heroSkinsTab);
+        PositionFixedTab(showTab, m_heroSkinsTab, m_heroSkinsTabPos, animate);
+        bool showTab2 = ShouldShowTab(m_cardBacksTab);
+        PositionFixedTab(showTab2, m_cardBacksTab, m_cardBacksTabPos, animate);
+        bool showTab3 = ShouldShowTab(m_coinsTab);
+        PositionFixedTab(showTab3, m_coinsTab, m_coinsTabPos, animate);
+		bool flag = m_initializedTabPositions && m_zilliaxTabs.Count > 0 && ShouldShowTab(m_zilliaxTabs[0]);
+		Vector3 position2 = m_tabContainer.transform.position;
+		foreach (BookTab zilliaxTab in m_zilliaxTabs)
 		{
-			if (tryClearFilters)
+			Vector3 vector2;
+			if (flag)
 			{
-				CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-				if (collectionManagerDisplay != null)
+				zilliaxTab.SetTargetVisibility(visible: true);
+				position2.x += m_spaceBetweenTabs;
+				position2.x += m_deselectedTabHalfWidth;
+				vector2 = m_tabContainer.transform.InverseTransformPoint(position2);
+				if (zilliaxTab == m_currentTab)
 				{
-					collectionManagerDisplay.ResetFilters(updateVisuals: false);
+					vector2.y = zilliaxTab.m_SelectedLocalYPos;
+					vector2.z = zilliaxTab.GetOriginalLocalPosition().z;
 				}
-				return JumpToPageWithCard(cardID, premium, callback, callbackData, tryClearFilters: false);
+				position2.x += m_deselectedTabHalfWidth;
 			}
-			return false;
-		}
-		if (m_currentPageNum == collectionPage)
-		{
-			return false;
-		}
-		FlipToPage(collectionPage, callback, callbackData);
-		return true;
-	}
-
-	public void FilterByManaCost(int cost, bool transitionPage = true)
-	{
-		if (cost == -1)
-		{
-			m_cardsCollection.FilterManaCost(null);
-		}
-		else
-		{
-			m_cardsCollection.FilterManaCost(cost);
-		}
-		UpdateFilteredCards();
-		if (transitionPage)
-		{
-			TransitionPageWhenReady(PageTransitionType.NONE, useCurrentPageNum: false, null, null);
-		}
-	}
-
-	public override void ChangeSearchTextFilter(string newSearchText, DelOnPageTransitionComplete callback, object callbackData, bool transitionPage = true)
-	{
-		if (newSearchText == "")
-		{
-			RemoveSearchTextFilter(callback, callbackData, transitionPage);
-			return;
+			else
+			{
+				zilliaxTab.SetTargetVisibility(visible: false);
+				vector2 = zilliaxTab.transform.localPosition;
+				vector2.z = CollectiblePageManager.HIDDEN_TAB_LOCAL_Z_POS;
+			}
+			if (animate)
+			{
+				zilliaxTab.SetTargetLocalPosition(vector2);
+				continue;
+			}
+			zilliaxTab.SetIsVisible(zilliaxTab.ShouldBeVisible());
+			zilliaxTab.transform.localPosition = vector2;
 		}
-		m_searchText = newSearchText;
-		UpdateNonCardSearchTextFilters();
-		base.ChangeSearchTextFilter(m_searchText, callback, callbackData, transitionPage);
-	}
-
-	public override void RemoveSearchTextFilter(DelOnPageTransitionComplete callback, object callbackData, bool transitionPage = true)
-	{
-		m_searchText = null;
-		UpdateNonCardSearchTextFilters();
-		base.RemoveSearchTextFilter(callback, callbackData, transitionPage);
-	}
+        if (animate)
+        {
+            StopCoroutine(CollectiblePageManager.ANIMATE_TABS_COROUTINE_NAME);
+            StartCoroutine(CollectiblePageManager.ANIMATE_TABS_COROUTINE_NAME);
+        }
+    }
 
-	private void UpdateNonCardSearchTextFilters()
-	{
-		CardBackManager.Get().SetSearchText(m_searchText);
-		CosmeticCoinManager.Get().SetSearchText(m_searchText);
-		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (collectionManagerDisplay != null)
+    private IEnumerator AnimateTabs()
+    {
+        bool playSounds = HeroPickerDisplay.Get() == null || !HeroPickerDisplay.Get().IsShown();
+		List<BookTab> list = new List<BookTab>();
+		List<BookTab> tabsToShow = new List<BookTab>();
+		List<BookTab> tabsToMove = new List<BookTab>();
+        foreach (CollectionClassTab classTab in m_classTabs)
+        {
+            if (classTab.IsVisible() || classTab.ShouldBeVisible())
+            {
+                if (classTab.IsVisible() && classTab.ShouldBeVisible())
+                {
+                    tabsToMove.Add(classTab);
+                }
+                else if (classTab.IsVisible() && !classTab.ShouldBeVisible())
+                {
+                    list.Add(classTab);
+                }
+                else
+                {
+                    tabsToShow.Add(classTab);
+                }
+            }
+        }
+		foreach (BookTab zilliaxTab in m_zilliaxTabs)
 		{
-			switch (collectionManagerDisplay.GetViewMode())
+			if (zilliaxTab.IsVisible() || zilliaxTab.ShouldBeVisible())
 			{
-			case CollectionUtils.ViewMode.HERO_SKINS:
-				if (!IsSearching() && !CollectionManager.Get().IsInEditMode())
+				if (zilliaxTab.IsVisible() && zilliaxTab.ShouldBeVisible())
 				{
-					collectionManagerDisplay.SetViewMode(CollectionUtils.ViewMode.HERO_PICKER, triggerResponse: false);
+					tabsToMove.Add(zilliaxTab);
 				}
-				else
+				else if (zilliaxTab.IsVisible() && !zilliaxTab.ShouldBeVisible())
 				{
-					collectionManagerDisplay.SetHeroSkinClass(null);
+					list.Add(zilliaxTab);
 				}
-				break;
-			case CollectionUtils.ViewMode.HERO_PICKER:
-				if (IsSearching())
+				else
 				{
-					collectionManagerDisplay.SetViewMode(CollectionUtils.ViewMode.HERO_SKINS, triggerResponse: false);
+					tabsToShow.Add(zilliaxTab);
 				}
-				break;
 			}
 		}
-		m_heroesCollection.FilterSearchText(m_searchText);
-		m_heroesCollection.UpdateResults();
-	}
-
-	public bool IsSearching()
-	{
-		return m_searchText != null;
-	}
+        m_tabsAreAnimating = true;
+        if (list.Count > 0)
+        {
+			foreach (BookTab tab in list)
+            {
+                if (playSounds)
+                {
+                    SoundManager.Get().LoadAndPlay("class_tab_retract.prefab:da79957be76b10343999d6fa92a6a2f0", tab.gameObject);
+                }
+                yield return new WaitForSeconds(0.03f);
+                tab.AnimateToTargetPosition(0.1f, iTween.EaseType.easeOutQuad);
+            }
+            yield return new WaitForSeconds(0.1f);
+        }
+        if (tabsToMove.Count > 0)
+        {
+			foreach (BookTab item in tabsToMove)
+            {
+                if (item.WillSlide() && playSounds)
+                {
+                    SoundManager.Get().LoadAndPlay("class_tab_slides_across_top.prefab:04482bc6f531b76468ff92a5b4e979b6", item.gameObject);
+                }
+                item.AnimateToTargetPosition(0.25f, iTween.EaseType.easeOutQuad);
+            }
+            yield return new WaitForSeconds(0.25f);
+        }
+        if (tabsToShow.Count > 0)
+        {
+			foreach (BookTab item2 in tabsToShow)
+            {
+                if (playSounds)
+                {
+                    SoundManager.Get().LoadAndPlay("class_tab_retract.prefab:da79957be76b10343999d6fa92a6a2f0", item2.gameObject);
+                }
+                item2.AnimateToTargetPosition(0.4f, iTween.EaseType.easeOutBounce);
+            }
+            yield return new WaitForSeconds(0.4f);
+        }
+        foreach (CollectionClassTab classTab2 in m_classTabs)
+        {
+            classTab2.SetIsVisible(classTab2.ShouldBeVisible());
+        }
+		foreach (BookTab zilliaxTab2 in m_zilliaxTabs)
+		{
+			zilliaxTab2.SetIsVisible(zilliaxTab2.ShouldBeVisible());
+		}
+        m_tabsAreAnimating = false;
+    }
+
+    private void RemoveGhostingEffectForRuneCards()
+    {
+        foreach (CollectionCardVisual ghostedRuneCard in m_ghostedRuneCards)
+        {
+            Actor actor = ghostedRuneCard.GetActor();
+            if (actor != null)
+            {
+                actor.GhostCardEffect(GhostCard.Type.NONE, actor.GetPremium());
+            }
+        }
+        m_ghostedRuneCards.Clear();
+    }
+
+    public void AddGhostedRuneCards(List<CollectionCardVisual> runeCards)
+    {
+        foreach (CollectionCardVisual runeCard in runeCards)
+        {
+            if (!m_ghostedRuneCards.Contains(runeCard))
+            {
+                m_ghostedRuneCards.Add(runeCard);
+            }
+        }
+    }
 
-	public string GetSearchText()
-	{
-		return m_searchText;
-	}
+	private void OnDeckTrayRunesAdded(CollectionDeck deck, RunePattern cardRunesAdded)
+    {
+        m_deckRunesWereUpdatedOnCurrentPage = !deck.Runes.Matches(m_originalDeckRunesForCurrentPage);
+        RemoveGhostingEffectForRuneCards();
+        UpdatePageGhostingForInvalidRunes(deck.Runes);
+    }
+
+    private void OnCraftingTrayShown()
+    {
+        RemoveGhostingEffectForRuneCards();
+    }
+
+    private void OnCraftingTrayHidden()
+    {
+        CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+        if (editedDeck != null && editedDeck.HasClass(TAG_CLASS.DEATHKNIGHT))
+        {
+            UpdatePageGhostingForInvalidRunes(editedDeck.Runes);
+        }
+    }
+
+    private void OnHideLockedRunesCheckboxToggled(bool isChecked)
+    {
+        IsShowingLockedRuneCards = isChecked;
+        if (IsShowingLockedRuneCards)
+        {
+            if (m_deckRunesWereUpdatedOnCurrentPage || m_classCardsCollection.HasHiddenDeathKnightCards)
+            {
+                m_classCardsCollection.UpdateResults();
+                FlipToPage(1, null, null, PageTransitionType.MANY_PAGE_LEFT);
+            }
+        }
+        else
+        {
+            FlipToNextFilteredDeathKnightPage(PageTransitionType.NONE);
+        }
+    }
+
+    private void UpdatePageGhostingForInvalidRunes(RunePattern runes)
+    {
+        CollectiblePageDisplay currentCollectiblePage = GetCurrentCollectiblePage();
+        if (!(currentCollectiblePage == null))
+        {
+            AddGhostedRuneCards(currentCollectiblePage.ApplyRuneCardGhostEffectsForCurrentPage(runes));
+        }
+    }
+
+    private void RuneIndicatorVisualOnRunePatternChanged(RunePattern currentDeckRunes)
+    {
+        m_deckRunesWereUpdatedOnCurrentPage = !currentDeckRunes.Matches(m_originalDeckRunesForCurrentPage);
+        RemoveGhostingEffectForRuneCards();
+        UpdatePageGhostingForInvalidRunes(currentDeckRunes);
+    }
+
+    private void SetCurrentClassTabInfo(CollectionTabInfo tabInfo)
+    {
+		CollectibleDisplay collectibleDisplay = CollectionManager.Get().GetCollectibleDisplay();
+		CollectionUtils.ViewMode viewMode = collectibleDisplay.GetViewMode();
+        if ((bool)UniversalInputManager.UsePhoneUI)
+        {
+            if (m_classFilterHeader == null)
+            {
+                Debug.LogError("CollectionPageManager:SetCurrentClassTab: m_classFilterHeader should not be null when UniversalInputManager.UsePhoneUI is true");
+                return;
+            }
+            if (!ShouldClassFilterBeVisible())
+            {
+                m_classFilterHeader.gameObject.SetActive(value: false);
+                return;
+            }
+            m_classFilterHeader.gameObject.SetActive(value: true);
+			m_classFilterHeader.SetMode(viewMode, tabInfo.tagClass, tabInfo.stringOverride);
+            return;
+        }
+		BookTab bookTab = null;
+        switch (viewMode)
+        {
+            case CollectionUtils.ViewMode.CARDS:
+			if (collectibleDisplay.GetViewSubmode() != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
+			{
+                if (tabInfo.tagClass != 0)
+                {
+					bookTab = m_classTabs.Find((CollectionClassTab obj) => obj.TabInfo.tagClass == tabInfo.tagClass && obj.m_tabViewMode != CollectionUtils.ViewMode.DECK_TEMPLATE);
+				}
+			}
+			else
+			{
+				bookTab = ((m_currentPageNum == 1) ? m_ZilliaxModulesTab : m_ZilliaxBlueprintsTab);
+                }
+                break;
+            case CollectionUtils.ViewMode.HERO_SKINS:
+            case CollectionUtils.ViewMode.HERO_PICKER:
+                {
+                    bool flag = viewMode == CollectionUtils.ViewMode.HERO_PICKER;
+                    bool flag2 = IsSearching() || CollectionManager.Get().GetEditedDeck() != null;
+                    if (flag || (flag2 && !flag))
+                    {
+				bookTab = m_heroSkinsTab;
+                    }
+                    break;
+                }
+            case CollectionUtils.ViewMode.CARD_BACKS:
+			bookTab = m_cardBacksTab;
+                break;
+            case CollectionUtils.ViewMode.COINS:
+			bookTab = m_coinsTab;
+                break;
+            default:
+			bookTab = null;
+                break;
+        }
+		if (!(bookTab == m_currentTab))
+        {
+            DeselectCurrentTab();
+			m_currentTab = bookTab;
+            if (m_currentTab != null)
+            {
+                StopCoroutine(CollectiblePageManager.SELECT_TAB_COROUTINE_NAME);
+                StartCoroutine(CollectiblePageManager.SELECT_TAB_COROUTINE_NAME, m_currentTab);
+            }
+        }
+    }
+
+    public void SetDeckRuleset(DeckRuleset deckRuleset, bool refresh = false)
+    {
+        m_cardsCollection.SetDeckRuleset(deckRuleset);
+        if (refresh)
+        {
+            UpdateFilteredCards();
+            TransitionPageWhenReady(PageTransitionType.NONE, useCurrentPageNum: false, null, null);
+        }
+    }
+
+    private void OnClassTabPressed(UIEvent e)
+    {
+        if (CanUserTurnPages())
+        {
+            CollectionClassTab collectionClassTab = e.GetElement() as CollectionClassTab;
+            if (!(collectionClassTab == null) && !(collectionClassTab == m_currentTab))
+            {
+                JumpToCollectionClassPage(collectionClassTab.TabInfo);
+            }
+        }
+    }
 
-	public void UpdateClassTabNewCardCounts()
+	private void OnZilliaxFunctionalTabPressed(UIEvent e)
 	{
-		foreach (CollectionClassTab classTab in m_classTabs)
+		if (CanUserTurnPages() && (CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode() != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES || base.CurrentPageNum != 1))
 		{
-			TAG_CLASS tagClass = classTab.TabInfo.tagClass;
-			int numNewItems = ((classTab.m_tabViewMode != CollectionUtils.ViewMode.DECK_TEMPLATE) ? GetNumNewCardsForClass(tagClass) : 0);
-			classTab.UpdateNewItemCount(numNewItems);
+			FlipToPage(1, null, null);
+			this.OnZilliaxTabPressed?.Invoke();
 		}
 	}
 
-	public int GetNumNewCardsForClass(TAG_CLASS tagClass)
+	private void OnZilliaxSavedVersionsTabPressed(UIEvent e)
 	{
-		return m_classCardsCollection.GetNumNewCardsForTab(new CollectionTabInfo
-		{
-			tagClass = tagClass
-		});
-	}
-
-	public override void NotifyOfCollectionChanged()
-	{
-		UpdateMassDisenchant();
-	}
-
-	public void OnDoneEditingDeck()
-	{
-		FormatType themeShowing = CollectionManager.Get().GetThemeShowing();
-		List<TAG_CLASS> deckClasses = RankMgr.GetExcludedClassesForFormat(themeShowing);
-		m_cardsCollection.FilterTheseClasses(CLASS_TAB_ORDER.Where((TAG_CLASS tag) => !deckClasses.Contains(tag)).ToArray());
-		UpdateFilteredCards();
-		m_heroesCollection.FilterTheseClasses(null);
-		m_heroesCollection.FilterOnlyOwned(owned: false);
-		m_heroesCollection.UpdateResults();
-		PageTransitionType transitionType = ((CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.CARDS) ? PageTransitionType.SINGLE_PAGE_LEFT : PageTransitionType.NONE);
-		TransitionPageWhenReady(transitionType, useCurrentPageNum: false, null, null);
-		UpdateCraftingModeButtonDustBottleVisibility(CollectionManager.Get().GetCardsToMassDisenchantCount());
-		NotificationManager.Get().DestroyNotificationWithText(GameStrings.Get("GLUE_COLLECTION_TUTORIAL_TEMPLATE_REPLACE_1"));
-		NotificationManager.Get().DestroyNotificationWithText(GameStrings.Get("GLUE_COLLECTION_TUTORIAL_TEMPLATE_REPLACE_2"));
-		NotificationManager.Get().DestroyNotificationWithText(GameStrings.Get("GLUE_COLLECTION_TUTORIAL_REPLACE_WILD_CARDS"));
-		NotificationManager.Get().DestroyNotificationWithText(GameStrings.Get("GLUE_COLLECTION_TUTORIAL_REPLACE_WILD_CARDS_NPR"));
-		CollectionDeckTray.Get().GetCardsContent().HideDeckHelpPopup();
-	}
-
-	public void UpdateCraftingModeButtonDustBottleVisibility(int disenchantCount)
-	{
-		CollectibleDisplay collectibleDisplay = CollectionManager.Get().GetCollectibleDisplay();
-		bool flag = collectibleDisplay.GetViewMode() == CollectionUtils.ViewMode.CARDS;
-		bool flag2 = (bool)UniversalInputManager.UsePhoneUI && collectibleDisplay.GetViewMode() == CollectionUtils.ViewMode.MASS_DISENCHANT;
-		bool show = (flag || flag2) && (disenchantCount > 0 || (bool)UniversalInputManager.UsePhoneUI);
-		CollectionManagerDisplay collectionManagerDisplay = collectibleDisplay as CollectionManagerDisplay;
-		if (collectionManagerDisplay != null)
-		{
-			collectionManagerDisplay.m_craftingModeButton.ShowDustBottle(show, flag);
-		}
-	}
-
-	public int GetMassDisenchantAmount()
-	{
-		return CollectionManager.Get().GetCardsToMassDisenchantCount();
-	}
-
-	public void LoadMassDisenchantScreen()
-	{
-		if (!(m_massDisenchant != null))
-		{
-			GameObject gameObject = AssetLoader.Get().InstantiatePrefab("MassDisenchant.prefab:0bfb8a7db15d748b291be3096753ca24");
-			m_massDisenchant = gameObject.GetComponent<MassDisenchant>();
-			m_massDisenchant.Hide();
-		}
-	}
-
-	public bool HasClassCardsAvailable(TAG_CLASS classTag)
-	{
-		return m_classCardsCollection.GetNumPagesForTab(new CollectionTabInfo
-		{
-			tagClass = classTag
-		}) > 0;
-	}
-
-	public bool HasAnyCardsAvailable()
-	{
-		return m_classCardsCollection.GetTotalNumPages() > 0;
-	}
-
-	public void ShowCraftingModeCards(DelOnPageTransitionComplete callback = null, object callbackData = null, bool showUncraftable = false, bool showNormalOwned = false, bool showNormalMissing = false, bool showPremiumOwned = false, bool showPremiumMissing = false, bool updatePage = true, bool toggleChanged = false)
-	{
-		List<CollectibleCardFilter.FilterMask> list = new List<CollectibleCardFilter.FilterMask>();
-		if (showNormalOwned)
-		{
-			list.Add(CollectibleCardFilter.FilterMask.PREMIUM_NORMAL | CollectibleCardFilter.FilterMask.OWNED);
-		}
-		if (showNormalMissing)
-		{
-			list.Add(CollectibleCardFilter.FilterMask.PREMIUM_NORMAL | CollectibleCardFilter.FilterMask.UNOWNED);
-		}
-		if (showPremiumOwned)
-		{
-			list.Add(CollectibleCardFilter.FilterMask.PREMIUM_GOLDEN | CollectibleCardFilter.FilterMask.OWNED);
-			list.Add(CollectibleCardFilter.FilterMask.PREMIUM_DIAMOND | CollectibleCardFilter.FilterMask.OWNED);
-			list.Add(CollectibleCardFilter.FilterMask.PREMIUM_SIGNATURE | CollectibleCardFilter.FilterMask.OWNED);
-		}
-		if (showPremiumMissing)
-		{
-			list.Add(CollectibleCardFilter.FilterMask.PREMIUM_GOLDEN | CollectibleCardFilter.FilterMask.UNOWNED);
-			list.Add(CollectibleCardFilter.FilterMask.PREMIUM_DIAMOND | CollectibleCardFilter.FilterMask.UNOWNED);
-			list.Add(CollectibleCardFilter.FilterMask.PREMIUM_SIGNATURE | CollectibleCardFilter.FilterMask.UNOWNED);
-		}
-		bool? isCraftable = null;
-		if (!showUncraftable)
-		{
-			isCraftable = true;
-		}
-		m_cardsCollection.FilterOnlyOwned(owned: false);
-		m_cardsCollection.FilterByMask(list);
-		m_cardsCollection.FilterByCraftability(isCraftable);
-		m_cardsCollection.FilterLeagueBannedCardsSubset(RankMgr.Get().GetBannedCardsInCurrentLeague());
-		UpdateFilteredCards();
-		if (toggleChanged)
-		{
-			m_lastCollectibleAnchor = null;
-		}
-		if (updatePage)
-		{
-			PageTransitionType transitionType = (toggleChanged ? PageTransitionType.MANY_PAGE_LEFT : PageTransitionType.NONE);
-			TransitionPageWhenReady(transitionType, useCurrentPageNum: false, callback, callbackData);
-		}
-	}
-
-	protected override bool CanUserTurnPages()
-	{
-		if (CraftingManager.GetIsInCraftingMode())
-		{
-			return false;
-		}
-		if (SceneMgr.Get().IsInDuelsMode() && !PvPDungeonRunScene.IsEditingDeck())
-		{
-			return false;
-		}
-		CardBackInfoManager cardBackInfoManager = CardBackInfoManager.Get();
-		if (cardBackInfoManager != null && cardBackInfoManager.IsPreviewing)
-		{
-			return false;
-		}
-		HeroSkinInfoManager heroSkinInfoManager = HeroSkinInfoManager.Get();
-		if (heroSkinInfoManager != null && heroSkinInfoManager.IsShowingPreview)
-		{
-			return false;
-		}
-		return base.CanUserTurnPages();
-	}
-
-	private CollectionPageDisplay PageAsCollectionPage(BookPageDisplay page)
-	{
-		if (!(page is CollectionPageDisplay))
-		{
-			Log.CollectionManager.PrintError("Page in CollectionPageManager is not a CollectionPageDisplay!  This should not happen!");
-		}
-		return page as CollectionPageDisplay;
-	}
-
-	protected override bool ShouldShowTab(BookTab tab)
-	{
-		if (!m_initializedTabPositions)
-		{
-			return true;
-		}
-		if (m_hideNonDeckTemplateTabs)
-		{
-			return tab.m_tabViewMode == CollectionUtils.ViewMode.DECK_TEMPLATE;
-		}
-		CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-		bool flag = editedDeck != null;
-		CollectionUtils.ViewSubmode viewSubmode = CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode();
-		switch (tab.m_tabViewMode)
-		{
-		case CollectionUtils.ViewMode.CARDS:
-		{
-			if (m_zilliaxTabs.Contains(tab))
-			{
-				return viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES;
-			}
-			CollectionClassTab collectionClassTab = tab as CollectionClassTab;
-			if (collectionClassTab == null)
-			{
-				Log.CollectionManager.PrintError("CollectionPageManager.ShouldShowTab passed a non-CollectionClassTab object.");
-				return false;
-			}
-			if (viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
-			{
-				return false;
-			}
-			TAG_CLASS tagClass = collectionClassTab.TabInfo.tagClass;
-			if (HasClassCardsAvailable(tagClass))
-			{
-				return true;
-			}
-			if (flag && !HasAnyCardsAvailable())
-			{
-				return editedDeck.GetClasses().Contains(tagClass);
-			}
-			return false;
-		}
-		case CollectionUtils.ViewMode.DECK_TEMPLATE:
-			if (flag)
-			{
-				return !SceneMgr.Get().IsInTavernBrawlMode();
-			}
-			return false;
-		case CollectionUtils.ViewMode.HERO_SKINS:
-		{
-			if (SceneMgr.Get().IsInDuelsMode())
-			{
-				return false;
-			}
-			if (flag)
-			{
-				if (editedDeck.HasUIHeroOverride())
-				{
-					return false;
-				}
-				if (viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
-				{
-					return false;
-				}
-				return CollectionManager.Get().GetCountOfOwnedHeroesForClass(editedDeck.GetClass()) > 1;
-			}
-			List<CollectibleCard> allResults = m_heroesCollection.GetAllResults();
-			if (allResults != null && allResults.Count > 0 && !m_classCardsCollection.IsManaCostFilterActive && !m_classCardsCollection.IsSingleSetFilterActive && IsSearching())
-			{
-				return true;
-			}
-			return HasAnyCardsAvailable();
-		}
-		case CollectionUtils.ViewMode.CARD_BACKS:
-		{
-			if (flag)
-			{
-				if (viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
-				{
-					return false;
-				}
-				HashSet<int> cardBacksOwned = CardBackManager.Get().GetCardBacksOwned();
-				if (cardBacksOwned != null)
-				{
-					return cardBacksOwned.Count > 1;
-				}
-				return false;
-			}
-			HashSet<int> currentDeckTrayModeCardBackIds = GetCurrentDeckTrayModeCardBackIds();
-			if (currentDeckTrayModeCardBackIds != null && currentDeckTrayModeCardBackIds.Count > 0 && !m_classCardsCollection.IsManaCostFilterActive && !m_classCardsCollection.IsSingleSetFilterActive && IsSearching())
-			{
-				return true;
-			}
-			return HasAnyCardsAvailable();
-		}
-		case CollectionUtils.ViewMode.COINS:
-		{
-			if (SceneMgr.Get().IsInDuelsMode())
-			{
-				return false;
-			}
-			if (flag)
-			{
-				if (viewSubmode == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
-				{
-					return false;
-				}
-				return CosmeticCoinManager.Get().GetTotalCoinsOwned() > 1;
-			}
-			List<CollectibleCard> currentDeckTrayModeCosmeticCoins = GetCurrentDeckTrayModeCosmeticCoins();
-			if (currentDeckTrayModeCosmeticCoins != null && currentDeckTrayModeCosmeticCoins.Count > 0 && !m_classCardsCollection.IsManaCostFilterActive && !m_classCardsCollection.IsSingleSetFilterActive && IsSearching())
-			{
-				return true;
-			}
-			return HasAnyCardsAvailable();
-		}
-		default:
-			return true;
-		}
-	}
-
-	private void SetupClassTab(CollectionClassTab classTab, TAG_CLASS classTag, string tabName, bool isTouch)
-	{
-		classTab.Init(classTag);
-		classTab.transform.localScale = classTab.m_DeselectedLocalScale;
-		classTab.transform.localEulerAngles = CollectiblePageManager.TAB_LOCAL_EULERS;
-		classTab.AddEventListener(UIEventType.RELEASE, OnClassTabPressed);
-		classTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
-		classTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
-		classTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
-		classTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
-		classTab.SetReceiveReleaseWithoutMouseDown(isTouch);
-		classTab.gameObject.name = tabName;
-	}
-
-	private void SetupZilliaxTab(BookTab zilliaxTab, string tabName, bool isTouch, UIEvent.Handler onReleaseHandler)
-	{
-		zilliaxTab.Init();
-		zilliaxTab.transform.localScale = zilliaxTab.m_DeselectedLocalScale;
-		zilliaxTab.transform.localEulerAngles = CollectiblePageManager.TAB_LOCAL_EULERS;
-		zilliaxTab.AddEventListener(UIEventType.RELEASE, onReleaseHandler);
-		zilliaxTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
-		zilliaxTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
-		zilliaxTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
-		zilliaxTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
-		zilliaxTab.SetReceiveReleaseWithoutMouseDown(isTouch);
-		zilliaxTab.gameObject.name = tabName;
-		m_allTabs.Add(zilliaxTab);
-		m_zilliaxTabs.Add(zilliaxTab);
-		m_tabVisibility[zilliaxTab] = false;
-	}
-
-	protected override void SetUpBookTabs()
-	{
-		if ((bool)UniversalInputManager.UsePhoneUI)
-		{
-			return;
-		}
-		bool flag = UniversalInputManager.Get().IsTouchMode();
-		if (m_deckTemplateTab != null && m_deckTemplateTab.gameObject.activeSelf)
-		{
-			m_allTabs.Add(m_deckTemplateTab);
-			m_classTabs.Add(m_deckTemplateTab);
-			m_deckTemplateTab.AddEventListener(UIEventType.RELEASE, OnDeckTemplateTabPressed);
-			m_deckTemplateTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
-			m_deckTemplateTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
-			m_deckTemplateTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
-			m_deckTemplateTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
-			m_deckTemplateTab.SetReceiveReleaseWithoutMouseDown(flag);
-			m_tabVisibility[m_deckTemplateTab] = true;
-		}
-		for (int i = 0; i < CLASS_TAB_ORDER.Length; i++)
-		{
-			TAG_CLASS classTag = CLASS_TAB_ORDER[i];
-			CollectionClassTab collectionClassTab = (CollectionClassTab)GameUtils.Instantiate(m_tabPrefab, m_tabContainer);
-			SetupClassTab(collectionClassTab, classTag, classTag.ToString(), flag);
-			m_allTabs.Add(collectionClassTab);
-			m_classTabs.Add(collectionClassTab);
-			m_tabVisibility[collectionClassTab] = true;
-			if (i <= 0)
-			{
-				m_deselectedTabHalfWidth = collectionClassTab.GetComponent<BoxCollider>().bounds.extents.x;
-			}
-		}
-		SetupZilliaxTab(m_ZilliaxModulesTab, "ZILLIAX_FUNCTIONAL", flag, OnZilliaxFunctionalTabPressed);
-		SetupZilliaxTab(m_ZilliaxBlueprintsTab, "ZILLIAX_VERSIONS", flag, OnZilliaxSavedVersionsTabPressed);
-		if (m_heroSkinsTab != null)
-		{
-			m_heroSkinsTab.Init(TAG_CLASS.NEUTRAL);
-			m_heroSkinsTab.AddEventListener(UIEventType.RELEASE, OnHeroSkinsTabPressed);
-			m_heroSkinsTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
-			m_heroSkinsTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
-			m_heroSkinsTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
-			m_heroSkinsTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
-			m_heroSkinsTab.SetReceiveReleaseWithoutMouseDown(flag);
-			m_allTabs.Add(m_heroSkinsTab);
-			m_tabVisibility[m_heroSkinsTab] = true;
-			m_heroSkinsTabPos = m_heroSkinsTab.transform.localPosition;
-		}
-		if (m_cardBacksTab != null)
-		{
-			m_cardBacksTab.Init(TAG_CLASS.NEUTRAL);
-			m_cardBacksTab.AddEventListener(UIEventType.RELEASE, OnCardBacksTabPressed);
-			m_cardBacksTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
-			m_cardBacksTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
-			m_cardBacksTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
-			m_cardBacksTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
-			m_cardBacksTab.SetReceiveReleaseWithoutMouseDown(flag);
-			m_allTabs.Add(m_cardBacksTab);
-			m_tabVisibility[m_cardBacksTab] = true;
-			m_cardBacksTabPos = m_cardBacksTab.transform.localPosition;
-		}
-		if (m_coinsTab != null)
-		{
-			m_coinsTab.Init(TAG_CLASS.NEUTRAL);
-			m_coinsTab.AddEventListener(UIEventType.RELEASE, OnCoinsTabPressed);
-			m_coinsTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver);
-			m_coinsTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut);
-			m_coinsTab.AddEventListener(UIEventType.ROLLOVER, base.OnTabOver_Touch);
-			m_coinsTab.AddEventListener(UIEventType.ROLLOUT, base.OnTabOut_Touch);
-			m_coinsTab.SetReceiveReleaseWithoutMouseDown(flag);
-			m_allTabs.Add(m_coinsTab);
-			m_tabVisibility[m_coinsTab] = true;
-			m_coinsTabPos = m_coinsTab.transform.localPosition;
-		}
-		PositionBookTabs(animate: false);
-		m_initializedTabPositions = true;
-	}
-
-	protected override void PositionBookTabs(bool animate)
-	{
-		Vector3 position = m_tabContainer.transform.position;
-		int num = CLASS_TAB_ORDER.Length;
-		if (m_deckTemplateTab != null && m_deckTemplateTab.gameObject.activeSelf)
-		{
-			num++;
-		}
-		for (int i = 0; i < num; i++)
-		{
-			CollectionClassTab collectionClassTab = m_classTabs[i];
-			Vector3 vector;
-			if (ShouldShowTab(collectionClassTab))
-			{
-				collectionClassTab.SetTargetVisibility(visible: true);
-				position.x += m_spaceBetweenTabs;
-				position.x += m_deselectedTabHalfWidth;
-				vector = m_tabContainer.transform.InverseTransformPoint(position);
-				if (collectionClassTab == m_currentTab)
-				{
-					vector.y = collectionClassTab.m_SelectedLocalYPos;
-					vector.z = collectionClassTab.GetOriginalLocalPosition().z;
-				}
-				position.x += m_deselectedTabHalfWidth;
-			}
-			else
-			{
-				collectionClassTab.SetTargetVisibility(visible: false);
-				vector = collectionClassTab.transform.localPosition;
-				vector.z = CollectiblePageManager.HIDDEN_TAB_LOCAL_Z_POS;
-			}
-			if (animate)
-			{
-				collectionClassTab.SetTargetLocalPosition(vector);
-				continue;
-			}
-			collectionClassTab.SetIsVisible(collectionClassTab.ShouldBeVisible());
-			collectionClassTab.transform.localPosition = vector;
-		}
-		bool showTab = ShouldShowTab(m_heroSkinsTab);
-		PositionFixedTab(showTab, m_heroSkinsTab, m_heroSkinsTabPos, animate);
-		bool showTab2 = ShouldShowTab(m_cardBacksTab);
-		PositionFixedTab(showTab2, m_cardBacksTab, m_cardBacksTabPos, animate);
-		bool showTab3 = ShouldShowTab(m_coinsTab);
-		PositionFixedTab(showTab3, m_coinsTab, m_coinsTabPos, animate);
-		bool flag = m_initializedTabPositions && m_zilliaxTabs.Count > 0 && ShouldShowTab(m_zilliaxTabs[0]);
-		Vector3 position2 = m_tabContainer.transform.position;
-		foreach (BookTab zilliaxTab in m_zilliaxTabs)
-		{
-			Vector3 vector2;
-			if (flag)
-			{
-				zilliaxTab.SetTargetVisibility(visible: true);
-				position2.x += m_spaceBetweenTabs;
-				position2.x += m_deselectedTabHalfWidth;
-				vector2 = m_tabContainer.transform.InverseTransformPoint(position2);
-				if (zilliaxTab == m_currentTab)
-				{
-					vector2.y = zilliaxTab.m_SelectedLocalYPos;
-					vector2.z = zilliaxTab.GetOriginalLocalPosition().z;
-				}
-				position2.x += m_deselectedTabHalfWidth;
-			}
-			else
-			{
-				zilliaxTab.SetTargetVisibility(visible: false);
-				vector2 = zilliaxTab.transform.localPosition;
-				vector2.z = CollectiblePageManager.HIDDEN_TAB_LOCAL_Z_POS;
-			}
-			if (animate)
-			{
-				zilliaxTab.SetTargetLocalPosition(vector2);
-				continue;
-			}
-			zilliaxTab.SetIsVisible(zilliaxTab.ShouldBeVisible());
-			zilliaxTab.transform.localPosition = vector2;
-		}
-		if (animate)
-		{
-			StopCoroutine(CollectiblePageManager.ANIMATE_TABS_COROUTINE_NAME);
-			StartCoroutine(CollectiblePageManager.ANIMATE_TABS_COROUTINE_NAME);
-		}
-	}
-
-	private IEnumerator AnimateTabs()
-	{
-		bool playSounds = HeroPickerDisplay.Get() == null || !HeroPickerDisplay.Get().IsShown();
-		List<BookTab> list = new List<BookTab>();
-		List<BookTab> tabsToShow = new List<BookTab>();
-		List<BookTab> tabsToMove = new List<BookTab>();
-		foreach (CollectionClassTab classTab in m_classTabs)
-		{
-			if (classTab.IsVisible() || classTab.ShouldBeVisible())
-			{
-				if (classTab.IsVisible() && classTab.ShouldBeVisible())
-				{
-					tabsToMove.Add(classTab);
-				}
-				else if (classTab.IsVisible() && !classTab.ShouldBeVisible())
-				{
-					list.Add(classTab);
-				}
-				else
-				{
-					tabsToShow.Add(classTab);
-				}
-			}
-		}
-		foreach (BookTab zilliaxTab in m_zilliaxTabs)
-		{
-			if (zilliaxTab.IsVisible() || zilliaxTab.ShouldBeVisible())
-			{
-				if (zilliaxTab.IsVisible() && zilliaxTab.ShouldBeVisible())
-				{
-					tabsToMove.Add(zilliaxTab);
-				}
-				else if (zilliaxTab.IsVisible() && !zilliaxTab.ShouldBeVisible())
-				{
-					list.Add(zilliaxTab);
-				}
-				else
-				{
-					tabsToShow.Add(zilliaxTab);
-				}
-			}
-		}
-		m_tabsAreAnimating = true;
-		if (list.Count > 0)
-		{
-			foreach (BookTab tab in list)
-			{
-				if (playSounds)
-				{
-					SoundManager.Get().LoadAndPlay("class_tab_retract.prefab:da79957be76b10343999d6fa92a6a2f0", tab.gameObject);
-				}
-				yield return new WaitForSeconds(0.03f);
-				tab.AnimateToTargetPosition(0.1f, iTween.EaseType.easeOutQuad);
-			}
-			yield return new WaitForSeconds(0.1f);
-		}
-		if (tabsToMove.Count > 0)
-		{
-			foreach (BookTab item in tabsToMove)
-			{
-				if (item.WillSlide() && playSounds)
-				{
-					SoundManager.Get().LoadAndPlay("class_tab_slides_across_top.prefab:04482bc6f531b76468ff92a5b4e979b6", item.gameObject);
-				}
-				item.AnimateToTargetPosition(0.25f, iTween.EaseType.easeOutQuad);
-			}
-			yield return new WaitForSeconds(0.25f);
-		}
-		if (tabsToShow.Count > 0)
-		{
-			foreach (BookTab item2 in tabsToShow)
-			{
-				if (playSounds)
-				{
-					SoundManager.Get().LoadAndPlay("class_tab_retract.prefab:da79957be76b10343999d6fa92a6a2f0", item2.gameObject);
-				}
-				item2.AnimateToTargetPosition(0.4f, iTween.EaseType.easeOutBounce);
-			}
-			yield return new WaitForSeconds(0.4f);
-		}
-		foreach (CollectionClassTab classTab2 in m_classTabs)
-		{
-			classTab2.SetIsVisible(classTab2.ShouldBeVisible());
-		}
-		foreach (BookTab zilliaxTab2 in m_zilliaxTabs)
-		{
-			zilliaxTab2.SetIsVisible(zilliaxTab2.ShouldBeVisible());
-		}
-		m_tabsAreAnimating = false;
-	}
-
-	private void RemoveGhostingEffectForRuneCards()
-	{
-		foreach (CollectionCardVisual ghostedRuneCard in m_ghostedRuneCards)
-		{
-			Actor actor = ghostedRuneCard.GetActor();
-			if (actor != null)
-			{
-				actor.GhostCardEffect(GhostCard.Type.NONE, actor.GetPremium());
-			}
-		}
-		m_ghostedRuneCards.Clear();
-	}
-
-	public void AddGhostedRuneCards(List<CollectionCardVisual> runeCards)
-	{
-		foreach (CollectionCardVisual runeCard in runeCards)
-		{
-			if (!m_ghostedRuneCards.Contains(runeCard))
-			{
-				m_ghostedRuneCards.Add(runeCard);
-			}
-		}
-	}
-
-	private void OnDeckTrayRunesAdded(CollectionDeck deck, RunePattern cardRunesAdded)
-	{
-		m_deckRunesWereUpdatedOnCurrentPage = !deck.Runes.Matches(m_originalDeckRunesForCurrentPage);
-		RemoveGhostingEffectForRuneCards();
-		UpdatePageGhostingForInvalidRunes(deck.Runes);
-	}
-
-	private void OnCraftingTrayShown()
-	{
-		RemoveGhostingEffectForRuneCards();
-	}
-
-	private void OnCraftingTrayHidden()
-	{
-		CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-		if (editedDeck != null && editedDeck.HasClass(TAG_CLASS.DEATHKNIGHT))
-		{
-			UpdatePageGhostingForInvalidRunes(editedDeck.Runes);
-		}
-	}
-
-	private void OnHideLockedRunesCheckboxToggled(bool isChecked)
-	{
-		IsShowingLockedRuneCards = isChecked;
-		if (IsShowingLockedRuneCards)
-		{
-			if (m_deckRunesWereUpdatedOnCurrentPage || m_classCardsCollection.HasHiddenDeathKnightCards)
-			{
-				m_classCardsCollection.UpdateResults();
-				FlipToPage(1, null, null, PageTransitionType.MANY_PAGE_LEFT);
-			}
-		}
-		else
-		{
-			FlipToNextFilteredDeathKnightPage(PageTransitionType.NONE);
-		}
-	}
-
-	private void UpdatePageGhostingForInvalidRunes(RunePattern runes)
-	{
-		CollectiblePageDisplay currentCollectiblePage = GetCurrentCollectiblePage();
-		if (!(currentCollectiblePage == null))
-		{
-			AddGhostedRuneCards(currentCollectiblePage.ApplyRuneCardGhostEffectsForCurrentPage(runes));
-		}
-	}
-
-	private void RuneIndicatorVisualOnRunePatternChanged(RunePattern currentDeckRunes)
-	{
-		m_deckRunesWereUpdatedOnCurrentPage = !currentDeckRunes.Matches(m_originalDeckRunesForCurrentPage);
-		RemoveGhostingEffectForRuneCards();
-		UpdatePageGhostingForInvalidRunes(currentDeckRunes);
-	}
-
-	private void SetCurrentClassTabInfo(CollectionTabInfo tabInfo)
-	{
-		CollectibleDisplay collectibleDisplay = CollectionManager.Get().GetCollectibleDisplay();
-		CollectionUtils.ViewMode viewMode = collectibleDisplay.GetViewMode();
-		if ((bool)UniversalInputManager.UsePhoneUI)
-		{
-			if (m_classFilterHeader == null)
-			{
-				Debug.LogError("CollectionPageManager:SetCurrentClassTab: m_classFilterHeader should not be null when UniversalInputManager.UsePhoneUI is true");
-				return;
-			}
-			if (!ShouldClassFilterBeVisible())
-			{
-				m_classFilterHeader.gameObject.SetActive(value: false);
-				return;
-			}
-			m_classFilterHeader.gameObject.SetActive(value: true);
-			m_classFilterHeader.SetMode(viewMode, tabInfo.tagClass, tabInfo.stringOverride);
-			return;
-		}
-		BookTab bookTab = null;
-		switch (viewMode)
-		{
-		case CollectionUtils.ViewMode.CARDS:
-			if (collectibleDisplay.GetViewSubmode() != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
-			{
-				if (tabInfo.tagClass != 0)
-				{
-					bookTab = m_classTabs.Find((CollectionClassTab obj) => obj.TabInfo.tagClass == tabInfo.tagClass && obj.m_tabViewMode != CollectionUtils.ViewMode.DECK_TEMPLATE);
-				}
-			}
-			else
-			{
-				bookTab = ((m_currentPageNum == 1) ? m_ZilliaxModulesTab : m_ZilliaxBlueprintsTab);
-			}
-			break;
-		case CollectionUtils.ViewMode.HERO_SKINS:
-		case CollectionUtils.ViewMode.HERO_PICKER:
-		{
-			bool flag = viewMode == CollectionUtils.ViewMode.HERO_PICKER;
-			bool flag2 = IsSearching() || CollectionManager.Get().GetEditedDeck() != null;
-			if (flag || (flag2 && !flag))
-			{
-				bookTab = m_heroSkinsTab;
-			}
-			break;
-		}
-		case CollectionUtils.ViewMode.CARD_BACKS:
-			bookTab = m_cardBacksTab;
-			break;
-		case CollectionUtils.ViewMode.COINS:
-			bookTab = m_coinsTab;
-			break;
-		default:
-			bookTab = null;
-			break;
-		}
-		if (!(bookTab == m_currentTab))
-		{
-			DeselectCurrentTab();
-			m_currentTab = bookTab;
-			if (m_currentTab != null)
-			{
-				StopCoroutine(CollectiblePageManager.SELECT_TAB_COROUTINE_NAME);
-				StartCoroutine(CollectiblePageManager.SELECT_TAB_COROUTINE_NAME, m_currentTab);
-			}
-		}
-	}
-
-	public void SetDeckRuleset(DeckRuleset deckRuleset, bool refresh = false)
-	{
-		m_cardsCollection.SetDeckRuleset(deckRuleset);
-		if (refresh)
-		{
-			UpdateFilteredCards();
-			TransitionPageWhenReady(PageTransitionType.NONE, useCurrentPageNum: false, null, null);
-		}
-	}
-
-	private void OnClassTabPressed(UIEvent e)
-	{
-		if (CanUserTurnPages())
-		{
-			CollectionClassTab collectionClassTab = e.GetElement() as CollectionClassTab;
-			if (!(collectionClassTab == null) && !(collectionClassTab == m_currentTab))
-			{
-				JumpToCollectionClassPage(collectionClassTab.TabInfo);
-			}
-		}
-	}
-
-	private void OnZilliaxFunctionalTabPressed(UIEvent e)
-	{
-		if (CanUserTurnPages() && (CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode() != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES || base.CurrentPageNum != 1))
-		{
-			FlipToPage(1, null, null);
-			this.OnZilliaxTabPressed?.Invoke();
-		}
-	}
-
-	private void OnZilliaxSavedVersionsTabPressed(UIEvent e)
-	{
-		if (CanUserTurnPages() && (CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode() != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES || base.CurrentPageNum != 2))
-		{
-			FlipToPage(2, null, null);
-			this.OnZilliaxTabPressed?.Invoke();
-		}
-	}
-
-	private void OnDeckTemplateTabPressed(UIEvent e)
-	{
-		if (CanUserTurnPages())
-		{
-			CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.DECK_TEMPLATE);
-		}
-	}
-
-	private void OnHeroSkinsTabPressed(UIEvent e)
-	{
-		if (!CanUserTurnPages())
-		{
-			return;
-		}
-		CollectionClassTab collectionClassTab = e.GetElement() as CollectionClassTab;
-		if (!(collectionClassTab == null) && !(collectionClassTab == m_currentTab) && ShouldShowTab(m_heroSkinsTab))
-		{
-			CollectionPageDisplay collectionPageDisplay = GetCurrentCollectiblePage() as CollectionPageDisplay;
-			if (collectionPageDisplay != null)
-			{
-				_ = collectionPageDisplay.m_pageFormatType;
-			}
-			if (IsSearching() || CollectionManager.Get().GetEditedDeck() != null)
-			{
-				OnHeroClassButtonPressed(e);
-			}
-			else
-			{
-				CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.HERO_PICKER);
-			}
-		}
-	}
-
-	private void OnHeroClassButtonPressed(UIEvent e)
-	{
-		CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.HERO_SKINS);
-	}
-
-	private void OnCardBacksTabPressed(UIEvent e)
-	{
-		if (CanUserTurnPages())
-		{
-			CollectionClassTab collectionClassTab = e.GetElement() as CollectionClassTab;
-			if (!(collectionClassTab == null) && !(collectionClassTab == m_currentTab))
-			{
-				CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.CARD_BACKS);
-			}
-		}
-	}
-
-	private void OnCoinsTabPressed(UIEvent e)
-	{
-		if (CanUserTurnPages())
-		{
-			CollectionClassTab collectionClassTab = e.GetElement() as CollectionClassTab;
-			if (!(collectionClassTab == null) && !(collectionClassTab == m_currentTab) && ShouldShowTab(m_coinsTab))
-			{
-				CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.COINS);
-			}
-		}
-	}
-
-	public void UpdateMassDisenchant()
-	{
-		CraftingTray.Get()?.SetMassDisenchantAmount();
-		CollectionManager collectionManager = CollectionManager.Get();
-		if (collectionManager != null)
-		{
-			int disenchantCount = 0;
-			collectionManager.GetMassDisenchantCardsAndCount(m_disenchantCards, out disenchantCount);
-			UpdateCraftingModeButtonDustBottleVisibility(disenchantCount);
-			MassDisenchant massDisenchant = MassDisenchant.Get();
-			if (massDisenchant != null)
-			{
-				massDisenchant.UpdateContents(m_disenchantCards);
-			}
-		}
-	}
-
-	public void JumpToCollectionClassPage(CollectionTabInfo pageTabInfo)
-	{
-		JumpToCollectionClassPage(pageTabInfo, null, null);
-	}
-
-	public void JumpToCollectionClassPage(TAG_CLASS pageClass)
-	{
-		JumpToCollectionClassPage(new CollectionTabInfo
-		{
-			tagClass = pageClass
-		}, null, null);
-	}
-
-	public void JumpToCollectionClassPage(CollectionTabInfo pageTabInfo, DelOnPageTransitionComplete callback, object callbackData)
-	{
-		CollectibleDisplay collectibleDisplay = CollectionManager.Get().GetCollectibleDisplay();
-		if (collectibleDisplay != null && collectibleDisplay.GetViewMode() != 0)
-		{
-			collectibleDisplay.SetViewMode(CollectionUtils.ViewMode.CARDS, new CollectionUtils.ViewModeData
-			{
-				m_setPageByClass = pageTabInfo.tagClass
-			});
-			return;
-		}
-		CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-		if (editedDeck != null && editedDeck.HasClass(TAG_CLASS.DEATHKNIGHT))
-		{
-			m_classCardsCollection.UpdateResults();
-			m_deckRunesWereUpdatedOnCurrentPage = false;
-		}
-		m_classCardsCollection.GetPageContentsForTab(pageTabInfo, 1, calculateCollectionPage: true, out var collectionPage);
-		FlipToPage(collectionPage, callback, callbackData);
-	}
-
-	protected override void AssembleEmptyPageUI(BookPageDisplay page)
-	{
-		base.AssembleEmptyPageUI(page);
-		AssembleEmptyPageUI(page as CollectiblePageDisplay, displayNoMatchesText: false);
-	}
-
-	protected override void AssembleEmptyPageUI(CollectiblePageDisplay page, bool displayNoMatchesText)
-	{
-		CollectionPageDisplay collectionPageDisplay = PageAsCollectionPage(page);
-		if (collectionPageDisplay == null)
-		{
-			Log.CollectionManager.PrintError("Page in CollectionPageManager is not a CollectionPageDisplay!  This should not happen!");
-			return;
-		}
-		collectionPageDisplay.SetClass(default(CollectionTabInfo));
-		bool showHints = CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.CARDS;
-		collectionPageDisplay.ShowNoMatchesFound(displayNoMatchesText, m_classCardsCollection.FindCardsResult, showHints);
-		if (CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.CARDS)
-		{
-			DeselectCurrentTab();
-		}
-		collectionPageDisplay.SetPageCountText(GameStrings.Get("GLUE_COLLECTION_EMPTY_PAGE"));
-		collectionPageDisplay.SetPageTextColor();
-	}
-
-	private void AssembleMassDisenchantPage(TransitionReadyCallbackData transitionReadyCallbackData, FormatType formatType)
-	{
-		CollectionPageDisplay page = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
-		page.ActivatePageCountText(active: false);
-		page.SetPageType(formatType);
-		AssembleEmptyPageUI(page, displayNoMatchesText: false);
-		SetHasPreviousAndNextPages(hasPreviousPage: false, hasNextPage: false);
-		page.SetMassDisenchant();
-		CollectionManager.Get().GetCollectibleDisplay().CollectionPageContentsChanged<ICollectible>(null, delegate
-		{
-			page.UpdatePageWithMassDisenchant();
-			TransitionPage(transitionReadyCallbackData);
-		}, null);
-	}
-
-	private List<CollectibleCard> GetFilteredDeathKnightCards<TCollectible>(ICollection<TCollectible> collectiblesToDisplay)
-	{
-		if (!(collectiblesToDisplay is List<CollectibleCard> list))
-		{
-			return null;
-		}
-		if (list.Count == 0)
-		{
-			return list;
-		}
-		if (list[0].GetEntityDef().GetClass() != TAG_CLASS.DEATHKNIGHT)
-		{
-			return null;
-		}
-		CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-		if (editedDeck == null)
-		{
-			return null;
-		}
-		List<CollectibleCard> list2 = new List<CollectibleCard>();
-		RunePattern runesToAdd = default(RunePattern);
-		foreach (CollectibleCard item in list)
-		{
-			runesToAdd.SetCostsFromEntity(item.GetEntityDef());
-			if (editedDeck.CanAddRunes(runesToAdd, DeckRule_DeathKnightRuneLimit.MaxRuneSlots))
-			{
-				list2.Add(item);
-			}
-		}
-		return list2;
-	}
-
-	protected override bool AssembleCollectiblePage<TCollectible>(TransitionReadyCallbackData transitionReadyCallbackData, ICollection<TCollectible> collectiblesToDisplay, int totalNumPages)
-	{
-		CollectionUtils.ViewMode viewMode = CollectionManager.Get().GetCollectibleDisplay().GetViewMode();
-		CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-		if (m_currentClassContext.tagClass == TAG_CLASS.DEATHKNIGHT && editedDeck != null)
-		{
-			m_originalDeckRunesForCurrentPage = editedDeck.Runes;
-		}
-		if (base.AssembleCollectiblePage(transitionReadyCallbackData, collectiblesToDisplay, totalNumPages))
-		{
-			if (!CollectionManager.Get().IsInEditMode() || viewMode != 0)
-			{
-				return true;
-			}
-			if (editedDeck == null)
-			{
-				return true;
-			}
-			List<TAG_CLASS> classes = editedDeck.GetClasses();
-			if (classes.Count <= 0)
-			{
-				return true;
-			}
-			TAG_CLASS tagClass = classes[0];
-			m_currentClassContext = new CollectionTabInfo
-			{
-				tagClass = tagClass
-			};
-			SetCurrentClassTabInfo(m_currentClassContext);
-			return true;
-		}
-		CollectionPageDisplay page = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
-		m_lastCollectibleAnchor = collectiblesToDisplay.FirstOrDefault();
-		if (viewMode == CollectionUtils.ViewMode.HERO_SKINS)
-		{
-			CollectionDeck editedDeck2 = CollectionManager.Get().GetEditedDeck();
-			if (editedDeck2 != null)
-			{
-				page.SetHeroSkins(editedDeck2.GetClass());
-			}
-			else
-			{
-				CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-				TAG_CLASS? heroSkins = ((collectionManagerDisplay != null) ? collectionManagerDisplay.GetHeroSkinClass() : null);
-				page.SetHeroSkins(heroSkins);
-			}
-		}
-		else if (viewMode == CollectionUtils.ViewMode.COINS)
-		{
-			page.SetCoins();
-		}
-		else if (CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode() != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
-		{
-			CollectionTabInfo currentTabInfoFromPage = m_classCardsCollection.GetCurrentTabInfoFromPage(m_currentPageNum);
-			page.SetClass(currentTabInfoFromPage);
-			m_currentClassContext = currentTabInfoFromPage;
-		}
-		m_deckRunesWereUpdatedOnCurrentPage = false;
-		page.SetPageCountText(GameStrings.Format("GLUE_COLLECTION_PAGE_NUM", m_currentPageNum));
-		page.SetPageTextColor();
-		page.ShowNoMatchesFound(show: false);
-		SetHasPreviousAndNextPages(m_currentPageNum > 1, m_currentPageNum < totalNumPages);
-		CollectionManager.Get().GetCollectibleDisplay().CollectionPageContentsChanged(collectiblesToDisplay, delegate(List<CollectionCardActors> actorList, List<ICollectible> nonActorCollectibleList, object data)
-		{
-			page.UpdateCollectionItems(actorList, nonActorCollectibleList, viewMode);
-			TransitionPageNextFrame(transitionReadyCallbackData);
-			if (m_deckTemplatePicker != null)
-			{
-				StartCoroutine(m_deckTemplatePicker.Show(show: false));
-			}
-		}, null);
-		return true;
-	}
-
-	private void AssembleDeckTemplatePage(TransitionReadyCallbackData transitionReadyCallbackData)
-	{
-		FormatType formatType = ((m_deckTemplatePicker != null && m_deckTemplatePicker.CurrentSelectedFormat != 0) ? m_deckTemplatePicker.CurrentSelectedFormat : FormatType.FT_STANDARD);
-		if (AssembleCollectionBasePage(transitionReadyCallbackData, emptyPage: false, formatType))
-		{
-			return;
-		}
-		CollectionPageDisplay collectionPageDisplay = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
-		if (m_deckTemplatePicker == null && !string.IsNullOrEmpty(m_deckTemplatePickerPrefab))
-		{
-			m_deckTemplatePicker = GameUtils.LoadGameObjectWithComponent<DeckTemplatePicker>(m_deckTemplatePickerPrefab);
-			if (m_deckTemplatePicker == null)
-			{
-				Debug.LogWarning("Failed to instantiate deck template picker prefab " + m_deckTemplatePickerPrefab);
-				return;
-			}
-			m_deckTemplatePicker.RegisterOnTemplateDeckChosen(delegate
-			{
-				HideNonDeckTemplateTabs(hide: false, updateTabs: true);
-				CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.CARDS);
-			});
-		}
-		collectionPageDisplay.UpdateDeckTemplateHeader(m_deckTemplatePicker?.m_pageHeader, formatType);
-		collectionPageDisplay.UpdateDeckTemplatePage(m_deckTemplatePicker);
-		collectionPageDisplay.SetDeckTemplates();
-		collectionPageDisplay.ShowNoMatchesFound(show: false);
-		collectionPageDisplay.SetPageCountText(string.Empty);
-		SetHasPreviousAndNextPages(hasPreviousPage: false, hasNextPage: false);
-		UpdateDeckTemplate(m_deckTemplatePicker);
-		TransitionPage(transitionReadyCallbackData);
-	}
-
-	public DeckTemplatePicker GetDeckTemplatePicker()
-	{
-		return m_deckTemplatePicker;
-	}
-
-	public void UpdateDeckTemplate(DeckTemplatePicker deckTemplatePicker)
-	{
-		if (deckTemplatePicker != null)
-		{
-			CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-			if (editedDeck != null)
-			{
-				deckTemplatePicker.SetDeckFormatAndClass(editedDeck.FormatType, editedDeck.GetClass());
-			}
-			StartCoroutine(deckTemplatePicker.Show(show: true));
-		}
-	}
-
-	private void AssembleCardBackPage(TransitionReadyCallbackData transitionReadyCallbackData, bool useCurrentPageNum)
-	{
-		Log.CollectionManager.Print("transitionPageId={0} pagesTurning={1} currentPageIsPageA={2} currentPageNum={3}", m_transitionPageId, m_pagesCurrentlyTurning, m_currentPageIsPageA, m_currentPageNum);
-		int count = GetCurrentDeckTrayModeCardBackIds().Count;
-		bool emptyPage = count == 0;
-		if (AssembleCollectionBasePage(transitionReadyCallbackData, emptyPage, FormatType.FT_STANDARD))
-		{
-			return;
-		}
-		CollectionPageDisplay page = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
-		int maxCardsPerPage = CollectiblePageDisplay.GetMaxCardsPerPage();
-		int num = count / maxCardsPerPage + ((count % maxCardsPerPage > 0) ? 1 : 0);
-		m_currentPageNum = Mathf.Clamp(m_currentPageNum, 1, num);
-		page.SetCardBacks();
-		page.ShowNoMatchesFound(count == 0);
-		page.SetPageCountText(GameStrings.Format("GLUE_COLLECTION_PAGE_NUM", m_currentPageNum));
-		SetHasPreviousAndNextPages(m_currentPageNum > 1, m_currentPageNum < num);
-		bool flag = !CollectionManager.Get().IsInEditMode();
-		List<CardBackManager.OwnedCardBack> cardBacksToDisplay = CardBackManager.Get()?.GetPageOfCardBacks(!flag, m_currentPageNum);
-		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (!(collectionManagerDisplay != null))
-		{
-			return;
-		}
-		collectionManagerDisplay.CollectionPageContentsChangedToCardBacks(cardBacksToDisplay, delegate(List<CollectionCardActors> actorList, List<ICollectible> nonActorCollectibleList, object data)
-		{
-			page.UpdateCollectionItems(actorList, nonActorCollectibleList, CollectionUtils.ViewMode.CARD_BACKS);
-			foreach (CollectionCardActors actor in actorList)
-			{
-				CardBackManager.Get().UpdateCardBackWithInternalCardBack(actor.GetPreferredActor());
-			}
-			TransitionPage(transitionReadyCallbackData);
-			if (m_deckTemplatePicker != null)
-			{
-				StartCoroutine(m_deckTemplatePicker.Show(show: false));
-			}
-		});
-	}
-
-	protected void AssembleHeroPickerPage(TransitionReadyCallbackData transitionReadyCallbackData)
-	{
-		CollectionPageDisplay page = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
-		page.ActivatePageCountText(active: false);
-		page.SetPageType(FormatType.FT_STANDARD);
-		AssembleEmptyPageUI(page, displayNoMatchesText: false);
-		MassDisenchant massDisenchant = MassDisenchant.Get();
-		if (massDisenchant != null)
-		{
-			massDisenchant.Hide();
-		}
-		SetHasPreviousAndNextPages(hasPreviousPage: false, hasNextPage: false);
-		page.SetHeroPicker();
-		page.SetPageTextColor();
-		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (!(collectionManagerDisplay == null))
+		if (CanUserTurnPages() && (CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode() != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES || base.CurrentPageNum != 2))
 		{
-			m_heroesCollection.SortResults();
-			m_heroesCollection.FilterHeroesByActiveClass();
-			collectionManagerDisplay.SetHeroSkinClass(null);
-			collectionManagerDisplay.CollectionPageContentsChanged<ICollectible>(null, delegate
-			{
-				CountClassHeroTotals(out var allHeroCounts, out var ownedHeroCounts);
-				page.UpdatePageWithHeroPicker(allHeroCounts, ownedHeroCounts);
-				TransitionPage(transitionReadyCallbackData);
-			}, null);
+			FlipToPage(2, null, null);
+			this.OnZilliaxTabPressed?.Invoke();
 		}
 	}
 
-	protected void CountClassHeroTotals(out int[] allHeroCounts, out int[] ownedHeroCounts)
-	{
-		List<TAG_CLASS> list = new List<TAG_CLASS>(GameUtils.ORDERED_HERO_CLASSES);
-		allHeroCounts = new int[list.Count];
-		ownedHeroCounts = new int[list.Count];
-		List<CollectibleCard> allResults = m_heroesCollection.GetAllResults();
-		for (int i = 0; i < allResults.Count; i++)
-		{
-			CollectibleCard collectibleCard = allResults[i];
-			TAG_CLASS @class = collectibleCard.Class;
-			int num = list.IndexOf(@class);
+    private void OnDeckTemplateTabPressed(UIEvent e)
+    {
+        if (CanUserTurnPages())
+        {
+            CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.DECK_TEMPLATE);
+        }
+    }
+
+    private void OnHeroSkinsTabPressed(UIEvent e)
+    {
+        if (!CanUserTurnPages())
+        {
+            return;
+        }
+        CollectionClassTab collectionClassTab = e.GetElement() as CollectionClassTab;
+        if (!(collectionClassTab == null) && !(collectionClassTab == m_currentTab) && ShouldShowTab(m_heroSkinsTab))
+        {
+            CollectionPageDisplay collectionPageDisplay = GetCurrentCollectiblePage() as CollectionPageDisplay;
+            if (collectionPageDisplay != null)
+            {
+                _ = collectionPageDisplay.m_pageFormatType;
+            }
+            if (IsSearching() || CollectionManager.Get().GetEditedDeck() != null)
+            {
+                OnHeroClassButtonPressed(e);
+            }
+            else
+            {
+                CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.HERO_PICKER);
+            }
+        }
+    }
+
+    private void OnHeroClassButtonPressed(UIEvent e)
+    {
+        CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.HERO_SKINS);
+    }
+
+    private void OnCardBacksTabPressed(UIEvent e)
+    {
+        if (CanUserTurnPages())
+        {
+            CollectionClassTab collectionClassTab = e.GetElement() as CollectionClassTab;
+            if (!(collectionClassTab == null) && !(collectionClassTab == m_currentTab))
+            {
+                CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.CARD_BACKS);
+            }
+        }
+    }
+
+    private void OnCoinsTabPressed(UIEvent e)
+    {
+        if (CanUserTurnPages())
+        {
+            CollectionClassTab collectionClassTab = e.GetElement() as CollectionClassTab;
+            if (!(collectionClassTab == null) && !(collectionClassTab == m_currentTab) && ShouldShowTab(m_coinsTab))
+            {
+                CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.COINS);
+            }
+        }
+    }
+
+    public void UpdateMassDisenchant()
+    {
+        CraftingTray.Get()?.SetMassDisenchantAmount();
+        CollectionManager collectionManager = CollectionManager.Get();
+        if (collectionManager != null)
+        {
+            int disenchantCount = 0;
+            collectionManager.GetMassDisenchantCardsAndCount(m_disenchantCards, out disenchantCount);
+            UpdateCraftingModeButtonDustBottleVisibility(disenchantCount);
+            MassDisenchant massDisenchant = MassDisenchant.Get();
+            if (massDisenchant != null)
+            {
+                massDisenchant.UpdateContents(m_disenchantCards);
+            }
+        }
+    }
+
+    public void JumpToCollectionClassPage(CollectionTabInfo pageTabInfo)
+    {
+        JumpToCollectionClassPage(pageTabInfo, null, null);
+    }
+
+    public void JumpToCollectionClassPage(TAG_CLASS pageClass)
+    {
+        JumpToCollectionClassPage(new CollectionTabInfo
+        {
+            tagClass = pageClass
+        }, null, null);
+    }
+
+    public void JumpToCollectionClassPage(CollectionTabInfo pageTabInfo, DelOnPageTransitionComplete callback, object callbackData)
+    {
+        CollectibleDisplay collectibleDisplay = CollectionManager.Get().GetCollectibleDisplay();
+        if (collectibleDisplay != null && collectibleDisplay.GetViewMode() != 0)
+        {
+            collectibleDisplay.SetViewMode(CollectionUtils.ViewMode.CARDS, new CollectionUtils.ViewModeData
+            {
+                m_setPageByClass = pageTabInfo.tagClass
+            });
+            return;
+        }
+        CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+        if (editedDeck != null && editedDeck.HasClass(TAG_CLASS.DEATHKNIGHT))
+        {
+            m_classCardsCollection.UpdateResults();
+            m_deckRunesWereUpdatedOnCurrentPage = false;
+        }
+        m_classCardsCollection.GetPageContentsForTab(pageTabInfo, 1, calculateCollectionPage: true, out var collectionPage);
+        FlipToPage(collectionPage, callback, callbackData);
+    }
+
+    protected override void AssembleEmptyPageUI(BookPageDisplay page)
+    {
+        base.AssembleEmptyPageUI(page);
+        AssembleEmptyPageUI(page as CollectiblePageDisplay, displayNoMatchesText: false);
+    }
+
+    protected override void AssembleEmptyPageUI(CollectiblePageDisplay page, bool displayNoMatchesText)
+    {
+        CollectionPageDisplay collectionPageDisplay = PageAsCollectionPage(page);
+        if (collectionPageDisplay == null)
+        {
+            Log.CollectionManager.PrintError("Page in CollectionPageManager is not a CollectionPageDisplay!  This should not happen!");
+            return;
+        }
+        collectionPageDisplay.SetClass(default(CollectionTabInfo));
+        bool showHints = CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.CARDS;
+        collectionPageDisplay.ShowNoMatchesFound(displayNoMatchesText, m_classCardsCollection.FindCardsResult, showHints);
+        if (CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.CARDS)
+        {
+            DeselectCurrentTab();
+        }
+        collectionPageDisplay.SetPageCountText(GameStrings.Get("GLUE_COLLECTION_EMPTY_PAGE"));
+        collectionPageDisplay.SetPageTextColor();
+    }
+
+    private void AssembleMassDisenchantPage(TransitionReadyCallbackData transitionReadyCallbackData, FormatType formatType)
+    {
+        CollectionPageDisplay page = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
+        page.ActivatePageCountText(active: false);
+        page.SetPageType(formatType);
+        AssembleEmptyPageUI(page, displayNoMatchesText: false);
+        SetHasPreviousAndNextPages(hasPreviousPage: false, hasNextPage: false);
+        page.SetMassDisenchant();
+        CollectionManager.Get().GetCollectibleDisplay().CollectionPageContentsChanged<ICollectible>(null, delegate
+        {
+            page.UpdatePageWithMassDisenchant();
+            TransitionPage(transitionReadyCallbackData);
+        }, null);
+    }
+
+    private List<CollectibleCard> GetFilteredDeathKnightCards<TCollectible>(ICollection<TCollectible> collectiblesToDisplay)
+    {
+		if (!(collectiblesToDisplay is List<CollectibleCard> list))
+        {
+            return null;
+        }
+        if (list.Count == 0)
+        {
+            return list;
+        }
+        if (list[0].GetEntityDef().GetClass() != TAG_CLASS.DEATHKNIGHT)
+        {
+            return null;
+        }
+        CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+        if (editedDeck == null)
+        {
+            return null;
+        }
+        List<CollectibleCard> list2 = new List<CollectibleCard>();
+        RunePattern runesToAdd = default(RunePattern);
+        foreach (CollectibleCard item in list)
+        {
+            runesToAdd.SetCostsFromEntity(item.GetEntityDef());
+            if (editedDeck.CanAddRunes(runesToAdd, DeckRule_DeathKnightRuneLimit.MaxRuneSlots))
+            {
+                list2.Add(item);
+            }
+        }
+        return list2;
+    }
+
+    protected override bool AssembleCollectiblePage<TCollectible>(TransitionReadyCallbackData transitionReadyCallbackData, ICollection<TCollectible> collectiblesToDisplay, int totalNumPages)
+    {
+        CollectionUtils.ViewMode viewMode = CollectionManager.Get().GetCollectibleDisplay().GetViewMode();
+        CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+        if (m_currentClassContext.tagClass == TAG_CLASS.DEATHKNIGHT && editedDeck != null)
+        {
+            m_originalDeckRunesForCurrentPage = editedDeck.Runes;
+        }
+        if (base.AssembleCollectiblePage(transitionReadyCallbackData, collectiblesToDisplay, totalNumPages))
+        {
+            if (!CollectionManager.Get().IsInEditMode() || viewMode != 0)
+            {
+                return true;
+            }
+            if (editedDeck == null)
+            {
+                return true;
+            }
+            List<TAG_CLASS> classes = editedDeck.GetClasses();
+            if (classes.Count <= 0)
+            {
+                return true;
+            }
+            TAG_CLASS tagClass = classes[0];
+            m_currentClassContext = new CollectionTabInfo
+            {
+                tagClass = tagClass
+            };
+            SetCurrentClassTabInfo(m_currentClassContext);
+            return true;
+        }
+        CollectionPageDisplay page = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
+        m_lastCollectibleAnchor = collectiblesToDisplay.FirstOrDefault();
+        if (viewMode == CollectionUtils.ViewMode.HERO_SKINS)
+        {
+            CollectionDeck editedDeck2 = CollectionManager.Get().GetEditedDeck();
+            if (editedDeck2 != null)
+            {
+                page.SetHeroSkins(editedDeck2.GetClass());
+            }
+            else
+            {
+                CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+                TAG_CLASS? heroSkins = ((collectionManagerDisplay != null) ? collectionManagerDisplay.GetHeroSkinClass() : null);
+                page.SetHeroSkins(heroSkins);
+            }
+        }
+        else if (viewMode == CollectionUtils.ViewMode.COINS)
+        {
+            page.SetCoins();
+        }
+		else if (CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode() != CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
+        {
+            CollectionTabInfo currentTabInfoFromPage = m_classCardsCollection.GetCurrentTabInfoFromPage(m_currentPageNum);
+            page.SetClass(currentTabInfoFromPage);
+            m_currentClassContext = currentTabInfoFromPage;
+        }
+        m_deckRunesWereUpdatedOnCurrentPage = false;
+        page.SetPageCountText(GameStrings.Format("GLUE_COLLECTION_PAGE_NUM", m_currentPageNum));
+        page.SetPageTextColor();
+        page.ShowNoMatchesFound(show: false);
+        SetHasPreviousAndNextPages(m_currentPageNum > 1, m_currentPageNum < totalNumPages);
+        CollectionManager.Get().GetCollectibleDisplay().CollectionPageContentsChanged(collectiblesToDisplay, delegate (List<CollectionCardActors> actorList, List<ICollectible> nonActorCollectibleList, object data)
+        {
+            page.UpdateCollectionItems(actorList, nonActorCollectibleList, viewMode);
+            TransitionPageNextFrame(transitionReadyCallbackData);
+            if (m_deckTemplatePicker != null)
+            {
+                StartCoroutine(m_deckTemplatePicker.Show(show: false));
+            }
+        }, null);
+        return true;
+    }
+
+    private void AssembleDeckTemplatePage(TransitionReadyCallbackData transitionReadyCallbackData)
+    {
+        FormatType formatType = ((m_deckTemplatePicker != null && m_deckTemplatePicker.CurrentSelectedFormat != 0) ? m_deckTemplatePicker.CurrentSelectedFormat : FormatType.FT_STANDARD);
+        if (AssembleCollectionBasePage(transitionReadyCallbackData, emptyPage: false, formatType))
+        {
+            return;
+        }
+        CollectionPageDisplay collectionPageDisplay = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
+        if (m_deckTemplatePicker == null && !string.IsNullOrEmpty(m_deckTemplatePickerPrefab))
+        {
+            m_deckTemplatePicker = GameUtils.LoadGameObjectWithComponent<DeckTemplatePicker>(m_deckTemplatePickerPrefab);
+            if (m_deckTemplatePicker == null)
+            {
+                Debug.LogWarning("Failed to instantiate deck template picker prefab " + m_deckTemplatePickerPrefab);
+                return;
+            }
+            m_deckTemplatePicker.RegisterOnTemplateDeckChosen(delegate
+            {
+                HideNonDeckTemplateTabs(hide: false, updateTabs: true);
+                CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.CARDS);
+            });
+        }
+        collectionPageDisplay.UpdateDeckTemplateHeader(m_deckTemplatePicker?.m_pageHeader, formatType);
+        collectionPageDisplay.UpdateDeckTemplatePage(m_deckTemplatePicker);
+        collectionPageDisplay.SetDeckTemplates();
+        collectionPageDisplay.ShowNoMatchesFound(show: false);
+        collectionPageDisplay.SetPageCountText(string.Empty);
+        SetHasPreviousAndNextPages(hasPreviousPage: false, hasNextPage: false);
+        UpdateDeckTemplate(m_deckTemplatePicker);
+        TransitionPage(transitionReadyCallbackData);
+    }
+
+    public DeckTemplatePicker GetDeckTemplatePicker()
+    {
+        return m_deckTemplatePicker;
+    }
+
+    public void UpdateDeckTemplate(DeckTemplatePicker deckTemplatePicker)
+    {
+        if (deckTemplatePicker != null)
+        {
+            CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+            if (editedDeck != null)
+            {
+                deckTemplatePicker.SetDeckFormatAndClass(editedDeck.FormatType, editedDeck.GetClass());
+            }
+            StartCoroutine(deckTemplatePicker.Show(show: true));
+        }
+    }
+
+    private void AssembleCardBackPage(TransitionReadyCallbackData transitionReadyCallbackData, bool useCurrentPageNum)
+    {
+        Log.CollectionManager.Print("transitionPageId={0} pagesTurning={1} currentPageIsPageA={2} currentPageNum={3}", m_transitionPageId, m_pagesCurrentlyTurning, m_currentPageIsPageA, m_currentPageNum);
+        int count = GetCurrentDeckTrayModeCardBackIds().Count;
+        bool emptyPage = count == 0;
+        if (AssembleCollectionBasePage(transitionReadyCallbackData, emptyPage, FormatType.FT_STANDARD))
+        {
+            return;
+        }
+        CollectionPageDisplay page = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
+        int maxCardsPerPage = CollectiblePageDisplay.GetMaxCardsPerPage();
+        int num = count / maxCardsPerPage + ((count % maxCardsPerPage > 0) ? 1 : 0);
+        m_currentPageNum = Mathf.Clamp(m_currentPageNum, 1, num);
+        page.SetCardBacks();
+        page.ShowNoMatchesFound(count == 0);
+        page.SetPageCountText(GameStrings.Format("GLUE_COLLECTION_PAGE_NUM", m_currentPageNum));
+        SetHasPreviousAndNextPages(m_currentPageNum > 1, m_currentPageNum < num);
+        bool flag = !CollectionManager.Get().IsInEditMode();
+        List<CardBackManager.OwnedCardBack> cardBacksToDisplay = CardBackManager.Get()?.GetPageOfCardBacks(!flag, m_currentPageNum);
+        CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+        if (!(collectionManagerDisplay != null))
+        {
+            return;
+        }
+        collectionManagerDisplay.CollectionPageContentsChangedToCardBacks(cardBacksToDisplay, delegate (List<CollectionCardActors> actorList, List<ICollectible> nonActorCollectibleList, object data)
+        {
+            page.UpdateCollectionItems(actorList, nonActorCollectibleList, CollectionUtils.ViewMode.CARD_BACKS);
+            foreach (CollectionCardActors actor in actorList)
+            {
+                CardBackManager.Get().UpdateCardBackWithInternalCardBack(actor.GetPreferredActor());
+            }
+            TransitionPage(transitionReadyCallbackData);
+            if (m_deckTemplatePicker != null)
+            {
+                StartCoroutine(m_deckTemplatePicker.Show(show: false));
+            }
+        });
+    }
+
+    protected void AssembleHeroPickerPage(TransitionReadyCallbackData transitionReadyCallbackData)
+    {
+        CollectionPageDisplay page = PageAsCollectionPage(transitionReadyCallbackData.m_assembledPage);
+        page.ActivatePageCountText(active: false);
+        page.SetPageType(FormatType.FT_STANDARD);
+        AssembleEmptyPageUI(page, displayNoMatchesText: false);
+        MassDisenchant massDisenchant = MassDisenchant.Get();
+        if (massDisenchant != null)
+        {
+            massDisenchant.Hide();
+        }
+        SetHasPreviousAndNextPages(hasPreviousPage: false, hasNextPage: false);
+        page.SetHeroPicker();
+        page.SetPageTextColor();
+        CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+        if (!(collectionManagerDisplay == null))
+        {
+            m_heroesCollection.SortResults();
+            m_heroesCollection.FilterHeroesByActiveClass();
+            collectionManagerDisplay.SetHeroSkinClass(null);
+            collectionManagerDisplay.CollectionPageContentsChanged<ICollectible>(null, delegate
+            {
+                CountClassHeroTotals(out var allHeroCounts, out var ownedHeroCounts);
+                page.UpdatePageWithHeroPicker(allHeroCounts, ownedHeroCounts);
+                TransitionPage(transitionReadyCallbackData);
+            }, null);
+        }
+    }
+
+    protected void CountClassHeroTotals(out int[] allHeroCounts, out int[] ownedHeroCounts)
+    {
+        List<TAG_CLASS> list = new List<TAG_CLASS>(GameUtils.ORDERED_HERO_CLASSES);
+        allHeroCounts = new int[list.Count];
+        ownedHeroCounts = new int[list.Count];
+        List<CollectibleCard> allResults = m_heroesCollection.GetAllResults();
+        for (int i = 0; i < allResults.Count; i++)
+        {
+            CollectibleCard collectibleCard = allResults[i];
+            TAG_CLASS @class = collectibleCard.Class;
+            int num = list.IndexOf(@class);
 			if (num < 0 || num >= list.Count)
 			{
 				Log.CollectionManager.PrintError($"Hero count failed to increment from hero: {collectibleCard.Name} ({collectibleCard.CardDbId})) due to invalid class! " + $"(Expected: 0 to {list.Count - 1}, Actual: {num})");
 				continue;
 			}
-			allHeroCounts[num]++;
-			if (collectibleCard.OwnedCount >= 1)
-			{
-				ownedHeroCounts[num]++;
-			}
-		}
-	}
-
-	protected void AssembleHeroSkinsPage(TransitionReadyCallbackData transitionReadyCallbackData, bool useCurrentPageNum)
-	{
-		m_heroesCollection.FilterHeroesByActiveClass();
-		List<CollectibleCard> heroesContents = m_heroesCollection.GetHeroesContents(m_currentPageNum);
-		heroesContents = m_heroesCollection.GetHeroesContents(m_currentPageNum);
-		AssembleCollectiblePage(transitionReadyCallbackData, heroesContents, m_heroesCollection.GetTotalNumPages());
-	}
-
-	protected void AssembleCoinPage(TransitionReadyCallbackData transitionReadyCallbackData, bool useCurrentPageNum)
-	{
-		int maxCardsPerPage = CollectiblePageDisplay.GetMaxCardsPerPage();
+            allHeroCounts[num]++;
+            if (collectibleCard.OwnedCount >= 1)
+            {
+                ownedHeroCounts[num]++;
+            }
+        }
+    }
+
+    protected void AssembleHeroSkinsPage(TransitionReadyCallbackData transitionReadyCallbackData, bool useCurrentPageNum)
+    {
+        m_heroesCollection.FilterHeroesByActiveClass();
+        List<CollectibleCard> heroesContents = m_heroesCollection.GetHeroesContents(m_currentPageNum);
+        heroesContents = m_heroesCollection.GetHeroesContents(m_currentPageNum);
+        AssembleCollectiblePage(transitionReadyCallbackData, heroesContents, m_heroesCollection.GetTotalNumPages());
+    }
+
+    protected void AssembleCoinPage(TransitionReadyCallbackData transitionReadyCallbackData, bool useCurrentPageNum)
+    {
+        int maxCardsPerPage = CollectiblePageDisplay.GetMaxCardsPerPage();
 		List<CollectibleCard> pageOfCoinCards = CosmeticCoinManager.Get().GetPageOfCoinCards(m_currentPageNum, maxCardsPerPage);
 		AssembleCollectiblePage(transitionReadyCallbackData, pageOfCoinCards, CosmeticCoinManager.Get().GetCoinPageCount(maxCardsPerPage));
 	}
@@ -1746,91 +1748,91 @@ public class CollectionPageManager : CollectiblePageManager
 		}
 		EnablePageTurnClickableRegions(enable: false);
 		EnablePageTurnArrows(enable: false);
-	}
-
-	protected override void AssemblePage(TransitionReadyCallbackData transitionReadyCallbackData, bool useCurrentPageNum)
-	{
-		CollectibleDisplay collectibleDisplay = CollectionManager.Get().GetCollectibleDisplay();
-		if (null == collectibleDisplay)
-		{
-			return;
-		}
+    }
+
+    protected override void AssemblePage(TransitionReadyCallbackData transitionReadyCallbackData, bool useCurrentPageNum)
+    {
+        CollectibleDisplay collectibleDisplay = CollectionManager.Get().GetCollectibleDisplay();
+        if (null == collectibleDisplay)
+        {
+            return;
+        }
 		if (!useCurrentPageNum)
 		{
 			m_currentPageNum = 1;
 		}
-		switch (collectibleDisplay.GetViewMode())
-		{
-		case CollectionUtils.ViewMode.CARD_BACKS:
-			AssembleCardBackPage(transitionReadyCallbackData, useCurrentPageNum);
-			break;
-		case CollectionUtils.ViewMode.DECK_TEMPLATE:
-			AssembleDeckTemplatePage(transitionReadyCallbackData);
-			break;
-		case CollectionUtils.ViewMode.HERO_PICKER:
-			AssembleHeroPickerPage(transitionReadyCallbackData);
-			break;
-		case CollectionUtils.ViewMode.HERO_SKINS:
-			AssembleHeroSkinsPage(transitionReadyCallbackData, useCurrentPageNum);
-			break;
-		case CollectionUtils.ViewMode.MASS_DISENCHANT:
-		{
-			FormatType themeShowing = CollectionManager.Get().GetThemeShowing();
-			AssembleMassDisenchantPage(transitionReadyCallbackData, themeShowing);
-			break;
-		}
-		case CollectionUtils.ViewMode.COINS:
-			AssembleCoinPage(transitionReadyCallbackData, useCurrentPageNum);
-			break;
-		case CollectionUtils.ViewMode.CARDS:
-		{
+        switch (collectibleDisplay.GetViewMode())
+        {
+            case CollectionUtils.ViewMode.CARD_BACKS:
+                AssembleCardBackPage(transitionReadyCallbackData, useCurrentPageNum);
+                break;
+            case CollectionUtils.ViewMode.DECK_TEMPLATE:
+                AssembleDeckTemplatePage(transitionReadyCallbackData);
+                break;
+            case CollectionUtils.ViewMode.HERO_PICKER:
+                AssembleHeroPickerPage(transitionReadyCallbackData);
+                break;
+            case CollectionUtils.ViewMode.HERO_SKINS:
+                AssembleHeroSkinsPage(transitionReadyCallbackData, useCurrentPageNum);
+                break;
+            case CollectionUtils.ViewMode.MASS_DISENCHANT:
+                {
+                    FormatType themeShowing = CollectionManager.Get().GetThemeShowing();
+                    AssembleMassDisenchantPage(transitionReadyCallbackData, themeShowing);
+                    break;
+                }
+            case CollectionUtils.ViewMode.COINS:
+                AssembleCoinPage(transitionReadyCallbackData, useCurrentPageNum);
+                break;
+            case CollectionUtils.ViewMode.CARDS:
+                {
 			if (collectibleDisplay.GetViewSubmode() == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
 			{
 				AssembleZilliaxModulesPage(transitionReadyCallbackData, useCurrentPageNum);
 			}
 			else
 			{
-				if (m_classCardsCollection == null)
-				{
-					break;
-				}
-				List<CollectibleCard> list = new List<CollectibleCard>();
-				if (useCurrentPageNum)
-				{
-					list = m_classCardsCollection.GetPageContents(m_currentPageNum);
-				}
-				else if (!(m_lastCollectibleAnchor is CollectibleCard collectibleCard))
-				{
-					m_currentPageNum = 1;
-					list = m_cardsCollection.GetPageContents(m_currentPageNum);
-				}
-				else
-				{
-					list = m_classCardsCollection.GetPageContentsForCard(collectibleCard.CardId, collectibleCard.PremiumType, out var collectionPage, m_currentClassContext);
-					if (list.Count == 0)
-					{
-						list = m_classCardsCollection.GetPageContentsForTab(m_currentClassContext, 1, calculateCollectionPage: true, out collectionPage);
-					}
-					if (list.Count == 0)
-					{
-						list = m_cardsCollection.GetPageContents(1);
-						collectionPage = 1;
-					}
-					m_currentPageNum = ((list.Count != 0) ? collectionPage : 0);
-				}
-				if (list.Count == 0)
-				{
-					list = m_cardsCollection.GetFirstNonEmptyPage(out var collectionPage2);
-					if (list.Count > 0)
-					{
-						m_currentPageNum = collectionPage2;
-					}
-				}
-				AssembleCollectiblePage(transitionReadyCallbackData, list, m_cardsCollection.GetTotalNumPages());
-			}
-			CollectionManagerDisplay collectionManagerDisplay = collectibleDisplay as CollectionManagerDisplay;
-			if (collectionManagerDisplay != null)
-			{
+                    if (m_classCardsCollection == null)
+                    {
+                        break;
+                    }
+                    List<CollectibleCard> list = new List<CollectibleCard>();
+                    if (useCurrentPageNum)
+                    {
+                        list = m_classCardsCollection.GetPageContents(m_currentPageNum);
+                    }
+			else if (!(m_lastCollectibleAnchor is CollectibleCard collectibleCard))
+                        {
+                            m_currentPageNum = 1;
+                            list = m_cardsCollection.GetPageContents(m_currentPageNum);
+                        }
+                        else
+                        {
+                            list = m_classCardsCollection.GetPageContentsForCard(collectibleCard.CardId, collectibleCard.PremiumType, out var collectionPage, m_currentClassContext);
+                            if (list.Count == 0)
+                            {
+                                list = m_classCardsCollection.GetPageContentsForTab(m_currentClassContext, 1, calculateCollectionPage: true, out collectionPage);
+                            }
+                            if (list.Count == 0)
+                            {
+                                list = m_cardsCollection.GetPageContents(1);
+                                collectionPage = 1;
+                            }
+                            m_currentPageNum = ((list.Count != 0) ? collectionPage : 0);
+                        }
+                    if (list.Count == 0)
+                    {
+                        list = m_cardsCollection.GetFirstNonEmptyPage(out var collectionPage2);
+                        if (list.Count > 0)
+                        {
+                            m_currentPageNum = collectionPage2;
+                        }
+                    }
+                    AssembleCollectiblePage(transitionReadyCallbackData, list, m_cardsCollection.GetTotalNumPages());
+			}
+                    CollectionManagerDisplay collectionManagerDisplay = collectibleDisplay as CollectionManagerDisplay;
+                    if (collectionManagerDisplay != null)
+                    {
 				bool flag = false;
 				CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
 				if (editedDeck != null)
@@ -1838,432 +1840,432 @@ public class CollectionPageManager : CollectiblePageManager
 					flag = ShouldShowAllClassCards(editedDeck);
 				}
 				collectionManagerDisplay.SetRuneLockedCheckboxVisible(CollectionManager.Get().IsEditingDeathKnightDeck() && !flag);
-			}
-			if (!CollectionManager.Get().GetCollectibleDisplay().InCraftingMode())
-			{
+                    }
+                    if (!CollectionManager.Get().GetCollectibleDisplay().InCraftingMode())
+                    {
 				CollectionDeck editedDeck2 = CollectionManager.Get().GetEditedDeck();
 				if (editedDeck2 != null && editedDeck2.HasClass(TAG_CLASS.DEATHKNIGHT))
-				{
+                        {
 					UpdatePageGhostingForInvalidRunes(editedDeck2.Runes);
-				}
-			}
-			break;
-		}
-		}
-	}
-
-	protected override void UpdateFilteredCards()
-	{
-		base.UpdateFilteredCards();
-		UpdateClassTabNewCardCounts();
-	}
-
-	protected override void TransitionPage(object callbackData)
-	{
-		base.TransitionPage(callbackData);
-		if (CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.MASS_DISENCHANT)
-		{
-			DeselectCurrentTab();
-		}
-		else
-		{
-			SetCurrentClassTabInfo(m_currentClassContext);
-		}
-	}
-
-	protected override void PageRight(DelOnPageTransitionComplete callback, object callbackData)
-	{
+                        }
+                    }
+                    break;
+                }
+        }
+    }
+
+    protected override void UpdateFilteredCards()
+    {
+        base.UpdateFilteredCards();
+        UpdateClassTabNewCardCounts();
+    }
+
+    protected override void TransitionPage(object callbackData)
+    {
+        base.TransitionPage(callbackData);
+        if (CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.MASS_DISENCHANT)
+        {
+            DeselectCurrentTab();
+        }
+        else
+        {
+            SetCurrentClassTabInfo(m_currentClassContext);
+        }
+    }
+
+    protected override void PageRight(DelOnPageTransitionComplete callback, object callbackData)
+    {
 		if (CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode() == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
 		{
 			return;
 		}
-		if (!IsEditingDeathKnightDeck(out var _))
-		{
-			base.PageRight(callback, callbackData);
-			return;
-		}
-		if (IsShowingLockedRuneCards)
-		{
-			base.PageRight(callback, callbackData);
-			return;
-		}
-		if (m_currentClassContext.tagClass == TAG_CLASS.DEATHKNIGHT)
-		{
-			if (m_deckRunesWereUpdatedOnCurrentPage)
-			{
-				FlipToNextFilteredDeathKnightPage(PageTransitionType.MANY_PAGE_RIGHT);
-				return;
-			}
-		}
-		else if (IsRightPageInDeathKnightTab())
-		{
-			m_classCardsCollection.UpdateResults();
-			m_classCardsCollection.GetPageContentsForTab(new CollectionTabInfo
-			{
-				tagClass = TAG_CLASS.DEATHKNIGHT
-			}, 1, calculateCollectionPage: true, out var collectionPage);
-			FlipToPage(collectionPage, null, null, PageTransitionType.MANY_PAGE_RIGHT);
-			return;
-		}
-		base.PageRight(callback, callbackData);
-	}
-
-	protected override void PageLeft(DelOnPageTransitionComplete callback, object callbackData)
-	{
+        if (!IsEditingDeathKnightDeck(out var _))
+        {
+            base.PageRight(callback, callbackData);
+            return;
+        }
+        if (IsShowingLockedRuneCards)
+        {
+            base.PageRight(callback, callbackData);
+            return;
+        }
+        if (m_currentClassContext.tagClass == TAG_CLASS.DEATHKNIGHT)
+        {
+            if (m_deckRunesWereUpdatedOnCurrentPage)
+            {
+                FlipToNextFilteredDeathKnightPage(PageTransitionType.MANY_PAGE_RIGHT);
+                return;
+            }
+        }
+        else if (IsRightPageInDeathKnightTab())
+        {
+            m_classCardsCollection.UpdateResults();
+            m_classCardsCollection.GetPageContentsForTab(new CollectionTabInfo
+            {
+                tagClass = TAG_CLASS.DEATHKNIGHT
+            }, 1, calculateCollectionPage: true, out var collectionPage);
+            FlipToPage(collectionPage, null, null, PageTransitionType.MANY_PAGE_RIGHT);
+            return;
+        }
+        base.PageRight(callback, callbackData);
+    }
+
+    protected override void PageLeft(DelOnPageTransitionComplete callback, object callbackData)
+    {
 		if (CollectionManager.Get().GetCollectibleDisplay().GetViewSubmode() == CollectionUtils.ViewSubmode.CARD_ZILLIAX_MODULES)
 		{
 			return;
 		}
-		if (!IsEditingDeathKnightDeck(out var _))
-		{
-			base.PageLeft(callback, callbackData);
-			return;
-		}
-		if (IsShowingLockedRuneCards)
-		{
-			base.PageLeft(callback, callbackData);
-			return;
-		}
-		if (m_currentClassContext.tagClass == TAG_CLASS.DEATHKNIGHT)
-		{
-			if (m_deckRunesWereUpdatedOnCurrentPage)
-			{
-				FlipToNextFilteredDeathKnightPage(PageTransitionType.MANY_PAGE_LEFT);
-				return;
-			}
-		}
-		else if (IsLeftPageInDeathKnightTab())
-		{
-			m_classCardsCollection.UpdateResults();
-			m_classCardsCollection.GetPageContentsForTab(m_currentClassContext, 1, calculateCollectionPage: true, out var collectionPage);
-			int newPageNum = collectionPage - 1;
-			FlipToPage(newPageNum, null, null, PageTransitionType.MANY_PAGE_LEFT);
-			return;
-		}
-		base.PageLeft(callback, callbackData);
-	}
-
-	public void ShowRuneCardPopupForTutorial()
-	{
-		CollectibleCard firstRuneCard = m_classCardsCollection.GetFirstRuneCard();
-		if (firstRuneCard == null)
-		{
-			Debug.LogWarning("CollectionPageManager.ShowRuneCardPopupForTutorial: There is no valid rune card.");
-			return;
-		}
-		m_classCardsCollection.GetPageContentsForCard(firstRuneCard.CardId, firstRuneCard.PremiumType, out var collectionPage, new CollectionTabInfo
-		{
-			tagClass = TAG_CLASS.DEATHKNIGHT
-		});
-		if (collectionPage != m_currentPageNum)
-		{
-			FlipToPage(collectionPage, null, null);
-		}
-		CollectionCardVisual cardVisual = GetCurrentCollectiblePage().GetCardVisual(firstRuneCard.CardId, firstRuneCard.PremiumType);
-		Vector3 runeBannerPosition = cardVisual.GetRuneBannerPosition();
-		runeBannerPosition.x += (UniversalInputManager.UsePhoneUI ? 14f : 13f);
-		NotificationManager notificationManager = NotificationManager.Get();
-		m_deathKnightRuneTutorialRunePopup = notificationManager.CreatePopupText(UserAttentionBlocker.NONE, runeBannerPosition, 15f * Vector3.one, GameStrings.Get("GLOBAL_RUNE_REQUIREMENT_POPUP_TEXT"));
-		m_deathKnightRuneTutorialRunePopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
-		cardVisual.SetRuneBannerHighlighted(highlight: true);
-	}
-
-	public void ShowRuneIndicatorArrowForTutorial()
-	{
-		CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
-		Vector3 firstRuneIndicatorButtonPosition = collectionDeckTray.GetFirstRuneIndicatorButtonPosition();
-		float scaleFactor;
-		if ((bool)UniversalInputManager.UsePhoneUI)
-		{
-			firstRuneIndicatorButtonPosition.x += -9f;
-			scaleFactor = 7f;
-		}
-		else
-		{
-			firstRuneIndicatorButtonPosition.x += -6f;
-			scaleFactor = 7f;
-		}
-		NotificationManager notificationManager = NotificationManager.Get();
-		m_runeIndicatorArrow = notificationManager.CreateBouncingArrow(UserAttentionBlocker.NONE, firstRuneIndicatorButtonPosition, Vector3.down * 90f, addToList: false, scaleFactor);
-		collectionDeckTray.SetRuneIndicatorHighlighted(highlighted: true);
-	}
-
-	public void DismissRuneCardPopupForTutorial()
-	{
-		NotificationManager.Get().DestroyNotification(m_deathKnightRuneTutorialRunePopup, 0f);
-		CollectibleCard firstRuneCard = m_classCardsCollection.GetFirstRuneCard();
-		if (firstRuneCard == null)
-		{
-			Debug.LogWarning("CollectionPageManager.ShowRuneCardPopupForTutorial: There is no valid rune card.");
-		}
-		else
-		{
-			GetCurrentCollectiblePage().GetCardVisual(firstRuneCard.CardId, firstRuneCard.PremiumType).SetRuneBannerHighlighted(highlight: false);
-		}
-	}
-
-	public void DismissRuneIndicatorArrowForTutorial()
-	{
-		NotificationManager.Get().DestroyNotification(m_runeIndicatorArrow, 0f);
-		CollectionDeckTray.Get().SetRuneIndicatorHighlighted(highlighted: false);
-	}
-
-	private void FlipToNextFilteredDeathKnightPage(PageTransitionType transitionType)
-	{
+        if (!IsEditingDeathKnightDeck(out var _))
+        {
+            base.PageLeft(callback, callbackData);
+            return;
+        }
+        if (IsShowingLockedRuneCards)
+        {
+            base.PageLeft(callback, callbackData);
+            return;
+        }
+        if (m_currentClassContext.tagClass == TAG_CLASS.DEATHKNIGHT)
+        {
+            if (m_deckRunesWereUpdatedOnCurrentPage)
+            {
+                FlipToNextFilteredDeathKnightPage(PageTransitionType.MANY_PAGE_LEFT);
+                return;
+            }
+        }
+        else if (IsLeftPageInDeathKnightTab())
+        {
+            m_classCardsCollection.UpdateResults();
+            m_classCardsCollection.GetPageContentsForTab(m_currentClassContext, 1, calculateCollectionPage: true, out var collectionPage);
+            int newPageNum = collectionPage - 1;
+            FlipToPage(newPageNum, null, null, PageTransitionType.MANY_PAGE_LEFT);
+            return;
+        }
+        base.PageLeft(callback, callbackData);
+    }
+
+    public void ShowRuneCardPopupForTutorial()
+    {
+        CollectibleCard firstRuneCard = m_classCardsCollection.GetFirstRuneCard();
+        if (firstRuneCard == null)
+        {
+            Debug.LogWarning("CollectionPageManager.ShowRuneCardPopupForTutorial: There is no valid rune card.");
+            return;
+        }
+        m_classCardsCollection.GetPageContentsForCard(firstRuneCard.CardId, firstRuneCard.PremiumType, out var collectionPage, new CollectionTabInfo
+        {
+            tagClass = TAG_CLASS.DEATHKNIGHT
+        });
+        if (collectionPage != m_currentPageNum)
+        {
+            FlipToPage(collectionPage, null, null);
+        }
+        CollectionCardVisual cardVisual = GetCurrentCollectiblePage().GetCardVisual(firstRuneCard.CardId, firstRuneCard.PremiumType);
+        Vector3 runeBannerPosition = cardVisual.GetRuneBannerPosition();
+        runeBannerPosition.x += (UniversalInputManager.UsePhoneUI ? 14f : 13f);
+        NotificationManager notificationManager = NotificationManager.Get();
+        m_deathKnightRuneTutorialRunePopup = notificationManager.CreatePopupText(UserAttentionBlocker.NONE, runeBannerPosition, 15f * Vector3.one, GameStrings.Get("GLOBAL_RUNE_REQUIREMENT_POPUP_TEXT"));
+        m_deathKnightRuneTutorialRunePopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
+        cardVisual.SetRuneBannerHighlighted(highlight: true);
+    }
+
+    public void ShowRuneIndicatorArrowForTutorial()
+    {
+        CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
+        Vector3 firstRuneIndicatorButtonPosition = collectionDeckTray.GetFirstRuneIndicatorButtonPosition();
+        float scaleFactor;
+        if ((bool)UniversalInputManager.UsePhoneUI)
+        {
+            firstRuneIndicatorButtonPosition.x += -9f;
+            scaleFactor = 7f;
+        }
+        else
+        {
+            firstRuneIndicatorButtonPosition.x += -6f;
+            scaleFactor = 7f;
+        }
+        NotificationManager notificationManager = NotificationManager.Get();
+        m_runeIndicatorArrow = notificationManager.CreateBouncingArrow(UserAttentionBlocker.NONE, firstRuneIndicatorButtonPosition, Vector3.down * 90f, addToList: false, scaleFactor);
+        collectionDeckTray.SetRuneIndicatorHighlighted(highlighted: true);
+    }
+
+    public void DismissRuneCardPopupForTutorial()
+    {
+        NotificationManager.Get().DestroyNotification(m_deathKnightRuneTutorialRunePopup, 0f);
+        CollectibleCard firstRuneCard = m_classCardsCollection.GetFirstRuneCard();
+        if (firstRuneCard == null)
+        {
+            Debug.LogWarning("CollectionPageManager.ShowRuneCardPopupForTutorial: There is no valid rune card.");
+        }
+        else
+        {
+            GetCurrentCollectiblePage().GetCardVisual(firstRuneCard.CardId, firstRuneCard.PremiumType).SetRuneBannerHighlighted(highlight: false);
+        }
+    }
+
+    public void DismissRuneIndicatorArrowForTutorial()
+    {
+        NotificationManager.Get().DestroyNotification(m_runeIndicatorArrow, 0f);
+        CollectionDeckTray.Get().SetRuneIndicatorHighlighted(highlighted: false);
+    }
+
+    private void FlipToNextFilteredDeathKnightPage(PageTransitionType transitionType)
+    {
 		if (m_lastCollectibleAnchor is CollectibleCard collectibleCard)
-		{
-			int collectionPage;
-			List<CollectibleCard> pageContentsForCard = m_classCardsCollection.GetPageContentsForCard(collectibleCard.CardId, collectibleCard.PremiumType, out collectionPage, m_currentClassContext);
-			if (pageContentsForCard.Count > 0)
-			{
-				m_classCardsCollection.UpdateResults();
-				List<CollectibleCard> pageContentsForCard2 = m_classCardsCollection.GetPageContentsForCard(collectibleCard.CardId, collectibleCard.PremiumType, out collectionPage, m_currentClassContext);
-				int num = collectionPage;
-				if (pageContentsForCard2.Count > 0)
-				{
-					switch (transitionType)
-					{
-					case PageTransitionType.MANY_PAGE_RIGHT:
-						num++;
-						break;
-					case PageTransitionType.MANY_PAGE_LEFT:
-						num--;
-						break;
-					}
-					FlipToPage(num, null, null, transitionType);
-					return;
-				}
-				CollectibleCard collectibleCard2 = ((transitionType != PageTransitionType.MANY_PAGE_LEFT) ? m_classCardsCollection.GetNextValidDeathKnightCardRight(collectibleCard) : m_classCardsCollection.GetNextValidDeathKnightCardLeft(collectibleCard));
-				if (collectibleCard2 != null)
-				{
-					num = m_classCardsCollection.GetPageNumberForCard(collectibleCard2, m_currentClassContext);
-					if (pageContentsForCard.Contains(collectibleCard2))
-					{
-						switch (transitionType)
-						{
-						case PageTransitionType.MANY_PAGE_RIGHT:
-							num++;
-							break;
-						case PageTransitionType.MANY_PAGE_LEFT:
-							num--;
-							break;
-						}
-					}
-					FlipToPage(num, null, null, transitionType);
-					return;
-				}
-				if (transitionType == PageTransitionType.MANY_PAGE_LEFT)
-				{
-					num = m_classCardsCollection.GetFirstPageForTab(m_currentClassContext);
-					if (num > 0)
-					{
-						num--;
-						FlipToPage(num, null, null, transitionType);
-						return;
-					}
-				}
-				else
-				{
-					num = m_classCardsCollection.GetLastPageForTab(m_currentClassContext);
-					if (num > 0)
-					{
-						num++;
-						FlipToPage(num, null, null, transitionType);
-						return;
-					}
-				}
-			}
-		}
-		TransitionPageWhenReady(PageTransitionType.MANY_PAGE_LEFT, useCurrentPageNum: false, null, null);
-		m_deckRunesWereUpdatedOnCurrentPage = false;
-	}
-
-	private bool IsLeftPageInDeathKnightTab()
-	{
-		return m_classCardsCollection.GetCurrentTabInfoFromPage(m_currentPageNum - 1).tagClass == TAG_CLASS.DEATHKNIGHT;
-	}
-
-	private bool IsRightPageInDeathKnightTab()
-	{
-		return m_classCardsCollection.GetCurrentTabInfoFromPage(m_currentPageNum + 1).tagClass == TAG_CLASS.DEATHKNIGHT;
-	}
-
-	private static bool IsEditingDeathKnightDeck(out RunePattern deckRunes)
-	{
-		CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-		bool flag = editedDeck?.HasClass(TAG_CLASS.DEATHKNIGHT) ?? false;
-		deckRunes = (flag ? editedDeck.Runes : default(RunePattern));
-		return flag;
-	}
-
-	protected override void OnPageTransitionRequested()
-	{
-		m_numPageFlipsThisSession++;
-		int @int = Options.Get().GetInt(Option.PAGE_MOUSE_OVERS);
-		int val = @int + 1;
-		if (@int < m_numPlageFlipsBeforeStopShowingArrows)
-		{
-			Options.Get().SetInt(Option.PAGE_MOUSE_OVERS, val);
-		}
-		ShowSetFilterTutorialIfNeeded();
-	}
-
-	protected override void OnPageTurnComplete(object callbackData, int operationId)
-	{
-		if (m_numPageFlipsThisSession % CollectiblePageManager.NUM_PAGE_FLIPS_UNTIL_UNLOAD_UNUSED_ASSETS == 0)
-		{
-			HearthstoneApplication hearthstoneApplication = HearthstoneApplication.Get();
-			if (hearthstoneApplication != null)
-			{
-				hearthstoneApplication.UnloadUnusedAssets();
-			}
-		}
-		TransitionReadyCallbackData transitionReadyCallbackData = callbackData as TransitionReadyCallbackData;
-		CollectionPageDisplay collectionPageDisplay = PageAsCollectionPage(transitionReadyCallbackData.m_otherPage);
-		CollectionUtils.ViewMode viewMode = CollectionManager.Get().GetCollectibleDisplay().GetViewMode();
-		bool num = collectionPageDisplay != PageAsCollectionPage(GetCurrentPage());
-		if (num || viewMode != CollectionUtils.ViewMode.HERO_SKINS)
-		{
-			collectionPageDisplay.HideHeroSkinsDecor();
-		}
-		if (num || viewMode != CollectionUtils.ViewMode.HERO_PICKER)
-		{
-			collectionPageDisplay.HideHeroPicker();
-		}
-		base.OnPageTurnComplete(callbackData, operationId);
-	}
-
-	private void ShowSetFilterTutorialIfNeeded()
-	{
-		if (!Options.Get().GetBool(Option.HAS_SEEN_SET_FILTER_TUTORIAL) && !CollectionManager.Get().IsInEditMode() && CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.CARDS && m_cardsCollection.CardSetFilterIsAllStandardSets())
-		{
-			CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-			if (!(collectionManagerDisplay == null) && !collectionManagerDisplay.IsShowingSetFilterTray() && CollectionManager.Get().AccountHasWildCards() && RankMgr.Get().WildCardsAllowedInCurrentLeague() && m_numPageFlipsThisSession >= NUM_PAGE_FLIPS_BEFORE_SET_FILTER_TUTORIAL && collectionManagerDisplay != null)
-			{
-				collectionManagerDisplay.ShowSetFilterTutorial(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
-				Options.Get().SetBool(Option.HAS_SEEN_SET_FILTER_TUTORIAL, val: true);
-			}
-		}
-	}
-
-	protected override void OnCollectionManagerViewModeChanged(CollectionUtils.ViewMode prevMode, CollectionUtils.ViewMode mode, CollectionUtils.ViewModeData userdata, bool triggerResponse)
-	{
-		if (!triggerResponse)
-		{
-			return;
-		}
-		Log.CollectionManager.Print("transitionPageId={0} pagesTurning={1} mode={2}-->{3} triggerResponse={4}", m_transitionPageId, m_pagesCurrentlyTurning, prevMode, mode, triggerResponse);
+        {
+            int collectionPage;
+            List<CollectibleCard> pageContentsForCard = m_classCardsCollection.GetPageContentsForCard(collectibleCard.CardId, collectibleCard.PremiumType, out collectionPage, m_currentClassContext);
+            if (pageContentsForCard.Count > 0)
+            {
+                m_classCardsCollection.UpdateResults();
+                List<CollectibleCard> pageContentsForCard2 = m_classCardsCollection.GetPageContentsForCard(collectibleCard.CardId, collectibleCard.PremiumType, out collectionPage, m_currentClassContext);
+                int num = collectionPage;
+                if (pageContentsForCard2.Count > 0)
+                {
+                    switch (transitionType)
+                    {
+                        case PageTransitionType.MANY_PAGE_RIGHT:
+                            num++;
+                            break;
+                        case PageTransitionType.MANY_PAGE_LEFT:
+                            num--;
+                            break;
+                    }
+                    FlipToPage(num, null, null, transitionType);
+                    return;
+                }
+                CollectibleCard collectibleCard2 = ((transitionType != PageTransitionType.MANY_PAGE_LEFT) ? m_classCardsCollection.GetNextValidDeathKnightCardRight(collectibleCard) : m_classCardsCollection.GetNextValidDeathKnightCardLeft(collectibleCard));
+                if (collectibleCard2 != null)
+                {
+                    num = m_classCardsCollection.GetPageNumberForCard(collectibleCard2, m_currentClassContext);
+                    if (pageContentsForCard.Contains(collectibleCard2))
+                    {
+                        switch (transitionType)
+                        {
+                            case PageTransitionType.MANY_PAGE_RIGHT:
+                                num++;
+                                break;
+                            case PageTransitionType.MANY_PAGE_LEFT:
+                                num--;
+                                break;
+                        }
+                    }
+                    FlipToPage(num, null, null, transitionType);
+                    return;
+                }
+                if (transitionType == PageTransitionType.MANY_PAGE_LEFT)
+                {
+                    num = m_classCardsCollection.GetFirstPageForTab(m_currentClassContext);
+                    if (num > 0)
+                    {
+                        num--;
+                        FlipToPage(num, null, null, transitionType);
+                        return;
+                    }
+                }
+                else
+                {
+                    num = m_classCardsCollection.GetLastPageForTab(m_currentClassContext);
+                    if (num > 0)
+                    {
+                        num++;
+                        FlipToPage(num, null, null, transitionType);
+                        return;
+                    }
+                }
+            }
+        }
+        TransitionPageWhenReady(PageTransitionType.MANY_PAGE_LEFT, useCurrentPageNum: false, null, null);
+        m_deckRunesWereUpdatedOnCurrentPage = false;
+    }
+
+    private bool IsLeftPageInDeathKnightTab()
+    {
+        return m_classCardsCollection.GetCurrentTabInfoFromPage(m_currentPageNum - 1).tagClass == TAG_CLASS.DEATHKNIGHT;
+    }
+
+    private bool IsRightPageInDeathKnightTab()
+    {
+        return m_classCardsCollection.GetCurrentTabInfoFromPage(m_currentPageNum + 1).tagClass == TAG_CLASS.DEATHKNIGHT;
+    }
+
+    private static bool IsEditingDeathKnightDeck(out RunePattern deckRunes)
+    {
+        CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+        bool flag = editedDeck?.HasClass(TAG_CLASS.DEATHKNIGHT) ?? false;
+        deckRunes = (flag ? editedDeck.Runes : default(RunePattern));
+        return flag;
+    }
+
+    protected override void OnPageTransitionRequested()
+    {
+        m_numPageFlipsThisSession++;
+        int @int = Options.Get().GetInt(Option.PAGE_MOUSE_OVERS);
+        int val = @int + 1;
+        if (@int < m_numPlageFlipsBeforeStopShowingArrows)
+        {
+            Options.Get().SetInt(Option.PAGE_MOUSE_OVERS, val);
+        }
+        ShowSetFilterTutorialIfNeeded();
+    }
+
+    protected override void OnPageTurnComplete(object callbackData, int operationId)
+    {
+        if (m_numPageFlipsThisSession % CollectiblePageManager.NUM_PAGE_FLIPS_UNTIL_UNLOAD_UNUSED_ASSETS == 0)
+        {
+            HearthstoneApplication hearthstoneApplication = HearthstoneApplication.Get();
+            if (hearthstoneApplication != null)
+            {
+                hearthstoneApplication.UnloadUnusedAssets();
+            }
+        }
+        TransitionReadyCallbackData transitionReadyCallbackData = callbackData as TransitionReadyCallbackData;
+        CollectionPageDisplay collectionPageDisplay = PageAsCollectionPage(transitionReadyCallbackData.m_otherPage);
+        CollectionUtils.ViewMode viewMode = CollectionManager.Get().GetCollectibleDisplay().GetViewMode();
+        bool num = collectionPageDisplay != PageAsCollectionPage(GetCurrentPage());
+        if (num || viewMode != CollectionUtils.ViewMode.HERO_SKINS)
+        {
+            collectionPageDisplay.HideHeroSkinsDecor();
+        }
+        if (num || viewMode != CollectionUtils.ViewMode.HERO_PICKER)
+        {
+            collectionPageDisplay.HideHeroPicker();
+        }
+        base.OnPageTurnComplete(callbackData, operationId);
+    }
+
+    private void ShowSetFilterTutorialIfNeeded()
+    {
+        if (!Options.Get().GetBool(Option.HAS_SEEN_SET_FILTER_TUTORIAL) && !CollectionManager.Get().IsInEditMode() && CollectionManager.Get().GetCollectibleDisplay().GetViewMode() == CollectionUtils.ViewMode.CARDS && m_cardsCollection.CardSetFilterIsAllStandardSets())
+        {
+            CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+            if (!(collectionManagerDisplay == null) && !collectionManagerDisplay.IsShowingSetFilterTray() && CollectionManager.Get().AccountHasWildCards() && RankMgr.Get().WildCardsAllowedInCurrentLeague() && m_numPageFlipsThisSession >= NUM_PAGE_FLIPS_BEFORE_SET_FILTER_TUTORIAL && collectionManagerDisplay != null)
+            {
+                collectionManagerDisplay.ShowSetFilterTutorial(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+                Options.Get().SetBool(Option.HAS_SEEN_SET_FILTER_TUTORIAL, val: true);
+            }
+        }
+    }
+
+    protected override void OnCollectionManagerViewModeChanged(CollectionUtils.ViewMode prevMode, CollectionUtils.ViewMode mode, CollectionUtils.ViewModeData userdata, bool triggerResponse)
+    {
+        if (!triggerResponse)
+        {
+            return;
+        }
+        Log.CollectionManager.Print("transitionPageId={0} pagesTurning={1} mode={2}-->{3} triggerResponse={4}", m_transitionPageId, m_pagesCurrentlyTurning, prevMode, mode, triggerResponse);
 		UpdateCraftingModeButtonDustBottleVisibility(CollectionManager.Get().GetCardsToMassDisenchantCount());
-		if (mode == CollectionUtils.ViewMode.DECK_TEMPLATE)
-		{
-			HideNonDeckTemplateTabs(hide: true);
-		}
-		if (mode != 0)
-		{
-			CollectionDeckTray.Get().GetCardsContent().HideDeckHelpPopup();
-		}
-		if (mode != CollectionUtils.ViewMode.HERO_SKINS)
-		{
-			CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-			if (collectionManagerDisplay != null)
-			{
-				collectionManagerDisplay.SetHeroSkinClass(null);
-			}
-		}
-		m_currentPageNum = 1;
-		if (userdata != null)
-		{
-			if (userdata.m_setPageByClass.HasValue)
-			{
+        if (mode == CollectionUtils.ViewMode.DECK_TEMPLATE)
+        {
+            HideNonDeckTemplateTabs(hide: true);
+        }
+        if (mode != 0)
+        {
+            CollectionDeckTray.Get().GetCardsContent().HideDeckHelpPopup();
+        }
+        if (mode != CollectionUtils.ViewMode.HERO_SKINS)
+        {
+            CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+            if (collectionManagerDisplay != null)
+            {
+                collectionManagerDisplay.SetHeroSkinClass(null);
+            }
+        }
+        m_currentPageNum = 1;
+        if (userdata != null)
+        {
+            if (userdata.m_setPageByClass.HasValue)
+            {
 				TAG_CLASS valueOrDefault = userdata.m_setPageByClass.GetValueOrDefault();
-				CollectionTabInfo collectionTabInfo = default(CollectionTabInfo);
+                CollectionTabInfo collectionTabInfo = default(CollectionTabInfo);
 				collectionTabInfo.tagClass = valueOrDefault;
-				CollectionTabInfo pageTabInfo = collectionTabInfo;
-				m_classCardsCollection.GetPageContentsForTab(pageTabInfo, 1, calculateCollectionPage: true, out m_currentPageNum);
-			}
-			else if (userdata.m_setPageByCard != null)
-			{
-				m_classCardsCollection.GetPageContentsForCard(userdata.m_setPageByCard, userdata.m_setPageByPremium, out m_currentPageNum, m_currentClassContext);
-			}
-		}
-		int num = 0;
-		int num2 = 0;
-		for (int i = 0; i < TAG_ORDERING.Length; i++)
-		{
-			if (prevMode == TAG_ORDERING[i])
-			{
-				num = i;
-			}
-			if (mode == TAG_ORDERING[i])
-			{
-				num2 = i;
-			}
-		}
-		PageTransitionType transition = ((num2 - num >= 0) ? PageTransitionType.SINGLE_PAGE_RIGHT : PageTransitionType.SINGLE_PAGE_LEFT);
-		DelOnPageTransitionComplete callback = null;
-		object callbackData = null;
-		if (userdata != null)
-		{
-			callback = userdata.m_pageTransitionCompleteCallback;
-			callbackData = userdata.m_pageTransitionCompleteData;
-		}
-		if (m_turnPageCoroutine != null)
-		{
-			StopCoroutine(m_turnPageCoroutine);
-		}
-		CollectionDeckTray.Get().m_decksContent.UpdateDeckName();
-		CollectionDeckTray.Get().UpdateDoneButtonText();
-		m_turnPageCoroutine = StartCoroutine(ViewModeChangedWaitToTurnPage(transition, prevMode == CollectionUtils.ViewMode.DECK_TEMPLATE, callback, callbackData));
-	}
-
-	private IEnumerator ViewModeChangedWaitToTurnPage(PageTransitionType transition, bool hideDeckTemplateBottomPanel, DelOnPageTransitionComplete callback, object callbackData)
-	{
-		if (m_deckTemplatePicker != null && hideDeckTemplateBottomPanel)
-		{
-			CollectionManager.Get().GetCollectibleDisplay().m_inputBlocker.gameObject.SetActive(value: true);
-			m_deckTemplatePicker.ShowBottomPanel(show: false);
-			while (m_deckTemplatePicker.IsShowingBottomPanel())
-			{
-				yield return null;
-			}
-			yield return StartCoroutine(m_deckTemplatePicker.ShowPacks(show: false));
-			CollectionManager.Get().GetCollectibleDisplay().m_inputBlocker.gameObject.SetActive(value: false);
-		}
-		TransitionPageWhenReady(transition, useCurrentPageNum: true, callback, callbackData);
-	}
-
-	public void OnFavoriteHeroChanged(TAG_CLASS heroClass, NetCache.CardDefinition favoriteHero, bool isFavorite, object userData)
-	{
-		PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteHeroSkins(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
-	}
-
-	public void OnFavoriteCardBackChanged(int newFavoriteCardBackID, bool isFavorite)
-	{
-		PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteCardBacks(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
-	}
-
-	public void OnFavoriteBattlegroundsGuideSkinChanged(BattlegroundsGuideSkinId? newFavoriteBattlegroundsGuideSkinID)
-	{
-		PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteBattlegroundsGuideSkin(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
-	}
+                CollectionTabInfo pageTabInfo = collectionTabInfo;
+                m_classCardsCollection.GetPageContentsForTab(pageTabInfo, 1, calculateCollectionPage: true, out m_currentPageNum);
+            }
+            else if (userdata.m_setPageByCard != null)
+            {
+                m_classCardsCollection.GetPageContentsForCard(userdata.m_setPageByCard, userdata.m_setPageByPremium, out m_currentPageNum, m_currentClassContext);
+            }
+        }
+        int num = 0;
+        int num2 = 0;
+        for (int i = 0; i < TAG_ORDERING.Length; i++)
+        {
+            if (prevMode == TAG_ORDERING[i])
+            {
+                num = i;
+            }
+            if (mode == TAG_ORDERING[i])
+            {
+                num2 = i;
+            }
+        }
+        PageTransitionType transition = ((num2 - num >= 0) ? PageTransitionType.SINGLE_PAGE_RIGHT : PageTransitionType.SINGLE_PAGE_LEFT);
+        DelOnPageTransitionComplete callback = null;
+        object callbackData = null;
+        if (userdata != null)
+        {
+            callback = userdata.m_pageTransitionCompleteCallback;
+            callbackData = userdata.m_pageTransitionCompleteData;
+        }
+        if (m_turnPageCoroutine != null)
+        {
+            StopCoroutine(m_turnPageCoroutine);
+        }
+        CollectionDeckTray.Get().m_decksContent.UpdateDeckName();
+        CollectionDeckTray.Get().UpdateDoneButtonText();
+        m_turnPageCoroutine = StartCoroutine(ViewModeChangedWaitToTurnPage(transition, prevMode == CollectionUtils.ViewMode.DECK_TEMPLATE, callback, callbackData));
+    }
+
+    private IEnumerator ViewModeChangedWaitToTurnPage(PageTransitionType transition, bool hideDeckTemplateBottomPanel, DelOnPageTransitionComplete callback, object callbackData)
+    {
+        if (m_deckTemplatePicker != null && hideDeckTemplateBottomPanel)
+        {
+            CollectionManager.Get().GetCollectibleDisplay().m_inputBlocker.gameObject.SetActive(value: true);
+            m_deckTemplatePicker.ShowBottomPanel(show: false);
+            while (m_deckTemplatePicker.IsShowingBottomPanel())
+            {
+                yield return null;
+            }
+            yield return StartCoroutine(m_deckTemplatePicker.ShowPacks(show: false));
+            CollectionManager.Get().GetCollectibleDisplay().m_inputBlocker.gameObject.SetActive(value: false);
+        }
+        TransitionPageWhenReady(transition, useCurrentPageNum: true, callback, callbackData);
+    }
+
+    public void OnFavoriteHeroChanged(TAG_CLASS heroClass, NetCache.CardDefinition favoriteHero, bool isFavorite, object userData)
+    {
+        PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteHeroSkins(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
+    }
+
+    public void OnFavoriteCardBackChanged(int newFavoriteCardBackID, bool isFavorite)
+    {
+        PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteCardBacks(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
+    }
+
+    public void OnFavoriteBattlegroundsGuideSkinChanged(BattlegroundsGuideSkinId? newFavoriteBattlegroundsGuideSkinID)
+    {
+        PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteBattlegroundsGuideSkin(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
+    }
 
 	public void OnFavoriteCoinChanged(int newFavoriteCoinId, bool isFavorite)
-	{
-		PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteCoin(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
-	}
+    {
+        PageAsCollectionPage(GetCurrentPage()).UpdateFavoriteCoin(CollectionManager.Get().GetCollectibleDisplay().GetViewMode());
+    }
 
-	private HashSet<int> GetCurrentDeckTrayModeCardBackIds()
-	{
+    private HashSet<int> GetCurrentDeckTrayModeCardBackIds()
+    {
 		return CardBackManager.Get().GetCardBackIds(CollectionManager.Get().IsInEditMode());
 	}
 
 	private List<CollectibleCard> GetCurrentDeckTrayModeCosmeticCoins()
 	{
 		return CosmeticCoinManager.Get().GetFilteredCoins();
-	}
+    }
 
-	private bool ShouldClassFilterBeVisible()
-	{
-		return CollectionManager.Get().OwnsAnyCollectible();
-	}
+    private bool ShouldClassFilterBeVisible()
+    {
+        return CollectionManager.Get().OwnsAnyCollectible();
+    }
 }
diff --git a/Assembly-CSharp/CollectionSearch.cs b/Assembly-CSharp/CollectionSearch.cs
index 5b2ef92..5e92e9f 100644
--- a/Assembly-CSharp/CollectionSearch.cs
+++ b/Assembly-CSharp/CollectionSearch.cs
@@ -3,6 +3,7 @@ using System.Text;
 using Blizzard.T5.MaterialService.Extensions;
 using Blizzard.T5.Services;
 using UnityEngine;
+using Accessibility;
 
 public class CollectionSearch : MonoBehaviour
 {
@@ -320,6 +321,7 @@ public class CollectionSearch : MonoBehaviour
 		};
 		textInputParams.m_showVirtualKeyboard = fromActivate;
 		UniversalInputManager.Get().UseTextInput(textInputParams);
+        AccessibilityMgr.AllowTextInput();
 	}
 
 	private void HideInput()
@@ -345,6 +347,8 @@ public class CollectionSearch : MonoBehaviour
 
 	private void OnInputComplete(string input)
 	{
+		AccessibilityMgr.Output(AccessibleCollectionManager.Get(), input);
+
 		m_text = input;
 		UpdateSearchText();
 		SoundManager.Get().LoadAndPlay("text_commit.prefab:05a794ae046d3e842b87893629a826f1");
diff --git a/Assembly-CSharp/CorpseCounter.cs b/Assembly-CSharp/CorpseCounter.cs
index f2f74e0..e3d4ca3 100644
--- a/Assembly-CSharp/CorpseCounter.cs
+++ b/Assembly-CSharp/CorpseCounter.cs
@@ -137,7 +137,7 @@ public class CorpseCounter : MonoBehaviour
 		{
 			Debug.LogWarningFormat("UpdateText() is called with no symbol set.");
 		}
-		else if (ShouldShowCorpseCounter())
+		else if (ShouldShowCorpseCounter(GetPlayer()))
 		{
 			int numAvailableCorpses = GetPlayer().GetNumAvailableCorpses();
 			if (numAvailableCorpses > m_numOfCorpses)
@@ -174,14 +174,13 @@ public class CorpseCounter : MonoBehaviour
 		return GameState.Get().GetFriendlySidePlayer();
 	}
 
-	private bool IsDeathKnightEntity(Entity entity)
+	private static bool IsDeathKnightEntity(Entity entity)
 	{
 		return entity?.HasClass(TAG_CLASS.DEATHKNIGHT) ?? false;
 	}
 
-	private bool ShouldShowCorpseCounter()
+	internal static bool ShouldShowCorpseCounter(Player player)
 	{
-		Player player = GetPlayer();
 		if (player == null)
 		{
 			return false;
@@ -213,7 +212,7 @@ public class CorpseCounter : MonoBehaviour
 		{
 			return true;
 		}
-		if (m_side == Player.Side.FRIENDLY)
+		if (player.GetSide() == Player.Side.FRIENDLY)
 		{
 			foreach (Card card3 in player.GetHandZone().GetCards())
 			{
diff --git a/Assembly-CSharp/CosmeticCoinManager.cs b/Assembly-CSharp/CosmeticCoinManager.cs
index 80a1c3e..548675e 100644
--- a/Assembly-CSharp/CosmeticCoinManager.cs
+++ b/Assembly-CSharp/CosmeticCoinManager.cs
@@ -12,6 +12,7 @@ using Hearthstone.Progression;
 using Hearthstone.UI;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class CosmeticCoinManager : IService
 {
@@ -112,9 +113,9 @@ public class CosmeticCoinManager : IService
 			return false;
 		}
 		if (array.Contains(text) && !IsFavoriteCoin(value))
-		{
-			return false;
-		}
+			{
+				return false;
+			}
 		if (array.Contains(text2) && IsOwnedCoinCard(coinCard.CardId))
 		{
 			return false;
@@ -160,8 +161,8 @@ public class CosmeticCoinManager : IService
 			}
 			else
 			{
-				m_cardIdCoinIdMap.Add(collectibleCard.CardDbId, record.ID);
-			}
+			m_cardIdCoinIdMap.Add(collectibleCard.CardDbId, record.ID);
+		}
 		}
 		UpdateCoinCards();
 	}
@@ -331,11 +332,13 @@ public class CosmeticCoinManager : IService
 		OfflineDataCache.OfflineData data = OfflineDataCache.ReadOfflineDataFromFile();
 		Network.Get().SetFavoriteCosmeticCoin(ref data, newFavoriteCoinID, isFavorite);
 		OfflineDataCache.WriteOfflineDataToFile(data);
+    AccessibleCollectionManager.Get().WaitingForServerResponse();
 	}
 
 	public void OnFavoriteCoinChanged(int newFavoriteCoinID, bool isFavorite)
 	{
 		Log.CoinManager.Print(string.Format("CoinManager - Favorite Coin Changed" + $" ID: {newFavoriteCoinID}" + $" Favorite: {isFavorite}"));
+		AccessibleCollectionManager.Get().OnFavoriteCoinChanged();
 		this.OnFavoriteCoinsChanged?.Invoke(newFavoriteCoinID, isFavorite);
 	}
 
@@ -476,4 +479,38 @@ public class CosmeticCoinManager : IService
 	{
 		m_searchText = searchText?.ToLower();
 	}
+
+	#region Accessibility
+	internal bool IsCoinCard(string cardId)
+	{
+		foreach (var coin in m_coinCards)
+		{
+			if (coin.CardId.Equals(cardId))
+			{
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	internal CosmeticCoinDbfRecord GetCoinRecord(CollectibleCard card)
+	{
+		if (!m_cardIdCoinIdMap.TryGetValue(card.CardDbId, out var coinId))
+		{
+			AccessibilityUtils.LogFatalError($"Could not find coin record for coin with DB ID: {card.CardDbId}");
+			return null;
+		}
+
+		CosmeticCoinDbfRecord coinRecord = GameDbf.CosmeticCoin.GetRecord(coinId);
+		if (coinRecord == null)
+		{
+			AccessibilityUtils.LogFatalError($"Could not find coin record for coin with coin ID: {coinId} (coin DB IS was {card.CardDbId})");
+			return null;
+		}
+
+		return coinRecord;
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/CraftingManager.cs b/Assembly-CSharp/CraftingManager.cs
index a92d421..23e5272 100644
--- a/Assembly-CSharp/CraftingManager.cs
+++ b/Assembly-CSharp/CraftingManager.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Assets;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class CraftingManager : MonoBehaviour
 {
@@ -22,231 +23,231 @@ public class CraftingManager : MonoBehaviour
 	}
 
 	[Header("Bones")]
-	public Transform m_floatingCardBone;
+    public Transform m_floatingCardBone;
 
-	public Transform m_faceDownCardBone;
+    public Transform m_faceDownCardBone;
 
-	public Transform m_cardInfoPaneBone;
+    public Transform m_cardInfoPaneBone;
 
-	public Transform m_cardCounterBone;
+    public Transform m_cardCounterBone;
 
 	public Transform m_signature25CardCounterBone;
 
-	public Transform m_showCraftingUIBone;
+    public Transform m_showCraftingUIBone;
 
-	public Transform m_hideCraftingUIBone;
+    public Transform m_hideCraftingUIBone;
 
-	public Transform m_showUpgradeToGoldenPopupBone;
+    public Transform m_showUpgradeToGoldenPopupBone;
 
 	public Transform m_signatureTooltipBone;
 
 	[Header("UI")]
-	public BoxCollider m_offClickCatcher;
+    public BoxCollider m_offClickCatcher;
 
-	public CraftCardCountTab m_cardCountTab;
+    public CraftCardCountTab m_cardCountTab;
 
-	public Vector3 m_cardCountTabShowScale = Vector3.one;
+    public Vector3 m_cardCountTabShowScale = Vector3.one;
 
-	public Vector3 m_cardCountTabHideScale = new Vector3(1f, 1f, 0f);
+    public Vector3 m_cardCountTabHideScale = new Vector3(1f, 1f, 0f);
 
-	public PegUIElement m_switchPremiumButton;
+    public PegUIElement m_switchPremiumButton;
 
-	public QuestCardRewardOverlay m_questCardRewardOverlay;
+    public QuestCardRewardOverlay m_questCardRewardOverlay;
 
 	public RelatedCardsTray m_relatedCardsTray;
 
 	[Header("Animation")]
-	public float m_timeForCardToFlipUp;
+    public float m_timeForCardToFlipUp;
 
-	public float m_timeForBackCardToMoveUp;
+    public float m_timeForBackCardToMoveUp;
 
-	public float m_delayBeforeBackCardMovesUp;
+    public float m_delayBeforeBackCardMovesUp;
 
-	public iTween.EaseType m_easeTypeForCardFlip;
+    public iTween.EaseType m_easeTypeForCardFlip;
 
-	public iTween.EaseType m_easeTypeForCardMoveUp;
+    public iTween.EaseType m_easeTypeForCardMoveUp;
 
-	public Vector3 m_utgAlertPopupOffset = new Vector3(-5f, 0f, 0f);
+    public Vector3 m_utgAlertPopupOffset = new Vector3(-5f, 0f, 0f);
 
-	private static CraftingManager s_instance;
+    private static CraftingManager s_instance;
 
-	public CraftingUI m_craftingUI;
+    public CraftingUI m_craftingUI;
 
-	private Widget m_upgradeToGoldenWidget;
+    private Widget m_upgradeToGoldenWidget;
 
-	private bool m_upgradeToGoldenWidgetShown;
+    private bool m_upgradeToGoldenWidgetShown;
 
-	private Actor m_currentBigActor;
+    private Actor m_currentBigActor;
 
-	private bool m_isCurrentActorAGhost;
+    private bool m_isCurrentActorAGhost;
 
-	private Actor m_upsideDownActor;
+    private Actor m_upsideDownActor;
 
-	private Actor m_currentRelatedCardActor;
+    private Actor m_currentRelatedCardActor;
 
-	private Actor m_ghostWeaponActor;
+    private Actor m_ghostWeaponActor;
 
-	private Actor m_ghostMinionActor;
+    private Actor m_ghostMinionActor;
 
-	private Actor m_ghostSpellActor;
+    private Actor m_ghostSpellActor;
 
-	private Actor m_ghostHeroActor;
+    private Actor m_ghostHeroActor;
 
-	private Actor m_ghostHeroPowerActor;
+    private Actor m_ghostHeroPowerActor;
 
-	private Actor m_ghostLocationActor;
+    private Actor m_ghostLocationActor;
 
-	private Actor m_templateWeaponActor;
+    private Actor m_templateWeaponActor;
 
-	private Actor m_templateSpellActor;
+    private Actor m_templateSpellActor;
 
-	private Actor m_templateMinionActor;
+    private Actor m_templateMinionActor;
 
-	private Actor m_templateHeroActor;
+    private Actor m_templateHeroActor;
 
-	private Actor m_templateHeroPowerActor;
+    private Actor m_templateHeroPowerActor;
 
-	private Actor m_templateLocationActor;
+    private Actor m_templateLocationActor;
 
-	private Actor m_hiddenActor;
+    private Actor m_hiddenActor;
 
-	private CardInfoPane m_cardInfoPane;
+    private CardInfoPane m_cardInfoPane;
 
-	private Actor m_templateGoldenWeaponActor;
+    private Actor m_templateGoldenWeaponActor;
 
-	private Actor m_templateGoldenSpellActor;
+    private Actor m_templateGoldenSpellActor;
 
-	private Actor m_templateGoldenMinionActor;
+    private Actor m_templateGoldenMinionActor;
 
-	private Actor m_templateGoldenHeroActor;
+    private Actor m_templateGoldenHeroActor;
 
-	private Actor m_templateGoldenHeroPowerActor;
+    private Actor m_templateGoldenHeroPowerActor;
 
-	private Actor m_templateDiamondMinionActor;
+    private Actor m_templateDiamondMinionActor;
 
 	private Dictionary<int, Actor> m_templateSignatureMinionActors;
 
-	private Actor m_templateGoldenLocationActor;
+    private Actor m_templateGoldenLocationActor;
 
-	private Actor m_ghostGoldenWeaponActor;
+    private Actor m_ghostGoldenWeaponActor;
 
-	private Actor m_ghostGoldenSpellActor;
+    private Actor m_ghostGoldenSpellActor;
 
-	private Actor m_ghostGoldenMinionActor;
+    private Actor m_ghostGoldenMinionActor;
 
-	private Actor m_ghostGoldenHeroActor;
+    private Actor m_ghostGoldenHeroActor;
 
-	private Actor m_ghostGoldenHeroPowerActor;
+    private Actor m_ghostGoldenHeroPowerActor;
 
-	private Actor m_ghostDiamondMinionActor;
+    private Actor m_ghostDiamondMinionActor;
 
 	private Dictionary<int, Actor> m_ghostSignatureMinionActors;
 
-	private Actor m_ghostGoldenLocationActor;
-
-	private bool m_cancellingCraftMode;
-
-	private long m_unCommitedArcaneDustAdjustments;
-
-	private CraftingPendingTransaction m_pendingClientTransaction;
-
-	private CraftingPendingTransaction m_pendingServerTransaction;
-
-	private Vector3 m_craftSourcePosition;
-
-	private Vector3 m_craftSourceScale;
-
-	private CollectionCardActors m_cardActors;
-
-	private Actor m_collectionCardActor;
-
-	private bool m_elementsLoaded;
-
-	private static readonly PlatformDependentValue<Vector3> HERO_POWER_START_POSITION = new PlatformDependentValue<Vector3>(PlatformCategory.Screen)
-	{
-		PC = new Vector3(0f, -0.5f, 0f),
-		Phone = new Vector3(0f, -0.5f, 0f)
-	};
-
-	private static readonly PlatformDependentValue<Vector3> HERO_POWER_START_SCALE = new PlatformDependentValue<Vector3>(PlatformCategory.Screen)
-	{
-		PC = new Vector3(0.1f, 0.1f, 0.1f),
-		Phone = new Vector3(0.1f, 0.1f, 0.1f)
-	};
-
-	private static readonly PlatformDependentValue<Vector3> HERO_POWER_POSITION = new PlatformDependentValue<Vector3>(PlatformCategory.Screen)
-	{
-		PC = new Vector3(-2.11f, -0.010312f, -0.06f),
-		Phone = new Vector3(-1.97f, -0.0006f, -0.033f)
-	};
-
-	private static readonly PlatformDependentValue<Vector3> HERO_POWER_SCALE = new PlatformDependentValue<Vector3>(PlatformCategory.Screen)
-	{
-		PC = new Vector3(0.85f, 0.85f, 0.85f),
-		Phone = new Vector3(0.76637f, 0.76637f, 0.76637f)
-	};
-
-	private static readonly float HERO_POWER_TWEEN_TIME = 0.5f;
-
-	private static readonly AssetReference UPGRADE_TO_GOLDEN_WIDGET_PREFAB = new AssetReference("UpgradeToGoldenPopup.prefab:15b90c0a0040d1445a44a463626214bc");
-
-	private ScreenEffectsHandle m_screenEffectsHandle;
-
-	public static bool IsInitialized => s_instance != null;
-
-	private bool IsInCraftingMode { get; set; }
-
-	private void Awake()
-	{
-		CollectionManager.Get()?.RegisterMassDisenchantListener(OnMassDisenchant);
-		if (m_upgradeToGoldenWidget != null)
-		{
-			m_upgradeToGoldenWidget.Hide();
-		}
-		m_screenEffectsHandle = new ScreenEffectsHandle(this);
-	}
-
-	private void OnDestroy()
-	{
-		if (CollectionManager.Get() != null)
-		{
-			CollectionManager.Get().RemoveMassDisenchantListener(OnMassDisenchant);
-		}
-		s_instance = null;
-	}
-
-	private void Start()
-	{
-		LoadElements();
-	}
-
-	private void LoadElements()
-	{
-		if (!m_elementsLoaded)
-		{
-			LoadActor("Card_Hand_Weapon.prefab:30888a1fdca5c6c43abcc5d9dca55783", ref m_ghostWeaponActor, ref m_templateWeaponActor);
-			LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.WEAPON, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenWeaponActor, ref m_templateGoldenWeaponActor);
-			LoadActor("Card_Hand_Ally.prefab:d00eb0f79080e0749993fe4619e9143d", ref m_ghostMinionActor, ref m_templateMinionActor);
-			LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.MINION, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenMinionActor, ref m_templateGoldenMinionActor);
-			LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.MINION, TAG_PREMIUM.DIAMOND), ref m_ghostDiamondMinionActor, ref m_templateDiamondMinionActor);
-			LoadActor("Card_Hand_Ability.prefab:3c3f5189f0d0b3745a1c1ca21d41efe0", ref m_ghostSpellActor, ref m_templateSpellActor);
-			LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.SPELL, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenSpellActor, ref m_templateGoldenSpellActor);
-			LoadActor("Card_Hand_Hero.prefab:a977c49edb5fb5d4c8dee4d2344d1395", ref m_ghostHeroActor, ref m_templateHeroActor);
-			LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.HERO, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenHeroActor, ref m_templateGoldenHeroActor);
-			LoadActor("History_HeroPower.prefab:e73edf8ccea2b11429093f7a448eef53", ref m_ghostHeroPowerActor, ref m_templateHeroPowerActor);
-			LoadActor(ActorNames.GetNameWithPremiumType(ActorNames.ACTOR_ASSET.HISTORY_HERO_POWER, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenHeroPowerActor, ref m_templateGoldenHeroPowerActor);
-			LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.LOCATION, TAG_PREMIUM.NORMAL), ref m_ghostLocationActor, ref m_templateLocationActor);
-			LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.LOCATION, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenLocationActor, ref m_templateGoldenLocationActor);
-			LoadActor("Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9", ref m_hiddenActor);
+    private Actor m_ghostGoldenLocationActor;
+
+    private bool m_cancellingCraftMode;
+
+    private long m_unCommitedArcaneDustAdjustments;
+
+    private CraftingPendingTransaction m_pendingClientTransaction;
+
+    private CraftingPendingTransaction m_pendingServerTransaction;
+
+    private Vector3 m_craftSourcePosition;
+
+    private Vector3 m_craftSourceScale;
+
+    private CollectionCardActors m_cardActors;
+
+    private Actor m_collectionCardActor;
+
+    private bool m_elementsLoaded;
+
+    private static readonly PlatformDependentValue<Vector3> HERO_POWER_START_POSITION = new PlatformDependentValue<Vector3>(PlatformCategory.Screen)
+    {
+        PC = new Vector3(0f, -0.5f, 0f),
+        Phone = new Vector3(0f, -0.5f, 0f)
+    };
+
+    private static readonly PlatformDependentValue<Vector3> HERO_POWER_START_SCALE = new PlatformDependentValue<Vector3>(PlatformCategory.Screen)
+    {
+        PC = new Vector3(0.1f, 0.1f, 0.1f),
+        Phone = new Vector3(0.1f, 0.1f, 0.1f)
+    };
+
+    private static readonly PlatformDependentValue<Vector3> HERO_POWER_POSITION = new PlatformDependentValue<Vector3>(PlatformCategory.Screen)
+    {
+        PC = new Vector3(-2.11f, -0.010312f, -0.06f),
+        Phone = new Vector3(-1.97f, -0.0006f, -0.033f)
+    };
+
+    private static readonly PlatformDependentValue<Vector3> HERO_POWER_SCALE = new PlatformDependentValue<Vector3>(PlatformCategory.Screen)
+    {
+        PC = new Vector3(0.85f, 0.85f, 0.85f),
+        Phone = new Vector3(0.76637f, 0.76637f, 0.76637f)
+    };
+
+    private static readonly float HERO_POWER_TWEEN_TIME = 0.5f;
+
+    private static readonly AssetReference UPGRADE_TO_GOLDEN_WIDGET_PREFAB = new AssetReference("UpgradeToGoldenPopup.prefab:15b90c0a0040d1445a44a463626214bc");
+
+    private ScreenEffectsHandle m_screenEffectsHandle;
+
+    public static bool IsInitialized => s_instance != null;
+
+    private bool IsInCraftingMode { get; set; }
+
+    private void Awake()
+    {
+        CollectionManager.Get()?.RegisterMassDisenchantListener(OnMassDisenchant);
+        if (m_upgradeToGoldenWidget != null)
+        {
+            m_upgradeToGoldenWidget.Hide();
+        }
+        m_screenEffectsHandle = new ScreenEffectsHandle(this);
+    }
+
+    private void OnDestroy()
+    {
+        if (CollectionManager.Get() != null)
+        {
+            CollectionManager.Get().RemoveMassDisenchantListener(OnMassDisenchant);
+        }
+        s_instance = null;
+    }
+
+    private void Start()
+    {
+        LoadElements();
+    }
+
+    private void LoadElements()
+    {
+        if (!m_elementsLoaded)
+        {
+            LoadActor("Card_Hand_Weapon.prefab:30888a1fdca5c6c43abcc5d9dca55783", ref m_ghostWeaponActor, ref m_templateWeaponActor);
+            LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.WEAPON, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenWeaponActor, ref m_templateGoldenWeaponActor);
+            LoadActor("Card_Hand_Ally.prefab:d00eb0f79080e0749993fe4619e9143d", ref m_ghostMinionActor, ref m_templateMinionActor);
+            LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.MINION, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenMinionActor, ref m_templateGoldenMinionActor);
+            LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.MINION, TAG_PREMIUM.DIAMOND), ref m_ghostDiamondMinionActor, ref m_templateDiamondMinionActor);
+            LoadActor("Card_Hand_Ability.prefab:3c3f5189f0d0b3745a1c1ca21d41efe0", ref m_ghostSpellActor, ref m_templateSpellActor);
+            LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.SPELL, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenSpellActor, ref m_templateGoldenSpellActor);
+            LoadActor("Card_Hand_Hero.prefab:a977c49edb5fb5d4c8dee4d2344d1395", ref m_ghostHeroActor, ref m_templateHeroActor);
+            LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.HERO, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenHeroActor, ref m_templateGoldenHeroActor);
+            LoadActor("History_HeroPower.prefab:e73edf8ccea2b11429093f7a448eef53", ref m_ghostHeroPowerActor, ref m_templateHeroPowerActor);
+            LoadActor(ActorNames.GetNameWithPremiumType(ActorNames.ACTOR_ASSET.HISTORY_HERO_POWER, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenHeroPowerActor, ref m_templateGoldenHeroPowerActor);
+            LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.LOCATION, TAG_PREMIUM.NORMAL), ref m_ghostLocationActor, ref m_templateLocationActor);
+            LoadActor(ActorNames.GetHandActor(TAG_CARDTYPE.LOCATION, TAG_PREMIUM.GOLDEN), ref m_ghostGoldenLocationActor, ref m_templateGoldenLocationActor);
+            LoadActor("Card_Hidden.prefab:1a94649d257bc284ca6e2962f634a8b9", ref m_hiddenActor);
 			LoadSignatureActors();
-			m_hiddenActor.GetMeshRenderer().transform.localEulerAngles = new Vector3(0f, 180f, 180f);
-			LayerUtils.SetLayer(m_hiddenActor.gameObject, GameLayer.IgnoreFullScreenEffects);
-			SoundManager.Get().Load("Card_Transition_Out.prefab:aecf5b5837772844b9d2db995744df82");
-			SoundManager.Get().Load("Card_Transition_In.prefab:3f3fbe896b8b260448e8c7e5d028d971");
-			LoadRandomCardBack();
-			m_elementsLoaded = true;
-		}
-	}
+            m_hiddenActor.GetMeshRenderer().transform.localEulerAngles = new Vector3(0f, 180f, 180f);
+            LayerUtils.SetLayer(m_hiddenActor.gameObject, GameLayer.IgnoreFullScreenEffects);
+            SoundManager.Get().Load("Card_Transition_Out.prefab:aecf5b5837772844b9d2db995744df82");
+            SoundManager.Get().Load("Card_Transition_In.prefab:3f3fbe896b8b260448e8c7e5d028d971");
+            LoadRandomCardBack();
+            m_elementsLoaded = true;
+        }
+    }
 
 	private void LoadSignatureActors()
 	{
@@ -263,91 +264,91 @@ public class CraftingManager : MonoBehaviour
 		}
 	}
 
-	public void SwitchPremiumView(TAG_PREMIUM premium)
-	{
-		if (premium != GetShownActor().GetPremium())
-		{
-			if (m_upsideDownActor != null)
-			{
-				UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
-				m_upsideDownActor = null;
-			}
-			if (m_currentBigActor != null)
-			{
-				m_currentBigActor.GetSpell(SpellType.GHOSTMODE).GetComponent<PlayMakerFSM>().SendEvent("Cancel");
-				UnityEngine.Object.Destroy(m_currentBigActor.gameObject);
-				m_currentBigActor = null;
-			}
-			string cardId = m_collectionCardActor.GetEntityDef().GetCardId();
-			if (GameUtils.IsClassicCard(cardId))
-			{
-				EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
-				m_pendingClientTransaction.CardID = GameUtils.TranslateDbIdToCardId(entityDef.GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
-			}
-			else
-			{
-				m_pendingClientTransaction.CardID = cardId;
-			}
-			m_pendingClientTransaction.Premium = premium;
-			NetCache.CardValue cardValue = GetCardValue(m_pendingClientTransaction.CardID, premium);
-			if (cardValue != null)
-			{
-				m_pendingClientTransaction.CardValueOverridden = cardValue.IsOverrideActive();
-			}
-			MoveCardToBigSpot(m_collectionCardActor, premium);
-			if (m_craftingUI != null)
-			{
-				m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
-			}
-		}
-	}
-
-	public static CraftingManager Get()
-	{
-		if (s_instance == null)
-		{
-			string text = (UniversalInputManager.UsePhoneUI ? "CraftingManager_phone.prefab:d28ac29ae64f14e649186d0d1fe5f7e8" : "CraftingManager.prefab:9dc2dd187dd914959b311d326c3fd5b2");
-			s_instance = AssetLoader.Get().InstantiatePrefab(text).GetComponent<CraftingManager>();
-			s_instance.LoadElements();
-		}
-		return s_instance;
-	}
-
-	public NetCache.CardValue GetCardValue(string cardID, TAG_PREMIUM premium)
-	{
-		NetCache.CardValue value = new NetCache.CardValue();
-		string cardId = cardID;
-		if (GameUtils.IsClassicCard(cardID))
-		{
-			cardId = GameUtils.TranslateDbIdToCardId(DefLoader.Get().GetEntityDef(cardID).GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
-		}
-		if (IsLegacyCardValueCacheEnabled())
-		{
-			NetCache.CardDefinition key = new NetCache.CardDefinition
-			{
-				Name = cardId,
-				Premium = premium
-			};
-			NetCache.NetCacheCardValues netObject = NetCache.Get().GetNetObject<NetCache.NetCacheCardValues>();
-			if (netObject == null || !netObject.Values.TryGetValue(key, out value))
-			{
-				return null;
-			}
-			return value;
-		}
-		EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+    public void SwitchPremiumView(TAG_PREMIUM premium)
+    {
+        if (premium != GetShownActor().GetPremium())
+        {
+            if (m_upsideDownActor != null)
+            {
+                UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
+                m_upsideDownActor = null;
+            }
+            if (m_currentBigActor != null)
+            {
+                m_currentBigActor.GetSpell(SpellType.GHOSTMODE).GetComponent<PlayMakerFSM>().SendEvent("Cancel");
+                UnityEngine.Object.Destroy(m_currentBigActor.gameObject);
+                m_currentBigActor = null;
+            }
+            string cardId = m_collectionCardActor.GetEntityDef().GetCardId();
+            if (GameUtils.IsClassicCard(cardId))
+            {
+                EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+                m_pendingClientTransaction.CardID = GameUtils.TranslateDbIdToCardId(entityDef.GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
+            }
+            else
+            {
+                m_pendingClientTransaction.CardID = cardId;
+            }
+            m_pendingClientTransaction.Premium = premium;
+            NetCache.CardValue cardValue = GetCardValue(m_pendingClientTransaction.CardID, premium);
+            if (cardValue != null)
+            {
+                m_pendingClientTransaction.CardValueOverridden = cardValue.IsOverrideActive();
+            }
+            MoveCardToBigSpot(m_collectionCardActor, premium);
+            if (m_craftingUI != null)
+            {
+                m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
+            }
+        }
+    }
+
+    public static CraftingManager Get()
+    {
+        if (s_instance == null)
+        {
+            string text = (UniversalInputManager.UsePhoneUI ? "CraftingManager_phone.prefab:d28ac29ae64f14e649186d0d1fe5f7e8" : "CraftingManager.prefab:9dc2dd187dd914959b311d326c3fd5b2");
+            s_instance = AssetLoader.Get().InstantiatePrefab(text).GetComponent<CraftingManager>();
+            s_instance.LoadElements();
+        }
+        return s_instance;
+    }
+
+    public NetCache.CardValue GetCardValue(string cardID, TAG_PREMIUM premium)
+    {
+        NetCache.CardValue value = new NetCache.CardValue();
+        string cardId = cardID;
+        if (GameUtils.IsClassicCard(cardID))
+        {
+            cardId = GameUtils.TranslateDbIdToCardId(DefLoader.Get().GetEntityDef(cardID).GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
+        }
+        if (IsLegacyCardValueCacheEnabled())
+        {
+            NetCache.CardDefinition key = new NetCache.CardDefinition
+            {
+                Name = cardId,
+                Premium = premium
+            };
+            NetCache.NetCacheCardValues netObject = NetCache.Get().GetNetObject<NetCache.NetCacheCardValues>();
+            if (netObject == null || !netObject.Values.TryGetValue(key, out value))
+            {
+                return null;
+            }
+            return value;
+        }
+        EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
 		InitCardValueDbfRecord record = GameDbf.InitCardValue.GetRecord((InitCardValueDbfRecord x) => entityDef.GetRarity() == (TAG_RARITY)x.Rarity && x.Premium == (int)premium);
 		if (record == null)
-		{
-			return null;
-		}
+        {
+            return null;
+        }
 		value.BaseBuyValue = record.Buy;
 		value.BaseSellValue = record.Sell;
 		value.BaseUpgradeValue = record.Upgrade;
 		int assetCardId = GameUtils.TranslateCardIdToDbId(entityDef.GetCardId());
 		CardValueDbfRecord record2 = GameDbf.CardValue.GetRecord((CardValueDbfRecord x) => assetCardId == x.AssetCardId && x.Premium == (int)premium && EventTimingManager.Get().IsEventActive(x.OverrideEvent));
 		if (record2 != null)
-		{
+        {
 			value.BuyValueOverride = record2.Buy;
 			value.OverrideEvent = record2.OverrideEvent;
 			if (record2.SellState == CardValue.SellState.RECENTLY_NERFED_USE_BUY_VALUE)
@@ -358,9 +359,9 @@ public class CraftingManager : MonoBehaviour
 			{
 				value.SellValueOverride = value.BaseSellValue;
 			}
-		}
-		return value;
-	}
+        }
+        return value;
+    }
 
 	public CanCraftCardResult CanUpgradeCardToGolden(string cardID, TAG_PREMIUM premium, EntityDef entityDef = null)
 	{
@@ -414,57 +415,60 @@ public class CraftingManager : MonoBehaviour
 	}
 
 	public bool HasEnoughCopiesToUpgrade(string cardID, TAG_PREMIUM premium)
-	{
-		if (!HasUpgradeToGoldenEnabled())
-		{
-			return false;
-		}
+    {
+        if (!HasUpgradeToGoldenEnabled())
+        {
+            return false;
+        }
 		CollectibleCard card = CollectionManager.Get().GetCard(cardID, TAG_PREMIUM.NORMAL);
 		CollectibleCard card2 = CollectionManager.Get().GetCard(cardID, TAG_PREMIUM.GOLDEN);
 		if (card == null || card2 == null)
-		{
-			return false;
-		}
+        {
+            return false;
+        }
 		CollectibleCard collectibleCard = ((premium == TAG_PREMIUM.NORMAL) ? card : card2);
 		bool isLegendary = collectibleCard.Rarity == TAG_RARITY.LEGENDARY;
-		int numOwnedIncludePending = GetNumOwnedIncludePending(cardID, TAG_PREMIUM.NORMAL);
-		int numOwnedIncludePending2 = GetNumOwnedIncludePending(cardID, TAG_PREMIUM.GOLDEN);
+        int numOwnedIncludePending = GetNumOwnedIncludePending(cardID, TAG_PREMIUM.NORMAL);
+        int numOwnedIncludePending2 = GetNumOwnedIncludePending(cardID, TAG_PREMIUM.GOLDEN);
 		return HasEnoughCopiesToUpgrade(collectibleCard, isLegendary, numOwnedIncludePending, numOwnedIncludePending2, premium);
 	}
 
 	public bool HasEnoughCopiesToUpgrade(CollectibleCard card, bool isLegendary, int normalCount, int goldenCount, TAG_PREMIUM premium)
 	{
 		if (!HasUpgradeToGoldenEnabled())
-		{
-			return false;
-		}
+        {
+            return false;
+        }
 		if (normalCount < card.DefaultMaxCopiesPerDeck)
-		{
+        {
 			if (!isLegendary && normalCount == 1 && goldenCount == 1)
-			{
-				return true;
-			}
+            {
+                return true;
+            }
 			if (!isLegendary && normalCount == 1 && premium == TAG_PREMIUM.GOLDEN)
-			{
-				return true;
-			}
-			return false;
-		}
-		return true;
-	}
-
-	public bool HasUpgradeToGoldenEnabled()
-	{
-		return NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().EnableUpgradeToGolden;
-	}
-
-	public bool IsLegacyCardValueCacheEnabled()
-	{
-		return NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().LegacyCardValueCacheEnabled;
-	}
+            {
+                return true;
+            }
+            return false;
+        }
+        return true;
+    }
+
+    public bool HasUpgradeToGoldenEnabled()
+    {
+        // Not accessible (and not a priority)
+        return false;
+
+        return NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().EnableUpgradeToGolden;
+    }
+
+    public bool IsLegacyCardValueCacheEnabled()
+    {
+        return NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().LegacyCardValueCacheEnabled;
+    }
 
 	public CanCraftCardResult CanCraftCardRightNow(EntityDef entityDef, TAG_PREMIUM premium)
-	{
+    {
 		if (premium == TAG_PREMIUM.SIGNATURE || premium == TAG_PREMIUM.DIAMOND)
 		{
 			return CanCraftCardResult.NotCraftable;
@@ -473,190 +477,189 @@ public class CraftingManager : MonoBehaviour
 		{
 			return CanCraftCardResult.NotCraftable;
 		}
-		NetCache.CardDefinition cardDefinition = new NetCache.CardDefinition
-		{
-			Name = entityDef.GetCardId(),
-			Premium = premium
-		};
+        NetCache.CardDefinition cardDefinition = new NetCache.CardDefinition
+        {
+            Name = entityDef.GetCardId(),
+            Premium = premium
+        };
 		int numOwnedIncludePending = GetNumOwnedIncludePending(cardDefinition.Name, cardDefinition.Premium);
-		int num = (entityDef.IsElite() ? 1 : 2);
-		if (numOwnedIncludePending >= num)
-		{
+		if (HasReachedCardLimit(entityDef, numOwnedIncludePending))
+        {
 			return CanCraftCardResult.TooManyCopies;
-		}
-		if (!TryGetCardBuyValue(cardDefinition.Name, cardDefinition.Premium, out var buyValue))
-		{
+        }
+        if (!TryGetCardBuyValue(cardDefinition.Name, cardDefinition.Premium, out var buyValue))
+        {
 			return CanCraftCardResult.NoCardValue;
-		}
-		if (NetCache.Get().GetArcaneDustBalance() < buyValue)
-		{
+        }
+        if (NetCache.Get().GetArcaneDustBalance() < buyValue)
+        {
 			return CanCraftCardResult.NotEnoughDust;
-		}
-		if (RankMgr.Get().IsCardLockedInCurrentLeague(entityDef))
-		{
+        }
+        if (RankMgr.Get().IsCardLockedInCurrentLeague(entityDef))
+        {
 			return CanCraftCardResult.CardLockedInCurrentLeague;
-		}
+        }
 		return CanCraftCardResult.CanCraft;
-	}
-
-	public bool TryGetCardBuyValue(string cardID, TAG_PREMIUM premium, out int buyValue)
-	{
-		NetCache.CardValue cardValue = GetCardValue(cardID, premium);
-		if (cardValue == null)
-		{
-			buyValue = 0;
-			return false;
-		}
-		if (GetNumClientTransactions() >= 0)
-		{
-			buyValue = cardValue.GetBuyValue();
-			return true;
-		}
-		buyValue = cardValue.GetSellValue();
-		return true;
-	}
-
-	public bool TryGetCardSellValue(string cardID, TAG_PREMIUM premium, out int sellValue)
-	{
-		NetCache.CardValue cardValue = GetCardValue(cardID, premium);
-		if (cardValue == null)
-		{
-			sellValue = 0;
-			return false;
-		}
-		if (GetNumClientTransactions() <= 0)
-		{
-			sellValue = cardValue.GetSellValue();
-			return true;
-		}
-		sellValue = cardValue.GetBuyValue();
-		return true;
-	}
-
-	public bool TryGetCardUpgradeValue(string cardID, out int upgradeValue)
-	{
-		NetCache.CardValue cardValue = GetCardValue(cardID, TAG_PREMIUM.NORMAL);
-		if (cardValue == null)
-		{
-			upgradeValue = 0;
-			return false;
-		}
-		upgradeValue = cardValue.GetUpgradeValue();
-		return true;
-	}
-
-	public bool IsCardShowing()
-	{
-		return m_currentBigActor != null;
-	}
-
-	public static bool GetIsInCraftingMode()
-	{
-		if (s_instance != null)
-		{
-			return s_instance.IsInCraftingMode;
-		}
-		return false;
-	}
-
-	public bool GetShownCardInfo(out EntityDef entityDef, out TAG_PREMIUM premium)
-	{
-		entityDef = null;
-		premium = TAG_PREMIUM.NORMAL;
-		if (m_currentBigActor == null)
-		{
-			return false;
-		}
-		entityDef = m_currentBigActor.GetEntityDef();
-		premium = m_currentBigActor.GetPremium();
-		if (entityDef == null)
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public Actor GetShownActor()
-	{
-		return m_currentBigActor;
-	}
-
-	public void OnMassDisenchant(int amount)
-	{
-		if (!MassDisenchant.Get())
-		{
-			m_craftingUI.UpdateBankText();
-		}
-	}
-
-	public long GetUnCommitedArcaneDustChanges()
-	{
-		return m_unCommitedArcaneDustAdjustments;
-	}
-
-	public void AdjustUnCommitedArcaneDustChanges(int amount)
-	{
-		m_unCommitedArcaneDustAdjustments += amount;
-	}
-
-	public void ResetUnCommitedArcaneDustChanges()
-	{
-		m_unCommitedArcaneDustAdjustments = 0L;
-	}
-
-	public int GetNumClientTransactions()
-	{
-		if (m_pendingClientTransaction == null)
-		{
-			return 0;
-		}
-		return m_pendingClientTransaction.GetTransactionAmount(GetShownActor().GetPremium());
-	}
-
-	public void NotifyOfTransaction(int amt)
-	{
-		if (m_pendingClientTransaction == null)
-		{
-			return;
-		}
-		if (amt > 0)
-		{
-			if (GetPendingClientTransaction().GetLastTransactionWasDisenchant())
-			{
-				GetPendingClientTransaction().Undo();
-				return;
-			}
-			if (m_craftingUI.m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.Create)
-			{
-				if (GetShownActor().GetPremium() == TAG_PREMIUM.NORMAL)
-				{
-					GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.NormalCreate);
-				}
-				else if (GetShownActor().GetPremium() == TAG_PREMIUM.GOLDEN)
-				{
-					GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.GoldenCreate);
-				}
-			}
-			else if (m_craftingUI.m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.Upgrade)
-			{
-				GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.UpgradeToGoldenFromNormal);
-				SwitchPremiumView(TAG_PREMIUM.GOLDEN);
-			}
-		}
-		if (amt < 0)
-		{
-			if (GetPendingClientTransaction().GetLastTransactionWasCrafting())
-			{
-				GetPendingClientTransaction().Undo();
-			}
-			else if (GetShownActor().GetPremium() == TAG_PREMIUM.NORMAL)
-			{
-				GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.NormalDisenchant);
-			}
-			else if (GetShownActor().GetPremium() == TAG_PREMIUM.GOLDEN)
-			{
-				GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.GoldenDisenchant);
-			}
+    }
+
+    public bool TryGetCardBuyValue(string cardID, TAG_PREMIUM premium, out int buyValue)
+    {
+        NetCache.CardValue cardValue = GetCardValue(cardID, premium);
+        if (cardValue == null)
+        {
+            buyValue = 0;
+            return false;
+        }
+        if (GetNumClientTransactions() >= 0)
+        {
+            buyValue = cardValue.GetBuyValue();
+            return true;
+        }
+        buyValue = cardValue.GetSellValue();
+        return true;
+    }
+
+    public bool TryGetCardSellValue(string cardID, TAG_PREMIUM premium, out int sellValue)
+    {
+        NetCache.CardValue cardValue = GetCardValue(cardID, premium);
+        if (cardValue == null)
+        {
+            sellValue = 0;
+            return false;
+        }
+        if (GetNumClientTransactions() <= 0)
+        {
+            sellValue = cardValue.GetSellValue();
+            return true;
+        }
+        sellValue = cardValue.GetBuyValue();
+        return true;
+    }
+
+    public bool TryGetCardUpgradeValue(string cardID, out int upgradeValue)
+    {
+        NetCache.CardValue cardValue = GetCardValue(cardID, TAG_PREMIUM.NORMAL);
+        if (cardValue == null)
+        {
+            upgradeValue = 0;
+            return false;
+        }
+        upgradeValue = cardValue.GetUpgradeValue();
+        return true;
+    }
+
+    public bool IsCardShowing()
+    {
+        return m_currentBigActor != null;
+    }
+
+    public static bool GetIsInCraftingMode()
+    {
+        if (s_instance != null)
+        {
+            return s_instance.IsInCraftingMode;
+        }
+        return false;
+    }
+
+    public bool GetShownCardInfo(out EntityDef entityDef, out TAG_PREMIUM premium)
+    {
+        entityDef = null;
+        premium = TAG_PREMIUM.NORMAL;
+        if (m_currentBigActor == null)
+        {
+            return false;
+        }
+        entityDef = m_currentBigActor.GetEntityDef();
+        premium = m_currentBigActor.GetPremium();
+        if (entityDef == null)
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public Actor GetShownActor()
+    {
+        return m_currentBigActor;
+    }
+
+    public void OnMassDisenchant(int amount)
+    {
+        if (!MassDisenchant.Get())
+        {
+            m_craftingUI.UpdateBankText();
+        }
+    }
+
+    public long GetUnCommitedArcaneDustChanges()
+    {
+        return m_unCommitedArcaneDustAdjustments;
+    }
+
+    public void AdjustUnCommitedArcaneDustChanges(int amount)
+    {
+        m_unCommitedArcaneDustAdjustments += amount;
+    }
+
+    public void ResetUnCommitedArcaneDustChanges()
+    {
+        m_unCommitedArcaneDustAdjustments = 0L;
+    }
+
+    public int GetNumClientTransactions()
+    {
+        if (m_pendingClientTransaction == null)
+        {
+            return 0;
+        }
+        return m_pendingClientTransaction.GetTransactionAmount(GetShownActor().GetPremium());
+    }
+
+    public void NotifyOfTransaction(int amt)
+    {
+        if (m_pendingClientTransaction == null)
+        {
+            return;
+        }
+        if (amt > 0)
+        {
+            if (GetPendingClientTransaction().GetLastTransactionWasDisenchant())
+            {
+                GetPendingClientTransaction().Undo();
+                return;
+            }
+            if (m_craftingUI.m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.Create)
+            {
+                if (GetShownActor().GetPremium() == TAG_PREMIUM.NORMAL)
+                {
+                    GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.NormalCreate);
+                }
+                else if (GetShownActor().GetPremium() == TAG_PREMIUM.GOLDEN)
+                {
+                    GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.GoldenCreate);
+                }
+            }
+            else if (m_craftingUI.m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.Upgrade)
+            {
+                GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.UpgradeToGoldenFromNormal);
+                SwitchPremiumView(TAG_PREMIUM.GOLDEN);
+            }
+        }
+        if (amt < 0)
+        {
+            if (GetPendingClientTransaction().GetLastTransactionWasCrafting())
+            {
+                GetPendingClientTransaction().Undo();
+            }
+            else if (GetShownActor().GetPremium() == TAG_PREMIUM.NORMAL)
+            {
+                GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.NormalDisenchant);
+            }
+            else if (GetShownActor().GetPremium() == TAG_PREMIUM.GOLDEN)
+            {
+                GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.GoldenDisenchant);
+            }
 			else if (GetShownActor().GetPremium() == TAG_PREMIUM.SIGNATURE)
 			{
 				GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.SignatureDisenchant);
@@ -665,859 +668,866 @@ public class CraftingManager : MonoBehaviour
 			{
 				GetPendingClientTransaction().Add(CraftingPendingTransaction.Operation.DiamondDisenchant);
 			}
-		}
-	}
-
-	public bool IsCancelling()
-	{
-		return m_cancellingCraftMode;
-	}
+        }
+    }
+
+    public bool IsCancelling()
+    {
+        return m_cancellingCraftMode;
+    }
+
+    private Actor CreateActorCopy(Actor actor, TAG_PREMIUM premium)
+    {
+        string heroSkinOrHandActor = ActorNames.GetHeroSkinOrHandActor(actor.GetEntityDef(), premium);
+        Actor component = AssetLoader.Get().InstantiatePrefab(heroSkinOrHandActor, AssetLoadingOptions.IgnorePrefabPosition).GetComponent<Actor>();
+        component.SetFullDefFromActor(actor);
+        component.SetEntity(actor.GetEntity());
+        component.SetPremium(premium);
+        component.UpdateAllComponents();
+        return component;
+    }
+
+    public void EnterCraftMode(Actor collectionCardActor, Action callback = null)
+    {
+        m_collectionCardActor = collectionCardActor;
+        if (m_collectionCardActor == null)
+        {
+            return;
+        }
+        m_cardActors = new CollectionCardActors();
+        switch (collectionCardActor.GetPremium())
+        {
+            case TAG_PREMIUM.DIAMOND:
+                m_cardActors.AddCardActor(CreateActorCopy(collectionCardActor, TAG_PREMIUM.DIAMOND));
+                break;
+            case TAG_PREMIUM.SIGNATURE:
+                m_cardActors.AddCardActor(CreateActorCopy(collectionCardActor, TAG_PREMIUM.SIGNATURE));
+                break;
+            default:
+                m_cardActors.AddCardActor(CreateActorCopy(collectionCardActor, TAG_PREMIUM.NORMAL));
+                m_cardActors.AddCardActor(CreateActorCopy(collectionCardActor, TAG_PREMIUM.GOLDEN));
+                break;
+        }
+        if (m_cancellingCraftMode || CollectionDeckTray.Get().IsWaitingToDeleteDeck())
+        {
+            return;
+        }
+        CollectionManager.Get().GetCollectibleDisplay().HideAllTips();
+        m_offClickCatcher.enabled = true;
+        TooltipPanelManager.Get().HideKeywordHelp();
+        SetupActor(m_collectionCardActor, m_collectionCardActor.GetPremium());
+        if (m_cardInfoPane == null && !UniversalInputManager.UsePhoneUI)
+        {
+            GameObject gameObject = AssetLoader.Get().InstantiatePrefab("CardInfoPane.prefab:b9220edd61d504be38fab162c18e56f1");
+            m_cardInfoPane = gameObject.GetComponent<CardInfoPane>();
+        }
+        if (m_cardInfoPane != null)
+        {
+            m_cardInfoPane.UpdateContent();
+        }
+        if (m_craftingUI == null)
+        {
+            string text = (UniversalInputManager.UsePhoneUI ? "CraftingUI_Phone.prefab:3119329ada4ac4a8888187b5b2d373f5" : "CraftingUI.prefab:ef05b5bf5ebb14a22919f0095d75f0b2");
+            GameObject gameObject2 = AssetLoader.Get().InstantiatePrefab(text);
+            m_craftingUI = gameObject2.GetComponent<CraftingUI>();
+            m_craftingUI.SetStartingActive();
+            GameUtils.SetParent(m_craftingUI, m_showCraftingUIBone.gameObject);
+        }
+        m_craftingUI.gameObject.SetActive(value: true);
+        m_switchPremiumButton.gameObject.SetActive(value: false);
+        m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
+        if (m_upgradeToGoldenWidget == null)
+        {
+            m_upgradeToGoldenWidget = WidgetInstance.Create(UPGRADE_TO_GOLDEN_WIDGET_PREFAB);
+            m_upgradeToGoldenWidget.Hide();
+            m_upgradeToGoldenWidget.RegisterReadyListener(delegate
+            {
+                GameUtils.SetParent(m_upgradeToGoldenWidget, m_showCraftingUIBone.gameObject);
+            });
+        }
+        m_upgradeToGoldenWidget.Hide();
+        FadeEffectsIn();
+        UpdateCardInfoPane();
+        ShowLeagueLockedCardPopup();
+        IsInCraftingMode = true;
+        Navigation.Push(delegate
+        {
+            bool result = CancelCraftMode();
+            if (callback != null)
+            {
+                callback();
+            }
+            return result;
+        });
+
+        AccessibleCollectionManager.Get().OnEnterCraftMode(m_collectionCardActor.GetEntityDef(), m_collectionCardActor.GetPremium(), m_cardInfoPane, m_craftingUI);
+    }
+
+    private void SetupActor(Actor collectionCardActor, TAG_PREMIUM premium)
+    {
+        if (m_upsideDownActor != null)
+        {
+            UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
+        }
+        if (m_currentBigActor != null)
+        {
+            UnityEngine.Object.Destroy(m_currentBigActor.gameObject);
+        }
+		Debug.Log("setting up actor " + collectionCardActor.GetEntityDef()?.ToString() + " " + premium);
+        MoveCardToBigSpot(collectionCardActor, premium);
+        string cardId = collectionCardActor.GetEntityDef().GetCardId();
+        m_pendingClientTransaction = new CraftingPendingTransaction();
+        if (GameUtils.IsClassicCard(cardId))
+        {
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+            m_pendingClientTransaction.CardID = GameUtils.TranslateDbIdToCardId(entityDef.GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
+        }
+        else
+        {
+            m_pendingClientTransaction.CardID = cardId;
+        }
+        m_pendingClientTransaction.Premium = premium;
+        m_pendingClientTransaction.ResetTransactionAmount();
+        NetCache.CardValue cardValue = GetCardValue(m_pendingClientTransaction.CardID, premium);
+        if (cardValue != null)
+        {
+            m_pendingClientTransaction.CardValueOverridden = cardValue.IsOverrideActive();
+        }
+        if (m_craftingUI != null)
+        {
+            m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
+        }
+    }
+
+    public bool CancelCraftMode()
+    {
+        if (m_upgradeToGoldenWidget != null && m_upgradeToGoldenWidgetShown)
+        {
+            HideUpgradeToGoldenWidget();
+            return false;
+        }
+        StopAllCoroutines();
+        m_offClickCatcher.enabled = false;
+        m_cancellingCraftMode = true;
+        Actor actor = m_upsideDownActor;
+        Actor actor2 = m_currentBigActor;
+        if (actor2 == null && actor != null)
+        {
+            actor2 = actor;
+            actor = null;
+        }
+        float num = 0.2f;
+        if (actor2 != null)
+        {
+            iTween.Stop(actor2.gameObject);
+            iTween.RotateTo(actor2.gameObject, Vector3.zero, num);
+            actor2.ToggleForceIdle(bOn: false);
+            if (actor != null)
+            {
+                iTween.Stop(actor.gameObject);
+                actor.transform.parent = actor2.transform;
+            }
+            SoundManager.Get().LoadAndPlay("Card_Transition_In.prefab:3f3fbe896b8b260448e8c7e5d028d971");
+			Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
+			tweenHashTable.Add("name", "CancelCraftMode");
+			tweenHashTable.Add("position", m_craftSourcePosition);
+			tweenHashTable.Add("time", num);
+			tweenHashTable.Add("oncomplete", "FinishActorMoveAway");
+			tweenHashTable.Add("oncompletetarget", base.gameObject);
+			tweenHashTable.Add("easetype", iTween.EaseType.linear);
+			iTween.MoveTo(actor2.gameObject, tweenHashTable);
+			Hashtable tweenHashTable2 = iTweenManager.Get().GetTweenHashTable();
+			tweenHashTable2.Add("scale", m_craftSourceScale);
+			tweenHashTable2.Add("time", num);
+			tweenHashTable2.Add("easetype", iTween.EaseType.linear);
+			iTween.ScaleTo(actor2.gameObject, tweenHashTable2);
+        }
+        iTween.Stop(m_cardCountTab.gameObject);
+        if (GetNumOwnedIncludePending() > 0)
+        {
+			Hashtable tweenHashTable3 = iTweenManager.Get().GetTweenHashTable();
+			tweenHashTable3.Add("position", m_craftSourcePosition - new Vector3(0f, 12f, 0f));
+			tweenHashTable3.Add("time", 3f * num);
+			tweenHashTable3.Add("oncomplete", iTween.EaseType.easeInQuad);
+			iTween.MoveTo(m_cardCountTab.gameObject, tweenHashTable3);
+			Hashtable tweenHashTable4 = iTweenManager.Get().GetTweenHashTable();
+			tweenHashTable4.Add("scale", 0.1f * Vector3.one);
+			tweenHashTable4.Add("time", 3f * num);
+			tweenHashTable4.Add("oncomplete", iTween.EaseType.easeInQuad);
+			iTween.ScaleTo(m_cardCountTab.gameObject, tweenHashTable4);
+        }
+        if (actor != null)
+        {
+            iTween.RotateTo(actor.gameObject, new Vector3(0f, 359f, 180f), num);
+			Hashtable tweenHashTable5 = iTweenManager.Get().GetTweenHashTable();
+			tweenHashTable5.Add("name", "CancelCraftMode2");
+			tweenHashTable5.Add("position", new Vector3(0f, -1f, 0f));
+			tweenHashTable5.Add("time", num);
+			tweenHashTable5.Add("islocal", true);
+			iTween.MoveTo(actor.gameObject, tweenHashTable5);
+            iTween.ScaleTo(actor.gameObject, new Vector3(actor.transform.localScale.x * 0.8f, actor.transform.localScale.y * 0.8f, actor.transform.localScale.z * 0.8f), num);
+        }
+		HideAndDestroyRelatedInfo();
+        if (m_craftingUI != null && m_craftingUI.IsEnabled())
+        {
+            m_craftingUI.Disable(m_hideCraftingUIBone.position);
+        }
+        m_cardCountTab.m_shadow.GetComponent<Animation>().Play("Crafting2ndCardShadowOff");
+        FadeEffectsOut();
+        if (m_cardInfoPane != null)
+        {
+            iTween.Stop(m_cardInfoPane.gameObject);
+            m_cardInfoPane.gameObject.SetActive(value: false);
+        }
+        if (m_upgradeToGoldenWidget != null)
+        {
+            m_upgradeToGoldenWidget.Hide();
+            m_upgradeToGoldenWidget.gameObject.SetActive(value: false);
+        }
+        iTween.ScaleTo(m_switchPremiumButton.gameObject, m_cardCountTabHideScale, 0.4f);
+        TellServerAboutWhatUserDid();
+        IsInCraftingMode = false;
+        AccessibleCollectionManager.Get().OnCancelCraftMode(m_cardInfoPane, m_craftingUI);
+        return true;
+    }
+
+    public void CreateButtonPressed()
+    {
+		HideAndDestroyRelatedInfo();
+        if (m_craftingUI.m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.CreateUpgrade)
+        {
+            ShowUpgradeToGoldenWidget();
+        }
+        else if (m_craftingUI.m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.Upgrade)
+        {
+            if (!GameUtils.IsGSDFlagSet(GameSaveKeyId.COLLECTION_MANAGER, GameSaveKeySubkeyId.COLLECTION_MANAGER_SEEN_UTG_ALERT))
+            {
+                AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+                popupInfo.m_offset = m_utgAlertPopupOffset;
+                popupInfo.m_headerText = GameStrings.Format("GLUE_CRAFTING_UTG_ALERT_HEADER");
+                popupInfo.m_text = GameStrings.Format("GLUE_CRAFTING_UTG_ALERT_BODY");
+                popupInfo.m_confirmText = GameStrings.Format("GLUE_CRAFTING_UTG_ALERT_CONFIRM");
+                popupInfo.m_cancelText = GameStrings.Format("GLUE_CRAFTING_UTG_ALERT_CANCEL");
+                popupInfo.m_showAlertIcon = false;
+                popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL;
+                popupInfo.m_alertTextAlignment = UberText.AlignmentOptions.Center;
+				AlertPopup.ResponseCallback responseCallback = delegate(AlertPopup.Response response, object userdata)
+                {
+                    GameUtils.SetGSDFlag(GameSaveKeyId.COLLECTION_MANAGER, GameSaveKeySubkeyId.COLLECTION_MANAGER_SEEN_UTG_ALERT, enableFlag: true);
+                    SetCraftingRelatedActorsActiveForUpgradeToGoldenPopup(active: true);
+                    if (response == AlertPopup.Response.CONFIRM)
+                    {
+                        m_craftingUI.DoCreate(isUpgrade: true);
+                    }
+				};
+				popupInfo.m_responseCallback = responseCallback;
+                SetCraftingRelatedActorsActiveForUpgradeToGoldenPopup(active: false);
+                DialogManager.Get().ShowPopup(popupInfo);
+            }
+            else
+            {
+                m_craftingUI.DoCreate(isUpgrade: true);
+            }
+        }
+        else
+        {
+            m_craftingUI.DoCreate(isUpgrade: false);
+        }
+    }
+
+    public void DisenchantButtonPressed()
+    {
+		HideAndDestroyRelatedInfo();
+        m_craftingUI.DoDisenchant();
+    }
+
+    public void UpdateBankText()
+    {
+        if (m_craftingUI != null)
+        {
+            m_craftingUI.UpdateBankText();
+        }
+    }
+
+    private void TellServerAboutWhatUserDid()
+    {
+        if (GetCurrentActor() == null)
+        {
+            return;
+        }
+        string cardID = m_pendingClientTransaction.CardID;
+        TAG_PREMIUM premium = m_pendingClientTransaction.Premium;
+        GameUtils.TranslateCardIdToDbId(cardID);
+        if (m_pendingClientTransaction.HasPendingTransactions())
+        {
+            m_pendingServerTransaction = m_pendingClientTransaction.ShallowCopy();
+        }
+        int numCopiesInCollection = CollectionManager.Get().GetNumCopiesInCollection(cardID, TAG_PREMIUM.NORMAL);
+        int numCopiesInCollection2 = CollectionManager.Get().GetNumCopiesInCollection(cardID, TAG_PREMIUM.GOLDEN);
+		int numCopiesInCollection3 = CollectionManager.Get().GetNumCopiesInCollection(cardID, TAG_PREMIUM.SIGNATURE);
+		int numCopiesInCollection4 = CollectionManager.Get().GetNumCopiesInCollection(cardID, TAG_PREMIUM.DIAMOND);
+        NetCache.CardValue cardValue = GetCardValue(cardID, premium);
+        if (cardValue == null)
+        {
+            return;
+        }
+        if (cardValue.IsOverrideActive() == m_pendingClientTransaction.CardValueOverridden)
+        {
+            if (m_pendingClientTransaction.HasPendingTransactions())
+            {
+				int expectedTransactionCost = m_pendingClientTransaction.GetExpectedTransactionCost(cardID);
+				Network.Get().CraftingTransaction(m_pendingClientTransaction, expectedTransactionCost, numCopiesInCollection, numCopiesInCollection2, numCopiesInCollection3, numCopiesInCollection4);
+            }
+        }
+        else
+        {
+            OnCardValueChangedError(null);
+        }
+        m_pendingClientTransaction = null;
+        ResetUnCommitedArcaneDustChanges();
+        BnetBar.Get().RefreshCurrency();
+    }
+
+    public void OnCardGenericError(Network.CardSaleResult sale)
+    {
+        m_pendingServerTransaction = null;
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+        popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
+        popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_GENERIC_ERROR");
+        popupInfo.m_showAlertIcon = true;
+        popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    public void OnCardPermissionError(Network.CardSaleResult sale)
+    {
+        m_pendingServerTransaction = null;
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+        popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
+        popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_CARD_PERMISSION_ERROR");
+        popupInfo.m_showAlertIcon = true;
+        popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    public void OnCardDisenchantSoulboundError(Network.CardSaleResult sale)
+    {
+        m_pendingServerTransaction = null;
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+        popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
+        popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_CARD_SOULBOUND");
+        popupInfo.m_showAlertIcon = true;
+        popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    public void OnCardCountError(Network.CardSaleResult sale)
+    {
+        m_pendingServerTransaction = null;
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+        popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
+        popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_GENERIC_ERROR");
+        popupInfo.m_showAlertIcon = true;
+        popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    public void OnCardCraftingEventNotActiveError(Network.CardSaleResult sale)
+    {
+        m_pendingServerTransaction = null;
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+        popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
+        popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_CARD_CRAFTING_EVENT_NOT_ACTIVE");
+        popupInfo.m_showAlertIcon = true;
+        popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    public void OnCardUnknownError(Network.CardSaleResult sale)
+    {
+        m_pendingServerTransaction = null;
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+        popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
+        popupInfo.m_text = GameStrings.Format("GLUE_COLLECTION_CARD_UNKNOWN_ERROR", sale.Action);
+        popupInfo.m_showAlertIcon = true;
+        popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    public void OnCardValueChangedError(Network.CardSaleResult sale)
+    {
+        m_pendingServerTransaction = null;
+        AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+        popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
+        popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_CARD_VALUE_CHANGED_ERROR");
+        popupInfo.m_showAlertIcon = true;
+        popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+        DialogManager.Get().ShowPopup(popupInfo);
+    }
+
+    public void OnCardDisenchanted(Network.CardSaleResult sale)
+    {
+        AccessibleCollectionManager.Get().OnCardDisenchanted();
+
+        m_pendingServerTransaction = null;
+        CollectionCardVisual cardVisual = CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
+            .GetCardVisual(sale.AssetName, sale.Premium);
+        if (cardVisual != null && cardVisual.IsShown())
+        {
+            cardVisual.OnDoneCrafting();
+        }
+    }
+
+    public void OnCardCreated(Network.CardSaleResult sale)
+    {
+        AccessibleCollectionManager.Get().OnCardCreated();
+
+        m_pendingServerTransaction = null;
+        CollectionCardVisual cardVisual = CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
+            .GetCardVisual(sale.AssetName, sale.Premium);
+        if (!(cardVisual != null) || !cardVisual.IsShown())
+        {
+            return;
+        }
+        cardVisual.OnDoneCrafting();
+        if (TemporaryAccountManager.IsTemporaryAccount() && cardVisual.GetActor() != null && sale.Action == Network.CardSaleResult.SaleResult.CARD_WAS_BOUGHT)
+        {
+            EntityDef entityDef = cardVisual.GetActor().GetEntityDef();
+            if (entityDef != null && (entityDef.GetRarity() == TAG_RARITY.EPIC || entityDef.GetRarity() == TAG_RARITY.LEGENDARY))
+            {
+                TemporaryAccountManager.Get().ShowEarnCardEventHealUpDialog(TemporaryAccountManager.HealUpReason.CRAFT_CARD);
+            }
+        }
+    }
+
+    public void OnCardUpgraded(Network.CardSaleResult result)
+    {
+        m_pendingServerTransaction = null;
+        CollectiblePageManager pageManager = CollectionManager.Get().GetCollectibleDisplay().GetPageManager();
+        CollectionCardVisual cardVisual = pageManager.GetCardVisual(result.AssetName, TAG_PREMIUM.NORMAL);
+        if (cardVisual != null && cardVisual.IsShown())
+        {
+            cardVisual.OnDoneCrafting();
+        }
+        CollectionCardVisual cardVisual2 = pageManager.GetCardVisual(result.AssetName, TAG_PREMIUM.GOLDEN);
+        if (cardVisual2 != null && cardVisual2.IsShown())
+        {
+            cardVisual2.OnDoneCrafting();
+        }
+    }
+
+    public void LoadGhostActorIfNecessary()
+    {
+        if (m_cancellingCraftMode)
+        {
+            return;
+        }
+        if (GetNumOwnedIncludePending() > 0)
+        {
+            if (m_upsideDownActor == null)
+            {
+                m_currentBigActor = GetAndPositionNewActor(m_currentBigActor, 1);
+                m_currentBigActor.name = "CurrentBigActor";
+                m_currentBigActor.transform.position = m_floatingCardBone.position;
+                m_currentBigActor.transform.localScale = m_floatingCardBone.localScale;
+                SetBigActorLayer(inCraftingMode: true);
+            }
+            else
+            {
+                m_upsideDownActor.transform.parent = null;
+                m_currentBigActor = m_upsideDownActor;
+                m_currentBigActor.name = "CurrentBigActor";
+                m_currentBigActor.transform.position = m_faceDownCardBone.position;
+                m_currentBigActor.transform.localScale = m_faceDownCardBone.localScale;
+                m_upsideDownActor = null;
+            }
+        }
+        else
+        {
+            if (m_upsideDownActor != null)
+            {
+                Log.Crafting.Print("Deleting rogue m_upsideDownActor!");
+                UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
+            }
+            m_currentBigActor = GetAndPositionNewActor(m_currentBigActor, 0);
+            m_currentBigActor.name = "CurrentBigActor";
+            m_currentBigActor.transform.position = m_floatingCardBone.position;
+            m_currentBigActor.transform.localScale = m_floatingCardBone.localScale;
+            iTween.ScaleTo(m_cardCountTab.gameObject, m_cardCountTabHideScale, 0.4f);
+            m_cardCountTab.transform.position = new Vector3(0f, 307f, -10f);
+            SetBigActorLayer(inCraftingMode: true);
+        }
+    }
+
+    public Actor LoadNewActorAndConstructIt()
+    {
+        if (m_cancellingCraftMode)
+        {
+            return null;
+        }
+        if (!m_isCurrentActorAGhost)
+        {
+            if (m_currentBigActor == null)
+            {
+                m_currentBigActor = GetAndPositionNewActor(m_upsideDownActor, 0);
+            }
+            else
+            {
+                Actor currentBigActor = m_currentBigActor;
+                m_currentBigActor = GetAndPositionNewActor(m_currentBigActor, 0);
+                Debug.LogWarning("Destroying unexpected m_currentBigActor to prevent a lost reference");
+                UnityEngine.Object.Destroy(currentBigActor.gameObject);
+            }
+            m_isCurrentActorAGhost = false;
+            m_currentBigActor.name = "CurrentBigActor";
+            m_currentBigActor.transform.position = m_floatingCardBone.position;
+            m_currentBigActor.transform.localScale = m_floatingCardBone.localScale;
+            SetBigActorLayer(inCraftingMode: true);
+        }
+        SpellType spellType = SpellType.CONSTRUCT;
+        EntityDef entityDef = m_collectionCardActor.GetEntityDef();
+        if (entityDef != null && entityDef.HasClass(TAG_CLASS.DEATHKNIGHT) && entityDef.HasRuneCost)
+        {
+            spellType = SpellType.DEATH_KNIGHT_CONSTRUCT;
+        }
+        m_currentBigActor.ActivateSpellBirthState(spellType);
+        return m_currentBigActor;
+    }
+
+    public void ForceNonGhostFlagOn()
+    {
+        m_isCurrentActorAGhost = false;
+    }
 
-	private Actor CreateActorCopy(Actor actor, TAG_PREMIUM premium)
-	{
-		string heroSkinOrHandActor = ActorNames.GetHeroSkinOrHandActor(actor.GetEntityDef(), premium);
-		Actor component = AssetLoader.Get().InstantiatePrefab(heroSkinOrHandActor, AssetLoadingOptions.IgnorePrefabPosition).GetComponent<Actor>();
-		component.SetFullDefFromActor(actor);
-		component.SetEntity(actor.GetEntity());
-		component.SetPremium(premium);
-		component.UpdateAllComponents();
-		return component;
+	public void FinishCreateAnims(bool showRelatedCards = true)
+    {
+        if (!(m_currentBigActor == null) && !m_cancellingCraftMode)
+        {
+            iTween.ScaleTo(m_cardCountTab.gameObject, m_cardCountTabShowScale, 0.4f);
+            m_currentBigActor.GetSpell(SpellType.GHOSTMODE).GetComponent<PlayMakerFSM>().SendEvent("Cancel");
+            m_isCurrentActorAGhost = false;
+            int numOwnedIncludePending = GetNumOwnedIncludePending();
+            m_cardCountTab.UpdateText(numOwnedIncludePending, m_currentBigActor.GetPremium());
+            m_cardCountTab.transform.position = GetCardCountPosition();
+			if (showRelatedCards)
+			{
+			ShowRelatedInfo(m_currentBigActor.GetPremium());
+        }
+    }
 	}
 
-	public void EnterCraftMode(Actor collectionCardActor, Action callback = null)
-	{
-		m_collectionCardActor = collectionCardActor;
-		if (m_collectionCardActor == null)
-		{
-			return;
-		}
-		m_cardActors = new CollectionCardActors();
-		switch (collectionCardActor.GetPremium())
-		{
-		case TAG_PREMIUM.DIAMOND:
-			m_cardActors.AddCardActor(CreateActorCopy(collectionCardActor, TAG_PREMIUM.DIAMOND));
-			break;
-		case TAG_PREMIUM.SIGNATURE:
-			m_cardActors.AddCardActor(CreateActorCopy(collectionCardActor, TAG_PREMIUM.SIGNATURE));
-			break;
-		default:
-			m_cardActors.AddCardActor(CreateActorCopy(collectionCardActor, TAG_PREMIUM.NORMAL));
-			m_cardActors.AddCardActor(CreateActorCopy(collectionCardActor, TAG_PREMIUM.GOLDEN));
-			break;
-		}
-		if (m_cancellingCraftMode || CollectionDeckTray.Get().IsWaitingToDeleteDeck())
-		{
-			return;
-		}
-		CollectionManager.Get().GetCollectibleDisplay().HideAllTips();
-		m_offClickCatcher.enabled = true;
-		TooltipPanelManager.Get().HideKeywordHelp();
-		SetupActor(m_collectionCardActor, m_collectionCardActor.GetPremium());
-		if (m_cardInfoPane == null && !UniversalInputManager.UsePhoneUI)
-		{
-			GameObject gameObject = AssetLoader.Get().InstantiatePrefab("CardInfoPane.prefab:b9220edd61d504be38fab162c18e56f1");
-			m_cardInfoPane = gameObject.GetComponent<CardInfoPane>();
-		}
-		if (m_cardInfoPane != null)
-		{
-			m_cardInfoPane.UpdateContent();
-		}
-		if (m_craftingUI == null)
-		{
-			string text = (UniversalInputManager.UsePhoneUI ? "CraftingUI_Phone.prefab:3119329ada4ac4a8888187b5b2d373f5" : "CraftingUI.prefab:ef05b5bf5ebb14a22919f0095d75f0b2");
-			GameObject gameObject2 = AssetLoader.Get().InstantiatePrefab(text);
-			m_craftingUI = gameObject2.GetComponent<CraftingUI>();
-			m_craftingUI.SetStartingActive();
-			GameUtils.SetParent(m_craftingUI, m_showCraftingUIBone.gameObject);
-		}
-		m_craftingUI.gameObject.SetActive(value: true);
-		m_switchPremiumButton.gameObject.SetActive(value: false);
-		m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
-		if (m_upgradeToGoldenWidget == null)
-		{
-			m_upgradeToGoldenWidget = WidgetInstance.Create(UPGRADE_TO_GOLDEN_WIDGET_PREFAB);
-			m_upgradeToGoldenWidget.Hide();
-			m_upgradeToGoldenWidget.RegisterReadyListener(delegate
-			{
-				GameUtils.SetParent(m_upgradeToGoldenWidget, m_showCraftingUIBone.gameObject);
-			});
-		}
-		m_upgradeToGoldenWidget.Hide();
-		FadeEffectsIn();
-		UpdateCardInfoPane();
-		ShowLeagueLockedCardPopup();
-		IsInCraftingMode = true;
-		Navigation.Push(delegate
-		{
-			bool result = CancelCraftMode();
-			if (callback != null)
-			{
-				callback();
-			}
-			return result;
-		});
-	}
-
-	private void SetupActor(Actor collectionCardActor, TAG_PREMIUM premium)
-	{
-		if (m_upsideDownActor != null)
-		{
-			UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
-		}
-		if (m_currentBigActor != null)
-		{
-			UnityEngine.Object.Destroy(m_currentBigActor.gameObject);
-		}
-		Debug.Log("setting up actor " + collectionCardActor.GetEntityDef()?.ToString() + " " + premium);
-		MoveCardToBigSpot(collectionCardActor, premium);
-		string cardId = collectionCardActor.GetEntityDef().GetCardId();
-		m_pendingClientTransaction = new CraftingPendingTransaction();
-		if (GameUtils.IsClassicCard(cardId))
-		{
-			EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
-			m_pendingClientTransaction.CardID = GameUtils.TranslateDbIdToCardId(entityDef.GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
-		}
-		else
-		{
-			m_pendingClientTransaction.CardID = cardId;
-		}
-		m_pendingClientTransaction.Premium = premium;
-		m_pendingClientTransaction.ResetTransactionAmount();
-		NetCache.CardValue cardValue = GetCardValue(m_pendingClientTransaction.CardID, premium);
-		if (cardValue != null)
-		{
-			m_pendingClientTransaction.CardValueOverridden = cardValue.IsOverrideActive();
-		}
-		if (m_craftingUI != null)
-		{
-			m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
-		}
-	}
-
-	public bool CancelCraftMode()
-	{
-		if (m_upgradeToGoldenWidget != null && m_upgradeToGoldenWidgetShown)
-		{
-			HideUpgradeToGoldenWidget();
-			return false;
-		}
-		StopAllCoroutines();
-		m_offClickCatcher.enabled = false;
-		m_cancellingCraftMode = true;
-		Actor actor = m_upsideDownActor;
-		Actor actor2 = m_currentBigActor;
-		if (actor2 == null && actor != null)
-		{
-			actor2 = actor;
-			actor = null;
-		}
-		float num = 0.2f;
-		if (actor2 != null)
-		{
-			iTween.Stop(actor2.gameObject);
-			iTween.RotateTo(actor2.gameObject, Vector3.zero, num);
-			actor2.ToggleForceIdle(bOn: false);
-			if (actor != null)
-			{
-				iTween.Stop(actor.gameObject);
-				actor.transform.parent = actor2.transform;
-			}
-			SoundManager.Get().LoadAndPlay("Card_Transition_In.prefab:3f3fbe896b8b260448e8c7e5d028d971");
-			Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
-			tweenHashTable.Add("name", "CancelCraftMode");
-			tweenHashTable.Add("position", m_craftSourcePosition);
-			tweenHashTable.Add("time", num);
-			tweenHashTable.Add("oncomplete", "FinishActorMoveAway");
-			tweenHashTable.Add("oncompletetarget", base.gameObject);
-			tweenHashTable.Add("easetype", iTween.EaseType.linear);
-			iTween.MoveTo(actor2.gameObject, tweenHashTable);
-			Hashtable tweenHashTable2 = iTweenManager.Get().GetTweenHashTable();
-			tweenHashTable2.Add("scale", m_craftSourceScale);
-			tweenHashTable2.Add("time", num);
-			tweenHashTable2.Add("easetype", iTween.EaseType.linear);
-			iTween.ScaleTo(actor2.gameObject, tweenHashTable2);
-		}
-		iTween.Stop(m_cardCountTab.gameObject);
-		if (GetNumOwnedIncludePending() > 0)
-		{
-			Hashtable tweenHashTable3 = iTweenManager.Get().GetTweenHashTable();
-			tweenHashTable3.Add("position", m_craftSourcePosition - new Vector3(0f, 12f, 0f));
-			tweenHashTable3.Add("time", 3f * num);
-			tweenHashTable3.Add("oncomplete", iTween.EaseType.easeInQuad);
-			iTween.MoveTo(m_cardCountTab.gameObject, tweenHashTable3);
-			Hashtable tweenHashTable4 = iTweenManager.Get().GetTweenHashTable();
-			tweenHashTable4.Add("scale", 0.1f * Vector3.one);
-			tweenHashTable4.Add("time", 3f * num);
-			tweenHashTable4.Add("oncomplete", iTween.EaseType.easeInQuad);
-			iTween.ScaleTo(m_cardCountTab.gameObject, tweenHashTable4);
-		}
-		if (actor != null)
-		{
-			iTween.RotateTo(actor.gameObject, new Vector3(0f, 359f, 180f), num);
-			Hashtable tweenHashTable5 = iTweenManager.Get().GetTweenHashTable();
-			tweenHashTable5.Add("name", "CancelCraftMode2");
-			tweenHashTable5.Add("position", new Vector3(0f, -1f, 0f));
-			tweenHashTable5.Add("time", num);
-			tweenHashTable5.Add("islocal", true);
-			iTween.MoveTo(actor.gameObject, tweenHashTable5);
-			iTween.ScaleTo(actor.gameObject, new Vector3(actor.transform.localScale.x * 0.8f, actor.transform.localScale.y * 0.8f, actor.transform.localScale.z * 0.8f), num);
-		}
-		HideAndDestroyRelatedInfo();
-		if (m_craftingUI != null && m_craftingUI.IsEnabled())
-		{
-			m_craftingUI.Disable(m_hideCraftingUIBone.position);
-		}
-		m_cardCountTab.m_shadow.GetComponent<Animation>().Play("Crafting2ndCardShadowOff");
-		FadeEffectsOut();
-		if (m_cardInfoPane != null)
-		{
-			iTween.Stop(m_cardInfoPane.gameObject);
-			m_cardInfoPane.gameObject.SetActive(value: false);
-		}
-		if (m_upgradeToGoldenWidget != null)
-		{
-			m_upgradeToGoldenWidget.Hide();
-			m_upgradeToGoldenWidget.gameObject.SetActive(value: false);
-		}
-		iTween.ScaleTo(m_switchPremiumButton.gameObject, m_cardCountTabHideScale, 0.4f);
-		TellServerAboutWhatUserDid();
-		IsInCraftingMode = false;
-		return true;
-	}
-
-	public void CreateButtonPressed()
-	{
-		HideAndDestroyRelatedInfo();
-		if (m_craftingUI.m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.CreateUpgrade)
-		{
-			ShowUpgradeToGoldenWidget();
-		}
-		else if (m_craftingUI.m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.Upgrade)
-		{
-			if (!GameUtils.IsGSDFlagSet(GameSaveKeyId.COLLECTION_MANAGER, GameSaveKeySubkeyId.COLLECTION_MANAGER_SEEN_UTG_ALERT))
-			{
-				AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-				popupInfo.m_offset = m_utgAlertPopupOffset;
-				popupInfo.m_headerText = GameStrings.Format("GLUE_CRAFTING_UTG_ALERT_HEADER");
-				popupInfo.m_text = GameStrings.Format("GLUE_CRAFTING_UTG_ALERT_BODY");
-				popupInfo.m_confirmText = GameStrings.Format("GLUE_CRAFTING_UTG_ALERT_CONFIRM");
-				popupInfo.m_cancelText = GameStrings.Format("GLUE_CRAFTING_UTG_ALERT_CANCEL");
-				popupInfo.m_showAlertIcon = false;
-				popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL;
-				popupInfo.m_alertTextAlignment = UberText.AlignmentOptions.Center;
-				AlertPopup.ResponseCallback responseCallback = delegate(AlertPopup.Response response, object userdata)
-				{
-					GameUtils.SetGSDFlag(GameSaveKeyId.COLLECTION_MANAGER, GameSaveKeySubkeyId.COLLECTION_MANAGER_SEEN_UTG_ALERT, enableFlag: true);
-					SetCraftingRelatedActorsActiveForUpgradeToGoldenPopup(active: true);
-					if (response == AlertPopup.Response.CONFIRM)
-					{
-						m_craftingUI.DoCreate(isUpgrade: true);
-					}
-				};
-				popupInfo.m_responseCallback = responseCallback;
-				SetCraftingRelatedActorsActiveForUpgradeToGoldenPopup(active: false);
-				DialogManager.Get().ShowPopup(popupInfo);
-			}
-			else
-			{
-				m_craftingUI.DoCreate(isUpgrade: true);
-			}
-		}
-		else
-		{
-			m_craftingUI.DoCreate(isUpgrade: false);
-		}
-	}
-
-	public void DisenchantButtonPressed()
-	{
-		HideAndDestroyRelatedInfo();
-		m_craftingUI.DoDisenchant();
-	}
-
-	public void UpdateBankText()
-	{
-		if (m_craftingUI != null)
-		{
-			m_craftingUI.UpdateBankText();
-		}
-	}
-
-	private void TellServerAboutWhatUserDid()
-	{
-		if (GetCurrentActor() == null)
-		{
-			return;
-		}
-		string cardID = m_pendingClientTransaction.CardID;
-		TAG_PREMIUM premium = m_pendingClientTransaction.Premium;
-		GameUtils.TranslateCardIdToDbId(cardID);
-		if (m_pendingClientTransaction.HasPendingTransactions())
-		{
-			m_pendingServerTransaction = m_pendingClientTransaction.ShallowCopy();
-		}
-		int numCopiesInCollection = CollectionManager.Get().GetNumCopiesInCollection(cardID, TAG_PREMIUM.NORMAL);
-		int numCopiesInCollection2 = CollectionManager.Get().GetNumCopiesInCollection(cardID, TAG_PREMIUM.GOLDEN);
-		int numCopiesInCollection3 = CollectionManager.Get().GetNumCopiesInCollection(cardID, TAG_PREMIUM.SIGNATURE);
-		int numCopiesInCollection4 = CollectionManager.Get().GetNumCopiesInCollection(cardID, TAG_PREMIUM.DIAMOND);
-		NetCache.CardValue cardValue = GetCardValue(cardID, premium);
-		if (cardValue == null)
-		{
-			return;
-		}
-		if (cardValue.IsOverrideActive() == m_pendingClientTransaction.CardValueOverridden)
-		{
-			if (m_pendingClientTransaction.HasPendingTransactions())
-			{
-				int expectedTransactionCost = m_pendingClientTransaction.GetExpectedTransactionCost(cardID);
-				Network.Get().CraftingTransaction(m_pendingClientTransaction, expectedTransactionCost, numCopiesInCollection, numCopiesInCollection2, numCopiesInCollection3, numCopiesInCollection4);
-			}
-		}
-		else
-		{
-			OnCardValueChangedError(null);
-		}
-		m_pendingClientTransaction = null;
-		ResetUnCommitedArcaneDustChanges();
-		BnetBar.Get().RefreshCurrency();
-	}
-
-	public void OnCardGenericError(Network.CardSaleResult sale)
-	{
-		m_pendingServerTransaction = null;
-		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-		popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
-		popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_GENERIC_ERROR");
-		popupInfo.m_showAlertIcon = true;
-		popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-		DialogManager.Get().ShowPopup(popupInfo);
-	}
-
-	public void OnCardPermissionError(Network.CardSaleResult sale)
-	{
-		m_pendingServerTransaction = null;
-		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-		popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
-		popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_CARD_PERMISSION_ERROR");
-		popupInfo.m_showAlertIcon = true;
-		popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-		DialogManager.Get().ShowPopup(popupInfo);
-	}
-
-	public void OnCardDisenchantSoulboundError(Network.CardSaleResult sale)
-	{
-		m_pendingServerTransaction = null;
-		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-		popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
-		popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_CARD_SOULBOUND");
-		popupInfo.m_showAlertIcon = true;
-		popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-		DialogManager.Get().ShowPopup(popupInfo);
-	}
-
-	public void OnCardCountError(Network.CardSaleResult sale)
-	{
-		m_pendingServerTransaction = null;
-		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-		popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
-		popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_GENERIC_ERROR");
-		popupInfo.m_showAlertIcon = true;
-		popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-		DialogManager.Get().ShowPopup(popupInfo);
-	}
-
-	public void OnCardCraftingEventNotActiveError(Network.CardSaleResult sale)
-	{
-		m_pendingServerTransaction = null;
-		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-		popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
-		popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_CARD_CRAFTING_EVENT_NOT_ACTIVE");
-		popupInfo.m_showAlertIcon = true;
-		popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-		DialogManager.Get().ShowPopup(popupInfo);
-	}
-
-	public void OnCardUnknownError(Network.CardSaleResult sale)
-	{
-		m_pendingServerTransaction = null;
-		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-		popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
-		popupInfo.m_text = GameStrings.Format("GLUE_COLLECTION_CARD_UNKNOWN_ERROR", sale.Action);
-		popupInfo.m_showAlertIcon = true;
-		popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-		DialogManager.Get().ShowPopup(popupInfo);
-	}
-
-	public void OnCardValueChangedError(Network.CardSaleResult sale)
-	{
-		m_pendingServerTransaction = null;
-		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-		popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_ERROR_HEADER");
-		popupInfo.m_text = GameStrings.Get("GLUE_COLLECTION_CARD_VALUE_CHANGED_ERROR");
-		popupInfo.m_showAlertIcon = true;
-		popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-		DialogManager.Get().ShowPopup(popupInfo);
-	}
-
-	public void OnCardDisenchanted(Network.CardSaleResult sale)
-	{
-		m_pendingServerTransaction = null;
-		CollectionCardVisual cardVisual = CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
-			.GetCardVisual(sale.AssetName, sale.Premium);
-		if (cardVisual != null && cardVisual.IsShown())
-		{
-			cardVisual.OnDoneCrafting();
-		}
-	}
-
-	public void OnCardCreated(Network.CardSaleResult sale)
-	{
-		m_pendingServerTransaction = null;
-		CollectionCardVisual cardVisual = CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
-			.GetCardVisual(sale.AssetName, sale.Premium);
-		if (!(cardVisual != null) || !cardVisual.IsShown())
-		{
-			return;
-		}
-		cardVisual.OnDoneCrafting();
-		if (TemporaryAccountManager.IsTemporaryAccount() && cardVisual.GetActor() != null && sale.Action == Network.CardSaleResult.SaleResult.CARD_WAS_BOUGHT)
-		{
-			EntityDef entityDef = cardVisual.GetActor().GetEntityDef();
-			if (entityDef != null && (entityDef.GetRarity() == TAG_RARITY.EPIC || entityDef.GetRarity() == TAG_RARITY.LEGENDARY))
-			{
-				TemporaryAccountManager.Get().ShowEarnCardEventHealUpDialog(TemporaryAccountManager.HealUpReason.CRAFT_CARD);
-			}
-		}
-	}
-
-	public void OnCardUpgraded(Network.CardSaleResult result)
-	{
-		m_pendingServerTransaction = null;
-		CollectiblePageManager pageManager = CollectionManager.Get().GetCollectibleDisplay().GetPageManager();
-		CollectionCardVisual cardVisual = pageManager.GetCardVisual(result.AssetName, TAG_PREMIUM.NORMAL);
-		if (cardVisual != null && cardVisual.IsShown())
-		{
-			cardVisual.OnDoneCrafting();
-		}
-		CollectionCardVisual cardVisual2 = pageManager.GetCardVisual(result.AssetName, TAG_PREMIUM.GOLDEN);
-		if (cardVisual2 != null && cardVisual2.IsShown())
-		{
-			cardVisual2.OnDoneCrafting();
-		}
-	}
-
-	public void LoadGhostActorIfNecessary()
-	{
-		if (m_cancellingCraftMode)
-		{
-			return;
-		}
-		if (GetNumOwnedIncludePending() > 0)
-		{
-			if (m_upsideDownActor == null)
-			{
-				m_currentBigActor = GetAndPositionNewActor(m_currentBigActor, 1);
-				m_currentBigActor.name = "CurrentBigActor";
-				m_currentBigActor.transform.position = m_floatingCardBone.position;
-				m_currentBigActor.transform.localScale = m_floatingCardBone.localScale;
-				SetBigActorLayer(inCraftingMode: true);
-			}
-			else
-			{
-				m_upsideDownActor.transform.parent = null;
-				m_currentBigActor = m_upsideDownActor;
-				m_currentBigActor.name = "CurrentBigActor";
-				m_currentBigActor.transform.position = m_faceDownCardBone.position;
-				m_currentBigActor.transform.localScale = m_faceDownCardBone.localScale;
-				m_upsideDownActor = null;
-			}
-		}
-		else
-		{
-			if (m_upsideDownActor != null)
-			{
-				Log.Crafting.Print("Deleting rogue m_upsideDownActor!");
-				UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
-			}
-			m_currentBigActor = GetAndPositionNewActor(m_currentBigActor, 0);
-			m_currentBigActor.name = "CurrentBigActor";
-			m_currentBigActor.transform.position = m_floatingCardBone.position;
-			m_currentBigActor.transform.localScale = m_floatingCardBone.localScale;
-			iTween.ScaleTo(m_cardCountTab.gameObject, m_cardCountTabHideScale, 0.4f);
-			m_cardCountTab.transform.position = new Vector3(0f, 307f, -10f);
-			SetBigActorLayer(inCraftingMode: true);
-		}
-	}
-
-	public Actor LoadNewActorAndConstructIt()
-	{
-		if (m_cancellingCraftMode)
-		{
-			return null;
-		}
-		if (!m_isCurrentActorAGhost)
-		{
-			if (m_currentBigActor == null)
-			{
-				m_currentBigActor = GetAndPositionNewActor(m_upsideDownActor, 0);
-			}
-			else
-			{
-				Actor currentBigActor = m_currentBigActor;
-				m_currentBigActor = GetAndPositionNewActor(m_currentBigActor, 0);
-				Debug.LogWarning("Destroying unexpected m_currentBigActor to prevent a lost reference");
-				UnityEngine.Object.Destroy(currentBigActor.gameObject);
-			}
-			m_isCurrentActorAGhost = false;
-			m_currentBigActor.name = "CurrentBigActor";
-			m_currentBigActor.transform.position = m_floatingCardBone.position;
-			m_currentBigActor.transform.localScale = m_floatingCardBone.localScale;
-			SetBigActorLayer(inCraftingMode: true);
-		}
-		SpellType spellType = SpellType.CONSTRUCT;
-		EntityDef entityDef = m_collectionCardActor.GetEntityDef();
-		if (entityDef != null && entityDef.HasClass(TAG_CLASS.DEATHKNIGHT) && entityDef.HasRuneCost)
-		{
-			spellType = SpellType.DEATH_KNIGHT_CONSTRUCT;
-		}
-		m_currentBigActor.ActivateSpellBirthState(spellType);
-		return m_currentBigActor;
-	}
-
-	public void ForceNonGhostFlagOn()
-	{
-		m_isCurrentActorAGhost = false;
-	}
-
-	public void FinishCreateAnims(bool showRelatedCards = true)
-	{
-		if (!(m_currentBigActor == null) && !m_cancellingCraftMode)
-		{
-			iTween.ScaleTo(m_cardCountTab.gameObject, m_cardCountTabShowScale, 0.4f);
-			m_currentBigActor.GetSpell(SpellType.GHOSTMODE).GetComponent<PlayMakerFSM>().SendEvent("Cancel");
-			m_isCurrentActorAGhost = false;
-			int numOwnedIncludePending = GetNumOwnedIncludePending();
-			m_cardCountTab.UpdateText(numOwnedIncludePending, m_currentBigActor.GetPremium());
-			m_cardCountTab.transform.position = GetCardCountPosition();
-			if (showRelatedCards)
-			{
-				ShowRelatedInfo(m_currentBigActor.GetPremium());
-			}
-		}
-	}
-
-	public void FlipCurrentActor()
-	{
+    public void FlipCurrentActor()
+    {
 		if (!(m_currentBigActor == null) && !m_isCurrentActorAGhost && (m_currentBigActor.GetPremium() != TAG_PREMIUM.GOLDEN || GetNumOwnedIncludePending(TAG_PREMIUM.GOLDEN) > 1) && GetNumOwnedIncludePending(m_currentBigActor.GetPremium()) > 1)
-		{
-			m_cardCountTab.transform.localScale = m_cardCountTabHideScale;
-			if (m_upsideDownActor != null)
-			{
-				Debug.LogError("m_upsideDownActor was not null, destroying object to prevent lost reference");
-				UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
-				m_upsideDownActor = null;
-			}
-			m_upsideDownActor = m_currentBigActor;
-			m_upsideDownActor.name = "UpsideDownActor";
-			m_upsideDownActor.GetSpell(SpellType.GHOSTMODE).GetComponent<PlayMakerFSM>().SendEvent("Cancel");
-			m_currentBigActor = null;
-			iTween.Stop(m_upsideDownActor.gameObject);
+        {
+            m_cardCountTab.transform.localScale = m_cardCountTabHideScale;
+            if (m_upsideDownActor != null)
+            {
+                Debug.LogError("m_upsideDownActor was not null, destroying object to prevent lost reference");
+                UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
+                m_upsideDownActor = null;
+            }
+            m_upsideDownActor = m_currentBigActor;
+            m_upsideDownActor.name = "UpsideDownActor";
+            m_upsideDownActor.GetSpell(SpellType.GHOSTMODE).GetComponent<PlayMakerFSM>().SendEvent("Cancel");
+            m_currentBigActor = null;
+            iTween.Stop(m_upsideDownActor.gameObject);
 			Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
 			tweenHashTable.Add("rotation", new Vector3(0f, 350f, 180f));
-			tweenHashTable.Add("time", 1f);
-			iTween.RotateTo(m_upsideDownActor.gameObject, tweenHashTable);
-			Hashtable tweenHashTable2 = iTweenManager.Get().GetTweenHashTable();
-			tweenHashTable2.Add("name", "FlipCurrentActor");
-			tweenHashTable2.Add("position", m_faceDownCardBone.position);
-			tweenHashTable2.Add("time", 1f);
-			iTween.MoveTo(m_upsideDownActor.gameObject, tweenHashTable2);
-			StartCoroutine(ReplaceFaceDownActorWithHiddenCard());
-		}
-	}
-
-	public void FinishFlipCurrentActorEarly()
-	{
-		StopAllCoroutines();
-		if (m_currentBigActor != null)
-		{
-			iTween.Stop(m_currentBigActor.gameObject);
-		}
-		if (m_upsideDownActor != null)
-		{
-			iTween.Stop(m_upsideDownActor.gameObject);
-		}
-		m_currentBigActor.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
-		m_currentBigActor.transform.position = m_floatingCardBone.position;
-		m_currentBigActor.Show();
-		GameObject hiddenStandIn = m_currentBigActor.GetHiddenStandIn();
-		if (!(hiddenStandIn == null))
-		{
-			hiddenStandIn.SetActive(value: false);
-			UnityEngine.Object.Destroy(hiddenStandIn);
-		}
-	}
-
-	public void FlipUpsideDownCard(Actor oldActor)
-	{
-		if (!m_cancellingCraftMode)
-		{
-			int numOwnedIncludePending = GetNumOwnedIncludePending();
-			if (numOwnedIncludePending > 1)
-			{
-				m_upsideDownActor = GetAndPositionNewUpsideDownActor(m_currentBigActor, fromPage: false);
-				m_upsideDownActor.name = "UpsideDownActor";
-				StartCoroutine(ReplaceFaceDownActorWithHiddenCard());
-			}
-			if (numOwnedIncludePending >= 1)
-			{
-				iTween.ScaleTo(m_cardCountTab.gameObject, m_cardCountTabShowScale, 0.4f);
-				m_cardCountTab.transform.position = GetCardCountPosition();
-				m_cardCountTab.UpdateText(numOwnedIncludePending, m_currentBigActor.GetPremium());
-			}
-			if (m_isCurrentActorAGhost)
-			{
-				m_currentBigActor.gameObject.transform.position = m_floatingCardBone.position;
-			}
-			else
-			{
-				Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
-				tweenHashTable.Add("name", "FlipUpsideDownCard");
-				tweenHashTable.Add("position", m_floatingCardBone.position);
-				tweenHashTable.Add("time", m_timeForCardToFlipUp);
-				tweenHashTable.Add("easetype", m_easeTypeForCardFlip);
-				iTween.MoveTo(m_currentBigActor.gameObject, tweenHashTable);
-			}
-			Hashtable tweenHashTable2 = iTweenManager.Get().GetTweenHashTable();
-			tweenHashTable2.Add("rotation", new Vector3(0f, 0f, 0f));
-			tweenHashTable2.Add("time", m_timeForCardToFlipUp);
-			tweenHashTable2.Add("easetype", m_easeTypeForCardFlip);
-			tweenHashTable2.Add("oncomplete", "OnCardFlipComplete");
-			tweenHashTable2.Add("oncompletetarget", base.gameObject);
-			iTween.RotateTo(m_currentBigActor.gameObject, tweenHashTable2);
-			StartCoroutine(ReplaceHiddenCardwithRealActor(m_currentBigActor));
-		}
-	}
-
-	private IEnumerator ReplaceFaceDownActorWithHiddenCard()
-	{
-		while (m_upsideDownActor != null && m_upsideDownActor.transform.localEulerAngles.z < 90f)
-		{
-			yield return null;
-		}
-		if (!(m_upsideDownActor == null))
-		{
-			GameObject gameObject = UnityEngine.Object.Instantiate(m_hiddenActor.gameObject);
-			gameObject.GetComponent<Actor>().UpdateCardBack();
-			gameObject.transform.parent = m_upsideDownActor.transform;
-			gameObject.transform.localScale = new Vector3(1f, 1f, 1f);
-			gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);
-			gameObject.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
-			m_upsideDownActor.Hide();
-			m_upsideDownActor.SetHiddenStandIn(gameObject);
-		}
-	}
-
-	private IEnumerator ReplaceHiddenCardwithRealActor(Actor actor)
-	{
-		while (actor != null && actor.transform.localEulerAngles.z > 90f && actor.transform.localEulerAngles.z < 270f)
-		{
-			yield return null;
-		}
-		if (!(actor == null))
-		{
-			actor.Show();
-			GameObject hiddenStandIn = actor.GetHiddenStandIn();
-			if (!(hiddenStandIn == null))
-			{
-				hiddenStandIn.SetActive(value: false);
-				UnityEngine.Object.Destroy(hiddenStandIn);
-			}
-		}
-	}
-
-	private void OnCardFlipComplete()
-	{
-		ShowRelatedInfo(m_currentBigActor.GetPremium());
-	}
-
-	public CraftingPendingTransaction GetPendingClientTransaction()
-	{
-		return m_pendingClientTransaction;
-	}
-
-	public CraftingPendingTransaction GetPendingServerTransaction()
-	{
-		return m_pendingServerTransaction;
-	}
-
-	public void ShowCraftingUI(UIEvent e)
-	{
-		if (m_craftingUI.IsEnabled())
-		{
-			m_craftingUI.Disable(m_hideCraftingUIBone.position);
-		}
-		else
-		{
-			m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
-		}
-	}
-
-	public void SetCraftingUIActive(bool active)
-	{
-		if (m_craftingUI != null)
-		{
-			m_craftingUI.gameObject.SetActive(active);
-		}
-	}
-
-	public void ShowUpgradeToGoldenWidget()
-	{
-		if (m_upgradeToGoldenWidget != null)
-		{
-			m_upgradeToGoldenWidget.gameObject.SetActive(value: true);
-			UpgradeToGoldenPopup componentInChildren = m_upgradeToGoldenWidget.GetComponentInChildren<UpgradeToGoldenPopup>();
-			if (componentInChildren != null)
-			{
-				componentInChildren.SetInfo(m_pendingClientTransaction, m_craftingUI, m_showUpgradeToGoldenPopupBone);
-				StartCoroutine(componentInChildren.ShowWhenReadyRoutine());
-			}
-			m_upgradeToGoldenWidgetShown = true;
-		}
-	}
-
-	public void HideUpgradeToGoldenWidget()
-	{
-		if (m_upgradeToGoldenWidget != null)
-		{
-			UpgradeToGoldenPopup componentInChildren = m_upgradeToGoldenWidget.GetComponentInChildren<UpgradeToGoldenPopup>();
-			if (componentInChildren != null)
-			{
-				componentInChildren.OnHide();
-			}
-			m_upgradeToGoldenWidgetShown = false;
-		}
-		ShowRelatedInfo(m_currentBigActor.GetPremium());
-	}
-
-	public void SetCraftingRelatedActorsActiveForUpgradeToGoldenPopup(bool active)
-	{
-		if (!HasUpgradeToGoldenEnabled())
-		{
-			return;
-		}
-		if (m_craftingUI != null)
-		{
-			if (active)
-			{
-				m_craftingUI.m_buttonDisenchant.GetComponent<Collider>().enabled = true;
-				m_craftingUI.m_buttonCreate.GetComponent<Collider>().enabled = true;
-				if (GetNumOwnedIncludePending() == 0)
-				{
-					LoadGhostActorIfNecessary();
-				}
-				m_currentBigActor.Show();
-				m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
-			}
-			else
-			{
-				FinishCreateAnims(active);
-				m_craftingUI.Disable(m_hideCraftingUIBone.position);
-			}
-		}
-		if (m_cardInfoPane != null)
-		{
-			m_cardInfoPane.gameObject.SetActive(active);
-		}
-		if (m_currentBigActor != null)
-		{
-			m_currentBigActor.gameObject.SetActive(active);
-		}
-		if (m_upsideDownActor != null)
-		{
-			m_upsideDownActor.gameObject.SetActive(active);
-		}
-		if (m_cardCountTab != null)
-		{
-			m_cardCountTab.gameObject.SetActive(active);
-		}
-	}
-
-	private Actor GetCurrentActor()
-	{
-		if (m_currentBigActor != null)
-		{
-			return m_currentBigActor;
-		}
-		if (m_upsideDownActor != null)
-		{
-			return m_upsideDownActor;
-		}
-		return null;
-	}
-
-	private void MoveCardToBigSpot(Actor collectionCardActor, TAG_PREMIUM premium)
-	{
-		if (collectionCardActor == null)
-		{
-			return;
-		}
-		EntityDef entityDef = collectionCardActor.GetEntityDef();
-		if (entityDef == null)
-		{
-			return;
-		}
-		int numOwnedIncludePending = GetNumOwnedIncludePending(entityDef.GetCardId(), premium);
-		if (m_currentBigActor != null)
-		{
-			Debug.LogError("m_currentBigActor was not null, destroying object before we lose the reference");
-			UnityEngine.Object.Destroy(m_currentBigActor.gameObject);
-			m_currentBigActor = null;
-		}
-		m_currentBigActor = GetAndPositionNewActor(m_cardActors.GetActor(premium), numOwnedIncludePending);
-		if (m_currentBigActor == null)
-		{
-			Debug.LogError("CraftingManager.MoveCardToBigSpot - GetAndPositionNewActor returned null");
-			return;
-		}
-		m_currentBigActor.name = "CurrentBigActor";
-		m_craftSourcePosition = collectionCardActor.transform.position;
-		m_craftSourceScale = collectionCardActor.transform.lossyScale;
-		m_craftSourceScale = Vector3.one * Mathf.Min(m_craftSourceScale.x, m_craftSourceScale.y, m_craftSourceScale.z);
-		m_currentBigActor.transform.position = m_craftSourcePosition;
-		TransformUtil.SetWorldScale(m_currentBigActor, m_craftSourceScale);
-		SetBigActorLayer(inCraftingMode: true);
-		m_currentBigActor.ToggleForceIdle(bOn: true);
-		m_currentBigActor.SetActorState(ActorStateType.CARD_IDLE);
-		if (entityDef.IsHeroSkin())
-		{
-			m_cardCountTab.gameObject.SetActive(value: false);
-		}
-		else
-		{
-			m_cardCountTab.gameObject.SetActive(value: true);
-			if (numOwnedIncludePending > 1)
-			{
-				if (m_upsideDownActor != null)
-				{
-					Debug.LogError("m_upsideDownActor was not null, destroying object before we lose the reference");
-					UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
-					m_upsideDownActor = null;
-				}
-				m_upsideDownActor = GetAndPositionNewUpsideDownActor(collectionCardActor, fromPage: true);
-				m_upsideDownActor.name = "UpsideDownActor";
-				StartCoroutine(ReplaceFaceDownActorWithHiddenCard());
-			}
-			if (numOwnedIncludePending > 0)
-			{
-				m_cardCountTab.UpdateText(numOwnedIncludePending, premium);
-				m_cardCountTab.transform.position = new Vector3(collectionCardActor.transform.position.x, collectionCardActor.transform.position.y - 2f, collectionCardActor.transform.position.z);
-			}
-		}
-		FinishBigCardMove();
-	}
+			tweenHashTable.Add("time", 1f);
+			iTween.RotateTo(m_upsideDownActor.gameObject, tweenHashTable);
+			Hashtable tweenHashTable2 = iTweenManager.Get().GetTweenHashTable();
+			tweenHashTable2.Add("name", "FlipCurrentActor");
+			tweenHashTable2.Add("position", m_faceDownCardBone.position);
+			tweenHashTable2.Add("time", 1f);
+			iTween.MoveTo(m_upsideDownActor.gameObject, tweenHashTable2);
+            StartCoroutine(ReplaceFaceDownActorWithHiddenCard());
+        }
+    }
+
+    public void FinishFlipCurrentActorEarly()
+    {
+        StopAllCoroutines();
+        if (m_currentBigActor != null)
+        {
+            iTween.Stop(m_currentBigActor.gameObject);
+        }
+        if (m_upsideDownActor != null)
+        {
+            iTween.Stop(m_upsideDownActor.gameObject);
+        }
+        m_currentBigActor.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+        m_currentBigActor.transform.position = m_floatingCardBone.position;
+        m_currentBigActor.Show();
+        GameObject hiddenStandIn = m_currentBigActor.GetHiddenStandIn();
+        if (!(hiddenStandIn == null))
+        {
+            hiddenStandIn.SetActive(value: false);
+            UnityEngine.Object.Destroy(hiddenStandIn);
+        }
+    }
+
+    public void FlipUpsideDownCard(Actor oldActor)
+    {
+        if (!m_cancellingCraftMode)
+        {
+            int numOwnedIncludePending = GetNumOwnedIncludePending();
+            if (numOwnedIncludePending > 1)
+            {
+                m_upsideDownActor = GetAndPositionNewUpsideDownActor(m_currentBigActor, fromPage: false);
+                m_upsideDownActor.name = "UpsideDownActor";
+                StartCoroutine(ReplaceFaceDownActorWithHiddenCard());
+            }
+            if (numOwnedIncludePending >= 1)
+            {
+                iTween.ScaleTo(m_cardCountTab.gameObject, m_cardCountTabShowScale, 0.4f);
+                m_cardCountTab.transform.position = GetCardCountPosition();
+                m_cardCountTab.UpdateText(numOwnedIncludePending, m_currentBigActor.GetPremium());
+            }
+            if (m_isCurrentActorAGhost)
+            {
+                m_currentBigActor.gameObject.transform.position = m_floatingCardBone.position;
+            }
+            else
+            {
+				Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
+				tweenHashTable.Add("name", "FlipUpsideDownCard");
+				tweenHashTable.Add("position", m_floatingCardBone.position);
+				tweenHashTable.Add("time", m_timeForCardToFlipUp);
+				tweenHashTable.Add("easetype", m_easeTypeForCardFlip);
+				iTween.MoveTo(m_currentBigActor.gameObject, tweenHashTable);
+            }
+			Hashtable tweenHashTable2 = iTweenManager.Get().GetTweenHashTable();
+			tweenHashTable2.Add("rotation", new Vector3(0f, 0f, 0f));
+			tweenHashTable2.Add("time", m_timeForCardToFlipUp);
+			tweenHashTable2.Add("easetype", m_easeTypeForCardFlip);
+			tweenHashTable2.Add("oncomplete", "OnCardFlipComplete");
+			tweenHashTable2.Add("oncompletetarget", base.gameObject);
+			iTween.RotateTo(m_currentBigActor.gameObject, tweenHashTable2);
+            StartCoroutine(ReplaceHiddenCardwithRealActor(m_currentBigActor));
+        }
+    }
+
+    private IEnumerator ReplaceFaceDownActorWithHiddenCard()
+    {
+        while (m_upsideDownActor != null && m_upsideDownActor.transform.localEulerAngles.z < 90f)
+        {
+            yield return null;
+        }
+        if (!(m_upsideDownActor == null))
+        {
+            GameObject gameObject = UnityEngine.Object.Instantiate(m_hiddenActor.gameObject);
+            gameObject.GetComponent<Actor>().UpdateCardBack();
+            gameObject.transform.parent = m_upsideDownActor.transform;
+            gameObject.transform.localScale = new Vector3(1f, 1f, 1f);
+            gameObject.transform.localPosition = new Vector3(0f, 0f, 0f);
+            gameObject.transform.localEulerAngles = new Vector3(0f, 0f, 0f);
+            m_upsideDownActor.Hide();
+            m_upsideDownActor.SetHiddenStandIn(gameObject);
+        }
+    }
+
+    private IEnumerator ReplaceHiddenCardwithRealActor(Actor actor)
+    {
+        while (actor != null && actor.transform.localEulerAngles.z > 90f && actor.transform.localEulerAngles.z < 270f)
+        {
+            yield return null;
+        }
+        if (!(actor == null))
+        {
+            actor.Show();
+            GameObject hiddenStandIn = actor.GetHiddenStandIn();
+            if (!(hiddenStandIn == null))
+            {
+                hiddenStandIn.SetActive(value: false);
+                UnityEngine.Object.Destroy(hiddenStandIn);
+            }
+        }
+    }
+
+    private void OnCardFlipComplete()
+    {
+		ShowRelatedInfo(m_currentBigActor.GetPremium());
+        }
+
+    public CraftingPendingTransaction GetPendingClientTransaction()
+    {
+        return m_pendingClientTransaction;
+    }
+
+    public CraftingPendingTransaction GetPendingServerTransaction()
+    {
+        return m_pendingServerTransaction;
+    }
+
+    public void ShowCraftingUI(UIEvent e)
+    {
+        if (m_craftingUI.IsEnabled())
+        {
+            m_craftingUI.Disable(m_hideCraftingUIBone.position);
+        }
+        else
+        {
+            m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
+        }
+    }
+
+    public void SetCraftingUIActive(bool active)
+    {
+        if (m_craftingUI != null)
+        {
+            m_craftingUI.gameObject.SetActive(active);
+        }
+    }
+
+    public void ShowUpgradeToGoldenWidget()
+    {
+        if (m_upgradeToGoldenWidget != null)
+        {
+            m_upgradeToGoldenWidget.gameObject.SetActive(value: true);
+            UpgradeToGoldenPopup componentInChildren = m_upgradeToGoldenWidget.GetComponentInChildren<UpgradeToGoldenPopup>();
+            if (componentInChildren != null)
+            {
+                componentInChildren.SetInfo(m_pendingClientTransaction, m_craftingUI, m_showUpgradeToGoldenPopupBone);
+                StartCoroutine(componentInChildren.ShowWhenReadyRoutine());
+            }
+            m_upgradeToGoldenWidgetShown = true;
+        }
+    }
+
+    public void HideUpgradeToGoldenWidget()
+    {
+        if (m_upgradeToGoldenWidget != null)
+        {
+            UpgradeToGoldenPopup componentInChildren = m_upgradeToGoldenWidget.GetComponentInChildren<UpgradeToGoldenPopup>();
+            if (componentInChildren != null)
+            {
+                componentInChildren.OnHide();
+            }
+            m_upgradeToGoldenWidgetShown = false;
+        }
+		ShowRelatedInfo(m_currentBigActor.GetPremium());
+    }
+
+    public void SetCraftingRelatedActorsActiveForUpgradeToGoldenPopup(bool active)
+    {
+        if (!HasUpgradeToGoldenEnabled())
+        {
+            return;
+        }
+        if (m_craftingUI != null)
+        {
+            if (active)
+            {
+                m_craftingUI.m_buttonDisenchant.GetComponent<Collider>().enabled = true;
+                m_craftingUI.m_buttonCreate.GetComponent<Collider>().enabled = true;
+                if (GetNumOwnedIncludePending() == 0)
+                {
+                    LoadGhostActorIfNecessary();
+                }
+                m_currentBigActor.Show();
+                m_craftingUI.Enable(m_showCraftingUIBone.position, m_hideCraftingUIBone.position);
+            }
+            else
+            {
+				FinishCreateAnims(active);
+                m_craftingUI.Disable(m_hideCraftingUIBone.position);
+            }
+        }
+        if (m_cardInfoPane != null)
+        {
+            m_cardInfoPane.gameObject.SetActive(active);
+        }
+        if (m_currentBigActor != null)
+        {
+            m_currentBigActor.gameObject.SetActive(active);
+        }
+        if (m_upsideDownActor != null)
+        {
+            m_upsideDownActor.gameObject.SetActive(active);
+        }
+        if (m_cardCountTab != null)
+        {
+            m_cardCountTab.gameObject.SetActive(active);
+        }
+    }
+
+    private Actor GetCurrentActor()
+    {
+        if (m_currentBigActor != null)
+        {
+            return m_currentBigActor;
+        }
+        if (m_upsideDownActor != null)
+        {
+            return m_upsideDownActor;
+        }
+        return null;
+    }
+
+    private void MoveCardToBigSpot(Actor collectionCardActor, TAG_PREMIUM premium)
+    {
+        if (collectionCardActor == null)
+        {
+            return;
+        }
+        EntityDef entityDef = collectionCardActor.GetEntityDef();
+        if (entityDef == null)
+        {
+            return;
+        }
+        int numOwnedIncludePending = GetNumOwnedIncludePending(entityDef.GetCardId(), premium);
+        if (m_currentBigActor != null)
+        {
+            Debug.LogError("m_currentBigActor was not null, destroying object before we lose the reference");
+            UnityEngine.Object.Destroy(m_currentBigActor.gameObject);
+            m_currentBigActor = null;
+        }
+        m_currentBigActor = GetAndPositionNewActor(m_cardActors.GetActor(premium), numOwnedIncludePending);
+        if (m_currentBigActor == null)
+        {
+            Debug.LogError("CraftingManager.MoveCardToBigSpot - GetAndPositionNewActor returned null");
+            return;
+        }
+        m_currentBigActor.name = "CurrentBigActor";
+        m_craftSourcePosition = collectionCardActor.transform.position;
+        m_craftSourceScale = collectionCardActor.transform.lossyScale;
+        m_craftSourceScale = Vector3.one * Mathf.Min(m_craftSourceScale.x, m_craftSourceScale.y, m_craftSourceScale.z);
+        m_currentBigActor.transform.position = m_craftSourcePosition;
+        TransformUtil.SetWorldScale(m_currentBigActor, m_craftSourceScale);
+        SetBigActorLayer(inCraftingMode: true);
+        m_currentBigActor.ToggleForceIdle(bOn: true);
+        m_currentBigActor.SetActorState(ActorStateType.CARD_IDLE);
+        if (entityDef.IsHeroSkin())
+        {
+            m_cardCountTab.gameObject.SetActive(value: false);
+        }
+        else
+        {
+            m_cardCountTab.gameObject.SetActive(value: true);
+            if (numOwnedIncludePending > 1)
+            {
+                if (m_upsideDownActor != null)
+                {
+                    Debug.LogError("m_upsideDownActor was not null, destroying object before we lose the reference");
+                    UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
+                    m_upsideDownActor = null;
+                }
+                m_upsideDownActor = GetAndPositionNewUpsideDownActor(collectionCardActor, fromPage: true);
+                m_upsideDownActor.name = "UpsideDownActor";
+                StartCoroutine(ReplaceFaceDownActorWithHiddenCard());
+            }
+            if (numOwnedIncludePending > 0)
+            {
+                m_cardCountTab.UpdateText(numOwnedIncludePending, premium);
+                m_cardCountTab.transform.position = new Vector3(collectionCardActor.transform.position.x, collectionCardActor.transform.position.y - 2f, collectionCardActor.transform.position.z);
+            }
+        }
+        FinishBigCardMove();
+    }
 
 	private static bool IncludesRuneCards(List<RelatedCardsDbfRecord> relatedCards)
-	{
+    {
 		if (relatedCards == null)
 		{
 			return false;
@@ -1533,15 +1543,15 @@ public class CraftingManager : MonoBehaviour
 		return false;
 	}
 
-	private List<string> GetRelatedCardIds(EntityDef def, out bool offsetCardNameForRunes)
+	internal List<string> GetRelatedCardIds(EntityDef def, out bool offsetCardNameForRunes)
 	{
 		List<string> list = new List<string>();
 		string text = "";
 		offsetCardNameForRunes = false;
 		int id = GameUtils.TranslateCardIdToDbId(def.GetCardId());
-		CardDbfRecord record = GameDbf.Card.GetRecord(id);
-		if (record != null)
-		{
+        CardDbfRecord record = GameDbf.Card.GetRecord(id);
+        if (record != null)
+        {
 			List<RelatedCardsDbfRecord> relatedCards = record.RelatedCards;
 			if (IncludesRuneCards(relatedCards))
 			{
@@ -1567,18 +1577,18 @@ public class CraftingManager : MonoBehaviour
 		{
 			list.Add(text);
 			return list;
-		}
-		if (def.IsHero())
-		{
+        }
+        if (def.IsHero())
+        {
 			text = GameUtils.GetHeroPowerCardIdFromHero(def.GetCardId());
 			if (!string.IsNullOrEmpty(text))
 			{
 				list.Add(text);
 				return list;
 			}
-		}
-		if (def.IsQuest())
-		{
+        }
+        if (def.IsQuest())
+        {
 			int id3 = def.GetTag(GAME_TAG.QUEST_REWARD_DATABASE_ID);
 			text = GameDbf.Card.GetRecord(id3)?.NoteMiniGuid;
 			if (!string.IsNullOrEmpty(text))
@@ -1586,33 +1596,33 @@ public class CraftingManager : MonoBehaviour
 				list.Add(text);
 				return list;
 			}
-		}
-		if (def.IsQuestline())
-		{
+        }
+        if (def.IsQuestline())
+        {
 			int id4 = def.GetTag(GAME_TAG.QUESTLINE_FINAL_REWARD_DATABASE_ID);
 			text = GameDbf.Card.GetRecord(id4)?.NoteMiniGuid;
 			if (!string.IsNullOrEmpty(text))
 			{
 				list.Add(text);
 				return list;
-			}
+        }
 		}
 		return list;
-	}
+    }
 
 	private void ShowRelatedInfo(TAG_PREMIUM premium)
-	{
-		if (m_currentBigActor == null)
-		{
-			Debug.LogError("Unexpected error in ShowRelatedBigCard. Current big actor was null");
-			return;
-		}
-		EntityDef entityDef = m_currentBigActor.GetEntityDef();
-		if (entityDef == null)
-		{
-			Debug.LogError("Unexpected error in ShowRelatedBigCard. Current big actor's entity def was null");
-			return;
-		}
+    {
+        if (m_currentBigActor == null)
+        {
+            Debug.LogError("Unexpected error in ShowRelatedBigCard. Current big actor was null");
+            return;
+        }
+        EntityDef entityDef = m_currentBigActor.GetEntityDef();
+        if (entityDef == null)
+        {
+            Debug.LogError("Unexpected error in ShowRelatedBigCard. Current big actor's entity def was null");
+            return;
+        }
 		int signatureFrameId = ActorNames.GetSignatureFrameId(entityDef.GetCardId());
 		if (m_currentBigActor.GetPremium() == TAG_PREMIUM.SIGNATURE && signatureFrameId >= 2)
 		{
@@ -1622,9 +1632,9 @@ public class CraftingManager : MonoBehaviour
 		bool offsetCardNameForRunes;
 		List<string> relatedCardIds = GetRelatedCardIds(entityDef, out offsetCardNameForRunes);
 		if (relatedCardIds.Count == 0)
-		{
-			return;
-		}
+        {
+            return;
+        }
 		if (relatedCardIds.Count > 1)
 		{
 			foreach (string item in relatedCardIds)
@@ -1641,59 +1651,59 @@ public class CraftingManager : MonoBehaviour
 
 	private void ShowSingleRelatedCard(EntityDef currentEntityDef, string relatedCardId, TAG_PREMIUM premium)
 	{
-		int numOwnedIncludePending = GetNumOwnedIncludePending();
+        int numOwnedIncludePending = GetNumOwnedIncludePending();
 		Actor templateActorForType = GetTemplateActorForType(currentEntityDef.GetCardType(), premium, currentEntityDef.GetCardId());
-		if (templateActorForType.GetEntityDef() == null || templateActorForType.GetEntityDef().GetCardId() != relatedCardId || templateActorForType.GetPremium() != premium || premium == TAG_PREMIUM.SIGNATURE)
-		{
+        if (templateActorForType.GetEntityDef() == null || templateActorForType.GetEntityDef().GetCardId() != relatedCardId || templateActorForType.GetPremium() != premium || premium == TAG_PREMIUM.SIGNATURE)
+        {
 			using DefLoader.DisposableFullDef disposableFullDef = DefLoader.Get().GetFullDef(relatedCardId, m_currentBigActor.CardPortraitQuality);
-			templateActorForType.SetEntityDef(disposableFullDef.EntityDef);
-			if (premium == TAG_PREMIUM.SIGNATURE)
-			{
-				premium = ((!templateActorForType.HasSignaturePortraitTexture()) ? TAG_PREMIUM.GOLDEN : TAG_PREMIUM.SIGNATURE);
-			}
-			templateActorForType.SetPremium(premium);
-		}
-		if (m_currentRelatedCardActor != null)
-		{
-			Debug.LogWarning("Current related card actor was not new when creating a new one. Ensure we cleanup this actor");
+                templateActorForType.SetEntityDef(disposableFullDef.EntityDef);
+                if (premium == TAG_PREMIUM.SIGNATURE)
+                {
+                    premium = ((!templateActorForType.HasSignaturePortraitTexture()) ? TAG_PREMIUM.GOLDEN : TAG_PREMIUM.SIGNATURE);
+                }
+                templateActorForType.SetPremium(premium);
+            }
+        if (m_currentRelatedCardActor != null)
+        {
+            Debug.LogWarning("Current related card actor was not new when creating a new one. Ensure we cleanup this actor");
 			HideAndDestroyRelatedInfo();
-		}
-		m_currentRelatedCardActor = GetAndPositionNewActor(templateActorForType, numOwnedIncludePending);
+        }
+        m_currentRelatedCardActor = GetAndPositionNewActor(templateActorForType, numOwnedIncludePending);
 		if (currentEntityDef.IsQuest() || currentEntityDef.IsQuestline())
-		{
+        {
 			EntityDef entityDef = DefLoader.Get().GetEntityDef(relatedCardId);
 			if (entityDef != null)
-			{
-				bool isPremium = m_currentRelatedCardActor.GetPremium() == TAG_PREMIUM.GOLDEN;
+            {
+                bool isPremium = m_currentRelatedCardActor.GetPremium() == TAG_PREMIUM.GOLDEN;
 				QuestCardRewardOverlay questCardRewardOverlay = AddQuestOverlay(entityDef, isPremium, m_currentRelatedCardActor.gameObject);
 				if (currentEntityDef.IsQuestline())
-				{
-					questCardRewardOverlay?.EnableRewardObjects();
-				}
-			}
-		}
-		LayerUtils.SetLayer(m_currentRelatedCardActor.gameObject, GameLayer.IgnoreFullScreenEffects);
-		m_currentRelatedCardActor.gameObject.transform.parent = m_currentBigActor.transform;
-		StartCoroutine(RevealRelatedCard(m_currentRelatedCardActor));
-	}
-
-	private IEnumerator RevealRelatedCard(Actor actor)
-	{
-		if (actor == null)
-		{
-			yield break;
-		}
-		Spell ghostSpell = actor.GetSpellIfLoaded(SpellType.GHOSTMODE);
-		if (ghostSpell != null)
-		{
-			while (!ghostSpell.IsFinished())
-			{
-				yield return null;
-			}
-		}
-		if (!(actor.gameObject == null))
-		{
-			actor.Show();
+                {
+                    questCardRewardOverlay?.EnableRewardObjects();
+                }
+            }
+        }
+        LayerUtils.SetLayer(m_currentRelatedCardActor.gameObject, GameLayer.IgnoreFullScreenEffects);
+        m_currentRelatedCardActor.gameObject.transform.parent = m_currentBigActor.transform;
+        StartCoroutine(RevealRelatedCard(m_currentRelatedCardActor));
+    }
+
+    private IEnumerator RevealRelatedCard(Actor actor)
+    {
+        if (actor == null)
+        {
+            yield break;
+        }
+        Spell ghostSpell = actor.GetSpellIfLoaded(SpellType.GHOSTMODE);
+        if (ghostSpell != null)
+        {
+            while (!ghostSpell.IsFinished())
+            {
+                yield return null;
+            }
+        }
+        if (!(actor.gameObject == null))
+        {
+            actor.Show();
 			GameObject obj = actor.gameObject;
 			Transform obj2 = obj.transform;
 			obj2.localPosition = HERO_POWER_START_POSITION;
@@ -1708,26 +1718,26 @@ public class CraftingManager : MonoBehaviour
 			tweenHashTable2.Add("islocal", true);
 			tweenHashTable2.Add("time", HERO_POWER_TWEEN_TIME);
 			iTween.ScaleTo(obj, tweenHashTable2);
-		}
-	}
+        }
+    }
 
 	public void HideAndDestroyRelatedInfo()
-	{
+    {
 		TooltipPanelManager.Get().HideKeywordHelp();
 		if (m_currentRelatedCardActor != null)
-		{
-			UnityEngine.Object.Destroy(m_currentRelatedCardActor.gameObject);
-			m_currentRelatedCardActor = null;
-		}
+        {
+            UnityEngine.Object.Destroy(m_currentRelatedCardActor.gameObject);
+            m_currentRelatedCardActor = null;
+        }
 		ShowRelatedCards(open: false);
-	}
-
-	private void FinishBigCardMove()
-	{
-		if (!(m_currentBigActor == null))
-		{
-			int numOwnedIncludePending = GetNumOwnedIncludePending();
-			SoundManager.Get().LoadAndPlay("Card_Transition_Out.prefab:aecf5b5837772844b9d2db995744df82");
+    }
+
+    private void FinishBigCardMove()
+    {
+        if (!(m_currentBigActor == null))
+        {
+            int numOwnedIncludePending = GetNumOwnedIncludePending();
+            SoundManager.Get().LoadAndPlay("Card_Transition_Out.prefab:aecf5b5837772844b9d2db995744df82");
 			Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
 			tweenHashTable.Add("name", "FinishBigCardMove");
 			tweenHashTable.Add("position", m_floatingCardBone.position);
@@ -1740,118 +1750,118 @@ public class CraftingManager : MonoBehaviour
 			tweenHashTable2.Add("time", 0.4f);
 			tweenHashTable2.Add("easetype", iTween.EaseType.easeOutQuad);
 			iTween.ScaleTo(m_currentBigActor.gameObject, tweenHashTable2);
-			if (numOwnedIncludePending > 0)
-			{
-				m_cardCountTab.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
-				iTween.MoveTo(m_cardCountTab.gameObject, GetCardCountPosition(), 0.4f);
-				iTween.ScaleTo(m_cardCountTab.gameObject, m_cardCountTabShowScale, 0.4f);
-			}
-		}
-	}
-
-	private void UpdateCardInfoPane()
-	{
-		if (!UniversalInputManager.UsePhoneUI)
-		{
-			if (m_currentBigActor == null)
-			{
-				Debug.LogError("CraftingManager.UpdateCardInfoPane -  m_currentBigActor is null");
-				return;
-			}
-			if (m_cardInfoPane == null)
-			{
-				Debug.LogError("CraftingManager.UpdateCardInfoPane - m_cardInfoPane is null");
-				return;
-			}
-			m_cardInfoPane.gameObject.SetActive(value: true);
-			m_cardInfoPane.UpdateContent();
-			m_cardInfoPane.transform.position = m_currentBigActor.transform.position - new Vector3(0f, 1f, 0f);
-			Vector3 localScale = m_cardInfoPaneBone.localScale;
-			m_cardInfoPane.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
-			iTween.MoveTo(m_cardInfoPane.gameObject, m_cardInfoPaneBone.position, 0.5f);
-			iTween.ScaleTo(m_cardInfoPane.gameObject, localScale, 0.5f);
-		}
-	}
-
-	private void FinishActorMoveTowardsScreen()
-	{
+            if (numOwnedIncludePending > 0)
+            {
+                m_cardCountTab.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
+                iTween.MoveTo(m_cardCountTab.gameObject, GetCardCountPosition(), 0.4f);
+                iTween.ScaleTo(m_cardCountTab.gameObject, m_cardCountTabShowScale, 0.4f);
+            }
+        }
+    }
+
+    private void UpdateCardInfoPane()
+    {
+        if (!UniversalInputManager.UsePhoneUI)
+        {
+            if (m_currentBigActor == null)
+            {
+                Debug.LogError("CraftingManager.UpdateCardInfoPane -  m_currentBigActor is null");
+                return;
+            }
+            if (m_cardInfoPane == null)
+            {
+                Debug.LogError("CraftingManager.UpdateCardInfoPane - m_cardInfoPane is null");
+                return;
+            }
+            m_cardInfoPane.gameObject.SetActive(value: true);
+            m_cardInfoPane.UpdateContent();
+            m_cardInfoPane.transform.position = m_currentBigActor.transform.position - new Vector3(0f, 1f, 0f);
+            Vector3 localScale = m_cardInfoPaneBone.localScale;
+            m_cardInfoPane.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
+            iTween.MoveTo(m_cardInfoPane.gameObject, m_cardInfoPaneBone.position, 0.5f);
+            iTween.ScaleTo(m_cardInfoPane.gameObject, localScale, 0.5f);
+        }
+    }
+
+    private void FinishActorMoveTowardsScreen()
+    {
 		ShowRelatedInfo(m_currentBigActor.GetPremium());
-	}
-
-	private void FinishActorMoveAway()
-	{
-		m_cancellingCraftMode = false;
-		iTween.Stop(m_cardCountTab.gameObject);
-		m_cardCountTab.transform.position = new Vector3(0f, 307f, -10f);
-		if (m_upsideDownActor != null)
-		{
-			UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
-		}
-		if (m_currentBigActor != null)
-		{
-			UnityEngine.Object.Destroy(m_currentBigActor.gameObject);
-		}
-		LoadRandomCardBack();
-	}
-
-	private void FadeEffectsIn()
-	{
-		ScreenEffectParameters blurVignettePerspective = ScreenEffectParameters.BlurVignettePerspective;
-		blurVignettePerspective.Blur = new BlurParameters(1f, 1f);
-		m_screenEffectsHandle.StartEffect(blurVignettePerspective);
-	}
-
-	private void FadeEffectsOut()
-	{
-		m_screenEffectsHandle.StopEffect();
-	}
-
-	private void OnVignetteFinished()
-	{
-		SetBigActorLayer(inCraftingMode: false);
-		if (GetCurrentCardVisual() != null)
-		{
-			GetCurrentCardVisual().OnDoneCrafting();
-		}
-		if (m_currentBigActor != null)
-		{
-			m_currentBigActor.name = "USED_TO_BE_CurrentBigActor";
-			StartCoroutine(MakeSureActorIsCleanedUp(m_currentBigActor));
-		}
-		m_currentBigActor = null;
-		m_craftingUI.gameObject.SetActive(value: false);
-	}
-
-	private IEnumerator MakeSureActorIsCleanedUp(Actor oldActor)
-	{
-		yield return new WaitForSeconds(1f);
-		if (!(oldActor == null))
-		{
-			UnityEngine.Object.DestroyImmediate(oldActor);
-		}
-	}
-
-	private Actor GetAndPositionNewUpsideDownActor(Actor oldActor, bool fromPage)
-	{
-		Actor andPositionNewActor = GetAndPositionNewActor(oldActor, 1);
-		LayerUtils.SetLayer(andPositionNewActor.gameObject, GameLayer.IgnoreFullScreenEffects);
-		if (fromPage)
-		{
-			andPositionNewActor.transform.position = oldActor.transform.position + new Vector3(0f, -2f, 0f);
-			andPositionNewActor.transform.localEulerAngles = new Vector3(0f, 0f, 180f);
-			iTween.RotateTo(andPositionNewActor.gameObject, new Vector3(0f, 350f, 180f), 0.4f);
+        }
+
+    private void FinishActorMoveAway()
+    {
+        m_cancellingCraftMode = false;
+        iTween.Stop(m_cardCountTab.gameObject);
+        m_cardCountTab.transform.position = new Vector3(0f, 307f, -10f);
+        if (m_upsideDownActor != null)
+        {
+            UnityEngine.Object.Destroy(m_upsideDownActor.gameObject);
+        }
+        if (m_currentBigActor != null)
+        {
+            UnityEngine.Object.Destroy(m_currentBigActor.gameObject);
+        }
+        LoadRandomCardBack();
+    }
+
+    private void FadeEffectsIn()
+    {
+        ScreenEffectParameters blurVignettePerspective = ScreenEffectParameters.BlurVignettePerspective;
+        blurVignettePerspective.Blur = new BlurParameters(1f, 1f);
+        m_screenEffectsHandle.StartEffect(blurVignettePerspective);
+    }
+
+    private void FadeEffectsOut()
+    {
+        m_screenEffectsHandle.StopEffect();
+    }
+
+    private void OnVignetteFinished()
+    {
+        SetBigActorLayer(inCraftingMode: false);
+        if (GetCurrentCardVisual() != null)
+        {
+            GetCurrentCardVisual().OnDoneCrafting();
+        }
+        if (m_currentBigActor != null)
+        {
+            m_currentBigActor.name = "USED_TO_BE_CurrentBigActor";
+            StartCoroutine(MakeSureActorIsCleanedUp(m_currentBigActor));
+        }
+        m_currentBigActor = null;
+        m_craftingUI.gameObject.SetActive(value: false);
+    }
+
+    private IEnumerator MakeSureActorIsCleanedUp(Actor oldActor)
+    {
+        yield return new WaitForSeconds(1f);
+        if (!(oldActor == null))
+        {
+            UnityEngine.Object.DestroyImmediate(oldActor);
+        }
+    }
+
+    private Actor GetAndPositionNewUpsideDownActor(Actor oldActor, bool fromPage)
+    {
+        Actor andPositionNewActor = GetAndPositionNewActor(oldActor, 1);
+        LayerUtils.SetLayer(andPositionNewActor.gameObject, GameLayer.IgnoreFullScreenEffects);
+        if (fromPage)
+        {
+            andPositionNewActor.transform.position = oldActor.transform.position + new Vector3(0f, -2f, 0f);
+            andPositionNewActor.transform.localEulerAngles = new Vector3(0f, 0f, 180f);
+            iTween.RotateTo(andPositionNewActor.gameObject, new Vector3(0f, 350f, 180f), 0.4f);
 			Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
 			tweenHashTable.Add("name", "GetAndPositionNewUpsideDownActor");
 			tweenHashTable.Add("position", m_faceDownCardBone.position);
 			tweenHashTable.Add("time", 0.4f);
 			iTween.MoveTo(andPositionNewActor.gameObject, tweenHashTable);
-			iTween.ScaleTo(andPositionNewActor.gameObject, m_faceDownCardBone.localScale, 0.4f);
-		}
-		else
-		{
-			andPositionNewActor.transform.localEulerAngles = new Vector3(0f, 350f, 180f);
-			andPositionNewActor.transform.position = m_faceDownCardBone.position + new Vector3(0f, -6f, 0f);
-			andPositionNewActor.transform.localScale = m_faceDownCardBone.localScale;
+            iTween.ScaleTo(andPositionNewActor.gameObject, m_faceDownCardBone.localScale, 0.4f);
+        }
+        else
+        {
+            andPositionNewActor.transform.localEulerAngles = new Vector3(0f, 350f, 180f);
+            andPositionNewActor.transform.position = m_faceDownCardBone.position + new Vector3(0f, -6f, 0f);
+            andPositionNewActor.transform.localScale = m_faceDownCardBone.localScale;
 			Hashtable tweenHashTable2 = iTweenManager.Get().GetTweenHashTable();
 			tweenHashTable2.Add("name", "GetAndPositionNewUpsideDownActor");
 			tweenHashTable2.Add("position", m_faceDownCardBone.position);
@@ -1859,27 +1869,27 @@ public class CraftingManager : MonoBehaviour
 			tweenHashTable2.Add("easetype", m_easeTypeForCardMoveUp);
 			tweenHashTable2.Add("delay", m_delayBeforeBackCardMovesUp);
 			iTween.MoveTo(andPositionNewActor.gameObject, tweenHashTable2);
-		}
-		return andPositionNewActor;
-	}
+        }
+        return andPositionNewActor;
+    }
 
-	private Actor GetAndPositionNewActor(Actor oldActor, int numCopies)
-	{
+    private Actor GetAndPositionNewActor(Actor oldActor, int numCopies)
+    {
 		bool flag = GameUtils.IsZilliaxCard(oldActor.GetEntityDef());
 		Actor actor = ((numCopies != 0 || flag) ? GetNonGhostActor(oldActor) : GetGhostActor(oldActor));
-		if (actor != null)
-		{
-			actor.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
-		}
-		return actor;
-	}
-
-	private Actor GetGhostActor(Actor actor)
-	{
-		m_isCurrentActorAGhost = true;
-		bool flag = actor.GetPremium() == TAG_PREMIUM.GOLDEN;
-		bool flag2 = actor.GetPremium() == TAG_PREMIUM.SIGNATURE;
-		bool flag3 = actor.GetPremium() == TAG_PREMIUM.DIAMOND;
+        if (actor != null)
+        {
+            actor.transform.localScale = new Vector3(0.1f, 0.1f, 0.1f);
+        }
+        return actor;
+    }
+
+    private Actor GetGhostActor(Actor actor)
+    {
+        m_isCurrentActorAGhost = true;
+        bool flag = actor.GetPremium() == TAG_PREMIUM.GOLDEN;
+        bool flag2 = actor.GetPremium() == TAG_PREMIUM.SIGNATURE;
+        bool flag3 = actor.GetPremium() == TAG_PREMIUM.DIAMOND;
 		Actor value = m_ghostMinionActor;
 		EntityDef entityDef = actor.GetEntityDef();
 		if (entityDef == null)
@@ -1887,8 +1897,8 @@ public class CraftingManager : MonoBehaviour
 			Debug.LogError("CraftingManager::GetGhostActor - EntityDef is null");
 		}
 		switch (entityDef.GetCardType())
-		{
-		case TAG_CARDTYPE.SPELL:
+        {
+            case TAG_CARDTYPE.SPELL:
 			if (flag)
 			{
 				value = m_ghostGoldenSpellActor;
@@ -1902,8 +1912,8 @@ public class CraftingManager : MonoBehaviour
 			{
 				value = m_ghostSpellActor;
 			}
-			break;
-		case TAG_CARDTYPE.WEAPON:
+                break;
+            case TAG_CARDTYPE.WEAPON:
 			if (flag)
 			{
 				value = m_ghostGoldenWeaponActor;
@@ -1917,8 +1927,8 @@ public class CraftingManager : MonoBehaviour
 			{
 				value = m_ghostWeaponActor;
 			}
-			break;
-		case TAG_CARDTYPE.MINION:
+                break;
+            case TAG_CARDTYPE.MINION:
 			if (flag)
 			{
 				value = m_ghostGoldenMinionActor;
@@ -1932,8 +1942,8 @@ public class CraftingManager : MonoBehaviour
 			{
 				value = ((!flag3) ? m_ghostMinionActor : m_ghostDiamondMinionActor);
 			}
-			break;
-		case TAG_CARDTYPE.HERO:
+                break;
+            case TAG_CARDTYPE.HERO:
 			if (flag)
 			{
 				value = m_ghostGoldenHeroActor;
@@ -1947,11 +1957,11 @@ public class CraftingManager : MonoBehaviour
 			{
 				value = m_ghostHeroActor;
 			}
-			break;
-		case TAG_CARDTYPE.HERO_POWER:
+                break;
+            case TAG_CARDTYPE.HERO_POWER:
 			value = ((!flag) ? m_ghostHeroPowerActor : m_ghostGoldenHeroPowerActor);
-			break;
-		case TAG_CARDTYPE.LOCATION:
+                break;
+            case TAG_CARDTYPE.LOCATION:
 			if (flag)
 			{
 				value = m_ghostGoldenLocationActor;
@@ -1965,46 +1975,46 @@ public class CraftingManager : MonoBehaviour
 			{
 				value = m_ghostLocationActor;
 			}
-			break;
-		default:
-			Debug.LogError("CraftingManager.GetGhostActor() - tried to get a ghost actor for a cardtype that we haven't anticipated!!");
-			break;
-		}
+                break;
+            default:
+                Debug.LogError("CraftingManager.GetGhostActor() - tried to get a ghost actor for a cardtype that we haven't anticipated!!");
+                break;
+        }
 		return SetUpGhostActor(value, actor);
-	}
+    }
 
-	private Actor GetNonGhostActor(Actor actor)
-	{
-		m_isCurrentActorAGhost = false;
-		return SetUpNonGhostActor(GetTemplateActor(actor), actor);
-	}
+    private Actor GetNonGhostActor(Actor actor)
+    {
+        m_isCurrentActorAGhost = false;
+        return SetUpNonGhostActor(GetTemplateActor(actor), actor);
+    }
 
 	private Actor GetTemplateActorForType(TAG_CARDTYPE type, TAG_PREMIUM premium, string cardId)
-	{
-		bool flag = premium == TAG_PREMIUM.GOLDEN;
-		bool flag2 = premium == TAG_PREMIUM.SIGNATURE;
-		bool flag3 = premium == TAG_PREMIUM.DIAMOND;
-		switch (type)
-		{
-		case TAG_CARDTYPE.SPELL:
-			if (flag)
-			{
-				return m_templateGoldenSpellActor;
-			}
-			return m_templateSpellActor;
-		case TAG_CARDTYPE.WEAPON:
-			if (flag)
-			{
-				return m_templateGoldenWeaponActor;
-			}
-			return m_templateWeaponActor;
-		case TAG_CARDTYPE.MINION:
-			if (flag)
-			{
-				return m_templateGoldenMinionActor;
-			}
-			if (flag2)
-			{
+    {
+        bool flag = premium == TAG_PREMIUM.GOLDEN;
+        bool flag2 = premium == TAG_PREMIUM.SIGNATURE;
+        bool flag3 = premium == TAG_PREMIUM.DIAMOND;
+        switch (type)
+        {
+            case TAG_CARDTYPE.SPELL:
+                if (flag)
+                {
+                    return m_templateGoldenSpellActor;
+                }
+                return m_templateSpellActor;
+            case TAG_CARDTYPE.WEAPON:
+                if (flag)
+                {
+                    return m_templateGoldenWeaponActor;
+                }
+                return m_templateWeaponActor;
+            case TAG_CARDTYPE.MINION:
+                if (flag)
+                {
+                    return m_templateGoldenMinionActor;
+                }
+                if (flag2)
+                {
 				int num2 = 0;
 				if (cardId == null)
 				{
@@ -2014,29 +2024,29 @@ public class CraftingManager : MonoBehaviour
 				num2 = ActorNames.GetSignatureFrameId(cardId);
 				m_templateSignatureMinionActors.TryGetValue(num2, out var value2);
 				return value2;
-			}
-			if (flag3)
-			{
-				return m_templateDiamondMinionActor;
-			}
-			return m_templateMinionActor;
-		case TAG_CARDTYPE.HERO:
-			if (flag)
-			{
-				return m_templateGoldenHeroActor;
-			}
-			return m_templateHeroActor;
-		case TAG_CARDTYPE.HERO_POWER:
-			if (flag)
-			{
-				return m_templateGoldenHeroPowerActor;
-			}
-			return m_templateHeroPowerActor;
-		case TAG_CARDTYPE.LOCATION:
-			if (flag)
-			{
-				return m_templateGoldenLocationActor;
-			}
+                }
+                if (flag3)
+                {
+                    return m_templateDiamondMinionActor;
+                }
+                return m_templateMinionActor;
+            case TAG_CARDTYPE.HERO:
+                if (flag)
+                {
+                    return m_templateGoldenHeroActor;
+                }
+                return m_templateHeroActor;
+            case TAG_CARDTYPE.HERO_POWER:
+                if (flag)
+                {
+                    return m_templateGoldenHeroPowerActor;
+                }
+                return m_templateHeroPowerActor;
+            case TAG_CARDTYPE.LOCATION:
+                if (flag)
+                {
+                    return m_templateGoldenLocationActor;
+                }
 			if (flag2)
 			{
 				int num = 0;
@@ -2049,211 +2059,218 @@ public class CraftingManager : MonoBehaviour
 				m_templateSignatureMinionActors.TryGetValue(num, out var value);
 				return value;
 			}
-			return m_templateLocationActor;
-		default:
-			Debug.LogError("CraftingManager.GetTemplateActorForType() - tried to get a actor for a cardtype that we haven't anticipated!!");
-			return m_templateMinionActor;
-		}
-	}
+                return m_templateLocationActor;
+            default:
+                Debug.LogError("CraftingManager.GetTemplateActorForType() - tried to get a actor for a cardtype that we haven't anticipated!!");
+                return m_templateMinionActor;
+        }
+    }
 
-	private Actor GetTemplateActor(Actor actor)
-	{
+    private Actor GetTemplateActor(Actor actor)
+    {
 		EntityDef entityDef = actor.GetEntityDef();
 		return GetTemplateActorForType(entityDef.GetCardType(), actor.GetPremium(), entityDef.GetCardId());
-	}
-
-	private Actor SetUpNonGhostActor(Actor templateActor, Actor actor)
-	{
-		Actor actor2 = UnityEngine.Object.Instantiate(templateActor);
-		actor2.SetFullDefFromActor(actor);
-		actor2.SetPremium(actor.GetPremium());
-		actor2.SetUnlit();
-		actor2.UpdateAllComponents();
-		return actor2;
-	}
-
-	private Actor SetUpGhostActor(Actor templateActor, Actor actor)
-	{
-		if (templateActor == null || actor == null)
-		{
-			Debug.LogError("CraftingManager.SetUpGhostActor - passed arguments are null");
-			return null;
-		}
-		Actor actor2 = UnityEngine.Object.Instantiate(templateActor);
-		actor2.SetFullDefFromActor(actor);
-		actor2.SetPremium(actor.GetPremium());
-		actor2.UpdateAllComponents();
-		actor2.UpdatePortraitTexture();
-		actor2.UpdateCardColor();
-		actor2.SetUnlit();
-		actor2.Hide();
-		if (actor.isMissingCard())
-		{
-			actor2.ActivateSpellBirthState(SpellType.MISSING_BIGCARD);
-		}
-		else
-		{
-			actor2.ActivateSpellBirthState(SpellType.GHOSTMODE);
-		}
-		StartCoroutine(ShowAfterTwoFrames(actor2));
-		return actor2;
-	}
-
-	private IEnumerator ShowAfterTwoFrames(Actor actorToShow)
-	{
-		yield return new WaitForEndOfFrame();
-		yield return new WaitForEndOfFrame();
-		if (!(actorToShow != m_currentBigActor))
-		{
-			actorToShow.Show();
-		}
-	}
-
-	private void SetBigActorLayer(bool inCraftingMode)
-	{
-		if (!(m_currentBigActor == null))
-		{
-			GameLayer layer = (inCraftingMode ? GameLayer.IgnoreFullScreenEffects : GameLayer.CardRaycast);
-			LayerUtils.SetLayer(m_currentBigActor.gameObject, layer);
-		}
-	}
-
-	private CollectionCardVisual GetCurrentCardVisual()
-	{
-		if (!GetShownCardInfo(out var entityDef, out var premium))
-		{
-			return null;
-		}
-		return CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
-			.GetCardVisual(entityDef.GetCardId(), premium);
-	}
-
-	public int GetNumOwnedIncludePending(TAG_PREMIUM? premium)
-	{
-		string cardId = m_collectionCardActor.GetEntityDef().GetCardId();
-		return GetNumOwnedIncludePending(cardId, premium);
-	}
-
-	public int GetNumOwnedIncludePending(string cardId, TAG_PREMIUM? premium)
-	{
-		int num = 0;
-		num = ((!premium.HasValue) ? CollectionManager.Get().GetTotalNumCopiesInCollection(cardId) : CollectionManager.Get().GetNumCopiesInCollection(cardId, premium.Value));
-		if (IsPendingTransactionForCard(cardId))
-		{
-			if (!premium.HasValue)
-			{
-				num += m_pendingClientTransaction.GetTransactionAmount(TAG_PREMIUM.NORMAL);
-				num += m_pendingClientTransaction.GetTransactionAmount(TAG_PREMIUM.GOLDEN);
+    }
+
+    private Actor SetUpNonGhostActor(Actor templateActor, Actor actor)
+    {
+        Actor actor2 = UnityEngine.Object.Instantiate(templateActor);
+        actor2.SetFullDefFromActor(actor);
+        actor2.SetPremium(actor.GetPremium());
+        actor2.SetUnlit();
+        actor2.UpdateAllComponents();
+        return actor2;
+    }
+
+    private Actor SetUpGhostActor(Actor templateActor, Actor actor)
+    {
+        if (templateActor == null || actor == null)
+        {
+            Debug.LogError("CraftingManager.SetUpGhostActor - passed arguments are null");
+            return null;
+        }
+        Actor actor2 = UnityEngine.Object.Instantiate(templateActor);
+        actor2.SetFullDefFromActor(actor);
+        actor2.SetPremium(actor.GetPremium());
+        actor2.UpdateAllComponents();
+        actor2.UpdatePortraitTexture();
+        actor2.UpdateCardColor();
+        actor2.SetUnlit();
+        actor2.Hide();
+        if (actor.isMissingCard())
+        {
+            actor2.ActivateSpellBirthState(SpellType.MISSING_BIGCARD);
+        }
+        else
+        {
+            actor2.ActivateSpellBirthState(SpellType.GHOSTMODE);
+        }
+        StartCoroutine(ShowAfterTwoFrames(actor2));
+        return actor2;
+    }
+
+    private IEnumerator ShowAfterTwoFrames(Actor actorToShow)
+    {
+        yield return new WaitForEndOfFrame();
+        yield return new WaitForEndOfFrame();
+        if (!(actorToShow != m_currentBigActor))
+        {
+            actorToShow.Show();
+        }
+    }
+
+    private void SetBigActorLayer(bool inCraftingMode)
+    {
+        if (!(m_currentBigActor == null))
+        {
+            GameLayer layer = (inCraftingMode ? GameLayer.IgnoreFullScreenEffects : GameLayer.CardRaycast);
+            LayerUtils.SetLayer(m_currentBigActor.gameObject, layer);
+        }
+    }
+
+    private CollectionCardVisual GetCurrentCardVisual()
+    {
+        if (!GetShownCardInfo(out var entityDef, out var premium))
+        {
+            return null;
+        }
+        return CollectionManager.Get().GetCollectibleDisplay().GetPageManager()
+            .GetCardVisual(entityDef.GetCardId(), premium);
+    }
+
+    public int GetNumOwnedIncludePending(TAG_PREMIUM? premium)
+    {
+        string cardId = m_collectionCardActor.GetEntityDef().GetCardId();
+        return GetNumOwnedIncludePending(cardId, premium);
+    }
+
+    public int GetNumOwnedIncludePending(string cardId, TAG_PREMIUM? premium)
+    {
+        int num = 0;
+        num = ((!premium.HasValue) ? CollectionManager.Get().GetTotalNumCopiesInCollection(cardId) : CollectionManager.Get().GetNumCopiesInCollection(cardId, premium.Value));
+        if (IsPendingTransactionForCard(cardId))
+        {
+            if (!premium.HasValue)
+            {
+                num += m_pendingClientTransaction.GetTransactionAmount(TAG_PREMIUM.NORMAL);
+                num += m_pendingClientTransaction.GetTransactionAmount(TAG_PREMIUM.GOLDEN);
 				num += m_pendingClientTransaction.GetTransactionAmount(TAG_PREMIUM.SIGNATURE);
-			}
-			else
-			{
-				num += m_pendingClientTransaction.GetTransactionAmount(premium.Value);
-			}
-		}
-		return num;
-	}
-
-	public int GetNumOwnedIncludePending()
-	{
-		if (m_pendingClientTransaction != null)
-		{
-			return GetNumOwnedIncludePending(m_pendingClientTransaction.Premium);
-		}
-		return GetNumOwnedIncludePending(m_collectionCardActor.GetPremium());
-	}
-
-	public bool IsPendingTransactionForCard(string cardId)
-	{
-		if (m_pendingClientTransaction == null)
-		{
-			return false;
-		}
-		if (m_pendingClientTransaction.CardID == cardId)
-		{
-			return true;
-		}
-		if (GameUtils.IsClassicCard(cardId))
-		{
-			string text = GameUtils.TranslateDbIdToCardId(m_collectionCardActor.GetEntityDef().GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
-			if (m_pendingClientTransaction.CardID == text)
-			{
-				return true;
-			}
-		}
-		return false;
-	}
-
-	private QuestCardRewardOverlay AddQuestOverlay(EntityDef def, bool isPremium, GameObject parent)
-	{
-		if (m_questCardRewardOverlay == null)
-		{
-			Debug.LogWarning("Attempted to add quest overlay to a card, but no prefab was set on CraftinManager");
-			return null;
-		}
-		GameObject gameObject = UnityEngine.Object.Instantiate(m_questCardRewardOverlay.gameObject, parent.transform);
-		if (gameObject == null)
-		{
-			Debug.LogError("Could not instantiate a new quest reward overlay from prefab");
-			return null;
-		}
-		QuestCardRewardOverlay component = gameObject.GetComponent<QuestCardRewardOverlay>();
-		if (component == null)
-		{
-			Debug.LogError("Newly instantiated quest reward overlay game object does not contain a QuestCardRewardOverlay component.");
-			UnityEngine.Object.Destroy(gameObject);
-			return null;
-		}
-		component.SetEntityType(def, isPremium);
-		return component;
-	}
-
-	private void LoadActor(string actorPath, ref Actor actor)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab(actorPath, AssetLoadingOptions.IgnorePrefabPosition);
-		gameObject.transform.position = new Vector3(-99999f, 99999f, 99999f);
-		actor = gameObject.GetComponent<Actor>();
-		actor.TurnOffCollider();
-	}
-
-	private void LoadActor(string actorPath, ref Actor actor, ref Actor actorCopy)
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab(actorPath, AssetLoadingOptions.IgnorePrefabPosition);
-		gameObject.transform.position = new Vector3(-99999f, 99999f, 99999f);
-		actor = gameObject.GetComponent<Actor>();
-		actorCopy = UnityEngine.Object.Instantiate(actor);
-		actor.TurnOffCollider();
-		actorCopy.TurnOffCollider();
-	}
-
-	private void ShowLeagueLockedCardPopup()
-	{
-		if (GetShownCardInfo(out var entityDef, out var _) && RankMgr.Get().IsCardLockedInCurrentLeague(entityDef))
-		{
+            }
+            else
+            {
+                num += m_pendingClientTransaction.GetTransactionAmount(premium.Value);
+            }
+        }
+        return num;
+    }
+
+    public int GetNumOwnedIncludePending()
+    {
+        if (m_pendingClientTransaction != null)
+        {
+            return GetNumOwnedIncludePending(m_pendingClientTransaction.Premium);
+        }
+        return GetNumOwnedIncludePending(m_collectionCardActor.GetPremium());
+    }
+
+    public bool IsPendingTransactionForCard(string cardId)
+    {
+        if (m_pendingClientTransaction == null)
+        {
+            return false;
+        }
+        if (m_pendingClientTransaction.CardID == cardId)
+        {
+            return true;
+        }
+        if (GameUtils.IsClassicCard(cardId))
+        {
+            string text = GameUtils.TranslateDbIdToCardId(m_collectionCardActor.GetEntityDef().GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
+            if (m_pendingClientTransaction.CardID == text)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private QuestCardRewardOverlay AddQuestOverlay(EntityDef def, bool isPremium, GameObject parent)
+    {
+        if (m_questCardRewardOverlay == null)
+        {
+            Debug.LogWarning("Attempted to add quest overlay to a card, but no prefab was set on CraftinManager");
+            return null;
+        }
+        GameObject gameObject = UnityEngine.Object.Instantiate(m_questCardRewardOverlay.gameObject, parent.transform);
+        if (gameObject == null)
+        {
+            Debug.LogError("Could not instantiate a new quest reward overlay from prefab");
+            return null;
+        }
+        QuestCardRewardOverlay component = gameObject.GetComponent<QuestCardRewardOverlay>();
+        if (component == null)
+        {
+            Debug.LogError("Newly instantiated quest reward overlay game object does not contain a QuestCardRewardOverlay component.");
+            UnityEngine.Object.Destroy(gameObject);
+            return null;
+        }
+        component.SetEntityType(def, isPremium);
+        return component;
+    }
+
+    private void LoadActor(string actorPath, ref Actor actor)
+    {
+        GameObject gameObject = AssetLoader.Get().InstantiatePrefab(actorPath, AssetLoadingOptions.IgnorePrefabPosition);
+        gameObject.transform.position = new Vector3(-99999f, 99999f, 99999f);
+        actor = gameObject.GetComponent<Actor>();
+        actor.TurnOffCollider();
+    }
+
+    private void LoadActor(string actorPath, ref Actor actor, ref Actor actorCopy)
+    {
+        GameObject gameObject = AssetLoader.Get().InstantiatePrefab(actorPath, AssetLoadingOptions.IgnorePrefabPosition);
+        gameObject.transform.position = new Vector3(-99999f, 99999f, 99999f);
+        actor = gameObject.GetComponent<Actor>();
+        actorCopy = UnityEngine.Object.Instantiate(actor);
+        actor.TurnOffCollider();
+        actorCopy.TurnOffCollider();
+    }
+
+    private void ShowLeagueLockedCardPopup()
+    {
+        if (GetShownCardInfo(out var entityDef, out var _) && RankMgr.Get().IsCardLockedInCurrentLeague(entityDef))
+        {
 			RankMgr rankMgr = RankMgr.Get();
 			LeagueDbfRecord leagueRecordForType = rankMgr.GetLeagueRecordForType(GameUtils.HasCompletedApprentice() ? League.LeagueType.NORMAL : League.LeagueType.NEW_PLAYER, rankMgr.GetLocalPlayerMedalInfo().GetCurrentSeasonId());
 			if (!string.IsNullOrEmpty(leagueRecordForType.LockedCardPopupTitleText) && !string.IsNullOrEmpty(leagueRecordForType.LockedCardPopupBodyText))
-			{
-				AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+            {
+                AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
 				popupInfo.m_headerText = leagueRecordForType.LockedCardPopupTitleText;
 				popupInfo.m_text = leagueRecordForType.LockedCardPopupBodyText;
-				popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-				popupInfo.m_layerToUse = GameLayer.UI;
-				popupInfo.m_showAlertIcon = false;
-				DialogManager.Get().ShowPopup(popupInfo);
-			}
-		}
-	}
-
-	private void LoadRandomCardBack()
-	{
-		CardBackManager.Get().LoadRandomCardBackIntoFavoriteSlot(updateScene: true);
-	}
-
-	private Vector3 GetCardCountPosition()
-	{
+                popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+                popupInfo.m_layerToUse = GameLayer.UI;
+                popupInfo.m_showAlertIcon = false;
+                DialogManager.Get().ShowPopup(popupInfo);
+            }
+        }
+    }
+
+    private void LoadRandomCardBack()
+    {
+        CardBackManager.Get().LoadRandomCardBackIntoFavoriteSlot(updateScene: true);
+    }
+
+    #region Accessibility
+    public bool HasReachedCardLimit(EntityDef entityDef, int numOwnedIncludePending)
+    {
+        int cardLimit = (entityDef.IsElite() ? 1 : 2);
+        return numOwnedIncludePending >= cardLimit;
+    }
+    #endregion
+    private Vector3 GetCardCountPosition()
+    {
 		if (m_currentBigActor.GetPremium() != TAG_PREMIUM.SIGNATURE)
-		{
+        {
 			return m_cardCounterBone.position;
 		}
 		EntityDef entityDef = m_currentBigActor.GetEntityDef();
@@ -2265,9 +2282,9 @@ public class CraftingManager : MonoBehaviour
 		if (ActorNames.GetSignatureFrameId(entityDef.GetCardId()) == 1)
 		{
 			return m_signature25CardCounterBone.position;
-		}
-		return m_cardCounterBone.position;
-	}
+        }
+        return m_cardCounterBone.position;
+    }
 
 	public void ShowRelatedCards(bool open)
 	{
diff --git a/Assembly-CSharp/CraftingTray.cs b/Assembly-CSharp/CraftingTray.cs
index 54d0403..f43b426 100644
--- a/Assembly-CSharp/CraftingTray.cs
+++ b/Assembly-CSharp/CraftingTray.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Assets;
 using Blizzard.T5.MaterialService.Extensions;
 using UnityEngine;
+using Accessibility;
 
 public class CraftingTray : CraftingTrayBase
 {
@@ -177,6 +178,8 @@ public class CraftingTray : CraftingTrayBase
 			(CollectionManager.Get().GetCollectibleDisplay().GetPageManager() as CollectionPageManager).ShowCraftingModeCards(null, null, m_includeUncraftableCheckbox.IsChecked(), m_normalOwnedCheckbox.IsChecked(), m_normalMissingCheckbox.IsChecked(), m_premiumOwnedCheckbox.IsChecked(), m_premiumMissingCheckbox.IsChecked(), updatePage);
 			CraftingTray.CraftingTrayShown?.Invoke();
 		}
+
+		AccessibleCollectionManager.Get().OnCraftingTrayOpened();
 	}
 
 	public override void Hide()
@@ -208,6 +211,8 @@ public class CraftingTray : CraftingTrayBase
 			{
 				CollectionManager.Get().GetCollectibleDisplay().SetViewMode(m_previousViewMode);
 			}
+
+			AccessibleCollectionManager.Get().OnCraftingTrayClosed();
 		}
 	}
 
diff --git a/Assembly-CSharp/CraftingUI.cs b/Assembly-CSharp/CraftingUI.cs
index 788d367..503a466 100644
--- a/Assembly-CSharp/CraftingUI.cs
+++ b/Assembly-CSharp/CraftingUI.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class CraftingUI : MonoBehaviour
 {
@@ -65,6 +66,16 @@ public class CraftingUI : MonoBehaviour
 
 	private bool m_initializedPositions;
 
+	#region Accessibility
+	internal int m_craftCost;
+
+	internal int m_disenchantDustGain;
+
+	internal int m_numOwnedIncludePending; // Num owned cards -> used for error messages
+
+	internal bool m_reachedCardLimit; // True if we're already at cap for this card (and can't craft more)
+	#endregion
+
 	private void Update()
 	{
 		if (!m_enabled)
@@ -120,7 +131,7 @@ public class CraftingUI : MonoBehaviour
 			Name = entityDef.GetCardId(),
 			Premium = premium
 		};
-		int num = craftingManager.GetNumOwnedIncludePending();
+		int num = m_numOwnedIncludePending = craftingManager.GetNumOwnedIncludePending();
 		TAG_CARD_SET cardSet = entityDef.GetCardSet();
 		string cardSetName = GameStrings.GetCardSetName(cardSet);
 		NetCache.CardValue cardValue = craftingManager.GetCardValue(cardDefinition.Name, cardDefinition.Premium);
@@ -144,10 +155,10 @@ public class CraftingUI : MonoBehaviour
 				empty = GameStrings.Get("GLUE_CRAFTING_ZILLIAX_VERSION_DESC");
 			}
 			else
-			{
-				text = cardSetName;
+		{
+			text = cardSetName;
 				empty = ((!Network.IsLoggedIn()) ? GameStrings.Get("GLUE_CRAFTING_SOULBOUND_OFFLINE_DESC") : ((cardSet != TAG_CARD_SET.CORE_HIDDEN) ? entityDef.GetHowToEarnText(cardDefinition.Premium) : GameStrings.Get("GLUE_CRAFTING_SOULBOUND_CORE_ROTATED_DESC")));
-			}
+		}
 		}
 		else
 		{
@@ -169,9 +180,9 @@ public class CraftingUI : MonoBehaviour
 			if (flag)
 			{
 				SetCreateCostBarActive(active: true);
-			}
-			else
-			{
+		}
+		else
+		{
 				SetCreateCostBarActive(!flag4);
 			}
 		}
@@ -189,15 +200,15 @@ public class CraftingUI : MonoBehaviour
 		{
 			SetCreateCostBarActive(active: true);
 			if (flag7)
-			{
-				m_buttonCreate.DisableButton(GameStrings.Get("GLUE_CRAFTING_UPGRADE"));
+		{
+			m_buttonCreate.DisableButton(GameStrings.Get("GLUE_CRAFTING_UPGRADE"));
 				m_buttonCreate.SetTextEnlargedForNoDustJarOnPhone(enlarge: false);
-			}
-			else
-			{
-				m_buttonCreate.DisableButton(GameStrings.Get("GLUE_CRAFTING_CREATE"));
+		}
+		else
+		{
+			m_buttonCreate.DisableButton(GameStrings.Get("GLUE_CRAFTING_CREATE"));
 				m_buttonCreate.SetTextEnlargedForNoDustJarOnPhone(enlarge: false);
-			}
+		}
 		}
 		bool flag8 = false;
 		bool willBecomeActiveInFuture;
@@ -222,6 +233,9 @@ public class CraftingUI : MonoBehaviour
 			{
 				num3 = (craftingManager.GetPendingClientTransaction().GetLastTransactionWasUpgrade() ? GetUpgradeValue(cardDefinition) : cardValue.GetBuyValue());
 			}
+
+			SetDisenchantValue(num3);
+			SetCraftValue(num2);
 			m_disenchantValue.Text = "+" + num3;
 			m_craftValue.Text = "-" + num2;
 			flag8 = true;
@@ -269,6 +283,7 @@ public class CraftingUI : MonoBehaviour
 			m_buttonDisenchant.EnableButton();
 			SetDisenchantCostBarActive(active: true);
 		}
+		m_reachedCardLimit = CraftingManager.Get().HasReachedCardLimit(entityDef, m_numOwnedIncludePending);
 	}
 
 	public void DoDisenchant()
@@ -367,7 +382,8 @@ public class CraftingUI : MonoBehaviour
 			}
 			UpdateTips();
 			craftingManager.NotifyOfTransaction(1);
-			if (craftingManager.GetNumOwnedIncludePending() > 1)
+      m_numOwnedIncludePending = craftingManager.GetNumOwnedIncludePending();
+			if (m_numOwnedIncludePending > 1)
 			{
 				craftingManager.ForceNonGhostFlagOn();
 			}
@@ -447,7 +463,7 @@ public class CraftingUI : MonoBehaviour
 
 	private void ShowFirstTimeTips()
 	{
-		if (!(m_activeObject == m_soulboundNotification) && !Options.Get().GetBool(Option.HAS_CRAFTED) && UserAttentionManager.CanShowAttentionGrabber("CraftingUI.ShowFirstTimeTips"))
+		if (!(m_activeObject == m_soulboundNotification) && !Options.Get().GetBool(Option.HAS_CRAFTED) && UserAttentionManager.CanShowAttentionGrabber(true, "CraftingUI.ShowFirstTimeTips"))
 		{
 			CreateCraftNotification();
 		}
@@ -455,6 +471,12 @@ public class CraftingUI : MonoBehaviour
 
 	private void CreateCraftNotification()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Not relevant given the TTS menu will convey the same info
+			return;
+		}
+
 		if (m_buttonCreate.IsButtonEnabled() && m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.Create)
 		{
 			Vector3 position;
@@ -482,7 +504,7 @@ public class CraftingUI : MonoBehaviour
 
 	private void UpdateTips()
 	{
-		if (Options.Get().GetBool(Option.HAS_CRAFTED) || !UserAttentionManager.CanShowAttentionGrabber("CraftingUI.UpdateTips") || m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.Upgrade || m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.CreateUpgrade)
+		if (Options.Get().GetBool(Option.HAS_CRAFTED) || !UserAttentionManager.CanShowAttentionGrabber(true, "CraftingUI.UpdateTips") || m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.Upgrade || m_buttonCreate.GetCraftingState() == CraftingButton.CraftingState.CreateUpgrade)
 		{
 			HideTips();
 		}
@@ -627,7 +649,7 @@ public class CraftingUI : MonoBehaviour
 		{
 			if (!(item == null))
 			{
-				Log.Crafting.Print("StopCurrentAnim: Destroying GameObject {0}", item);
+				Log.Crafting.Print("StopCurrentAnim: Destroying GameObject {0}", new object[1] { item });
 				Object.Destroy(item);
 			}
 		}
@@ -657,6 +679,8 @@ public class CraftingUI : MonoBehaviour
 
 	private IEnumerator DoDisenchantAnims()
 	{
+		AccessibleCollectionManager.Get().OnDisenchantAnimStarted();
+
 		SoundManager.Get().Play(m_disenchantSound.GetComponent<AudioSource>());
 		SoundManager.Get().Stop(m_craftingSound.GetComponent<AudioSource>());
 		m_isAnimating = true;
@@ -671,7 +695,7 @@ public class CraftingUI : MonoBehaviour
 		m_explodingActor = CraftingManager.Get().GetShownActor();
 		Actor oldActor = m_explodingActor;
 		m_thingsToDestroy.Add(m_explodingActor.gameObject);
-		Log.Crafting.Print("Adding {0} to thingsToDestroy", m_explodingActor.gameObject);
+		Log.Crafting.Print("Adding {0} to thingsToDestroy", new object[1] { m_explodingActor.gameObject });
 		UpdateBankText();
 		if (CraftingManager.Get().IsCancelling())
 		{
@@ -692,6 +716,7 @@ public class CraftingUI : MonoBehaviour
 			yield return new WaitForSeconds(1f);
 			CraftingManager.Get().m_cardCountTab.gameObject.SetActive(value: true);
 			m_isAnimating = false;
+			AccessibleCollectionManager.Get().OnDisenchantAnimDone();
 			yield return new WaitForSeconds(10f);
 			if (oldActor != null)
 			{
@@ -753,6 +778,8 @@ public class CraftingUI : MonoBehaviour
 
 	private IEnumerator DoCreateAnims()
 	{
+		AccessibleCollectionManager.Get().OnCreateAnimStarted();
+
 		Actor shownActor = CraftingManager.Get().GetShownActor();
 		SoundManager.Get().Play(m_craftingSound.GetComponent<AudioSource>());
 		SoundManager.Get().Stop(m_disenchantSound.GetComponent<AudioSource>());
@@ -780,5 +807,21 @@ public class CraftingUI : MonoBehaviour
 			yield return new WaitForSeconds(1f);
 			m_isAnimating = false;
 		}
+
+		AccessibleCollectionManager.Get().OnCreateAnimDone();
+	}
+
+	#region Accessibility
+	private void SetDisenchantValue(int val)
+	{
+		m_disenchantDustGain = val;
+		m_disenchantValue.Text = "+" + val;
+	}
+
+	private void SetCraftValue(int val)
+	{
+		m_craftCost = val;
+		m_craftValue.Text = "-" + val;
 	}
+	#endregion
 }
diff --git a/Assembly-CSharp/CreateButton.cs b/Assembly-CSharp/CreateButton.cs
index 7e5afaf..1fe847a 100644
--- a/Assembly-CSharp/CreateButton.cs
+++ b/Assembly-CSharp/CreateButton.cs
@@ -109,7 +109,7 @@ public class CreateButton : CraftingButton
 						Options.Get().SetBool(Option.HAS_SEEN_STANDARD_MODE_TUTORIAL, val: true);
 						SetRotationManager.Get().SetRotationIntroProgress();
 						Options.Get().SetBool(Option.NEEDS_TO_MAKE_STANDARD_DECK, val: false);
-						UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+						UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 						Options.Get().SetBool(Option.SHOW_SWITCH_TO_WILD_ON_PLAY_SCREEN, val: true);
 						Options.Get().SetBool(Option.SHOW_SWITCH_TO_WILD_ON_CREATE_DECK, val: true);
 					}
diff --git a/Assembly-CSharp/Currency.cs b/Assembly-CSharp/Currency.cs
index 534b26d..5e5cd7a 100644
--- a/Assembly-CSharp/Currency.cs
+++ b/Assembly-CSharp/Currency.cs
@@ -21,9 +21,6 @@ public class Currency
 		ChangedVersion = 0
 	};
 
-	[CompilerGenerated]
-	private int <ChangedVersion>k__BackingField;
-
 	public string Code { get; private set; }
 
 	public int ID { get; private set; }
@@ -36,14 +33,8 @@ public class Currency
 
 	public Tax TaxText { get; private set; }
 
-	private int ChangedVersion
-	{
-		[CompilerGenerated]
-		set
-		{
-			<ChangedVersion>k__BackingField = value;
-		}
-	}
+	private int ChangedVersion;
+
 
 	public Currency()
 	{
diff --git a/Assembly-CSharp/CurrencyBalanceChangedEventArgs.cs b/Assembly-CSharp/CurrencyBalanceChangedEventArgs.cs
index add1d1b..1d69794 100644
--- a/Assembly-CSharp/CurrencyBalanceChangedEventArgs.cs
+++ b/Assembly-CSharp/CurrencyBalanceChangedEventArgs.cs
@@ -3,18 +3,16 @@ using System.Runtime.CompilerServices;
 
 public class CurrencyBalanceChangedEventArgs : EventArgs
 {
-	[CompilerGenerated]
-	private readonly long <OldAmount>k__BackingField;
+	public CurrencyType Currency { get; }
 
-	[CompilerGenerated]
-	private readonly long <NewAmount>k__BackingField;
+	public long OldAmount { get; set; }
 
-	public CurrencyType Currency { get; }
+	public long NewAmount { get; set; }
 
 	public CurrencyBalanceChangedEventArgs(CurrencyType type, long oldAmount, long newAmount)
 	{
 		Currency = type;
-		<OldAmount>k__BackingField = oldAmount;
-		<NewAmount>k__BackingField = newAmount;
+		OldAmount = oldAmount;
+		NewAmount = newAmount;
 	}
 }
diff --git a/Assembly-CSharp/CurrencyConversionPage.cs b/Assembly-CSharp/CurrencyConversionPage.cs
index ed835b4..6636d28 100644
--- a/Assembly-CSharp/CurrencyConversionPage.cs
+++ b/Assembly-CSharp/CurrencyConversionPage.cs
@@ -63,7 +63,7 @@ public class CurrencyConversionPage : ProductPage
 
 	public void OpenToSKU(float desiredAmount)
 	{
-		Open();
+		Open(false);
 		if (m_baseQuantity > 0f)
 		{
 			m_selectedQuantity = ClampSelection(Mathf.CeilToInt(desiredAmount / m_baseQuantity));
@@ -71,9 +71,9 @@ public class CurrencyConversionPage : ProductPage
 		}
 	}
 
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
-		base.Open();
+		base.Open(false);
 		if (m_productImmutable == null)
 		{
 			ProductDataModel dataModel = m_widget.GetDataModel<ProductDataModel>();
diff --git a/Assembly-CSharp/CustomDeckPage.cs b/Assembly-CSharp/CustomDeckPage.cs
index f7ff4e2..e72272b 100644
--- a/Assembly-CSharp/CustomDeckPage.cs
+++ b/Assembly-CSharp/CustomDeckPage.cs
@@ -50,7 +50,7 @@ public class CustomDeckPage : MonoBehaviour
 
 	protected int m_numCustomDecks;
 
-	protected List<CollectionDeckBoxVisual> m_customDecks = new List<CollectionDeckBoxVisual>();
+	public List<CollectionDeckBoxVisual> m_customDecks = new List<CollectionDeckBoxVisual>();
 
 	protected DeckButtonCallback m_deckButtonCallback;
 
@@ -385,8 +385,8 @@ public class CustomDeckPage : MonoBehaviour
 			{
 				index += 3;
 			}
-			float customDeckHorizontalSpacing = m_customDeckHorizontalSpacing;
-			float customDeckVerticalSpacing = m_customDeckVerticalSpacing;
+		float customDeckHorizontalSpacing = m_customDeckHorizontalSpacing;
+		float customDeckVerticalSpacing = m_customDeckVerticalSpacing;
 			if (index == 0)
 			{
 				deckToDisplay.transform.localPosition = m_customDeckStart;
diff --git a/Assembly-CSharp/DeckArchetypesIntroPopup.cs b/Assembly-CSharp/DeckArchetypesIntroPopup.cs
index 1be58dd..77547ee 100644
--- a/Assembly-CSharp/DeckArchetypesIntroPopup.cs
+++ b/Assembly-CSharp/DeckArchetypesIntroPopup.cs
@@ -1,7 +1,9 @@
 using System;
+using System.Collections.Generic;
 using Blizzard.T5.MaterialService.Extensions;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class DeckArchetypesIntroPopup : BasicPopup
@@ -9,6 +11,7 @@ public class DeckArchetypesIntroPopup : BasicPopup
 	public class DeckArchetypesIntroPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+		public DeckArchetypesIntroPopupInfo(string accessibleText="") : base(accessibleText) {}
 	}
 
 	public static readonly AssetReference PrefabReference = new AssetReference("NPPG_DeckPickerArchetypes.prefab:6b850c6784b6e6044af0bcef1d4e506f");
@@ -64,11 +67,14 @@ public class DeckArchetypesIntroPopup : BasicPopup
 		{
 			OverlayUI.Get().AddGameObject(base.gameObject, CanvasAnchor.CENTER, destroyOnSceneLoad: false, (!UniversalInputManager.UsePhoneUI) ? CanvasScaleMode.HEIGHT : CanvasScaleMode.WIDTH);
 			m_widget.TriggerEvent("SHOW_POPUP");
+
+			ReadPopup();
 		}
 	}
 
 	public override void Hide()
 	{
+		AccessibilityMgr.HideUI(this);
 		if (m_popupInfo is DeckArchetypesIntroPopupInfo { m_onHiddenCallback: not null } deckArchetypesIntroPopupInfo)
 		{
 			deckArchetypesIntroPopupInfo.m_onHiddenCallback();
@@ -102,4 +108,37 @@ public class DeckArchetypesIntroPopup : BasicPopup
 			m_magePortraitMesh.SetSharedMaterial(m_magePortraitMaterialIndex, customDeckPortrait2);
 		}
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleMultilineText> m_accessibleArchetypes;
+
+	private void ReadPopup()
+	{
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, GameStrings.Get("GLUE_PROGRESSION_APPRENTICE_DECK_POPUP_SUBTITLE"));
+		var archetypes = new List<AccessibleMultilineText>();
+		archetypes.Add(new AccessibleMultilineText(this, GameStrings.Get("GLUE_PROGRESSION_APPRENTICE_DECK_POPUP_AGGRO"), GameStrings.GetClassName(TAG_CLASS.HUNTER), GameStrings.Get("GLUE_PROGRESSION_APPRENTICE_DECK_POPUP_AGGRO_DESC")));
+		archetypes.Add(new AccessibleMultilineText(this, GameStrings.Get("GLUE_PROGRESSION_APPRENTICE_DECK_POPUP_CONTROL"), GameStrings.GetClassName(TAG_CLASS.MAGE), GameStrings.Get("GLUE_PROGRESSION_APPRENTICE_DECK_POPUP_CONTROL_DESC")));
+		m_accessibleArchetypes = new AccessibleListOfItems<AccessibleMultilineText>(this, archetypes);
+		m_accessibleArchetypes.StartReading();
+	}
+
+	public override void HandleAccessibleInput()
+	{
+		if (AccessibleKey.CONFIRM.IsPressed())
+		{
+			m_widget.TriggerEvent(HIDE_EVENT_NAME);
+		}
+		else
+		{
+			m_accessibleArchetypes.HandleAccessibleInput();
+		}
+	}
+
+	public override string GetAccessibleHelp()
+	{
+		return LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/DeckHelper.cs b/Assembly-CSharp/DeckHelper.cs
index 2becee4..b4f0aa9 100644
--- a/Assembly-CSharp/DeckHelper.cs
+++ b/Assembly-CSharp/DeckHelper.cs
@@ -268,29 +268,29 @@ public class DeckHelper : MonoBehaviour
 	private Actor LoadBestCardActor(EntityDef entityDef, TAG_PREMIUM premiumToUse, GhostCard.Type ghostCard = GhostCard.Type.NONE)
 	{
 		using DefLoader.DisposableCardDef disposableCardDef = DefLoader.Get().GetCardDef(entityDef.GetCardId(), new CardPortraitQuality(3, premiumToUse));
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab(ActorNames.GetHandActor(entityDef, premiumToUse), AssetLoadingOptions.IgnorePrefabPosition);
-		if (gameObject == null)
-		{
-			Debug.LogWarning($"DeckHelper - FAILED to load actor \"{base.name}\"");
-			return null;
-		}
-		Actor component = gameObject.GetComponent<Actor>();
-		if (component == null)
-		{
-			Debug.LogWarning($"DeckHelper - ERROR actor \"{base.name}\" has no Actor component");
-			return null;
+			GameObject gameObject = AssetLoader.Get().InstantiatePrefab(ActorNames.GetHandActor(entityDef, premiumToUse), AssetLoadingOptions.IgnorePrefabPosition);
+			if (gameObject == null)
+			{
+				Debug.LogWarning($"DeckHelper - FAILED to load actor \"{base.name}\"");
+				return null;
+			}
+			Actor component = gameObject.GetComponent<Actor>();
+			if (component == null)
+			{
+				Debug.LogWarning($"DeckHelper - ERROR actor \"{base.name}\" has no Actor component");
+				return null;
+			}
+			component.transform.parent = base.transform;
+			LayerUtils.SetLayer(component, base.gameObject.layer);
+			component.SetEntityDef(entityDef);
+			component.SetCardDef(disposableCardDef);
+			component.SetPremium(premiumToUse);
+			component.GhostCardEffect(ghostCard, premiumToUse);
+			component.UpdateAllComponents();
+			component.Hide();
+			component.gameObject.name = disposableCardDef.CardDef.name + "_actor";
+			return component;
 		}
-		component.transform.parent = base.transform;
-		LayerUtils.SetLayer(component, base.gameObject.layer);
-		component.SetEntityDef(entityDef);
-		component.SetCardDef(disposableCardDef);
-		component.SetPremium(premiumToUse);
-		component.GhostCardEffect(ghostCard, premiumToUse);
-		component.UpdateAllComponents();
-		component.Hide();
-		component.gameObject.name = disposableCardDef.CardDef.name + "_actor";
-		return component;
-	}
 
 	private void CleanOldChoices()
 	{
@@ -361,7 +361,7 @@ public class DeckHelper : MonoBehaviour
 			Navigation.PushUnique(OnNavigateBack);
 			m_shown = true;
 			m_rootObject.SetActive(value: true);
-			if (!Options.Get().GetBool(Option.HAS_SEEN_DECK_HELPER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DeckHelper.Show:" + Option.HAS_SEEN_DECK_HELPER))
+			if (!Options.Get().GetBool(Option.HAS_SEEN_DECK_HELPER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckHelper.Show:" + Option.HAS_SEEN_DECK_HELPER))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_ANNOUNCER_CM_HELP_DECK_50"), "VO_ANNOUNCER_CM_HELP_DECK_50.prefab:450881875d33d094e9a27f6260fb06d9");
 				Options.Get().SetBool(Option.HAS_SEEN_DECK_HELPER, val: true);
diff --git a/Assembly-CSharp/DeckOptionsMenu.cs b/Assembly-CSharp/DeckOptionsMenu.cs
index 3a2e0f1..3c54243 100644
--- a/Assembly-CSharp/DeckOptionsMenu.cs
+++ b/Assembly-CSharp/DeckOptionsMenu.cs
@@ -4,6 +4,7 @@ using Blizzard.T5.Core;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class DeckOptionsMenu : MonoBehaviour
 {
@@ -211,6 +212,10 @@ public class DeckOptionsMenu : MonoBehaviour
 				collectionManagerDisplay.OnDoneEditingDeck();
 			}
 		}
+		else
+        {
+			AccessibleCollectionManager.Get().OnDeleteDeckCanceled();
+        }
 	}
 
 	private void OnRetireButtonReleased(UIEvent e)
@@ -270,7 +275,7 @@ public class DeckOptionsMenu : MonoBehaviour
 		}
 	}
 
-	private IEnumerator SwitchFormat(FormatType format)
+	internal IEnumerator SwitchFormat(FormatType format)
 	{
 		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
 		if (collectionManagerDisplay != null)
@@ -327,9 +332,11 @@ public class DeckOptionsMenu : MonoBehaviour
 		{
 			m_deck.FormatType = format;
 		}
+
+		AccessibleCollectionManager.Get().OnDeckFormatChanged(m_deck);
 	}
 
-	private List<FormatType> GetFormatTypesToConvert(FormatType formatType)
+	internal List<FormatType> GetFormatTypesToConvert(FormatType formatType)
 	{
 		List<FormatType> list = new List<FormatType>();
 		switch (formatType)
@@ -390,11 +397,11 @@ public class DeckOptionsMenu : MonoBehaviour
 			if (formatType != FormatType.FT_WILD && collectionManager.ShouldShowWildToStandardTutorial())
 			{
 				collectionManagerDisplay.ShowStandardInfoTutorial(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
-			}
+		}
 		}
 		if (!num)
 		{
-			cardsContent.UpdateCardList();
+		cardsContent.UpdateCardList();
 		}
 		cardsContent.UpdateTileVisuals();
 		DeckTrayCardListContent sideboardCardsContent = collectionDeckTray.GetSideboardCardsContent();
@@ -408,21 +415,7 @@ public class DeckOptionsMenu : MonoBehaviour
 	private void SetSwitchFormatText(FormatType currentFormat)
 	{
 		List<FormatType> formatTypesToConvert = GetFormatTypesToConvert(currentFormat);
-		Map<FormatType, string> map = new Map<FormatType, string>
-		{
-			{
-				FormatType.FT_STANDARD,
-				"GLUE_COLLECTION_TO_STANDARD"
-			},
-			{
-				FormatType.FT_WILD,
-				"GLUE_COLLECTION_TO_WILD"
-			},
-			{
-				FormatType.FT_TWIST,
-				"GLUE_COLLECTION_TO_TWIST"
-			}
-		};
+
 		if (m_convertFormatButtons.Length == formatTypesToConvert.Count)
 		{
 			for (int i = 0; i < m_convertFormatButtons.Length; i++)
@@ -432,7 +425,7 @@ public class DeckOptionsMenu : MonoBehaviour
 					Debug.LogError("Button Uber text reference not assigned");
 					continue;
 				}
-				if (map.TryGetValue(formatTypesToConvert[i], out var value))
+				if (s_FORMAT_TO_SWITCH_STRING.TryGetValue(formatTypesToConvert[i], out var value))
 				{
 					m_convertFormatButtons[i].ButtonText.Text = GameStrings.Get(value);
 					continue;
@@ -470,7 +463,7 @@ public class DeckOptionsMenu : MonoBehaviour
 		}
 	}
 
-	private bool CanConvertCurrentDeckToTwist()
+	internal bool CanConvertCurrentDeckToTwist()
 	{
 		if (!RankMgr.IsCurrentTwistSeasonActive())
 		{
@@ -587,12 +580,12 @@ public class DeckOptionsMenu : MonoBehaviour
 
 	private void OnCopyButtonReleased(UIEvent e)
 	{
-		m_deckInfo.Hide();
-		CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-		ClipboardUtils.CopyToClipboard(editedDeck.GetShareableDeck().Serialize());
-		UIStatus.Get().AddInfo(GameStrings.Get("GLUE_COLLECTION_DECK_COPIED_TOAST"));
-		TelemetryManager.Client().SendDeckCopied(editedDeck.ID, editedDeck.GetShareableDeck().Serialize(includeComments: false));
-	}
+			m_deckInfo.Hide();
+			CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+			ClipboardUtils.CopyToClipboard(editedDeck.GetShareableDeck().Serialize());
+			UIStatus.Get().AddInfo(GameStrings.Get("GLUE_COLLECTION_DECK_COPIED_TOAST"));
+			TelemetryManager.Client().SendDeckCopied(editedDeck.ID, editedDeck.GetShareableDeck().Serialize(includeComments: false));
+		}
 
 	private bool ShowCopyDeckButton()
 	{
@@ -719,4 +712,22 @@ public class DeckOptionsMenu : MonoBehaviour
 		}
 		return true;
 	}
+
+	#region Accessibility
+			internal static Map<FormatType, string> s_FORMAT_TO_SWITCH_STRING = new Map<FormatType, string>
+			{
+				{
+					FormatType.FT_STANDARD,
+					"GLUE_COLLECTION_TO_STANDARD"
+				},
+				{
+					FormatType.FT_WILD,
+					"GLUE_COLLECTION_TO_WILD"
+			},
+			{
+				FormatType.FT_TWIST,
+				"GLUE_COLLECTION_TO_TWIST"
+			}
+		};
+		#endregion
 }
diff --git a/Assembly-CSharp/DeckPickerTrayDisplay.cs b/Assembly-CSharp/DeckPickerTrayDisplay.cs
index 76e757d..03dad93 100644
--- a/Assembly-CSharp/DeckPickerTrayDisplay.cs
+++ b/Assembly-CSharp/DeckPickerTrayDisplay.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using System.Linq;
 using Assets;
 using Blizzard.T5.Configuration;
+using Blizzard.T5.Jobs;
 using Blizzard.T5.MaterialService.Extensions;
 using Blizzard.Telemetry.WTCG.Client;
 using Hearthstone.Core;
@@ -13,9 +14,10 @@ using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
 using UnityEngine.Serialization;
+using Accessibility;
 
 [CustomEditClass]
-public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
+public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay, AccessibleScreen
 {
 	[Serializable]
 	public class ModeTextures
@@ -58,23 +60,23 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			switch (visualsFormatType)
 			{
-			case VisualsFormatType.VFT_STANDARD:
-				return standardTex;
-			case VisualsFormatType.VFT_WILD:
-				return wildTex;
-			case VisualsFormatType.VFT_CLASSIC:
-				return classicTex;
+				case VisualsFormatType.VFT_STANDARD:
+					return standardTex;
+				case VisualsFormatType.VFT_WILD:
+					return wildTex;
+				case VisualsFormatType.VFT_CLASSIC:
+					return classicTex;
 			case VisualsFormatType.VFT_TWIST:
 				return classicTex;
-			case VisualsFormatType.VFT_CASUAL:
+				case VisualsFormatType.VFT_CASUAL:
 				if (GameUtils.HasCompletedApprentice() || !(apprenticeTex != null))
 				{
 					return casualTex;
 				}
 				return apprenticeTex;
-			default:
+				default:
 				Debug.LogError("DeckPickerTrayDisplay.GetTextureForFormat does not support " + visualsFormatType);
-				return null;
+					return null;
 			}
 		}
 
@@ -82,19 +84,19 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			switch (visualsFormatType)
 			{
-			case VisualsFormatType.VFT_STANDARD:
-				return customStandardTex;
-			case VisualsFormatType.VFT_WILD:
-				return customWildTex;
-			case VisualsFormatType.VFT_CLASSIC:
-				return customClassicTex;
+				case VisualsFormatType.VFT_STANDARD:
+					return customStandardTex;
+				case VisualsFormatType.VFT_WILD:
+					return customWildTex;
+				case VisualsFormatType.VFT_CLASSIC:
+					return customClassicTex;
 			case VisualsFormatType.VFT_TWIST:
 				return customClassicTex;
-			case VisualsFormatType.VFT_CASUAL:
-				return customCasualTex;
-			default:
+				case VisualsFormatType.VFT_CASUAL:
+					return customCasualTex;
+				default:
 				Debug.LogError("DeckPickerTrayDisplay.GetCustomTextureForFormat does not support " + visualsFormatType);
-				return null;
+					return null;
 			}
 		}
 	}
@@ -519,6 +521,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_currentMedalInfo = RankMgr.Get().GetLocalPlayerMedalInfo().GetCurrentMedalForCurrentFormatType();
 		m_formatTypePickerWidget = WidgetInstance.Create(FORMAT_TYPE_PICKER_POPUP_PREFAB);
 		m_formatTypePickerWidget.Hide();
+		AccessibleFormatTypePickerPopup.Hide();
 		m_formatTypePickerWidget.RegisterReadyListener(delegate
 		{
 			OnFormatTypePickerPopupReady();
@@ -658,22 +661,22 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			PegasusShared.FormatType formatType = Options.GetFormatType();
 			switch (formatType)
 			{
-			case PegasusShared.FormatType.FT_WILD:
-				key = "GLUE_CREATE_WILD_DECK";
-				break;
-			case PegasusShared.FormatType.FT_STANDARD:
-				key = "GLUE_CREATE_STANDARD_DECK";
-				break;
-			case PegasusShared.FormatType.FT_CLASSIC:
-				key = "GLUE_CREATE_CLASSIC_DECK";
-				break;
+				case PegasusShared.FormatType.FT_WILD:
+					key = "GLUE_CREATE_WILD_DECK";
+					break;
+				case PegasusShared.FormatType.FT_STANDARD:
+					key = "GLUE_CREATE_STANDARD_DECK";
+					break;
+				case PegasusShared.FormatType.FT_CLASSIC:
+					key = "GLUE_CREATE_CLASSIC_DECK";
+					break;
 			case PegasusShared.FormatType.FT_TWIST:
 				key = "GLUE_CREATE_TWIST_DECK";
 				break;
-			default:
-				Debug.LogError("DeckPickerTrayDisplay.UpdateCreateDeckText called in unsupported format type: " + formatType);
-				SetHeaderText("UNSUPPORTED DECK TEXT " + formatType);
-				return;
+				default:
+					Debug.LogError("DeckPickerTrayDisplay.UpdateCreateDeckText called in unsupported format type: " + formatType);
+					SetHeaderText("UNSUPPORTED DECK TEXT " + formatType);
+					return;
 			}
 		}
 		SetHeaderText(GameStrings.Get(key));
@@ -740,18 +743,18 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		base.HandleGameStartupFailure();
 		switch (SceneMgr.Get().GetMode())
 		{
-		case SceneMgr.Mode.ADVENTURE:
-			if (AdventureConfig.Get().CurrentSubScene == AdventureData.Adventuresubscene.PRACTICE)
-			{
-				PracticePickerTrayDisplay.Get().OnGameDenied();
-			}
-			break;
-		case SceneMgr.Mode.TOURNAMENT:
-			if (PresenceMgr.Get().CurrentStatus == Global.PresenceStatus.PLAY_QUEUE)
-			{
-				PresenceMgr.Get().SetPrevStatus();
-			}
-			break;
+			case SceneMgr.Mode.ADVENTURE:
+				if (AdventureConfig.Get().CurrentSubScene == AdventureData.Adventuresubscene.PRACTICE)
+				{
+					PracticePickerTrayDisplay.Get().OnGameDenied();
+				}
+				break;
+			case SceneMgr.Mode.TOURNAMENT:
+				if (PresenceMgr.Get().CurrentStatus == Global.PresenceStatus.PLAY_QUEUE)
+				{
+					PresenceMgr.Get().SetPrevStatus();
+				}
+				break;
 		}
 	}
 
@@ -880,7 +883,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 
 	public void ShowSwitchToWildTutorialIfNecessary()
 	{
-		if (!(m_switchFormatPopup != null) && !CollectionManager.Get().ShouldSeeTwistModeNotification() && UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_INTRO, "DeckPickerTrayDisplay.ShowSwitchToWildTutorialIfNecessary"))
+		if (!(m_switchFormatPopup != null) && !CollectionManager.Get().ShouldSeeTwistModeNotification() && UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_INTRO, "DeckPickerTrayDisplay.ShowSwitchToWildTutorialIfNecessary"))
 		{
 			if (Options.GetFormatType() == PegasusShared.FormatType.FT_WILD)
 			{
@@ -908,7 +911,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 
 	public void ShowNewTwistModePopupIfNecessary(float delaySeconds = 0f)
 	{
-		if (!(m_switchFormatPopup != null) && !m_switchFormatButton.IsCovered() && CollectionManager.Get().ShouldSeeTwistModeNotification() && !TwistDetailsDisplayManager.TwistSeasonInfoModel.ShouldShowTwistLoginPopup)
+		if (!(m_switchFormatPopup != null) && !m_switchFormatButton.IsCovered() && CollectionManager.Get().ShouldSeeTwistModeNotification() && !TwistDetailsDisplayManager.TwistSeasonInfoModel.ShouldShowTwistLoginPopup && !AccessibilityMgr.IsAccessibilityEnabled())
 		{
 			StartCoroutine(ShowNewTwistModePopup(delaySeconds));
 		}
@@ -1051,7 +1054,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 
 	protected override IEnumerator InitDeckDependentElements()
 	{
-		Log.PlayModeInvestigation.PrintInfo("DeckPickerTrayDisplay.InitDeckDependentElements() called");
+		Log.PlayModeInvestigation.PrintInfo("DeckPickerTrayDisplay.InitDeckDependentElements() called", Array.Empty<object>());
 		bool flag = IsChoosingHero();
 		DeckPickerMode defaultDeckPickerMode = (m_deckPickerMode = DeckPickerMode.CUSTOM);
 		m_numPagesToShow = 1;
@@ -1107,6 +1110,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		CreateCustomDeckPage(CustomDeckPage.PageType.RESERVE);
 		SetupPageDecksBasedOnFormat(VisualsFormatTypeExtensions.GetCurrentVisualsFormatType(), decks);
 		UpdateDeckVisuals();
+
+		OnSetupDeckPages();
 	}
 
 	private int GetDeckPageCount(int numberOfDecks)
@@ -1127,50 +1132,50 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		SetMissingTwistDeckActive(active: false);
 		switch (mode)
 		{
-		case SceneMgr.Mode.TOURNAMENT:
-			m_rankedPlayDisplayWidget = WidgetInstance.Create(UniversalInputManager.UsePhoneUI ? "RankedPlayDisplay_phone.prefab:22b0793a4bc044e47a1948619c2aa896" : "RankedPlayDisplay.prefab:1f884a817dbbdd84b9f8713dc21759f1");
-			m_rankedPlayDisplayWidget.RegisterReadyListener(delegate
-			{
-				OnRankedPlayDisplayWidgetReady();
-			});
+			case SceneMgr.Mode.TOURNAMENT:
+				m_rankedPlayDisplayWidget = WidgetInstance.Create(UniversalInputManager.UsePhoneUI ? "RankedPlayDisplay_phone.prefab:22b0793a4bc044e47a1948619c2aa896" : "RankedPlayDisplay.prefab:1f884a817dbbdd84b9f8713dc21759f1");
+				m_rankedPlayDisplayWidget.RegisterReadyListener(delegate
+				{
+					OnRankedPlayDisplayWidgetReady();
+				});
 			UpdateApprenticeProgressInfo();
-			SetPlayButtonText(GameStrings.Get("GLOBAL_PLAY"));
-			ChangePlayButtonTextAlpha();
-			UpdateRankedClassWinsPlate();
-			UpdatePageArrows();
+				SetPlayButtonText(GameStrings.Get("GLOBAL_PLAY"));
+				ChangePlayButtonTextAlpha();
+				UpdateRankedClassWinsPlate();
+				UpdatePageArrows();
 			if (Options.GetFormatType() == PegasusShared.FormatType.FT_TWIST && CollectionManager.Get().GetNumberOfTwistDecks() == 0)
-			{
+				{
 				SetMissingTwistDeckActive(active: true);
-			}
-			break;
-		case SceneMgr.Mode.TAVERN_BRAWL:
-			SetHeaderForTavernBrawl();
-			break;
+				}
+				break;
+			case SceneMgr.Mode.TAVERN_BRAWL:
+				SetHeaderForTavernBrawl();
+				break;
 		}
 		UnityEngine.Vector2 keyholeTextureOffsets = new UnityEngine.Vector2(0f, 0f);
 		m_currentModeTextures = m_collectionTextures;
 		switch (mode)
 		{
-		case SceneMgr.Mode.ADVENTURE:
-			m_currentModeTextures = m_adventureTextures;
-			keyholeTextureOffsets.x = 0.5f;
-			break;
-		case SceneMgr.Mode.COLLECTIONMANAGER:
-			m_currentModeTextures = m_collectionTextures;
-			break;
-		case SceneMgr.Mode.TAVERN_BRAWL:
-			m_currentModeTextures = m_tavernBrawlTextures;
-			keyholeTextureOffsets.x = 0.5f;
-			keyholeTextureOffsets.y = 0.61f;
-			break;
-		case SceneMgr.Mode.TOURNAMENT:
-			m_currentModeTextures = m_tournamentTextures;
-			break;
-		case SceneMgr.Mode.FRIENDLY:
-			m_currentModeTextures = m_friendlyTextures;
-			keyholeTextureOffsets.y = 0.61f;
-			break;
-		}
+			case SceneMgr.Mode.ADVENTURE:
+				m_currentModeTextures = m_adventureTextures;
+				keyholeTextureOffsets.x = 0.5f;
+				break;
+			case SceneMgr.Mode.COLLECTIONMANAGER:
+				m_currentModeTextures = m_collectionTextures;
+				break;
+			case SceneMgr.Mode.TAVERN_BRAWL:
+				m_currentModeTextures = m_tavernBrawlTextures;
+				keyholeTextureOffsets.x = 0.5f;
+				keyholeTextureOffsets.y = 0.61f;
+				break;
+			case SceneMgr.Mode.TOURNAMENT:
+				m_currentModeTextures = m_tournamentTextures;
+				break;
+			case SceneMgr.Mode.FRIENDLY:
+						m_currentModeTextures = m_friendlyTextures;
+						keyholeTextureOffsets.y = 0.61f;
+						break;
+					}
 		VisualsFormatType currentVisualsFormatType = VisualsFormatTypeExtensions.GetCurrentVisualsFormatType();
 		Texture textureForFormat = m_currentModeTextures.GetTextureForFormat(currentVisualsFormatType);
 		Texture customTextureForFormat = m_currentModeTextures.GetCustomTextureForFormat(currentVisualsFormatType);
@@ -1387,19 +1392,19 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			if (SceneMgr.Get().GetMode() == SceneMgr.Mode.TOURNAMENT && SetRotationManager.HasSeenStandardModeTutorial())
 			{
-				if (newVisualsFormatType == VisualsFormatType.VFT_WILD && !Options.Get().GetBool(Option.HAS_SEEN_WILD_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_WILD_MODE_VO))
+				if (newVisualsFormatType == VisualsFormatType.VFT_WILD && !Options.Get().GetBool(Option.HAS_SEEN_WILD_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_WILD_MODE_VO))
 				{
 					HideSetRotationNotifications();
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_WILD_GAME"), "VO_INNKEEPER_Male_Dwarf_SetRotation_35.prefab:db2f6e3818fa49b4d8423121eba762f6");
 					Options.Get().SetBool(Option.HAS_SEEN_WILD_MODE_VO, val: true);
 				}
-				if (newVisualsFormatType == VisualsFormatType.VFT_CLASSIC && !Options.Get().GetBool(Option.HAS_SEEN_CLASSIC_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_CLASSIC_MODE_VO))
+				if (newVisualsFormatType == VisualsFormatType.VFT_CLASSIC && !Options.Get().GetBool(Option.HAS_SEEN_CLASSIC_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_CLASSIC_MODE_VO))
 				{
 					HideSetRotationNotifications();
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_CLASSIC_TAKES_YOU_BACK_ORIGINAL_HEARTHSTONE"), "VO_Innkeeper_Male_Dwarf_ClassicMode_06.prefab:f91da6f7e66fd754fb4e568d15d49116");
 					Options.Get().SetBool(Option.HAS_SEEN_CLASSIC_MODE_VO, val: true);
 				}
-				if (newVisualsFormatType == VisualsFormatType.VFT_TWIST && !Options.Get().GetBool(Option.HAS_SEEN_TWIST_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_TWIST_MODE_VO))
+				if (newVisualsFormatType == VisualsFormatType.VFT_TWIST && !Options.Get().GetBool(Option.HAS_SEEN_TWIST_MODE_VO) && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickerTrayDisplay.UpdateFormat_Tournament:" + Option.HAS_SEEN_TWIST_MODE_VO))
 				{
 					HideSetRotationNotifications();
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, INNKEEPER_QUOTE_POS, GameStrings.Get("GLUE_TWIST_NEW_MODE"), "");
@@ -1581,7 +1586,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 
 	private void InitDeckPages()
 	{
-		Log.PlayModeInvestigation.PrintInfo("DeckPickerTrayDisplay.InitDeckPages() called." + $"m_numPagesToShow={m_numPagesToShow}, m_customPages.Count={m_customPages.Count}");
+		Log.PlayModeInvestigation.PrintInfo("DeckPickerTrayDisplay.InitDeckPages() called." + $"m_numPagesToShow={m_numPagesToShow}, m_customPages.Count={m_customPages.Count}", Array.Empty<object>());
 		if (m_numPagesToShow <= 0)
 		{
 			Debug.LogWarning("DeckPickerTrayDisplay.InitDeckPages() called with invalid amount of pages");
@@ -1596,7 +1601,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			CustomDeckPage customDeckPage = m_customPages[m_customPages.Count - 1];
 			m_customPages.Remove(customDeckPage);
 			UnityEngine.Object.Destroy(customDeckPage.gameObject);
-			Log.PlayModeInvestigation.PrintInfo("DeckPickerTrayDisplay.InitDeckPages() -- Deck page removed." + $"New total: {m_customPages.Count}");
+			Log.PlayModeInvestigation.PrintInfo("DeckPickerTrayDisplay.InitDeckPages() -- Deck page removed." + $"New total: {m_customPages.Count}", Array.Empty<object>());
 		}
 		for (int i = 0; i < m_customPages.Count; i++)
 		{
@@ -2206,7 +2211,9 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_formatTypePickerWidget.transform.position = new Vector3(0f, m_formatTypePickerYOffset, 0f);
 		m_formatTypePickerWidget.Show();
 		UpdateAvailableFormatOptions();
+
 		m_formatTypePickerWidget.TriggerEvent("OPEN", new TriggerEventParameters(null, m_visualsFormatType));
+		AccessibleFormatTypePickerPopup.Show(m_formatTypePickerWidget);
 	}
 
 	public void ShowPopupDuringSetRotation(VisualsFormatType visualsFormatType)
@@ -2215,6 +2222,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_formatTypePickerWidget.transform.position = new Vector3(0f, m_formatTypePickerYOffset, 0f);
 		m_formatTypePickerWidget.Show();
 		m_formatTypePickerWidget.TriggerEvent("SET_ROTATION_OPEN", new TriggerEventParameters(null, (int)visualsFormatType));
+				AccessibleFormatTypePickerPopup.Show(m_formatTypePickerWidget);
 	}
 
 	public void SwitchFormatTypeAndRankedPlayMode(VisualsFormatType newVisualsFormatType)
@@ -2242,16 +2250,16 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		SceneMgr.Mode mode = SceneMgr.Get().GetMode();
 		switch (mode)
 		{
-		case SceneMgr.Mode.COLLECTIONMANAGER:
-			UpdateCreateDeckText();
-			UpdateFormat_CollectionManager();
-			break;
-		case SceneMgr.Mode.TOURNAMENT:
-			UpdateFormat_Tournament(newVisualsFormatType);
-			TournamentDisplay.Get().UpdateHeaderText();
-			m_rankedPlayDisplay.OnSwitchFormat(newVisualsFormatType);
+			case SceneMgr.Mode.COLLECTIONMANAGER:
+				UpdateCreateDeckText();
+				UpdateFormat_CollectionManager();
+				break;
+			case SceneMgr.Mode.TOURNAMENT:
+				UpdateFormat_Tournament(newVisualsFormatType);
+				TournamentDisplay.Get().UpdateHeaderText();
+				m_rankedPlayDisplay.OnSwitchFormat(newVisualsFormatType);
 			ToggleApprenticeProgressTray(newVisualsFormatType == VisualsFormatType.VFT_CASUAL);
-			break;
+				break;
 		}
 		SetMissingTwistDeckActive(active: false);
 		if (newVisualsFormatType == VisualsFormatType.VFT_TWIST && mode == SceneMgr.Mode.TOURNAMENT && CollectionManager.Get().GetNumberOfTwistDecks() == 0)
@@ -2262,7 +2270,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_formatTypePickerWidget.TriggerEvent("HIDE");
 		if (CanSwitchFormats())
 		{
-			StartCoroutine(m_switchFormatButton.EnableWithDelay(0.8f));
+		StartCoroutine(m_switchFormatButton.EnableWithDelay(0.8f));
 		}
 		StartCoroutine(DisableIsModeSwitchShowing(0.8f));
 		if (mode != SceneMgr.Mode.TOURNAMENT)
@@ -2270,8 +2278,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			return;
 		}
 		DeckPickerTrayDisplay capturedThis = this;
-		if (ShouldShowRotatedBoosterPopup(newVisualsFormatType))
-		{
+			if (ShouldShowRotatedBoosterPopup(newVisualsFormatType))
+			{
 			Action callbackOnHide = delegate
 			{
 				if (capturedThis != null)
@@ -2280,9 +2288,9 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 				}
 			};
 			StartCoroutine(ShowRotatedBoostersPopup(callbackOnHide));
-		}
-		else if (ShouldShowStandardDeckVO(newVisualsFormatType))
-		{
+			}
+			else if (ShouldShowStandardDeckVO(newVisualsFormatType))
+			{
 			Action<int> finishedCallback = delegate
 			{
 				if (capturedThis != null)
@@ -2291,7 +2299,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 				}
 			};
 			StartCoroutine(ShowStandardDeckVO(finishedCallback));
-		}
+			}
 		else
 		{
 			StartCoroutine(ShowIntroPopupsIfNeeded_Routine(1f));
@@ -2332,49 +2340,49 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		}
 		switch ((SceneMgr.Get() != null) ? SceneMgr.Get().GetMode() : SceneMgr.Mode.INVALID)
 		{
-		case SceneMgr.Mode.COLLECTIONMANAGER:
-		case SceneMgr.Mode.TAVERN_BRAWL:
-		{
-			CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-			if (CollectionDeckTray.Get() != null)
-			{
-				CollectionDeckTray.Get().GetDecksContent().CreateNewDeckCancelled();
-			}
-			if (Get() != null && !Get().m_heroChosen && collectionManagerDisplay != null)
-			{
-				collectionManagerDisplay.CancelSelectNewDeckHeroMode();
-			}
-			if (HeroPickerDisplay.Get() != null)
-			{
-				HeroPickerDisplay.Get().HideTray();
-			}
-			PresenceMgr.Get().SetPrevStatus();
-			if (SceneMgr.Get().IsInTavernBrawlMode())
-			{
-				TavernBrawlDisplay.Get().EnablePlayButton();
-			}
-			if (collectionManagerDisplay != null)
-			{
-				DeckTemplatePicker deckTemplatePicker = (UniversalInputManager.UsePhoneUI ? collectionManagerDisplay.GetPhoneDeckTemplateTray() : collectionManagerDisplay.m_pageManager.GetDeckTemplatePicker());
-				if (deckTemplatePicker != null)
+			case SceneMgr.Mode.COLLECTIONMANAGER:
+			case SceneMgr.Mode.TAVERN_BRAWL:
+				{
+					CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+					if (CollectionDeckTray.Get() != null)
+					{
+						CollectionDeckTray.Get().GetDecksContent().CreateNewDeckCancelled();
+					}
+					if (Get() != null && !Get().m_heroChosen && collectionManagerDisplay != null)
+					{
+						collectionManagerDisplay.CancelSelectNewDeckHeroMode();
+					}
+					if (HeroPickerDisplay.Get() != null)
+					{
+						HeroPickerDisplay.Get().HideTray();
+					}
+					PresenceMgr.Get().SetPrevStatus();
+					if (SceneMgr.Get().IsInTavernBrawlMode())
+					{
+						TavernBrawlDisplay.Get().EnablePlayButton();
+					}
+					if (collectionManagerDisplay != null)
+					{
+						DeckTemplatePicker deckTemplatePicker = (UniversalInputManager.UsePhoneUI ? collectionManagerDisplay.GetPhoneDeckTemplateTray() : collectionManagerDisplay.m_pageManager.GetDeckTemplatePicker());
+						if (deckTemplatePicker != null)
+						{
+							Navigation.RemoveHandler(deckTemplatePicker.OnNavigateBack);
+						}
+					}
+					break;
+				}
+			case SceneMgr.Mode.TOURNAMENT:
+				BackOutToHub();
+				GameMgr.Get().CancelFindGame();
+				break;
+			case SceneMgr.Mode.ADVENTURE:
+				AdventureConfig.Get().SubSceneGoBack();
+				if (AdventureConfig.Get().CurrentSubScene == AdventureData.Adventuresubscene.PRACTICE)
 				{
-					Navigation.RemoveHandler(deckTemplatePicker.OnNavigateBack);
+					PracticePickerTrayDisplay.Get().gameObject.SetActive(value: false);
 				}
-			}
-			break;
-		}
-		case SceneMgr.Mode.TOURNAMENT:
-			BackOutToHub();
-			GameMgr.Get().CancelFindGame();
-			break;
-		case SceneMgr.Mode.ADVENTURE:
-			AdventureConfig.Get().SubSceneGoBack();
-			if (AdventureConfig.Get().CurrentSubScene == AdventureData.Adventuresubscene.PRACTICE)
-			{
-				PracticePickerTrayDisplay.Get().gameObject.SetActive(value: false);
-			}
-			GameMgr.Get().CancelFindGame();
-			break;
+				GameMgr.Get().CancelFindGame();
+				break;
 		}
 		return base.OnNavigateBackImplementation();
 	}
@@ -2402,7 +2410,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		ShowPage(m_currentPageIndex - 1, skipTraySlidingAnimation);
 	}
 
-	private void ShowPage(int pageNum, bool skipTraySlidingAnimation = false)
+	internal void ShowPage(int pageNum, bool skipTraySlidingAnimation = false)
 	{
 		if (iTween.Count(m_randomDeckPickerTray) > 0 || pageNum < 0 || pageNum >= m_customPages.Count)
 		{
@@ -2501,8 +2509,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			}
 			else
 			{
-				twistDetailsDisplayManager.HideTwistHeaderPanel();
-			}
+			twistDetailsDisplayManager.HideTwistHeaderPanel();
+		}
 		}
 		else if (isPagingForward)
 		{
@@ -2720,6 +2728,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			loanerDeckDisplay.SetSelectedDeckInDataModel(deckbox.m_isLoanerDeck);
 		}
+
+		OnSelectedDeck(deckbox);
 		m_heroActor.UpdateDeckRunesComponent(deckbox.GetCollectionDeck());
 		return true;
 	}
@@ -2751,16 +2761,16 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		}
 		PegasusShared.FormatType? formatTypeToValidateAgainst = deckBox.GetFormatTypeToValidateAgainst();
 		CollectionDeck.CardCountByStatus cardCountByStatus = collectionDeck.CountCardsByStatus(formatTypeToValidateAgainst);
-		if (cardCountByStatus.Extra > 0)
-		{
-			HandleExtraCards(collectionDeck, cardCountByStatus);
+			if (cardCountByStatus.Extra > 0)
+			{
+				HandleExtraCards(collectionDeck, cardCountByStatus);
 			return;
-		}
+			}
 		if (cardCountByStatus.MissingPlusInvalid > 0)
-		{
-			HandleMissingAndInvalidCards(collectionDeck, cardCountByStatus);
+			{
+				HandleMissingAndInvalidCards(collectionDeck, cardCountByStatus);
 			return;
-		}
+			}
 		int invalidSideboardCardCount = collectionDeck.GetInvalidSideboardCardCount(formatTypeToValidateAgainst);
 		if (invalidSideboardCardCount > 0)
 		{
@@ -2775,24 +2785,24 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		AlertPopup.PopupInfo popupInfo2;
 		if (enableClickToFixDeck)
 		{
-			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-			popupInfo.m_showAlertIcon = false;
-			popupInfo.m_alertTextAlignment = UberText.AlignmentOptions.Center;
-			popupInfo.m_confirmText = GameStrings.Get("GLOBAL_BUTTON_YES");
-			popupInfo.m_cancelText = GameStrings.Get("GLOBAL_BUTTON_NO");
-			popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL;
-			popupInfo.m_headerText = GameStrings.FormatPlurals("GLUE_COLLECTION_DECK_EXTRA_CARDS_POPUP_HEADER", pluralNumbers);
-			popupInfo.m_text = GameStrings.Format("GLUE_COLLECTION_DECK_EXTRA_CARDS_POPUP_TEXT", deckCardCount.Extra);
+		AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+		popupInfo.m_showAlertIcon = false;
+		popupInfo.m_alertTextAlignment = UberText.AlignmentOptions.Center;
+		popupInfo.m_confirmText = GameStrings.Get("GLOBAL_BUTTON_YES");
+		popupInfo.m_cancelText = GameStrings.Get("GLOBAL_BUTTON_NO");
+		popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL;
+		popupInfo.m_headerText = GameStrings.FormatPlurals("GLUE_COLLECTION_DECK_EXTRA_CARDS_POPUP_HEADER", pluralNumbers);
+		popupInfo.m_text = GameStrings.Format("GLUE_COLLECTION_DECK_EXTRA_CARDS_POPUP_TEXT", deckCardCount.Extra);
 			popupInfo2 = popupInfo;
-			popupInfo2.m_responseCallback = delegate(AlertPopup.Response response, object userData)
+		popupInfo2.m_responseCallback = delegate (AlertPopup.Response response, object userData)
+		{
+			if (response == AlertPopup.Response.CONFIRM && !deck.IsSavingChanges())
 			{
-				if (response == AlertPopup.Response.CONFIRM && !deck.IsSavingChanges())
-				{
-					deck.RemoveExtraCards(Options.GetFormatType());
-					UpdateDeckVisualsAndSelectDeck(deck);
-					deck.SendChanges(CollectionDeck.ChangeSource.ClickToFixExtraCards);
-				}
-			};
+				deck.RemoveExtraCards(Options.GetFormatType());
+				UpdateDeckVisualsAndSelectDeck(deck);
+				deck.SendChanges(CollectionDeck.ChangeSource.ClickToFixExtraCards);
+			}
+		};
 		}
 		else
 		{
@@ -2811,36 +2821,36 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		AlertPopup.PopupInfo popupInfo;
 		if (NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().EnableClickToFixDeck)
 		{
-			if (CollectionManager.Get().HasPendingSmartDeckRequest(deck.ID))
-			{
-				return;
-			}
+		if (CollectionManager.Get().HasPendingSmartDeckRequest(deck.ID))
+		{
+			return;
+		}
 			popupInfo = new AlertPopup.PopupInfo
+		{
+			m_showAlertIcon = false,
+			m_alertTextAlignment = UberText.AlignmentOptions.Center,
+			m_confirmText = GameStrings.Get("GLOBAL_BUTTON_YES"),
+			m_cancelText = GameStrings.Get("GLOBAL_BUTTON_NO"),
+			m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL,
+			m_headerText = GameStrings.Get("GLUE_COLLECTION_DECK_INCOMPLETE_POPUP_HEADER")
+		};
+		int num = deck.GetSlots().Count((CollectionDeckSlot slot) => RankMgr.Get().IsCardLockedInCurrentLeague(slot.GetEntityDef()));
+		if (num > 0)
+		{
+			popupInfo.m_text = GameStrings.Format("GLUE_COLLECTION_DECK_INCOMPLETE_POPUP_TEXT_NPR", num);
+		}
+		else
+		{
+			popupInfo.m_text = GameStrings.Format("GLUE_COLLECTION_DECK_INCOMPLETE_POPUP_TEXT", deckCardCount.MissingPlusInvalid);
+		}
+		popupInfo.m_responseCallback = delegate (AlertPopup.Response response, object userData)
+		{
+			if (response == AlertPopup.Response.CONFIRM && !deck.IsSavingChanges())
 			{
-				m_showAlertIcon = false,
-				m_alertTextAlignment = UberText.AlignmentOptions.Center,
-				m_confirmText = GameStrings.Get("GLOBAL_BUTTON_YES"),
-				m_cancelText = GameStrings.Get("GLOBAL_BUTTON_NO"),
-				m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL,
-				m_headerText = GameStrings.Get("GLUE_COLLECTION_DECK_INCOMPLETE_POPUP_HEADER")
-			};
-			int num = deck.GetSlots().Count((CollectionDeckSlot slot) => RankMgr.Get().IsCardLockedInCurrentLeague(slot.GetEntityDef()));
-			if (num > 0)
-			{
-				popupInfo.m_text = GameStrings.Format("GLUE_COLLECTION_DECK_INCOMPLETE_POPUP_TEXT_NPR", num);
-			}
-			else
-			{
-				popupInfo.m_text = GameStrings.Format("GLUE_COLLECTION_DECK_INCOMPLETE_POPUP_TEXT", deckCardCount.MissingPlusInvalid);
+				deck.RemoveInvalidCards(Options.GetFormatType());
+				CollectionManager.Get().AutoFillDeck(deck, allowSmartDeckCompletion: true, OnClickToFixAutoFillCallback);
 			}
-			popupInfo.m_responseCallback = delegate(AlertPopup.Response response, object userData)
-			{
-				if (response == AlertPopup.Response.CONFIRM && !deck.IsSavingChanges())
-				{
-					deck.RemoveInvalidCards(Options.GetFormatType());
-					CollectionManager.Get().AutoFillDeck(deck, allowSmartDeckCompletion: true, OnClickToFixAutoFillCallback);
-				}
-			};
+		};
 		}
 		else
 		{
@@ -2922,22 +2932,22 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		Options.Get().SetInt(Option.LAST_PRECON_HERO_CHOSEN, (int)button.m_heroClass);
 		if (button.IsLocked())
 		{
-			HeroPickerLockedStatus heroPickerLockedStatus = IsHeroPickerButtonLocked(button.m_heroClass);
+		HeroPickerLockedStatus heroPickerLockedStatus = IsHeroPickerButtonLocked(button.m_heroClass);
 			button.GetEntityDef().GetShortName();
-			switch (heroPickerLockedStatus)
-			{
-			case HeroPickerLockedStatus.LOCKED_HERO_UNLOCK_NOT_DONE:
+		switch (heroPickerLockedStatus)
+		{
+		case HeroPickerLockedStatus.LOCKED_HERO_UNLOCK_NOT_DONE:
 			{
 				int apprenticeTrackLevelForHeroClassUnlock = GetApprenticeTrackLevelForHeroClassUnlock(button.m_heroClass);
 				AddHeroLockedTooltip(GameStrings.Get("GLUE_HERO_LOCKED_NAME"), GameStrings.Format("GLUE_HERO_LOCKED_DESC", apprenticeTrackLevelForHeroClassUnlock), button.m_heroClass);
-				break;
-			}
-			case HeroPickerLockedStatus.LOCKED_IN_TWIST_SCENARIO:
-				AddHeroLockedTooltip(GameStrings.Get("GLUE_HERO_LOCKED_NAME"), GameStrings.Get("GLUE_EXCLUDED_IN_TWIST_SCENARIO"), heroPickerLockedStatus, button.m_heroClass);
-				break;
+			break;
 			}
+		case HeroPickerLockedStatus.LOCKED_IN_TWIST_SCENARIO:
+			AddHeroLockedTooltip(GameStrings.Get("GLUE_HERO_LOCKED_NAME"), GameStrings.Get("GLUE_EXCLUDED_IN_TWIST_SCENARIO"), heroPickerLockedStatus, button.m_heroClass);
+			break;
 		}
 	}
+	}
 
 	private int GetApprenticeTrackLevelForHeroClassUnlock(TAG_CLASS heroClass)
 	{
@@ -3059,10 +3069,10 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			return;
 		}
 		if (m_rewardTrack == null)
-		{
+			{
 			m_rewardTrack = RewardTrackManager.Get().GetRewardTrack(Global.RewardTrackType.APPRENTICE);
 			if (!m_rewardTrack.IsValid || m_rewardTrack.TrackDataModel == null)
-			{
+				{
 				Log.All.PrintError("Unable to update ranked display for apprentice when data isn't ready");
 				return;
 			}
@@ -3093,9 +3103,9 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 				ChooseOne = freeRewardListRecord.ChooseOne,
 				Description = description,
 				Items = dataModelList
-			};
+				};
 			rewardTrackNodeRewardsDataModel = new RewardTrackNodeRewardsDataModel
-			{
+				{
 				Level = rewardTrackLevelDbfRecord.Level,
 				IsClaimable = flag,
 				IsClaimed = false,
@@ -3104,16 +3114,16 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 				RewardTrackType = (int)m_rewardTrack.TrackDataModel.RewardTrackType,
 				Items = items,
 				Summary = summary
-			};
-		}
+				};
+			}
 		if (rewardTrackNodeRewardsDataModel != null)
 		{
 			m_apprenticeProgressWidget.BindDataModel(rewardTrackNodeRewardsDataModel);
 		}
-		else
-		{
+			else
+			{
 			m_apprenticeProgressWidget.UnbindDataModel(236);
-		}
+			}
 		if (m_apprenticeRewardPopupWidget != null)
 		{
 			if (rewardTrackNodeRewardsDataModel != null)
@@ -3199,17 +3209,17 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	private void UpdateHeroInfo(CollectionDeckBoxVisual deckBox)
 	{
 		using DefLoader.DisposableFullDef fullDef = deckBox.SharedDisposableFullDef();
-		UpdateHeroInfo(fullDef, deckBox.GetDeckNameText().Text, deckBox.GetHeroCardPremium());
-	}
+			UpdateHeroInfo(fullDef, deckBox.GetDeckNameText().Text, deckBox.GetHeroCardPremium());
+		}
 
 	protected override void UpdateHeroInfo(HeroPickerButton button)
 	{
 		using DefLoader.DisposableFullDef disposableFullDef = button.ShareFullDef();
-		string shortName = disposableFullDef.EntityDef.GetShortName();
-		string heroName = ((!string.IsNullOrEmpty(shortName)) ? shortName : disposableFullDef.EntityDef.GetName());
-		TAG_PREMIUM heroPremium = CollectionManager.Get().GetHeroPremium(disposableFullDef.EntityDef.GetClass());
-		UpdateHeroInfo(disposableFullDef, heroName, heroPremium, button.IsLocked());
-	}
+			string shortName = disposableFullDef.EntityDef.GetShortName();
+			string heroName = ((!string.IsNullOrEmpty(shortName)) ? shortName : disposableFullDef.EntityDef.GetName());
+			TAG_PREMIUM heroPremium = CollectionManager.Get().GetHeroPremium(disposableFullDef.EntityDef.GetClass());
+			UpdateHeroInfo(disposableFullDef, heroName, heroPremium, button.IsLocked());
+		}
 
 	private void UpdateHeroInfo(DefLoader.DisposableFullDef fullDef, string heroName, TAG_PREMIUM premium, bool locked = false)
 	{
@@ -3221,7 +3231,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_heroActor.SetUnlit();
 		NetCache.HeroLevel heroLevel = ((!locked) ? GameUtils.GetHeroLevel(fullDef.EntityDef.GetClass()) : null);
 		int valueOrDefault = GameUtils.GetTotalHeroLevel().GetValueOrDefault();
-		m_xpBar.UpdateDisplay(heroLevel, valueOrDefault);
+		m_xpBar.UpdateDisplay(null, heroLevel, valueOrDefault, false);
 		string heroPowerCardIdFromHero = GameUtils.GetHeroPowerCardIdFromHero(fullDef.EntityDef.GetCardId());
 		if (!locked && ShouldShowHeroPower() && !string.IsNullOrEmpty(heroPowerCardIdFromHero))
 		{
@@ -3254,23 +3264,23 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		m_PreviousInRankedPlayMode = inRankedPlayMode;
 		base.TransitionToFormatType(formatType, inRankedPlayMode, transitionSpeed);
 		UpdateTrayBackgroundTransitionValues(visualsFormatType, visualsFormatType2, transitionSpeed);
-		if (!inRankedPlayMode)
-		{
+			if (!inRankedPlayMode)
+			{
 			ToggleApprenticeProgressUI(shouldEnable: true);
 			if (m_rankedPlayDisplay != null)
 			{
 				m_rankedPlayDisplay.Hide(m_rankedPlayDisplayHideDelay);
 			}
 		}
-		else
-		{
-			ToggleApprenticeProgressUI(shouldEnable: false);
-			if (m_rankedPlayDisplay != null)
+			else
 			{
-				m_rankedPlayDisplay.Show(m_rankedPlayDisplayShowDelay);
-				m_rankedPlayDisplay.OnSwitchFormat(visualsFormatType2);
+			ToggleApprenticeProgressUI(shouldEnable: false);
+				if (m_rankedPlayDisplay != null)
+				{
+					m_rankedPlayDisplay.Show(m_rankedPlayDisplayShowDelay);
+					m_rankedPlayDisplay.OnSwitchFormat(visualsFormatType2);
+				}
 			}
-		}
 		UpdateValidHeroClasses();
 		if (m_inHeroPicker && ((visualsFormatType == VisualsFormatType.VFT_TWIST && visualsFormatType2 != VisualsFormatType.VFT_TWIST) || (visualsFormatType != VisualsFormatType.VFT_TWIST && visualsFormatType2 == VisualsFormatType.VFT_TWIST)))
 		{
@@ -3285,23 +3295,23 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		if (m_currentModeTextures != null)
 		{
-			float targetValue = 1f;
-			Texture textureForFormat = m_currentModeTextures.GetTextureForFormat(oldVisualsFormatType);
-			Texture customTextureForFormat = m_currentModeTextures.GetCustomTextureForFormat(oldVisualsFormatType);
-			Texture textureForFormat2 = m_currentModeTextures.GetTextureForFormat(visualsFormatType);
-			Texture customTextureForFormat2 = m_currentModeTextures.GetCustomTextureForFormat(visualsFormatType);
-			SetCustomDeckPageTextures(customTextureForFormat, customTextureForFormat2);
-			if ((bool)UniversalInputManager.UsePhoneUI)
-			{
-				SetPhoneDetailsTrayTextures(textureForFormat, textureForFormat2);
-			}
-			else
-			{
-				SetTrayFrameAndBasicDeckPageTextures(textureForFormat, textureForFormat2);
-			}
-			StopCoroutine("TransitionTrayMaterial");
-			StartCoroutine(TransitionTrayMaterial(targetValue, transitionSpeed));
+		float targetValue = 1f;
+		Texture textureForFormat = m_currentModeTextures.GetTextureForFormat(oldVisualsFormatType);
+		Texture customTextureForFormat = m_currentModeTextures.GetCustomTextureForFormat(oldVisualsFormatType);
+		Texture textureForFormat2 = m_currentModeTextures.GetTextureForFormat(visualsFormatType);
+		Texture customTextureForFormat2 = m_currentModeTextures.GetCustomTextureForFormat(visualsFormatType);
+		SetCustomDeckPageTextures(customTextureForFormat, customTextureForFormat2);
+		if ((bool)UniversalInputManager.UsePhoneUI)
+		{
+			SetPhoneDetailsTrayTextures(textureForFormat, textureForFormat2);
+		}
+		else
+		{
+			SetTrayFrameAndBasicDeckPageTextures(textureForFormat, textureForFormat2);
 		}
+		StopCoroutine("TransitionTrayMaterial");
+		StartCoroutine(TransitionTrayMaterial(targetValue, transitionSpeed));
+	}
 	}
 
 	private void PlayTrayTransitionGlowBursts(VisualsFormatType oldVisualsFormatType, VisualsFormatType visualsFormatType)
@@ -3436,35 +3446,35 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		switch (Box.Get().GetState())
 		{
-		case Box.State.SET_ROTATION_OPEN:
-			if (m_setRotationTutorialState == SetRotationTutorialState.PREPARING)
-			{
+			case Box.State.SET_ROTATION_OPEN:
+				if (m_setRotationTutorialState == SetRotationTutorialState.PREPARING)
+				{
+					return;
+				}
+				break;
+			case Box.State.LOADING:
 				return;
-			}
-			break;
-		case Box.State.LOADING:
-			return;
 		}
 		string text;
 		switch (visualsFormatType)
 		{
-		case VisualsFormatType.VFT_STANDARD:
-			text = m_standardTransitionSound;
-			break;
-		case VisualsFormatType.VFT_WILD:
-		case VisualsFormatType.VFT_CASUAL:
-			text = m_wildTransitionSound;
-			break;
-		case VisualsFormatType.VFT_CLASSIC:
-			text = m_classicTransitionSound;
-			break;
+			case VisualsFormatType.VFT_STANDARD:
+				text = m_standardTransitionSound;
+				break;
+			case VisualsFormatType.VFT_WILD:
+			case VisualsFormatType.VFT_CASUAL:
+				text = m_wildTransitionSound;
+				break;
+			case VisualsFormatType.VFT_CLASSIC:
+				text = m_classicTransitionSound;
+				break;
 		case VisualsFormatType.VFT_TWIST:
 			text = m_classicTransitionSound;
 			break;
-		default:
-			Debug.LogError("No transition sound for format " + visualsFormatType);
-			text = "";
-			break;
+			default:
+				Debug.LogError("No transition sound for format " + visualsFormatType);
+				text = "";
+				break;
 		}
 		if (!string.IsNullOrEmpty(text))
 		{
@@ -3622,24 +3632,24 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		switch (eventName)
 		{
-		case "WILD_BUTTON_CLICKED":
-			SwitchFormatTypeAndRankedPlayMode(VisualsFormatType.VFT_WILD);
-			break;
-		case "STANDARD_BUTTON_CLICKED":
-			SwitchFormatTypeAndRankedPlayMode(VisualsFormatType.VFT_STANDARD);
-			break;
-		case "CLASSIC_BUTTON_CLICKED":
-			SwitchFormatTypeAndRankedPlayMode(VisualsFormatType.VFT_CLASSIC);
-			break;
+			case "WILD_BUTTON_CLICKED":
+				SwitchFormatTypeAndRankedPlayMode(VisualsFormatType.VFT_WILD);
+				break;
+			case "STANDARD_BUTTON_CLICKED":
+				SwitchFormatTypeAndRankedPlayMode(VisualsFormatType.VFT_STANDARD);
+				break;
+			case "CLASSIC_BUTTON_CLICKED":
+				SwitchFormatTypeAndRankedPlayMode(VisualsFormatType.VFT_CLASSIC);
+				break;
 		case "TWIST_BUTTON_CLICKED":
 			SwitchFormatTypeAndRankedPlayMode(VisualsFormatType.VFT_TWIST);
 			break;
-		case "CASUAL_BUTTON_CLICKED":
-			SwitchFormatTypeAndRankedPlayMode(VisualsFormatType.VFT_CASUAL);
-			break;
-		case "HIDE":
-			FireFormatTypePickerClosedEvent();
-			break;
+			case "CASUAL_BUTTON_CLICKED":
+				SwitchFormatTypeAndRankedPlayMode(VisualsFormatType.VFT_CASUAL);
+				break;
+			case "HIDE":
+				FireFormatTypePickerClosedEvent();
+				break;
 		}
 	}
 
@@ -3673,6 +3683,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	{
 		base.SetCollectionButtonEnabled(enable);
 		UpdateCollectionButtonGlow();
+
 	}
 
 	private void UpdateCollectionButtonGlow()
@@ -3705,43 +3716,43 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			Options.SetFormatType(PegasusShared.FormatType.FT_STANDARD);
 			return;
 		}
-		PegasusShared.FormatType formatType;
-		bool inRankedPlayMode;
-		if (m_inHeroPicker)
-		{
-			formatType = Options.GetFormatType();
-			inRankedPlayMode = true;
-		}
-		else
-		{
-			formatType = Options.GetFormatType();
-			inRankedPlayMode = Options.GetInRankedPlayMode();
-		}
-		m_visualsFormatType = VisualsFormatTypeExtensions.ToVisualsFormatType(formatType, inRankedPlayMode);
-		m_switchFormatButton.SetVisualsFormatType(m_visualsFormatType);
-		m_switchFormatButton.AddEventListener(UIEventType.RELEASE, SwitchFormatButtonPress);
-		switch (SceneMgr.Get().GetMode())
-		{
-		case SceneMgr.Mode.TOURNAMENT:
-			m_switchFormatButton.Uncover();
-			break;
-		case SceneMgr.Mode.COLLECTIONMANAGER:
-			if (CollectionManager.Get().AccountHasUnlockedWild())
+			PegasusShared.FormatType formatType;
+			bool inRankedPlayMode;
+			if (m_inHeroPicker)
 			{
-				m_switchFormatButton.Uncover();
-				break;
+				formatType = Options.GetFormatType();
+				inRankedPlayMode = true;
+			}
+			else
+			{
+				formatType = Options.GetFormatType();
+				inRankedPlayMode = Options.GetInRankedPlayMode();
+			}
+			m_visualsFormatType = VisualsFormatTypeExtensions.ToVisualsFormatType(formatType, inRankedPlayMode);
+			m_switchFormatButton.SetVisualsFormatType(m_visualsFormatType);
+			m_switchFormatButton.AddEventListener(UIEventType.RELEASE, SwitchFormatButtonPress);
+			switch (SceneMgr.Get().GetMode())
+			{
+				case SceneMgr.Mode.TOURNAMENT:
+					m_switchFormatButton.Uncover();
+					break;
+				case SceneMgr.Mode.COLLECTIONMANAGER:
+					if (CollectionManager.Get().AccountHasUnlockedWild())
+					{
+						m_switchFormatButton.Uncover();
+						break;
+					}
+					m_switchFormatButton.Cover();
+					m_switchFormatButton.Disable();
+					break;
+				case SceneMgr.Mode.FRIENDLY:
+				case SceneMgr.Mode.ADVENTURE:
+				case SceneMgr.Mode.TAVERN_BRAWL:
+					m_switchFormatButton.Cover();
+					m_switchFormatButton.Disable();
+					break;
 			}
-			m_switchFormatButton.Cover();
-			m_switchFormatButton.Disable();
-			break;
-		case SceneMgr.Mode.FRIENDLY:
-		case SceneMgr.Mode.ADVENTURE:
-		case SceneMgr.Mode.TAVERN_BRAWL:
-			m_switchFormatButton.Cover();
-			m_switchFormatButton.Disable();
-			break;
 		}
-	}
 
 	protected override void ShowHero()
 	{
@@ -3753,7 +3764,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			if (!(m_selectedCustomDeckBox != null))
 			{
-				Log.All.PrintError("DeckPickerTrayDisplay.ShowHero with no button or deck box selected!");
+				Log.All.PrintError("DeckPickerTrayDisplay.ShowHero with no button or deck box selected!", Array.Empty<object>());
 				return;
 			}
 			UpdateHeroInfo(m_selectedCustomDeckBox);
@@ -3801,37 +3812,37 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			{
 				break;
 			}
-			int num = 2;
-			if (formatTypeForNewPlayModeGame == PegasusShared.FormatType.FT_TWIST)
-			{
+				int num = 2;
+				if (formatTypeForNewPlayModeGame == PegasusShared.FormatType.FT_TWIST)
+				{
 				RankMgr.RankedPlaySeason currentTwistSeason = RankMgr.GetCurrentTwistSeason();
 				if (currentTwistSeason != null)
 				{
 					num = currentTwistSeason.GetScenario()?.ID ?? num;
 				}
-			}
-			int deckTemplateId3 = m_selectedCustomDeckBox.GetDeckTemplateId();
-			if (deckTemplateId3 == 0)
-			{
-				GameMgr.Get().FindGame(gameTypeForNewPlayModeGame, formatTypeForNewPlayModeGame, num, 0, selectedDeckID2, null, null, restoreSavedGameState: false, null, null, 0L);
-			}
-			else
-			{
-				GameMgr gameMgr2 = GameMgr.Get();
-				int missionId = num;
-				long deckId2 = 0L;
-				int deckTemplateId2 = deckTemplateId3;
-				gameMgr2.FindGame(gameTypeForNewPlayModeGame, formatTypeForNewPlayModeGame, missionId, 0, deckId2, null, null, restoreSavedGameState: false, null, null, 0L, PegasusShared.GameType.GT_UNKNOWN, deckTemplateId2);
-			}
-			bool flag = true;
-			if (gameTypeForNewPlayModeGame == PegasusShared.GameType.GT_RANKED && RankMgr.Get().IsLegendRank(formatTypeForNewPlayModeGame))
-			{
-				flag = false;
-			}
-			if (flag)
-			{
-				PresenceMgr.Get().SetStatus(Global.PresenceStatus.PLAY_QUEUE);
-			}
+				}
+				int deckTemplateId3 = m_selectedCustomDeckBox.GetDeckTemplateId();
+				if (deckTemplateId3 == 0)
+				{
+					GameMgr.Get().FindGame(gameTypeForNewPlayModeGame, formatTypeForNewPlayModeGame, num, 0, selectedDeckID2, null, null, restoreSavedGameState: false, null, null, 0L);
+				}
+				else
+				{
+					GameMgr gameMgr2 = GameMgr.Get();
+					int missionId = num;
+					long deckId2 = 0L;
+					int deckTemplateId2 = deckTemplateId3;
+					gameMgr2.FindGame(gameTypeForNewPlayModeGame, formatTypeForNewPlayModeGame, missionId, 0, deckId2, null, null, restoreSavedGameState: false, null, null, 0L, PegasusShared.GameType.GT_UNKNOWN, deckTemplateId2);
+				}
+				bool flag = true;
+				if (gameTypeForNewPlayModeGame == PegasusShared.GameType.GT_RANKED && RankMgr.Get().IsLegendRank(formatTypeForNewPlayModeGame))
+				{
+					flag = false;
+				}
+				if (flag)
+				{
+					PresenceMgr.Get().SetStatus(Global.PresenceStatus.PLAY_QUEUE);
+				}
 			break;
 		}
 		case SceneMgr.Mode.FRIENDLY:
@@ -3872,28 +3883,28 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 				SetHeroRaised(raised: false);
 				break;
 			case AdventureData.Adventuresubscene.MISSION_DECK_PICKER:
-			{
+				{
 				if (OnPlayButtonPressed_SaveHeroAndAdvanceToDungeonRunIfNecessary())
 				{
 					break;
 				}
-				int heroCardDbId = 0;
-				if (m_selectedHeroButton != null && m_selectedHeroButton.m_heroClass != 0)
-				{
-					heroCardDbId = GameUtils.GetFavoriteHeroCardDBIdFromClass(m_selectedHeroButton.m_heroClass);
-				}
-				ScenarioDbId missionToPlay = adventureConfig.GetMissionToPlay();
-				if (GameDbf.Scenario.GetRecord((int)missionToPlay).RuleType == Scenario.RuleType.CHOOSE_HERO)
-				{
-					GameMgr.Get().FindGameWithHero(PegasusShared.GameType.GT_VS_AI, PegasusShared.FormatType.FT_WILD, (int)missionToPlay, 0, heroCardDbId, 0L);
+					int heroCardDbId = 0;
+					if (m_selectedHeroButton != null && m_selectedHeroButton.m_heroClass != 0)
+					{
+						heroCardDbId = GameUtils.GetFavoriteHeroCardDBIdFromClass(m_selectedHeroButton.m_heroClass);
+					}
+					ScenarioDbId missionToPlay = adventureConfig.GetMissionToPlay();
+					if (GameDbf.Scenario.GetRecord((int)missionToPlay).RuleType == Scenario.RuleType.CHOOSE_HERO)
+					{
+						GameMgr.Get().FindGameWithHero(PegasusShared.GameType.GT_VS_AI, PegasusShared.FormatType.FT_WILD, (int)missionToPlay, 0, heroCardDbId, 0L);
 					break;
-				}
+					}
 				int deckTemplateId = m_selectedCustomDeckBox.GetDeckTemplateId();
 				if (deckTemplateId == 0)
-				{
+					{
 					GameMgr.Get().FindGame(PegasusShared.GameType.GT_VS_AI, PegasusShared.FormatType.FT_WILD, (int)missionToPlay, 0, selectedDeckID, null, null, restoreSavedGameState: false, null, null, 0L);
-					break;
-				}
+				break;
+			}
 				GameMgr gameMgr = GameMgr.Get();
 				long deckId = 0L;
 				int deckTemplateId2 = deckTemplateId;
@@ -4014,8 +4025,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		long currentDeckHash = ComputeCurrentDeckHash(deck);
 		if (TryRedirectToMysteryScenario(deck, currentDeckHash, 30, -8433254302802380797L, 5026))
 		{
-			return true;
-		}
+		return true;
+	}
 		if (TryRedirectToMysteryScenario(deck, currentDeckHash, 43, 4901740154402535512L, 5396))
 		{
 			return true;
@@ -4059,6 +4070,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			decksContent.CreateNewDeckFromUserSelection(heroDef.GetClass(), heroDef.GetCardId());
 			CollectionManager.Get().GetCollectibleDisplay().EnableInput(enable: true);
+
+			AccessibilityMgr.SetScreen(TavernBrawlDisplay.Get());
 			yield break;
 		}
 		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
@@ -4187,7 +4200,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 				}
 			}
 		}
-		while (!UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_INTRO, "ShowIntroPopupsIfNeeded"))
+		while (!UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_INTRO, "ShowIntroPopupsIfNeeded"))
 		{
 			yield return null;
 		}
@@ -4203,6 +4216,8 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			PlayEnterModeDialogues();
 		}
+
+		ReadPickerTrayDisplay();
 	}
 
 	private bool CustomPagesReady()
@@ -4297,7 +4312,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		bool flag = RewardUtils.HasNewRewardedDeck(out deckId);
 		if (flag && !HasValidDeckboxWithId(deckId))
 		{
-			Log.DeckTray.PrintWarning("HasNewRewardedDeckId - Newest rewarded deck ID option was set to an invalid deck ID: {0}", deckId);
+			Log.DeckTray.PrintWarning("HasNewRewardedDeckId - Newest rewarded deck ID option was set to an invalid deck ID: {0}", new object[1] { deckId });
 			return false;
 		}
 		return flag;
@@ -4308,7 +4323,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		return GetDeckboxWithDeckID(deckId) != null;
 	}
 
-	private long GetLastChosenDeckId()
+	internal long GetLastChosenDeckId()
 	{
 		if (SceneMgr.Get().GetMode() != SceneMgr.Mode.FRIENDLY)
 		{
@@ -4374,28 +4389,28 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		base.OnFriendChallengeChanged(challengeEvent, player, challengeData, userData);
 		switch (challengeEvent)
 		{
-		case FriendChallengeEvent.I_RECEIVED_SHARED_DECKS:
-			UseSharedDecks(FriendChallengeMgr.Get().GetSharedDecks());
-			break;
-		case FriendChallengeEvent.I_ENDED_DECK_SHARE:
-			StopUsingSharedDecks();
-			break;
-		case FriendChallengeEvent.I_CANCELED_DECK_SHARE_REQUEST:
-			OnDeckShareRequestCancelDeclineOrError();
-			break;
-		case FriendChallengeEvent.OPPONENT_DECLINED_DECK_SHARE_REQUEST:
-			OnDeckShareRequestCancelDeclineOrError();
-			break;
-		case FriendChallengeEvent.DECK_SHARE_ERROR_OCCURED:
-			OnDeckShareRequestCancelDeclineOrError();
-			break;
-		case FriendChallengeEvent.I_ACCEPTED_DECK_SHARE_REQUEST:
-		case FriendChallengeEvent.I_DECLINED_DECK_SHARE_REQUEST:
-			if (FriendChallengeMgr.Get().DidISelectDeckOrHero())
-			{
-				FriendlyChallengeHelper.Get().StartChallengeOrWaitForOpponent("GLOBAL_FRIEND_CHALLENGE_OPPONENT_WAITING_DECK", OnFriendChallengeWaitingForOpponentDialogResponse);
-			}
-			break;
+			case FriendChallengeEvent.I_RECEIVED_SHARED_DECKS:
+				UseSharedDecks(FriendChallengeMgr.Get().GetSharedDecks());
+				break;
+			case FriendChallengeEvent.I_ENDED_DECK_SHARE:
+				StopUsingSharedDecks();
+				break;
+			case FriendChallengeEvent.I_CANCELED_DECK_SHARE_REQUEST:
+				OnDeckShareRequestCancelDeclineOrError();
+				break;
+			case FriendChallengeEvent.OPPONENT_DECLINED_DECK_SHARE_REQUEST:
+				OnDeckShareRequestCancelDeclineOrError();
+				break;
+			case FriendChallengeEvent.DECK_SHARE_ERROR_OCCURED:
+				OnDeckShareRequestCancelDeclineOrError();
+				break;
+			case FriendChallengeEvent.I_ACCEPTED_DECK_SHARE_REQUEST:
+			case FriendChallengeEvent.I_DECLINED_DECK_SHARE_REQUEST:
+				if (FriendChallengeMgr.Get().DidISelectDeckOrHero())
+				{
+					FriendlyChallengeHelper.Get().StartChallengeOrWaitForOpponent("GLOBAL_FRIEND_CHALLENGE_OPPONENT_WAITING_DECK", OnFriendChallengeWaitingForOpponentDialogResponse);
+				}
+				break;
 		}
 	}
 
@@ -4547,7 +4562,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	private bool ShowInnkeeperQuoteIfNeeded()
 	{
 		bool result = false;
-		if (SceneMgr.Get().GetMode() == SceneMgr.Mode.COLLECTIONMANAGER && Options.Get().GetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK) && Options.GetFormatType() == PegasusShared.FormatType.FT_WILD && UserAttentionManager.CanShowAttentionGrabber("DeckPickTrayDisplay.ShowInnkeeperQuoteIfNeeded:" + Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK))
+		if (SceneMgr.Get().GetMode() == SceneMgr.Mode.COLLECTIONMANAGER && Options.Get().GetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK) && Options.GetFormatType() == PegasusShared.FormatType.FT_WILD && UserAttentionManager.CanShowAttentionGrabber(true, "DeckPickTrayDisplay.ShowInnkeeperQuoteIfNeeded:" + Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, NotificationManager.DEFAULT_CHARACTER_POS, GameStrings.Get("VO_INNKEEPER_PLAY_STANDARD_TO_WILD"), "VO_INNKEEPER_Male_Dwarf_SetRotation_43.prefab:4b4ce858139927946905ec0d40d5b3c1");
 			Options.Get().SetBool(Option.SHOW_WILD_DISCLAIMER_POPUP_ON_CREATE_DECK, val: false);
@@ -4580,7 +4595,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		bool result = false;
 		if (num == 0 || num == 2 || num == 6)
 		{
-			if (UserAttentionManager.CanShowAttentionGrabber("DeckPickerTrayDisplay.ShowWhizbangPopupIfNeeded()"))
+			if (UserAttentionManager.CanShowAttentionGrabber(false, "DeckPickerTrayDisplay.ShowWhizbangPopupIfNeeded()"))
 			{
 				StartCoroutine(ShowWhizbangPopup(templateDeck));
 				num++;
@@ -4600,10 +4615,13 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		if (whizbangDeck != null)
 		{
 			yield return new WaitForSeconds(1f);
-			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+			var headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
+			var bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", GameStrings.GetClassName(whizbangDeck.m_class), whizbangDeck.m_title);
+			var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+			BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 			popupInfo.m_prefabAssetRefs.Add("WhizbangDialog_notification.prefab:89912cf72b2d5cf47820d2328de40f3f");
-			popupInfo.m_headerText = GameStrings.Get("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_HEADER");
-			popupInfo.m_bodyText = GameStrings.Format("GLUE_COLLECTION_MANAGER_WHIZBANG_POPUP_BODY", GameStrings.GetClassName(whizbangDeck.m_class), whizbangDeck.m_title);
+			popupInfo.m_headerText = headerText;
+			popupInfo.m_bodyText = bodyText;
 			popupInfo.m_disableBnetBar = true;
 			DialogManager.Get().ShowBasicPopup(UserAttentionBlocker.NONE, popupInfo);
 		}
@@ -4620,7 +4638,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		case SceneMgr.Mode.FRIENDLY:
 			if (FriendChallengeMgr.Get().IsChallengeTavernBrawl())
 			{
-				break;
+			break;
 			}
 			goto default;
 		default:
@@ -4713,7 +4731,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			{
 				StopCoroutine(m_showLeftArrowCoroutine);
 			}
-			m_leftArrow.gameObject.SetActive(value: false);
+			m_leftArrow?.gameObject.SetActive(value: false);
 		}
 		if (flag2)
 		{
@@ -4727,7 +4745,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			StopCoroutine(m_showRightArrowCoroutine);
 		}
-		m_rightArrow.gameObject.SetActive(value: false);
+		m_rightArrow?.gameObject.SetActive(value: false);
 	}
 
 	private bool IsShowingFirstPage()
@@ -4929,9 +4947,9 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	private IEnumerator ShowRotatedBoostersPopup(Action callbackOnHide = null)
 	{
 		yield return new WaitForSeconds(1f);
-		if (UserAttentionManager.CanShowAttentionGrabber(UserAttentionBlocker.SET_ROTATION_INTRO, "ShowSetRotationTutorialDialog"))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, UserAttentionBlocker.SET_ROTATION_INTRO, "ShowSetRotationTutorialDialog"))
 		{
-			SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo setRotationRotatedBoostersPopupInfo = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo();
+			SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo setRotationRotatedBoostersPopupInfo = new SetRotationRotatedBoostersPopup.SetRotationRotatedBoostersPopupInfo("");
 			setRotationRotatedBoostersPopupInfo.m_onHiddenCallback = callbackOnHide;
 			DialogManager.Get().ShowSetRotationTutorialPopup(UserAttentionBlocker.SET_ROTATION_INTRO, setRotationRotatedBoostersPopupInfo);
 			GameSaveDataManager gameSaveDataManager = GameSaveDataManager.Get();
@@ -4971,7 +4989,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			m_switchFormatButton.Disable();
 			m_switchFormatButton.RemoveEventListener(UIEventType.RELEASE, OnSwitchFormatReleased);
-			Processor.QueueJob("LoginManager.CompleteLoginFlow", LoginManager.Get().CompleteLoginFlow());
+			Processor.QueueJob("LoginManager.CompleteLoginFlow", LoginManager.Get().CompleteLoginFlow(), Array.Empty<IJobDependency>());
 			StartCoroutine(ShowWelcomeQuests());
 		}
 		else
@@ -5049,7 +5067,7 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		{
 			m_switchFormatButton.Enable();
 		}
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 	}
 
 	private bool ShouldShowStandardDeckVO(VisualsFormatType newVisualsFormatType)
@@ -5075,14 +5093,14 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 		yield return new WaitForSeconds(1f);
 		switch (GetNumValidStandardDecks())
 		{
-		case 1u:
+			case 1u:
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.SET_ROTATION_INTRO, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_HAVE_ONE_STANDARD_DECK"), "VO_INNKEEPER_Male_Dwarf_HAVE_STANDARD_DECK_07.prefab:282cd0db8b3737d4bb55d71f915074e4", 0f, finishedCallback);
-			break;
-		default:
+				break;
+			default:
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.SET_ROTATION_INTRO, INNKEEPER_QUOTE_POS, GameStrings.Get("VO_INNKEEPER_HAVE_STANDARD_DECKS"), "VO_INNKEEPER_Male_Dwarf_HAVE_STANDARD_DECKS_08.prefab:0c1c2ab2c4ead094abc69ec278aa4878", 0f, finishedCallback);
-			break;
-		case 0u:
-			break;
+				break;
+			case 0u:
+				break;
 		}
 		GameSaveDataManager gameSaveDataManager = GameSaveDataManager.Get();
 		if (gameSaveDataManager != null)
@@ -5092,4 +5110,495 @@ public class DeckPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			gameSaveDataManager.SaveSubkeys(list);
 		}
 	}
+
+	#region Accessibility
+
+	private enum AccessibleState
+	{
+		LOADING,
+		CREATE_DECK_MAIN_MENU,
+		CREATE_DECK_SWITCHING_FORMAT,
+		CREATE_DECK_CHOOSING_CLASS,
+		CREATE_DECK_CLASS_CHOSEN,
+		FRIENDLY_MAIN_MENU,
+		FRIENDLY_CHOOSING_DECK,
+		RANKED_MAIN_MENU,
+		RANKED_CHOOSING_DECK,
+		RANKED_READING_RANK_MEDAL
+	};
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleHorizontalMenu<AccessibleHeroPickerButton> m_accessibleHeroPickerButtons;
+
+	private bool m_chosenDeck; // Used to stop the game from starting immediately if we already have a deck selected
+
+	private void ReadPickerTrayDisplay()
+	{
+		if (CreatingDeck())
+		{
+			ReadCreateDeckScreen();
+			return;
+		}
+	}
+
+	private bool CreatingDeck()
+	{
+		return IsChoosingHero();
+	}
+
+	internal int? GetCurrentPageIndex()
+	{
+		return m_currentPageIndex;
+	}
+
+	private void OnSetupDeckPages()
+	{
+		// TODO: Refactor Practice vs AI to do this properly
+		// Merge ranked with friendly when that happens as most things are similar
+
+		switch (SceneMgr.Get().GetMode())
+		{
+			case SceneMgr.Mode.ADVENTURE:
+				// Practice vs AI
+				AccessibleAdventureScene.Get().OnDeckPickerTrayDisplayReady(m_customPages);
+				break;
+			case SceneMgr.Mode.FRIENDLY:
+				FriendlyOnDeckPickerTrayDisplayReady();
+				break;
+			case SceneMgr.Mode.TOURNAMENT:
+				RankedOnDeckPickerTrayDisplayReady();
+				break;
+			default:
+				break;
+		}
+	}
+
+	private void OnSelectedDeck(CollectionDeckBoxVisual deckbox)
+	{
+		// TODO: Refactor Practice vs AI to do this properly
+
+		switch (SceneMgr.Get().GetMode())
+		{
+			case SceneMgr.Mode.ADVENTURE:
+				// Practice vs AI
+				AccessibleAdventureScene.Get().OnSelectedDeck(deckbox);
+				break;
+			case SceneMgr.Mode.FRIENDLY:
+			case SceneMgr.Mode.TOURNAMENT:
+				PvPOnSelectedDeck();
+				break;
+			default:
+				break;
+		}
+	}
+
+	protected override void OnChosenHero()
+	{
+		if (CreatingDeck())
+		{
+			m_curAccessibleState = AccessibleState.CREATE_DECK_CLASS_CHOSEN;
+			AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_START);
+			return;
+		}
+	}
+
+	#region Deck creation
+	private AccessibleMenu m_createDeckMainMenu;
+
+	private void ReadCreateDeckScreen()
+	{
+		AccessibilityMgr.SetScreen(this);
+
+		SetupCreateDeckMenu();
+	}
+
+	private void SetupCreateDeckMenu()
+	{
+		if (m_switchFormatButton.IsCovered())
+		{
+			SetupCreateDeckChooseClassMenu(false);
+		}
+		else
+		{
+			SetupCreateDeckMainMenu();
+		}
+	}
+
+	private void SetupCreateDeckMainMenu()
+	{
+		m_createDeckMainMenu = new AccessibleMenu(this, "", AccessibilityUtils.GoBackToHub);
+		m_createDeckMainMenu.AddOption(m_modeName.Text, () => SetupCreateDeckChooseClassMenu(true));
+		m_createDeckMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_SWITCH_FORMAT), OnSwitchFormat);
+
+		ReadCreateDeckMainMenu();
+	}
+
+	private void ReadCreateDeckMainMenu()
+	{
+		m_createDeckMainMenu.StartReading();
+		m_curAccessibleState = AccessibleState.CREATE_DECK_MAIN_MENU;
+	}
+
+	private void OnSwitchFormat()
+	{
+		m_curAccessibleState = AccessibleState.CREATE_DECK_SWITCHING_FORMAT;
+		m_switchFormatButton.TriggerRelease();
+	}
+
+	// isSubMenu -> true if we can switch format / false if we haven't unlocked wild yet
+	private void SetupCreateDeckChooseClassMenu(bool isSubMenu)
+	{
+		if (isSubMenu)
+		{
+			m_accessibleHeroPickerButtons = new AccessibleHorizontalMenu<AccessibleHeroPickerButton>(this, "", ReadCreateDeckMainMenu);
+		}
+		else
+		{
+			m_accessibleHeroPickerButtons = new AccessibleHorizontalMenu<AccessibleHeroPickerButton>(this, m_modeName.Text, AccessibilityUtils.GoBackToHub);
+		}
+
+		foreach (var hb in m_heroButtons)
+		{
+			if (!hb.IsLocked())
+			{
+				m_accessibleHeroPickerButtons.AddOption(new AccessibleHeroPickerButton(this, hb, true), () => hb.TriggerRelease());
+			}
+		}
+
+		m_accessibleHeroPickerButtons.StartReading();
+
+		m_curAccessibleState = AccessibleState.CREATE_DECK_CHOOSING_CLASS;
+	}
+
+	#endregion
+
+	#region Friendly
+
+	private AccessibleMenu m_friendlyMainMenu;
+
+	private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_friendlyChooseDeckMenu;
+
+	private void FriendlyOnDeckPickerTrayDisplayReady()
+	{
+		AccessibilityMgr.SetScreen(this);
+		AccessibilityMgr.Output(this, m_modeName.Text);
+
+		m_friendlyMainMenu = new AccessibleMenu(this, "", m_backButton.TriggerRelease);
+		m_friendlyMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), FriendlyReadChooseDeck);
+
+		if (m_DeckShareRequestButton.isActiveAndEnabled)
+		{
+			m_friendlyMainMenu.AddOption(m_DeckShareRequestButton.GetText(), m_DeckShareRequestButton.TriggerRelease);
+		}
+
+		m_friendlyMainMenu.AddOption(m_backButton.GetText(), m_backButton.TriggerRelease);
+
+		FriendlyReadMainMenu();
+	}
+
+	private void FriendlyReadChooseDeck()
+	{
+		m_chosenDeck = false;
+		m_curAccessibleState = AccessibleState.FRIENDLY_CHOOSING_DECK;
+		m_friendlyChooseDeckMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), FriendlyReadMainMenu);
+
+		var selectedDeckId = GetLastChosenDeckId();
+		var selectedDeckIdx = 0;
+
+		for (int i = 0, curIdx = 0; i < m_customPages.Count; i++)
+		{
+			var page = m_customPages[i];
+			var pageDecks = page.m_customDecks;
+
+			for (int j = 0; j < pageDecks.Count; j++, curIdx++)
+			{
+				var deck = pageDecks[j];
+				var deckId = deck.GetDeckID();
+
+				if (deckId == -1L && !deck.m_isLoanerDeck)
+				{
+					break;
+				}
+				else if (deckId == selectedDeckId)
+				{
+					selectedDeckIdx = curIdx;
+				}
+
+				var deckPageIdx = i;
+
+				var accessibleDeck = new AccessibleCollectionDeckBoxVisual(this, deck);
+
+				m_friendlyChooseDeckMenu.AddOption(accessibleDeck, () => SelectDeck(deck), () => ShowDeckPage(deckPageIdx));
+			}
+		}
+
+		m_friendlyChooseDeckMenu.SetIndex(selectedDeckIdx);
+		m_friendlyChooseDeckMenu.StartReading();
+	}
+
+	private void SelectDeck(CollectionDeckBoxVisual deck)
+	{
+		m_chosenDeck = true;
+		deck.TriggerRelease();
+	}
+
+	private void ShowDeckPage(int pageIndex)
+	{
+		if (m_currentPageIndex != pageIndex)
+		{
+			ShowPage(pageIndex);
+		}
+	}
+
+	private void FriendlyReadMainMenu()
+	{
+		m_friendlyMainMenu.StartReading();
+		m_curAccessibleState = AccessibleState.FRIENDLY_MAIN_MENU;
+	}
+
+	private void PvPOnSelectedDeck()
+	{
+		if (AccessibilityMgr.IsAccessibilityEnabled() && m_chosenDeck)
+		{
+			m_playButton.TriggerRelease();
+		}
+	}
+
+	internal void OnWaitingForSharedDeck()
+	{
+		// Stop the refocus message from coming up while we wait for the deck to arrive
+		m_curAccessibleState = AccessibleState.LOADING;
+	}
+
+	#endregion
+
+	#region Ranked
+
+	private AccessibleMenu m_rankedMainMenu;
+
+	private AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual> m_rankedChooseDeckMenu;
+
+	private AccessibleMultilineText m_accessibleRankedMedal;
+
+	private void RankedOnDeckPickerTrayDisplayReady()
+	{
+		AccessibilityMgr.SetScreen(this);
+		if (!GameUtils.HasCompletedApprentice() && RewardTrackManager.Get().HasAnyUnclaimedApprenticeRewards())
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.APPRENTICE_REWARD_REMINDER));
+		}
+
+		AccessibilityMgr.Output(this, m_modeName.Text);
+
+		m_rankedMainMenu = new AccessibleMenu(this, "", m_backButton.TriggerRelease);
+		m_rankedMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), RankedReadChooseDeck);
+
+		if (Options.GetInRankedPlayMode())
+		{
+			m_rankedMainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_HEARTHSTONE_RANKED_READ_RANK), ReadCurrentRank);
+		}
+		m_rankedMainMenu.AddOption(GameStrings.Get("GLUE_BACON_INFO_POPUP_PLAY_TUTORIAL"), GameUtils.ReplayTraditionalTutorial);
+
+		m_rankedMainMenu.AddOption(m_backButton.GetText(), m_backButton.TriggerRelease);
+
+		RankedReadMainMenu();
+	}
+
+	private void ReadCurrentRank()
+	{
+		var lines = new List<string>();
+
+		var curMedal = RankMgr.Get().GetLocalPlayerMedalInfo().GetCurrentMedal(Options.GetFormatType());
+		lines.Add(AccessibleRankedUtils.GetRankText(curMedal));
+		AccessibleCardUtils.AddLineIfExists(AccessibleRankedUtils.GetRankStarsText(curMedal), lines);
+		AccessibleCardUtils.AddLineIfExists(AccessibleRankedUtils.GetStarBonusText(curMedal), lines);
+
+		m_accessibleRankedMedal = new AccessibleMultilineText(this, lines);
+		m_accessibleRankedMedal.ReadAllLines();
+		m_curAccessibleState = AccessibleState.RANKED_READING_RANK_MEDAL;
+	}
+
+	private void RankedReadChooseDeck()
+	{
+		m_chosenDeck = false;
+		m_curAccessibleState = AccessibleState.RANKED_CHOOSING_DECK;
+		m_rankedChooseDeckMenu = new AccessibleHorizontalMenu<AccessibleCollectionDeckBoxVisual>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_DECK_TITLE), RankedReadMainMenu);
+
+		var selectedDeckId = GetLastChosenDeckId();
+		var selectedDeckIdx = 0;
+
+		for (int i = 0, curIdx = 0; i < m_customPages.Count; i++)
+		{
+			var page = m_customPages[i];
+			var pageDecks = page.m_customDecks;
+
+			for (int j = 0; j < pageDecks.Count; j++, curIdx++)
+			{
+				var deck = pageDecks[j];
+				var deckId = deck.GetDeckID();
+
+				if (deckId == -1L && !deck.m_isLoanerDeck)
+				{
+					break;
+				}
+				else if (deckId == selectedDeckId)
+				{
+					selectedDeckIdx = curIdx;
+				}
+
+				var deckPageIdx = i;
+
+				var accessibleDeck = new AccessibleCollectionDeckBoxVisual(this, deck);
+
+				m_rankedChooseDeckMenu.AddOption(accessibleDeck, () => SelectDeck(deck), () => ShowDeckPage(deckPageIdx));
+			}
+		}
+
+		m_rankedChooseDeckMenu.SetIndex(selectedDeckIdx);
+		m_rankedChooseDeckMenu.StartReading();
+	}
+
+	private void RankedReadMainMenu()
+	{
+		m_rankedMainMenu.StartReading();
+		m_curAccessibleState = AccessibleState.RANKED_MAIN_MENU;
+	}
+
+	#endregion
+
+	public void HandleInput()
+	{
+		if (m_curAccessibleState == AccessibleState.CREATE_DECK_MAIN_MENU)
+		{
+			m_createDeckMainMenu?.HandleAccessibleInput();
+		}
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CHOOSING_CLASS)
+		{
+			m_accessibleHeroPickerButtons?.HandleAccessibleInput();
+		}
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CLASS_CHOSEN)
+		{
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				m_playButton.TriggerRelease();
+			}
+			else if (AccessibleKey.BACK.IsPressed())
+			{
+				AccessibilityUtils.GoBackToHub();
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_MAIN_MENU)
+		{
+			m_friendlyMainMenu?.HandleAccessibleInput();
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_CHOOSING_DECK)
+		{
+			                    if(AccessibleKey.HUB_MY_COLLECTION.IsPressed()) m_collectionButton.TriggerRelease();
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				FriendlyReadMainMenu();
+			}
+			else
+			{
+				m_friendlyChooseDeckMenu?.HandleAccessibleInput();
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_MAIN_MENU)
+		{
+			m_rankedMainMenu?.HandleAccessibleInput();
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_CHOOSING_DECK)
+		{
+						                    if(AccessibleKey.HUB_MY_COLLECTION.IsPressed()) m_collectionButton.TriggerRelease();
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				RankedReadMainMenu();
+			}
+			else
+			{
+				m_rankedChooseDeckMenu?.HandleAccessibleInput();
+			}
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_READING_RANK_MEDAL)
+		{
+			m_accessibleRankedMedal?.HandleAccessibleInput();
+
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				RankedReadMainMenu();
+			}
+		}
+	}
+
+	public string GetHelp()
+	{
+		if (m_curAccessibleState == AccessibleState.CREATE_DECK_MAIN_MENU)
+		{
+			return m_createDeckMainMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CHOOSING_CLASS)
+		{
+			return m_accessibleHeroPickerButtons?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CLASS_CHOSEN)
+		{
+			// Click to start seems fine and easier on translators
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_MAIN_MENU)
+		{
+			return m_friendlyMainMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_CHOOSING_DECK)
+		{
+			return m_friendlyChooseDeckMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_MAIN_MENU)
+		{
+			return m_rankedMainMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_CHOOSING_DECK)
+		{
+			return m_rankedChooseDeckMenu?.GetHelp();
+		}
+		else if (m_curAccessibleState == AccessibleState.RANKED_READING_RANK_MEDAL)
+		{
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+		}
+
+		return "";
+	}
+
+	public void OnGainedFocus()
+	{
+		if (m_curAccessibleState == AccessibleState.CREATE_DECK_SWITCHING_FORMAT)
+		{
+			m_curAccessibleState = AccessibleState.CREATE_DECK_MAIN_MENU;
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_MAIN_MENU)
+		{
+			m_friendlyMainMenu?.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.FRIENDLY_CHOOSING_DECK)
+		{
+			m_friendlyChooseDeckMenu?.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_MAIN_MENU)
+		{
+			m_createDeckMainMenu?.StartReading();
+		}
+		else if (m_curAccessibleState == AccessibleState.CREATE_DECK_CHOOSING_CLASS)
+		{
+			if (AccessibleCollectionManager.Get().IsCreatingDeckFromClipboard())
+			{
+				AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+			}
+			else
+			{
+				m_accessibleHeroPickerButtons?.StartReading();
+			}
+		}
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/DeckTemplatePicker.cs b/Assembly-CSharp/DeckTemplatePicker.cs
index 32cbdf4..9995533 100644
--- a/Assembly-CSharp/DeckTemplatePicker.cs
+++ b/Assembly-CSharp/DeckTemplatePicker.cs
@@ -6,72 +6,73 @@ using Blizzard.T5.MaterialService.Extensions;
 using Hearthstone.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class DeckTemplatePicker : MonoBehaviour
+public class DeckTemplatePicker : MonoBehaviour, AccessibleScreen
 {
-	public delegate void OnTemplateDeckChosen();
+    public delegate void OnTemplateDeckChosen();
 
-	public GameObject m_root;
+    public GameObject m_root;
 
-	public GameObject m_pageHeader;
+    public GameObject m_pageHeader;
 
-	public UberText m_pageHeaderText;
+    public UberText m_pageHeaderText;
 
-	public UIBObjectSpacing m_pickerButtonRoot;
+    public UIBObjectSpacing m_pickerButtonRoot;
 
-	public DeckTemplatePickerButton m_pickerButtonTpl;
+    public DeckTemplatePickerButton m_pickerButtonTpl;
 
-	public DeckTemplatePickerButton m_customDeckButton;
+    public DeckTemplatePickerButton m_customDeckButton;
 
-	public UberText m_deckTemplateDescription;
+    public UberText m_deckTemplateDescription;
 
-	public UberText m_deckTemplatePhoneName;
+    public UberText m_deckTemplatePhoneName;
 
-	public PlayButton m_chooseButton;
+    public PlayButton m_chooseButton;
 
-	public GameObject m_bottomPanel;
+    public GameObject m_bottomPanel;
 
-	public Material m_deckArtMaterial;
+    public Material m_deckArtMaterial;
 
-	public DeckTemplatePhoneTray m_phoneTray;
+    public DeckTemplatePhoneTray m_phoneTray;
 
-	public UIBButton m_phoneBackButton;
+    public UIBButton m_phoneBackButton;
 
-	public RuneIndicatorVisual m_runeIndicatorVisual;
+    public RuneIndicatorVisual m_runeIndicatorVisual;
 
-	public Vector3 m_bottomPanelHideOffset = new Vector3(0f, 0f, 25f);
+    public Vector3 m_bottomPanelHideOffset = new Vector3(0f, 0f, 25f);
 
-	public float m_bottomPanelSlideInWaitDelay = 0.25f;
+    public float m_bottomPanelSlideInWaitDelay = 0.25f;
 
-	public float m_bottomPanelAnimateTime = 0.25f;
+    public float m_bottomPanelAnimateTime = 0.25f;
 
-	public float m_packAnimInTime = 0.25f;
+    public float m_packAnimInTime = 0.25f;
 
-	public float m_packAnimOutTime = 0.2f;
+    public float m_packAnimOutTime = 0.2f;
 
-	public Vector3 m_offscreenPackOffset;
+    public Vector3 m_offscreenPackOffset;
 
-	public Transform m_ghostCardTipBone;
+    public Transform m_ghostCardTipBone;
 
-	private List<DeckTemplatePickerButton> m_pickerButtons = new List<DeckTemplatePickerButton>();
+    private List<DeckTemplatePickerButton> m_pickerButtons = new List<DeckTemplatePickerButton>();
 
-	private CollectionManager.TemplateDeck m_customDeck = new CollectionManager.TemplateDeck();
+    private CollectionManager.TemplateDeck m_customDeck = new CollectionManager.TemplateDeck();
 
-	private TAG_CLASS m_currentSelectedClass;
+    private TAG_CLASS m_currentSelectedClass;
 
-	private FormatType m_currentSelectedFormat;
+    private FormatType m_currentSelectedFormat;
 
-	private CollectionManager.TemplateDeck m_currentSelectedDeck;
+    private CollectionManager.TemplateDeck m_currentSelectedDeck;
 
-	private List<OnTemplateDeckChosen> m_templateDeckChosenListeners = new List<OnTemplateDeckChosen>();
+    private List<OnTemplateDeckChosen> m_templateDeckChosenListeners = new List<OnTemplateDeckChosen>();
 
-	private Vector3 m_origBottomPanelPos;
+    private Vector3 m_origBottomPanelPos;
 
-	private bool m_showingBottomPanel;
+    private bool m_showingBottomPanel;
 
-	private TransformProps m_customDeckInitialPosition;
+    private TransformProps m_customDeckInitialPosition;
 
-	private bool m_packsShown;
+    private bool m_packsShown;
 
 	public FormatType CurrentSelectedFormat
 	{
@@ -85,617 +86,751 @@ public class DeckTemplatePicker : MonoBehaviour
 		}
 	}
 
-	private void Awake()
-	{
-		m_currentSelectedDeck = m_customDeck;
-		for (int i = 0; i < 3; i++)
-		{
-			int idx = i;
-			DeckTemplatePickerButton deckTemplatePickerButton = (DeckTemplatePickerButton)GameUtils.Instantiate(m_pickerButtonTpl, m_pickerButtonRoot.gameObject, withRotation: true);
-			Vector3 zero = Vector3.zero;
-			if ((bool)UniversalInputManager.UsePhoneUI)
-			{
-				zero.x = 0.75f;
-			}
-			m_pickerButtonRoot.AddObject(deckTemplatePickerButton, zero);
-			deckTemplatePickerButton.AddEventListener(UIEventType.RELEASE, delegate
-			{
-				SelectButtonWithIndex(idx);
-			});
-			deckTemplatePickerButton.gameObject.SetActive(value: true);
-			m_pickerButtons.Add(deckTemplatePickerButton);
-		}
-		if (m_pickerButtons.Count > 0)
-		{
-			m_pickerButtons[0].SetIsCoreDeck(isCore: true);
-		}
-		m_pickerButtonRoot.UpdatePositions();
-		m_pickerButtonTpl.gameObject.SetActive(value: false);
-		if (m_customDeckButton != null)
-		{
-			m_customDeckButton.gameObject.SetActive(value: true);
-			m_customDeckButton.AddEventListener(UIEventType.RELEASE, delegate
-			{
-				SelectCustomDeckButton();
-			});
-		}
-		if (m_chooseButton != null)
-		{
-			m_chooseButton.Disable();
-			m_chooseButton.AddEventListener(UIEventType.RELEASE, delegate
-			{
-				ChooseRecipeAndFillInCards();
-			});
-		}
-		if (m_phoneTray != null)
-		{
-			m_phoneTray.m_scrollbar.SaveScroll("start");
-			m_phoneTray.gameObject.SetActive(value: false);
-		}
-		if (m_bottomPanel != null)
-		{
-			m_origBottomPanelPos = m_bottomPanel.transform.localPosition;
-		}
-		if (m_phoneBackButton != null)
-		{
-			m_phoneBackButton.AddEventListener(UIEventType.RELEASE, delegate(UIEvent e)
-			{
-				OnBackButtonPressed(e);
-			});
-		}
-		m_customDeckInitialPosition = TransformUtil.GetLocalTransformProps(m_customDeckButton.transform);
-	}
-
-	private void OnBackButtonPressed(UIEvent e)
-	{
-		Navigation.GoBack();
-	}
-
-	private IEnumerator BackOut()
-	{
-		CollectionManager.Get().GetCollectibleDisplay().EnableInput(enable: false);
-		Navigation.RemoveHandler(CollectionDeckTray.Get().OnBackOutOfContainerContents);
-		yield return StartCoroutine(ShowPacks(show: false));
-		CollectionDeckTray deckTray = CollectionDeckTray.Get();
-		deckTray.OnBackOutOfDeckContentsImpl(deleteDeck: true);
-		while (!deckTray.m_cardsContent.HasFinishedExiting())
-		{
-			yield return null;
-		}
-		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (collectionManagerDisplay != null)
-		{
-			collectionManagerDisplay.EnterSelectNewDeckHeroMode();
-			HeroPickerDisplay heroPickerDisplay = collectionManagerDisplay.GetHeroPickerDisplay();
-			while (heroPickerDisplay != null && !heroPickerDisplay.IsShown())
-			{
-				yield return null;
-			}
-		}
-		if ((bool)UniversalInputManager.UsePhoneUI)
-		{
-			StartCoroutine(HideTrays());
-		}
-		CollectionManager.Get().GetCollectibleDisplay().EnableInput(enable: true);
-	}
-
-	public bool OnNavigateBack()
-	{
-		StartCoroutine(BackOut());
-		return true;
-	}
-
-	public void RegisterOnTemplateDeckChosen(OnTemplateDeckChosen dlg)
-	{
-		m_templateDeckChosenListeners.Add(dlg);
-	}
-
-	public void UnregisterOnTemplateDeckChosen(OnTemplateDeckChosen dlg)
-	{
-		m_templateDeckChosenListeners.Remove(dlg);
-	}
-
-	public bool IsShowingBottomPanel()
-	{
-		return m_showingBottomPanel;
-	}
-
-	public bool IsShowingPacks()
-	{
-		return m_packsShown;
-	}
-
-	public IEnumerator Show(bool show)
-	{
-		CollectionDeckTray deckTray = CollectionDeckTray.Get();
-		CollectionManager collectionManager = CollectionManager.Get();
-		DeckTrayCardListContent cardsContent = null;
-		CollectionDeck collectionDeck = null;
-		if (deckTray != null)
-		{
-			cardsContent = deckTray.GetCardsContent();
-		}
-		if (cardsContent == null)
-		{
-			yield break;
-		}
-		if (collectionManager != null)
-		{
-			collectionDeck = collectionManager.GetEditedDeck();
-		}
-		if (show)
-		{
-			m_root.SetActive(value: true);
-			m_showingBottomPanel = false;
-			m_packsShown = false;
-			m_pickerButtonRoot.UpdatePositions();
-			TransformUtil.CopyLocal(m_customDeckButton.transform, m_customDeckInitialPosition);
-			m_customDeckButton.GetComponentInChildren<UberText>().Text = GameStrings.Get(GameStrings.Get("GLUE_DECK_TEMPLATE_CUSTOM_DECK"));
-			if (collectionDeck != null)
-			{
-				SetupTemplateButtons(m_customDeck);
-				m_chooseButton.Disable();
-				if (m_deckTemplateDescription != null)
-				{
-					m_deckTemplateDescription.Text = GameStrings.Get("GLUE_COLLECTION_DECK_TEMPLATE_SELECT_A_DECK");
-				}
-				cardsContent.ResetFakeDeck();
-				if (m_phoneTray != null)
-				{
-					m_phoneTray.m_cardsContent.ResetFakeDeck();
-				}
-				FillWithCustomDeck();
-				if (!UniversalInputManager.UsePhoneUI)
-				{
-					deckTray.DisableRuneIndicatorVisualButtons();
-				}
-				m_currentSelectedDeck = m_customDeck;
-				if (!UniversalInputManager.UsePhoneUI)
-				{
-					OnTrayToggled(shown: true);
-				}
-				Navigation.Push(OnNavigateBack);
-				if (!CollectionManager.Get().ShouldShowDeckTemplatePageForClass(m_currentSelectedClass) && !UniversalInputManager.UsePhoneUI)
-				{
-					SelectCustomDeckButton(preselect: true);
-				}
-				ShowBottomPanel(show: true);
-				yield return StartCoroutine(ShowPacks(show: true));
-				while (deckTray == null || deckTray.GetCurrentContentType() != DeckTray.DeckContentTypes.Cards)
-				{
-					yield return null;
-				}
-			}
-		}
-		else if (m_root.activeSelf)
-		{
-			yield return StartCoroutine(ShowPacks(show: false));
-			cardsContent.ResetFakeDeck();
-			deckTray.EnableRuneIndicatorVisualButtons();
-			ShowBottomPanel(show: true);
-			m_root.SetActive(value: false);
-		}
-	}
-
-	private void SetupTemplateButtons(CollectionManager.TemplateDeck refDeck)
-	{
-		List<CollectionManager.TemplateDeck> nonStarterTemplateDecks = CollectionManager.Get().GetNonStarterTemplateDecks(m_currentSelectedFormat, m_currentSelectedClass);
-		if (nonStarterTemplateDecks == null)
-		{
-			Log.Decks.PrintWarning("SetupTemplateButtons with class {0} which had no template decks", m_currentSelectedClass);
-			return;
-		}
-		for (int i = 0; i < m_pickerButtons.Count && i < nonStarterTemplateDecks.Count; i++)
-		{
-			CollectionManager.TemplateDeck templateDeck = nonStarterTemplateDecks[i];
-			bool num = refDeck == templateDeck;
-			if (num)
-			{
-				m_currentSelectedDeck = templateDeck;
-			}
-			m_pickerButtons[i].SetSelected(selected: false);
-			if (num && m_deckTemplateDescription != null)
-			{
-				m_deckTemplateDescription.Text = templateDeck.m_description;
-			}
-			if (num && m_deckTemplatePhoneName != null)
-			{
-				m_deckTemplatePhoneName.Text = templateDeck.m_title;
-			}
-			m_pickerButtons[i].transform.localEulerAngles = Vector3.zero;
-			m_pickerButtons[i].GetComponent<RandomTransform>().Apply();
-			AnimatedLowPolyPack component = m_pickerButtons[i].GetComponent<AnimatedLowPolyPack>();
-			component.Init(0, m_pickerButtons[i].transform.localPosition, m_pickerButtons[i].transform.localPosition + m_offscreenPackOffset, ignoreFullscreenEffects: false, changeActivation: false);
-			component.SetFlyingLocalRotations(m_pickerButtons[i].transform.localEulerAngles, m_pickerButtons[i].transform.localEulerAngles);
-		}
-		if (m_customDeckButton != null)
-		{
-			m_customDeckButton.SetSelected(selected: false);
-			m_customDeckButton.transform.localEulerAngles = Vector3.zero;
-			AnimatedLowPolyPack component2 = m_customDeckButton.GetComponent<AnimatedLowPolyPack>();
-			component2.Init(0, m_customDeckButton.transform.localPosition, m_customDeckButton.transform.localPosition + m_offscreenPackOffset, ignoreFullscreenEffects: false, changeActivation: false);
-			component2.SetFlyingLocalRotations(m_customDeckButton.transform.localEulerAngles, m_customDeckButton.transform.localEulerAngles);
-		}
-	}
-
-	public IEnumerator ShowPacks(bool show)
-	{
-		float delay = 0f;
-		if (show)
-		{
-			CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-			if (collectionManagerDisplay != null)
-			{
-				HeroPickerDisplay heroPickerDisplay = collectionManagerDisplay.GetHeroPickerDisplay();
-				while (heroPickerDisplay != null && !heroPickerDisplay.IsHidden())
-				{
-					yield return new WaitForEndOfFrame();
-				}
-			}
-		}
-		DeckTemplatePickerButton[] array = m_pickerButtons.ToArray();
-		GeneralUtils.Shuffle(array);
-		DeckTemplatePickerButton[] array2 = array;
-		for (int i = 0; i < array2.Length; i++)
-		{
-			AnimatedLowPolyPack component = array2[i].GetComponent<AnimatedLowPolyPack>();
-			if (show)
-			{
-				component.FlyIn(m_packAnimInTime, delay);
-			}
-			else
-			{
-				component.FlyOut(m_packAnimOutTime, delay);
-			}
-			yield return new WaitForSeconds(UnityEngine.Random.Range(0.2f * m_packAnimInTime, 0.4f * m_packAnimInTime));
-		}
-		AnimatedLowPolyPack component2 = m_customDeckButton.GetComponent<AnimatedLowPolyPack>();
-		if (show)
-		{
-			component2.FlyIn(m_packAnimInTime, delay);
-			yield return new WaitForSeconds(m_packAnimInTime + delay);
-		}
-		else
-		{
-			component2.FlyOut(m_packAnimOutTime, delay);
-			yield return new WaitForSeconds(m_packAnimOutTime + delay);
-		}
-		m_packsShown = show;
-	}
-
-	public void ShowBottomPanel(bool show)
-	{
-		if (!(m_bottomPanel != null))
-		{
-			return;
-		}
-		Vector3 origBottomPanelPos = m_origBottomPanelPos;
-		Vector3 origBottomPanelPos2 = m_origBottomPanelPos;
-		float num = 0f;
-		if (show)
-		{
-			origBottomPanelPos2 += m_bottomPanelHideOffset;
-			num = m_bottomPanelSlideInWaitDelay;
-			m_showingBottomPanel = true;
-		}
-		else
-		{
-			origBottomPanelPos += m_bottomPanelHideOffset;
-			Processor.ScheduleCallback(m_bottomPanelAnimateTime, realTime: false, delegate
-			{
-				m_showingBottomPanel = show;
-			});
-		}
-		iTween.Stop(m_bottomPanel);
-		m_bottomPanel.transform.localPosition = origBottomPanelPos2;
+    private void Awake()
+    {
+        m_currentSelectedDeck = m_customDeck;
+        for (int i = 0; i < 3; i++)
+        {
+            int idx = i;
+            DeckTemplatePickerButton deckTemplatePickerButton = (DeckTemplatePickerButton)GameUtils.Instantiate(m_pickerButtonTpl, m_pickerButtonRoot.gameObject, withRotation: true);
+            Vector3 zero = Vector3.zero;
+            if ((bool)UniversalInputManager.UsePhoneUI)
+            {
+                zero.x = 0.75f;
+            }
+            m_pickerButtonRoot.AddObject(deckTemplatePickerButton, zero);
+            deckTemplatePickerButton.AddEventListener(UIEventType.RELEASE, delegate
+            {
+                SelectButtonWithIndex(idx);
+            });
+            deckTemplatePickerButton.gameObject.SetActive(value: true);
+            m_pickerButtons.Add(deckTemplatePickerButton);
+        }
+        if (m_pickerButtons.Count > 0)
+        {
+            m_pickerButtons[0].SetIsCoreDeck(isCore: true);
+        }
+        m_pickerButtonRoot.UpdatePositions();
+        m_pickerButtonTpl.gameObject.SetActive(value: false);
+        if (m_customDeckButton != null)
+        {
+            m_customDeckButton.gameObject.SetActive(value: true);
+            m_customDeckButton.AddEventListener(UIEventType.RELEASE, delegate
+            {
+                SelectCustomDeckButton();
+            });
+        }
+        if (m_chooseButton != null)
+        {
+            m_chooseButton.Disable();
+            m_chooseButton.AddEventListener(UIEventType.RELEASE, delegate
+            {
+                ChooseRecipeAndFillInCards();
+            });
+        }
+        if (m_phoneTray != null)
+        {
+            m_phoneTray.m_scrollbar.SaveScroll("start");
+            m_phoneTray.gameObject.SetActive(value: false);
+        }
+        if (m_bottomPanel != null)
+        {
+            m_origBottomPanelPos = m_bottomPanel.transform.localPosition;
+        }
+        if (m_phoneBackButton != null)
+        {
+            m_phoneBackButton.AddEventListener(UIEventType.RELEASE, delegate (UIEvent e)
+            {
+                OnBackButtonPressed(e);
+            });
+        }
+        m_customDeckInitialPosition = TransformUtil.GetLocalTransformProps(m_customDeckButton.transform);
+    }
+
+    private void OnBackButtonPressed(UIEvent e)
+    {
+        Navigation.GoBack();
+    }
+
+    private IEnumerator BackOut()
+    {
+        CollectionManager.Get().GetCollectibleDisplay().EnableInput(enable: false);
+        Navigation.RemoveHandler(CollectionDeckTray.Get().OnBackOutOfContainerContents);
+        yield return StartCoroutine(ShowPacks(show: false));
+        CollectionDeckTray deckTray = CollectionDeckTray.Get();
+        deckTray.OnBackOutOfDeckContentsImpl(deleteDeck: true);
+        while (!deckTray.m_cardsContent.HasFinishedExiting())
+        {
+            yield return null;
+        }
+        CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+        if (collectionManagerDisplay != null)
+        {
+            collectionManagerDisplay.EnterSelectNewDeckHeroMode();
+            HeroPickerDisplay heroPickerDisplay = collectionManagerDisplay.GetHeroPickerDisplay();
+            while (heroPickerDisplay != null && !heroPickerDisplay.IsShown())
+            {
+                yield return null;
+            }
+        }
+        if ((bool)UniversalInputManager.UsePhoneUI)
+        {
+            StartCoroutine(HideTrays());
+        }
+        CollectionManager.Get().GetCollectibleDisplay().EnableInput(enable: true);
+    }
+
+    public bool OnNavigateBack()
+    {
+        StartCoroutine(BackOut());
+        return true;
+    }
+
+    public void RegisterOnTemplateDeckChosen(OnTemplateDeckChosen dlg)
+    {
+        m_templateDeckChosenListeners.Add(dlg);
+    }
+
+    public void UnregisterOnTemplateDeckChosen(OnTemplateDeckChosen dlg)
+    {
+        m_templateDeckChosenListeners.Remove(dlg);
+    }
+
+    public bool IsShowingBottomPanel()
+    {
+        return m_showingBottomPanel;
+    }
+
+    public bool IsShowingPacks()
+    {
+        return m_packsShown;
+    }
+
+    public IEnumerator Show(bool show)
+    {
+        CollectionDeckTray deckTray = CollectionDeckTray.Get();
+        CollectionManager collectionManager = CollectionManager.Get();
+        DeckTrayCardListContent cardsContent = null;
+        CollectionDeck collectionDeck = null;
+        if (deckTray != null)
+        {
+            cardsContent = deckTray.GetCardsContent();
+        }
+        if (cardsContent == null)
+        {
+            yield break;
+        }
+        if (collectionManager != null)
+        {
+            collectionDeck = collectionManager.GetEditedDeck();
+        }
+        if (show)
+        {
+            m_root.SetActive(value: true);
+            m_showingBottomPanel = false;
+            m_packsShown = false;
+            m_pickerButtonRoot.UpdatePositions();
+            TransformUtil.CopyLocal(m_customDeckButton.transform, m_customDeckInitialPosition);
+            m_customDeckButton.GetComponentInChildren<UberText>().Text = GameStrings.Get(GameStrings.Get("GLUE_DECK_TEMPLATE_CUSTOM_DECK"));
+            if (collectionDeck != null)
+            {
+                SetupTemplateButtons(m_customDeck);
+                m_chooseButton.Disable();
+                if (m_deckTemplateDescription != null)
+                {
+                    m_deckTemplateDescription.Text = GameStrings.Get("GLUE_COLLECTION_DECK_TEMPLATE_SELECT_A_DECK");
+                }
+                cardsContent.ResetFakeDeck();
+                if (m_phoneTray != null)
+                {
+                    m_phoneTray.m_cardsContent.ResetFakeDeck();
+                }
+                FillWithCustomDeck();
+                if (!UniversalInputManager.UsePhoneUI)
+                {
+                    deckTray.DisableRuneIndicatorVisualButtons();
+                }
+                m_currentSelectedDeck = m_customDeck;
+                if (!UniversalInputManager.UsePhoneUI)
+                {
+                    OnTrayToggled(shown: true);
+                }
+                Navigation.Push(OnNavigateBack);
+                if (!CollectionManager.Get().ShouldShowDeckTemplatePageForClass(m_currentSelectedClass) && !UniversalInputManager.UsePhoneUI)
+                {
+                    SelectCustomDeckButton(preselect: true);
+                }
+                ShowBottomPanel(show: true);
+                yield return StartCoroutine(ShowPacks(show: true));
+                while (deckTray == null || deckTray.GetCurrentContentType() != DeckTray.DeckContentTypes.Cards)
+                {
+                    yield return null;
+                }
+            }
+
+            ReadDeckTemplatePicker();
+        }
+        else if (m_root.activeSelf)
+        {
+            yield return StartCoroutine(ShowPacks(show: false));
+            cardsContent.ResetFakeDeck();
+            deckTray.EnableRuneIndicatorVisualButtons();
+            ShowBottomPanel(show: true);
+            m_root.SetActive(value: false);
+        }
+    }
+
+    private void SetupTemplateButtons(CollectionManager.TemplateDeck refDeck)
+    {
+        List<CollectionManager.TemplateDeck> nonStarterTemplateDecks = CollectionManager.Get().GetNonStarterTemplateDecks(m_currentSelectedFormat, m_currentSelectedClass);
+        if (nonStarterTemplateDecks == null)
+        {
+            Log.Decks.PrintWarning("SetupTemplateButtons with class {0} which had no template decks", m_currentSelectedClass);
+            return;
+        }
+        for (int i = 0; i < m_pickerButtons.Count && i < nonStarterTemplateDecks.Count; i++)
+        {
+            CollectionManager.TemplateDeck templateDeck = nonStarterTemplateDecks[i];
+            bool num = refDeck == templateDeck;
+            if (num)
+            {
+                m_currentSelectedDeck = templateDeck;
+            }
+            m_pickerButtons[i].SetSelected(selected: false);
+            if (num && m_deckTemplateDescription != null)
+            {
+                m_deckTemplateDescription.Text = templateDeck.m_description;
+            }
+            if (num && m_deckTemplatePhoneName != null)
+            {
+                m_deckTemplatePhoneName.Text = templateDeck.m_title;
+            }
+            m_pickerButtons[i].transform.localEulerAngles = Vector3.zero;
+            m_pickerButtons[i].GetComponent<RandomTransform>().Apply();
+            AnimatedLowPolyPack component = m_pickerButtons[i].GetComponent<AnimatedLowPolyPack>();
+            component.Init(0, m_pickerButtons[i].transform.localPosition, m_pickerButtons[i].transform.localPosition + m_offscreenPackOffset, ignoreFullscreenEffects: false, changeActivation: false);
+            component.SetFlyingLocalRotations(m_pickerButtons[i].transform.localEulerAngles, m_pickerButtons[i].transform.localEulerAngles);
+        }
+        if (m_customDeckButton != null)
+        {
+            m_customDeckButton.SetSelected(selected: false);
+            m_customDeckButton.transform.localEulerAngles = Vector3.zero;
+            AnimatedLowPolyPack component2 = m_customDeckButton.GetComponent<AnimatedLowPolyPack>();
+            component2.Init(0, m_customDeckButton.transform.localPosition, m_customDeckButton.transform.localPosition + m_offscreenPackOffset, ignoreFullscreenEffects: false, changeActivation: false);
+            component2.SetFlyingLocalRotations(m_customDeckButton.transform.localEulerAngles, m_customDeckButton.transform.localEulerAngles);
+        }
+    }
+
+    public IEnumerator ShowPacks(bool show)
+    {
+        float delay = 0f;
+        if (show)
+        {
+            CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+            if (collectionManagerDisplay != null)
+            {
+                HeroPickerDisplay heroPickerDisplay = collectionManagerDisplay.GetHeroPickerDisplay();
+                while (heroPickerDisplay != null && !heroPickerDisplay.IsHidden())
+                {
+                    yield return new WaitForEndOfFrame();
+                }
+            }
+        }
+        DeckTemplatePickerButton[] array = m_pickerButtons.ToArray();
+        GeneralUtils.Shuffle(array);
+        DeckTemplatePickerButton[] array2 = array;
+        for (int i = 0; i < array2.Length; i++)
+        {
+            AnimatedLowPolyPack component = array2[i].GetComponent<AnimatedLowPolyPack>();
+            if (show)
+            {
+                component.FlyIn(m_packAnimInTime, delay);
+            }
+            else
+            {
+                component.FlyOut(m_packAnimOutTime, delay);
+            }
+            yield return new WaitForSeconds(UnityEngine.Random.Range(0.2f * m_packAnimInTime, 0.4f * m_packAnimInTime));
+        }
+        AnimatedLowPolyPack component2 = m_customDeckButton.GetComponent<AnimatedLowPolyPack>();
+        if (show)
+        {
+            component2.FlyIn(m_packAnimInTime, delay);
+            yield return new WaitForSeconds(m_packAnimInTime + delay);
+        }
+        else
+        {
+            component2.FlyOut(m_packAnimOutTime, delay);
+            yield return new WaitForSeconds(m_packAnimOutTime + delay);
+        }
+        m_packsShown = show;
+    }
+
+    public void ShowBottomPanel(bool show)
+    {
+        if (!(m_bottomPanel != null))
+        {
+            return;
+        }
+        Vector3 origBottomPanelPos = m_origBottomPanelPos;
+        Vector3 origBottomPanelPos2 = m_origBottomPanelPos;
+        float num = 0f;
+        if (show)
+        {
+            origBottomPanelPos2 += m_bottomPanelHideOffset;
+            num = m_bottomPanelSlideInWaitDelay;
+            m_showingBottomPanel = true;
+        }
+        else
+        {
+            origBottomPanelPos += m_bottomPanelHideOffset;
+            Processor.ScheduleCallback(m_bottomPanelAnimateTime, realTime: false, delegate
+            {
+                m_showingBottomPanel = show;
+            });
+        }
+        iTween.Stop(m_bottomPanel);
+        m_bottomPanel.transform.localPosition = origBottomPanelPos2;
 		iTween.MoveTo(m_bottomPanel, iTween.Hash("position", origBottomPanelPos, "islocal", true, "time", m_bottomPanelAnimateTime, "delay", num));
-	}
-
-	public void OnTrayToggled(bool shown)
-	{
-		if (shown)
-		{
-			StartCoroutine(ShowTutorialPopup());
-		}
-		else
-		{
-			CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.CARDS, triggerResponse: true);
-		}
-	}
-
-	private IEnumerator ShowTutorialPopup()
-	{
-		yield return new WaitForSeconds(0.5f);
-		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (collectionManagerDisplay != null && !Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DeckTemplatePicker.ShowTutorialPopup:" + Option.HAS_SEEN_DECK_TEMPLATE_SCREEN))
-		{
-			Transform deckTemplateTutorialWelcomeBone = collectionManagerDisplay.m_deckTemplateTutorialWelcomeBone;
-			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, deckTemplateTutorialWelcomeBone.localPosition, GameStrings.Get("GLUE_COLLECTION_TUTORIAL_TEMPLATE_WELCOME"), "VO_INNKEEPER_Male_Dwarf_RECIPE1_01.prefab:0261ef622a5e2b945a8f89e87cbe01a7", 3f);
-			Options.Get().SetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, val: true);
-		}
-	}
-
-	public void SetDeckFormatAndClass(FormatType deckFormat, TAG_CLASS deckClass)
-	{
-		m_currentSelectedFormat = deckFormat;
-		m_currentSelectedClass = deckClass;
-		List<CollectionManager.TemplateDeck> nonStarterTemplateDecks = CollectionManager.Get().GetNonStarterTemplateDecks(m_currentSelectedFormat, m_currentSelectedClass);
-		int num = nonStarterTemplateDecks?.Count ?? 0;
-		Color color = CollectionPageManager.ColorForClass(deckClass);
-		m_pageHeaderText.Text = GameStrings.Format("GLUE_DECK_TEMPLATE_CHOOSE_DECK", GameStrings.GetClassName(deckClass));
-		CollectionPageDisplay.SetPageFlavorTextures(m_pageHeader, CollectionPageDisplay.TagClassToHeaderClass(deckClass));
-		for (int i = 0; i < m_pickerButtons.Count; i++)
-		{
-			DeckTemplatePickerButton deckTemplatePickerButton = m_pickerButtons[i];
-			bool flag = i < num;
-			deckTemplatePickerButton.gameObject.SetActive(flag);
-			if (!flag)
-			{
-				continue;
-			}
-			CollectionManager.TemplateDeck templateDeck = nonStarterTemplateDecks[i];
-			deckTemplatePickerButton.SetTitleText(templateDeck.m_title);
-			int num2 = 0;
-			int num3 = 0;
-			foreach (KeyValuePair<string, int> cardId in templateDeck.m_cardIds)
-			{
-				CollectionManager.Get().GetOwnedCardCount(cardId.Key, out var normal, out var golden, out var signature, out var diamond);
-				int num4 = Mathf.Min(normal + golden + signature + diamond, cardId.Value);
-				num2 += num4;
-				num3 += cardId.Value;
-			}
-			deckTemplatePickerButton.SetCardCountText(num2, num3);
-			deckTemplatePickerButton.m_packRibbon.GetMaterial().color = color;
-			DeckTemplateDbfRecord record = GameDbf.DeckTemplate.GetRecord(templateDeck.m_deckTemplateId);
-			if (record != null && record.DisplayCardId != 0)
-			{
-				deckTemplatePickerButton.SetDeckArtByCardId(record.DisplayCardId, m_deckArtMaterial, record);
-			}
-			else
-			{
-				deckTemplatePickerButton.SetDeckArtByMaterialPath(templateDeck.m_displayTexture, record);
-			}
-		}
-		if (m_customDeckButton != null)
-		{
-			m_customDeckButton.m_deckTexture.GetMaterial().mainTextureOffset = CollectionPageManager.s_classTextureOffsets[deckClass];
-			m_customDeckButton.m_packRibbon.GetMaterial().color = color;
-		}
-	}
-
-	private void SelectButtonWithIndex(int index)
-	{
-		((Action)delegate
-		{
-			if (m_chooseButton != null)
-			{
-				m_chooseButton.Enable();
-			}
-			List<CollectionManager.TemplateDeck> nonStarterTemplateDecks = CollectionManager.Get().GetNonStarterTemplateDecks(m_currentSelectedFormat, m_currentSelectedClass);
-			CollectionManager.TemplateDeck templateDeck = m_customDeck;
-			if (nonStarterTemplateDecks != null && index < nonStarterTemplateDecks.Count)
-			{
-				templateDeck = nonStarterTemplateDecks[index];
-			}
-			for (int i = 0; i < m_pickerButtons.Count; i++)
-			{
-				m_pickerButtons[i].SetSelected(i == index);
-			}
-			if (m_deckTemplateDescription != null)
-			{
-				m_deckTemplateDescription.Text = templateDeck.m_description;
-			}
-			if (m_deckTemplatePhoneName != null)
-			{
-				m_deckTemplatePhoneName.Text = templateDeck.m_title;
-			}
-			if (m_customDeckButton != null)
-			{
-				m_customDeckButton.SetSelected(selected: false);
-			}
-			m_currentSelectedDeck = templateDeck;
-			if ((bool)UniversalInputManager.UsePhoneUI)
-			{
-				SlidingTray component = m_phoneTray.GetComponent<SlidingTray>();
-				if (component.TraySliderIsAnimating())
-				{
-					return;
-				}
-				m_phoneTray.gameObject.SetActive(value: true);
-				component.ShowTray();
-				m_phoneTray.m_scrollbar.LoadScroll("start", snap: false);
-				m_phoneTray.FlashDeckTemplateHighlight();
-			}
-			else
-			{
-				CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
-				if (collectionDeckTray != null)
-				{
-					collectionDeckTray.FlashDeckTemplateHighlight();
-				}
-			}
-			FillDeckWithTemplate(m_currentSelectedDeck);
-			StartCoroutine(ShowTips());
-		})();
-	}
-
-	public IEnumerator ShowTips()
-	{
-		if ((bool)UniversalInputManager.UsePhoneUI)
-		{
-			while (m_phoneTray.GetComponent<SlidingTray>().TraySliderIsAnimating())
-			{
-				yield return null;
-			}
-		}
-	}
-
-	private void FillDeckWithTemplate(CollectionManager.TemplateDeck tplDeck)
-	{
-		CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
-		if (collectionDeckTray == null)
-		{
-			Log.ErrorReporter.PrintError("DeckTemplatePicker::FillDeckWithTemplate deckTray is null!");
-			return;
-		}
-		DeckTrayCardListContent cardsContent = collectionDeckTray.GetCardsContent();
-		if (cardsContent == null)
-		{
-			Log.ErrorReporter.PrintError("DeckTemplatePicker::FillDeckWithTemplate cardListContent is null!");
-			return;
-		}
-		CollectionDeck editingDeck = cardsContent.GetEditingDeck();
-		if (editingDeck == null)
-		{
-			Log.ErrorReporter.PrintError("DeckTemplatePicker::FillDeckWithTemplate currentDeck is null!");
-			return;
-		}
-		if (tplDeck == null)
-		{
-			CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-			editingDeck.CopyFrom(editedDeck);
-		}
-		else
-		{
-			editingDeck.FillFromTemplateDeck(tplDeck);
-		}
-		collectionDeckTray.m_cardsContent.UpdateCardList();
-		collectionDeckTray.m_decksContent.UpdateDeckName();
-		collectionDeckTray.InitializeRuneIndicatorVisual(editingDeck);
-		if (m_phoneTray != null)
-		{
-			CollectionDeck editingDeck2 = m_phoneTray.m_cardsContent.GetEditingDeck();
-			if (tplDeck == null)
-			{
-				CollectionDeck editedDeck2 = CollectionManager.Get().GetEditedDeck();
-				editingDeck2.CopyFrom(editedDeck2);
-			}
-			else
-			{
-				editingDeck2.FillFromTemplateDeck(tplDeck);
-			}
-			if (editingDeck2.HasClass(TAG_CLASS.DEATHKNIGHT))
-			{
-				m_runeIndicatorVisual.Show();
-				m_runeIndicatorVisual.Initialize(editingDeck2, collectionDeckTray);
-				m_phoneTray.m_cardsContent.SetRuneIndicatorSpacerVisible(visible: true);
-				m_runeIndicatorVisual.DisableRuneButtons();
-			}
-			else
-			{
-				m_runeIndicatorVisual.Hide();
-				m_phoneTray.m_cardsContent.SetRuneIndicatorSpacerVisible(visible: false);
-			}
-			m_phoneTray.m_cardsContent.UpdateCardList();
-			LayerUtils.SetLayer(m_phoneTray, GameLayer.IgnoreFullScreenEffects);
-		}
-	}
-
-	private void FillWithCustomDeck()
-	{
-		FillDeckWithTemplate(null);
-	}
-
-	private void FireOnTemplateDeckChosenEvent()
-	{
-		OnTemplateDeckChosen[] array = m_templateDeckChosenListeners.ToArray();
-		for (int i = 0; i < array.Length; i++)
-		{
-			array[i]();
-		}
-	}
-
-	private IEnumerator HideTrays()
-	{
-		SlidingTray phoneTray = m_phoneTray.GetComponent<SlidingTray>();
-		phoneTray.HideTray();
-		while (phoneTray.isActiveAndEnabled && !phoneTray.IsTrayInShownPosition())
-		{
-			yield return new WaitForEndOfFrame();
-		}
-		GetComponent<SlidingTray>().HideTray();
-	}
-
-	private void ChooseRecipeAndFillInCards()
-	{
-		CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
-		if (collectionDeckTray == null)
-		{
-			Log.ErrorReporter.PrintError("DeckTemplatePicker::ChooseRecipeAndFillInCards deckTray is null!");
-			return;
-		}
-		DeckTrayCardListContent cardsContent = collectionDeckTray.GetCardsContent();
-		if (cardsContent == null)
-		{
-			Log.ErrorReporter.PrintError("DeckTemplatePicker::ChooseRecipeAndFillInCards cardListContent is null!");
-			return;
-		}
-		CollectionManager collectionManager = CollectionManager.Get();
-		if (collectionManager == null)
-		{
-			Log.ErrorReporter.PrintError("DeckTemplatePicker::ChooseRecipeAndFillInCards collectionManager is null!");
-			return;
-		}
-		cardsContent.CommitFakeDeckChanges();
-		collectionManager.SetShowDeckTemplatePageForClass(m_currentSelectedClass, m_currentSelectedDeck != m_customDeck);
-		FireOnTemplateDeckChosenEvent();
-		CollectionDeck editedDeck = collectionManager.GetEditedDeck();
-		collectionDeckTray.InitializeRuneIndicatorVisual(editedDeck);
-		if (m_currentSelectedDeck != m_customDeck)
-		{
-			editedDeck.SourceType = DeckSourceType.DECK_SOURCE_TYPE_TEMPLATE;
-			Network.Get().SetDeckTemplateSource(editedDeck.ID, m_currentSelectedDeck.m_id);
-		}
-		Navigation.RemoveHandler(OnNavigateBack);
-		if ((bool)UniversalInputManager.UsePhoneUI)
-		{
-			StartCoroutine(EnterDeckPhone());
-		}
-		CollectionManagerDisplay collectionManagerDisplay = collectionManager.GetCollectibleDisplay() as CollectionManagerDisplay;
-		if (collectionManagerDisplay != null && collectionManager.ShouldShowWildToStandardTutorial() && editedDeck.FormatType == FormatType.FT_STANDARD)
-		{
-			collectionManagerDisplay.ShowStandardInfoTutorial(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
-		}
-		if (editedDeck.HasClass(TAG_CLASS.DEATHKNIGHT))
-		{
-			TutorialDeathKnightDeckBuilding.ShowTutorial(UIVoiceLinesManager.TriggerType.STARTED_EDITING_DEATH_KNIGHT_DECK);
-		}
-	}
-
-	private void SelectCustomDeckButton(bool preselect = false)
-	{
-		CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
-		if (collectionDeckTray != null && !preselect)
-		{
-			collectionDeckTray.FlashDeckTemplateHighlight();
-		}
-		if (m_chooseButton != null)
-		{
-			m_chooseButton.Enable();
-		}
-		for (int i = 0; i < m_pickerButtons.Count; i++)
-		{
-			m_pickerButtons[i].SetSelected(selected: false);
-		}
-		if (m_customDeckButton != null)
-		{
-			m_customDeckButton.SetSelected(selected: true);
-		}
-		if (m_deckTemplateDescription != null)
-		{
-			m_deckTemplateDescription.Text = GameStrings.Get("GLUE_DECK_TEMPLATE_CUSTOM_DECK_DESCRIPTION");
-		}
-		FillWithCustomDeck();
-		m_currentSelectedDeck = m_customDeck;
-		if ((bool)UniversalInputManager.UsePhoneUI && !preselect)
-		{
-			ChooseRecipeAndFillInCards();
-		}
-	}
-
-	public IEnumerator EnterDeckPhone()
-	{
-		yield return StartCoroutine(ShowPacks(show: false));
-		yield return StartCoroutine(HideTrays());
-	}
+    }
+
+    public void OnTrayToggled(bool shown)
+    {
+        if (shown)
+        {
+            StartCoroutine(ShowTutorialPopup());
+        }
+        else
+        {
+            CollectionManager.Get().GetCollectibleDisplay().SetViewMode(CollectionUtils.ViewMode.CARDS, triggerResponse: true);
+        }
+    }
+
+    private IEnumerator ShowTutorialPopup()
+    {
+        yield return new WaitForSeconds(0.5f);
+        CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
+        if (collectionManagerDisplay != null && !Options.Get().GetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DeckTemplatePicker.ShowTutorialPopup:" + Option.HAS_SEEN_DECK_TEMPLATE_SCREEN))
+        {
+            Transform deckTemplateTutorialWelcomeBone = collectionManagerDisplay.m_deckTemplateTutorialWelcomeBone;
+            NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, deckTemplateTutorialWelcomeBone.localPosition, GameStrings.Get("GLUE_COLLECTION_TUTORIAL_TEMPLATE_WELCOME"), "VO_INNKEEPER_Male_Dwarf_RECIPE1_01.prefab:0261ef622a5e2b945a8f89e87cbe01a7", 3f);
+            Options.Get().SetBool(Option.HAS_SEEN_DECK_TEMPLATE_SCREEN, val: true);
+        }
+    }
+
+    public void SetDeckFormatAndClass(FormatType deckFormat, TAG_CLASS deckClass)
+    {
+        m_currentSelectedFormat = deckFormat;
+        m_currentSelectedClass = deckClass;
+        List<CollectionManager.TemplateDeck> nonStarterTemplateDecks = CollectionManager.Get().GetNonStarterTemplateDecks(m_currentSelectedFormat, m_currentSelectedClass);
+        int num = nonStarterTemplateDecks?.Count ?? 0;
+        Color color = CollectionPageManager.ColorForClass(deckClass);
+        m_pageHeaderText.Text = GameStrings.Format("GLUE_DECK_TEMPLATE_CHOOSE_DECK", GameStrings.GetClassName(deckClass));
+        CollectionPageDisplay.SetPageFlavorTextures(m_pageHeader, CollectionPageDisplay.TagClassToHeaderClass(deckClass));
+        for (int i = 0; i < m_pickerButtons.Count; i++)
+        {
+            DeckTemplatePickerButton deckTemplatePickerButton = m_pickerButtons[i];
+            bool flag = i < num;
+            deckTemplatePickerButton.gameObject.SetActive(flag);
+            if (!flag)
+            {
+                continue;
+            }
+            CollectionManager.TemplateDeck templateDeck = nonStarterTemplateDecks[i];
+            deckTemplatePickerButton.SetTitleText(templateDeck.m_title);
+            int num2 = 0;
+            int num3 = 0;
+            foreach (KeyValuePair<string, int> cardId in templateDeck.m_cardIds)
+            {
+                CollectionManager.Get().GetOwnedCardCount(cardId.Key, out var normal, out var golden, out var signature, out var diamond);
+                int num4 = Mathf.Min(normal + golden + signature + diamond, cardId.Value);
+                num2 += num4;
+                num3 += cardId.Value;
+            }
+            deckTemplatePickerButton.SetCardCountText(num2, num3);
+            deckTemplatePickerButton.m_packRibbon.GetMaterial().color = color;
+            DeckTemplateDbfRecord record = GameDbf.DeckTemplate.GetRecord(templateDeck.m_deckTemplateId);
+            if (record != null && record.DisplayCardId != 0)
+            {
+                deckTemplatePickerButton.SetDeckArtByCardId(record.DisplayCardId, m_deckArtMaterial, record);
+            }
+            else
+            {
+                deckTemplatePickerButton.SetDeckArtByMaterialPath(templateDeck.m_displayTexture, record);
+            }
+        }
+        if (m_customDeckButton != null)
+        {
+            m_customDeckButton.m_deckTexture.GetMaterial().mainTextureOffset = CollectionPageManager.s_classTextureOffsets[deckClass];
+            m_customDeckButton.m_packRibbon.GetMaterial().color = color;
+        }
+    }
+
+    private void SelectButtonWithIndex(int index)
+    {
+        ((Action)delegate
+        {
+            if (m_chooseButton != null)
+            {
+                m_chooseButton.Enable();
+            }
+            List<CollectionManager.TemplateDeck> nonStarterTemplateDecks = CollectionManager.Get().GetNonStarterTemplateDecks(m_currentSelectedFormat, m_currentSelectedClass);
+            CollectionManager.TemplateDeck templateDeck = m_customDeck;
+            if (nonStarterTemplateDecks != null && index < nonStarterTemplateDecks.Count)
+            {
+                templateDeck = nonStarterTemplateDecks[index];
+            }
+            for (int i = 0; i < m_pickerButtons.Count; i++)
+            {
+                m_pickerButtons[i].SetSelected(i == index);
+            }
+            if (m_deckTemplateDescription != null)
+            {
+                m_deckTemplateDescription.Text = templateDeck.m_description;
+            }
+            if (m_deckTemplatePhoneName != null)
+            {
+                m_deckTemplatePhoneName.Text = templateDeck.m_title;
+            }
+            if (m_customDeckButton != null)
+            {
+                m_customDeckButton.SetSelected(selected: false);
+            }
+            m_currentSelectedDeck = templateDeck;
+            if ((bool)UniversalInputManager.UsePhoneUI)
+            {
+                SlidingTray component = m_phoneTray.GetComponent<SlidingTray>();
+                if (component.TraySliderIsAnimating())
+                {
+                    return;
+                }
+                m_phoneTray.gameObject.SetActive(value: true);
+                component.ShowTray();
+                m_phoneTray.m_scrollbar.LoadScroll("start", snap: false);
+                m_phoneTray.FlashDeckTemplateHighlight();
+            }
+            else
+            {
+                CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
+                if (collectionDeckTray != null)
+                {
+                    collectionDeckTray.FlashDeckTemplateHighlight();
+                }
+            }
+            FillDeckWithTemplate(m_currentSelectedDeck);
+            StartCoroutine(ShowTips());
+
+            OnAccessibleDeckTemplateChosen(false);
+        })();
+    }
+
+    public IEnumerator ShowTips()
+    {
+        if ((bool)UniversalInputManager.UsePhoneUI)
+        {
+            while (m_phoneTray.GetComponent<SlidingTray>().TraySliderIsAnimating())
+            {
+                yield return null;
+            }
+        }
+    }
+
+    private void FillDeckWithTemplate(CollectionManager.TemplateDeck tplDeck)
+    {
+        CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
+        if (collectionDeckTray == null)
+        {
+            Log.ErrorReporter.PrintError("DeckTemplatePicker::FillDeckWithTemplate deckTray is null!");
+            return;
+        }
+        DeckTrayCardListContent cardsContent = collectionDeckTray.GetCardsContent();
+        if (cardsContent == null)
+        {
+            Log.ErrorReporter.PrintError("DeckTemplatePicker::FillDeckWithTemplate cardListContent is null!");
+            return;
+        }
+        CollectionDeck editingDeck = cardsContent.GetEditingDeck();
+        if (editingDeck == null)
+        {
+            Log.ErrorReporter.PrintError("DeckTemplatePicker::FillDeckWithTemplate currentDeck is null!");
+            return;
+        }
+        if (tplDeck == null)
+        {
+            CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+            editingDeck.CopyFrom(editedDeck);
+        }
+        else
+        {
+            editingDeck.FillFromTemplateDeck(tplDeck);
+        }
+        collectionDeckTray.m_cardsContent.UpdateCardList();
+        collectionDeckTray.m_decksContent.UpdateDeckName();
+        collectionDeckTray.InitializeRuneIndicatorVisual(editingDeck);
+        if (m_phoneTray != null)
+        {
+            CollectionDeck editingDeck2 = m_phoneTray.m_cardsContent.GetEditingDeck();
+            if (tplDeck == null)
+            {
+                CollectionDeck editedDeck2 = CollectionManager.Get().GetEditedDeck();
+                editingDeck2.CopyFrom(editedDeck2);
+            }
+            else
+            {
+                editingDeck2.FillFromTemplateDeck(tplDeck);
+            }
+            if (editingDeck2.HasClass(TAG_CLASS.DEATHKNIGHT))
+            {
+                m_runeIndicatorVisual.Show();
+                m_runeIndicatorVisual.Initialize(editingDeck2, collectionDeckTray);
+                m_phoneTray.m_cardsContent.SetRuneIndicatorSpacerVisible(visible: true);
+                m_runeIndicatorVisual.DisableRuneButtons();
+            }
+            else
+            {
+                m_runeIndicatorVisual.Hide();
+                m_phoneTray.m_cardsContent.SetRuneIndicatorSpacerVisible(visible: false);
+            }
+            m_phoneTray.m_cardsContent.UpdateCardList();
+            LayerUtils.SetLayer(m_phoneTray, GameLayer.IgnoreFullScreenEffects);
+        }
+    }
+
+    private void FillWithCustomDeck()
+    {
+        FillDeckWithTemplate(null);
+    }
+
+    private void FireOnTemplateDeckChosenEvent()
+    {
+        OnTemplateDeckChosen[] array = m_templateDeckChosenListeners.ToArray();
+        for (int i = 0; i < array.Length; i++)
+        {
+            array[i]();
+        }
+    }
+
+    private IEnumerator HideTrays()
+    {
+        SlidingTray phoneTray = m_phoneTray.GetComponent<SlidingTray>();
+        phoneTray.HideTray();
+        while (phoneTray.isActiveAndEnabled && !phoneTray.IsTrayInShownPosition())
+        {
+            yield return new WaitForEndOfFrame();
+        }
+        GetComponent<SlidingTray>().HideTray();
+    }
+
+    private void ChooseRecipeAndFillInCards()
+    {
+        CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
+        if (collectionDeckTray == null)
+        {
+            Log.ErrorReporter.PrintError("DeckTemplatePicker::ChooseRecipeAndFillInCards deckTray is null!");
+            return;
+        }
+        DeckTrayCardListContent cardsContent = collectionDeckTray.GetCardsContent();
+        if (cardsContent == null)
+        {
+            Log.ErrorReporter.PrintError("DeckTemplatePicker::ChooseRecipeAndFillInCards cardListContent is null!");
+            return;
+        }
+        CollectionManager collectionManager = CollectionManager.Get();
+        if (collectionManager == null)
+        {
+            Log.ErrorReporter.PrintError("DeckTemplatePicker::ChooseRecipeAndFillInCards collectionManager is null!");
+            return;
+        }
+        cardsContent.CommitFakeDeckChanges();
+        collectionManager.SetShowDeckTemplatePageForClass(m_currentSelectedClass, m_currentSelectedDeck != m_customDeck);
+        FireOnTemplateDeckChosenEvent();
+        CollectionDeck editedDeck = collectionManager.GetEditedDeck();
+        collectionDeckTray.InitializeRuneIndicatorVisual(editedDeck);
+        if (m_currentSelectedDeck != m_customDeck)
+        {
+            editedDeck.SourceType = DeckSourceType.DECK_SOURCE_TYPE_TEMPLATE;
+            Network.Get().SetDeckTemplateSource(editedDeck.ID, m_currentSelectedDeck.m_id);
+        }
+        Navigation.RemoveHandler(OnNavigateBack);
+        if ((bool)UniversalInputManager.UsePhoneUI)
+        {
+            StartCoroutine(EnterDeckPhone());
+        }
+        CollectionManagerDisplay collectionManagerDisplay = collectionManager.GetCollectibleDisplay() as CollectionManagerDisplay;
+        if (collectionManagerDisplay != null && collectionManager.ShouldShowWildToStandardTutorial() && editedDeck.FormatType == FormatType.FT_STANDARD)
+        {
+            collectionManagerDisplay.ShowStandardInfoTutorial(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+        }
+
+        AccessibleCollectionManager.Get().OnEditDeckScreen();
+        if (editedDeck.HasClass(TAG_CLASS.DEATHKNIGHT))
+        {
+            TutorialDeathKnightDeckBuilding.ShowTutorial(UIVoiceLinesManager.TriggerType.STARTED_EDITING_DEATH_KNIGHT_DECK);
+        }
+    }
+
+    private void SelectCustomDeckButton(bool preselect = false)
+    {
+        CollectionDeckTray collectionDeckTray = CollectionDeckTray.Get();
+        if (collectionDeckTray != null && !preselect)
+        {
+            collectionDeckTray.FlashDeckTemplateHighlight();
+        }
+        if (m_chooseButton != null)
+        {
+            m_chooseButton.Enable();
+        }
+        for (int i = 0; i < m_pickerButtons.Count; i++)
+        {
+            m_pickerButtons[i].SetSelected(selected: false);
+        }
+        if (m_customDeckButton != null)
+        {
+            m_customDeckButton.SetSelected(selected: true);
+        }
+        if (m_deckTemplateDescription != null)
+        {
+            m_deckTemplateDescription.Text = GameStrings.Get("GLUE_DECK_TEMPLATE_CUSTOM_DECK_DESCRIPTION");
+        }
+        FillWithCustomDeck();
+        m_currentSelectedDeck = m_customDeck;
+        if ((bool)UniversalInputManager.UsePhoneUI && !preselect)
+        {
+            ChooseRecipeAndFillInCards();
+        }
+
+        OnAccessibleDeckTemplateChosen(true);
+    }
+
+    public IEnumerator EnterDeckPhone()
+    {
+        yield return StartCoroutine(ShowPacks(show: false));
+        yield return StartCoroutine(HideTrays());
+    }
+
+    #region Accessibility
+
+    private enum State { LOADING, CHOOSING_TEMPLATE, TEMPLATE_CHOSEN, CUSTOM_DECK_CHOSEN };
+
+    private State m_curState;
+
+    private AccessibleHorizontalMenu<AccessibleDeckTemplatePickerButton> m_accessibleButtons;
+
+    private void ReadDeckTemplatePicker()
+    {
+        m_curState = State.LOADING;
+
+        AccessibilityMgr.SetScreen(this);
+
+        SetupChooseTemplateMenu();
+    }
+
+    private void SetupChooseTemplateMenu()
+    {
+        m_accessibleButtons = new AccessibleHorizontalMenu<AccessibleDeckTemplatePickerButton>(this, m_pageHeaderText.Text, () => AccessibilityUtils.GoBackToHub());
+
+        foreach (var deck in m_pickerButtons)
+        {
+            m_accessibleButtons.AddOption(new AccessibleDeckTemplatePickerButton(this, deck), () => deck.TriggerRelease());
+        }
+
+        m_accessibleButtons.AddOption(new AccessibleDeckTemplatePickerButton(this, m_customDeckButton, true), () => m_customDeckButton.TriggerRelease());
+
+        m_accessibleButtons.StartReading();
+
+        m_curState = State.CHOOSING_TEMPLATE;
+    }
+
+    private void OnAccessibleDeckTemplateChosen(bool isCustomDeck)
+    {
+        if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+            // Race conditions on preselect. It doesn't make sense to say this out loud unless we're choosing though
+            if (isCustomDeck)
+            {
+                SetupCustomDeckChosen();
+            }
+            else
+            {
+                SetupTemplateChosen();
+            }
+        }
+    }
+
+    private void SetupCustomDeckChosen()
+    {
+        AccessibilityMgr.Output(this, GetCustomDeckChooseHelpMessage());
+        m_curState = State.CUSTOM_DECK_CHOSEN;
+    }
+
+    private void SetupTemplateChosen()
+    {
+        AccessibilityMgr.Output(this, GetTemplateChooseHelpMessage());
+        m_curState = State.TEMPLATE_CHOSEN;
+    }
+
+    public void HandleInput()
+    {
+        if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+            m_accessibleButtons?.HandleAccessibleInput();
+        }
+        else if (m_curState == State.TEMPLATE_CHOSEN || m_curState == State.CUSTOM_DECK_CHOSEN)
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+                m_chooseButton?.TriggerRelease();
+            }
+            else if (AccessibleKey.BACK.IsPressed())
+            {
+                SetupChooseTemplateMenu();
+            }
+        }
+    }
+
+    public string GetHelp()
+    {
+        if (m_curState == State.TEMPLATE_CHOSEN)
+        {
+            return GetTemplateChooseHelpMessage();
+        }
+        else if (m_curState == State.CUSTOM_DECK_CHOSEN)
+        {
+            return GetCustomDeckChooseHelpMessage();
+        }
+        else if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+            return m_accessibleButtons?.GetHelp();
+        }
+
+        return "";
+    }
+
+    private string GetCustomDeckChooseHelpMessage()
+    {
+        return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_CUSTOM_DECK_CHOOSE_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+    }
+
+    private string GetTemplateChooseHelpMessage()
+    {
+        return LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_RECIPE_CHOOSE_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+    }
+
+    public void OnGainedFocus()
+    {
+        if (m_curState == State.TEMPLATE_CHOSEN)
+        {
+            AccessibilityMgr.Output(this, GetTemplateChooseHelpMessage());
+        }
+        else if (m_curState == State.CUSTOM_DECK_CHOSEN)
+        {
+            AccessibilityMgr.Output(this, GetCustomDeckChooseHelpMessage());
+        }
+        else if (m_curState == State.CHOOSING_TEMPLATE)
+        {
+            m_accessibleButtons.StartReading();
+        }
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/DeckTrayCardListContent.cs b/Assembly-CSharp/DeckTrayCardListContent.cs
index 1ec467f..d81f2b4 100644
--- a/Assembly-CSharp/DeckTrayCardListContent.cs
+++ b/Assembly-CSharp/DeckTrayCardListContent.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Hearthstone.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class DeckTrayCardListContent : DeckTrayContent
@@ -623,9 +624,13 @@ public class DeckTrayCardListContent : DeckTrayContent
 			CollectionManager.Get().GetCollectibleDisplay().UpdateCurrentPageCardLocks(playSound: true);
 		}
 		DeckHelper.Get().OnCardAdded(editingDeck);
-		if (!Options.Get().GetBool(Option.HAS_ADDED_CARDS_TO_DECK, defaultVal: false) && !m_isSideboardContent && editingDeck.GetTotalCardCount() >= 2 && !DeckHelper.Get().IsActive() && editingDeck.GetTotalCardCount() < 15 && UserAttentionManager.CanShowAttentionGrabber("DeckTrayCardListContent.AddCard:" + Option.HAS_ADDED_CARDS_TO_DECK))
+
+		if (!Options.Get().GetBool(Option.HAS_ADDED_CARDS_TO_DECK, defaultVal: false) && !m_isSideboardContent && editingDeck.GetTotalCardCount() >= 2 && !DeckHelper.Get().IsActive() && editingDeck.GetTotalCardCount() < 15 && UserAttentionManager.CanShowAttentionGrabber(true, "DeckTrayCardListContent.AddCard:" + Option.HAS_ADDED_CARDS_TO_DECK))
 		{
-			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_PAGEFLIP_28"), "VO_INNKEEPER_CM_PAGEFLIP_28.prefab:47bb7bdb89ad93443ab7d031bbe666fb");
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+			{
+				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_CM_PAGEFLIP_28"), "VO_INNKEEPER_CM_PAGEFLIP_28.prefab:47bb7bdb89ad93443ab7d031bbe666fb");
+			}
 			Options.Get().SetBool(Option.HAS_ADDED_CARDS_TO_DECK, val: true);
 		}
 		return true;
@@ -691,31 +696,31 @@ public class DeckTrayCardListContent : DeckTrayContent
 			{
 				if (collectionDeckSlot.GetEntityDef().HasTag(GAME_TAG.ZILLIAX_CUSTOMIZABLE_COSMETICMODULE))
 				{
-					continue;
-				}
-				num += collectionDeckSlot.Count;
+				continue;
+			}
+			num += collectionDeckSlot.Count;
 				DeckTrayDeckTileVisual orAddCardTileVisual = GetOrAddCardTileVisual(num2);
-				orAddCardTileVisual.SetInArena(m_inArena);
-				Vector3 vector2 = cardTileOffset;
+			orAddCardTileVisual.SetInArena(m_inArena);
+			Vector3 vector2 = cardTileOffset;
 				if (num2 > 0)
-				{
+			{
 					CollectionDeckTileActor actor = GetOrAddCardTileVisual(num2 - 1).GetActor();
 					float num3 = m_cardTileSlotLocalHeight;
-					if ((bool)actor)
+				if ((bool)actor)
+				{
+					EntityDef entityDef = actor.GetEntityDef();
+					if (entityDef != null && entityDef.HasSideboard)
 					{
-						EntityDef entityDef = actor.GetEntityDef();
-						if (entityDef != null && entityDef.HasSideboard)
-						{
 							num3 = m_cardTileSlotLocalHeightSideboard;
-						}
 					}
-					vector2 = vector + Vector3.down * num3;
 				}
-				vector = vector2;
-				orAddCardTileVisual.gameObject.transform.localPosition = vector2;
-				orAddCardTileVisual.MarkAsUsed();
-				orAddCardTileVisual.Show();
-				orAddCardTileVisual.SetSlot(currentDeck, collectionDeckSlot, justChangedCardID.Equals(collectionDeckSlot.CardID), offsetCardNameForRunes);
+					vector2 = vector + Vector3.down * num3;
+			}
+			vector = vector2;
+			orAddCardTileVisual.gameObject.transform.localPosition = vector2;
+			orAddCardTileVisual.MarkAsUsed();
+			orAddCardTileVisual.Show();
+			orAddCardTileVisual.SetSlot(currentDeck, collectionDeckSlot, justChangedCardID.Equals(collectionDeckSlot.CardID), offsetCardNameForRunes);
 				num2++;
 			}
 		}
@@ -1010,10 +1015,14 @@ public class DeckTrayCardListContent : DeckTrayContent
 		Transform removeCardTutorialBone = CollectionDeckTray.Get().m_removeCardTutorialBone;
 		if (m_deckHelpPopup == null)
 		{
-			m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, removeCardTutorialBone.position, removeCardTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL08"));
-			if (m_deckHelpPopup != null)
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
 			{
-				m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+				// Visual notification
+				m_deckHelpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, removeCardTutorialBone.position, removeCardTutorialBone.localScale, GameStrings.Get("GLUE_COLLECTION_TUTORIAL08"));
+				if (m_deckHelpPopup != null)
+				{
+					m_deckHelpPopup.PulseReminderEveryXSeconds(3f);
+				}
 			}
 		}
 	}
@@ -1078,13 +1087,13 @@ public class DeckTrayCardListContent : DeckTrayContent
 			if (!m_isSideboardContent)
 			{
 				if (CollectionManager.Get().IsEditingDeathKnightDeck())
-				{
-					deckTemplateHelpButtonOriginalLocalPosition.y = m_deckTemplateHelpButtonDeathKnightPosY;
-				}
-				else
-				{
-					deckTemplateHelpButtonOriginalLocalPosition = m_deckTemplateHelpButtonOriginalLocalPosition;
-				}
+			{
+				deckTemplateHelpButtonOriginalLocalPosition.y = m_deckTemplateHelpButtonDeathKnightPosY;
+			}
+			else
+			{
+				deckTemplateHelpButtonOriginalLocalPosition = m_deckTemplateHelpButtonOriginalLocalPosition;
+			}
 				if (editingDeck.FormatType == FormatType.FT_TWIST)
 				{
 					if (CollectionManager.Get().IsEditingDeathKnightDeck())
@@ -1446,4 +1455,13 @@ public class DeckTrayCardListContent : DeckTrayContent
 			array[i](cardCount, maxCount);
 		}
 	}
+
+	#region Accessibility
+
+	internal List<DeckTrayDeckTileVisual> GetCardTiles()
+	{
+		return m_cardTiles;
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/DeckTrayDeckListContent.cs b/Assembly-CSharp/DeckTrayDeckListContent.cs
index 21d5cfc..1d47438 100644
--- a/Assembly-CSharp/DeckTrayDeckListContent.cs
+++ b/Assembly-CSharp/DeckTrayDeckListContent.cs
@@ -7,6 +7,7 @@ using Hearthstone;
 using Hearthstone.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class DeckTrayDeckListContent : DeckTrayReorderableContent
@@ -62,13 +63,13 @@ public class DeckTrayDeckListContent : DeckTrayReorderableContent
 
 	protected CollectionDeckInfo m_deckInfoTooltip;
 
-	protected List<TraySection> m_traySections = new List<TraySection>();
+	internal List<TraySection> m_traySections = new List<TraySection>();
 
-	protected TraySection m_editingTraySection;
+	internal TraySection m_editingTraySection;
 
 	protected int m_centeringDeckList = -1;
 
-	protected DeckOptionsMenu m_deckOptionsMenu;
+	internal DeckOptionsMenu m_deckOptionsMenu;
 
 	protected bool m_initialized;
 
@@ -566,11 +567,14 @@ public class DeckTrayDeckListContent : DeckTrayReorderableContent
 				deckBox.SetDeckName(collectionDeck.Name);
 			}
 			deckBox.ShowDeckName();
+      AccessibleCollectionManager.Get().OnFinishRenamingDeck();
 		}
 	}
 
 	public void CreateNewDeckFromUserSelection(TAG_CLASS heroClass, string heroCardID, string customDeckName = null, DeckSourceType deckSourceType = DeckSourceType.DECK_SOURCE_TYPE_NORMAL, string pastedDeckHashString = null)
 	{
+		AccessibleCollectionManager.Get().PrepareToEditDeck();
+
 		bool num = SceneMgr.Get().IsInTavernBrawlMode();
 		bool flag = SceneMgr.Get().GetMode() == SceneMgr.Mode.PVP_DUNGEON_RUN;
 		DeckType deckType = DeckType.NORMAL_DECK;
@@ -578,8 +582,8 @@ public class DeckTrayDeckListContent : DeckTrayReorderableContent
 		if (num)
 		{
 			value = GameStrings.Get("GLUE_COLLECTION_TAVERN_BRAWL_DECKNAME");
-			deckType = DeckType.TAVERN_BRAWL_DECK;
-		}
+				deckType = DeckType.TAVERN_BRAWL_DECK;
+			}
 		else if (flag)
 		{
 			deckType = DeckType.PVPDR_DECK;
@@ -1074,12 +1078,12 @@ public class DeckTrayDeckListContent : DeckTrayReorderableContent
 			{
 				break;
 			}
-			if (traySection.m_deckBox.GetDeckID() == -1)
-			{
-				return result;
-			}
-			result = traySection;
-			num++;
+				if (traySection.m_deckBox.GetDeckID() == -1)
+				{
+					return result;
+				}
+				result = traySection;
+				num++;
 		}
 		return result;
 	}
diff --git a/Assembly-CSharp/DeckTrayDeckTileVisual.cs b/Assembly-CSharp/DeckTrayDeckTileVisual.cs
index 15b48d4..82dea9e 100644
--- a/Assembly-CSharp/DeckTrayDeckTileVisual.cs
+++ b/Assembly-CSharp/DeckTrayDeckTileVisual.cs
@@ -180,7 +180,7 @@ public class DeckTrayDeckTileVisual : PegUIElement
 		m_actor.UpdateCardRuneBannerComponent();
 	}
 
-	private CollectionDeckTileActor.GhostedState GetGhostedState()
+	public CollectionDeckTileActor.GhostedState GetGhostedState()
 	{
 		CollectionDeckTileActor.GhostedState result = CollectionDeckTileActor.GhostedState.NONE;
 		if (m_deck != null)
@@ -264,18 +264,18 @@ public class DeckTrayDeckTileVisual : PegUIElement
 		m_actor.UpdateDeckCardProperties(flag, isMultiCard: false, m_slot.Count, m_useSliderAnimations);
 		if (m_defHandleOverride == null)
 		{
-			DefLoader.Get().LoadCardDef(entityDef.GetCardId(), delegate(string cardID, DefLoader.DisposableCardDef cardDef, object data)
+		DefLoader.Get().LoadCardDef(entityDef.GetCardId(), delegate(string cardID, DefLoader.DisposableCardDef cardDef, object data)
+		{
+			using (cardDef)
 			{
-				using (cardDef)
+				if (!(m_actor == null) && cardID.Equals(m_actor.GetEntityDef().GetCardId()))
 				{
-					if (!(m_actor == null) && cardID.Equals(m_actor.GetEntityDef().GetCardId()))
-					{
-						m_actor.SetCardDef(cardDef);
-						m_actor.UpdateAllComponents();
-						m_actor.UpdateGhostTileEffect();
-					}
+					m_actor.SetCardDef(cardDef);
+					m_actor.UpdateAllComponents();
+					m_actor.UpdateGhostTileEffect();
 				}
-			}, null, new CardPortraitQuality(1, tAG_PREMIUM));
+			}
+		}, null, new CardPortraitQuality(1, tAG_PREMIUM));
 			return;
 		}
 		DefLoader.DisposableCardDef disposableCardDef = m_defHandleOverride.Share();
@@ -319,4 +319,11 @@ public class DeckTrayDeckTileVisual : PegUIElement
 		}
 		return m_actor.GetEntityDef()?.HasRuneCost ?? false;
 	}
+
+	#region Accessibility
+	internal CollectionDeck GetDeck() {
+		return m_deck;
+	}
+	#endregion
+
 }
diff --git a/Assembly-CSharp/DialogBase.cs b/Assembly-CSharp/DialogBase.cs
index 790def1..8facf1a 100644
--- a/Assembly-CSharp/DialogBase.cs
+++ b/Assembly-CSharp/DialogBase.cs
@@ -2,8 +2,10 @@ using System.Collections;
 using System.Collections.Generic;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System;
 
-public class DialogBase : MonoBehaviour
+public abstract class DialogBase : MonoBehaviour, AccessibleUI
 {
 	public delegate void HideCallback(DialogBase dialog, object userData);
 
@@ -94,6 +96,7 @@ public class DialogBase : MonoBehaviour
 
 	public virtual void Hide()
 	{
+		AccessibilityMgr.HideUI(this);
 		m_shown = false;
 		StartCoroutine(HideWhenAble());
 	}
@@ -218,4 +221,8 @@ public class DialogBase : MonoBehaviour
 	{
 		m_screenEffectsHandle.StopEffect();
 	}
+
+    public abstract void HandleAccessibleInput();
+
+    public abstract string GetAccessibleHelp();
 }
diff --git a/Assembly-CSharp/DialogManager.cs b/Assembly-CSharp/DialogManager.cs
index f806a1c..25f0d5d 100644
--- a/Assembly-CSharp/DialogManager.cs
+++ b/Assembly-CSharp/DialogManager.cs
@@ -13,6 +13,7 @@ using Hearthstone.UI;
 using PegasusShared;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class DialogManager : MonoBehaviour
@@ -222,7 +223,7 @@ public class DialogManager : MonoBehaviour
 	public bool AddToQueue(DialogRequest request)
 	{
 		UserAttentionBlocker attentionCategory = request?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.AddToQueue:" + ((request == null) ? "null" : request.m_type.ToString())))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.AddToQueue:" + ((request == null) ? "null" : request.m_type.ToString())))
 		{
 			return false;
 		}
@@ -233,12 +234,12 @@ public class DialogManager : MonoBehaviour
 
 	private void UpdateQueue()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || m_currentDialog != null || m_loadingDialog || m_dialogRequests.Count == 0)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || m_currentDialog != null || m_loadingDialog || m_dialogRequests.Count == 0)
 		{
 			return;
 		}
 		DialogRequest dialogRequest = m_dialogRequests.Peek();
-		if (!UserAttentionManager.CanShowAttentionGrabber(dialogRequest.m_attentionCategory, "DialogManager.UpdateQueue:" + dialogRequest.m_attentionCategory))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, dialogRequest.m_attentionCategory, "DialogManager.UpdateQueue:" + dialogRequest.m_attentionCategory))
 		{
 			Processor.ScheduleCallback(0.5f, realTime: false, delegate
 			{
@@ -254,7 +255,7 @@ public class DialogManager : MonoBehaviour
 	public void ShowPopup(AlertPopup.PopupInfo info, DialogProcessCallback callback, object userData)
 	{
 		UserAttentionBlocker attentionCategory = info?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (!UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) && UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.ShowPopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
+		if (!UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) && UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.ShowPopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
 		{
 			DialogRequest dialogRequest = new DialogRequest();
 			dialogRequest.m_type = DialogType.ALERT;
@@ -279,7 +280,7 @@ public class DialogManager : MonoBehaviour
 	public bool ShowUniquePopup(AlertPopup.PopupInfo info, DialogProcessCallback callback, object userData)
 	{
 		UserAttentionBlocker attentionCategory = info?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.ShowUniquePopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.ShowUniquePopup:" + ((info == null) ? "null" : (info.m_id + ":" + info.m_attentionCategory))))
 		{
 			return false;
 		}
@@ -601,7 +602,7 @@ public class DialogManager : MonoBehaviour
 
 	public void ShowBonusStarsPopup(RankedPlayDataModel dataModel, Action onHiddenCallback)
 	{
-		RankedBonusStarsPopup.BonusStarsPopupInfo bonusStarsPopupInfo = new RankedBonusStarsPopup.BonusStarsPopupInfo
+		RankedBonusStarsPopup.BonusStarsPopupInfo bonusStarsPopupInfo = new RankedBonusStarsPopup.BonusStarsPopupInfo("")
 		{
 			m_onHiddenCallback = onHiddenCallback
 		};
@@ -618,7 +619,7 @@ public class DialogManager : MonoBehaviour
 
 	public void ShowRankedIntroPopUp(Action onHiddenCallback)
 	{
-		RankedIntroPopup.RankedIntroPopupInfo rankedIntroPopupInfo = new RankedIntroPopup.RankedIntroPopupInfo
+		RankedIntroPopup.RankedIntroPopupInfo rankedIntroPopupInfo = new RankedIntroPopup.RankedIntroPopupInfo("")
 		{
 			m_onHiddenCallback = onHiddenCallback
 		};
@@ -650,7 +651,13 @@ public class DialogManager : MonoBehaviour
 
 	public void ShowRewardTrackInfographic(Action onHiddenCallback)
 	{
-		RewardTrackInfographic.RewardTrackInfographicInfo info = new RewardTrackInfographic.RewardTrackInfographicInfo
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			RewardTrackInfographic.IncrementPopupSeenFlag();
+			onHiddenCallback();
+			return;
+		}
+		RewardTrackInfographic.RewardTrackInfographicInfo info = new RewardTrackInfographic.RewardTrackInfographicInfo("")
 		{
 			m_prefabAssetRefs = { (string)RewardTrackInfographic.PrefabReference },
 			m_onHiddenCallback = onHiddenCallback
@@ -722,7 +729,7 @@ public class DialogManager : MonoBehaviour
 			return (int)((a.OriginData != b.OriginData) ? (a.OriginData - b.OriginData) : (a.NoticeID - b.NoticeID));
 		});
 		NetCache.ProfileNotice profileNotice = MaybeShowSeasonEndDialog_GetLatestMedalNotice(newNotices);
-		if (profileNotice == null || !(profileNotice is NetCache.ProfileNoticeMedal profileNoticeMedal) || m_handledMedalNoticeIDs.Contains(profileNoticeMedal.NoticeID) || UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("DialogManager.MaybeShowSeasonEndDialog"))
+		if (profileNotice == null || !(profileNotice is NetCache.ProfileNoticeMedal profileNoticeMedal) || m_handledMedalNoticeIDs.Contains(profileNoticeMedal.NoticeID) || UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "DialogManager.MaybeShowSeasonEndDialog"))
 		{
 			return;
 		}
@@ -849,7 +856,7 @@ public class DialogManager : MonoBehaviour
 	{
 		DialogRequest dialogRequest = ((m_dialogRequests.Count == 0) ? null : m_dialogRequests.Peek());
 		UserAttentionBlocker attentionCategory = dialogRequest?.m_attentionCategory ?? UserAttentionBlocker.NONE;
-		if (m_dialogRequests.Count == 0 || UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(attentionCategory, "DialogManager.OnPopupLoaded:" + ((dialogRequest == null) ? "null" : dialogRequest.m_type.ToString())))
+		if (m_dialogRequests.Count == 0 || UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, attentionCategory, "DialogManager.OnPopupLoaded:" + ((dialogRequest == null) ? "null" : dialogRequest.m_type.ToString())))
 		{
 			m_loadingDialog = false;
 			UnityEngine.Object.DestroyImmediate(go);
@@ -1202,4 +1209,17 @@ public class DialogManager : MonoBehaviour
 		};
 		AddToQueue(request);
 	}
+
+    #region Accessibility
+    internal AccessibleUI GetCurrentDialog()
+    {
+        return m_currentDialog;
+    }
+
+    internal int GetNumQueuedDialogs()
+    {
+        return m_dialogRequests.Count;
+    }
+    #endregion
+
 }
diff --git a/Assembly-CSharp/DiamondRenderToTextureAtlas.cs b/Assembly-CSharp/DiamondRenderToTextureAtlas.cs
index dab2319..68625e6 100644
--- a/Assembly-CSharp/DiamondRenderToTextureAtlas.cs
+++ b/Assembly-CSharp/DiamondRenderToTextureAtlas.cs
@@ -20,9 +20,6 @@ public class DiamondRenderToTextureAtlas : GreedyPacker
 
 	private const float MARGIN = 1f;
 
-	[CompilerGenerated]
-	private readonly int <Index>k__BackingField;
-
 	private readonly Vector2Int m_size;
 
 	private readonly int m_totalPixelSpace;
@@ -45,11 +42,12 @@ public class DiamondRenderToTextureAtlas : GreedyPacker
 
 	public Color ClearColor { get; private set; } = Color.clear;
 
+	public int Index { get; set; }
 
 	public DiamondRenderToTextureAtlas(int index, int width, int height, RenderTextureFormat format = RenderTextureFormat.ARGB32)
 		: base(width, height)
 	{
-		<Index>k__BackingField = index;
+		Index = index;
 		Texture = RenderTextureTracker.Get().CreateNewTexture(width, height, 16, format);
 		Texture.useMipMap = false;
 		Texture.autoGenerateMips = false;
@@ -118,10 +116,10 @@ public class DiamondRenderToTextureAtlas : GreedyPacker
 		}
 		if (flag)
 		{
-			BuildCommandBuffers();
-			Dirty = true;
-			return true;
-		}
+				BuildCommandBuffers();
+				Dirty = true;
+				return true;
+			}
 		return false;
 	}
 
diff --git a/Assembly-CSharp/DictionaryUtils.cs b/Assembly-CSharp/DictionaryUtils.cs
new file mode 100644
index 0000000..9a5630e
--- /dev/null
+++ b/Assembly-CSharp/DictionaryUtils.cs
@@ -0,0 +1,20 @@
+using System;
+using System.Collections.Generic;
+
+static class DictionaryUtils {
+    public static bool TryAdd<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, TValue value)
+{
+    if (dictionary == null)
+    {
+        throw new ArgumentNullException(nameof(dictionary));
+    }
+
+    if (!dictionary.ContainsKey(key))
+    {
+        dictionary.Add(key, value);
+        return true;
+    }
+
+    return false;
+}
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/DisenchantButton.cs b/Assembly-CSharp/DisenchantButton.cs
index b9f89b5..5faa894 100644
--- a/Assembly-CSharp/DisenchantButton.cs
+++ b/Assembly-CSharp/DisenchantButton.cs
@@ -1,6 +1,7 @@
 using System.Collections.Generic;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class DisenchantButton : CraftingButton
 {
@@ -111,6 +112,7 @@ public class DisenchantButton : CraftingButton
 		if (response == AlertPopup.Response.CANCEL)
 		{
 			PendingDisenchantWarnings.Clear();
+			AccessibleCollectionManager.Get().OnCancelDisenchantPopup();
 		}
 		else if (PendingDisenchantWarnings.Count > 0)
 		{
diff --git a/Assembly-CSharp/DownloadManagerDialog.cs b/Assembly-CSharp/DownloadManagerDialog.cs
index 3d9182a..9251650 100644
--- a/Assembly-CSharp/DownloadManagerDialog.cs
+++ b/Assembly-CSharp/DownloadManagerDialog.cs
@@ -7,6 +7,7 @@ using Hearthstone.DataModels;
 using Hearthstone.Streaming;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(Widget))]
 public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
@@ -251,8 +252,8 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 		SendEventDownwardStateAction.SendEventDownward(base.gameObject, "HIDE", SendEventDownwardStateAction.BubbleDownEventDepth.DirectChildrenOnly);
 		BnetBar.Get().CancelRequestToDisableButtons();
 		if (!(m_popupRoot == null))
-		{
-			UIContext.GetRoot().DismissPopup(m_popupRoot);
+	{
+		UIContext.GetRoot().DismissPopup(m_popupRoot);
 			UnityEngine.Object.Destroy(m_popupRoot);
 		}
 	}
@@ -343,8 +344,8 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 				{
 					if (!(progressTracker is Divider))
 					{
-						throw new Exception($"Unhandled progress tracker type: {progressTracker.GetType()}");
-					}
+					throw new Exception($"Unhandled progress tracker type: {progressTracker.GetType()}");
+				}
 					continue;
 				}
 				UpdateOptionalAssetsProgress(downloadManager, tracker2, initial);
@@ -355,16 +356,16 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 			}
 			if (dataModel != null)
 			{
-				DownloadManagerDialogModuleItemDataModel downloadManagerDialogModuleItemDataModel = dataModel.ModuleList[i];
-				if (!flag)
-				{
-					flag = !Mathf.Approximately(downloadManagerDialogModuleItemDataModel.Progress, progressTracker.Progress);
-				}
-				downloadManagerDialogModuleItemDataModel.Status = progressTracker.Status;
-				downloadManagerDialogModuleItemDataModel.Progress = progressTracker.Progress;
+			DownloadManagerDialogModuleItemDataModel downloadManagerDialogModuleItemDataModel = dataModel.ModuleList[i];
+			if (!flag)
+			{
+				flag = !Mathf.Approximately(downloadManagerDialogModuleItemDataModel.Progress, progressTracker.Progress);
+			}
+			downloadManagerDialogModuleItemDataModel.Status = progressTracker.Status;
+			downloadManagerDialogModuleItemDataModel.Progress = progressTracker.Progress;
 				downloadManagerDialogModuleItemDataModel.DownloadedSizeLabel = DownloadUtils.FormatBytesAsHumanReadable(progressTracker.DownloadedSize);
 				if (progressTracker.HasTotalSizeChanged)
-				{
+			{
 					downloadManagerDialogModuleItemDataModel.TotalSizeLabel = DownloadUtils.FormatBytesAsHumanReadable(progressTracker.TotalSize);
 				}
 				progressTracker.AcknowledgeChanges();
@@ -436,7 +437,7 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 		if (m_downloadConfirmationPopup != null)
 		{
 			UIContext.GetRoot().DismissPopup(m_downloadConfirmationPopupWidget.gameObject);
-		}
+			}
 	}
 
 	private void ShowModuleUninstallPopup(ModuleProgressTracker tracker, bool isCancel)
@@ -458,8 +459,8 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 		await GameDownloadManagerProvider.Get().DeleteModuleAsync(tag);
 		string uninstallLoadingPopupComplete = (isCancel ? "GLOBAL_DOWNLOAD_MANAGER_CANCEL_LOADING_POPUP_CANCEL_MESSAGE" : "GLOBAL_DOWNLOAD_MANAGER_UNINSTALL_LOADING_POPUP_COMPLETE_MESSAGE");
 		SetUninstallLoadingPopupComplete(uninstallLoadingPopupComplete);
-		UpdateData(initial: false);
-	}
+				UpdateData(initial: false);
+			}
 
 	private void ShowOptionalAssetsUninstallPopup()
 	{
@@ -581,13 +582,13 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 			break;
 		case DownloadStatus.DOWNLOADING:
 			if (downloadManager.AssetDownloaderState == AssetDownloaderState.DOWNLOADING)
-			{
-				TagDownloadStatus moduleDownloadStatus2 = downloadManager.GetModuleDownloadStatus(tracker.Tag);
+		{
+			TagDownloadStatus moduleDownloadStatus2 = downloadManager.GetModuleDownloadStatus(tracker.Tag);
 				if (moduleDownloadStatus2.BytesTotal > 0)
 				{
 					DownloadUtils.CalculateModuleDownloadProgress(moduleDownloadStatus2, tracker.TotalSize, out var downloadedBytes2, out var progress2);
 					tracker.UpdateProgress(downloadedBytes2, progress2);
-				}
+		}
 			}
 			break;
 		case DownloadStatus.PAUSED:
@@ -619,7 +620,7 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 			break;
 		case DownloadStatus.DOWNLOADING:
 			if (downloadManager.AssetDownloaderState == AssetDownloaderState.DOWNLOADING)
-			{
+		{
 				TagDownloadStatus optionalDownloadStatus = downloadManager.GetOptionalDownloadStatus();
 				if (optionalDownloadStatus.BytesTotal > 0)
 				{
@@ -636,7 +637,7 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 			if (optionalAssetsDownloadSize != tracker.TotalSize)
 			{
 				tracker.Init(optionalAssetsDownloadSize, tracker.DownloadedSize, (float)tracker.DownloadedSize / (float)tracker.TotalSize);
-			}
+		}
 			break;
 		}
 	}
@@ -651,7 +652,7 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 		case ModuleState.Queued:
 			return DownloadStatus.QUEUED;
 		case ModuleState.Downloading:
-			return GetInterruptionReason(downloadManager.InterruptionReason);
+		return GetInterruptionReason(downloadManager.InterruptionReason);
 		case ModuleState.ReadyToPlay:
 		case ModuleState.FullyInstalled:
 			return DownloadStatus.DOWNLOADED;
@@ -861,8 +862,8 @@ public class DownloadManagerDialog : MonoBehaviour, IWidgetEventListener
 				return;
 			}
 			DownloadPermissionManager.DownloadEnabled = true;
-			gameDownloadManager.StartUpdateProcessForOptional();
-		}
+				gameDownloadManager.StartUpdateProcessForOptional();
+			}
 	}
 
 	private void OnDismissDialog()
diff --git a/Assembly-CSharp/DraftCardVisual.cs b/Assembly-CSharp/DraftCardVisual.cs
index d4fcf9a..4b2f58e 100644
--- a/Assembly-CSharp/DraftCardVisual.cs
+++ b/Assembly-CSharp/DraftCardVisual.cs
@@ -28,6 +28,7 @@ public class DraftCardVisual : CardSelectionHandler
 			if (m_actor.GetEntityDef().IsHeroSkin() || m_actor.GetEntityDef().IsHeroPower())
 			{
 				DraftDisplay.Get().OnHeroClicked(m_cardChoice);
+				DraftDisplay.Get().DoHeroSelectAnimation();
 				return;
 			}
 			m_chosen = true;
diff --git a/Assembly-CSharp/DraftDisplay.cs b/Assembly-CSharp/DraftDisplay.cs
index b6b57ea..4ed8aff 100644
--- a/Assembly-CSharp/DraftDisplay.cs
+++ b/Assembly-CSharp/DraftDisplay.cs
@@ -7,7 +7,7 @@ using Hearthstone;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
-
+using Accessibility;
 [CustomEditClass]
 public class DraftDisplay : MonoBehaviour
 {
@@ -42,7 +42,7 @@ public class DraftDisplay : MonoBehaviour
 		}
 	}
 
-	private class DraftChoice
+	internal class DraftChoice
 	{
 		public string m_cardID = string.Empty;
 
@@ -236,6 +236,7 @@ public class DraftDisplay : MonoBehaviour
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, val: false);
 		}
 		m_screenEffectsHandle = new ScreenEffectsHandle(this);
+		AccessibilityMgr.SetScreen(AccessibleArenaDisplay.Get());
 	}
 
 	private void OnDestroy()
@@ -275,6 +276,7 @@ public class DraftDisplay : MonoBehaviour
 		{
 			m_draftDeckTray.gameObject.SetActive(value: true);
 		}
+
 	}
 
 	private void Update()
@@ -390,14 +392,14 @@ public class DraftDisplay : MonoBehaviour
 			DraftChoice draftChoice = m_choices[j];
 			if (draftChoice.m_cardID != null)
 			{
-				ChoiceCallback choiceCallback = new ChoiceCallback();
-				choiceCallback.choiceID = j + 1;
-				choiceCallback.slot = m_draftManager.GetSlot();
-				choiceCallback.premium = draftChoice.m_premium;
-				DefLoader.Get().LoadFullDef(draftChoice.m_cardID, OnFullDefLoaded, choiceCallback);
-			}
+			ChoiceCallback choiceCallback = new ChoiceCallback();
+			choiceCallback.choiceID = j + 1;
+			choiceCallback.slot = m_draftManager.GetSlot();
+			choiceCallback.premium = draftChoice.m_premium;
+			DefLoader.Get().LoadFullDef(draftChoice.m_cardID, OnFullDefLoaded, choiceCallback);
 		}
 	}
+	}
 
 	public void SetDraftMode(DraftMode mode)
 	{
@@ -543,7 +545,7 @@ public class DraftDisplay : MonoBehaviour
 		{
 			if (choice.m_actor != null)
 			{
-				choice.m_actor.TurnOffCollider();
+			choice.m_actor.TurnOffCollider();
 			}
 		});
 		if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO_POWER)
@@ -655,7 +657,7 @@ public class DraftDisplay : MonoBehaviour
 		return m_zoomedHero != null;
 	}
 
-	private void DoHeroSelectAnimation()
+	internal void DoHeroSelectAnimation()
 	{
 		bool flag = m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO_POWER;
 		RemoveListeners();
@@ -814,6 +816,7 @@ public class DraftDisplay : MonoBehaviour
 		component.AddEventListener(UIEventType.ROLLOUT, DeckHeaderOut);
 		SceneMgr.Get().NotifySceneLoaded();
 	}
+	bool m_firstTimeThisRun=false;
 
 	private IEnumerator InitializeDraftScreen()
 	{
@@ -821,7 +824,7 @@ public class DraftDisplay : MonoBehaviour
 		{
 			yield return null;
 		}
-		if (!m_firstTimeIntroComplete && !Options.Get().GetBool(Option.HAS_SEEN_FORGE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.InitializeDraftScreen:" + Option.HAS_SEEN_FORGE))
+		if (!m_firstTimeIntroComplete && !Options.Get().GetBool(Option.HAS_SEEN_FORGE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.InitializeDraftScreen:" + Option.HAS_SEEN_FORGE))
 		{
 			while (SceneMgr.Get().IsTransitioning())
 			{
@@ -830,7 +833,8 @@ public class DraftDisplay : MonoBehaviour
 			PresenceMgr.Get().SetStatus(Global.PresenceStatus.ARENA_PURCHASE);
 			m_firstTimeIntroComplete = true;
 			DoFirstTimeIntro();
-			yield break;
+			m_firstTimeThisRun=true;
+			yield return null;
 		}
 		switch (m_currentMode)
 		{
@@ -840,6 +844,7 @@ public class DraftDisplay : MonoBehaviour
 			{
 				yield return null;
 			}
+			if(!m_firstTimeThisRun) {
 			int numTicketsOwned = m_draftManager.GetNumTicketsOwned();
 			if (StoreManager.Get().HasOutstandingPurchaseNotices(ProductType.PRODUCT_TYPE_DRAFT))
 			{
@@ -848,11 +853,13 @@ public class DraftDisplay : MonoBehaviour
 			}
 			if (numTicketsOwned > 0)
 			{
+				AccessibilityMgr.Output(null,LocalizationUtils.Format(LocalizationKey.ARENA_TICKETS_COUNT,numTicketsOwned));
 				ShowOutstandingTicketScreen(numTicketsOwned);
 				break;
 			}
 			PresenceMgr.Get().SetStatus(Global.PresenceStatus.ARENA_PURCHASE);
 			ShowPurchaseScreen();
+			}
 			break;
 		}
 		case DraftMode.DRAFTING:
@@ -865,6 +872,7 @@ public class DraftDisplay : MonoBehaviour
 				ShowPurchaseScreen();
 			}
 			PresenceMgr.Get().SetStatus(Global.PresenceStatus.ARENA_FORGE);
+			AccessibilityMgr.HideUI(ArenaStore.Get());
 			if (m_draftManager.ShouldShowFreeArenaWinScreen())
 			{
 				ShowFreeArenaWinScreen();
@@ -1259,7 +1267,7 @@ public class DraftDisplay : MonoBehaviour
 
 	public void ShowInnkeeperInstructions()
 	{
-		if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_HERO_CHOICE))
+		if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_HERO && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_HERO_CHOICE))
 		{
 			if (!m_draftManager.HasSlotType(DraftSlotType.DRAFT_SLOT_HERO_POWER))
 			{
@@ -1267,13 +1275,13 @@ public class DraftDisplay : MonoBehaviour
 				Options.Get().SetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, val: true);
 			}
 		}
-		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.DoHeroSelectAnimation:" + Option.HAS_SEEN_FORGE_CARD_CHOICE))
+		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.DoHeroSelectAnimation:" + Option.HAS_SEEN_FORGE_CARD_CHOICE))
 		{
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_HERO_CHOICE, val: true);
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FORGE_INST2_20"), "VO_INNKEEPER_FORGE_INST2_20.prefab:242b6a30031534e47b1f8ddd69370eac", 3f);
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE, val: true);
 		}
-		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_CARD_CHOICE2))
+		else if (m_draftManager.GetSlotType() == DraftSlotType.DRAFT_SLOT_CARD && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.UpdateInstructionText:" + Option.HAS_SEEN_FORGE_CARD_CHOICE2))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FORGE_INST3_21"), "VO_INNKEEPER_FORGE_INST3_21.prefab:06182dd3360965d4ea48952a6dd4a720", 3f);
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_CARD_CHOICE2, val: true);
@@ -1348,6 +1356,9 @@ public class DraftDisplay : MonoBehaviour
 		{
 			m_instructionText.Text = "";
 		}
+		#region accessibility
+		AccessibilityMgr.Output(null,m_instructionText.Text);
+		#endregion
 	}
 
 	private void DoFirstTimeIntro()
@@ -1483,7 +1494,7 @@ public class DraftDisplay : MonoBehaviour
 			yield return new WaitForSeconds(0.3f);
 		}
 		ArenaTrayDisplay.Get().UpdateTray();
-		if (!UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.ShowActiveDraftScreen"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.ShowActiveDraftScreen"))
 		{
 			yield break;
 		}
@@ -1509,6 +1520,7 @@ public class DraftDisplay : MonoBehaviour
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(133.1f, NotificationManager.DEPTH, 54.2f), GameStrings.Get("VO_INNKEEPER_FORGE_1WIN"), "VO_INNKEEPER_ARENA_1WIN.prefab:31bb13e800c74c0439ee1a7bfc1e3499");
 			Options.Get().SetBool(Option.HAS_SEEN_FORGE_1WIN, val: true);
 		}
+		AccessibleArenaDisplay.ArenaIdleMenu();
 	}
 
 	private void ShowDraftRewardsScreen()
@@ -1528,7 +1540,7 @@ public class DraftDisplay : MonoBehaviour
 		if (m_draftManager.ShouldActivateKey())
 		{
 			int maxWins = m_draftManager.GetMaxWins();
-			if (m_draftManager.GetWins() >= maxWins && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_MAX_WIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftDisplay.ShowDraftRewardsScreen:" + Option.HAS_SEEN_FORGE_MAX_WIN))
+			if (m_draftManager.GetWins() >= maxWins && !Options.Get().GetBool(Option.HAS_SEEN_FORGE_MAX_WIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftDisplay.ShowDraftRewardsScreen:" + Option.HAS_SEEN_FORGE_MAX_WIN))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_MAX_ARENA_WINS_04"), "VO_INNKEEPER_MAX_ARENA_WINS_04.prefab:cdf8e488f2d17604499f2cc358cb35f6");
 				Options.Get().SetBool(Option.HAS_SEEN_FORGE_MAX_WIN, val: true);
@@ -1543,8 +1555,12 @@ public class DraftDisplay : MonoBehaviour
 		else
 		{
 			ArenaTrayDisplay.Get().ShowRewardsOpenAtStart();
+
 		}
 		LoadAndPositionHeroCard();
+		#region accessibility
+		ArenaTrayDisplay.Get().m_TheKeyMesh.GetComponent<PegUIElement>().TriggerPress();
+		#endregion
 	}
 
 	private IEnumerator RestartArena()
@@ -1837,6 +1853,7 @@ public class DraftDisplay : MonoBehaviour
 	{
 		if (!CanAutoDraft())
 		{
+			AccessibleArenaDisplay.BuildDraftChoicesList(m_choices);
 			yield break;
 		}
 		int frameStart2 = Time.frameCount;
@@ -1973,8 +1990,8 @@ public class DraftDisplay : MonoBehaviour
 			if (collider != null)
 			{
 				DraftCardVisual draftCardVisual = collider.gameObject.AddComponent<DraftCardVisual>();
-				draftCardVisual.SetActor(draftChoice.m_actor);
-				draftCardVisual.SetChoiceNum(choiceCallback.choiceID);
+			draftCardVisual.SetActor(draftChoice.m_actor);
+			draftCardVisual.SetChoiceNum(choiceCallback.choiceID);
 			}
 			if (HaveActorsForAllChoices())
 			{
@@ -1998,26 +2015,26 @@ public class DraftDisplay : MonoBehaviour
 	{
 		ChoiceCallback choiceCallback = (ChoiceCallback)callbackData;
 		using DefLoader.DisposableFullDef disposableFullDef = choiceCallback.fullDef;
-		if (go == null)
-		{
-			Debug.LogWarning($"DraftDisplay.OnDualClassActorLoaded() - FAILED to load actor \"{assetRef}\"");
-			return;
-		}
-		go.transform.SetParent(base.transform, worldPositionStays: true);
-		Actor component = go.GetComponent<Actor>();
-		if (component == null)
-		{
-			Debug.LogWarning($"DraftDisplay.OnDualClassActorLoaded() - ERROR actor \"{assetRef}\" has no Actor component");
-			return;
-		}
-		m_subClassHeroPowerDefs[choiceCallback.choiceID - 1]?.Dispose();
-		m_subClassHeroPowerDefs[choiceCallback.choiceID - 1] = disposableFullDef.Share();
-		m_subclassHeroPowerActors[choiceCallback.choiceID - 1] = component;
-		if (HaveActorsForAllChoices() && HaveAllSubclassHeroPowerDefs())
-		{
-			PositionAndShowChoices();
+			if (go == null)
+			{
+				Debug.LogWarning($"DraftDisplay.OnDualClassActorLoaded() - FAILED to load actor \"{assetRef}\"");
+				return;
+			}
+			go.transform.SetParent(base.transform, worldPositionStays: true);
+			Actor component = go.GetComponent<Actor>();
+			if (component == null)
+			{
+				Debug.LogWarning($"DraftDisplay.OnDualClassActorLoaded() - ERROR actor \"{assetRef}\" has no Actor component");
+				return;
+			}
+			m_subClassHeroPowerDefs[choiceCallback.choiceID - 1]?.Dispose();
+			m_subClassHeroPowerDefs[choiceCallback.choiceID - 1] = disposableFullDef.Share();
+			m_subclassHeroPowerActors[choiceCallback.choiceID - 1] = component;
+			if (HaveActorsForAllChoices() && HaveAllSubclassHeroPowerDefs())
+			{
+				PositionAndShowChoices();
+			}
 		}
-	}
 
 	private void OnCardDefLoaded(string cardId, DefLoader.DisposableCardDef def, object callbackData)
 	{
diff --git a/Assembly-CSharp/DraftManager.cs b/Assembly-CSharp/DraftManager.cs
index 3fc1c13..c6b01eb 100644
--- a/Assembly-CSharp/DraftManager.cs
+++ b/Assembly-CSharp/DraftManager.cs
@@ -9,6 +9,7 @@ using PegasusClient;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class DraftManager : IService
 {
@@ -453,11 +454,14 @@ public class DraftManager : IService
 			m_weeks = "GLUE_ARENA_POPUP_ENDING_SOON_HEADER_WEEKS",
 			m_monthAgo = "GLUE_ARENA_POPUP_ENDING_SOON_HEADER_MONTHS"
 		};
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var headerText = TimeUtils.GetElapsedTimeString(secondsToCurrentSeasonEnd, stringSet, roundUp: true);
+		var bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.Season.Strings, "ENDING_SOON_BODY");
+		var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.SeasonEndingSoonPrefab);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.SeasonEndingSoonPrefabExtra);
-		popupInfo.m_headerText = TimeUtils.GetElapsedTimeString(secondsToCurrentSeasonEnd, stringSet, roundUp: true);
-		popupInfo.m_bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.Season.Strings, "ENDING_SOON_BODY");
+		popupInfo.m_headerText = headerText;
+		popupInfo.m_bodyText = bodyText;
 		popupInfo.m_responseUserData = CurrentSeasonId;
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_responseCallback = delegate
@@ -487,11 +491,14 @@ public class DraftManager : IService
 			m_weeks = "GLUE_ARENA_POPUP_COMING_SOON_HEADER_WEEKS",
 			m_monthAgo = "GLUE_ARENA_POPUP_COMING_SOON_HEADER_MONTHS"
 		};
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var headerText = TimeUtils.GetElapsedTimeString(secondsToNextSeasonStart, stringSet, roundUp: true);
+		var bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.NextSeasonStrings, "COMING_SOON_BODY");
+		var popupText = AccessibleSpeechUtils.CombineSentences(headerText, bodyText);
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.NextSeasonComingSoonPrefab);
 		popupInfo.m_prefabAssetRefs.Add(m_currentSeason.NextSeasonComingSoonPrefabExtra);
-		popupInfo.m_headerText = TimeUtils.GetElapsedTimeString(secondsToNextSeasonStart, stringSet, roundUp: true);
-		popupInfo.m_bodyText = GameStrings.FormatStringWithPlurals(m_currentSeason.NextSeasonStrings, "COMING_SOON_BODY");
+		popupInfo.m_headerText = headerText;
+		popupInfo.m_bodyText = bodyText;
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_responseUserData = m_currentSeason.NextSeasonId;
 		popupInfo.m_responseCallback = delegate
@@ -653,7 +660,7 @@ public class DraftManager : IService
 		sessionRecord.RunFinished = true;
 		sessionRecord.SessionRecordType = SessionRecordType.ARENA;
 		BnetPresenceMgr.Get().SetGameFieldBlob(22u, sessionRecord);
-		if (!Options.Get().GetBool(Option.HAS_ACKED_ARENA_REWARDS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftManager.OnAckRewards:" + Option.HAS_ACKED_ARENA_REWARDS))
+		if (!Options.Get().GetBool(Option.HAS_ACKED_ARENA_REWARDS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftManager.OnAckRewards:" + Option.HAS_ACKED_ARENA_REWARDS))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_ARENA_1ST_REWARD"), "VO_INNKEEPER_ARENA_1ST_REWARD.prefab:660e915849550ae4085735866647d529");
 			Options.Get().SetBool(Option.HAS_ACKED_ARENA_REWARDS, val: true);
@@ -715,7 +722,7 @@ public class DraftManager : IService
 		{
 			DemoMgr.Get().CreateDemoText(GameStrings.Get("GLUE_BLIZZCON2013_ARENA_5_WINS"), unclickable: false, shouldDoArenaInstruction: false);
 		}
-		else if (m_losses == 3 && !Options.Get().GetBool(Option.HAS_LOST_IN_ARENA, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("DraftManager.OnChoicesAndContents:" + Option.HAS_LOST_IN_ARENA))
+		else if (m_losses == 3 && !Options.Get().GetBool(Option.HAS_LOST_IN_ARENA, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "DraftManager.OnChoicesAndContents:" + Option.HAS_LOST_IN_ARENA))
 		{
 			NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_ARENA_3RD_LOSS"), "VO_INNKEEPER_ARENA_3RD_LOSS.prefab:6b2af024c9980d344a087295afb5e3df");
 			Options.Get().SetBool(Option.HAS_LOST_IN_ARENA, val: true);
diff --git a/Assembly-CSharp/DropdownControl.cs b/Assembly-CSharp/DropdownControl.cs
index 4169bba..50003bd 100644
--- a/Assembly-CSharp/DropdownControl.cs
+++ b/Assembly-CSharp/DropdownControl.cs
@@ -43,7 +43,7 @@ public class DropdownControl : PegUIElement
 	{
 	};
 
-	private List<DropdownMenuItem> m_items = new List<DropdownMenuItem>();
+	internal List<DropdownMenuItem> m_items = new List<DropdownMenuItem>();
 
 	private Font m_overrideFont;
 
diff --git a/Assembly-CSharp/DuelsPlayMat.cs b/Assembly-CSharp/DuelsPlayMat.cs
index 4ad5858..9eb59f3 100644
--- a/Assembly-CSharp/DuelsPlayMat.cs
+++ b/Assembly-CSharp/DuelsPlayMat.cs
@@ -11,7 +11,7 @@ public class DuelsPlayMat : MonoBehaviour
 
 	public AsyncReference m_vaultLeverReference;
 
-	private Clickable m_leverButton;
+	internal Clickable m_leverButton;
 
 	private Widget m_livesWidget;
 
diff --git a/Assembly-CSharp/DuelsPopupManager.cs b/Assembly-CSharp/DuelsPopupManager.cs
index c8db76c..c42bb8e 100644
--- a/Assembly-CSharp/DuelsPopupManager.cs
+++ b/Assembly-CSharp/DuelsPopupManager.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Assets;
 using Blizzard.GameService.SDK.Client.Integration;
 using Blizzard.T5.MaterialService.Extensions;
@@ -11,7 +12,7 @@ using Hearthstone.UI;
 using PegasusUtil;
 using UnityEngine;
 
-public class DuelsPopupManager : MonoBehaviour, IStore
+public class DuelsPopupManager : MonoBehaviour, IStore, AccessibleUI
 {
 	private const string HEROIC_STORE_OPENED_EVENT = "HEROIC_STORE_OPENED";
 
@@ -207,6 +208,7 @@ public class DuelsPopupManager : MonoBehaviour, IStore
 
 	private void OnBuyWithTicketButtonPressed(UIEvent buttonEvent)
 	{
+		AccessibilityMgr.HideUI(this);
 		m_visualController.SetState("PURCHASE_ACKNOWLEDGED");
 		m_purchaseSuccessfulDelegate();
 	}
@@ -306,6 +308,7 @@ public class DuelsPopupManager : MonoBehaviour, IStore
 	{
 		this.OnProductOpened?.Invoke();
 		m_visualController.SetState("OPEN");
+		ReadScreen();
 	}
 
 	public void ShowNotice(string header, string desc, string rating, Action callback)
@@ -319,6 +322,7 @@ public class DuelsPopupManager : MonoBehaviour, IStore
 	{
 		PresenceMgr.Get().SetStatus(Global.PresenceStatus.DUELS_IDLE);
 		m_visualController.SetState("HIDE");
+		AccessibilityMgr.HideUI(this);
 	}
 
 	public void AddOnNormalButtonPressedDelegate(Action action)
@@ -575,6 +579,7 @@ public class DuelsPopupManager : MonoBehaviour, IStore
 		{
 			EndArenaTicketTransaction();
 			BlockInputs(blocked: false);
+			AccessibilityMgr.HideUI(this);
 			m_visualController.SetState("PURCHASE_ACKNOWLEDGED");
 			m_purchaseSuccessfulDelegate();
 		}
@@ -697,4 +702,149 @@ public class DuelsPopupManager : MonoBehaviour, IStore
 		}
 		return hashSet;
 	}
+
+	#region Accessibility
+	private enum State { LOADING, choosing_DUELS_TYPE, HEROIC_DUEL_HAS_TICKET, HEROIC_DUEL_NO_TICKET };
+
+	private State m_curState = State.LOADING;
+
+	private AccessibleHorizontalMenu<AccessibleMultilineText> m_typeMenu;
+
+	private AccessibleMenu m_buyWithTicketMenu, m_buyWithCurrencyMenu;
+
+	private void onClickNormal()
+	{
+		OnNormalButtonPressed(null);
+		Hide();
+		m_curState = State.LOADING;
+	}
+
+	private void onClickHeroic()
+	{
+		var numTickets = NetCache.Get().GetArenaTicketBalance();
+		if (numTickets > 0)
+		{
+			SetupBuyWithTicketMenu(numTickets);
+		}
+		else
+		{
+			SetupBuyWithCurrencyMenu();
+		}
+	}
+
+	private void SetupBuyWithTicketMenu(int numTickets)
+	{
+		m_curState = State.HEROIC_DUEL_HAS_TICKET;
+		AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.ARENA_TICKETS_COUNT, numTickets));
+		m_buyWithTicketMenu = new AccessibleMenu(this, GameStrings.Get("GLUE_PVPDR_HEROIC_POPUP_DESCRIPTION_HASTICKETS"), SetupDuelsTypeMenu);
+		m_buyWithTicketMenu.AddOption(GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_ACCEPT"), () => OnBuyWithTicketButtonPressed(null));
+		m_buyWithTicketMenu.AddOption(GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_DECLINE"), SetupDuelsTypeMenu);
+		m_buyWithTicketMenu.StartReading();
+	}
+
+	private void SetupBuyWithCurrencyMenu()
+	{
+		m_buyWithCurrencyMenu = new AccessibleMenu(this, null, SetupDuelsTypeMenu);
+		long goldCost = DuelsConfig.PAID_GOLD_COST;
+		m_arenaTicketBundle.TryGetVCPrice(CurrencyType.ROW_RUNESTONES, out long runestoneCost);
+		if (goldCost > 0)
+		{
+			m_buyWithCurrencyMenu.AddOption(LocalizationUtils.Format(LocalizationKey.UI_SHOP_ITEM_BUY_FOR_N_GOLD, goldCost), () => tryBuyWithGold(goldCost));
+		}
+		if (runestoneCost > 0)
+		{
+			m_buyWithCurrencyMenu.AddOption(LocalizationUtils.Format(LocalizationKey.UI_SHOP_ITEM_BUY_FOR_N_RUNESTONES, runestoneCost), () => tryBuyWithRunestones(runestoneCost));
+		}
+		if (m_buyWithCurrencyMenu.GetNumItems() > 0)
+		{
+			m_curState = State.HEROIC_DUEL_NO_TICKET;
+			m_buyWithCurrencyMenu.StartReading(false);
+		}
+	}
+
+	private void tryBuyWithGold(long cost)
+	{
+		var goldBalance = AccessibleShopUtils.GetGoldBalance();
+		if (goldBalance < cost)
+		{
+			AccessibilityMgr.Output(this, GameStrings.Get("GAMEPLAY_PlayErrors_REQ_ENOUGH_COIN"));
+		}
+		else
+		{
+			OnBuyWithGoldButtonPressed(null);
+		}
+	}
+
+		private void tryBuyWithRunestones(long cost)
+	{
+		var runestoneBalance = AccessibleShopUtils.GetRunestoneBalance();
+		if (runestoneBalance < cost)
+		{
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SHOP_NOT_ENOUGH_RUNESTONES));
+		}
+		else
+		{
+			OnBuyWithVCButtonPressed(null);
+		}
+	}
+
+
+	private void onGoBack()
+	{
+		Hide();
+		PvPDungeonRunScene.Get().ReadMainMenu(); // Stuck in loading state otherwise.
+	}
+
+	private void SetupDuelsTypeMenu()
+	{
+		m_typeMenu = new AccessibleHorizontalMenu<AccessibleMultilineText>(this, LocalizationUtils.Get(LocalizationKey.SCREEN_DUELS_CHOOSE_TYPE), onGoBack);
+		m_typeMenu.AddOption(new AccessibleMultilineText(this, GameStrings.Get("GLUE_PVPDR_ENTRY_POPUP_LABEL_NORMAL"), GameStrings.Get("GLUE_PVPDR_ENTRY_POPUP_DESCRIPTION_NORMAL")), onClickNormal);
+		m_typeMenu.AddOption(new AccessibleMultilineText(this, GameStrings.Get("GLUE_PVPDR_ENTRY_POPUP_LABEL_HEROIC"), GameStrings.Get("GLUE_PVPDR_ENTRY_POPUP_DESCRIPTION_HEROIC")), onClickHeroic);
+		ReadDuelsTypeMenu();
+	}
+
+	private void ReadDuelsTypeMenu()
+	{
+		m_curState = State.choosing_DUELS_TYPE;
+		m_typeMenu.StartReading();
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (m_curState == State.choosing_DUELS_TYPE)
+		{
+			m_typeMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.HEROIC_DUEL_HAS_TICKET)
+		{
+			m_buyWithTicketMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.HEROIC_DUEL_NO_TICKET)
+		{
+			m_buyWithCurrencyMenu.HandleAccessibleInput();
+		}
+	}
+
+		public string GetAccessibleHelp()
+	{
+		if (m_curState == State.choosing_DUELS_TYPE)
+		{
+			return m_typeMenu?.GetHelp();
+		}
+		return "";
+	}
+
+	public void OnGainedFocus()
+	{
+		if (m_curState == State.choosing_DUELS_TYPE)
+		{
+			m_typeMenu?.StartReading();
+		}
+	}
+	public void ReadScreen()
+	{
+		AccessibilityMgr.ShowUI(this);
+		SetupDuelsTypeMenu();
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/DungeonCrawlBossKillCounter.cs b/Assembly-CSharp/DungeonCrawlBossKillCounter.cs
index b1deaab..482b4dc 100644
--- a/Assembly-CSharp/DungeonCrawlBossKillCounter.cs
+++ b/Assembly-CSharp/DungeonCrawlBossKillCounter.cs
@@ -42,7 +42,7 @@ public class DungeonCrawlBossKillCounter : MonoBehaviour
 
 	public BossKillCounterStyleOverride[] m_bossKillCounterStyle;
 
-	private long m_bossWins;
+	public long m_bossWins;
 
 	private long m_runWins;
 
diff --git a/Assembly-CSharp/EmoteHandler.cs b/Assembly-CSharp/EmoteHandler.cs
index 7d3897e..58be712 100644
--- a/Assembly-CSharp/EmoteHandler.cs
+++ b/Assembly-CSharp/EmoteHandler.cs
@@ -4,6 +4,7 @@ using System.Linq;
 using Blizzard.T5.Core;
 using Blizzard.T5.Core.Utils;
 using UnityEngine;
+using Accessibility;
 
 public class EmoteHandler : MonoBehaviour
 {
@@ -243,6 +244,8 @@ public class EmoteHandler : MonoBehaviour
 		{
 			availableEmote.Enable();
 		}
+
+		AccessibleGameplay.Get().OnEmotesShown(m_availableEmotes);
 	}
 
 	public void HideEmotes()
diff --git a/Assembly-CSharp/EndGameScreen.cs b/Assembly-CSharp/EndGameScreen.cs
index 3850bb8..ff567d2 100644
--- a/Assembly-CSharp/EndGameScreen.cs
+++ b/Assembly-CSharp/EndGameScreen.cs
@@ -13,233 +13,238 @@ using PegasusLettuce;
 using PegasusShared;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class EndGameScreen : MonoBehaviour
 {
-	public delegate void OnTwoScoopsShownHandler(bool shown, EndGameTwoScoop twoScoops);
+    public delegate void OnTwoScoopsShownHandler(bool shown, EndGameTwoScoop twoScoops);
 
-	public EndGameTwoScoop m_twoScoop;
+    public EndGameTwoScoop m_twoScoop;
 
-	public PegUIElement m_hitbox;
+    public PegUIElement m_hitbox;
 
-	public UberText m_noGoldRewardText;
+    public UberText m_noGoldRewardText;
 
-	public UberText m_continueText;
+    public UberText m_continueText;
 
-	[CustomEditField(T = EditType.GAME_OBJECT)]
-	public string m_ScoreScreenPrefab;
+    [CustomEditField(T = EditType.GAME_OBJECT)]
+    public string m_ScoreScreenPrefab;
 
-	public static OnTwoScoopsShownHandler OnTwoScoopsShown;
+    public static OnTwoScoopsShownHandler OnTwoScoopsShown;
 
-	public static Action OnBackOutOfGameplay;
+    public static Action OnBackOutOfGameplay;
 
-	private static EndGameScreen s_instance;
+    private static EndGameScreen s_instance;
 
-	private bool m_shown;
+    private bool m_shown;
 
-	private bool m_netCacheReady;
+    private bool m_netCacheReady;
 
-	private bool m_achievesReady;
+    private bool m_achievesReady;
 
-	private bool m_heroRewardEventReady;
+    private bool m_heroRewardEventReady;
 
-	protected List<Achievement> m_completedQuests = new List<Achievement>();
+    protected List<Achievement> m_completedQuests = new List<Achievement>();
 
-	private bool m_isShowingFixedRewards;
+    private bool m_isShowingFixedRewards;
 
-	private List<Reward> m_rewards = new List<Reward>();
+    private List<Reward> m_rewards = new List<Reward>();
 
-	private int m_numRewardsToLoad;
+    private int m_numRewardsToLoad;
 
-	private bool m_rewardsLoaded;
+    private bool m_rewardsLoaded;
 
-	private List<Reward> m_genericRewards = new List<Reward>();
+    private List<Reward> m_genericRewards = new List<Reward>();
 
-	private HashSet<long> m_genericRewardChestNoticeIdsReady = new HashSet<long>();
+    private HashSet<long> m_genericRewardChestNoticeIdsReady = new HashSet<long>();
 
-	private Reward m_currentlyShowingReward;
+    private Reward m_currentlyShowingReward;
 
-	private bool m_haveShownTwoScoop;
+    private bool m_haveShownTwoScoop;
 
-	private bool m_hasAlreadySetMode;
+    private bool m_hasAlreadySetMode;
 
-	private int m_inputBlocker;
+    private int m_inputBlocker;
 
-	private bool m_playingBlockingAnim;
+    private bool m_playingBlockingAnim;
 
-	private bool m_doneDisplayingRewards;
+    private bool m_doneDisplayingRewards;
 
-	private bool m_showingScoreScreen;
+    private bool m_showingScoreScreen;
 
-	private ScoreScreen m_scoreScreen;
+    private ScoreScreen m_scoreScreen;
 
-	private GameObject m_rankChangeTwoScoop;
+    private GameObject m_rankChangeTwoScoop;
 
-	private bool m_rankChangeReady;
+    private bool m_rankChangeReady;
 
-	private bool m_medalInfoUpdated;
+    private bool m_medalInfoUpdated;
 
-	private const int MEDAL_INFO_RETRY_COUNT_MAX = 3;
+    private const int MEDAL_INFO_RETRY_COUNT_MAX = 3;
 
-	private const float MEDAL_INFO_RETRY_INITIAL_DELAY = 1f;
+    private const float MEDAL_INFO_RETRY_INITIAL_DELAY = 1f;
 
-	private int m_medalInfoRetryCount;
+    private int m_medalInfoRetryCount;
 
-	private float m_medalInfoRetryDelay;
+    private float m_medalInfoRetryDelay;
 
-	private bool m_shouldShowRankChange;
+    private bool m_shouldShowRankChange;
 
-	private bool m_isShowingRankChange;
+    private bool m_isShowingRankChange;
 
-	private bool m_hasSentRankedInitTelemetry;
+    private bool m_hasSentRankedInitTelemetry;
 
-	private float m_endGameScreenStartTime;
+    private float m_endGameScreenStartTime;
 
-	private Widget m_rankedRewardDisplayWidget;
+    private Widget m_rankedRewardDisplayWidget;
 
-	private RankedRewardDisplay m_rankedRewardDisplay;
+    private RankedRewardDisplay m_rankedRewardDisplay;
 
-	private bool m_isShowingRankedReward;
+    private bool m_isShowingRankedReward;
 
-	private List<List<RewardData>> m_rankedRewardsToDisplay = new List<List<RewardData>>();
+    private List<List<RewardData>> m_rankedRewardsToDisplay = new List<List<RewardData>>();
 
-	private Widget m_rankedCardBackProgressWidget;
+    private Widget m_rankedCardBackProgressWidget;
 
-	private RankedCardBackProgressDisplay m_rankedCardBackProgress;
+    private RankedCardBackProgressDisplay m_rankedCardBackProgress;
 
-	private bool m_shouldShowRankedCardBackProgress;
+    private bool m_shouldShowRankedCardBackProgress;
 
-	private bool m_isShowingRankedCardBackProgress;
+    private bool m_isShowingRankedCardBackProgress;
 
-	private bool m_isShowingTrackRewards;
+    private bool m_isShowingTrackRewards;
 
-	private bool m_shouldShowRewardXpGains;
+    private bool m_shouldShowRewardXpGains;
 
-	private bool m_isShowingMercenariesExperienceRewards;
+    private bool m_isShowingMercenariesExperienceRewards;
 
-	private bool m_finishedShowingMercenariesExperienceRewards;
+    private bool m_finishedShowingMercenariesExperienceRewards;
 
-	private bool m_hasTimedOutAndLogged;
+    private bool m_hasTimedOutAndLogged;
 
-	private float m_timeoutTimerStartTime;
+    private float m_timeoutTimerStartTime;
 
-	private ScreenEffectsHandle m_screenEffectsHandle;
+    private ScreenEffectsHandle m_screenEffectsHandle;
 
-	private const float m_maxWaitTime = 5f;
+    private const float m_maxWaitTime = 5f;
 
-	protected virtual void Awake()
-	{
-		s_instance = this;
-		if (GameMgr.Get().IsBattlegrounds())
-		{
-			m_netCacheReady = true;
-		}
-		StartCoroutine(WaitForAchieveManager());
-		ProcessPreviousAchievements();
-		AchieveManager.Get().RegisterAchievesUpdatedListener(OnAchievesUpdated);
-		m_shouldShowRankChange = !GameMgr.Get().IsSpectator() && GameMgr.Get().IsPlay() && Options.Get().GetBool(Option.IN_RANKED_PLAY_MODE);
-		m_hitbox.gameObject.SetActive(value: false);
-		string key = "GLOBAL_CLICK_TO_CONTINUE";
-		if (UniversalInputManager.Get().IsTouchMode())
-		{
-			key = "GLOBAL_CLICK_TO_CONTINUE_TOUCH";
-		}
-		m_continueText.Text = GameStrings.Get(key);
-		m_continueText.gameObject.SetActive(value: false);
-		m_noGoldRewardText.gameObject.SetActive(value: false);
-		PegUI.Get().AddInputCamera(CameraUtils.FindFirstByLayer(GameLayer.IgnoreFullScreenEffects));
-		LayerUtils.SetLayer(m_hitbox.gameObject, GameLayer.IgnoreFullScreenEffects);
-		LayerUtils.SetLayer(m_continueText.gameObject, GameLayer.IgnoreFullScreenEffects);
-		if (!Network.ShouldBeConnectedToAurora())
-		{
-			UpdateRewards();
-		}
-		m_genericRewardChestNoticeIdsReady = GenericRewardChestNoticeManager.Get().GetReadyGenericRewardChestNotices();
-		GenericRewardChestNoticeManager.Get().RegisterRewardsUpdatedListener(OnGenericRewardUpdated);
-		m_screenEffectsHandle = new ScreenEffectsHandle(this);
-	}
-
-	protected virtual void OnDestroy()
-	{
-		if (NetCache.Get() != null)
-		{
-			NetCache.Get().RemoveUpdatedListener(typeof(NetCache.NetCacheMedalInfo), OnMedalInfoUpdate);
-		}
-		if (OnTwoScoopsShown != null)
-		{
-			OnTwoScoopsShown(shown: false, m_twoScoop);
-		}
-		if (AchieveManager.Get() != null)
-		{
-			AchieveManager.Get().RemoveAchievesUpdatedListener(OnAchievesUpdated);
-		}
-		if (GenericRewardChestNoticeManager.Get() != null)
-		{
-			GenericRewardChestNoticeManager.Get().RemoveRewardsUpdatedListener(OnGenericRewardUpdated);
-		}
-		m_screenEffectsHandle.StopEffect();
-		s_instance = null;
-	}
-
-	public static EndGameScreen Get()
-	{
-		return s_instance;
-	}
+    protected virtual void Awake()
+    {
+        s_instance = this;
+        if (GameMgr.Get().IsBattlegrounds())
+        {
+            m_netCacheReady = true;
+        }
+        StartCoroutine(WaitForAchieveManager());
+        ProcessPreviousAchievements();
+        AchieveManager.Get().RegisterAchievesUpdatedListener(OnAchievesUpdated);
+        m_shouldShowRankChange = !GameMgr.Get().IsSpectator() && GameMgr.Get().IsPlay() && Options.Get().GetBool(Option.IN_RANKED_PLAY_MODE);
+        m_hitbox.gameObject.SetActive(value: false);
+        string key = "GLOBAL_CLICK_TO_CONTINUE";
+        if (UniversalInputManager.Get().IsTouchMode())
+        {
+            key = "GLOBAL_CLICK_TO_CONTINUE_TOUCH";
+        }
+        m_continueText.Text = GameStrings.Get(key);
+        m_continueText.gameObject.SetActive(value: false);
+        m_noGoldRewardText.gameObject.SetActive(value: false);
+        PegUI.Get().AddInputCamera(CameraUtils.FindFirstByLayer(GameLayer.IgnoreFullScreenEffects));
+        LayerUtils.SetLayer(m_hitbox.gameObject, GameLayer.IgnoreFullScreenEffects);
+        LayerUtils.SetLayer(m_continueText.gameObject, GameLayer.IgnoreFullScreenEffects);
+        if (!Network.ShouldBeConnectedToAurora())
+        {
+            UpdateRewards();
+        }
+        m_genericRewardChestNoticeIdsReady = GenericRewardChestNoticeManager.Get().GetReadyGenericRewardChestNotices();
+        GenericRewardChestNoticeManager.Get().RegisterRewardsUpdatedListener(OnGenericRewardUpdated);
+        m_screenEffectsHandle = new ScreenEffectsHandle(this);
+    }
 
-	public virtual void Show()
-	{
-		if (GameState.Get() == null || !GameState.Get().WasRestartRequested())
-		{
-			m_shown = true;
-			m_endGameScreenStartTime = Time.time;
-			Network.Get().DisconnectFromGameServer();
-			InputManager.Get().DisableInput();
-			m_hitbox.gameObject.SetActive(value: true);
-			m_screenEffectsHandle.StartEffect(ScreenEffectParameters.BlurVignetteDesaturatePerspective);
-			if (GameState.Get() != null && GameState.Get().GetFriendlySidePlayer() != null)
-			{
-				GameState.Get().GetFriendlySidePlayer().GetHandZone()
-					.UpdateLayout(null);
-			}
-			ShowScoreScreen();
+    protected virtual void OnDestroy()
+    {
+        if (NetCache.Get() != null)
+        {
+            NetCache.Get().RemoveUpdatedListener(typeof(NetCache.NetCacheMedalInfo), OnMedalInfoUpdate);
+        }
+        if (OnTwoScoopsShown != null)
+        {
+            OnTwoScoopsShown(shown: false, m_twoScoop);
+        }
+        if (AchieveManager.Get() != null)
+        {
+            AchieveManager.Get().RemoveAchievesUpdatedListener(OnAchievesUpdated);
+        }
+        if (GenericRewardChestNoticeManager.Get() != null)
+        {
+            GenericRewardChestNoticeManager.Get().RemoveRewardsUpdatedListener(OnGenericRewardUpdated);
+        }
+        m_screenEffectsHandle.StopEffect();
+        s_instance = null;
+    }
+
+    public static EndGameScreen Get()
+    {
+        return s_instance;
+    }
+
+    public virtual void Show()
+    {
+        if (GameState.Get() == null || !GameState.Get().WasRestartRequested())
+        {
+            AccessibleEndGameScreen.Get().OnShow();
+
+            m_shown = true;
+            m_endGameScreenStartTime = Time.time;
+            Network.Get().DisconnectFromGameServer();
+            InputManager.Get().DisableInput();
+            m_hitbox.gameObject.SetActive(value: true);
+            m_screenEffectsHandle.StartEffect(ScreenEffectParameters.BlurVignetteDesaturatePerspective);
+            if (GameState.Get() != null && GameState.Get().GetFriendlySidePlayer() != null)
+            {
+                GameState.Get().GetFriendlySidePlayer().GetHandZone()
+                    .UpdateLayout(null);
+            }
+            ShowScoreScreen();
 			StartCoroutine(ShowStandardFlowIfReady());
-		}
-	}
-
-	public void SetPlayingBlockingAnim(bool set)
-	{
-		m_playingBlockingAnim = set;
-	}
-
-	public bool IsPlayingBlockingAnim()
-	{
-		return m_playingBlockingAnim;
-	}
-
-	public void AddInputBlocker()
-	{
-		m_inputBlocker++;
-	}
-
-	public void RemoveInputBlocker()
-	{
-		m_inputBlocker--;
-	}
 
-	private bool IsInputBlocked()
-	{
-		return m_inputBlocker > 0;
-	}
-
-	public bool IsScoreScreenShown()
-	{
-		return m_showingScoreScreen;
-	}
-
-	private void ShowTutorialProgress()
-	{
-		HideTwoScoop();
+            AccessibleEndGameScreen.Get().OnShown(m_hitbox);
+        }
+    }
+
+    public void SetPlayingBlockingAnim(bool set)
+    {
+        m_playingBlockingAnim = set;
+    }
+
+    public bool IsPlayingBlockingAnim()
+    {
+        return m_playingBlockingAnim;
+    }
+
+    public void AddInputBlocker()
+    {
+        m_inputBlocker++;
+    }
+
+    public void RemoveInputBlocker()
+    {
+        m_inputBlocker--;
+    }
+
+    private bool IsInputBlocked()
+    {
+        return m_inputBlocker > 0;
+    }
+
+    public bool IsScoreScreenShown()
+    {
+        return m_showingScoreScreen;
+    }
+
+    private void ShowTutorialProgress()
+    {
+        HideTwoScoop();
 		if (GameMgr.Get().GetMissionId() == 5290 && TutorialProgressScreen.HasEverOpenedRewardChest() && NetCache.Get().GetNetObject<NetCache.NetCacheProfileProgress>().CampaignProgress == TutorialProgress.LICH_KING_COMPLETE)
 		{
 			LoadingScreen.Get().SetFadeColor(Color.white);
@@ -247,19 +252,19 @@ public class EndGameScreen : MonoBehaviour
 		}
 		else
 		{
-			StartCoroutine(LoadTutorialProgress());
-		}
+        StartCoroutine(LoadTutorialProgress());
+    }
 	}
 
-	private IEnumerator LoadTutorialProgress()
-	{
-		yield return new WaitForSeconds(0.25f);
+    private IEnumerator LoadTutorialProgress()
+    {
+        yield return new WaitForSeconds(0.25f);
 		AssetLoader.Get().InstantiatePrefab("TutorialInterstitialPopup.prefab:a5140e1dc7b29634cb548f42574bce5b", OnTutorialProgressScreenCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
-	}
+    }
 
-	private void OnTutorialProgressScreenCallback(AssetReference assetRef, GameObject go, object callbackData)
-	{
-		go.transform.parent = base.transform;
+    private void OnTutorialProgressScreenCallback(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        go.transform.parent = base.transform;
 		TutorialProgressScreen component = go.GetComponent<TutorialProgressScreen>();
 		if (component != null)
 		{
@@ -312,29 +317,29 @@ public class EndGameScreen : MonoBehaviour
 	{
 		ServiceManager.Get<ILoginService>()?.ClearAuthentication();
 		BackToMode(SceneMgr.Mode.RESET);
-	}
-
-	protected void ContinueButtonPress_Common()
-	{
-		LoadingScreen.Get().AddTransitionObject(this);
-	}
-
-	protected void ContinueButtonPress_ProceedToError(UIEvent e)
-	{
-		if (!IsPlayingBlockingAnim())
-		{
-			HideScoreScreen();
-			m_hitbox.RemoveEventListener(UIEventType.RELEASE, ContinueButtonPress_ProceedToError);
-		}
-	}
-
-	protected void ContinueButtonPress_PrevMode(UIEvent e)
-	{
-		ContinueEvents();
-	}
-
-	public bool ContinueEvents()
-	{
+    }
+
+    protected void ContinueButtonPress_Common()
+    {
+        LoadingScreen.Get().AddTransitionObject(this);
+    }
+
+    protected void ContinueButtonPress_ProceedToError(UIEvent e)
+    {
+        if (!IsPlayingBlockingAnim())
+        {
+            HideScoreScreen();
+            m_hitbox.RemoveEventListener(UIEventType.RELEASE, ContinueButtonPress_ProceedToError);
+        }
+    }
+
+    protected void ContinueButtonPress_PrevMode(UIEvent e)
+    {
+        ContinueEvents();
+    }
+
+    public bool ContinueEvents()
+    {
 		if (!GameMgr.Get().IsBattlegrounds() && !GameMgr.Get().IsMercenaries() && GameMgr.Get().IsTraditionalTutorial())
 		{
 			if (!GameUtils.IsTraditionalTutorialComplete())
@@ -348,1192 +353,1194 @@ public class EndGameScreen : MonoBehaviour
 				return true;
 			}
 		}
-		if (ContinueDefaultEvents())
-		{
-			return true;
-		}
-		if (m_twoScoop == null)
-		{
-			return false;
-		}
-		PlayMakerFSM component = m_twoScoop.GetComponent<PlayMakerFSM>();
-		if (component != null)
+        if (ContinueDefaultEvents())
+        {
+            return true;
+        }
+        if (m_twoScoop == null)
+        {
+            return false;
+        }
+        PlayMakerFSM component = m_twoScoop.GetComponent<PlayMakerFSM>();
+        if (component != null)
+        {
+            component.SendEvent("Death");
+        }
+        ContinueButtonPress_Common();
+        m_hitbox.RemoveEventListener(UIEventType.RELEASE, ContinueButtonPress_PrevMode);
+        ReturnToPreviousMode();
+        return false;
+    }
+
+    protected void ContinueButtonPress_TutorialProgress(UIEvent e)
+    {
+        ContinueTutorialEvents();
+    }
+
+    public void ContinueTutorialEvents()
+    {
+        if (!ContinueDefaultEvents())
+        {
+            ContinueButtonPress_Common();
+            m_hitbox.RemoveEventListener(UIEventType.RELEASE, ContinueButtonPress_TutorialProgress);
+            m_continueText.gameObject.SetActive(value: false);
+            ShowTutorialProgress();
+        }
+    }
+
+    private bool ContinueDefaultEvents()
+    {
+        if (IsPlayingBlockingAnim())
+        {
+            return true;
+        }
+        if (IsInputBlocked())
+        {
+            return true;
+        }
+        if (m_currentlyShowingReward != null)
+        {
+            m_currentlyShowingReward.Hide(animate: true);
+            m_currentlyShowingReward = null;
+        }
+        HideScoreScreen();
+        if (!m_haveShownTwoScoop)
+        {
+            return true;
+        }
+        HideTwoScoop();
+        if (ShowHeroRewardEvent() && m_heroRewardEventReady)
+        {
+            return true;
+        }
+        if (ShowRewardTrackXpGains())
+        {
+            return true;
+        }
+        if (ShowNextRewardTrackAutoClaimedReward()) // TODO
+        {
+            return true;
+        }
+        /*
+        if (ShowFixedRewards()) // comment this out because the fixed rewards are currently inaccessible
+        {
+            return true;
+        }
+*/
+        if (ShowGoldReward())
+        {
+            return true;
+        }
+        if (ShowRankedCardBackProgress()) // TODO Ranked only
+        {
+            return true;
+        }
+        if (ShowRankChange())
+        {
+            return true;
+        }
+        if (ShowRankedRewards()) // TODO Ranked only
+        {
+            return true;
+        }
+        if (ShowNextProgressionQuestReward()) // TODO
+        {
+            return true;
+        }
+        if (ShowMercenariesExperienceRewards())
+        {
+            return true;
+        }
+        if (ShowNextCompletedQuest())
+        {
+            return true;
+        }
+        if (ShowNextReward())
+        {
+            return true;
+        }
+        if (ShowNextGenericReward())
+        {
+            return true;
+        }
+        if (!SpectatorManager.Get().IsSpectatingOrWatching && TemporaryAccountManager.IsTemporaryAccount() && ShowHealUpDialog())
+        {
+            return true;
+        }
+        if (ShowPushNotificationPrompt())
+        {
+            return true;
+        }
+		ShowAppRatingPrompt();
+        m_doneDisplayingRewards = true;
+        return false;
+    }
+
+    protected virtual void OnTwoScoopShown()
+    {
+    }
+
+    protected virtual void OnTwoScoopHidden()
+    {
+    }
+
+    protected virtual void InitGoldRewardUI()
+    {
+    }
+
+    private static string GetFriendlyChallengeRewardMessage(Achievement achieve)
+    {
+        if (DemoMgr.Get().IsDemo())
+        {
+            return null;
+        }
+        string text = null;
+        if (achieve.DbfRecord.MaxDefense > 0)
+        {
+            text = GetFriendlyChallengeEarlyConcedeMessage(achieve.DbfRecord.MaxDefense);
+            if (!string.IsNullOrEmpty(text))
+            {
+                return text;
+            }
+        }
+        AchieveRegionDataDbfRecord currentRegionData = achieve.GetCurrentRegionData();
+        if (currentRegionData != null && currentRegionData.RewardableLimit > 0 && achieve.IntervalRewardStartDate > 0)
+        {
+            DateTime dateTime = DateTime.FromFileTimeUtc(achieve.IntervalRewardStartDate);
+            if ((DateTime.UtcNow - dateTime).TotalDays < currentRegionData.RewardableInterval && achieve.IntervalRewardCount >= currentRegionData.RewardableLimit)
+            {
+                text = GameStrings.Get("GLOBAL_FRIENDLYCHALLENGE_QUEST_REWARD_AT_LIMIT");
+            }
+        }
+        if (string.IsNullOrEmpty(text) && currentRegionData != null && currentRegionData.RewardableLimit > 0 && FriendChallengeMgr.Get().DidReceiveChallenge())
+        {
+            achieve.IncrementIntervalRewardCount();
+        }
+        return text;
+    }
+
+    protected static string GetFriendlyChallengeRewardText()
+    {
+        if (!FriendChallengeMgr.Get().HasChallenge())
+        {
+            return null;
+        }
+        if (DemoMgr.Get().IsDemo())
+        {
+            return null;
+        }
+        string text = null;
+        AchieveManager achieveManager = AchieveManager.Get();
+        PartyQuestInfo partyQuestInfo = FriendChallengeMgr.Get().GetPartyQuestInfo();
+        if (partyQuestInfo != null)
+        {
+            bool num = FriendChallengeMgr.Get().DidSendChallenge();
+            bool flag = FriendChallengeMgr.Get().DidReceiveChallenge();
+            PlayerType playerType = PlayerType.PT_ANY;
+            if (num)
+            {
+                playerType = PlayerType.PT_FRIENDLY_CHALLENGER;
+            }
+            if (flag)
+            {
+                playerType = PlayerType.PT_FRIENDLY_CHALLENGEE;
+            }
+            for (int i = 0; i < partyQuestInfo.QuestIds.Count; i++)
+            {
+                Achievement achievement = achieveManager.GetAchievement(partyQuestInfo.QuestIds[i]);
+                if (achievement != null && achievement.IsValidFriendlyPlayerChallengeType(playerType))
+                {
+                    text = GetFriendlyChallengeRewardMessage(achievement);
+                }
+                if (string.IsNullOrEmpty(text))
+                {
+                    Achievement achievement2 = achieveManager.GetAchievement(achievement.DbfRecord.SharedAchieveId);
+                    if (achievement2 != null && achievement2.IsValidFriendlyPlayerChallengeType(playerType))
+                    {
+                        text = GetFriendlyChallengeRewardMessage(achievement2);
+                    }
+                }
+            }
+        }
+		if (string.IsNullOrEmpty(text) && EventTimingManager.Get().IsEventActive(EventTimingType.FRIEND_WEEK))
+        {
+            NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+            bool num2 = (from a in achieveManager.GetActiveQuests()
+                         where a.IsAffectedByFriendWeek && (a.AchieveTrigger == Achieve.Trigger.WIN || a.AchieveTrigger == Achieve.Trigger.FINISH) && a.GameModeRequiresNonFriendlyChallenge
+                         select a).Any();
+            bool flag2 = false;
+            if (FriendChallengeMgr.Get().IsChallengeTavernBrawl() && netObject != null && netObject.FriendWeekAllowsTavernBrawlRecordUpdate)
+            {
+                BrawlType challengeBrawlType = FriendChallengeMgr.Get().GetChallengeBrawlType();
+                TavernBrawlMission mission = TavernBrawlManager.Get().GetMission(challengeBrawlType);
+                TavernBrawlPlayerRecord record = TavernBrawlManager.Get().GetRecord(challengeBrawlType);
+                bool flag3 = mission != null && (mission.rewardTrigger == RewardTrigger.REWARD_TRIGGER_WIN_GAME || mission.rewardTrigger == RewardTrigger.REWARD_TRIGGER_FINISH_GAME);
+                if (mission != null && mission.rewardType != RewardType.REWARD_UNKNOWN && flag3 && record != null && record.RewardProgress < mission.RewardTriggerQuota)
+                {
+                    flag2 = true;
+                }
+            }
+            if (!num2 && !flag2)
+            {
+                return null;
+            }
+            int concederMaxDefense = 0;
+            if (netObject != null)
+            {
+                concederMaxDefense = netObject.FriendWeekConcederMaxDefense;
+            }
+            text = GetFriendlyChallengeEarlyConcedeMessage(concederMaxDefense);
+        }
+        return text;
+    }
+
+    private static string GetFriendlyChallengeEarlyConcedeMessage(int concederMaxDefense)
+    {
+        if (DemoMgr.Get().IsDemo())
+        {
+            return null;
+        }
+        int num = 0;
+        NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+        if (netObject != null)
+        {
+            num = netObject.FriendWeekConcededGameMinTotalTurns;
+        }
+        string key = null;
+        int num2 = 0;
+        GameState gameState = GameState.Get();
+        bool flag = false;
+        foreach (KeyValuePair<int, Player> item in gameState.GetPlayerMap())
+        {
+            Player value = item.Value;
+            TAG_PLAYSTATE preGameOverPlayState = value.GetPreGameOverPlayState();
+            if (preGameOverPlayState == TAG_PLAYSTATE.CONCEDED || preGameOverPlayState == TAG_PLAYSTATE.DISCONNECTED)
+            {
+                flag = true;
+                Entity hero = value.GetHero();
+                if (hero != null)
+                {
+                    num2 = hero.GetCurrentDefense();
+                    key = ((value.GetSide() != Player.Side.FRIENDLY) ? "GLOBAL_FRIENDLYCHALLENGE_REWARD_CONCEDED_YOUR_OPPONENT" : "GLOBAL_FRIENDLYCHALLENGE_REWARD_CONCEDED_YOURSELF");
+                    break;
+                }
+            }
+        }
+        bool flag2 = concederMaxDefense > 0;
+        bool flag3 = !flag || (flag2 && num2 <= concederMaxDefense);
+        bool flag4 = !flag || gameState.GetTurn() >= num;
+        if (!flag3 && !flag4)
+        {
+            return GameStrings.Get(key);
+        }
+        return null;
+    }
+
+    protected void BackToMode(SceneMgr.Mode mode)
+    {
+        AchieveManager.Get().RemoveAchievesUpdatedListener(OnAchievesUpdated);
+        HideTwoScoop();
+        if (OnBackOutOfGameplay != null)
+        {
+            OnBackOutOfGameplay();
+        }
+        if (!m_hasAlreadySetMode)
+        {
+            m_hasAlreadySetMode = true;
+            StartCoroutine(ToMode(mode));
+            Navigation.Clear();
+        }
+    }
+
+    private IEnumerator ToMode(SceneMgr.Mode mode)
+    {
+        yield return new WaitForSeconds(0.5f);
+        SceneMgr.Get().SetNextMode(mode);
+    }
+
+    private void ReturnToPreviousMode()
+    {
+		SceneMgr.Mode mode = GameMgr.Get().GetPostGameSceneMode();
+		if (mode == SceneMgr.Mode.ADVENTURE && (!GameDownloadManagerProvider.Get().IsModuleReadyToPlay(DownloadTags.Content.Adventure) || !GameUtils.HasCompletedApprentice()))
 		{
-			component.SendEvent("Death");
+			mode = SceneMgr.Mode.HUB;
 		}
-		ContinueButtonPress_Common();
-		m_hitbox.RemoveEventListener(UIEventType.RELEASE, ContinueButtonPress_PrevMode);
-		ReturnToPreviousMode();
-		return false;
-	}
-
-	protected void ContinueButtonPress_TutorialProgress(UIEvent e)
-	{
-		ContinueTutorialEvents();
-	}
-
-	public void ContinueTutorialEvents()
-	{
-		if (!ContinueDefaultEvents())
+		else if (mode == SceneMgr.Mode.BACON && !GameDownloadManagerProvider.Get().IsModuleReadyToPlay(DownloadTags.Content.Bgs))
 		{
-			ContinueButtonPress_Common();
-			m_hitbox.RemoveEventListener(UIEventType.RELEASE, ContinueButtonPress_TutorialProgress);
-			m_continueText.gameObject.SetActive(value: false);
-			ShowTutorialProgress();
+			mode = SceneMgr.Mode.HUB;
 		}
-	}
+		GameMgr.Get().PreparePostGameSceneMode(mode);
+		if (mode == SceneMgr.Mode.PVP_DUNGEON_RUN)
+        {
+            DuelsConfig.Get().SetLastGameResult(GameMgr.Get().LastGameData.GameResult);
+        }
+		BackToMode(mode);
+    }
+
+    private void ShowScoreScreen()
+    {
+        if (!GameState.Get().CanShowScoreScreen())
+        {
+            return;
+        }
+        m_scoreScreen = GameUtils.LoadGameObjectWithComponent<ScoreScreen>(m_ScoreScreenPrefab);
+        if ((bool)m_scoreScreen)
+        {
+            TransformUtil.AttachAndPreserveLocalTransform(m_scoreScreen.transform, base.transform);
+            LayerUtils.SetLayer(m_scoreScreen, GameLayer.IgnoreFullScreenEffects);
+            m_scoreScreen.Show();
+            m_showingScoreScreen = true;
+            SetPlayingBlockingAnim(set: true);
+            StartCoroutine(WaitThenSetPlayingBlockingAnim(0.65f, set: false));
+            if (Gameplay.Get().HasBattleNetFatalError())
+            {
+                m_hitbox.AddEventListener(UIEventType.RELEASE, ContinueButtonPress_ProceedToError);
+            }
+        }
+    }
+
+    private void HideScoreScreen()
+    {
+        if ((bool)m_scoreScreen)
+        {
+            m_scoreScreen.Hide();
+            m_showingScoreScreen = false;
+            SetPlayingBlockingAnim(set: true);
+            StartCoroutine(WaitThenSetPlayingBlockingAnim(0.25f, set: false));
+        }
+    }
+
+    protected void HideTwoScoop()
+    {
+        if (m_twoScoop.IsShown())
+        {
+            m_twoScoop.Hide();
+            m_noGoldRewardText.gameObject.SetActive(value: false);
+            OnTwoScoopHidden();
+            if (OnTwoScoopsShown != null)
+            {
+                OnTwoScoopsShown(shown: false, m_twoScoop);
+            }
+            if (InputManager.Get() != null)
+            {
+                InputManager.Get().EnableInput();
+            }
+        }
+    }
+
+    protected void ShowTwoScoop()
+    {
+        StartCoroutine(ShowTwoScoopWhenReady());
+    }
+
+    private IEnumerator ShowTwoScoopWhenReady()
+    {
+        while ((bool)m_scoreScreen)
+        {
+            SendTelemetryIfTimeout("ScoreScreen");
+            yield return null;
+        }
+        while (!m_twoScoop.IsLoaded())
+        {
+            SendTelemetryIfTimeout("TwoScoop");
+            yield return null;
+        }
+        while (JustEarnedHeroReward())
+        {
+            SendTelemetryIfTimeout("HeroReward");
+            if (m_heroRewardEventReady)
+            {
+                break;
+            }
+            yield return null;
+        }
+		m_twoScoop.Show(AccessibleEndGameScreen.Get());
+        if (!SpectatorManager.Get().IsSpectatingOrWatching && ShouldMakeUtilRequests())
+        {
+            InitGoldRewardUI();
+        }
+        OnTwoScoopShown();
+        m_haveShownTwoScoop = true;
+        if (OnTwoScoopsShown != null)
+        {
+            OnTwoScoopsShown(shown: true, m_twoScoop);
+        }
+    }
+
+    protected IEnumerator WaitThenSetPlayingBlockingAnim(float sec, bool set)
+    {
+        yield return new WaitForSeconds(sec);
+        SetPlayingBlockingAnim(set);
+    }
+
+    protected bool ShouldMakeUtilRequests()
+    {
+        if (!Network.ShouldBeConnectedToAurora())
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public bool IsDoneDisplayingRewards()
+    {
+        return m_doneDisplayingRewards;
+    }
 
-	private bool ContinueDefaultEvents()
-	{
-		if (IsPlayingBlockingAnim())
-		{
-			return true;
-		}
-		if (IsInputBlocked())
-		{
-			return true;
-		}
-		if (m_currentlyShowingReward != null)
-		{
-			m_currentlyShowingReward.Hide(animate: true);
-			m_currentlyShowingReward = null;
-		}
-		HideScoreScreen();
-		if (!m_haveShownTwoScoop)
-		{
-			return true;
-		}
-		HideTwoScoop();
-		if (ShowHeroRewardEvent() && m_heroRewardEventReady)
-		{
-			return true;
-		}
-		if (ShowRewardTrackXpGains())
-		{
-			return true;
-		}
-		if (ShowNextRewardTrackAutoClaimedReward())
-		{
-			return true;
-		}
-		if (ShowFixedRewards())
-		{
-			return true;
-		}
-		if (ShowGoldReward())
-		{
-			return true;
-		}
-		if (ShowRankedCardBackProgress())
-		{
-			return true;
-		}
-		if (ShowRankChange())
-		{
-			return true;
-		}
-		if (ShowRankedRewards())
-		{
-			return true;
-		}
-		if (ShowNextProgressionQuestReward())
-		{
-			return true;
-		}
-		if (ShowMercenariesExperienceRewards())
-		{
-			return true;
-		}
-		if (ShowNextCompletedQuest())
-		{
-			return true;
-		}
-		if (ShowNextReward())
-		{
-			return true;
+	private IEnumerator ShowStandardFlowIfReady()
+    {
+		while (!m_shown)
+        {
+			yield return null;
 		}
-		if (ShowNextGenericReward())
+		while (ShouldMakeUtilRequests() && !m_netCacheReady && SendTelemetryIfTimeout("m_netCacheReady"))
 		{
-			return true;
+			yield return null;
 		}
-		if (!SpectatorManager.Get().IsSpectatingOrWatching && TemporaryAccountManager.IsTemporaryAccount() && ShowHealUpDialog())
+		while (!m_achievesReady)
 		{
-			return true;
+			SendTelemetryIfTimeout("m_achievesReady");
+			yield return null;
 		}
-		if (ShowPushNotificationPrompt())
+		while (!m_rewardsLoaded)
 		{
-			return true;
+			SendTelemetryIfTimeout("m_rewardsLoaded");
+			yield return null;
 		}
-		ShowAppRatingPrompt();
-		m_doneDisplayingRewards = true;
-		return false;
-	}
-
-	protected virtual void OnTwoScoopShown()
-	{
-	}
-
-	protected virtual void OnTwoScoopHidden()
-	{
-	}
-
-	protected virtual void InitGoldRewardUI()
-	{
-	}
-
-	private static string GetFriendlyChallengeRewardMessage(Achievement achieve)
-	{
-		if (DemoMgr.Get().IsDemo())
+		while (m_shouldShowRankChange && (!m_rankChangeReady || !m_medalInfoUpdated))
 		{
-			return null;
+			SendTelemetryIfTimeout($"m_rankChangeReady: {m_rankChangeReady} m_medalInfoUpdated: {m_medalInfoUpdated}");
+			yield return null;
 		}
-		string text = null;
-		if (achieve.DbfRecord.MaxDefense > 0)
+		while (m_shouldShowRankedCardBackProgress && m_rankedCardBackProgress == null)
 		{
-			text = GetFriendlyChallengeEarlyConcedeMessage(achieve.DbfRecord.MaxDefense);
-			if (!string.IsNullOrEmpty(text))
-			{
-				return text;
-			}
+			SendTelemetryIfTimeout("m_rankedCardBackProgress");
+			yield return null;
 		}
-		AchieveRegionDataDbfRecord currentRegionData = achieve.GetCurrentRegionData();
-		if (currentRegionData != null && currentRegionData.RewardableLimit > 0 && achieve.IntervalRewardStartDate > 0)
+		while (m_shouldShowRewardXpGains && !RewardXpNotificationManager.Get().IsReady)
 		{
-			DateTime dateTime = DateTime.FromFileTimeUtc(achieve.IntervalRewardStartDate);
-			if ((DateTime.UtcNow - dateTime).TotalDays < currentRegionData.RewardableInterval && achieve.IntervalRewardCount >= currentRegionData.RewardableLimit)
-			{
-				text = GameStrings.Get("GLOBAL_FRIENDLYCHALLENGE_QUEST_REWARD_AT_LIMIT");
-			}
-		}
-		if (string.IsNullOrEmpty(text) && currentRegionData != null && currentRegionData.RewardableLimit > 0 && FriendChallengeMgr.Get().DidReceiveChallenge())
+			SendTelemetryIfTimeout("RewardXpNotificationManager.Get().IsReady");
+			yield return null;
+        }
+        SendRankedInitTelemetryIfNeeded();
+        ShowStandardFlow();
+    }
+
+    protected virtual void ShowStandardFlow()
+    {
+        ShowTwoScoop();
+		ShowRewardsXpGains();
+		if (!UniversalInputManager.UsePhoneUI)
 		{
-			achieve.IncrementIntervalRewardCount();
+			m_continueText.gameObject.SetActive(value: true);
 		}
-		return text;
 	}
 
-	protected static string GetFriendlyChallengeRewardText()
+	protected void ShowRewardsXpGains()
 	{
-		if (!FriendChallengeMgr.Get().HasChallenge())
-		{
-			return null;
-		}
-		if (DemoMgr.Get().IsDemo())
+        if (RewardXpNotificationManager.Get().HasXpGainsToShow)
+        {
+            m_shouldShowRewardXpGains = true;
+            RewardXpNotificationManager.Get().InitEndOfGameFlow(null);
+            RewardXpNotificationManager.Get().ShowRewardTrackXpGains(delegate
+            {
+                ContinueEvents();
+            }, justShowGameXp: true);
+        }
+    }
+
+    protected virtual void OnNetCacheReady()
+    {
+        m_netCacheReady = true;
+        NetCache.Get().UnregisterNetCacheHandler(OnNetCacheReady);
+        if (m_shouldShowRankChange)
+        {
+            RetryMedalInfoRequestIfNeeded();
+            LoadRankChange();
+            LoadRankedRewardDisplay();
+            LoadRankedCardBackProgress();
+        }
+        MaybeUpdateRewards();
+    }
+
+    private void RetryMedalInfoRequestIfNeeded()
+    {
+        if (IsMedalInfoRetryNeeded())
+        {
+            StartCoroutine(RetryMedalInfoRequest());
+			return;
+        }
+            NetCache.Get().RemoveUpdatedListener(typeof(NetCache.NetCacheMedalInfo), OnMedalInfoUpdate);
+            m_medalInfoUpdated = true;
+        }
+
+    private bool IsMedalInfoRetryNeeded()
+    {
+        if (!ShouldMakeUtilRequests())
+        {
+            return false;
+        }
+        if (!m_shouldShowRankChange)
+        {
+            return false;
+        }
+        if (m_medalInfoRetryCount >= 3)
+        {
+            return false;
+        }
+        FormatType formatType = Options.GetFormatType();
+        MedalInfoTranslator localPlayerMedalInfo = RankMgr.Get().GetLocalPlayerMedalInfo();
+        if (localPlayerMedalInfo != null)
+        {
+            return localPlayerMedalInfo.GetChangeType(formatType) == RankChangeType.NO_GAME_PLAYED;
+        }
+        return true;
+    }
+
+    private IEnumerator RetryMedalInfoRequest()
+    {
+        if (m_medalInfoRetryCount == 0)
+        {
+            m_medalInfoRetryDelay = 1f;
+            NetCache.Get().RegisterUpdatedListener(typeof(NetCache.NetCacheMedalInfo), OnMedalInfoUpdate);
+        }
+        else
+        {
+            m_medalInfoRetryDelay *= 2f;
+        }
+        m_medalInfoRetryCount++;
+        yield return new WaitForSeconds(m_medalInfoRetryDelay);
+        NetCache.Get().RefreshNetObject<NetCache.NetCacheMedalInfo>();
+    }
+
+    private void OnMedalInfoUpdate()
+    {
+        RetryMedalInfoRequestIfNeeded();
+    }
+
+    private void SendRankedInitTelemetryIfNeeded()
+    {
+        if (m_shouldShowRankChange && !m_hasSentRankedInitTelemetry)
+        {
+            m_hasSentRankedInitTelemetry = true;
+            float num = Time.time - m_endGameScreenStartTime;
+            FormatType formatType = Options.GetFormatType();
+            MedalInfoTranslator localPlayerMedalInfo = RankMgr.Get().GetLocalPlayerMedalInfo();
+            bool flag = m_medalInfoRetryCount >= 3 && (localPlayerMedalInfo == null || localPlayerMedalInfo.GetChangeType(formatType) == RankChangeType.NO_GAME_PLAYED);
+            if (flag && localPlayerMedalInfo != null)
+            {
+                Log.All.PrintError("EndGameScreen_MedalInfoTimeOut elapsedTime={0} retries={1} prev={2} curr={3}", num, m_medalInfoRetryCount, localPlayerMedalInfo.GetPreviousMedal(formatType).ToString(), localPlayerMedalInfo.GetCurrentMedal(formatType).ToString());
+            }
+            bool showRankedReward = m_rankedRewardsToDisplay.Count > 0;
+            TelemetryManager.Client().SendEndGameScreenInit(num, m_medalInfoRetryCount, flag, showRankedReward, m_shouldShowRankedCardBackProgress, m_rewards.Count);
+        }
+    }
+
+    private void LoadRankChange()
+    {
+        AssetReference rANK_CHANGE_TWO_SCOOP_PREFAB_NEW = RankMgr.RANK_CHANGE_TWO_SCOOP_PREFAB_NEW;
+        AssetLoader.Get().InstantiatePrefab(rANK_CHANGE_TWO_SCOOP_PREFAB_NEW, OnRankChangeLoaded);
+    }
+
+    private void OnRankChangeLoaded(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        m_rankChangeTwoScoop = go;
+        m_rankChangeTwoScoop.gameObject.SetActive(value: false);
+        m_rankChangeReady = true;
+    }
+
+    private void OnRankChangeClosed()
+    {
+        m_isShowingRankChange = false;
+        m_shouldShowRankChange = false;
+        ContinueEvents();
+    }
+
+    private void LoadRankedRewardDisplay()
+    {
+        if (RankMgr.Get().GetLocalPlayerMedalInfo().GetRankedRewardsEarned(Options.GetFormatType(), ref m_rankedRewardsToDisplay) && m_rankedRewardsToDisplay.Count != 0)
+        {
+            m_rankedRewardDisplayWidget = WidgetInstance.Create(RankMgr.RANKED_REWARD_DISPLAY_PREFAB);
+            m_rankedRewardDisplayWidget.RegisterReadyListener(delegate
+            {
+                OnRankedRewardDisplayWidgetReady();
+            });
+        }
+    }
+
+    private void OnRankedRewardDisplayWidgetReady()
+    {
+        m_rankedRewardDisplay = m_rankedRewardDisplayWidget.GetComponentInChildren<RankedRewardDisplay>();
+    }
+
+    private void LoadRankedCardBackProgress()
+    {
+        m_shouldShowRankedCardBackProgress = RankMgr.Get().GetLocalPlayerMedalInfo().ShouldShowCardBackProgress();
+        if (m_shouldShowRankedCardBackProgress)
+        {
+            m_rankedCardBackProgressWidget = WidgetInstance.Create(RankMgr.RANKED_CARDBACK_PROGRESS_DISPLAY_PREFAB);
+            m_rankedCardBackProgressWidget.RegisterReadyListener(delegate
+            {
+                OnRankedCardBackProgressWidgetReady();
+            });
+        }
+    }
+
+    private void OnRankedCardBackProgressWidgetReady()
+    {
+        m_rankedCardBackProgress = m_rankedCardBackProgressWidget.GetComponentInChildren<RankedCardBackProgressDisplay>();
+    }
+
+    private IEnumerator WaitForAchieveManager()
+    {
+        while (!AchieveManager.Get().IsReady())
+        {
+            yield return null;
+        }
+        m_achievesReady = true;
+        MaybeUpdateRewards();
+    }
+
+    private void ProcessPreviousAchievements()
+    {
+        OnAchievesUpdated(new List<Achievement>(), new List<Achievement>(), null);
+    }
+
+    private void OnAchievesUpdated(List<Achievement> updatedAchieves, List<Achievement> completedAchieves, object userData)
+    {
+        List<Achievement> newCompletedAchievesToShow = AchieveManager.Get().GetNewCompletedAchievesToShow();
+        bool flag = PopupDisplayManager.ShouldSuppressPopups();
+        foreach (Achievement achieve in newCompletedAchievesToShow)
+        {
+			if ((!flag || achieve.Mode == Achieve.GameMode.MERCENARIES) && achieve.RewardTiming == Achieve.RewardTiming.IMMEDIATE && string.IsNullOrWhiteSpace(achieve.CustomVisualWidget) && m_completedQuests.Find((Achievement obj) => achieve.ID == obj.ID) == null)
+            {
+                m_completedQuests.Add(achieve);
+            }
+        }
+    }
+
+    private void OnGenericRewardUpdated(long rewardNoticeId, object userData)
+    {
+        m_genericRewardChestNoticeIdsReady.Add(rewardNoticeId);
+        UpdateRewards();
+    }
+
+    protected bool HasShownScoops()
+    {
+        return m_haveShownTwoScoop;
+    }
+
+    protected void SetHeroRewardEventReady(bool isReady)
+    {
+        m_heroRewardEventReady = isReady;
+    }
+
+    private void MaybeUpdateRewards()
+    {
+        if (m_achievesReady && m_netCacheReady)
+        {
+            UpdateRewards();
+        }
+    }
+
+    private void LoadRewards(List<RewardData> rewardsToLoad, Reward.DelOnRewardLoaded callback)
+    {
+        if (rewardsToLoad == null)
+        {
+            return;
+        }
+        foreach (RewardData item in rewardsToLoad)
+        {
+            if (PopupDisplayManager.Get().RewardPopups.UpdateNoticesSeen(item))
+            {
+                m_numRewardsToLoad++;
+                item.LoadRewardObject(callback);
+            }
+        }
+    }
+
+    private void UpdateRewards()
+    {
+		GameMgr gameMgr = GameMgr.Get();
+		if (gameMgr == null)
 		{
-			return null;
+			Log.All.PrintError("EndGameScreen::UpdateRewards GameMgr object is null.");
+			return;
 		}
-		string text = null;
-		AchieveManager achieveManager = AchieveManager.Get();
-		PartyQuestInfo partyQuestInfo = FriendChallengeMgr.Get().GetPartyQuestInfo();
-		if (partyQuestInfo != null)
-		{
-			bool num = FriendChallengeMgr.Get().DidSendChallenge();
-			bool flag = FriendChallengeMgr.Get().DidReceiveChallenge();
-			PlayerType playerType = PlayerType.PT_ANY;
-			if (num)
-			{
-				playerType = PlayerType.PT_FRIENDLY_CHALLENGER;
-			}
-			if (flag)
+        bool flag = true;
+		if (gameMgr.IsTraditionalTutorial())
+        {
+            flag = GameUtils.IsTraditionalTutorialComplete();
+        }
+        List<RewardData> rewardsToShow = null;
+        List<RewardData> genericRewardChestsToShow = null;
+        List<RewardData> purchasedCardRewardsToShow = null;
+        if (flag)
+        {
+			if (NetCache.Get() == null)
 			{
-				playerType = PlayerType.PT_FRIENDLY_CHALLENGEE;
+				Log.All.PrintError("EndGameScreen::UpdateRewards NetCache object is null.");
+				return;
 			}
-			for (int i = 0; i < partyQuestInfo.QuestIds.Count; i++)
+            List<NetCache.ProfileNotice> list = NetCache.Get().GetNetObject<NetCache.NetCacheProfileNotices>().Notices.Where((NetCache.ProfileNotice n) => n.Type != NetCache.ProfileNotice.NoticeType.GENERIC_REWARD_CHEST || m_genericRewardChestNoticeIdsReady.Any((long r) => n.NoticeID == r)).ToList();
+            list.RemoveAll((NetCache.ProfileNotice n) => n.Origin == NetCache.ProfileNotice.NoticeOrigin.NOTICE_ORIGIN_DUELS);
+            List<RewardData> rewards = RewardUtils.GetRewards(list);
+            HashSet<Achieve.RewardTiming> rewardTimings = new HashSet<Achieve.RewardTiming> { Achieve.RewardTiming.IMMEDIATE };
+            RewardUtils.GetViewableRewards(rewards, rewardTimings, out rewardsToShow, out genericRewardChestsToShow, ref purchasedCardRewardsToShow, ref m_completedQuests);
+        }
+        else
+        {
+            rewardsToShow = new List<RewardData>();
+        }
+        JustEarnedHeroReward();
+		if (!gameMgr.IsSpectator())
+        {
+			GameState gameState = GameState.Get();
+			if (gameState != null)
 			{
-				Achievement achievement = achieveManager.GetAchievement(partyQuestInfo.QuestIds[i]);
-				if (achievement != null && achievement.IsValidFriendlyPlayerChallengeType(playerType))
-				{
-					text = GetFriendlyChallengeRewardMessage(achievement);
-				}
-				if (string.IsNullOrEmpty(text))
+				GameEntity gameEntity = gameState.GetGameEntity();
+				if (gameEntity != null)
 				{
-					Achievement achievement2 = achieveManager.GetAchievement(achievement.DbfRecord.SharedAchieveId);
-					if (achievement2 != null && achievement2.IsValidFriendlyPlayerChallengeType(playerType))
-					{
-						text = GetFriendlyChallengeRewardMessage(achievement2);
-					}
-				}
+					List<RewardData> customRewards = gameEntity.GetCustomRewards();
+            if (customRewards != null)
+            {
+                rewardsToShow.AddRange(customRewards);
+            }
+        }
 			}
 		}
-		if (string.IsNullOrEmpty(text) && EventTimingManager.Get().IsEventActive(EventTimingType.FRIEND_WEEK))
+        LoadRewards(rewardsToShow, OnRewardObjectLoaded);
+        LoadRewards(genericRewardChestsToShow, OnGenericRewardObjectLoaded);
+        if (m_numRewardsToLoad == 0)
+        {
+            m_rewardsLoaded = true;
+        }
+    }
+
+    private void OnRewardObjectLoaded(Reward reward, object callbackData)
+    {
+        LoadReward(reward, ref m_rewards);
+    }
+
+    private void OnGenericRewardObjectLoaded(Reward reward, object callbackData)
+    {
+        LoadReward(reward, ref m_genericRewards);
+    }
+
+    private void PositionReward(Reward reward)
+    {
+        reward.transform.parent = base.transform;
+        reward.transform.localRotation = Quaternion.identity;
+        reward.transform.localPosition = PopupDisplayManager.Get().RewardPopups.GetRewardLocalPos();
+    }
+
+    private void LoadReward(Reward reward, ref List<Reward> allRewards)
+    {
+        reward.Hide();
+        PositionReward(reward);
+        allRewards.Add(reward);
+        m_numRewardsToLoad--;
+        if (m_numRewardsToLoad <= 0)
+        {
+            RewardUtils.SortRewards(ref allRewards);
+            m_rewardsLoaded = true;
+        }
+    }
+
+    private void DisplayLoadedRewardObject(Reward reward, object callbackData)
+    {
+        if (m_currentlyShowingReward != null)
+        {
+            m_currentlyShowingReward.Hide(animate: true);
+            m_currentlyShowingReward = null;
+        }
+        reward.Hide();
+        PositionReward(reward);
+        m_currentlyShowingReward = reward;
+        SetPlayingBlockingAnim(set: true);
+        LayerUtils.SetLayer(m_currentlyShowingReward.gameObject, GameLayer.IgnoreFullScreenEffects);
+        ShowReward(m_currentlyShowingReward);
+    }
+
+    private void ShowReward(Reward reward)
+    {
+        bool updateCacheValues = !(reward is CardReward);
+        RewardUtils.ShowReward(UserAttentionBlocker.NONE, reward, updateCacheValues, PopupDisplayManager.Get().RewardPopups.GetRewardPunchScale(), PopupDisplayManager.Get().RewardPopups.GetRewardScale());
+        StartCoroutine(WaitThenSetPlayingBlockingAnim(0.35f, set: false));
+    }
+
+    protected virtual bool ShowHeroRewardEvent()
+    {
+        return false;
+    }
+
+    protected bool ShowFixedRewards()
+    {
+        if (m_isShowingFixedRewards)
+        {
+            return true;
+        }
+        if (PopupDisplayManager.SuppressPopupsTemporarily)
+        {
+            return false;
+        }
+        HashSet<Achieve.RewardTiming> rewardVisualTimings = new HashSet<Achieve.RewardTiming> { Achieve.RewardTiming.IMMEDIATE };
+        FixedRewardsMgr.DelOnAllFixedRewardsShown allRewardsShownCallback = delegate
+        {
+            m_isShowingFixedRewards = false;
+            ContinueEvents();
+        };
+        m_isShowingFixedRewards = FixedRewardsMgr.Get().ShowFixedRewards(UserAttentionBlocker.NONE, rewardVisualTimings, allRewardsShownCallback, null);
+        return m_isShowingFixedRewards;
+    }
+
+    private bool ShowGoldReward()
+    {
+		int num = m_rewards.FindIndex((Reward reward) => reward.Data is GoldRewardData { Origin: NetCache.ProfileNotice.NoticeOrigin.TOURNEY });
+        if (num < 0)
+        {
+            return false;
+        }
+        Reward item = m_rewards[num];
+        m_rewards.RemoveAt(num);
+        m_rewards.Insert(0, item);
+        ShowNextReward();
+        return true;
+    }
+
+    private bool ShowNextProgressionQuestReward()
+    {
+        if (!QuestManager.Get().ShowNextReward(delegate
+        {
+            ContinueEvents();
+        }))
+        {
+            return false;
+        }
+        return true;
+    }
+
+    protected bool ShowNextCompletedQuest()
+    {
+        if (m_completedQuests.Count == 0)
+        {
+            return false;
+        }
+        if (QuestToast.IsQuestActive())
+        {
+            QuestToast.GetCurrentToast().CloseQuestToast();
+        }
+        Achievement achievement = m_completedQuests[0];
+        m_completedQuests.RemoveAt(0);
+		while (!string.IsNullOrEmpty(achievement.CustomVisualWidget))
 		{
-			NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-			bool num2 = (from a in achieveManager.GetActiveQuests()
-				where a.IsAffectedByFriendWeek && (a.AchieveTrigger == Achieve.Trigger.WIN || a.AchieveTrigger == Achieve.Trigger.FINISH) && a.GameModeRequiresNonFriendlyChallenge
-				select a).Any();
-			bool flag2 = false;
-			if (FriendChallengeMgr.Get().IsChallengeTavernBrawl() && netObject != null && netObject.FriendWeekAllowsTavernBrawlRecordUpdate)
-			{
-				BrawlType challengeBrawlType = FriendChallengeMgr.Get().GetChallengeBrawlType();
-				TavernBrawlMission mission = TavernBrawlManager.Get().GetMission(challengeBrawlType);
-				TavernBrawlPlayerRecord record = TavernBrawlManager.Get().GetRecord(challengeBrawlType);
-				bool flag3 = mission != null && (mission.rewardTrigger == RewardTrigger.REWARD_TRIGGER_WIN_GAME || mission.rewardTrigger == RewardTrigger.REWARD_TRIGGER_FINISH_GAME);
-				if (mission != null && mission.rewardType != RewardType.REWARD_UNKNOWN && flag3 && record != null && record.RewardProgress < mission.RewardTriggerQuota)
-				{
-					flag2 = true;
-				}
-			}
-			if (!num2 && !flag2)
-			{
-				return null;
-			}
-			int concederMaxDefense = 0;
-			if (netObject != null)
+			if (m_completedQuests.Count == 0)
 			{
-				concederMaxDefense = netObject.FriendWeekConcederMaxDefense;
+				return false;
 			}
-			text = GetFriendlyChallengeEarlyConcedeMessage(concederMaxDefense);
-		}
-		return text;
-	}
-
-	private static string GetFriendlyChallengeEarlyConcedeMessage(int concederMaxDefense)
-	{
-		if (DemoMgr.Get().IsDemo())
-		{
-			return null;
-		}
-		int num = 0;
-		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-		if (netObject != null)
-		{
-			num = netObject.FriendWeekConcededGameMinTotalTurns;
+			achievement = m_completedQuests[0];
+			m_completedQuests.RemoveAt(0);
 		}
-		string key = null;
-		int num2 = 0;
-		GameState gameState = GameState.Get();
-		bool flag = false;
-		foreach (KeyValuePair<int, Player> item in gameState.GetPlayerMap())
-		{
-			Player value = item.Value;
-			TAG_PLAYSTATE preGameOverPlayState = value.GetPreGameOverPlayState();
-			if (preGameOverPlayState == TAG_PLAYSTATE.CONCEDED || preGameOverPlayState == TAG_PLAYSTATE.DISCONNECTED)
+        if (!achievement.UseGenericRewardVisual)
+        {
+            bool flag = false;
+            foreach (RewardData reward in achievement.Rewards)
+            {
+				if (reward.RewardType == Reward.Type.CARD && reward is CardRewardData cardRewardData)
+                    {
+                        TAG_CARD_SET cardSetFromCardID = GameUtils.GetCardSetFromCardID(cardRewardData.CardID);
+                        flag |= !GameDbf.GetIndex().GetCardSet(cardSetFromCardID).IsCoreCardSet;
+                    }
+                }
+            bool updateCacheValues = !flag;
+            QuestToast.ShowQuestToast(UserAttentionBlocker.NONE, ShowQuestToastCallback, updateCacheValues, achievement);
+            NarrativeManager.Get().OnQuestCompleteShown(achievement.ID);
+        }
+        else
+        {
+            achievement.AckCurrentProgressAndRewardNotices();
+			if (achievement.Rewards.Count > 0)
 			{
-				flag = true;
-				Entity hero = value.GetHero();
-				if (hero != null)
-				{
-					num2 = hero.GetCurrentDefense();
-					key = ((value.GetSide() != Player.Side.FRIENDLY) ? "GLOBAL_FRIENDLYCHALLENGE_REWARD_CONCEDED_YOUR_OPPONENT" : "GLOBAL_FRIENDLYCHALLENGE_REWARD_CONCEDED_YOURSELF");
-					break;
-				}
-			}
-		}
-		bool flag2 = concederMaxDefense > 0;
-		bool flag3 = !flag || (flag2 && num2 <= concederMaxDefense);
-		bool flag4 = !flag || gameState.GetTurn() >= num;
-		if (!flag3 && !flag4)
-		{
-			return GameStrings.Get(key);
-		}
-		return null;
-	}
-
-	protected void BackToMode(SceneMgr.Mode mode)
-	{
-		AchieveManager.Get().RemoveAchievesUpdatedListener(OnAchievesUpdated);
-		HideTwoScoop();
-		if (OnBackOutOfGameplay != null)
-		{
-			OnBackOutOfGameplay();
-		}
-		if (!m_hasAlreadySetMode)
-		{
-			m_hasAlreadySetMode = true;
-			StartCoroutine(ToMode(mode));
-			Navigation.Clear();
-		}
-	}
-
-	private IEnumerator ToMode(SceneMgr.Mode mode)
-	{
-		yield return new WaitForSeconds(0.5f);
-		SceneMgr.Get().SetNextMode(mode);
-	}
-
-	private void ReturnToPreviousMode()
-	{
-		SceneMgr.Mode mode = GameMgr.Get().GetPostGameSceneMode();
-		if (mode == SceneMgr.Mode.ADVENTURE && (!GameDownloadManagerProvider.Get().IsModuleReadyToPlay(DownloadTags.Content.Adventure) || !GameUtils.HasCompletedApprentice()))
-		{
-			mode = SceneMgr.Mode.HUB;
-		}
-		else if (mode == SceneMgr.Mode.BACON && !GameDownloadManagerProvider.Get().IsModuleReadyToPlay(DownloadTags.Content.Bgs))
-		{
-			mode = SceneMgr.Mode.HUB;
-		}
-		GameMgr.Get().PreparePostGameSceneMode(mode);
-		if (mode == SceneMgr.Mode.PVP_DUNGEON_RUN)
-		{
-			DuelsConfig.Get().SetLastGameResult(GameMgr.Get().LastGameData.GameResult);
-		}
-		BackToMode(mode);
-	}
-
-	private void ShowScoreScreen()
-	{
-		if (!GameState.Get().CanShowScoreScreen())
-		{
-			return;
-		}
-		m_scoreScreen = GameUtils.LoadGameObjectWithComponent<ScoreScreen>(m_ScoreScreenPrefab);
-		if ((bool)m_scoreScreen)
-		{
-			TransformUtil.AttachAndPreserveLocalTransform(m_scoreScreen.transform, base.transform);
-			LayerUtils.SetLayer(m_scoreScreen, GameLayer.IgnoreFullScreenEffects);
-			m_scoreScreen.Show();
-			m_showingScoreScreen = true;
-			SetPlayingBlockingAnim(set: true);
-			StartCoroutine(WaitThenSetPlayingBlockingAnim(0.65f, set: false));
-			if (Gameplay.Get().HasBattleNetFatalError())
-			{
-				m_hitbox.AddEventListener(UIEventType.RELEASE, ContinueButtonPress_ProceedToError);
-			}
-		}
-	}
-
-	private void HideScoreScreen()
-	{
-		if ((bool)m_scoreScreen)
-		{
-			m_scoreScreen.Hide();
-			m_showingScoreScreen = false;
-			SetPlayingBlockingAnim(set: true);
-			StartCoroutine(WaitThenSetPlayingBlockingAnim(0.25f, set: false));
-		}
-	}
-
-	protected void HideTwoScoop()
-	{
-		if (m_twoScoop.IsShown())
-		{
-			m_twoScoop.Hide();
-			m_noGoldRewardText.gameObject.SetActive(value: false);
-			OnTwoScoopHidden();
-			if (OnTwoScoopsShown != null)
-			{
-				OnTwoScoopsShown(shown: false, m_twoScoop);
-			}
-			if (InputManager.Get() != null)
-			{
-				InputManager.Get().EnableInput();
-			}
-		}
-	}
-
-	protected void ShowTwoScoop()
-	{
-		StartCoroutine(ShowTwoScoopWhenReady());
-	}
-
-	private IEnumerator ShowTwoScoopWhenReady()
-	{
-		while ((bool)m_scoreScreen)
-		{
-			SendTelemetryIfTimeout("ScoreScreen");
-			yield return null;
-		}
-		while (!m_twoScoop.IsLoaded())
-		{
-			SendTelemetryIfTimeout("TwoScoop");
-			yield return null;
-		}
-		while (JustEarnedHeroReward())
-		{
-			SendTelemetryIfTimeout("HeroReward");
-			if (m_heroRewardEventReady)
-			{
-				break;
-			}
-			yield return null;
-		}
-		m_twoScoop.Show();
-		if (!SpectatorManager.Get().IsSpectatingOrWatching && ShouldMakeUtilRequests())
-		{
-			InitGoldRewardUI();
-		}
-		OnTwoScoopShown();
-		m_haveShownTwoScoop = true;
-		if (OnTwoScoopsShown != null)
-		{
-			OnTwoScoopsShown(shown: true, m_twoScoop);
-		}
-	}
-
-	protected IEnumerator WaitThenSetPlayingBlockingAnim(float sec, bool set)
-	{
-		yield return new WaitForSeconds(sec);
-		SetPlayingBlockingAnim(set);
-	}
-
-	protected bool ShouldMakeUtilRequests()
-	{
-		if (!Network.ShouldBeConnectedToAurora())
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public bool IsDoneDisplayingRewards()
-	{
-		return m_doneDisplayingRewards;
-	}
-
-	private IEnumerator ShowStandardFlowIfReady()
-	{
-		while (!m_shown)
-		{
-			yield return null;
-		}
-		while (ShouldMakeUtilRequests() && !m_netCacheReady && SendTelemetryIfTimeout("m_netCacheReady"))
-		{
-			yield return null;
-		}
-		while (!m_achievesReady)
-		{
-			SendTelemetryIfTimeout("m_achievesReady");
-			yield return null;
-		}
-		while (!m_rewardsLoaded)
-		{
-			SendTelemetryIfTimeout("m_rewardsLoaded");
-			yield return null;
-		}
-		while (m_shouldShowRankChange && (!m_rankChangeReady || !m_medalInfoUpdated))
-		{
-			SendTelemetryIfTimeout($"m_rankChangeReady: {m_rankChangeReady} m_medalInfoUpdated: {m_medalInfoUpdated}");
-			yield return null;
-		}
-		while (m_shouldShowRankedCardBackProgress && m_rankedCardBackProgress == null)
-		{
-			SendTelemetryIfTimeout("m_rankedCardBackProgress");
-			yield return null;
-		}
-		while (m_shouldShowRewardXpGains && !RewardXpNotificationManager.Get().IsReady)
-		{
-			SendTelemetryIfTimeout("RewardXpNotificationManager.Get().IsReady");
-			yield return null;
-		}
-		SendRankedInitTelemetryIfNeeded();
-		ShowStandardFlow();
-	}
-
-	protected virtual void ShowStandardFlow()
-	{
-		ShowTwoScoop();
-		ShowRewardsXpGains();
-		if (!UniversalInputManager.UsePhoneUI)
-		{
-			m_continueText.gameObject.SetActive(value: true);
-		}
-	}
-
-	protected void ShowRewardsXpGains()
-	{
-		if (RewardXpNotificationManager.Get().HasXpGainsToShow)
-		{
-			m_shouldShowRewardXpGains = true;
-			RewardXpNotificationManager.Get().InitEndOfGameFlow(null);
-			RewardXpNotificationManager.Get().ShowRewardTrackXpGains(delegate
-			{
-				ContinueEvents();
-			}, justShowGameXp: true);
-		}
-	}
-
-	protected virtual void OnNetCacheReady()
-	{
-		m_netCacheReady = true;
-		NetCache.Get().UnregisterNetCacheHandler(OnNetCacheReady);
-		if (m_shouldShowRankChange)
-		{
-			RetryMedalInfoRequestIfNeeded();
-			LoadRankChange();
-			LoadRankedRewardDisplay();
-			LoadRankedCardBackProgress();
-		}
-		MaybeUpdateRewards();
-	}
-
-	private void RetryMedalInfoRequestIfNeeded()
-	{
-		if (IsMedalInfoRetryNeeded())
-		{
-			StartCoroutine(RetryMedalInfoRequest());
-			return;
-		}
-		NetCache.Get().RemoveUpdatedListener(typeof(NetCache.NetCacheMedalInfo), OnMedalInfoUpdate);
-		m_medalInfoUpdated = true;
-	}
-
-	private bool IsMedalInfoRetryNeeded()
-	{
-		if (!ShouldMakeUtilRequests())
-		{
-			return false;
-		}
-		if (!m_shouldShowRankChange)
-		{
-			return false;
-		}
-		if (m_medalInfoRetryCount >= 3)
-		{
-			return false;
-		}
-		FormatType formatType = Options.GetFormatType();
-		MedalInfoTranslator localPlayerMedalInfo = RankMgr.Get().GetLocalPlayerMedalInfo();
-		if (localPlayerMedalInfo != null)
-		{
-			return localPlayerMedalInfo.GetChangeType(formatType) == RankChangeType.NO_GAME_PLAYED;
-		}
-		return true;
-	}
-
-	private IEnumerator RetryMedalInfoRequest()
-	{
-		if (m_medalInfoRetryCount == 0)
-		{
-			m_medalInfoRetryDelay = 1f;
-			NetCache.Get().RegisterUpdatedListener(typeof(NetCache.NetCacheMedalInfo), OnMedalInfoUpdate);
-		}
-		else
-		{
-			m_medalInfoRetryDelay *= 2f;
-		}
-		m_medalInfoRetryCount++;
-		yield return new WaitForSeconds(m_medalInfoRetryDelay);
-		NetCache.Get().RefreshNetObject<NetCache.NetCacheMedalInfo>();
-	}
-
-	private void OnMedalInfoUpdate()
-	{
-		RetryMedalInfoRequestIfNeeded();
-	}
-
-	private void SendRankedInitTelemetryIfNeeded()
-	{
-		if (m_shouldShowRankChange && !m_hasSentRankedInitTelemetry)
-		{
-			m_hasSentRankedInitTelemetry = true;
-			float num = Time.time - m_endGameScreenStartTime;
-			FormatType formatType = Options.GetFormatType();
-			MedalInfoTranslator localPlayerMedalInfo = RankMgr.Get().GetLocalPlayerMedalInfo();
-			bool flag = m_medalInfoRetryCount >= 3 && (localPlayerMedalInfo == null || localPlayerMedalInfo.GetChangeType(formatType) == RankChangeType.NO_GAME_PLAYED);
-			if (flag && localPlayerMedalInfo != null)
-			{
-				Log.All.PrintError("EndGameScreen_MedalInfoTimeOut elapsedTime={0} retries={1} prev={2} curr={3}", num, m_medalInfoRetryCount, localPlayerMedalInfo.GetPreviousMedal(formatType).ToString(), localPlayerMedalInfo.GetCurrentMedal(formatType).ToString());
-			}
-			bool showRankedReward = m_rankedRewardsToDisplay.Count > 0;
-			TelemetryManager.Client().SendEndGameScreenInit(num, m_medalInfoRetryCount, flag, showRankedReward, m_shouldShowRankedCardBackProgress, m_rewards.Count);
-		}
-	}
-
-	private void LoadRankChange()
-	{
-		AssetReference rANK_CHANGE_TWO_SCOOP_PREFAB_NEW = RankMgr.RANK_CHANGE_TWO_SCOOP_PREFAB_NEW;
-		AssetLoader.Get().InstantiatePrefab(rANK_CHANGE_TWO_SCOOP_PREFAB_NEW, OnRankChangeLoaded);
-	}
-
-	private void OnRankChangeLoaded(AssetReference assetRef, GameObject go, object callbackData)
-	{
-		m_rankChangeTwoScoop = go;
-		m_rankChangeTwoScoop.gameObject.SetActive(value: false);
-		m_rankChangeReady = true;
-	}
-
-	private void OnRankChangeClosed()
-	{
-		m_isShowingRankChange = false;
-		m_shouldShowRankChange = false;
-		ContinueEvents();
-	}
-
-	private void LoadRankedRewardDisplay()
-	{
-		if (RankMgr.Get().GetLocalPlayerMedalInfo().GetRankedRewardsEarned(Options.GetFormatType(), ref m_rankedRewardsToDisplay) && m_rankedRewardsToDisplay.Count != 0)
-		{
-			m_rankedRewardDisplayWidget = WidgetInstance.Create(RankMgr.RANKED_REWARD_DISPLAY_PREFAB);
-			m_rankedRewardDisplayWidget.RegisterReadyListener(delegate
-			{
-				OnRankedRewardDisplayWidgetReady();
-			});
-		}
-	}
-
-	private void OnRankedRewardDisplayWidgetReady()
-	{
-		m_rankedRewardDisplay = m_rankedRewardDisplayWidget.GetComponentInChildren<RankedRewardDisplay>();
-	}
-
-	private void LoadRankedCardBackProgress()
-	{
-		m_shouldShowRankedCardBackProgress = RankMgr.Get().GetLocalPlayerMedalInfo().ShouldShowCardBackProgress();
-		if (m_shouldShowRankedCardBackProgress)
-		{
-			m_rankedCardBackProgressWidget = WidgetInstance.Create(RankMgr.RANKED_CARDBACK_PROGRESS_DISPLAY_PREFAB);
-			m_rankedCardBackProgressWidget.RegisterReadyListener(delegate
-			{
-				OnRankedCardBackProgressWidgetReady();
-			});
-		}
-	}
-
-	private void OnRankedCardBackProgressWidgetReady()
-	{
-		m_rankedCardBackProgress = m_rankedCardBackProgressWidget.GetComponentInChildren<RankedCardBackProgressDisplay>();
-	}
-
-	private IEnumerator WaitForAchieveManager()
-	{
-		while (!AchieveManager.Get().IsReady())
-		{
-			yield return null;
-		}
-		m_achievesReady = true;
-		MaybeUpdateRewards();
-	}
-
-	private void ProcessPreviousAchievements()
-	{
-		OnAchievesUpdated(new List<Achievement>(), new List<Achievement>(), null);
-	}
-
-	private void OnAchievesUpdated(List<Achievement> updatedAchieves, List<Achievement> completedAchieves, object userData)
-	{
-		List<Achievement> newCompletedAchievesToShow = AchieveManager.Get().GetNewCompletedAchievesToShow();
-		bool flag = PopupDisplayManager.ShouldSuppressPopups();
-		foreach (Achievement achieve in newCompletedAchievesToShow)
-		{
-			if ((!flag || achieve.Mode == Achieve.GameMode.MERCENARIES) && achieve.RewardTiming == Achieve.RewardTiming.IMMEDIATE && string.IsNullOrWhiteSpace(achieve.CustomVisualWidget) && m_completedQuests.Find((Achievement obj) => achieve.ID == obj.ID) == null)
-			{
-				m_completedQuests.Add(achieve);
-			}
-		}
-	}
-
-	private void OnGenericRewardUpdated(long rewardNoticeId, object userData)
-	{
-		m_genericRewardChestNoticeIdsReady.Add(rewardNoticeId);
-		UpdateRewards();
-	}
-
-	protected bool HasShownScoops()
-	{
-		return m_haveShownTwoScoop;
-	}
-
-	protected void SetHeroRewardEventReady(bool isReady)
-	{
-		m_heroRewardEventReady = isReady;
-	}
-
-	private void MaybeUpdateRewards()
-	{
-		if (m_achievesReady && m_netCacheReady)
-		{
-			UpdateRewards();
-		}
-	}
-
-	private void LoadRewards(List<RewardData> rewardsToLoad, Reward.DelOnRewardLoaded callback)
-	{
-		if (rewardsToLoad == null)
-		{
-			return;
-		}
-		foreach (RewardData item in rewardsToLoad)
-		{
-			if (PopupDisplayManager.Get().RewardPopups.UpdateNoticesSeen(item))
-			{
-				m_numRewardsToLoad++;
-				item.LoadRewardObject(callback);
-			}
-		}
-	}
-
-	private void UpdateRewards()
-	{
-		GameMgr gameMgr = GameMgr.Get();
-		if (gameMgr == null)
-		{
-			Log.All.PrintError("EndGameScreen::UpdateRewards GameMgr object is null.");
-			return;
-		}
-		bool flag = true;
-		if (gameMgr.IsTraditionalTutorial())
-		{
-			flag = GameUtils.IsTraditionalTutorialComplete();
-		}
-		List<RewardData> rewardsToShow = null;
-		List<RewardData> genericRewardChestsToShow = null;
-		List<RewardData> purchasedCardRewardsToShow = null;
-		if (flag)
-		{
-			if (NetCache.Get() == null)
-			{
-				Log.All.PrintError("EndGameScreen::UpdateRewards NetCache object is null.");
-				return;
-			}
-			List<NetCache.ProfileNotice> list = NetCache.Get().GetNetObject<NetCache.NetCacheProfileNotices>().Notices.Where((NetCache.ProfileNotice n) => n.Type != NetCache.ProfileNotice.NoticeType.GENERIC_REWARD_CHEST || m_genericRewardChestNoticeIdsReady.Any((long r) => n.NoticeID == r)).ToList();
-			list.RemoveAll((NetCache.ProfileNotice n) => n.Origin == NetCache.ProfileNotice.NoticeOrigin.NOTICE_ORIGIN_DUELS);
-			List<RewardData> rewards = RewardUtils.GetRewards(list);
-			HashSet<Achieve.RewardTiming> rewardTimings = new HashSet<Achieve.RewardTiming> { Achieve.RewardTiming.IMMEDIATE };
-			RewardUtils.GetViewableRewards(rewards, rewardTimings, out rewardsToShow, out genericRewardChestsToShow, ref purchasedCardRewardsToShow, ref m_completedQuests);
-		}
-		else
-		{
-			rewardsToShow = new List<RewardData>();
-		}
-		JustEarnedHeroReward();
-		if (!gameMgr.IsSpectator())
-		{
-			GameState gameState = GameState.Get();
-			if (gameState != null)
-			{
-				GameEntity gameEntity = gameState.GetGameEntity();
-				if (gameEntity != null)
-				{
-					List<RewardData> customRewards = gameEntity.GetCustomRewards();
-					if (customRewards != null)
-					{
-						rewardsToShow.AddRange(customRewards);
-					}
-				}
-			}
-		}
-		LoadRewards(rewardsToShow, OnRewardObjectLoaded);
-		LoadRewards(genericRewardChestsToShow, OnGenericRewardObjectLoaded);
-		if (m_numRewardsToLoad == 0)
-		{
-			m_rewardsLoaded = true;
-		}
-	}
-
-	private void OnRewardObjectLoaded(Reward reward, object callbackData)
-	{
-		LoadReward(reward, ref m_rewards);
-	}
-
-	private void OnGenericRewardObjectLoaded(Reward reward, object callbackData)
-	{
-		LoadReward(reward, ref m_genericRewards);
-	}
-
-	private void PositionReward(Reward reward)
-	{
-		reward.transform.parent = base.transform;
-		reward.transform.localRotation = Quaternion.identity;
-		reward.transform.localPosition = PopupDisplayManager.Get().RewardPopups.GetRewardLocalPos();
-	}
-
-	private void LoadReward(Reward reward, ref List<Reward> allRewards)
-	{
-		reward.Hide();
-		PositionReward(reward);
-		allRewards.Add(reward);
-		m_numRewardsToLoad--;
-		if (m_numRewardsToLoad <= 0)
-		{
-			RewardUtils.SortRewards(ref allRewards);
-			m_rewardsLoaded = true;
-		}
-	}
-
-	private void DisplayLoadedRewardObject(Reward reward, object callbackData)
-	{
-		if (m_currentlyShowingReward != null)
-		{
-			m_currentlyShowingReward.Hide(animate: true);
-			m_currentlyShowingReward = null;
-		}
-		reward.Hide();
-		PositionReward(reward);
-		m_currentlyShowingReward = reward;
-		SetPlayingBlockingAnim(set: true);
-		LayerUtils.SetLayer(m_currentlyShowingReward.gameObject, GameLayer.IgnoreFullScreenEffects);
-		ShowReward(m_currentlyShowingReward);
-	}
-
-	private void ShowReward(Reward reward)
-	{
-		bool updateCacheValues = !(reward is CardReward);
-		RewardUtils.ShowReward(UserAttentionBlocker.NONE, reward, updateCacheValues, PopupDisplayManager.Get().RewardPopups.GetRewardPunchScale(), PopupDisplayManager.Get().RewardPopups.GetRewardScale());
-		StartCoroutine(WaitThenSetPlayingBlockingAnim(0.35f, set: false));
-	}
-
-	protected virtual bool ShowHeroRewardEvent()
-	{
-		return false;
-	}
-
-	protected bool ShowFixedRewards()
-	{
-		if (m_isShowingFixedRewards)
-		{
-			return true;
-		}
-		if (PopupDisplayManager.SuppressPopupsTemporarily)
-		{
-			return false;
-		}
-		HashSet<Achieve.RewardTiming> rewardVisualTimings = new HashSet<Achieve.RewardTiming> { Achieve.RewardTiming.IMMEDIATE };
-		FixedRewardsMgr.DelOnAllFixedRewardsShown allRewardsShownCallback = delegate
-		{
-			m_isShowingFixedRewards = false;
-			ContinueEvents();
-		};
-		m_isShowingFixedRewards = FixedRewardsMgr.Get().ShowFixedRewards(UserAttentionBlocker.NONE, rewardVisualTimings, allRewardsShownCallback, null);
-		return m_isShowingFixedRewards;
-	}
-
-	private bool ShowGoldReward()
-	{
-		int num = m_rewards.FindIndex((Reward reward) => reward.Data is GoldRewardData { Origin: NetCache.ProfileNotice.NoticeOrigin.TOURNEY });
-		if (num < 0)
-		{
-			return false;
-		}
-		Reward item = m_rewards[num];
-		m_rewards.RemoveAt(num);
-		m_rewards.Insert(0, item);
-		ShowNextReward();
-		return true;
-	}
-
-	private bool ShowNextProgressionQuestReward()
-	{
-		if (!QuestManager.Get().ShowNextReward(delegate
-		{
-			ContinueEvents();
-		}))
-		{
-			return false;
-		}
-		return true;
-	}
-
-	protected bool ShowNextCompletedQuest()
-	{
-		if (m_completedQuests.Count == 0)
-		{
-			return false;
-		}
-		if (QuestToast.IsQuestActive())
-		{
-			QuestToast.GetCurrentToast().CloseQuestToast();
-		}
-		Achievement achievement = m_completedQuests[0];
-		m_completedQuests.RemoveAt(0);
-		while (!string.IsNullOrEmpty(achievement.CustomVisualWidget))
-		{
-			if (m_completedQuests.Count == 0)
-			{
-				return false;
-			}
-			achievement = m_completedQuests[0];
-			m_completedQuests.RemoveAt(0);
-		}
-		if (!achievement.UseGenericRewardVisual)
-		{
-			bool flag = false;
-			foreach (RewardData reward in achievement.Rewards)
-			{
-				if (reward.RewardType == Reward.Type.CARD && reward is CardRewardData cardRewardData)
-				{
-					TAG_CARD_SET cardSetFromCardID = GameUtils.GetCardSetFromCardID(cardRewardData.CardID);
-					flag |= !GameDbf.GetIndex().GetCardSet(cardSetFromCardID).IsCoreCardSet;
-				}
-			}
-			bool updateCacheValues = !flag;
-			QuestToast.ShowQuestToast(UserAttentionBlocker.NONE, ShowQuestToastCallback, updateCacheValues, achievement);
-			NarrativeManager.Get().OnQuestCompleteShown(achievement.ID);
-		}
-		else
-		{
-			achievement.AckCurrentProgressAndRewardNotices();
-			if (achievement.Rewards.Count > 0)
-			{
-				achievement.Rewards[0].LoadRewardObject(DisplayLoadedRewardObject);
-			}
-		}
-		return true;
-	}
-
-	protected void ShowQuestToastCallback(object userData)
-	{
-		if (!(this == null))
-		{
-			ContinueEvents();
-		}
-	}
-
-	protected bool ShowRewardTrackXpGains()
-	{
-		RewardXpNotificationManager rewardXpNotificationManager = RewardXpNotificationManager.Get();
-		if (rewardXpNotificationManager.IsShowingXpGains && !rewardXpNotificationManager.JustShowGameXp)
-		{
-			rewardXpNotificationManager.TerminateEarly();
-			return false;
-		}
-		if (!rewardXpNotificationManager.HasXpGainsToShow && !rewardXpNotificationManager.JustShowGameXp)
-		{
-			return false;
-		}
-		if (rewardXpNotificationManager.IsShowingXpGains && rewardXpNotificationManager.JustShowGameXp)
-		{
-			rewardXpNotificationManager.ContinueNotifications();
-		}
-		else
-		{
-			rewardXpNotificationManager.ShowRewardTrackXpGains(delegate
-			{
-				ContinueEvents();
-			});
-		}
-		return true;
-	}
-
-	protected bool ShowNextRewardTrackAutoClaimedReward()
-	{
-		if (m_isShowingTrackRewards)
-		{
-			return true;
-		}
-		Action callback = delegate
-		{
-			m_isShowingTrackRewards = false;
-			ContinueEvents();
-		};
-		if (!RewardTrackManager.Get().ShowNextReward(callback))
-		{
-			return false;
-		}
-		m_isShowingTrackRewards = true;
-		return true;
-	}
-
-	protected bool ShowNextReward()
-	{
-		if (m_rewards.Count == 0)
-		{
-			return false;
-		}
-		SetPlayingBlockingAnim(set: true);
-		m_currentlyShowingReward = m_rewards[0];
-		m_rewards.RemoveAt(0);
-		ShowReward(m_currentlyShowingReward);
-		return true;
-	}
-
-	protected bool ShowNextGenericReward()
-	{
-		if (m_genericRewards.Count == 0)
-		{
-			return false;
-		}
-		SetPlayingBlockingAnim(set: true);
-		m_currentlyShowingReward = m_genericRewards[0];
-		m_genericRewards.RemoveAt(0);
-		QuestToast.ShowGenericRewardQuestToast(UserAttentionBlocker.NONE, ShowQuestToastCallback, m_currentlyShowingReward.Data, m_currentlyShowingReward.Data.NameOverride, m_currentlyShowingReward.Data.DescriptionOverride);
-		StartCoroutine(WaitThenSetPlayingBlockingAnim(0.35f, set: false));
-		return true;
-	}
-
-	private bool ShowRankChange()
-	{
-		if (!m_shouldShowRankChange)
-		{
-			return false;
-		}
-		if (m_isShowingRankChange)
-		{
-			return true;
-		}
-		m_rankChangeTwoScoop.gameObject.SetActive(value: true);
-		RankChangeTwoScoop_NEW component = m_rankChangeTwoScoop.GetComponent<RankChangeTwoScoop_NEW>();
-		component.Initialize(RankMgr.Get().GetLocalPlayerMedalInfo(), Options.GetFormatType(), OnRankChangeClosed);
-		component.Show();
-		m_isShowingRankChange = true;
-		return true;
-	}
-
-	private bool ShowRankedRewards()
-	{
-		if (m_rankedRewardsToDisplay.Count == 0)
-		{
-			return false;
-		}
-		if (m_isShowingRankedReward)
-		{
-			return true;
-		}
-		m_isShowingRankedReward = true;
-		FormatType formatType = Options.GetFormatType();
-		TranslatedMedalInfo currentMedal = RankMgr.Get().GetLocalPlayerMedalInfo().GetCurrentMedal(formatType);
-		m_rankedRewardDisplay.Initialize(currentMedal, m_rankedRewardsToDisplay, OnRankedRewardsClosed);
-		m_rankedRewardDisplay.Show();
-		return true;
-	}
-
-	private void OnRankedRewardsClosed()
-	{
-		m_isShowingRankedReward = false;
-		m_rankedRewardsToDisplay.Clear();
-		UnityEngine.Object.Destroy(m_rankedRewardDisplayWidget.gameObject);
-		ContinueEvents();
-	}
-
-	private bool ShowRankedCardBackProgress()
-	{
-		if (!m_shouldShowRankedCardBackProgress)
-		{
-			return false;
-		}
-		if (m_isShowingRankedCardBackProgress)
-		{
-			return true;
-		}
-		m_isShowingRankedCardBackProgress = true;
-		m_rankedCardBackProgress.Initialize(RankMgr.Get().GetLocalPlayerMedalInfo(), OnRankedCardBackProgressClosed);
-		m_rankedCardBackProgress.Show();
-		return true;
-	}
-
-	private void OnRankedCardBackProgressClosed()
-	{
-		m_shouldShowRankedCardBackProgress = false;
-		m_isShowingRankedCardBackProgress = false;
-		UnityEngine.Object.Destroy(m_rankedCardBackProgressWidget.gameObject);
-		if (FindRankedCardBackRewardAndMakeNext())
-		{
-			ShowNextReward();
-		}
-		else
-		{
-			ContinueEvents();
-		}
-	}
-
-	private bool FindRankedCardBackRewardAndMakeNext()
-	{
-		int currentSeasonId = RankMgr.Get().GetLocalPlayerMedalInfo().GetCurrentSeasonId();
-		int rankedCardBackId = RankMgr.Get().GetRankedCardBackIdForSeasonId(currentSeasonId);
-		int num = m_rewards.FindIndex((Reward reward) => (reward.Data is CardBackRewardData cardBackRewardData && cardBackRewardData.CardBackID == rankedCardBackId) ? true : false);
-		if (num < 0)
-		{
-			return false;
-		}
-		Reward item = m_rewards[num];
-		m_rewards.RemoveAt(num);
-		m_rewards.Insert(0, item);
-		return true;
-	}
-
-	protected virtual bool JustEarnedHeroReward()
-	{
-		return false;
-	}
-
-	protected virtual bool ShowHealUpDialog()
-	{
-		return false;
-	}
-
-	protected virtual bool ShowPushNotificationPrompt()
-	{
-		return false;
-	}
+            achievement.Rewards[0].LoadRewardObject(DisplayLoadedRewardObject);
+        }
+		}
+        return true;
+    }
+
+    protected void ShowQuestToastCallback(object userData)
+    {
+        if (!(this == null))
+        {
+            ContinueEvents();
+        }
+    }
+
+    protected bool ShowRewardTrackXpGains()
+    {
+        RewardXpNotificationManager rewardXpNotificationManager = RewardXpNotificationManager.Get();
+        if (rewardXpNotificationManager.IsShowingXpGains && !rewardXpNotificationManager.JustShowGameXp)
+        {
+            rewardXpNotificationManager.TerminateEarly();
+            return false;
+        }
+        if (!rewardXpNotificationManager.HasXpGainsToShow && !rewardXpNotificationManager.JustShowGameXp)
+        {
+            return false;
+        }
+        if (rewardXpNotificationManager.IsShowingXpGains && rewardXpNotificationManager.JustShowGameXp)
+        {
+            rewardXpNotificationManager.ContinueNotifications();
+        }
+        else
+        {
+            rewardXpNotificationManager.ShowRewardTrackXpGains(delegate
+            {
+                ContinueEvents();
+            });
+        }
+        return true;
+    }
+
+    protected bool ShowNextRewardTrackAutoClaimedReward()
+    {
+        if (m_isShowingTrackRewards)
+        {
+            return true;
+        }
+        Action callback = delegate
+        {
+            m_isShowingTrackRewards = false;
+            ContinueEvents();
+        };
+        if (!RewardTrackManager.Get().ShowNextReward(callback))
+        {
+            return false;
+        }
+        m_isShowingTrackRewards = true;
+        return true;
+    }
+
+    protected bool ShowNextReward()
+    {
+        if (m_rewards.Count == 0)
+        {
+            return false;
+        }
+        SetPlayingBlockingAnim(set: true);
+        m_currentlyShowingReward = m_rewards[0];
+        m_rewards.RemoveAt(0);
+        ShowReward(m_currentlyShowingReward);
+        return true;
+    }
+
+    protected bool ShowNextGenericReward()
+    {
+        if (m_genericRewards.Count == 0)
+        {
+            return false;
+        }
+        SetPlayingBlockingAnim(set: true);
+        m_currentlyShowingReward = m_genericRewards[0];
+        m_genericRewards.RemoveAt(0);
+        QuestToast.ShowGenericRewardQuestToast(UserAttentionBlocker.NONE, ShowQuestToastCallback, m_currentlyShowingReward.Data, m_currentlyShowingReward.Data.NameOverride, m_currentlyShowingReward.Data.DescriptionOverride);
+        StartCoroutine(WaitThenSetPlayingBlockingAnim(0.35f, set: false));
+        return true;
+    }
+
+    private bool ShowRankChange()
+    {
+        if (!m_shouldShowRankChange)
+        {
+            return false;
+        }
+        if (m_isShowingRankChange)
+        {
+            return true;
+        }
+        m_rankChangeTwoScoop.gameObject.SetActive(value: true);
+        RankChangeTwoScoop_NEW component = m_rankChangeTwoScoop.GetComponent<RankChangeTwoScoop_NEW>();
+        component.Initialize(RankMgr.Get().GetLocalPlayerMedalInfo(), Options.GetFormatType(), OnRankChangeClosed);
+        component.Show();
+        m_isShowingRankChange = true;
+        return true;
+    }
+
+    private bool ShowRankedRewards()
+    {
+        if (m_rankedRewardsToDisplay.Count == 0)
+        {
+            return false;
+        }
+        if (m_isShowingRankedReward)
+        {
+            return true;
+        }
+        m_isShowingRankedReward = true;
+        FormatType formatType = Options.GetFormatType();
+        TranslatedMedalInfo currentMedal = RankMgr.Get().GetLocalPlayerMedalInfo().GetCurrentMedal(formatType);
+        m_rankedRewardDisplay.Initialize(currentMedal, m_rankedRewardsToDisplay, OnRankedRewardsClosed);
+        m_rankedRewardDisplay.Show();
+        return true;
+    }
+
+    private void OnRankedRewardsClosed()
+    {
+        m_isShowingRankedReward = false;
+        m_rankedRewardsToDisplay.Clear();
+        UnityEngine.Object.Destroy(m_rankedRewardDisplayWidget.gameObject);
+        ContinueEvents();
+    }
+
+    private bool ShowRankedCardBackProgress()
+    {
+        if (!m_shouldShowRankedCardBackProgress)
+        {
+            return false;
+        }
+        if (m_isShowingRankedCardBackProgress)
+        {
+            return true;
+        }
+        m_isShowingRankedCardBackProgress = true;
+        m_rankedCardBackProgress.Initialize(RankMgr.Get().GetLocalPlayerMedalInfo(), OnRankedCardBackProgressClosed);
+        m_rankedCardBackProgress.Show();
+        return true;
+    }
+
+    private void OnRankedCardBackProgressClosed()
+    {
+        m_shouldShowRankedCardBackProgress = false;
+        m_isShowingRankedCardBackProgress = false;
+        UnityEngine.Object.Destroy(m_rankedCardBackProgressWidget.gameObject);
+        if (FindRankedCardBackRewardAndMakeNext())
+        {
+            ShowNextReward();
+        }
+        else
+        {
+            ContinueEvents();
+        }
+    }
+
+    private bool FindRankedCardBackRewardAndMakeNext()
+    {
+        int currentSeasonId = RankMgr.Get().GetLocalPlayerMedalInfo().GetCurrentSeasonId();
+        int rankedCardBackId = RankMgr.Get().GetRankedCardBackIdForSeasonId(currentSeasonId);
+		int num = m_rewards.FindIndex((Reward reward) => (reward.Data is CardBackRewardData cardBackRewardData && cardBackRewardData.CardBackID == rankedCardBackId) ? true : false);
+        if (num < 0)
+        {
+            return false;
+        }
+        Reward item = m_rewards[num];
+        m_rewards.RemoveAt(num);
+        m_rewards.Insert(0, item);
+        return true;
+    }
+
+    protected virtual bool JustEarnedHeroReward()
+    {
+        return false;
+    }
+
+    protected virtual bool ShowHealUpDialog()
+    {
+        return false;
+    }
+
+    protected virtual bool ShowPushNotificationPrompt()
+    {
+        return false;
+    }
 
 	protected virtual void ShowAppRatingPrompt()
-	{
-	}
-
-	protected bool ShowMercenariesExperienceRewards()
-	{
-		if (m_isShowingMercenariesExperienceRewards)
-		{
-			return true;
-		}
-		if (m_finishedShowingMercenariesExperienceRewards)
-		{
-			return false;
-		}
-		LettuceMissionEntity lettuceMissionEntity = null;
-		if (GameState.Get().GetGameEntity() is LettuceMissionEntity)
-		{
-			lettuceMissionEntity = (LettuceMissionEntity)GameState.Get().GetGameEntity();
-			List<MercenaryExpRewardData> list = new List<MercenaryExpRewardData>();
-			foreach (MercenariesExperienceUpdate mercenaryExperienceUpdate in lettuceMissionEntity.GetMercenaryExperienceUpdates())
-			{
-				if (mercenaryExperienceUpdate.PreExp != mercenaryExperienceUpdate.PostExp)
-				{
-					MercenaryExpRewardData item = new MercenaryExpRewardData(mercenaryExperienceUpdate.MercenaryId, (int)mercenaryExperienceUpdate.PreExp, (int)mercenaryExperienceUpdate.PostExp, (int)mercenaryExperienceUpdate.ExpDelta);
-					list.Add(item);
-				}
-			}
-			if (list.Count == 0)
-			{
-				m_finishedShowingMercenariesExperienceRewards = true;
-				return false;
-			}
-			list = list.OrderByDescending((MercenaryExpRewardData r) => r.NumberOfLevelUps).ToList();
-			AssetLoader.Get().InstantiatePrefab("MercenariesExperienceTwoScoop.prefab:eb825692c63590b4d8a76def17e8aa3a", OnMercenariesExperienceTwoScoopLoaded, list);
-			m_isShowingMercenariesExperienceRewards = true;
-			return true;
-		}
-		m_finishedShowingMercenariesExperienceRewards = true;
-		return false;
-	}
-
-	private void OnMercenariesExperienceTwoScoopLoaded(AssetReference assetRef, GameObject go, object callbackData)
-	{
-		if (go == null)
-		{
-			Log.Lettuce.PrintError("Failed to load Mercenaries Experience Two Scoop.");
-			m_isShowingMercenariesExperienceRewards = false;
-			m_finishedShowingMercenariesExperienceRewards = true;
-			return;
-		}
-		MercenariesExperienceTwoScoop component = go.GetComponent<MercenariesExperienceTwoScoop>();
-		if (component == null)
-		{
-			Log.Lettuce.PrintError("MercenariesExperienceTwoScoop game object had no script attached!");
-			m_isShowingMercenariesExperienceRewards = false;
-			m_finishedShowingMercenariesExperienceRewards = true;
-		}
-		else
-		{
-			List<MercenaryExpRewardData> mercenaryExpRewards = (List<MercenaryExpRewardData>)callbackData;
-			component.Initialize(mercenaryExpRewards, OnMercenariesExperienceTwoScoopClosed);
-		}
-	}
-
-	private void OnMercenariesExperienceTwoScoopClosed()
-	{
-		m_isShowingMercenariesExperienceRewards = false;
-		m_finishedShowingMercenariesExperienceRewards = true;
-		ContinueEvents();
-	}
-
-	private bool SendTelemetryIfTimeout(string culprit)
-	{
-		if (m_hasTimedOutAndLogged)
-		{
-			return false;
-		}
-		if (m_timeoutTimerStartTime == 0f)
-		{
+    {
+    }
+
+    protected bool ShowMercenariesExperienceRewards()
+    {
+        if (m_isShowingMercenariesExperienceRewards)
+        {
+            return true;
+        }
+        if (m_finishedShowingMercenariesExperienceRewards)
+        {
+            return false;
+        }
+        LettuceMissionEntity lettuceMissionEntity = null;
+        if (GameState.Get().GetGameEntity() is LettuceMissionEntity)
+        {
+            lettuceMissionEntity = (LettuceMissionEntity)GameState.Get().GetGameEntity();
+            List<MercenaryExpRewardData> list = new List<MercenaryExpRewardData>();
+            foreach (MercenariesExperienceUpdate mercenaryExperienceUpdate in lettuceMissionEntity.GetMercenaryExperienceUpdates())
+            {
+                if (mercenaryExperienceUpdate.PreExp != mercenaryExperienceUpdate.PostExp)
+                {
+                    MercenaryExpRewardData item = new MercenaryExpRewardData(mercenaryExperienceUpdate.MercenaryId, (int)mercenaryExperienceUpdate.PreExp, (int)mercenaryExperienceUpdate.PostExp, (int)mercenaryExperienceUpdate.ExpDelta);
+                    list.Add(item);
+                }
+            }
+            if (list.Count == 0)
+            {
+                m_finishedShowingMercenariesExperienceRewards = true;
+                return false;
+            }
+            list = list.OrderByDescending((MercenaryExpRewardData r) => r.NumberOfLevelUps).ToList();
+            AssetLoader.Get().InstantiatePrefab("MercenariesExperienceTwoScoop.prefab:eb825692c63590b4d8a76def17e8aa3a", OnMercenariesExperienceTwoScoopLoaded, list);
+            m_isShowingMercenariesExperienceRewards = true;
+            return true;
+        }
+        m_finishedShowingMercenariesExperienceRewards = true;
+        return false;
+    }
+
+    private void OnMercenariesExperienceTwoScoopLoaded(AssetReference assetRef, GameObject go, object callbackData)
+    {
+        if (go == null)
+        {
+            Log.Lettuce.PrintError("Failed to load Mercenaries Experience Two Scoop.");
+            m_isShowingMercenariesExperienceRewards = false;
+            m_finishedShowingMercenariesExperienceRewards = true;
+            return;
+        }
+        MercenariesExperienceTwoScoop component = go.GetComponent<MercenariesExperienceTwoScoop>();
+        if (component == null)
+        {
+            Log.Lettuce.PrintError("MercenariesExperienceTwoScoop game object had no script attached!");
+            m_isShowingMercenariesExperienceRewards = false;
+            m_finishedShowingMercenariesExperienceRewards = true;
+        }
+        else
+        {
+            List<MercenaryExpRewardData> mercenaryExpRewards = (List<MercenaryExpRewardData>)callbackData;
+            component.Initialize(mercenaryExpRewards, OnMercenariesExperienceTwoScoopClosed);
+        }
+    }
+
+    private void OnMercenariesExperienceTwoScoopClosed()
+    {
+        m_isShowingMercenariesExperienceRewards = false;
+        m_finishedShowingMercenariesExperienceRewards = true;
+        ContinueEvents();
+    }
+
+    private bool SendTelemetryIfTimeout(string culprit)
+    {
+        if (m_hasTimedOutAndLogged)
+        {
+            return false;
+        }
+        if (m_timeoutTimerStartTime == 0f)
+        {
 			m_timeoutTimerStartTime = Time.time;
-		}
+        }
 		float num = Time.time - m_timeoutTimerStartTime;
-		if (num >= 5f)
-		{
+        if (num >= 5f)
+        {
 			TelemetryManager.Client().SendLiveIssue("EndGameScreen_NetCacheReadyTimeout", "Timeout occurred when waiting for " + culprit + " to be ready, " + $"time elapsed: {num} while waiting for {culprit}.");
 			Log.All.PrintError("Timeout occurred when waiting for " + culprit + " to be ready, " + $"time elapsed: {num} while waiting for {culprit}.");
-			m_hasTimedOutAndLogged = true;
-			return false;
-		}
-		return true;
-	}
+            m_hasTimedOutAndLogged = true;
+            return false;
+        }
+        return true;
+    }
 }
diff --git a/Assembly-CSharp/EndGameTwoScoop.cs b/Assembly-CSharp/EndGameTwoScoop.cs
index 8c0d751..276213c 100644
--- a/Assembly-CSharp/EndGameTwoScoop.cs
+++ b/Assembly-CSharp/EndGameTwoScoop.cs
@@ -1,51 +1,52 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class EndGameTwoScoop : MonoBehaviour
 {
-	public UberText m_bannerLabel;
+    public UberText m_bannerLabel;
 
-	public GameObject m_heroBone;
+    public GameObject m_heroBone;
 
 	public GameObject m_duoHeroBone;
 
 	public GameObject m_duoTeammateHeroBone;
 
-	public Actor m_heroActor;
+    public Actor m_heroActor;
 
 	public Actor m_teammateHeroActor;
 
-	public HeroXPBar m_xpBarPrefab;
+    public HeroXPBar m_xpBarPrefab;
 
 	public Vector3 m_xpBarLocalScale = new Vector3(0.9064f, 0.9064f, 0.9064f);
 
 	public Vector3 m_xpBarLocalPosition = new Vector3(-0.166f, 0.224f, -0.738f);
 
-	public GameObject m_levelUpTier1;
+    public GameObject m_levelUpTier1;
 
-	public GameObject m_levelUpTier2;
+    public GameObject m_levelUpTier2;
 
-	public GameObject m_levelUpTier3;
+    public GameObject m_levelUpTier3;
 
-	protected bool m_heroActorLoaded;
+    protected bool m_heroActorLoaded;
 
-	protected HeroXPBar m_xpBar;
+    protected HeroXPBar m_xpBar;
 
-	private bool m_isShown;
+    private bool m_isShown;
 
-	private static readonly float AFTER_PUNCH_SCALE_VAL = 2.3f;
+    private static readonly float AFTER_PUNCH_SCALE_VAL = 2.3f;
 
-	protected static readonly float START_SCALE_VAL = 0.01f;
+    protected static readonly float START_SCALE_VAL = 0.01f;
 
-	protected static readonly float END_SCALE_VAL = 2.5f;
+    protected static readonly float END_SCALE_VAL = 2.5f;
 
-	protected static readonly Vector3 START_POSITION = new Vector3(-7.8f, 8.2f, -5f);
+    protected static readonly Vector3 START_POSITION = new Vector3(-7.8f, 8.2f, -5f);
 
-	protected static readonly float BAR_ANIMATION_DELAY = 1f;
+    protected static readonly float BAR_ANIMATION_DELAY = 1f;
 
-	public virtual void Awake()
-	{
-		base.gameObject.SetActive(value: false);
+    public virtual void Awake()
+    {
+        base.gameObject.SetActive(value: false);
 		GameObject callbackData = m_heroBone;
 		if (GameMgr.Get().IsBattlegroundDuoGame())
 		{
@@ -53,160 +54,165 @@ public class EndGameTwoScoop : MonoBehaviour
 			AssetLoader.Get().InstantiatePrefab(GetActorName(), OnTeammateHeroActorLoaded, m_duoTeammateHeroBone, AssetLoadingOptions.IgnorePrefabPosition);
 		}
 		AssetLoader.Get().InstantiatePrefab(GetActorName(), OnHeroActorLoaded, callbackData, AssetLoadingOptions.IgnorePrefabPosition);
-	}
-
-	public virtual void OnDestroy()
-	{
-	}
-
-	private void Start()
-	{
-		LayerUtils.SetLayer(base.gameObject, GameLayer.IgnoreFullScreenEffects);
-		ResetPositions();
-	}
-
-	public bool IsShown()
-	{
-		return m_isShown;
-	}
-
-	public void Show(bool showXPBar = true)
-	{
-		m_isShown = true;
-		base.gameObject.SetActive(value: true);
-		ShowImpl();
-		if (!showXPBar || GameMgr.Get().IsTraditionalTutorial() || GameMgr.Get().IsSpectator())
-		{
-			return;
-		}
-		NetCache.HeroLevel heroLevel = null;
-		int totalLevel = 0;
-		Entity startingHero = GameState.Get().GetFriendlySidePlayer().GetStartingHero();
-		if (startingHero != null)
-		{
-			heroLevel = GameUtils.GetHeroLevel(startingHero.GetClass());
+    }
+
+    public virtual void OnDestroy()
+    {
+    }
+
+    private void Start()
+    {
+        LayerUtils.SetLayer(base.gameObject, GameLayer.IgnoreFullScreenEffects);
+        ResetPositions();
+    }
+
+    public bool IsShown()
+    {
+        return m_isShown;
+    }
+
+    public void Show(AccessibleComponent parent, bool showXPBar = true)
+    {
+        m_isShown = true;
+        base.gameObject.SetActive(value: true);
+        ShowImpl();
+        if (!showXPBar || GameMgr.Get().IsTraditionalTutorial() || GameMgr.Get().IsSpectator())
+        {
+            return;
+        }
+        NetCache.HeroLevel heroLevel = null;
+        int totalLevel = 0;
+        Entity startingHero = GameState.Get().GetFriendlySidePlayer().GetStartingHero();
+        if (startingHero != null)
+        {
+            heroLevel = GameUtils.GetHeroLevel(startingHero.GetClass());
 			totalLevel = GameUtils.GetTotalHeroLevel().GetValueOrDefault();
-		}
-		if (heroLevel == null)
-		{
-			HideXpBar();
-		}
-		else if (m_xpBarPrefab != null)
-		{
-			m_xpBar = Object.Instantiate(m_xpBarPrefab);
-			if (m_heroActor.m_xpBarRootObject != null)
-			{
-				m_xpBar.transform.parent = m_heroActor.m_xpBarRootObject.transform;
-				m_xpBar.transform.localScale = Vector3.one;
-				m_xpBar.transform.localPosition = Vector3.zero;
-			}
-			else
-			{
-				m_xpBar.transform.parent = m_heroActor.transform;
+        }
+        if (heroLevel == null)
+        {
+            HideXpBar();
+			AccessibilityMgr.Output(parent, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+        }
+        else if (m_xpBarPrefab != null)
+        {
+            m_xpBar = Object.Instantiate(m_xpBarPrefab);
+            if (m_heroActor.m_xpBarRootObject != null)
+            {
+                m_xpBar.transform.parent = m_heroActor.m_xpBarRootObject.transform;
+                m_xpBar.transform.localScale = Vector3.one;
+                m_xpBar.transform.localPosition = Vector3.zero;
+            }
+            else
+            {
+                m_xpBar.transform.parent = m_heroActor.transform;
 				m_xpBar.transform.localScale = m_xpBarLocalScale;
 				m_xpBar.transform.localPosition = m_xpBarLocalPosition;
-			}
-			NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-			m_xpBar.m_soloLevelLimit = netObject?.XPSoloLimit ?? 60;
-			m_xpBar.m_isAnimated = true;
-			m_xpBar.m_delay = BAR_ANIMATION_DELAY;
-			m_xpBar.m_levelUpCallback = PlayLevelUpEffect;
-			m_xpBar.UpdateDisplay(heroLevel, totalLevel);
-		}
-	}
-
-	public void Hide()
-	{
-		HideAll();
-	}
-
-	public virtual bool IsLoaded()
-	{
-		return m_heroActorLoaded;
-	}
-
-	public void HideXpBar()
-	{
-		if (m_xpBar != null)
-		{
-			m_xpBar.gameObject.SetActive(value: false);
-		}
-	}
-
-	public virtual void StopAnimating()
-	{
-	}
-
-	protected virtual string GetActorName()
-	{
-		return "Card_Play_Hero.prefab:42cbbd2c4969afb46b3887bb628de19d";
-	}
-
-	protected virtual void ShowImpl()
-	{
-	}
-
-	protected virtual void ResetPositions()
-	{
-	}
-
-	protected void SetBannerLabel(string label)
-	{
-		m_bannerLabel.Text = label;
-	}
-
-	protected void EnableBannerLabel(bool enable)
-	{
-		m_bannerLabel.gameObject.SetActive(enable);
-	}
-
-	protected void PunchEndGameTwoScoop()
-	{
-		if (EndGameScreen.Get() != null)
-		{
-			EndGameScreen.Get().SetPlayingBlockingAnim(set: false);
-		}
-		iTween.ScaleTo(base.gameObject, new Vector3(AFTER_PUNCH_SCALE_VAL, AFTER_PUNCH_SCALE_VAL, AFTER_PUNCH_SCALE_VAL), 0.15f);
-	}
-
-	private void HideAll()
-	{
-		ScreenEffectsMgr.Get().SetActive(enabled: false);
+            }
+            NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+            m_xpBar.m_soloLevelLimit = netObject?.XPSoloLimit ?? 60;
+            m_xpBar.m_isAnimated = true;
+            m_xpBar.m_delay = BAR_ANIMATION_DELAY;
+            m_xpBar.m_levelUpCallback = PlayLevelUpEffect;
+			m_xpBar.UpdateDisplay(AccessibleEndGameScreen.Get(), heroLevel, totalLevel, true);
+        }
+        else
+        {
+            AccessibilityMgr.Output(parent, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+        }
+    }
+
+    public void Hide()
+    {
+        HideAll();
+    }
+
+    public virtual bool IsLoaded()
+    {
+        return m_heroActorLoaded;
+    }
+
+    public void HideXpBar()
+    {
+        if (m_xpBar != null)
+        {
+            m_xpBar.gameObject.SetActive(value: false);
+        }
+    }
+
+    public virtual void StopAnimating()
+    {
+    }
+
+    protected virtual string GetActorName()
+    {
+        return "Card_Play_Hero.prefab:42cbbd2c4969afb46b3887bb628de19d";
+    }
+
+    protected virtual void ShowImpl()
+    {
+    }
+
+    protected virtual void ResetPositions()
+    {
+    }
+
+    protected void SetBannerLabel(string label)
+    {
+        m_bannerLabel.Text = label;
+    }
+
+    protected void EnableBannerLabel(bool enable)
+    {
+        m_bannerLabel.gameObject.SetActive(enable);
+    }
+
+    protected void PunchEndGameTwoScoop()
+    {
+        if (EndGameScreen.Get() != null)
+        {
+            EndGameScreen.Get().SetPlayingBlockingAnim(set: false);
+        }
+        iTween.ScaleTo(base.gameObject, new Vector3(AFTER_PUNCH_SCALE_VAL, AFTER_PUNCH_SCALE_VAL, AFTER_PUNCH_SCALE_VAL), 0.15f);
+    }
+
+    private void HideAll()
+    {
+        ScreenEffectsMgr.Get().SetActive(enabled: false);
 		Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
 		tweenHashTable.Add("scale", new Vector3(START_SCALE_VAL, START_SCALE_VAL, START_SCALE_VAL));
 		tweenHashTable.Add("time", 0.25f);
 		tweenHashTable.Add("oncomplete", "OnAllHidden");
 		tweenHashTable.Add("oncompletetarget", base.gameObject);
-		iTween.FadeTo(base.gameObject, 0f, 0.25f);
+        iTween.FadeTo(base.gameObject, 0f, 0.25f);
 		iTween.ScaleTo(base.gameObject, tweenHashTable);
-		m_isShown = false;
-	}
-
-	private void OnAllHidden()
-	{
-		iTween.FadeTo(base.gameObject, 0f, 0f);
-		base.gameObject.SetActive(value: false);
-		ResetPositions();
-	}
-
-	private void OnHeroActorLoaded(AssetReference assetRef, GameObject go, object callbackData)
-	{
+        m_isShown = false;
+    }
+
+    private void OnAllHidden()
+    {
+        iTween.FadeTo(base.gameObject, 0f, 0f);
+        base.gameObject.SetActive(value: false);
+        ResetPositions();
+    }
+
+    private void OnHeroActorLoaded(AssetReference assetRef, GameObject go, object callbackData)
+    {
 		GameObject gameObject = (GameObject)callbackData;
-		go.transform.parent = base.transform;
+        go.transform.parent = base.transform;
 		go.transform.localPosition = gameObject.transform.localPosition;
 		go.transform.localScale = gameObject.transform.localScale;
 		go.transform.localRotation = gameObject.transform.localRotation;
-		m_heroActor = go.GetComponent<Actor>();
-		m_heroActor.TurnOffCollider();
-		m_heroActor.m_healthObject.SetActive(value: false);
-		m_heroActorLoaded = true;
-		Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
-		if (heroCard != null)
-		{
-			m_heroActor.SetPremium(heroCard.GetPremium());
-		}
-		m_heroActor.UpdateAllComponents();
-	}
+        m_heroActor = go.GetComponent<Actor>();
+        m_heroActor.TurnOffCollider();
+        m_heroActor.m_healthObject.SetActive(value: false);
+        m_heroActorLoaded = true;
+        Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+        if (heroCard != null)
+        {
+            m_heroActor.SetPremium(heroCard.GetPremium());
+        }
+        m_heroActor.UpdateAllComponents();
+    }
 
 	private void OnTeammateHeroActorLoaded(AssetReference assetRef, GameObject go, object callbackData)
 	{
@@ -232,13 +238,13 @@ public class EndGameTwoScoop : MonoBehaviour
 		}
 	}
 
-	protected void PlayLevelUpEffect()
-	{
-		GameObject gameObject = Object.Instantiate(m_levelUpTier1);
-		if ((bool)gameObject)
-		{
-			gameObject.transform.parent = base.transform;
-			gameObject.GetComponent<PlayMakerFSM>().SendEvent("Birth");
-		}
-	}
+    protected void PlayLevelUpEffect()
+    {
+        GameObject gameObject = Object.Instantiate(m_levelUpTier1);
+        if ((bool)gameObject)
+        {
+            gameObject.transform.parent = base.transform;
+            gameObject.GetComponent<PlayMakerFSM>().SendEvent("Birth");
+        }
+    }
 }
diff --git a/Assembly-CSharp/EnemyEmoteHandler.cs b/Assembly-CSharp/EnemyEmoteHandler.cs
index ec64134..507281e 100644
--- a/Assembly-CSharp/EnemyEmoteHandler.cs
+++ b/Assembly-CSharp/EnemyEmoteHandler.cs
@@ -4,17 +4,18 @@ using System.Linq;
 using Blizzard.T5.Core;
 using Blizzard.T5.Core.Utils;
 using UnityEngine;
+using Accessibility;
 
 public class EnemyEmoteHandler : MonoBehaviour
 {
 	[Serializable]
-	private class EnemyEmote
+	public class EnemyEmote
 	{
-		public GameObject m_SquelchEmote;
+	public GameObject m_SquelchEmote;
 
-		public MeshRenderer m_SquelchEmoteBackplate;
+	public MeshRenderer m_SquelchEmoteBackplate;
 
-		public UberText m_SquelchEmoteText;
+	public UberText m_SquelchEmoteText;
 
 		public bool m_SquelchTeammate;
 
@@ -232,7 +233,7 @@ public class EnemyEmoteHandler : MonoBehaviour
 		return false;
 	}
 
-	private void DoSquelchClick(EnemyEmote enemyEmote)
+	internal void DoSquelchClick(EnemyEmote enemyEmote = null)
 	{
 		if (GameMgr.Get().IsBattlegroundDuoGame())
 		{
@@ -240,16 +241,16 @@ public class EnemyEmoteHandler : MonoBehaviour
 			int num = GameState.Get().GetFriendlySidePlayer().GetTag(GAME_TAG.BACON_DUO_TEAMMATE_PLAYER_ID);
 			if (enemyEmote.m_SquelchTeammate)
 			{
-				foreach (int item in m_squelched.Keys.ToList())
-				{
+			foreach (int item in m_squelched.Keys.ToList())
+			{
 					if (item == num)
-					{
-						m_squelched[item] = !m_squelched[item];
-					}
+				{
+					m_squelched[item] = !m_squelched[item];
 				}
 			}
-			else
-			{
+		}
+		else
+		{
 				foreach (int item2 in m_squelched.Keys.ToList())
 				{
 					if (item2 != playerId && item2 != num)
@@ -346,6 +347,8 @@ public class EnemyEmoteHandler : MonoBehaviour
 		emote.m_SquelchEmote.GetComponent<Collider>().enabled = true;
 		iTween.Stop(emote.m_SquelchEmote);
 		iTween.ScaleTo(emote.m_SquelchEmote, iTween.Hash("scale", m_squelchEmoteStartingScale, "time", 0.5f, "ignoretimescale", true, "easetype", iTween.EaseType.easeOutElastic));
+
+		AccessibleGameplay.Get().OnEnemyEmotesShown(emote.m_SquelchEmoteText.Text);
 	}
 
 	private void HideEnemyEmote(EnemyEmote emote)
diff --git a/Assembly-CSharp/Entity.cs b/Assembly-CSharp/Entity.cs
index 2cab359..babc207 100644
--- a/Assembly-CSharp/Entity.cs
+++ b/Assembly-CSharp/Entity.cs
@@ -275,8 +275,14 @@ public class Entity : EntityBase
 		}, fromShowEntity: true);
 	}
 
+	#region Accessibility
+	private EntityDef m_entityDefBeforeHideEntity;
+	#endregion
+
 	public void OnHideEntity(Network.HistHideEntity hideEntity)
 	{
+		m_entityDefBeforeHideEntity = GetEntityDef();
+
 		SetTagAndHandleChange(GAME_TAG.ZONE, hideEntity.Zone);
 		EntityDef entityDef = GetEntityDef();
 		SetTag(GAME_TAG.ATK, entityDef.GetATK());
@@ -428,7 +434,7 @@ public class Entity : EntityBase
 			SetRealTimePlayerLeaderboardPlace(change.Value);
 			if (!(GameState.Get().GetGameEntity() is TB_BaconShop_Tutorial) || GetControllerSide() != Player.Side.OPPOSING)
 			{
-				UpdateSharedPlayer();
+			UpdateSharedPlayer();
 			}
 			break;
 		case GAME_TAG.BACON_DUO_PLAYER_FIGHTS_FIRST_NEXT_COMBAT:
@@ -437,8 +443,8 @@ public class Entity : EntityBase
 		case GAME_TAG.PLAYER_TECH_LEVEL:
 			if (!GetRealTimeBaconCombatPhaseHero())
 			{
-				SetRealTimePlayerTechLevel(change.Value);
-				PlayerLeaderboardManager.Get().NotifyPlayerTileEvent(GetTag(GAME_TAG.PLAYER_ID), PlayerLeaderboardManager.PlayerTileEvent.TECH_LEVEL);
+			SetRealTimePlayerTechLevel(change.Value);
+			PlayerLeaderboardManager.Get().NotifyPlayerTileEvent(GetTag(GAME_TAG.PLAYER_ID), PlayerLeaderboardManager.PlayerTileEvent.TECH_LEVEL);
 			}
 			break;
 		case GAME_TAG.BACON_DUO_PASSABLE:
@@ -470,13 +476,13 @@ public class Entity : EntityBase
 		case GAME_TAG.BACON_MUKLA_BANANA_SPAWN_COUNT:
 			if (!GetRealTimeBaconCombatPhaseHero())
 			{
-				PlayerLeaderboardManager.Get().NotifyPlayerTileEvent(GetTag(GAME_TAG.PLAYER_ID), PlayerLeaderboardManager.PlayerTileEvent.BANANA);
+			PlayerLeaderboardManager.Get().NotifyPlayerTileEvent(GetTag(GAME_TAG.PLAYER_ID), PlayerLeaderboardManager.PlayerTileEvent.BANANA);
 			}
 			break;
 		case GAME_TAG.BACON_QUEST_COMPLETED:
 			if (!GetRealTimeBaconCombatPhaseHero())
 			{
-				PlayerLeaderboardManager.Get().NotifyPlayerTileEvent(GetTag(GAME_TAG.PLAYER_ID), PlayerLeaderboardManager.PlayerTileEvent.QUEST_COMPLETE);
+			PlayerLeaderboardManager.Get().NotifyPlayerTileEvent(GetTag(GAME_TAG.PLAYER_ID), PlayerLeaderboardManager.PlayerTileEvent.QUEST_COMPLETE);
 			}
 			break;
 		case GAME_TAG.BACON_COMBAT_PHASE_HERO:
@@ -835,8 +841,8 @@ public class Entity : EntityBase
 				{
 					if (parentEntity.GetZone() != TAG_ZONE.PLAY)
 					{
-						parentEntity.RemoveSubCard(this);
-					}
+					parentEntity.RemoveSubCard(this);
+				}
 				}
 				else
 				{
@@ -919,9 +925,9 @@ public class Entity : EntityBase
 			{
 				break;
 			}
-			switch (change.newValue)
-			{
-			case 1:
+				switch (change.newValue)
+				{
+				case 1:
 			{
 				SpellUtils.ActivateBirthIfNecessary(actor3.GetLoadedSpell(SpellType.HERO_BUDDY_SINGLE));
 				HeroBuddyWidgetCoinBased component2 = actor3.GetComponent<HeroBuddyWidgetCoinBased>();
@@ -930,18 +936,18 @@ public class Entity : EntityBase
 					component2.EnterStage2();
 					heroBuddyCard.GetEntity()?.SetTagAndHandleChange(GAME_TAG.EXHAUSTED, 0);
 				}
-				break;
+					break;
 			}
-			case 2:
+				case 2:
 				SpellUtils.ActivateBirthIfNecessary(actor3.GetLoadedSpell(SpellType.HERO_BUDDY_DOUBLE));
-				break;
-			default:
-				PlayerLeaderboardManager.Get().NotifyPlayerTileEvent(GetTag(GAME_TAG.PLAYER_ID), PlayerLeaderboardManager.PlayerTileEvent.DOUBLE_HERO_BUDDY);
-				Debug.LogWarning($"Unexpected Number of Hero Buddies gained: {change.newValue}");
-				break;
-			case 0:
-				break;
-			}
+					break;
+				default:
+					PlayerLeaderboardManager.Get().NotifyPlayerTileEvent(GetTag(GAME_TAG.PLAYER_ID), PlayerLeaderboardManager.PlayerTileEvent.DOUBLE_HERO_BUDDY);
+					Debug.LogWarning($"Unexpected Number of Hero Buddies gained: {change.newValue}");
+					break;
+				case 0:
+					break;
+				}
 			break;
 		}
 		case GAME_TAG.BACON_HERO_QUEST_REWARD_DATABASE_ID:
@@ -996,41 +1002,41 @@ public class Entity : EntityBase
 			return false;
 		}
 		using DefLoader.DisposableCardDef disposableCardDef = DefLoader.Get().GetCardDef(enchantmentPortraitCardID);
-		if (disposableCardDef == null)
-		{
-			return false;
-		}
-		EntityDef entityDef = DefLoader.Get().GetEntityDef(enchantmentPortraitCardID);
-		if (entityDef == null)
-		{
-			return false;
-		}
-		TAG_PREMIUM premium = TAG_PREMIUM.NORMAL;
-		Material enchantmentPortraitMat;
-		if (entityDef.GetCardType() == TAG_CARDTYPE.ENCHANTMENT)
-		{
-			if (disposableCardDef.CardDef.TryGetEnchantmentPortrait(out enchantmentPortraitMat))
+			if (disposableCardDef == null)
 			{
-				return true;
+				return false;
 			}
-			if (disposableCardDef.CardDef.GetPortraitTexture(premium) != null)
+			EntityDef entityDef = DefLoader.Get().GetEntityDef(enchantmentPortraitCardID);
+			if (entityDef == null)
 			{
-				return true;
+				return false;
 			}
-		}
-		else
-		{
-			if (disposableCardDef.CardDef.TryGetHistoryTileFullPortrait(premium, out enchantmentPortraitMat))
+			TAG_PREMIUM premium = TAG_PREMIUM.NORMAL;
+			Material enchantmentPortraitMat;
+			if (entityDef.GetCardType() == TAG_CARDTYPE.ENCHANTMENT)
 			{
-				return true;
+				if (disposableCardDef.CardDef.TryGetEnchantmentPortrait(out enchantmentPortraitMat))
+				{
+					return true;
+				}
+				if (disposableCardDef.CardDef.GetPortraitTexture(premium) != null)
+				{
+					return true;
+				}
 			}
-			if (disposableCardDef.CardDef.GetPortraitTexture(premium) != null)
+			else
 			{
-				return true;
+				if (disposableCardDef.CardDef.TryGetHistoryTileFullPortrait(premium, out enchantmentPortraitMat))
+				{
+					return true;
+				}
+				if (disposableCardDef.CardDef.GetPortraitTexture(premium) != null)
+				{
+					return true;
+				}
 			}
+			return false;
 		}
-		return false;
-	}
 
 	public string GetEnchantmentCreatorCardIDForPortrait()
 	{
@@ -1382,8 +1388,8 @@ public class Entity : EntityBase
 		if (!(enchantmentBannerText == null) && GetCardId() == "ETC_335")
 		{
 			enchantmentBannerText.transform.localScale *= 0.8f;
-			if (UniversalInputManager.Get().IsTouchMode())
-			{
+		if (UniversalInputManager.Get().IsTouchMode())
+		{
 				enchantmentBannerText.transform.localPosition += new Vector3(0.14f, 0.084f, 0f);
 			}
 			else if (IsControlledByFriendlySidePlayer())
@@ -1605,13 +1611,13 @@ public class Entity : EntityBase
 		{
 			int tag = GetTag(GAME_TAG.BACON_SKIN_PARENT_ID);
 			using DefLoader.DisposableFullDef disposableFullDef = DefLoader.Get().GetFullDef(tag);
-			if (disposableFullDef?.EntityDef == null || disposableFullDef?.CardDef == null)
-			{
-				Log.Gameplay.PrintError("GetHeroBuddyId(): Unable to load def for card ID {0}.", tag);
-				return 0;
+				if (disposableFullDef?.EntityDef == null || disposableFullDef?.CardDef == null)
+				{
+					Log.Gameplay.PrintError("GetHeroBuddyId(): Unable to load def for card ID {0}.", tag);
+					return 0;
+				}
+				return disposableFullDef.EntityDef.GetTag(GAME_TAG.BACON_COMPANION_ID);
 			}
-			return disposableFullDef.EntityDef.GetTag(GAME_TAG.BACON_COMPANION_ID);
-		}
 		return GetTag(GAME_TAG.BACON_COMPANION_ID);
 	}
 
@@ -1702,35 +1708,35 @@ public class Entity : EntityBase
 	public string GetCardTextInHand()
 	{
 		using DefLoader.DisposableCardDef disposableCardDef = ShareDisposableCardDef();
-		if (disposableCardDef?.CardDef == null)
-		{
-			Log.All.PrintError("Entity.GetCardTextInHand(): entity {0} does not have a CardDef", GetEntityId());
-			return string.Empty;
+			if (disposableCardDef?.CardDef == null)
+			{
+				Log.All.PrintError("Entity.GetCardTextInHand(): entity {0} does not have a CardDef", GetEntityId());
+				return string.Empty;
+			}
+			return GetCardTextBuilder().BuildCardTextInHand(this);
 		}
-		return GetCardTextBuilder().BuildCardTextInHand(this);
-	}
 
 	public string GetCardTextInHistory()
 	{
 		using DefLoader.DisposableCardDef disposableCardDef = ShareDisposableCardDef();
-		if (disposableCardDef?.CardDef == null)
-		{
-			Log.All.PrintError("Entity.GetCardTextInHand(): entity {0} does not have a CardDef", GetEntityId());
-			return string.Empty;
+			if (disposableCardDef?.CardDef == null)
+			{
+				Log.All.PrintError("Entity.GetCardTextInHand(): entity {0} does not have a CardDef", GetEntityId());
+				return string.Empty;
+			}
+			return GetCardTextBuilder().BuildCardTextInHistory(this);
 		}
-		return GetCardTextBuilder().BuildCardTextInHistory(this);
-	}
 
 	public string GetTargetingArrowText()
 	{
 		using DefLoader.DisposableCardDef disposableCardDef = ShareDisposableCardDef();
-		if (disposableCardDef?.CardDef == null)
-		{
-			Log.All.PrintError("Entity.GetTargetingArrowText(): entity {0} does not have a CardDef", GetEntityId());
-			return string.Empty;
+			if (disposableCardDef?.CardDef == null)
+			{
+				Log.All.PrintError("Entity.GetTargetingArrowText(): entity {0} does not have a CardDef", GetEntityId());
+				return string.Empty;
+			}
+			return GetCardTextBuilder().GetTargetingArrowText(this);
 		}
-		return GetCardTextBuilder().GetTargetingArrowText(this);
-	}
 
 	public void AddAttachment(Entity entity)
 	{
@@ -2003,6 +2009,22 @@ public class Entity : EntityBase
 		return entity;
 	}
 
+	public Entity CloneForAccessibility()
+	{
+		Entity entity = new Entity();
+		entity.m_duplicateForHistory = true;
+		entity.m_staticEntityDef = GetEntityDefWhileCloningForAccessibility();
+		entity.m_dynamicEntityDef = null;
+		entity.m_card = m_card;
+		entity.m_cardId = base.m_cardId;
+		entity.ReplaceTags(m_tags);
+		entity.m_subCardIDs = m_subCardIDs;
+		entity.m_loadState = m_loadState;
+		entity.m_displayedCreatorName = m_displayedCreatorName;
+		entity.m_enchantmentCreatorCardIDForPortrait = m_enchantmentCreatorCardIDForPortrait;
+		return entity;
+	}
+
 	public bool IsHistoryDupe()
 	{
 		return m_duplicateForHistory;
@@ -2036,9 +2058,9 @@ public class Entity : EntityBase
 				return lettuceAbilityOwner.GetController();
 			}
 		}
-		Entity parentEntity = GetParentEntity();
+			Entity parentEntity = GetParentEntity();
 		if (parentEntity != null && parentEntity.IsLettuceAbility())
-		{
+			{
 			Entity parentEntity2 = GetParentEntity();
 			if (parentEntity2 != null)
 			{
@@ -2720,9 +2742,9 @@ public class Entity : EntityBase
 				return SpellType.TRIGGER_UPBEAT;
 			}
 			if (gameState.IsUsingFastActorTriggers() && !IsHeroPower())
-			{
-				return SpellType.FAST_TRIGGER;
-			}
+		{
+			return SpellType.FAST_TRIGGER;
+		}
 		}
 		return SpellType.TRIGGER;
 	}
@@ -2929,4 +2951,18 @@ public class Entity : EntityBase
 		}
 		return false;
 	}
+
+	#region Accessibility
+	private EntityDef GetEntityDefWhileCloningForAccessibility()
+	{
+		// In patch 28.2, It is possible for an entity to be both shown and hidden as part of the same power task list. Since we only snapshot when a ptl ends, we would normally miss the ShowEntity. Therefore, cache the old EntityDef during HideEntity and return it if the current one is unsuitable.
+
+		EntityDef entityDef = GetEntityDef();
+		if (!entityDef.HasValidDisplayName() && m_entityDefBeforeHideEntity != null)
+		{
+			return m_entityDefBeforeHideEntity;
+		}
+		return entityDef;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/EntityBase.cs b/Assembly-CSharp/EntityBase.cs
index 248fccb..57c35ad 100644
--- a/Assembly-CSharp/EntityBase.cs
+++ b/Assembly-CSharp/EntityBase.cs
@@ -453,9 +453,9 @@ public abstract class EntityBase
 	{
 		GameEntity gameEntity = GameState.Get()?.GetGameEntity();
 		if (IsBattlegroundHeroBuddy() && gameEntity != null)
-		{
-			return gameEntity.GetTag(GAME_TAG.BACON_USE_COIN_BASED_BUDDY_METER) != 0;
-		}
+			{
+				return gameEntity.GetTag(GAME_TAG.BACON_USE_COIN_BASED_BUDDY_METER) != 0;
+			}
 		return false;
 	}
 
@@ -1111,4 +1111,41 @@ public abstract class EntityBase
 	{
 		m_entityRaces = null;
 	}
+
+	#region Accessibility
+
+	public bool HasReborn()
+	{
+		return HasTag(GAME_TAG.REBORN);
+	}
+
+	public bool IsFreeze()
+	{
+		return HasTag(GAME_TAG.FREEZE);
+	}
+
+	public bool CanBeAttacked()
+	{
+		if (!HasTag(GAME_TAG.CANT_BE_ATTACKED))
+		{
+			return !HasTag(GAME_TAG.UNTOUCHABLE);
+		}
+		return false;
+	}
+
+	public bool CanBeTargetedByOpponents()
+	{
+		if (!HasTag(GAME_TAG.CANT_BE_TARGETED_BY_OPPONENTS))
+		{
+			return !HasTag(GAME_TAG.UNTOUCHABLE);
+		}
+		return false;
+	}
+
+	public bool IsMagnet()
+	{
+		return HasTag(GAME_TAG.MAGNET);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/EventTimingManager.cs b/Assembly-CSharp/EventTimingManager.cs
index 5b70f4f..4914621 100644
--- a/Assembly-CSharp/EventTimingManager.cs
+++ b/Assembly-CSharp/EventTimingManager.cs
@@ -15,21 +15,11 @@ public class EventTimingManager : IService
 
 	private class EventTiming
 	{
-		[CompilerGenerated]
-		private EventTimingType <Type>k__BackingField;
-
 		public string Name { get; private set; }
 
 		public long Id { get; private set; }
 
-		private EventTimingType Type
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Type>k__BackingField = value;
-			}
-		}
+		private EventTimingType Type;
 
 		public DateTime? StartTimeUtc { get; private set; }
 
diff --git a/Assembly-CSharp/ExistingAccountPopup.cs b/Assembly-CSharp/ExistingAccountPopup.cs
index d761a53..6bf15bc 100644
--- a/Assembly-CSharp/ExistingAccountPopup.cs
+++ b/Assembly-CSharp/ExistingAccountPopup.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using UnityEngine;
 
-public class ExistingAccountPopup : DialogBase
+public class ExistingAccountPopup : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool hasAccount);
 
diff --git a/Assembly-CSharp/FatalErrorScene.cs b/Assembly-CSharp/FatalErrorScene.cs
index f883eb7..454ed8c 100644
--- a/Assembly-CSharp/FatalErrorScene.cs
+++ b/Assembly-CSharp/FatalErrorScene.cs
@@ -12,7 +12,7 @@ public class FatalErrorScene : PegasusScene
 		{
 			service.AppAbort();
 		}
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.FATAL_ERROR_SCENE);
+		UserAttentionManager.StartBlocking(true, UserAttentionBlocker.FATAL_ERROR_SCENE);
 		if (DialogManager.Get() != null)
 		{
 			DialogManager.Get().ClearAllImmediately();
@@ -35,12 +35,12 @@ public class FatalErrorScene : PegasusScene
 
 	private void OnDestroy()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.FATAL_ERROR_SCENE);
+		UserAttentionManager.StopBlocking(true, UserAttentionBlocker.FATAL_ERROR_SCENE);
 	}
 
 	public override void Unload()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.FATAL_ERROR_SCENE);
+		UserAttentionManager.StopBlocking(true, UserAttentionBlocker.FATAL_ERROR_SCENE);
 	}
 
 	private void OnFatalErrorScreenLoaded(AssetReference assetRef, GameObject go, object callbackData)
diff --git a/Assembly-CSharp/FatalErrorScreen.cs b/Assembly-CSharp/FatalErrorScreen.cs
index e7f1420..60ab4f9 100644
--- a/Assembly-CSharp/FatalErrorScreen.cs
+++ b/Assembly-CSharp/FatalErrorScreen.cs
@@ -3,8 +3,9 @@ using System.Collections;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
-public class FatalErrorScreen : MonoBehaviour
+public class FatalErrorScreen : MonoBehaviour, AccessibleScreen
 {
 	public UberText m_closedSignText;
 
@@ -121,6 +122,8 @@ public class FatalErrorScreen : MonoBehaviour
 		{
 			Processor.TerminateAllProcessing();
 		}
+
+		ReadScreen();
 	}
 
 	private void OnClick(UIEvent e)
@@ -160,4 +163,43 @@ public class FatalErrorScreen : MonoBehaviour
 		yield return new WaitForSeconds(waitDuration);
 		HearthstoneApplication.Get().Reset();
 	}
+
+    #region Accessibility
+
+	private void ReadScreen()
+    {
+		AccessibilityMgr.SetScreen(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_FATAL_ERROR_SCREEN_TITLE));
+
+		if (m_closedSignTitle != null && m_closedSignTitle.Text != null)
+        {
+			AccessibilityMgr.Output(this, m_closedSignTitle.Text);
+        }
+
+		if (m_closedSignText != null && m_closedSignText.Text != null)
+        {
+			AccessibilityMgr.Output(this, m_closedSignText.Text);
+        }
+
+        AccessibilityMgr.Output(this, GetHelp());
+    }
+
+    public void HandleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			HearthstoneApplication.Get().Exit();
+        }
+    }
+
+    public string GetHelp()
+    {
+		return LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_EXIT, AccessibleKey.CONFIRM);
+    }
+
+    public void OnGainedFocus()
+    {
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/FinisherAuthoringList.cs b/Assembly-CSharp/FinisherAuthoringList.cs
index 319bab0..1d06ebd 100644
--- a/Assembly-CSharp/FinisherAuthoringList.cs
+++ b/Assembly-CSharp/FinisherAuthoringList.cs
@@ -1,7 +1,7 @@
 using System.Collections.Generic;
 using UnityEngine;
 
-[CreateAssetMenu(menuName = "Prototyping/Finisher Authoring List")]
+// [CreateAssetMenu(menuName = "Prototyping/Finisher Authoring List")]
 public class FinisherAuthoringList : ScriptableObject
 {
 	public List<FinisherGameplaySettings> Finishers = new List<FinisherGameplaySettings>();
diff --git a/Assembly-CSharp/FinisherGameplaySettings.cs b/Assembly-CSharp/FinisherGameplaySettings.cs
index e8594c8..97a26e0 100644
--- a/Assembly-CSharp/FinisherGameplaySettings.cs
+++ b/Assembly-CSharp/FinisherGameplaySettings.cs
@@ -1,7 +1,7 @@
 using Blizzard.T5.AssetManager;
 using UnityEngine;
 
-[CreateAssetMenu(menuName = "Prototyping/Finisher Gameplay Settings")]
+// [CreateAssetMenu(menuName = "Prototyping/Finisher Gameplay Settings")]
 public class FinisherGameplaySettings : ScriptableObject
 {
 	private AssetHandle<FinisherGameplaySettings> FinisherHandle;
@@ -81,8 +81,8 @@ public class FinisherGameplaySettings : ScriptableObject
 	{
 		if (FinisherHandle != null)
 		{
-			FinisherHandle.Dispose();
-			FinisherHandle = null;
-		}
+		FinisherHandle.Dispose();
+		FinisherHandle = null;
 	}
 }
+}
diff --git a/Assembly-CSharp/FixedRewardsMgr.cs b/Assembly-CSharp/FixedRewardsMgr.cs
index 907d884..9daad07 100644
--- a/Assembly-CSharp/FixedRewardsMgr.cs
+++ b/Assembly-CSharp/FixedRewardsMgr.cs
@@ -123,7 +123,7 @@ public class FixedRewardsMgr : IService
 
 	public bool ShowFixedRewards(UserAttentionBlocker blocker, HashSet<Achieve.RewardTiming> rewardVisualTimings, DelOnAllFixedRewardsShown allRewardsShownCallback, DelPositionNonToastReward positionNonToastRewardCallback)
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(blocker, $"FixedRewardsMgr.ShowFixedRewards:{blocker}") || StoreManager.Get().IsPromptShowing)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, blocker, $"FixedRewardsMgr.ShowFixedRewards:{blocker}") || StoreManager.Get().IsPromptShowing)
 		{
 			return false;
 		}
diff --git a/Assembly-CSharp/FreeArenaWinDialog.cs b/Assembly-CSharp/FreeArenaWinDialog.cs
index dcc4e28..fc57fee 100644
--- a/Assembly-CSharp/FreeArenaWinDialog.cs
+++ b/Assembly-CSharp/FreeArenaWinDialog.cs
@@ -1,7 +1,8 @@
+using Accessibility;
 using System.Collections;
 using UnityEngine;
 
-public class FreeArenaWinDialog : DialogBase
+public class FreeArenaWinDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Assembly-CSharp/FriendChallengeMgr.cs b/Assembly-CSharp/FriendChallengeMgr.cs
index 50e474a..10d0f03 100644
--- a/Assembly-CSharp/FriendChallengeMgr.cs
+++ b/Assembly-CSharp/FriendChallengeMgr.cs
@@ -1,3 +1,4 @@
+using System;
 using System.Collections.Generic;
 using System.Linq;
 using Assets;
@@ -10,6 +11,7 @@ using PegasusShared;
 using PegasusUtil;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 public class FriendChallengeMgr
 {
@@ -88,7 +90,7 @@ public class FriendChallengeMgr
 		}
 	}
 
-	public static FriendChallengeMgr Get()
+	public unsafe static FriendChallengeMgr Get()
 	{
 		if (s_instance == null)
 		{
@@ -121,7 +123,7 @@ public class FriendChallengeMgr
 		BnetPresenceMgr.Get().SetGameField(20u, BattleNet.GetEnvironment());
 	}
 
-	private void BnetParty_OnJoined(OnlineEventType evt, PartyInfo party, LeaveReason? reason)
+	internal void BnetParty_OnJoined(OnlineEventType evt, PartyInfo party, LeaveReason? reason)
 	{
 		if (party.Type != PartyType.FRIENDLY_CHALLENGE)
 		{
@@ -142,40 +144,45 @@ public class FriendChallengeMgr
 				break;
 			}
 			m_data.m_partyId = party.Id;
-			if (BattleNet.GetPartyAttribute(party.Id, "WTCG.Game.ScenarioId", out long value))
+			long num = default(long);
+			if (BattleNet.GetPartyAttribute<long>(party.Id, "WTCG.Game.ScenarioId", out num))
 			{
-				m_data.m_scenarioId = (int)value;
+				m_data.m_scenarioId = (int)num;
 			}
-			if (BattleNet.GetPartyAttribute(party.Id, "WTCG.Format.Type", out long value2))
+			long num2 = default(long);
+			if (BattleNet.GetPartyAttribute<long>(party.Id, "WTCG.Format.Type", out num2))
 			{
-				m_data.m_challengeFormatType = (FormatType)value2;
+				m_data.m_challengeFormatType = (FormatType)num2;
 			}
 			else
 			{
 				m_data.m_challengeFormatType = FormatType.FT_UNKNOWN;
 			}
-			if (BattleNet.GetPartyAttribute(party.Id, "WTCG.Brawl.Type", out long value3))
+			long num3 = default(long);
+			if (BattleNet.GetPartyAttribute<long>(party.Id, "WTCG.Brawl.Type", out num3))
 			{
-				if (value3 >= 1 && value3 < 3)
+				if (num3 >= 1 && num3 < 3)
 				{
-					m_data.m_challengeBrawlType = (BrawlType)value3;
+					m_data.m_challengeBrawlType = (BrawlType)num3;
 				}
 			}
 			else
 			{
 				m_data.m_challengeBrawlType = BrawlType.BRAWL_TYPE_UNKNOWN;
 			}
-			if (BattleNet.GetPartyAttribute(party.Id, "WTCG.Season.Id", out int value4))
+			int seasonId = default(int);
+			if (BattleNet.GetPartyAttribute<int>(party.Id, "WTCG.Season.Id", out seasonId))
 			{
-				m_data.m_seasonId = value4;
+				m_data.m_seasonId = seasonId;
 			}
 			else
 			{
 				m_data.m_seasonId = 0;
 			}
-			if (BattleNet.GetPartyAttribute(party.Id, "WTCG.Brawl.LibraryItemId", out int value5))
+			int brawlLibraryItemId = default(int);
+			if (BattleNet.GetPartyAttribute<int>(party.Id, "WTCG.Brawl.LibraryItemId", out brawlLibraryItemId))
 			{
-				m_data.m_brawlLibraryItemId = value5;
+				m_data.m_brawlLibraryItemId = brawlLibraryItemId;
 			}
 			else
 			{
@@ -192,9 +199,10 @@ public class FriendChallengeMgr
 			}
 			else
 			{
-				BattleNet.GetAllPartyAttributes(party.Id, out var attributes);
-				Attribute[] array = attributes;
-				foreach (Attribute attribute in array)
+				Blizzard.GameService.Protocol.V2.Client.Attribute[] array = default(Blizzard.GameService.Protocol.V2.Client.Attribute[]);
+				BattleNet.GetAllPartyAttributes(party.Id, out array);
+				Blizzard.GameService.Protocol.V2.Client.Attribute[] array2 = array;
+				foreach (Blizzard.GameService.Protocol.V2.Client.Attribute attribute in array2)
 				{
 					BnetParty_OnPartyAttributeChanged(party, attribute);
 				}
@@ -246,7 +254,7 @@ public class FriendChallengeMgr
 		}
 	}
 
-	private void BnetParty_OnPartyAttributeChanged(PartyInfo party, Attribute attribute)
+	private void BnetParty_OnPartyAttributeChanged(PartyInfo party, Blizzard.GameService.Protocol.V2.Client.Attribute attribute)
 	{
 		if (party.Type != PartyType.FRIENDLY_CHALLENGE || m_data.m_partyId != party.Id)
 		{
@@ -326,7 +334,7 @@ public class FriendChallengeMgr
 		PushPartyEvent(party.Id, attribute.Name, data, bnetGameAccountId);
 	}
 
-	private void BnetParty_OnPartyAttributeChanged_DeclineReason(PartyInfo party, Attribute attribute)
+	private void BnetParty_OnPartyAttributeChanged_DeclineReason(PartyInfo party, Blizzard.GameService.Protocol.V2.Client.Attribute attribute)
 	{
 		if (party.Type != PartyType.FRIENDLY_CHALLENGE || !DidSendChallenge() || !attribute.Value.HasIntValue)
 		{
@@ -388,13 +396,13 @@ public class FriendChallengeMgr
 		}
 	}
 
-	private void BnetParty_OnPartyAttributeChanged_Error(PartyInfo party, Attribute attribute)
+	private void BnetParty_OnPartyAttributeChanged_Error(PartyInfo party, Blizzard.GameService.Protocol.V2.Client.Attribute attribute)
 	{
 		if (party.Type == PartyType.FRIENDLY_CHALLENGE)
 		{
 			if (DidReceiveChallenge() && attribute.Value.HasIntValue)
 			{
-				Log.Party.Print(Blizzard.T5.Logging.LogLevel.Error, "BnetParty_OnPartyAttributeChanged_Error - code={0}", attribute.Value.IntValue);
+				Log.Party.Print((Blizzard.T5.Logging.LogLevel)4, "BnetParty_OnPartyAttributeChanged_Error - code={0}", new object[1] { attribute.Value.IntValue });
 				BnetErrorInfo info = new BnetErrorInfo(BnetFeature.Games, BnetFeatureEvent.Games_OnCreated, (BattleNetErrors)attribute.Value.IntValue);
 				GameMgr.Get().OnBnetError(info, null);
 			}
@@ -903,7 +911,7 @@ public class FriendChallengeMgr
 				}
 			}
 		}
-		List<Attribute> list = BnetAttribute.CreateAttributeCollection(BnetAttribute.CreateAttribute("WTCG.Game.ScenarioId", m_data.m_scenarioId), BnetAttribute.CreateAttribute("WTCG.Format.Type", (long)m_data.m_challengeFormatType), BnetAttribute.CreateAttribute("WTCG.Season.Id", (long)m_data.m_seasonId));
+		List<Blizzard.GameService.Protocol.V2.Client.Attribute> list = BnetAttribute.CreateAttributeCollection(BnetAttribute.CreateAttribute("WTCG.Game.ScenarioId", m_data.m_scenarioId), BnetAttribute.CreateAttribute("WTCG.Format.Type", (long)m_data.m_challengeFormatType), BnetAttribute.CreateAttribute("WTCG.Season.Id", (long)m_data.m_seasonId));
 		if (IsChallengeTavernBrawl())
 		{
 			list.Add(BnetAttribute.CreateAttribute("WTCG.Brawl.Type", (long)m_data.m_challengeBrawlType));
@@ -959,6 +967,7 @@ public class FriendChallengeMgr
 			m_data.m_challengeeAccepted = true;
 			string name = (DidSendChallenge() ? "s1" : "s2");
 			BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute(name, "deck"));
+			AccessibilityMgr.TransitioningScreens();
 			FireChangedEvent(FriendChallengeEvent.I_ACCEPTED_CHALLENGE, m_data.m_challenger);
 		}
 	}
@@ -1121,41 +1130,48 @@ public class FriendChallengeMgr
 
 	public bool IsDeckShareEnabled()
 	{
+		if (m_simulatingChallenge)
+		{
+			return true;
+		}
+
 		if (!HasChallenge())
 		{
 			return false;
 		}
-		if (BattleNet.GetPartyAttribute(m_data.m_partyId, "isDeckShareEnabled", out string value))
+		string text = default(string);
+		if (BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "isDeckShareEnabled", out text))
 		{
-			return value == "deckShareEnabled";
+			return text == "deckShareEnabled";
 		}
 		return false;
 	}
 
 	public void RequestDeckShare()
 	{
-		string value2;
+		string text2 = default(string);
 		if (DidSendChallenge())
 		{
-			if (BattleNet.GetPartyAttribute(m_data.m_partyId, "p1DeckShareState", out string value))
+			string text = default(string);
+			if (BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p1DeckShareState", out text))
 			{
-				if (value == "sharingUnused")
+				if (text == "sharingUnused")
 				{
 					BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p1DeckShareState", "sharing"));
 				}
-				else if (value == "none")
+				else if (text == "none")
 				{
 					BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p1DeckShareState", "requested"));
 				}
 			}
 		}
-		else if (DidReceiveChallenge() && BattleNet.GetPartyAttribute(m_data.m_partyId, "p2DeckShareState", out value2))
+		else if (DidReceiveChallenge() && BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p2DeckShareState", out text2))
 		{
-			if (value2 == "sharingUnused")
+			if (text2 == "sharingUnused")
 			{
 				BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p2DeckShareState", "sharing"));
 			}
-			else if (value2 == "none")
+			else if (text2 == "none")
 			{
 				BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p2DeckShareState", "requested"));
 			}
@@ -1164,15 +1180,16 @@ public class FriendChallengeMgr
 
 	public void EndDeckShare()
 	{
-		string value2;
+		string text2 = default(string);
 		if (DidSendChallenge())
 		{
-			if (BattleNet.GetPartyAttribute(m_data.m_partyId, "p1DeckShareState", out string value) && value == "sharing")
+			string text = default(string);
+			if (BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p1DeckShareState", out text) && text == "sharing")
 			{
 				BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p1DeckShareState", "sharingUnused"));
 			}
 		}
-		else if (DidReceiveChallenge() && BattleNet.GetPartyAttribute(m_data.m_partyId, "p2DeckShareState", out value2) && value2 == "sharing")
+		else if (DidReceiveChallenge() && BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p2DeckShareState", out text2) && text2 == "sharing")
 		{
 			BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p2DeckShareState", "sharingUnused"));
 		}
@@ -1184,7 +1201,7 @@ public class FriendChallengeMgr
 		byte[] array = SerializeSharedDecks(decks);
 		if (array == null)
 		{
-			Log.Party.PrintError("{0}.ShareDecks_InternalParty(): Unable to Serialize decks!.", this);
+			Log.Party.PrintError("{0}.ShareDecks_InternalParty(): Unable to Serialize decks!.", new object[1] { this });
 			if (DidSendChallenge())
 			{
 				BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p2DeckShareState", "error"));
@@ -1210,20 +1227,20 @@ public class FriendChallengeMgr
 		{
 			return new List<CollectionDeck>(m_data.m_sharedDecks);
 		}
-		byte[] value = null;
+		byte[] array = null;
 		if (DidSendChallenge() && (m_data.m_challengerDeckShareState == "sharing" || m_data.m_challengerDeckShareState == "sharingUnused"))
 		{
-			BattleNet.GetPartyAttribute(m_data.m_partyId, "p2DeckShareDecks", out value);
+			BattleNet.GetPartyAttribute<byte[]>(m_data.m_partyId, "p2DeckShareDecks", out array);
 		}
 		else if (DidReceiveChallenge() && (m_data.m_challengeeDeckShareState == "sharing" || m_data.m_challengeeDeckShareState == "sharingUnused"))
 		{
-			BattleNet.GetPartyAttribute(m_data.m_partyId, "p1DeckShareDecks", out value);
+			BattleNet.GetPartyAttribute<byte[]>(m_data.m_partyId, "p1DeckShareDecks", out array);
 		}
-		if (value == null)
+		if (array == null)
 		{
 			return null;
 		}
-		return DeserializeSharedDecks(value);
+		return DeserializeSharedDecks(array);
 	}
 
 	private byte[] SerializeSharedDecks(List<CollectionDeck> collectionDecks)
@@ -1321,7 +1338,7 @@ public class FriendChallengeMgr
 		}
 		catch
 		{
-			Log.Party.PrintError("{0}.ShareDecks_InternalParty(): Unable to Deserialize decks!.", this);
+			Log.Party.PrintError("{0}.ShareDecks_InternalParty(): Unable to Deserialize decks!.", new object[1] { this });
 			m_data.m_sharedDecks = null;
 		}
 		return m_data.m_sharedDecks;
@@ -1355,15 +1372,16 @@ public class FriendChallengeMgr
 		{
 			return;
 		}
-		string value2;
+		string text2 = default(string);
 		if (DidSendChallenge())
 		{
-			if (BattleNet.GetPartyAttribute(m_data.m_partyId, "p1DeckShareState", out string value) && value == "requested")
+			string text = default(string);
+			if (BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p1DeckShareState", out text) && text == "requested")
 			{
 				BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p1DeckShareState", "none"));
 			}
 		}
-		else if (DidReceiveChallenge() && BattleNet.GetPartyAttribute(m_data.m_partyId, "p2DeckShareState", out value2) && value2 == "requested")
+		else if (DidReceiveChallenge() && BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p2DeckShareState", out text2) && text2 == "requested")
 		{
 			BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p2DeckShareState", "none"));
 		}
@@ -1374,22 +1392,26 @@ public class FriendChallengeMgr
 		string val = ((response == AlertPopup.Response.CANCEL) ? "declined" : "sharing");
 		if (DidSendChallenge())
 		{
-			if (BattleNet.GetPartyAttribute(m_data.m_partyId, "p2DeckShareState", out string value) && value == "requested")
+			string text = default(string);
+			if (BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p2DeckShareState", out text) && text == "requested")
 			{
 				BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p2DeckShareState", val));
 			}
-			if (BattleNet.GetPartyAttribute(m_data.m_partyId, "p1DeckShareState", out string value2) && value2 == "requested")
+			string text2 = default(string);
+			if (BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p1DeckShareState", out text2) && text2 == "requested")
 			{
 				FriendlyChallengeHelper.Get().ShowDeckShareRequestWaitingDialog(OnFriendChallengeDeckShareRequestDialogWaitingResponse);
 			}
 		}
 		else if (DidReceiveChallenge())
 		{
-			if (BattleNet.GetPartyAttribute(m_data.m_partyId, "p1DeckShareState", out string value3) && value3 == "requested")
+			string text3 = default(string);
+			if (BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p1DeckShareState", out text3) && text3 == "requested")
 			{
 				BattleNet.SetPartyAttributes(m_data.m_partyId, BnetAttribute.CreateAttribute("p1DeckShareState", val));
 			}
-			if (BattleNet.GetPartyAttribute(m_data.m_partyId, "p2DeckShareState", out string value4) && value4 == "requested")
+			string text4 = default(string);
+			if (BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p2DeckShareState", out text4) && text4 == "requested")
 			{
 				FriendlyChallengeHelper.Get().ShowDeckShareRequestWaitingDialog(OnFriendChallengeDeckShareRequestDialogWaitingResponse);
 			}
@@ -1489,6 +1511,11 @@ public class FriendChallengeMgr
 
 	private void SelectMyDeck_InternalParty(long deckId)
 	{
+		if (m_simulatingChallenge)
+		{
+			return;
+		}
+
 		string val = ((deckId == 0L) ? "deck" : "ready");
 		CardBackManager.Get().FindCardBackToUse(deckId, out var cardBackToUse, out var deckCardBack);
 		long? num = null;
@@ -1540,6 +1567,11 @@ public class FriendChallengeMgr
 
 	private void SelectMyHero_InternalParty(long heroCardDbId)
 	{
+		if (m_simulatingChallenge)
+		{
+			return;
+		}
+
 		string val = ((heroCardDbId == 0L) ? "deck" : "ready");
 		if (DidSendChallenge())
 		{
@@ -1571,9 +1603,10 @@ public class FriendChallengeMgr
 	public PartyQuestInfo GetPartyQuestInfo(BnetPartyId partyId, string attributeKey)
 	{
 		PartyQuestInfo result = null;
-		if (BattleNet.GetPartyAttribute(partyId, attributeKey, out byte[] value))
+		byte[] bytes = default(byte[]);
+		if (BattleNet.GetPartyAttribute<byte[]>(partyId, attributeKey, out bytes))
 		{
-			result = ProtobufUtil.ParseFrom<PartyQuestInfo>(value);
+			result = ProtobufUtil.ParseFrom<PartyQuestInfo>(bytes);
 		}
 		return result;
 	}
@@ -1956,6 +1989,7 @@ public class FriendChallengeMgr
 		{
 			return true;
 		}
+
 		return false;
 	}
 
@@ -1988,10 +2022,12 @@ public class FriendChallengeMgr
 		}
 		else if (flag)
 		{
-			BattleNet.GetPartyAttribute(m_data.m_partyId, "p1DeckShareState", out string value);
-			DeckShareState deckShareStateEnumFromAttribute = GetDeckShareStateEnumFromAttribute(value);
-			BattleNet.GetPartyAttribute(m_data.m_partyId, "p2DeckShareState", out string value2);
-			DeckShareState deckShareStateEnumFromAttribute2 = GetDeckShareStateEnumFromAttribute(value2);
+			string deckShareStateAttribute = default(string);
+			BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p1DeckShareState", out deckShareStateAttribute);
+			DeckShareState deckShareStateEnumFromAttribute = GetDeckShareStateEnumFromAttribute(deckShareStateAttribute);
+			string deckShareStateAttribute2 = default(string);
+			BattleNet.GetPartyAttribute<string>(m_data.m_partyId, "p2DeckShareState", out deckShareStateAttribute2);
+			DeckShareState deckShareStateEnumFromAttribute2 = GetDeckShareStateEnumFromAttribute(deckShareStateAttribute2);
 			GameMgr.Get().EnterFriendlyChallengeGameWithDecks(formatType, m_data.m_challengeBrawlType, m_data.m_scenarioId, m_data.m_seasonId, m_data.m_brawlLibraryItemId, m_data.m_challengee.GetHearthstoneGameAccountId(), deckShareStateEnumFromAttribute, m_data.m_challengerDeckId, deckShareStateEnumFromAttribute2, m_data.m_challengeeDeckId, m_data.m_challengerRandomHeroCardId, m_data.m_challengeeRandomHeroCardId, m_data.m_challengerCardBackId, m_data.m_challengeeCardBackId);
 		}
 		else
@@ -2274,6 +2310,7 @@ public class FriendChallengeMgr
 			FriendlyChallengeHelper.Get().ShowDeckShareRequestDialog(OnFriendChallengeDeckShareRequestDialogResponse);
 			break;
 		case FriendChallengeEvent.OPPONENT_ACCEPTED_DECK_SHARE_REQUEST:
+			DeckPickerTrayDisplay.Get().OnWaitingForSharedDeck();
 			FriendlyChallengeHelper.Get().HideDeckShareRequestWaitingDialog();
 			break;
 		case FriendChallengeEvent.OPPONENT_DECLINED_DECK_SHARE_REQUEST:
@@ -2308,7 +2345,7 @@ public class FriendChallengeMgr
 
 	private bool CanPromptReceivedChallenge()
 	{
-		bool flag = !UserAttentionManager.CanShowAttentionGrabber("FriendlyChallengeMgr.CanPromptReceivedChallenge");
+        bool flag = !UserAttentionManager.CanShowAttentionGrabber(false, "FriendlyChallengeMgr.CanPromptReceivedChallenge");
 		if (!flag)
 		{
 			if (GameMgr.Get().IsFindingGame())
@@ -2505,6 +2542,7 @@ public class FriendChallengeMgr
 
 	private void ShowOpponentDeclinedChallengeDialog(BnetPlayer challengee, FriendlyChallengeData challengeData)
 	{
+		AccessibilityMgr.TransitioningUIs();
 		if (m_challengeDialog != null)
 		{
 			m_challengeDialog.Hide();
@@ -2680,6 +2718,8 @@ public class FriendChallengeMgr
 
 	public bool UpdateMyAvailability()
 	{
+		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
+		//IL_008f: Expected O, but got Unknown
 		if (!Network.ShouldBeConnectedToAurora() || !Network.IsLoggedIn())
 		{
 			return false;
@@ -2687,13 +2727,13 @@ public class FriendChallengeMgr
 		bool flag = !HasAvailabilityBlocker();
 		bool canBeInvitedToBattlegrounds = GameUtils.CanCheckTutorialCompletion() && GameUtils.IsBattleGroundsTutorialComplete();
 		bool canBeInvitedToMercenaries = GameUtils.CanCheckTutorialCompletion() && GameUtils.IsMercenariesVillageTutorialComplete();
-		Log.Presence.PrintDebug("UpdateMyAvailability: Available=" + flag);
+		Log.Presence.PrintDebug("UpdateMyAvailability: Available=" + flag, Array.Empty<object>());
 		m_canBeInvitedToGame = flag;
 		m_canBeInvitedToBattlegrounds = canBeInvitedToBattlegrounds;
 		m_canBeInvitedToMercenaries = canBeInvitedToMercenaries;
 		if (!m_updateMyAvailabilityCallbackScheduledThisFrame)
 		{
-			Processor.ScheduleCallback(0f, realTime: false, UpdateMyAvailabilityScheduledCallback);
+			Processor.ScheduleCallback(0f, false, new Processor.ScheduledCallback(UpdateMyAvailabilityScheduledCallback), (object)null);
 		}
 		m_updateMyAvailabilityCallbackScheduledThisFrame = true;
 		return flag;
@@ -2704,7 +2744,7 @@ public class FriendChallengeMgr
 		if (m_updateMyAvailabilityCallbackScheduledThisFrame)
 		{
 			m_updateMyAvailabilityCallbackScheduledThisFrame = false;
-			Log.Presence.PrintDebug("UpdateMyAvailabilityScheduledCallback: Available=" + m_canBeInvitedToGame);
+			Log.Presence.PrintDebug("UpdateMyAvailabilityScheduledCallback: Available=" + m_canBeInvitedToGame, Array.Empty<object>());
 			BnetPresenceMgr.Get().SetGameField(1u, m_canBeInvitedToGame);
 			BnetNearbyPlayerMgr.Get().SetAvailability(m_canBeInvitedToGame);
 			BnetNearbyPlayerMgr.Get().SetBattlegroundsAvailability(m_canBeInvitedToBattlegrounds);
@@ -2742,11 +2782,11 @@ public class FriendChallengeMgr
 		}
 		if (availabilityBlockerReasons == AvailabilityBlockerReasons.NONE)
 		{
-			availabilityBlockerReasons = UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: true);
+			availabilityBlockerReasons = UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: true);
 		}
 		if (availabilityBlockerReasons != 0)
 		{
-			Log.Presence.PrintDebug("GetAvailabilityBlockerReason: " + availabilityBlockerReasons);
+			Log.Presence.PrintDebug("GetAvailabilityBlockerReason: " + availabilityBlockerReasons, Array.Empty<object>());
 		}
 		return availabilityBlockerReasons;
 	}
@@ -2780,6 +2820,7 @@ public class FriendChallengeMgr
 		bool flag = (!DidSendChallenge() && m_data.m_challengeeDeckOrHeroSelected) || (DidSendChallenge() && m_data.m_challengerDeckOrHeroSelected);
 		if (m_challengeDialog != null && !flag)
 		{
+			AccessibilityMgr.TransitioningScreens();
 			m_challengeDialog.Hide();
 			m_challengeDialog = null;
 		}
@@ -2846,4 +2887,102 @@ public class FriendChallengeMgr
 		}
 		return false;
 	}
+
+	#region Accessibility testing
+
+	private bool m_simulatingChallenge;
+
+	internal void Cheat_SimulateChallenge(BnetPlayer challenger, FormatType formatType)
+	{
+		m_data = new FriendlyChallengeData();
+		m_data.m_challenger = challenger;
+		m_data.m_challengee = BnetPresenceMgr.Get().GetMyPlayer();
+		m_data.m_challengerId = m_data.m_challenger.GetHearthstoneGameAccount().GetId();
+		m_hasSeenDeclinedReason = false;
+		m_data.m_scenarioId = 2;
+		m_data.m_seasonId = 0;
+		m_data.m_challengeFormatType = formatType;
+
+		m_simulatingChallenge = true;
+
+		DialogManager.Get().ShowFriendlyChallenge(formatType, challenger, false, PartyType.FRIENDLY_CHALLENGE, null, Cheat_OnChallengeReceivedDialogResponse, Cheat_OnChallengeReceivedDialogProcessed);
+	}
+
+	internal void Cheat_SimulateBattlegroundsPartyInvite(BnetPlayer challenger)
+	{
+		var formatType = FormatType.FT_WILD;
+
+		m_data = new FriendlyChallengeData();
+		m_data.m_challenger = challenger;
+		m_data.m_challengee = BnetPresenceMgr.Get().GetMyPlayer();
+		m_data.m_challengerId = m_data.m_challenger.GetHearthstoneGameAccount().GetId();
+		m_hasSeenDeclinedReason = false;
+		m_data.m_scenarioId = 2;
+		m_data.m_seasonId = 0;
+		m_data.m_challengeFormatType = formatType;
+
+		DialogManager.Get().ShowFriendlyChallenge(formatType, challenger, false, PartyType.BATTLEGROUNDS_PARTY, null, Cheat_OnBattlegroundsPartyInviteReceivedDialogResponse, Cheat_OnBattlegroundsPartyInviteReceivedDialogProcessed);
+	}
+
+	private bool Cheat_OnBattlegroundsPartyInviteReceivedDialogProcessed(DialogBase dialog, object userData)
+	{
+		return true;
+	}
+	private void Cheat_OnBattlegroundsPartyInviteReceivedDialogResponse(bool accept)
+	{
+		if (accept)
+		{
+			InGameSystemTests.Output("Accepted invite");
+		}
+		else
+		{
+			InGameSystemTests.Output("Declined invite");
+		}
+	}
+
+	internal void Cheat_SimulateBattlegroundsSuggestionPopup(BnetGameAccountId playerToInviteGameAccountId, string playerToInviteName, BnetGameAccountId suggesterGameAccountId, string suggesterName)
+	{
+		DialogManager.Get().ShowBattlegroundsSuggestion(playerToInviteGameAccountId, playerToInviteName, suggesterGameAccountId, suggesterName, Cheat_OnBattlegroundsSuggestionReceivedResponse);
+	}
+
+	private void Cheat_OnBattlegroundsSuggestionReceivedResponse(bool accept, BnetGameAccountId playerToInvite)
+	{
+		if (accept)
+		{
+			InGameSystemTests.Output("Accepted suggestion");
+		}
+		else
+		{
+			InGameSystemTests.Output("Declined suggestion");
+		}
+	}
+
+	internal void Cheat_Cleanup()
+	{
+		m_data = null;
+		m_simulatingChallenge = false;
+	}
+
+	private bool Cheat_OnChallengeReceivedDialogProcessed(DialogBase dialog, object userData)
+	{
+		m_challengeDialog = dialog;
+		return true;
+	}
+
+	private void Cheat_OnChallengeReceivedDialogResponse(bool accept)
+	{
+		if (accept)
+		{
+			AccessibilityMgr.TransitioningScreens();
+
+			m_challengeDialog?.Hide();
+			m_challengeDialog = null;
+
+			Navigation.Clear();
+			Options.SetFormatType(FormatType.FT_STANDARD);
+			SceneMgr.Get().SetNextMode(SceneMgr.Mode.FRIENDLY);
+		}
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/FriendListChallengeButton.cs b/Assembly-CSharp/FriendListChallengeButton.cs
index 538c6d6..0f38b43 100644
--- a/Assembly-CSharp/FriendListChallengeButton.cs
+++ b/Assembly-CSharp/FriendListChallengeButton.cs
@@ -1,4 +1,5 @@
 using System.Collections;
+using Blizzard.GameService.SDK.Client.Integration;
 using Hearthstone.UI;
 using UnityEngine;
 
@@ -19,6 +20,10 @@ public class FriendListChallengeButton : MonoBehaviour
 
 	public FriendListFriendFrame FriendFrame { get; set; }
 
+	#region Accessibility
+	private static string CLOSE_CHALLENGE_MENU_EVENT_NAME = "CODE_FLYOUT_MENU_DISMISSED";
+	#endregion
+
 	protected void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
@@ -51,7 +56,7 @@ public class FriendListChallengeButton : MonoBehaviour
 		m_flyoutMenuWidget.transform.position = friendListFrame.friendFlyoutBone.transform.position;
 		m_flyoutMenuWidget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "CODE_FLYOUT_MENU_DISMISSED")
+			if (eventName == CLOSE_CHALLENGE_MENU_EVENT_NAME)
 			{
 				FriendFrame.CloseChallengeMenu();
 			}
@@ -79,7 +84,7 @@ public class FriendListChallengeButton : MonoBehaviour
 		{
 			m_flyoutMenu.UpdateFlyoutMenu();
 		}
-	}
+  }
 
 	public void DismissPopups(bool showAlert = false)
 	{
@@ -88,4 +93,218 @@ public class FriendListChallengeButton : MonoBehaviour
 			m_flyoutMenu.DismissPopups(showAlert);
 		}
 	}
+
+	#region Accessibility
+
+	internal enum ChallengeButtonState
+	{
+		UNKNOWN,
+		CHALLENGE,
+		SPECTATE,
+		KICK_SPECTATOR,
+		REVEAL_CARDS_TO_OPPONENT_SPECTATOR,
+		INVITE_PLAYER_TO_SPECTATE,
+		INVITED_PLAYER_TO_SPECTATE,
+		CANNOT_INTERACT,
+	};
+
+	internal class ChallengeButtonDataModel
+    {
+		internal string text;
+		internal string text2;
+		internal ChallengeButtonState state;
+		internal bool canClickButton;
+
+		internal ChallengeButtonDataModel(string text, string text2, ChallengeButtonState state, bool canClickButton)
+        {
+			this.text = text;
+			this.text2 = text2;
+			this.state = state;
+			this.canClickButton = canClickButton;
+        }
+    }
+
+	internal ChallengeButtonDataModel GetChallengeButtonDataModel()
+    {
+		string text = string.Empty;
+		string text2 = string.Empty;
+		ChallengeButtonState state = ChallengeButtonState.UNKNOWN;
+		bool canClickButton = true;
+
+		BnetGameAccountId hearthstoneGameAccountId = m_player.GetHearthstoneGameAccountId();
+		SpectatorManager spectatorManager = SpectatorManager.Get();
+		bool flag = PartyManager.Get().IsInBattlegroundsParty() && !SceneMgr.Get().IsInGame() && !GameMgr.Get().IsFindingGame();
+		if (ChatMgr.Get().FriendListFrame.EditMode != FriendListFrame.FriendListEditMode.REMOVE_FRIENDS)
+		{
+			if (flag && PartyManager.Get().CanInvite(hearthstoneGameAccountId))
+			{
+				text = "GLOBAL_FRIENDLIST_BATTLEGROUNDS_TOOLTIP_INVITE_HEADER";
+				text2 = "GLOBAL_FRIENDLIST_BATTLEGROUNDS_TOOLTIP_INVITE_BODY";
+				state = ChallengeButtonState.CHALLENGE;
+				canClickButton = true;
+			}
+			else if (flag && PartyManager.Get().CanKick(hearthstoneGameAccountId))
+			{
+				text = "GLOBAL_FRIENDLIST_BATTLEGROUNDS_TOOLTIP_KICK_HEADER";
+				text2 = "GLOBAL_FRIENDLIST_BATTLEGROUNDS_TOOLTIP_KICK_BODY";
+				state = ChallengeButtonState.CANNOT_INTERACT;
+				canClickButton = false;
+			}
+			else if (flag && !PartyManager.Get().IsPartyLeader() && BnetFriendMgr.Get().IsFriend(m_player))
+			{
+				text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
+				text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_BATTLEGROUNDS_PARTY_MEMBER";
+				state = ChallengeButtonState.CANNOT_INTERACT;
+				canClickButton = false;
+			}
+			else if (spectatorManager.HasInvitedMeToSpectate(hearthstoneGameAccountId))
+			{
+				text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_AVAILABLE_HEADER";
+				text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_RECEIVED_INVITE_TEXT";
+				state = ChallengeButtonState.SPECTATE;
+				canClickButton = true;
+			}
+			else if (!spectatorManager.CanSpectate(m_player))
+			{
+				if (spectatorManager.IsSpectatingMe(hearthstoneGameAccountId))
+				{
+					text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_KICK_HEADER";
+					text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_KICK_TEXT";
+					state = ChallengeButtonState.KICK_SPECTATOR;
+                    canClickButton = true;
+                }
+                else if (spectatorManager.CanInviteToSpectateMyGame(hearthstoneGameAccountId))
+				{
+					if (spectatorManager.IsPlayerSpectatingMyGamesOpposingSide(hearthstoneGameAccountId))
+					{
+						text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITE_OTHER_SIDE_HEADER";
+						text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITE_OTHER_SIDE_TEXT";
+						state = ChallengeButtonState.REVEAL_CARDS_TO_OPPONENT_SPECTATOR;
+                        canClickButton = true;
+                    }
+                    else
+					{
+						text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITE_HEADER";
+						text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITE_TEXT";
+						state = ChallengeButtonState.INVITE_PLAYER_TO_SPECTATE;
+                        canClickButton = true;
+					}
+				}
+				else if (spectatorManager.IsInvitedToSpectateMyGame(hearthstoneGameAccountId))
+				{
+					text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITED_HEADER";
+					text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_INVITED_TEXT";
+					state = ChallengeButtonState.INVITED_PLAYER_TO_SPECTATE;
+                    canClickButton = false;
+                }
+                else if (spectatorManager.IsSpectatingPlayer(hearthstoneGameAccountId))
+				{
+					text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_SPECTATING_HEADER";
+					text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_SPECTATING_TEXT";
+					state = ChallengeButtonState.CANNOT_INTERACT;
+                    canClickButton = false;
+				}
+				else if (spectatorManager.HasPreviouslyKickedMeFromGame(hearthstoneGameAccountId, SpectatorManager.GetSpectatorGameHandleFromPlayer(m_player)))
+				{
+					text = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_PREVIOUSLY_KICKED_HEADER";
+					text2 = "GLOBAL_FRIENDLIST_SPECTATE_TOOLTIP_PREVIOUSLY_KICKED_TEXT";
+					state = ChallengeButtonState.SPECTATE;
+                    canClickButton = false;
+				}
+				else
+				{
+                    text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
+
+                    if (!FriendChallengeMgr.Get().AmIAvailable())
+                    {
+                        if (BnetPresenceMgr.Get().GetMyPlayer().IsAppearingOffline())
+                        {
+                            text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_IM_APPEARING_OFFLINE";
+							state = ChallengeButtonState.CHALLENGE;
+							canClickButton = false;
+                        }
+                        else
+                        {
+                            if (!flag || BnetFriendMgr.Get().IsFriend(m_player))
+                            {
+                                text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_IM_UNAVAILABLE";
+                                state = ChallengeButtonState.CHALLENGE;
+                                canClickButton = false;
+                            }
+                            else
+                            {
+                                text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_AVAILABLE";
+								state = ChallengeButtonState.CHALLENGE;
+								canClickButton = true;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (!FriendChallengeMgr.Get().CanChallenge(m_player) && BnetFriendMgr.Get().IsFriend(m_player))
+                        {
+                            text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_THEYRE_UNAVAILABLE";
+                            state = ChallengeButtonState.CHALLENGE;
+                            canClickButton = false;
+                        }
+                        else
+                        {
+                            if ((!BnetRecentPlayerMgr.Get().IsCurrentOpponent(m_player) && !BnetRecentPlayerMgr.Get().IsRecentStranger(m_player)) || BnetNearbyPlayerMgr.Get().IsNearbyStranger(m_player))
+                            {
+                                text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_AVAILABLE";
+                                state = ChallengeButtonState.CHALLENGE;
+                                canClickButton = true;
+                            }
+                            else
+                            {
+                                text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_UNAVAILABLE";
+                                state = ChallengeButtonState.CHALLENGE;
+                                canClickButton = false;
+                            }
+                        }
+                    }
+                }
+            }
+      else
+      {
+        state = ChallengeButtonState.SPECTATE;
+        canClickButton = true;
+      }
+    }
+
+		if (UniversalInputManager.Get().IsTouchMode())
+		{
+			if (GameStrings.HasKey(text + "_TOUCH"))
+			{
+				text += "_TOUCH";
+			}
+			if (GameStrings.HasKey(text2 + "_TOUCH"))
+			{
+				text2 += "_TOUCH";
+			}
+		}
+
+		return new ChallengeButtonDataModel(text, text2, state, canClickButton);
+    }
+
+	internal string FormatHeadline(string text)
+    {
+        return GameStrings.Get(text);
+    }
+
+	internal string FormatBodytext(string text2)
+    {
+        return GameStrings.Format(text2, m_player.GetBestName());
+    }
+
+	internal void CloseChallengeMenu()
+	{
+		m_flyoutMenuWidget.TriggerEvent(CLOSE_CHALLENGE_MENU_EVENT_NAME);
+	}
+
+	internal void CloseFriendsListMenu()
+	{
+		ChatMgr.Get().CloseFriendsList();
+	}
+  #endregion
 }
diff --git a/Assembly-CSharp/FriendListChallengeMenu.cs b/Assembly-CSharp/FriendListChallengeMenu.cs
new file mode 100644
index 0000000..0cb326f
--- /dev/null
+++ b/Assembly-CSharp/FriendListChallengeMenu.cs
@@ -0,0 +1,777 @@
+using Blizzard.GameService.SDK.Client.Integration;
+using PegasusShared;
+using System;
+using UnityEngine;
+
+public class FriendListChallengeMenu : MonoBehaviour
+{
+	public UIBButton m_StandardDuelButton;
+
+	public UIBButton m_WildDuelButton;
+
+	public UIBButton m_ClassicDuelButton;
+
+	public UIBButton m_TavernBrawlButton;
+
+	public UIBButton m_BaconButton;
+
+	public UIBButton m_MercenariesFriendlyButton;
+
+	public UIBButton m_AddAsFriendButton;
+
+	public UIBButton m_SpectateButton;
+
+	public TooltipZone m_StandardDuelTooltipZone;
+
+	public TooltipZone m_WildDuelTooltipZone;
+
+	public TooltipZone m_ClassicDuelTooltipZone;
+
+	public TooltipZone m_TavernBrawlTooltipZone;
+
+	public TooltipZone m_BaconTooltipZone;
+
+	public TooltipZone m_MercenariesFriendlyTooltipZone;
+
+	public GameObject m_StandardDuelButtonX;
+
+	public GameObject m_StandardDuelButtonDisabled;
+
+	public GameObject m_WildDuelButtonX;
+
+	public GameObject m_WildDuelButtonDisabled;
+
+	public GameObject m_ClassicDuelButtonX;
+
+	public GameObject m_ClassicDuelButtonDisabled;
+
+	public GameObject m_TavernBrawlButtonX;
+
+	public GameObject m_TavernBrawlButtonDisabled;
+
+	public GameObject m_BaconButtonDisabled;
+
+	public GameObject m_MercenariesFriendlyButtonDisabled;
+
+	public MultiSliceElement m_FrameContainer;
+
+	public MultiSliceElement m_ShadowContainer;
+
+	public GameObject m_MiddleFrame;
+
+	public GameObject m_MiddleShadow;
+
+	public GameObject m_FiresideBrawlButtonGlow;
+
+	public UberText m_SpectateText;
+
+	public float m_middleFrameScaleOffsetForWild = 0.5f;
+
+	public float m_middleShadowScaleOffsetForWild = 0.1f;
+
+	public float m_middleFrameScaleOffsetForSpectateMode = 0.5f;
+
+	public float m_middleShadowScaleOffsetForSpectateMode = 0.16f;
+
+	public float m_middleFrameScaleOffsetForAddFriend = 0.63f;
+
+	public float m_middleShadowScaleOffsetForAddFriend = 0.12f;
+
+	public float m_middleFrameScaleOffsetForRecentStranger = 3.15f;
+
+	public float m_middleShadowScaleOffsetForRecentStranger = 0.5f;
+
+	private FriendListChallengeButton m_challengeButton;
+
+	private bool m_bHasStandardDeck;
+
+	private bool m_bHasWildDeck;
+
+	private bool m_bHasClassicDeck;
+
+	private bool m_bHasTavernBrawlDeck;
+
+	private bool m_bCanChallengeTavernBrawl;
+
+	private bool m_bIsTavernBrawlUnlocked;
+
+	private float m_defaultMiddleFrameScaleY;
+
+	private float m_defaultMiddleShadowScaleY;
+
+	private Vector3 m_defaultAddAsFriendButtonPosition;
+
+	private static readonly PlatformDependentValue<Vector3> CHALLENGE_MENU_DEFAULT_POSITION = new PlatformDependentValue<Vector3>(PlatformCategory.Screen)
+	{
+		PC = new Vector3(205.9f, -130f, 0f),
+		Phone = new Vector3(184.9f, -130f, 0f)
+	};
+
+	private void Awake()
+	{
+		m_challengeButton = GetComponentInParent<FriendListChallengeButton>();
+		m_defaultMiddleFrameScaleY = m_MiddleFrame.transform.localScale.y;
+		m_defaultMiddleShadowScaleY = m_MiddleShadow.transform.localScale.y;
+		m_defaultAddAsFriendButtonPosition = m_AddAsFriendButton.gameObject.transform.localPosition;
+	}
+
+	private void Start()
+	{
+		m_StandardDuelButton.AddEventListener(UIEventType.RELEASE, OnStandardDuelButtonReleased);
+		m_WildDuelButton.AddEventListener(UIEventType.RELEASE, OnWildDuelButtonReleased);
+		m_ClassicDuelButton.AddEventListener(UIEventType.RELEASE, OnClassicDuelButtonReleased);
+		m_TavernBrawlButton.AddEventListener(UIEventType.RELEASE, OnRegularTavernBrawlButtonReleased);
+		m_BaconButton.AddEventListener(UIEventType.RELEASE, OnBaconButtonReleased);
+		m_MercenariesFriendlyButton.AddEventListener(UIEventType.RELEASE, OnMercenariesFriendlyButtonReleased);
+		m_AddAsFriendButton.AddEventListener(UIEventType.RELEASE, OnAddAsFriendButtonReleased);
+		m_SpectateButton.AddEventListener(UIEventType.RELEASE, OnSpectateButtonReleased);
+		InitializeButtonLayout();
+		InitializeMenuPosition();
+	}
+
+	private void OnEnable()
+	{
+		InitializeButtonLayout();
+		InitializeMenuPosition();
+	}
+
+	public void InitializeButtonLayout()
+	{
+		if (m_challengeButton == null)
+		{
+			return;
+		}
+		BnetPlayer player = m_challengeButton.GetPlayer();
+		if (player == null)
+		{
+			return;
+		}
+		float num = m_defaultMiddleFrameScaleY;
+		float num2 = m_defaultMiddleShadowScaleY;
+		bool flag = FriendChallengeMgr.Get().CanChallenge(player);
+		if (flag || BnetNearbyPlayerMgr.Get().IsNearbyStranger(player))
+		{
+			m_SpectateButton.gameObject.SetActive(value: false);
+			m_SpectateText.gameObject.SetActive(value: false);
+			m_StandardDuelButton.gameObject.SetActive(value: true);
+			m_WildDuelButton.gameObject.SetActive(value: true);
+			m_ClassicDuelButton.gameObject.SetActive(value: true);
+			m_TavernBrawlButton.gameObject.SetActive(value: true);
+			m_BaconButton.gameObject.SetActive(value: true);
+			m_MercenariesFriendlyButton.gameObject.SetActive(value: true);
+			bool flag2 = !flag || PartyManager.Get().IsInBattlegroundsParty();
+			bool flag3 = GameUtils.IsTraditionalTutorialComplete();
+			NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+			if (!netObject.Games.Friendly || flag2 || !flag3)
+			{
+				DisableDuelButton(m_StandardDuelButton, m_StandardDuelButtonDisabled);
+				DisableDuelButton(m_WildDuelButton, m_WildDuelButtonDisabled);
+				DisableDuelButton(m_ClassicDuelButton, m_ClassicDuelButtonDisabled);
+				m_StandardDuelButton.RemoveEventListener(UIEventType.RELEASE, OnStandardDuelButtonReleased);
+				m_StandardDuelButton.AddEventListener(UIEventType.ROLLOVER, OnStandardDuelButtonOver);
+				m_WildDuelButton.RemoveEventListener(UIEventType.RELEASE, OnWildDuelButtonReleased);
+				m_WildDuelButton.AddEventListener(UIEventType.ROLLOVER, OnWildDuelButtonOver);
+				m_ClassicDuelButton.RemoveEventListener(UIEventType.RELEASE, OnClassicDuelButtonReleased);
+				m_ClassicDuelButton.AddEventListener(UIEventType.ROLLOVER, OnClassicDuelButtonOver);
+			}
+			if (!netObject.Games.BattlegroundsFriendlyChallenge || flag2 || !player.GetHearthstoneGameAccount().GetBattlegroundsTutorialComplete() || !GameUtils.IsBattleGroundsTutorialComplete())
+			{
+				DisableBaconButton();
+			}
+			if (!netObject.Games.MercenariesFriendly || flag2 || !player.GetHearthstoneGameAccount().GetMercenariesTutorialComplete() || !GameUtils.IsMercenariesVillageTutorialComplete())
+			{
+				DisableMercenariesFriendlyButton();
+			}
+			if (!CollectionManager.Get().ShouldAccountSeeStandardWild())
+			{
+				m_StandardDuelButton.SetText("GLOBAL_FRIENDLIST_CHALLENGE_MENU_DUEL_BUTTON");
+				m_TavernBrawlButton.gameObject.transform.localPosition = m_WildDuelButton.gameObject.transform.localPosition;
+				float num3 = m_StandardDuelButton.transform.localPosition.y - m_TavernBrawlButton.transform.localPosition.y;
+				m_BaconButton.gameObject.transform.localPosition = m_TavernBrawlButton.gameObject.transform.localPosition - Vector3.up * num3;
+				float num4 = m_StandardDuelButton.transform.localPosition.y - m_TavernBrawlButton.transform.localPosition.y;
+				m_MercenariesFriendlyButton.gameObject.transform.localPosition = m_BaconButton.gameObject.transform.localPosition - Vector3.up * num4;
+				float num5 = m_StandardDuelButton.transform.localPosition.y - m_ClassicDuelButton.transform.localPosition.y;
+				m_AddAsFriendButton.gameObject.transform.localPosition = m_defaultAddAsFriendButtonPosition + Vector3.up * num5;
+				m_WildDuelButton.gameObject.SetActive(value: false);
+				m_ClassicDuelButton.gameObject.SetActive(value: false);
+				num -= m_middleFrameScaleOffsetForWild * 2f;
+				num2 -= m_middleShadowScaleOffsetForWild * 2f;
+				m_MiddleFrame.transform.localScale = new Vector3(m_MiddleFrame.transform.localScale.x, num, m_MiddleFrame.transform.localScale.z);
+				m_MiddleShadow.transform.localScale = new Vector3(m_MiddleShadow.transform.localScale.x, num2, m_MiddleShadow.transform.localScale.z);
+			}
+			m_bHasStandardDeck = CollectionManager.Get().AccountHasValidDeck(FormatType.FT_STANDARD);
+			m_bHasWildDeck = CollectionManager.Get().AccountHasAnyValidDeck();
+			m_bHasClassicDeck = CollectionManager.Get().AccountHasValidDeck(FormatType.FT_CLASSIC);
+			m_bCanChallengeTavernBrawl = TavernBrawlManager.Get().CanChallengeToTavernBrawl(BrawlType.BRAWL_TYPE_TAVERN_BRAWL);
+			m_bIsTavernBrawlUnlocked = TavernBrawlManager.Get().HasUnlockedTavernBrawl(BrawlType.BRAWL_TYPE_TAVERN_BRAWL);
+			if (m_bCanChallengeTavernBrawl && flag && flag3)
+			{
+				TavernBrawlMission mission = TavernBrawlManager.Get().GetMission(BrawlType.BRAWL_TYPE_TAVERN_BRAWL);
+				m_bHasTavernBrawlDeck = !mission.canCreateDeck || TavernBrawlManager.Get().HasValidDeck(BrawlType.BRAWL_TYPE_TAVERN_BRAWL);
+			}
+			else
+			{
+				DisableTavernBrawlButton();
+			}
+			SetupAddFriendButtonAndFixFrameLength(num, num2);
+			m_FrameContainer.UpdateSlices();
+			m_ShadowContainer.UpdateSlices();
+			if (!CollectionManager.Get().AreAllDeckContentsReady() && CollectionManager.Get().RequestDeckContentsForDecksWithoutContentsLoaded(OnDeckContents_UpdateButtons))
+			{
+				m_bHasStandardDeck = true;
+				m_bHasWildDeck = true;
+				m_bHasClassicDeck = true;
+			}
+		}
+		else if (SpectatorManager.Get().CanSpectate(player))
+		{
+			m_SpectateButton.gameObject.SetActive(value: true);
+			m_SpectateText.gameObject.SetActive(value: true);
+			m_SpectateText.Text = GameStrings.Format("GLOBAL_FRIENDLIST_SPECTATE_MENU_DESCRIPTION", player.GetBestName());
+			m_StandardDuelButton.gameObject.SetActive(value: false);
+			m_WildDuelButton.gameObject.SetActive(value: false);
+			m_ClassicDuelButton.gameObject.SetActive(value: false);
+			m_TavernBrawlButton.gameObject.SetActive(value: false);
+			m_BaconButton.gameObject.SetActive(value: false);
+			m_MercenariesFriendlyButton.gameObject.SetActive(value: false);
+			num -= m_middleFrameScaleOffsetForSpectateMode;
+			num2 -= m_middleShadowScaleOffsetForSpectateMode;
+			SetupAddFriendButtonAndFixFrameLength(num, num2);
+			m_FrameContainer.UpdateSlices();
+			m_ShadowContainer.UpdateSlices();
+		}
+		else if (BnetRecentPlayerMgr.Get().IsRecentStranger(player))
+		{
+			m_SpectateButton.gameObject.SetActive(value: false);
+			m_SpectateText.gameObject.SetActive(value: false);
+			m_StandardDuelButton.gameObject.SetActive(value: false);
+			m_WildDuelButton.gameObject.SetActive(value: false);
+			m_ClassicDuelButton.gameObject.SetActive(value: false);
+			m_TavernBrawlButton.gameObject.SetActive(value: false);
+			m_BaconButton.gameObject.SetActive(value: false);
+			m_MercenariesFriendlyButton.gameObject.SetActive(value: false);
+			m_AddAsFriendButton.gameObject.transform.localPosition = m_StandardDuelButton.transform.localPosition;
+			num -= m_middleFrameScaleOffsetForRecentStranger;
+			num2 -= m_middleShadowScaleOffsetForRecentStranger;
+			SetupAddFriendButtonAndFixFrameLength(num, num2);
+			m_FrameContainer.UpdateSlices();
+			m_ShadowContainer.UpdateSlices();
+		}
+		UpdateActiveChallengeButtons();
+	}
+
+	public void InitializeMenuPosition()
+	{
+		base.transform.localPosition = CHALLENGE_MENU_DEFAULT_POSITION;
+		Bounds bounds = base.gameObject.GetComponent<Collider>().bounds;
+		Camera camera = CameraUtils.FindFirstByLayer(base.gameObject.layer);
+		Vector3 vector = camera.WorldToScreenPoint(new Vector3(bounds.min.x, bounds.min.y, bounds.center.z));
+		if (vector.y < 0f)
+		{
+			Vector3 vector2 = camera.WorldToScreenPoint(base.transform.position);
+			base.transform.position = camera.ScreenToWorldPoint(new Vector3(vector2.x, vector2.y - vector.y, vector2.z));
+		}
+	}
+
+	private void DisableDuelButton(UIBButton buttonToDisable, GameObject disabledVisual)
+	{
+		disabledVisual.SetActive(value: true);
+		buttonToDisable.gameObject.GetComponent<UIBHighlight>().m_MouseOverHighlight = null;
+		buttonToDisable.AddEventListener(UIEventType.ROLLOUT, OnButtonOut);
+	}
+
+	private void DisableTavernBrawlButton()
+	{
+		DisableDuelButton(m_TavernBrawlButton, m_TavernBrawlButtonDisabled);
+		m_TavernBrawlButton.RemoveEventListener(UIEventType.RELEASE, OnRegularTavernBrawlButtonReleased);
+		m_TavernBrawlButton.AddEventListener(UIEventType.ROLLOVER, OnTavernBrawlButtonOver);
+	}
+
+	private void DisableBaconButton()
+	{
+		DisableDuelButton(m_BaconButton, m_BaconButtonDisabled);
+		m_BaconButton.RemoveEventListener(UIEventType.RELEASE, OnBaconButtonReleased);
+		m_BaconButton.AddEventListener(UIEventType.ROLLOVER, OnBaconButtonOver);
+	}
+
+	private void DisableMercenariesFriendlyButton()
+	{
+		DisableDuelButton(m_MercenariesFriendlyButton, m_MercenariesFriendlyButtonDisabled);
+		m_MercenariesFriendlyButton.RemoveEventListener(UIEventType.RELEASE, OnMercenariesFriendlyButtonReleased);
+		m_MercenariesFriendlyButton.AddEventListener(UIEventType.ROLLOVER, OnMercenariesFriendlyButtonOver);
+	}
+
+	private void UpdateActiveChallengeButtons()
+	{
+		m_StandardDuelButtonX.SetActive(!m_bHasStandardDeck);
+		m_WildDuelButtonX.SetActive(!m_bHasWildDeck);
+		m_ClassicDuelButtonX.SetActive(!m_bHasClassicDeck);
+		m_TavernBrawlButtonX.SetActive(m_bCanChallengeTavernBrawl && (!m_bIsTavernBrawlUnlocked || !m_bHasTavernBrawlDeck));
+	}
+
+	private void OnDeckContents_UpdateButtons()
+	{
+		if (!(this == null))
+		{
+			m_bHasStandardDeck = CollectionManager.Get().AccountHasValidDeck(FormatType.FT_STANDARD);
+			m_bHasWildDeck = CollectionManager.Get().AccountHasAnyValidDeck();
+			m_bHasClassicDeck = CollectionManager.Get().AccountHasValidDeck(FormatType.FT_CLASSIC);
+			UpdateActiveChallengeButtons();
+		}
+	}
+
+	private void OnStandardDuelButtonOver(UIEvent e)
+	{
+		string text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
+		string text2 = GetDescriptionTextWhenUnavailable();
+		if (!NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().Games.Friendly)
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_MODE_UNAVAILABLE";
+		}
+		if (UniversalInputManager.Get().IsTouchMode())
+		{
+			if (GameStrings.HasKey(text + "_TOUCH"))
+			{
+				text += "_TOUCH";
+			}
+			if (GameStrings.HasKey(text2 + "_TOUCH"))
+			{
+				text2 += "_TOUCH";
+			}
+		}
+		if (!GameUtils.IsTraditionalTutorialComplete())
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_TRADITIONAL_LOCKED";
+		}
+		ShowTooltip(text, text2, m_StandardDuelTooltipZone, m_StandardDuelButton);
+	}
+
+	private void OnWildDuelButtonOver(UIEvent e)
+	{
+		string text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
+		string text2 = GetDescriptionTextWhenUnavailable();
+		if (!NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().Games.Friendly)
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_MODE_UNAVAILABLE";
+		}
+		if (UniversalInputManager.Get().IsTouchMode())
+		{
+			if (GameStrings.HasKey(text + "_TOUCH"))
+			{
+				text += "_TOUCH";
+			}
+			if (GameStrings.HasKey(text2 + "_TOUCH"))
+			{
+				text2 += "_TOUCH";
+			}
+		}
+		if (!GameUtils.IsTraditionalTutorialComplete())
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_TRADITIONAL_LOCKED";
+		}
+		ShowTooltip(text, text2, m_WildDuelTooltipZone, m_WildDuelButton);
+	}
+
+	private void OnClassicDuelButtonOver(UIEvent e)
+	{
+		string text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
+		string text2 = GetDescriptionTextWhenUnavailable();
+		if (!NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().Games.Friendly)
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_MODE_UNAVAILABLE";
+		}
+		if (UniversalInputManager.Get().IsTouchMode())
+		{
+			if (GameStrings.HasKey(text + "_TOUCH"))
+			{
+				text += "_TOUCH";
+			}
+			if (GameStrings.HasKey(text2 + "_TOUCH"))
+			{
+				text2 += "_TOUCH";
+			}
+		}
+		if (!GameUtils.IsTraditionalTutorialComplete())
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_TRADITIONAL_LOCKED";
+		}
+		ShowTooltip(text, text2, m_ClassicDuelTooltipZone, m_ClassicDuelButton);
+	}
+
+	private void OnTavernBrawlButtonOver(UIEvent e)
+	{
+		string text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
+		string text2 = GetDescriptionTextWhenUnavailable();
+		if (!TavernBrawlManager.Get().IsTavernBrawlActive(BrawlType.BRAWL_TYPE_TAVERN_BRAWL))
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_TOOLTIP_NO_TAVERN_BRAWL";
+		}
+		else if (TavernBrawlManager.Get().IsTavernBrawlActive(BrawlType.BRAWL_TYPE_TAVERN_BRAWL) && !TavernBrawlManager.Get().CanChallengeToTavernBrawl(BrawlType.BRAWL_TYPE_TAVERN_BRAWL))
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_TOOLTIP_TAVERN_BRAWL_NOT_CHALLENGEABLE";
+		}
+		if (UniversalInputManager.Get().IsTouchMode())
+		{
+			if (GameStrings.HasKey(text + "_TOUCH"))
+			{
+				text += "_TOUCH";
+			}
+			if (GameStrings.HasKey(text2 + "_TOUCH"))
+			{
+				text2 += "_TOUCH";
+			}
+		}
+		if (!GameUtils.IsTraditionalTutorialComplete())
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_TAVERN_BRAWL_LOCKED";
+		}
+		ShowTooltip(text, text2, m_TavernBrawlTooltipZone, m_TavernBrawlButton);
+	}
+
+	private void OnBaconButtonOver(UIEvent e)
+	{
+		string text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
+		string text2 = GetDescriptionTextWhenUnavailable();
+		if (!NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().Games.BattlegroundsFriendlyChallenge)
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_MODE_UNAVAILABLE";
+		}
+		if (UniversalInputManager.Get().IsTouchMode())
+		{
+			if (GameStrings.HasKey(text + "_TOUCH"))
+			{
+				text += "_TOUCH";
+			}
+			if (GameStrings.HasKey(text2 + "_TOUCH"))
+			{
+				text2 += "_TOUCH";
+			}
+		}
+		bool battlegroundsTutorialComplete = m_challengeButton.GetPlayer().GetHearthstoneGameAccount().GetBattlegroundsTutorialComplete();
+		if (!GameUtils.IsBattleGroundsTutorialComplete())
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_BATTLEGROUNDS_LOCKED";
+		}
+		else if (!battlegroundsTutorialComplete)
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGEE_NO_BATTLEGROUNDS_TUTORIAL_COMPLETE";
+		}
+		ShowTooltip(text, text2, m_BaconTooltipZone, m_BaconButton);
+	}
+
+	private void OnMercenariesFriendlyButtonOver(UIEvent e)
+	{
+		string text = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_HEADER";
+		string text2 = GetDescriptionTextWhenUnavailable();
+		if (!NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().Games.BattlegroundsFriendlyChallenge)
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_MODE_UNAVAILABLE";
+		}
+		if (UniversalInputManager.Get().IsTouchMode())
+		{
+			if (GameStrings.HasKey(text + "_TOUCH"))
+			{
+				text += "_TOUCH";
+			}
+			if (GameStrings.HasKey(text2 + "_TOUCH"))
+			{
+				text2 += "_TOUCH";
+			}
+		}
+		bool mercenariesTutorialComplete = m_challengeButton.GetPlayer().GetHearthstoneGameAccount().GetMercenariesTutorialComplete();
+		if (!GameUtils.IsMercenariesVillageTutorialComplete())
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_MERCS_LOCKED";
+		}
+		else if (!mercenariesTutorialComplete)
+		{
+			text2 = "GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGEE_NO_MERCS_TUTORIAL_COMPLETE";
+		}
+		ShowTooltip(text, text2, m_MercenariesFriendlyTooltipZone, m_MercenariesFriendlyButton);
+	}
+
+	private string GetDescriptionTextWhenUnavailable()
+	{
+		string result = "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_THEYRE_UNAVAILABLE";
+		if (!FriendChallengeMgr.Get().AmIAvailable())
+		{
+			result = (BnetPresenceMgr.Get().GetMyPlayer().IsAppearingOffline() ? "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_IM_APPEARING_OFFLINE" : ((!PartyManager.Get().IsInBattlegroundsParty() || PartyManager.Get().IsPartyLeader()) ? "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_IM_UNAVAILABLE" : "GLOBAL_FRIENDLIST_CHALLENGE_BUTTON_BATTLEGROUNDS_PARTY_MEMBER"));
+		}
+		return result;
+	}
+
+	private void OnButtonOut(UIEvent e)
+	{
+		HideTooltip();
+	}
+
+	private void OnStandardDuelButtonReleased(UIEvent e)
+	{
+		SendStartStandardDuelChallenge();
+	}
+
+    private void OnWildDuelButtonReleased(UIEvent e)
+	{
+		SendStartWildDuelChallenge();
+	}
+
+	private void OnClassicDuelButtonReleased(UIEvent e)
+	{
+		SendStartClassicDuelChallenge();
+	}
+
+	private void OnRegularTavernBrawlButtonReleased(UIEvent e)
+	{
+		if (!m_bIsTavernBrawlUnlocked)
+		{
+			AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
+			{
+				m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
+				m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_TAVERN_BRAWL_LOCKED"),
+				m_showAlertIcon = true,
+				m_responseDisplay = AlertPopup.ResponseDisplay.OK
+			};
+			DialogManager.Get().ShowPopup(info);
+			m_challengeButton.CloseChallengeMenu();
+		}
+		else if (!m_bCanChallengeTavernBrawl)
+		{
+			AlertPopup.PopupInfo info2 = new AlertPopup.PopupInfo
+			{
+				m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
+				m_text = GameStrings.Format("GLOBAL_TAVERN_BRAWL_ERROR_SEASON_INCREMENTED"),
+				m_showAlertIcon = true,
+				m_responseDisplay = AlertPopup.ResponseDisplay.OK
+			};
+			DialogManager.Get().ShowPopup(info2);
+			m_challengeButton.CloseChallengeMenu();
+		}
+		else if (!m_bHasTavernBrawlDeck)
+		{
+			FriendChallengeMgr.ShowChallengerNeedsToCreateTavernBrawlDeckAlert();
+			m_challengeButton.CloseChallengeMenu();
+		}
+		else
+		{
+			TavernBrawlManager.Get().CurrentBrawlType = BrawlType.BRAWL_TYPE_TAVERN_BRAWL;
+			BnetPlayer player = m_challengeButton.GetPlayer();
+			FriendChallengeMgr.Get().SendTavernBrawlChallenge(player, BrawlType.BRAWL_TYPE_TAVERN_BRAWL, TavernBrawlManager.Get().CurrentMission().seasonId, TavernBrawlManager.Get().CurrentMission().SelectedBrawlLibraryItemId);
+			m_challengeButton.CloseFriendsListMenu();
+		}
+	}
+
+	private void OnBaconButtonReleased(UIEvent e)
+	{
+		BnetPlayer player = m_challengeButton.GetPlayer();
+		NavigateToSceneForPartyChallenge(SceneMgr.Mode.BACON);
+		PartyManager.Get().SendInvite(PartyType.BATTLEGROUNDS_PARTY, player.GetBestGameAccountId());
+		m_challengeButton.CloseChallengeMenu();
+	}
+
+	private void OnMercenariesFriendlyButtonReleased(UIEvent e)
+	{
+		BnetPlayer player = m_challengeButton.GetPlayer();
+		PartyManager.Get().StartMercenariesFriendlyChallengeEntry(player);
+		m_challengeButton.CloseChallengeMenu();
+		m_challengeButton.CloseFriendsListMenu();
+	}
+
+	private void NavigateToSceneForPartyChallenge(SceneMgr.Mode nextMode)
+	{
+		GameMgr.Get().SetPendingAutoConcede(pendingAutoConcede: true);
+		if (CollectionManager.Get().IsInEditMode())
+		{
+			CollectionManager.Get().GetEditedDeck()?.SendChanges(CollectionDeck.ChangeSource.NavigateToSceneForPartyChallenge);
+		}
+		SceneMgr.Get().SetNextMode(nextMode);
+	}
+
+	private void OnAddAsFriendButtonReleased(UIEvent e)
+	{
+		BnetPlayer player = m_challengeButton.GetPlayer();
+		BnetFriendMgr.Get().SendInvite(player.GetBattleTag().GetString());
+		m_challengeButton.CloseChallengeMenu();
+	}
+
+	private void OnSpectateButtonReleased(UIEvent e)
+	{
+		BnetPlayer player = m_challengeButton.GetPlayer();
+		SpectatorManager.Get().SpectatePlayer(player);
+		m_challengeButton.CloseChallengeMenu();
+	}
+
+	private void SetupAddFriendButtonAndFixFrameLength(float middleFrameScaleY, float middleShadowScaleY)
+	{
+		BnetPlayer player = m_challengeButton.GetPlayer();
+		if (BnetFriendMgr.Get().IsFriend(player))
+		{
+			m_AddAsFriendButton.gameObject.SetActive(value: false);
+			middleFrameScaleY -= m_middleFrameScaleOffsetForAddFriend;
+			middleShadowScaleY -= m_middleShadowScaleOffsetForAddFriend;
+		}
+		else
+		{
+			m_AddAsFriendButton.gameObject.SetActive(value: true);
+		}
+		m_MiddleFrame.transform.localScale = new Vector3(m_MiddleFrame.transform.localScale.x, middleFrameScaleY, m_MiddleFrame.transform.localScale.z);
+		m_MiddleShadow.transform.localScale = new Vector3(m_MiddleShadow.transform.localScale.x, middleShadowScaleY, m_MiddleShadow.transform.localScale.z);
+	}
+
+	private void ShowTooltip(string headerKey, string descriptionFormat, TooltipZone tooltipZone, UIBButton button)
+	{
+		string headline = GameStrings.Get(headerKey);
+		BnetPlayer player = m_challengeButton.GetPlayer();
+		string bodytext = GameStrings.Format(descriptionFormat, player.GetBestName());
+		HideTooltip();
+		tooltipZone.ShowSocialTooltip(button, headline, bodytext, 75f, GameLayer.BattleNetDialog);
+		tooltipZone.AnchorTooltipTo(button.gameObject, Anchor.TOP_RIGHT, Anchor.TOP_LEFT);
+	}
+
+	private void HideTooltip()
+	{
+		if (m_StandardDuelTooltipZone != null)
+		{
+			m_StandardDuelTooltipZone.HideTooltip();
+		}
+		if (m_WildDuelTooltipZone != null)
+		{
+			m_WildDuelTooltipZone.HideTooltip();
+		}
+		if (m_ClassicDuelTooltipZone != null)
+		{
+			m_ClassicDuelTooltipZone.HideTooltip();
+		}
+		if (m_TavernBrawlTooltipZone != null)
+		{
+			m_TavernBrawlTooltipZone.HideTooltip();
+		}
+		if (m_BaconTooltipZone != null)
+		{
+			m_BaconTooltipZone.HideTooltip();
+		}
+		if (m_MercenariesFriendlyTooltipZone != null)
+		{
+			m_MercenariesFriendlyTooltipZone.HideTooltip();
+		}
+	}
+
+	#region Accessibility
+	public static void ClickSpectateButton(FriendListChallengeButton m_challengeButton) {
+		BnetPlayer player = m_challengeButton.GetPlayer();
+		SpectatorManager.Get().SpectatePlayer(player);
+		m_challengeButton?.CloseFriendsListMenu();
+	}
+    public void SendStartStandardDuelChallenge()
+    {
+		if (!m_bHasStandardDeck)
+		{
+			FireNoStandardDeckPopup();
+			m_challengeButton?.CloseChallengeMenu();
+		}
+		else
+		{
+            BnetPlayer player = m_challengeButton.GetPlayer();
+            SendFriendlyChallenge(player, FormatType.FT_STANDARD);
+			m_challengeButton?.CloseFriendsListMenu();
+		}
+    }
+
+    public void SendStartWildDuelChallenge()
+    {
+		if (!m_bHasWildDeck)
+		{
+			FireNoWildDeckPopup();
+			m_challengeButton.CloseChallengeMenu();
+		}
+		else
+		{
+			FriendChallengeMgr.Get().SetChallengeMethod(FriendChallengeMgr.ChallengeMethod.FROM_FRIEND_LIST);
+			BnetPlayer player = m_challengeButton.GetPlayer();
+			FriendChallengeMgr.Get().SendChallenge(player, FormatType.FT_WILD, enableDeckShare: true);
+			m_challengeButton.CloseFriendsListMenu();
+		}
+    }
+
+	public void SendStartClassicDuelChallenge()
+    {
+		if (!m_bHasClassicDeck)
+		{
+			FireNoClassicDeckPopup();
+			m_challengeButton.CloseChallengeMenu();
+		}
+		else
+		{
+			FriendChallengeMgr.Get().SetChallengeMethod(FriendChallengeMgr.ChallengeMethod.FROM_FRIEND_LIST);
+			BnetPlayer player = m_challengeButton.GetPlayer();
+			FriendChallengeMgr.Get().SendChallenge(player, FormatType.FT_CLASSIC, enableDeckShare: true);
+			m_challengeButton.CloseFriendsListMenu();
+		}
+    }
+
+	public static void ClickVirtualChallengeButton(BnetPlayer player, FormatType format)
+    {
+		// Only used by accessibility when the menu isn't even open
+		if (!CollectionManager.Get().AccountHasValidDeck(format))
+        {
+			if (format == FormatType.FT_STANDARD)
+			{
+				FireNoStandardDeckPopup();
+			}
+			else if (format == FormatType.FT_CLASSIC)
+			{
+				FireNoClassicDeckPopup();
+			}
+			else
+			{
+				FireNoWildDeckPopup(); // Wild == all so good as a catch-all for players who might be using OCR for something else
+			}
+		}
+		else
+        {
+			SendFriendlyChallenge(player, format);
+        }
+    }
+
+    private static void FireNoStandardDeckPopup()
+    {
+        AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
+        {
+            m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
+            m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_STANDARD_DECK"),
+            m_showAlertIcon = true,
+            m_responseDisplay = AlertPopup.ResponseDisplay.OK
+        };
+        DialogManager.Get().ShowPopup(info);
+    }
+
+	private static void FireNoWildDeckPopup()
+	{
+		AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
+		{
+			m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
+			m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_DECK"),
+			m_showAlertIcon = true,
+			m_responseDisplay = AlertPopup.ResponseDisplay.OK
+		};
+		DialogManager.Get().ShowPopup(info);
+	}
+
+	private static void FireNoClassicDeckPopup()
+	{
+		AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
+		{
+			m_headerText = GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_HEADER"),
+			m_text = GameStrings.Format("GLOBAL_FRIENDLIST_CHALLENGE_CHALLENGER_NO_CLASSIC_DECK"),
+			m_showAlertIcon = true,
+			m_responseDisplay = AlertPopup.ResponseDisplay.OK
+		};
+		DialogManager.Get().ShowPopup(info);
+	}
+
+    private static void SendFriendlyChallenge(BnetPlayer player, FormatType format)
+    {
+        FriendChallengeMgr.Get().SetChallengeMethod(FriendChallengeMgr.ChallengeMethod.FROM_FRIEND_LIST);
+        FriendChallengeMgr.Get().SendChallenge(player, format, enableDeckShare: true);
+    }
+    #endregion
+}
diff --git a/Assembly-CSharp/FriendListFrame.cs b/Assembly-CSharp/FriendListFrame.cs
index 9be4ad8..4fd9dd2 100644
--- a/Assembly-CSharp/FriendListFrame.cs
+++ b/Assembly-CSharp/FriendListFrame.cs
@@ -7,8 +7,9 @@ using Blizzard.T5.MaterialService.Extensions;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class FriendListFrame : MonoBehaviour
+public class FriendListFrame : MonoBehaviour, AccessibleUI
 {
 	public enum FriendListEditMode
 	{
@@ -231,7 +232,7 @@ public class FriendListFrame : MonoBehaviour
 					return m_cachedMaxVisibleItems;
 				}
 				m_cachedMaxVisibleItems = 0;
-				UnityEngine.Vector2 clipSize = m_friendList.items.ClipSize;
+                UnityEngine.Vector2 clipSize = m_friendList.items.ClipSize;
 				Bounds prefabBounds = GetPrefabBounds(m_friendList.prefabs.requestItem.gameObject);
 				Bounds prefabBounds2 = GetPrefabBounds(m_friendList.prefabs.friendItem.gameObject);
 				float a = prefabBounds.max.z - prefabBounds.min.z;
@@ -290,11 +291,11 @@ public class FriendListFrame : MonoBehaviour
 			{
 				return true;
 			}
-			FriendListItemHeader friendListItemHeader = m_friendList.FindHeader(friendListItem.SubType);
-			if (friendListItemHeader == null || !friendListItemHeader.IsShowingContents)
-			{
-				return false;
-			}
+				FriendListItemHeader friendListItemHeader = m_friendList.FindHeader(friendListItem.SubType);
+				if (friendListItemHeader == null || !friendListItemHeader.IsShowingContents)
+				{
+					return false;
+				}
 			if (m_friendList.EditMode == FriendListEditMode.REMOVE_FRIENDS)
 			{
 				if (friendListItem.ItemMainType != MobileFriendListItem.TypeFlags.Header)
@@ -763,6 +764,8 @@ public class FriendListFrame : MonoBehaviour
 
 	private void Start()
 	{
+		m_curState = State.LOADING; // Important for handling added invites properly
+
 		UpdateMyself();
 		InitItems();
 		UpdateRAFState();
@@ -773,10 +776,13 @@ public class FriendListFrame : MonoBehaviour
 		{
 			this.OnStarted();
 		}
+
+		ReadFriendsMenu();
 	}
 
 	private void OnDestroy()
 	{
+		AccessibilityMgr.HideUI(this);
 		m_itemsCameraOverridePass.Unschedule();
 		UnregisterFriendEvents();
 		CloseAddFriendFrame();
@@ -934,12 +940,18 @@ public class FriendListFrame : MonoBehaviour
 		{
 			m_addFriendFrame.SetPlayer(player);
 		}
+		AccessibilityMgr.AllowTextInput();
 	}
 
 	public void CloseAddFriendFrame()
 	{
 		if (!(m_addFriendFrame == null))
 		{
+			if (AccessibilityMgr.IsCurrentlyFocused(this) && m_addFriendFrame.gameObject.activeInHierarchy)
+			{
+				ReadFriendsMenu();
+			}
+
 			m_addFriendFrame.Close();
 			if (this.AddFriendFrameClosed != null)
 			{
@@ -973,12 +985,12 @@ public class FriendListFrame : MonoBehaviour
 	{
 		foreach (FriendListFriendFrame renderedItem in GetRenderedItems<FriendListFriendFrame>())
 		{
-			if (renderedItem.GetFriend() == player)
-			{
+				if (renderedItem.GetFriend() == player)
+				{
 				renderedItem.ForceHighlight = true;
-			}
-			else
-			{
+				}
+				else
+				{
 				renderedItem.ForceHighlight = false;
 			}
 		}
@@ -1054,7 +1066,7 @@ public class FriendListFrame : MonoBehaviour
 		}
 	}
 
-	public void CloseFlyoutMenu()
+    public void CloseFlyoutMenu()
 	{
 		if (!(flyoutMenu == null))
 		{
@@ -1173,6 +1185,7 @@ public class FriendListFrame : MonoBehaviour
 		{
 			m_timeSinceLastScroll = Time.realtimeSinceStartup;
 			m_updateItemsAfterScroll = true;
+			UpdateAccessibleFriends();
 		};
 		SuspendItemsLayout();
 		UpdateRequests(bnetFriendMgr.GetReceivedInvites(), null);
@@ -1236,45 +1249,55 @@ public class FriendListFrame : MonoBehaviour
 		UpdateFriendItems();
 	}
 
-	private void UpdateRequests(List<BnetInvitation> addedList, List<BnetInvitation> removedList)
+	private bool UpdateRequests(List<BnetInvitation> addedList, List<BnetInvitation> removedList)
 	{
+		var ret = false;
+
 		if (removedList == null && addedList == null)
 		{
-			return;
+			return false;
 		}
 		if (removedList != null)
 		{
 			foreach (BnetInvitation removed in removedList)
 			{
 				RemoveItem(isHeader: false, MobileFriendListItem.TypeFlags.Request, removed);
+				ret = true;
 			}
 		}
 		foreach (FriendListRequestFrame renderedItem in GetRenderedItems<FriendListRequestFrame>())
 		{
 			renderedItem.UpdateInvite();
 		}
+
 		if (addedList == null)
 		{
-			return;
+			return ret;
 		}
+
 		foreach (BnetInvitation added in addedList)
 		{
 			FriendListItem itemToAdd = new FriendListItem(isHeader: false, MobileFriendListItem.TypeFlags.Request, added);
 			AddItem(itemToAdd);
+			ret = true;
 		}
+
+		return ret;
 	}
 
-	private void UpdateAllFriends(List<BnetPlayer> addedList, List<BnetPlayer> removedList)
+	private bool UpdateAllFriends(List<BnetPlayer> addedList, List<BnetPlayer> removedList)
 	{
+		var ret = false;
 		if (removedList == null && addedList == null)
 		{
-			return;
+			return ret;
 		}
 		if (removedList != null)
 		{
 			foreach (BnetPlayer removed in removedList)
 			{
 				RemoveItem(isHeader: false, MobileFriendListItem.TypeFlags.Friend, removed);
+				ret = true;
 			}
 		}
 		UpdateFriendItems();
@@ -1282,13 +1305,16 @@ public class FriendListFrame : MonoBehaviour
 		{
 			foreach (BnetPlayer added in addedList)
 			{
-				added.GetPersistentGameId();
-				FriendListItem itemToAdd = new FriendListItem(isHeader: false, MobileFriendListItem.TypeFlags.Friend, added);
-				AddItem(itemToAdd);
+					added.GetPersistentGameId();
+					FriendListItem itemToAdd = new FriendListItem(isHeader: false, MobileFriendListItem.TypeFlags.Friend, added);
+					AddItem(itemToAdd);
+					ret = true;
+				}
 			}
-		}
 		SortAndRefreshTouchList();
 		UpdateRemoveFriendVisibility();
+
+		return ret;
 	}
 
 	private FriendListFriendFrame FindRenderedBaseFriendFrame(BnetPlayer friend)
@@ -1435,20 +1461,12 @@ public class FriendListFrame : MonoBehaviour
 
 	private void UpdateFriendsHeader()
 	{
+		var text = GetFriendsHeaderText();
+
 		List<FriendListItem> friendItems = GetFriendItems();
-		int num = 0;
-		foreach (FriendListItem item in friendItems)
-		{
-			if (item.GetFriend().IsOnline())
-			{
-				num++;
-			}
-		}
 		int count = friendItems.Count;
 		if (count > 0)
 		{
-			string text = null;
-			text = ((num != count) ? GameStrings.Format("GLOBAL_FRIENDLIST_FRIENDS_HEADER", num, count) : GameStrings.Format("GLOBAL_FRIENDLIST_FRIENDS_HEADER_ALL_ONLINE", num));
 			FriendListItemHeader friendListItemHeader = FindOrCreateHeader(MobileFriendListItem.TypeFlags.Friend);
 			if (!DoesHeaderExist(MobileFriendListItem.TypeFlags.Friend))
 			{
@@ -1464,7 +1482,7 @@ public class FriendListFrame : MonoBehaviour
 		}
 	}
 
-	private void UpdateHeaderBackground(FriendListItemHeader itemHeader)
+    private void UpdateHeaderBackground(FriendListItemHeader itemHeader)
 	{
 		if (itemHeader == null)
 		{
@@ -1684,6 +1702,12 @@ public class FriendListFrame : MonoBehaviour
 
 	private void AddItem(FriendListItem itemToAdd)
 	{
+		if (itemToAdd.ItemMainType == MobileFriendListItem.TypeFlags.RecentPlayer || itemToAdd.ItemMainType == MobileFriendListItem.TypeFlags.NearbyPlayer)
+		{
+			// 23.6.0 refactor broke nearby/recents
+			return;
+		}
+
 		m_allItems.Add(itemToAdd);
 	}
 
@@ -1770,6 +1794,7 @@ public class FriendListFrame : MonoBehaviour
 		if (!items.IsLayoutSuspended)
 		{
 			m_allItems.Sort(ItemsSortCompare);
+			UpdateAccessibleFriends();
 			if (m_longListBehavior == null)
 			{
 				m_longListBehavior = new VirtualizedFriendsListBehavior(this);
@@ -1855,16 +1880,21 @@ public class FriendListFrame : MonoBehaviour
 		}
 	}
 
-	private void OnFriendsChanged(BnetFriendChangelist changelist, object userData)
+	internal void OnFriendsChanged(BnetFriendChangelist changelist, object userData)
 	{
 		SuspendItemsLayout();
-		UpdateRequests(changelist.GetAddedReceivedInvites(), changelist.GetRemovedReceivedInvites());
-		UpdateAllFriends(changelist.GetAddedFriends(), changelist.GetRemovedFriends());
+		var friendsChanged = UpdateRequests(changelist.GetAddedReceivedInvites(), changelist.GetRemovedReceivedInvites());
+		friendsChanged |= UpdateAllFriends(changelist.GetAddedFriends(), changelist.GetRemovedFriends());
 		UpdateAllHeaders();
 		ResumeItemsLayout();
 		SortAndRefreshTouchList();
 		UpdateAllHeaderBackgrounds();
 		UpdateSelectedItem();
+
+		if (friendsChanged)
+		{
+			ReadFriendsMenu();
+		}
 	}
 
 	private void OnRecentPlayersChanged(BnetRecentOrNearbyPlayerChangelist changelist, object userData)
@@ -1976,9 +2006,9 @@ public class FriendListFrame : MonoBehaviour
 			{
 				if (playerUpdate.Change == PlayerUpdate.ChangeType.Added)
 				{
-					FriendListItem itemToAdd = new FriendListItem(isHeader: false, typeFlag, playerUpdate.Player);
-					AddItem(itemToAdd);
-				}
+						FriendListItem itemToAdd = new FriendListItem(isHeader: false, typeFlag, playerUpdate.Player);
+						AddItem(itemToAdd);
+					}
 				else
 				{
 					RemoveItem(isHeader: false, typeFlag, playerUpdate.Player);
@@ -2196,6 +2226,12 @@ public class FriendListFrame : MonoBehaviour
 		{
 			BnetFriendMgr.Get().RemoveFriend(m_friendToRemove);
 		}
+		else if (response == AlertPopup.Response.CANCEL)
+		{
+			AccessibilityMgr.HideUI(m_removeFriendPopup);
+			RereadRemoveFriendsList();
+		}
+
 		m_friendToRemove = null;
 		m_removeFriendPopup = null;
 		if (this.RemoveFriendPopupClosed != null)
@@ -2352,4 +2388,842 @@ public class FriendListFrame : MonoBehaviour
 			UpdatePortrait(medalIsDisplayable: false);
 		});
 	}
+
+	#region Accessibility
+
+	private enum State {
+		LOADING,
+		MAIN_MENU,
+		READING_FRIEND_INVITES,
+		READING_FRIEND_INVITE,
+		READING_PROFILE,
+		READING_FRIENDS_LIST,
+		CHALLENGING_FRIEND,
+		ADDING_FRIENDS,
+		REMOVING_FRIENDS,
+		INTERACTING_WITH_FRIEND,
+		INTERACTING_WITH_RECENT,
+		READING_NEARBY_LIST,
+		READING_RECENT_LIST,
+	}
+
+	private State m_curState;
+
+	private AccessibleMenu m_mainMenu;
+
+	private AccessibleMenu m_interactWithFriendMenu;
+
+	private AccessibleMenu m_interactWithRecentMenu;
+
+	private AccessibleMenu m_challengeFriendMenu;
+
+	private AccessibleMenu m_handleRequestMenu;
+
+	private AccessibleListOfItems<AccessibleFriendListFriendFrame> m_accessibleFriends;
+
+	private AccessibleListOfItems<AccessibleFriendListRequestFrame> m_accessibleRequests;
+
+	private AccessibleListOfItems<AccessibleRecentPlayer> m_accessibleRecents;
+
+	private AccessiblePlayerProfile m_accessibleProfile;
+
+	private List<BnetPlayer> m_allFriends; // Needed so that indexes in the friend list can be calculated properly.
+
+	private bool m_shouldGoToTop = false, m_shouldGoToBottom = false;
+
+	private void ReadFriendsMenu()
+    {
+		if (m_flyoutOpen)
+        {
+			CloseFlyoutMenu();
+        }
+
+		m_curState = State.LOADING;
+		m_accessibleFriends = new AccessibleListOfItems<AccessibleFriendListFriendFrame>(this, new List<AccessibleFriendListFriendFrame>());
+		m_accessibleFriends.onReadItem = OnReadFriend;
+		m_accessibleRecents = new AccessibleListOfItems<AccessibleRecentPlayer>(this, new List<AccessibleRecentPlayer>());
+
+		AccessibilityMgr.ShowUI(this);
+
+		m_mainMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_MENU_NAME), BnetBar.Get().m_friendButton.TriggerRelease);
+
+		if (DoesHeaderExist(MobileFriendListItem.TypeFlags.Request))
+        {
+            var requestsHeader = FindOrCreateHeader(MobileFriendListItem.TypeFlags.Request);
+			m_mainMenu.AddOption(requestsHeader.m_Text.Text, ReadFriendRequests);
+        }
+
+		if (DoesHeaderExist(MobileFriendListItem.TypeFlags.NearbyPlayer) && GetNearbyOrRecentPlayersCount(MobileFriendListItem.TypeFlags.NearbyPlayer) > 0)
+        {
+            var nearbyHeader = FindOrCreateHeader(MobileFriendListItem.TypeFlags.NearbyPlayer);
+			m_mainMenu.AddOption(nearbyHeader.m_Text.Text, ReadNearbyList);
+        }
+
+        int recentCount = BnetRecentPlayerMgr.Get().GetRecentPlayers().Count;
+        if (recentCount > 0)
+        {
+			m_mainMenu.AddOption(GameStrings.Format("GLOBAL_FRIENDLIST_RECENT_PLAYERS_HEADER", recentCount), ReadRecentList);
+        }
+
+		var numFriends = BnetFriendMgr.Get().GetFriendCount();
+		var haveFriends = numFriends > 0;
+		var friendlistIsFull = numFriends >= BnetFriendMgr.Get().GetMaxFriends();
+		var sentInvitesFull = BnetFriendMgr.Get().GetSentInvites().Count >= BnetFriendMgr.Get().GetMaxSentInvites();
+		var canAddFriends = !friendlistIsFull && !sentInvitesFull;
+
+		if (haveFriends && !AreAllFriendsNearby())
+        {
+            m_mainMenu.AddOption(GetFriendsHeaderText(false), ReadFriendsList);
+        }
+
+        m_mainMenu.AddOption(GameStrings.Get("GLUE_PROGRESSION_PROFILE_TITLE"), ReadProfile);
+
+		if (canAddFriends)
+        {
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_FRIEND_LIST_ADD_FRIENDS"), AddFriend);
+        }
+
+        if (haveFriends)
+        {
+            m_mainMenu.AddOption(GameStrings.Get("GLUE_FRIEND_LIST_REMOVE_FRIENDS"), ReadRemoveFriendsMenu);
+        }
+
+		m_mainMenu.StartReading();
+
+		m_curState = State.MAIN_MENU;
+    }
+
+	private bool AreAllFriendsNearby()
+	{
+		var friends = BnetFriendMgr.Get().GetFriends();
+		foreach (var friend in friends)
+		{
+			if (!BnetNearbyPlayerMgr.Get().IsNearbyPlayer(friend))
+			{
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	private void AddFriend()
+    {
+		addFriendButton.TriggerRelease();
+    }
+
+    private void ReadRemoveFriendsMenu()
+    {
+		ReadRemoveFriendsList();
+    }
+
+    private void ReadRemoveFriendsList()
+    {
+		m_curState = State.REMOVING_FRIENDS;
+		UpdateAccessibleFriends();
+		AddFriendListCallbacks();
+		m_accessibleFriends.StartReadingFromIndex(0);
+
+		if (m_accessibleFriends.Count == 0)
+		{
+			AccessibilityUtils.LogFatalError("ReadRemoveFriendsList() reached an empty list");
+			return;
+		}
+    }
+
+    private void ReadFriendRequests()
+    {
+		var requests = GetRenderedItems<FriendListRequestFrame>();
+
+		var accessibleRequests = new List<AccessibleFriendListRequestFrame>();
+
+		foreach(var request in requests)
+        {
+			accessibleRequests.Add(new AccessibleFriendListRequestFrame(this, request));
+        }
+
+		m_accessibleRequests = new AccessibleListOfItems<AccessibleFriendListRequestFrame>(this, accessibleRequests);
+		RereadRequestsList();
+    }
+
+    private void RereadRequestsList()
+    {
+		m_accessibleRequests.StartReading();
+		m_curState = State.READING_FRIEND_INVITES;
+    }
+
+    private void ReadFriendsList()
+    {
+		m_curState = State.READING_FRIENDS_LIST;
+		UpdateAccessibleFriends();
+		AddFriendListCallbacks();
+		m_accessibleFriends.StartReadingFromIndex(0);
+
+		if (m_accessibleFriends.Count == 0)
+		{
+			return;
+		}
+    }
+
+	private void OnReadFriend(AccessibleFriendListFriendFrame friend)
+	{
+		items.ScrollToItem(friend.GetFriendListFriendFrame().GetComponent<MobileFriendListItem>());
+		AccessibilityUtils.LogDebug($"OnReadFriend {friend.GetLine(0)}, scroll value is now {items.ScrollValue}");
+	}
+
+	private int GetIndexOfFriend(AccessibleFriendListFriendFrame item)
+	{
+		return m_allFriends.IndexOf(item.GetFriendListFriendFrame().GetFriend()) + 1;
+	}
+
+	private void AddFriendListCallbacks()
+	{
+		m_accessibleFriends.getItemIndex = GetIndexOfFriend;
+		m_accessibleFriends.SetCountOverride(m_allFriends.Count);
+	}
+
+	private void RemoveFriendListCallbacks()
+	{
+		m_accessibleFriends.getItemIndex = null;
+		m_accessibleFriends.SetCountOverride(-1);
+	}
+
+	private void UpdateAccessibleFriends()
+	{
+		AccessibilityUtils.LogDebug($"UpdateAccessibleFriends: Current scroll value is {items.ScrollValue}");
+		if (m_accessibleFriends != null && (m_curState == State.READING_FRIENDS_LIST || m_curState == State.REMOVING_FRIENDS))
+		{
+			var renderedFriends = GetRenderedItems<FriendListFriendFrame>();
+			var addedFriends = new HashSet<BnetPlayer>();
+
+			var accessibleFriends = new List<AccessibleFriendListFriendFrame>();
+
+			foreach (var rf in renderedFriends)
+			{
+				var bnetPlayer = rf.GetFriend();
+
+				// Nearby/recents are also "friends" but we don't want to traverse through them
+				if (BnetFriendMgr.Get().IsFriend(bnetPlayer) && !addedFriends.Contains(bnetPlayer))
+				{
+					accessibleFriends.Add(new AccessibleFriendListFriendFrame(this, rf));
+					addedFriends.Add(bnetPlayer);
+				}
+			}
+
+m_allFriends = new List<BnetPlayer>();
+			foreach (var listItem in m_allItems)
+			{
+				var friend = listItem.GetFriend();
+				if (friend != null)
+				{
+					m_allFriends.Add(friend);
+				}
+			}
+
+			m_accessibleFriends.UpdateItems(accessibleFriends, true);
+			if (m_shouldGoToTop)
+			{
+				m_accessibleFriends.StartReadingFromIndex(0);
+				m_shouldGoToTop = false;
+			}
+			else if (m_shouldGoToBottom)
+			{
+				m_accessibleFriends.StartReadingFromIndex(m_accessibleFriends.Items.Count - 1);
+				m_shouldGoToBottom = false;
+			}
+		}
+	}
+
+    private void RereadFriendsList()
+    {
+		UpdateAccessibleFriends();
+		if (m_accessibleFriends.Count == 0)
+		{
+			ReadFriendsMenu();
+			return;
+		}
+
+		m_accessibleFriends.StartReading();
+		m_curState = State.READING_FRIENDS_LIST;
+    }
+
+    private void RereadRemoveFriendsList()
+    {
+		UpdateAccessibleFriends();
+		if (m_accessibleFriends.Count == 0)
+		{
+			ReadFriendsMenu();
+			return;
+		}
+
+		m_accessibleFriends.StartReading();
+		m_curState = State.REMOVING_FRIENDS;
+    }
+
+    private void ReadNearbyList()
+    {
+		var nearbyPlayers = GetNearbyFriends();
+		var renderedFriends = GetRenderedItems<FriendListFriendFrame>();
+
+		var addedFriends = new HashSet<BnetPlayer>();
+
+		var nearbyFriendListFrames = new List<FriendListFriendFrame>();
+		foreach (var rf in renderedFriends)
+		{
+			var bnetFriend = rf.GetFriend();
+
+			// TODO: Review this since the dedupe broke with 23.0
+			if (nearbyPlayers.Contains(bnetFriend) && !addedFriends.Contains(bnetFriend))
+			{
+				nearbyFriendListFrames.Add(rf);
+				addedFriends.Add(bnetFriend);
+			}
+		}
+
+		var accessibleNearbyPlayers = new List<AccessibleFriendListFriendFrame>();
+
+		foreach(var player in nearbyFriendListFrames)
+        {
+			accessibleNearbyPlayers.Add(new AccessibleFriendListFriendFrame(this, player));
+        }
+
+		m_accessibleFriends.UpdateItems(accessibleNearbyPlayers);
+		RemoveFriendListCallbacks();
+		m_accessibleFriends.StartReadingFromIndex(0);
+
+		if (m_accessibleFriends.Count == 0)
+		{
+			return;
+		}
+
+		m_curState = State.READING_NEARBY_LIST;
+    }
+
+    private void ReadRecentList()
+    {
+		var recents = BnetRecentPlayerMgr.Get().GetRecentPlayers();
+
+		var accessibleRecentPlayers = new List<AccessibleRecentPlayer>();
+
+		foreach(var player in recents)
+        {
+			accessibleRecentPlayers.Add(new AccessibleRecentPlayer(this, player));
+        }
+
+		m_accessibleRecents.UpdateItems(accessibleRecentPlayers);
+		m_accessibleRecents.StartReadingFromIndex(0);
+
+		m_curState = State.READING_RECENT_LIST;
+    }
+
+	private void RereadRecentList()
+	{
+		m_accessibleRecents.StartReading();
+		m_curState = State.READING_RECENT_LIST;
+	}
+
+    private void RereadNearbyList()
+    {
+		if (m_accessibleFriends.Count == 0)
+		{
+			ReadFriendsMenu();
+			return;
+		}
+
+		m_accessibleFriends.StartReading();
+		m_curState = State.READING_NEARBY_LIST;
+    }
+
+	private void InteractWithRecent(AccessibleRecentPlayer recent)
+	{
+		SetupInteractWithRecentMenu(recent.GetPlayer());
+	}
+
+	private void SetupInteractWithRecentMenu(BnetPlayer recent)
+	{
+		m_interactWithRecentMenu = new AccessibleMenu(this, "", RereadRecentList);
+
+		if (BnetFriendMgr.Get().IsFriend(recent))
+		{
+			m_interactWithRecentMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_CHAT_SEND_MESSAGE), () => ChatWithRecentPlayer(recent));
+		}
+		else if (!BnetRecentPlayerMgr.Get().IsCurrentOpponent(recent))
+		{
+			m_interactWithRecentMenu.AddOption(GameStrings.Get("GLOBAL_ADDFRIEND_BUTTON"), () => AddRecentPlayerAsFriend(recent));
+		}
+		m_interactWithRecentMenu.AddOption(GameStrings.Get("GLOBAL_FRIENDLIST_CHALLENGE_MENU_REPORT_BUTTON"), () => ReportRecentPlayer(recent));
+		m_interactWithRecentMenu.StartReading();
+		m_curState = State.INTERACTING_WITH_RECENT;
+	}
+
+	private void ChatWithRecentPlayer(BnetPlayer recent)
+	{
+		ChatMgr.Get().OnFriendListFriendSelected(recent);
+	}
+
+	private void AddRecentPlayerAsFriend(BnetPlayer recent)
+	{
+		BnetFriendMgr.Get().SendInviteByBattleTag(recent.GetBattleTag().GetString());
+		ReadRecentList();
+	}
+
+	private void ReportRecentPlayer(BnetPlayer recent)
+	{
+		AccessibleReportingPopup.show(recent, RereadRecentList, () => SetupInteractWithRecentMenu(recent));
+	}
+
+    private void ReadProfile()
+    {
+		m_accessibleProfile = new AccessiblePlayerProfile(this, me);
+		m_accessibleProfile.ReadLine();
+		m_curState = State.READING_PROFILE;
+    }
+
+    private void OnDisable()
+    {
+		AccessibilityMgr.HideUI(this);
+    }
+
+    private string GetFriendsHeaderText(bool useXOfY=true)
+    {
+		List<FriendListItem> friendItems = GetFriendItems();
+		int num = 0;
+		foreach (FriendListItem item in friendItems)
+		{
+			BnetPlayer friend = item.GetFriend();
+			if (friend.IsOnline())
+			{
+				num++;
+			}
+		}
+		int count = friendItems.Count;
+
+        return (useXOfY && num != count) ? GameStrings.Format("GLOBAL_FRIENDLIST_FRIENDS_HEADER", num, count) : GameStrings.Format("GLOBAL_FRIENDLIST_FRIENDS_HEADER_ALL_ONLINE", num);
+    }
+
+	private int GetNearbyOrRecentPlayersCount(MobileFriendListItem.TypeFlags typeFlag)
+	{
+		int num = 0;
+		foreach (FriendListItem allItem in m_allItems)
+		{
+			if (allItem.ItemMainType == typeFlag && typeFlag != MobileFriendListItem.TypeFlags.NearbyPlayer)
+			{
+				num++;
+			}
+		}
+    return num;
+	}
+
+	private List<FriendListItem> GetNearbyOrRecentItems(MobileFriendListItem.TypeFlags typeFlag)
+	{
+		List<FriendListItem> list = new List<FriendListItem>();
+		foreach (FriendListItem allItem in m_allItems)
+		{
+			if (allItem.ItemMainType == typeFlag)
+			{
+				list.Add(allItem);
+			}
+		}
+		return list;
+	}
+
+	private List<BnetPlayer> GetNearbyFriends()
+	{
+		var ret = new List<BnetPlayer>();
+
+		var nearbyItems = GetNearbyOrRecentItems(MobileFriendListItem.TypeFlags.NearbyPlayer);
+
+		foreach (var item in nearbyItems)
+		{
+			ret.Add(item.GetNearbyPlayer());
+		}
+
+		return ret;
+	}
+
+    public void HandleAccessibleInput()
+    {
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_mainMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_FRIENDS_LIST)
+        {
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				if (m_accessibleFriends.Count == 0)
+				{
+					m_accessibleFriends.StartReading();
+				}
+				else
+				{
+					var curFriend = m_accessibleFriends.GetItemBeingRead().GetFriendListFriendFrame();
+					InteractWithFriend(curFriend);
+				}
+			}
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+				if (m_accessibleFriends?.HandleAccessibleInput() ?? false)
+				{
+					var curFriend = m_accessibleFriends.GetItemBeingRead().GetFriendListFriendFrame();
+					if (!curFriend.gameObject.activeSelf)
+					{
+						// Activate challenge buttons since we depend on it (even though they're hidden)
+						curFriend.gameObject.SetActive(true);
+					}
+				}
+			}
+        }
+		else if (m_curState == State.CHALLENGING_FRIEND)
+		{
+			m_challengeFriendMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_NEARBY_LIST)
+        {
+            var curPlayer = m_accessibleFriends.GetItemBeingRead().GetFriendListFriendFrame();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				if (m_accessibleFriends.Count == 0)
+				{
+					m_accessibleFriends.StartReading();
+				}
+				else
+				{
+					InteractWithNearbyPlayer(curPlayer);
+				}
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+                m_accessibleFriends?.HandleAccessibleInput();
+            }
+        }
+		else if (m_curState == State.REMOVING_FRIENDS)
+        {
+            var curFriend = m_accessibleFriends.GetItemBeingRead().GetFriendListFriendFrame();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				curFriend.OnDeleteFriendButtonPressed();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+                m_accessibleFriends?.HandleAccessibleInput();
+            }
+        }
+		else if (m_curState == State.READING_PROFILE)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_accessibleProfile.CopyBattleTagToClipboard();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+                m_accessibleProfile?.HandleAccessibleInput();
+            }
+        }
+		else if (m_curState == State.INTERACTING_WITH_FRIEND)
+        {
+			m_interactWithFriendMenu?.HandleAccessibleInput();
+        }
+		else if (m_curState == State.READING_FRIEND_INVITES)
+        {
+            var curRequest = m_accessibleRequests.GetItemBeingRead().GetFriendListRequestFrame();
+
+            if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				ReadFriendInvite(curRequest);
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				ReadFriendsMenu();
+            }
+			else
+            {
+                m_accessibleRequests?.HandleAccessibleInput();
+            }
+        }
+		else if (m_curState == State.READING_FRIEND_INVITE)
+		{
+			m_handleRequestMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_RECENT_LIST)
+		{
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				var currentRecent = m_accessibleRecents.GetItemBeingRead();
+				InteractWithRecent(currentRecent);
+			}
+			else if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadFriendsMenu();
+			}
+			else
+			{
+				m_accessibleRecents?.HandleAccessibleInput();
+			}
+		}
+		else if (m_curState == State.INTERACTING_WITH_RECENT)
+		{
+			m_interactWithRecentMenu?.HandleAccessibleInput();
+			}
+    }
+
+	private void InteractWithFriend(FriendListFriendFrame curFriend)
+    {
+		InteractWithFriendOrNearbyPlayer(curFriend, RereadFriendsList);
+    }
+
+	private void InteractWithNearbyPlayer(FriendListFriendFrame curPlayer)
+    {
+		InteractWithFriendOrNearbyPlayer(curPlayer, RereadNearbyList);
+    }
+
+	private void InteractWithFriendOrNearbyPlayer(FriendListFriendFrame curFriend, Action goBackAction)
+    {
+		m_interactWithFriendMenu = new AccessibleMenu(this, "", goBackAction);
+
+		if (BnetFriendMgr.Get().IsFriend(curFriend.GetFriend()))
+		{
+			// Nearby "friends" aren't necessarily friends and you can't challenge them
+			SetupInteractWithFriendMenu(m_interactWithFriendMenu, curFriend);
+		}
+		else
+		{
+			SetupInteractWithNearbyPlayerMenu(m_interactWithFriendMenu, curFriend);
+		}
+
+        m_interactWithFriendMenu.StartReading();
+
+		m_curState = State.INTERACTING_WITH_FRIEND;
+    }
+
+	private void SetupInteractWithNearbyPlayerMenu(AccessibleMenu friendMenu, FriendListFriendFrame player)
+	{
+		friendMenu.AddOption(GameStrings.Get("GLOBAL_ADDFRIEND_BUTTON"), () => AddNearbyPlayerAsFriend(player));
+	}
+
+	private void AddNearbyPlayerAsFriend(FriendListFriendFrame player)
+	{
+		var bnetPlayer = player.GetFriend();
+
+		if (bnetPlayer.IsCheatPlayer)
+		{
+			string message = GameStrings.Get("GLOBAL_ADDFRIEND_SENT_CONFIRMATION");
+			UIStatus.Get().AddInfo(message);
+			return;
+		}
+		else
+		{
+			BnetFriendMgr.Get().SendInvite(bnetPlayer.GetBattleTag().GetString());
+		}
+	}
+
+	private void SetupInteractWithFriendMenu(AccessibleMenu friendMenu, FriendListFriendFrame friend)
+	{
+		if (GameUtils.IsTraditionalTutorialComplete())
+		{
+			var challengeFriendButton = friend.m_challengeButton;
+			BnetPlayer player=friend.GetFriend();
+			bool flag = FriendChallengeMgr.Get().CanChallenge(player);
+			bool flag2 = !flag || PartyManager.Get().IsInBattlegroundsParty();
+						NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+			var dataModel = challengeFriendButton.GetChallengeButtonDataModel();
+			switch (dataModel.state)
+			{
+				case FriendListChallengeButton.ChallengeButtonState.CHALLENGE:
+					friendMenu.AddOption(GameStrings.Format(dataModel.text,player.GetBestName()), () => ChallengeFriend(friend));
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.CANNOT_INTERACT:
+					friendMenu.AddOption(LocalizationUtils.Format(LocalizationKey.UI_SOCIAL_FRIEND_NO_CHALLENGE,friend.m_friendDataModel.PlayerName), () => ClickFriendChallengeButton(friend));
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.SPECTATE:
+				case FriendListChallengeButton.ChallengeButtonState.INVITED_PLAYER_TO_SPECTATE: // Doesn't really matter since it's just text
+					friendMenu.AddOption(GameStrings.Get("GLOBAL_SPECTATE"), () => ClickFriendChallengeButton(friend));
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.KICK_SPECTATOR:
+					friendMenu.AddOption(challengeFriendButton.FormatBodytext(dataModel.text2), () => ClickFriendChallengeButton(friend)); // meh
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.REVEAL_CARDS_TO_OPPONENT_SPECTATOR:
+					friendMenu.AddOption(challengeFriendButton.FormatBodytext(dataModel.text2), () => ClickFriendChallengeButton(friend)); // meh
+					break;
+				case FriendListChallengeButton.ChallengeButtonState.INVITE_PLAYER_TO_SPECTATE:
+					friendMenu.AddOption(challengeFriendButton.FormatBodytext(dataModel.text2), () => ClickFriendChallengeButton(friend));
+					break;
+				default:
+					AccessibilityUtils.LogFatalError($"FriendListFrame.InteractWithFriend() reached unknown state: {dataModel.state}");
+					friendMenu.AddOption(GameStrings.Get("GLOBAL_CHAT_CHALLENGE"), () => ClickFriendChallengeButton(friend));
+					break;
+			}
+			if (netObject.Games.BattlegroundsFriendlyChallenge && !flag2 && player.GetHearthstoneGameAccount().GetBattlegroundsTutorialComplete() && GameUtils.IsBattleGroundsTutorialComplete())
+				friendMenu.AddOption(LocalizationUtils.Format(LocalizationKey.UI_SOCIAL_INVITE_FRIEND_TO_BG), () => InviteToBgParty(friend));
+		}
+		friendMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_CHAT_SEND_MESSAGE), () => friend.OpenChatWithFriend());
+	}
+
+	private void ReadFriendInvite(FriendListRequestFrame curRequest)
+	{
+		m_handleRequestMenu = new AccessibleMenu(this, "", RereadRequestsList);
+
+		var acceptRequestButton = curRequest.m_AcceptButton;
+		var declineRequestButton = curRequest.m_DeclineButton;
+
+		m_handleRequestMenu.AddOption(GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_ACCEPT"), acceptRequestButton.TriggerRelease);
+		m_handleRequestMenu.AddOption(GameStrings.Get("GLOBAL_FRIEND_CHALLENGE_DECLINE"), declineRequestButton.TriggerRelease);
+
+        m_handleRequestMenu.StartReading();
+
+		m_curState = State.READING_FRIEND_INVITE;
+	}
+
+	private void InviteToBgParty(FriendListFriendFrame friend) {
+				BnetPlayer player=friend.GetFriend();
+		/*
+		FriendListChallengeButton btn=friend.m_challengeButton;
+		var dataModel = btn.GetChallengeButtonDataModel();
+		if(dataModel.canClickButton==false) {
+			AccessibilityMgr.Output(this,btn.FormatBodytext(dataModel.text2));
+			return;
+		}
+		*/
+						SceneMgr.Get().SetNextMode(SceneMgr.Mode.BACON);
+		PartyManager.Get().SendInvite(PartyType.BATTLEGROUNDS_PARTY, player.GetBestGameAccountId());
+		var challengeFriendButton = friend.m_challengeButton;
+		challengeFriendButton.CloseFriendsListMenu();
+
+	}
+    private void ChallengeFriend(FriendListFriendFrame curFriend)
+    {
+		var challengeFriendButton = curFriend.m_challengeButton;
+		var dataModel = challengeFriendButton.GetChallengeButtonDataModel();
+
+		if (!dataModel.canClickButton)
+        {
+			AccessibilityUtils.LogDebug($"ChallengeFriend canClickButton=false");
+			var text = challengeFriendButton.FormatBodytext(dataModel.text2);
+			AccessibilityMgr.Output(this, text);
+        }
+		else
+        {
+			bool flag = PartyManager.Get().IsInBattlegroundsParty() && !SceneMgr.Get().IsInGame() && !GameMgr.Get().IsFindingGame();
+			if(!flag) SetupChallengeFriendMenu(curFriend);
+			else InviteToBgParty(curFriend);
+        }
+    }
+
+	private void SetupChallengeFriendMenu(FriendListFriendFrame curFriend)
+	{
+		m_challengeFriendMenu = new AccessibleMenu(this, "", RereadFriendsList);
+
+		AccessibilityUtils.LogDebug($"SetupChallengeFriendMenu");
+
+		m_challengeFriendMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_STANDARD), () => ClickVirtualChallengeButton(curFriend, FormatType.FT_STANDARD));
+
+		if (CollectionManager.Get().ShouldAccountSeeStandardWild())
+		{
+			m_challengeFriendMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_WILD), () => ClickVirtualChallengeButton(curFriend, FormatType.FT_WILD));
+			m_challengeFriendMenu.AddOption(LocalizationUtils.Get(LocalizationKey.GLOBAL_TWIST), () => ClickVirtualChallengeButton(curFriend, FormatType.FT_TWIST));
+		}
+
+		m_challengeFriendMenu.StartReading();
+		m_curState = State.CHALLENGING_FRIEND;
+	}
+
+	private void ClickVirtualChallengeButton(FriendListFriendFrame friend, FormatType format)
+	{
+		var challengeFriendButton = friend.m_challengeButton;
+
+		FriendListChallengeMenu.ClickVirtualChallengeButton(friend.GetFriend(), format);
+
+		challengeFriendButton.CloseFriendsListMenu();
+	}
+
+	private void ClickFriendChallengeButton(FriendListFriendFrame curFriend)
+    {
+		var challengeFriendButton = curFriend.m_challengeButton;
+		var dataModel = challengeFriendButton.GetChallengeButtonDataModel();
+		var challengeFriendButtonClickable = curFriend.m_challengeButtonClickable;
+
+		if (!dataModel.canClickButton)
+        {
+			AccessibilityUtils.LogDebug($"ClickFriendChallengeButton canClickButton=true");
+			var text = challengeFriendButton.FormatBodytext(dataModel.text2);
+			AccessibilityMgr.Output(this, text);
+        }
+		else
+        {
+			AccessibilityUtils.LogDebug($"ClickFriendChallengeButton canClickButton=false");
+			challengeFriendButtonClickable?.GetPegUIElement()?.TriggerRelease();
+			FriendListChallengeMenu.ClickSpectateButton(challengeFriendButton);
+
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_curState == State.MAIN_MENU)
+		{
+			return m_mainMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_FRIENDS_LIST)
+        {
+			return AccessibleSpeech.MENU_HORIZONTAL_HELP(true);
+		}
+		else if (m_curState == State.READING_NEARBY_LIST)
+        {
+			return AccessibleSpeech.MENU_HORIZONTAL_HELP(true);
+		}
+		else if (m_curState == State.REMOVING_FRIENDS)
+        {
+			return AccessibleSpeech.MENU_HORIZONTAL_HELP(true);
+        }
+		else if (m_curState == State.READING_PROFILE)
+        {
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+        }
+		else if (m_curState == State.INTERACTING_WITH_FRIEND)
+        {
+			return m_interactWithFriendMenu?.GetHelp();
+        }
+		else if (m_curState == State.CHALLENGING_FRIEND)
+		{
+			return m_interactWithFriendMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_FRIEND_INVITES)
+        {
+			return AccessibleSpeech.MENU_HORIZONTAL_HELP(true);
+        }
+		else if (m_curState == State.READING_FRIEND_INVITE)
+		{
+			return m_handleRequestMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_RECENT_LIST)
+		{
+			return m_accessibleRecents?.GetHelp(true);
+		}
+		else if (m_curState == State.INTERACTING_WITH_RECENT)
+		{
+			return m_interactWithRecentMenu?.GetHelp();
+		}
+
+		return "";
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/FriendListFriendFrame.cs b/Assembly-CSharp/FriendListFriendFrame.cs
index fd76672..56496c3 100644
--- a/Assembly-CSharp/FriendListFriendFrame.cs
+++ b/Assembly-CSharp/FriendListFriendFrame.cs
@@ -41,23 +41,23 @@ public class FriendListFriendFrame : MonoBehaviour
 
 	private Clickable m_clickable;
 
-	private FriendListFrame m_friendListFrame;
+	internal FriendListChallengeButton m_challengeButton;
 
-	private FriendListChallengeButton m_challengeButton;
+	private FriendListFrame m_friendListFrame;
 
 	private Widget m_friendFlyoutMenuWidget;
 
-	private Clickable m_challengeButtonClickable;
+	internal Clickable m_challengeButtonClickable;
 
 	private bool m_isRecentPlayerFrame;
 
 	private BnetPlayer m_player;
 
-	private MedalInfoTranslator m_rankedMedalInfo;
+	internal MedalInfoTranslator m_rankedMedalInfo;
 
 	private SelectableMedal m_selectableMedal;
 
-	private FriendDataModel m_friendDataModel;
+	internal FriendDataModel m_friendDataModel;
 
 	private Coroutine m_friendUpdateCoroutine;
 
@@ -318,9 +318,9 @@ public class FriendListFriendFrame : MonoBehaviour
 	private void OnChallengeButtonRelease(UIEvent e)
 	{
 		if (m_friendDataModel.IsInEditMode)
-		{
-			OnDeleteFriendButtonPressed();
-		}
+			{
+				OnDeleteFriendButtonPressed();
+			}
 		else
 		{
 			OnAvailableButtonPressed();
@@ -329,15 +329,7 @@ public class FriendListFriendFrame : MonoBehaviour
 
 	private void OnFriendFrameReleased(UIEvent e)
 	{
-		if (!(m_friendListFrame != null) || !m_friendListFrame.IsInEditMode)
-		{
-			FriendMgr.Get().SetSelectedFriend(m_player);
-			if (BnetFriendMgr.Get().IsFriend(m_player.GetAccountId()))
-			{
-				SoundManager.Get().LoadAndPlay("Small_Click.prefab:2a1c5335bf08dc84eb6e04fc58160681");
-				ChatMgr.Get().OnFriendListFriendSelected(m_player);
-			}
-		}
+		OpenChatWithFriend();
 	}
 
 	private void OnAvailableButtonPressed()
@@ -352,7 +344,7 @@ public class FriendListFriendFrame : MonoBehaviour
 		}
 	}
 
-	private void OnDeleteFriendButtonPressed()
+	internal void OnDeleteFriendButtonPressed()
 	{
 		if (m_friendListFrame != null)
 		{
@@ -567,4 +559,21 @@ public class FriendListFriendFrame : MonoBehaviour
 	{
 		m_widget.TriggerEvent(shouldHighlight ? "SHOW_HIGHLIGHT_CODE" : "HIDE_HIGHLIGHT_CODE");
 	}
+
+	#region Accessibility
+	internal void OpenChatWithFriend()
+	{
+		if (!(m_friendListFrame != null) || !m_friendListFrame.IsInEditMode)
+		{
+			FriendMgr.Get().SetSelectedFriend(m_player);
+			if (BnetFriendMgr.Get().IsFriend(m_player.GetAccountId()))
+			{
+				SoundManager.Get().LoadAndPlay("Small_Click.prefab:2a1c5335bf08dc84eb6e04fc58160681");
+				ChatMgr.Get().OnFriendListFriendSelected(m_player);
+			}
+		}
+	}
+
+	#endregion
+
 }
diff --git a/Assembly-CSharp/FriendListItemFooter.cs b/Assembly-CSharp/FriendListItemFooter.cs
index 274e80c..40c9997 100644
--- a/Assembly-CSharp/FriendListItemFooter.cs
+++ b/Assembly-CSharp/FriendListItemFooter.cs
@@ -59,15 +59,7 @@ public class FriendListItemFooter : PegUIElement, ITouchListItem
 	{
 	}
 
-	[SpecialName]
-	GameObject ITouchListItem.get_gameObject()
-	{
-		return base.gameObject;
-	}
 
-	[SpecialName]
-	Transform ITouchListItem.get_transform()
-	{
-		return base.transform;
-	}
+
+
 }
diff --git a/Assembly-CSharp/FriendListItemHeader.cs b/Assembly-CSharp/FriendListItemHeader.cs
index 3db8421..57f72d7 100644
--- a/Assembly-CSharp/FriendListItemHeader.cs
+++ b/Assembly-CSharp/FriendListItemHeader.cs
@@ -159,15 +159,7 @@ public class FriendListItemHeader : PegUIElement, ITouchListItem
 	{
 	}
 
-	[SpecialName]
-	GameObject ITouchListItem.get_gameObject()
-	{
-		return base.gameObject;
-	}
 
-	[SpecialName]
-	Transform ITouchListItem.get_transform()
-	{
-		return base.transform;
-	}
+
+
 }
diff --git a/Assembly-CSharp/FriendListRequestFrame.cs b/Assembly-CSharp/FriendListRequestFrame.cs
index dc069bc..ba5b3a7 100644
--- a/Assembly-CSharp/FriendListRequestFrame.cs
+++ b/Assembly-CSharp/FriendListRequestFrame.cs
@@ -67,12 +67,24 @@ public class FriendListRequestFrame : MonoBehaviour
 
 	private void OnAcceptButtonPressed(UIEvent e)
 	{
+		if (m_invite.m_isCheatInvite)
+		{
+			BnetFriendMgr.Get().Cheat_AcceptInvite(m_invite);
+			return;
+		}
+
 		BnetFriendMgr.Get().AcceptInvite(m_invite);
 		SoundManager.Get().LoadAndPlay(ON_CLICK_SOUND_PREFAB);
 	}
 
 	private void OnDeclineButtonPressed(UIEvent e)
 	{
+		if (m_invite.m_isCheatInvite)
+		{
+			BnetFriendMgr.Get().Cheat_DeclineInvite(m_invite.GetId());
+			return;
+		}
+
 		BnetFriendMgr.Get().IgnoreInvite(m_invite.GetId());
 		SoundManager.Get().LoadAndPlay(ON_CLICK_SOUND_PREFAB);
 	}
diff --git a/Assembly-CSharp/FriendlyChallengeDialog.cs b/Assembly-CSharp/FriendlyChallengeDialog.cs
index 7fe43b7..9c47154 100644
--- a/Assembly-CSharp/FriendlyChallengeDialog.cs
+++ b/Assembly-CSharp/FriendlyChallengeDialog.cs
@@ -1,5 +1,6 @@
 using System;
 using System.Collections;
+using Accessibility;
 using Blizzard.GameService.SDK.Client.Integration;
 using Blizzard.T5.MaterialService.Extensions;
 using Hearthstone.Core;
@@ -97,6 +98,8 @@ public class FriendlyChallengeDialog : DialogBase
 				SoundManager.Get().LoadAndPlay(m_friendQuestSliderSound2);
 			});
 		}
+
+		ReadPopup();
 	}
 
 	public override void Hide()
@@ -149,7 +152,7 @@ public class FriendlyChallengeDialog : DialogBase
 			{
 				key = "GLOBAL_FRIEND_CHALLENGE_BODY1_WILD";
 				if (m_wildFormatIcon != null)
-				{
+			{
 					m_wildFormatIcon.SetActive(value: true);
 				}
 			}
@@ -330,4 +333,32 @@ public class FriendlyChallengeDialog : DialogBase
 			m_friendlyQuestFrame.m_rewardMesh.gameObject.SetActive(value: false);
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadPopup()
+	{
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, $"{m_challengeText.Text} {m_challengerName.Text}");
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null);
+		m_accessibleMenu.AddOption(m_acceptButton.GetText(), m_acceptButton.TriggerRelease);
+		m_accessibleMenu.AddOption(m_denyButton.GetText(), m_denyButton.TriggerRelease);
+		m_accessibleMenu.StartReading();
+	}
+
+	public override void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public override string GetAccessibleHelp()
+	{
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/FriendlyChallengeHelper.cs b/Assembly-CSharp/FriendlyChallengeHelper.cs
index cae4e3d..53d1dd4 100644
--- a/Assembly-CSharp/FriendlyChallengeHelper.cs
+++ b/Assembly-CSharp/FriendlyChallengeHelper.cs
@@ -17,17 +17,7 @@ public class FriendlyChallengeHelper
 
 	private AlertPopup m_deckShareErrorPopup;
 
-	[CompilerGenerated]
-	private BnetAccountId <ActiveChallengeMenu>k__BackingField;
-
-	public BnetAccountId ActiveChallengeMenu
-	{
-		[CompilerGenerated]
-		set
-		{
-			<ActiveChallengeMenu>k__BackingField = value;
-		}
-	}
+	public BnetAccountId ActiveChallengeMenu { get; set; }
 
 	public static FriendlyChallengeHelper Get()
 	{
diff --git a/Assembly-CSharp/GAME_TAG.cs b/Assembly-CSharp/GAME_TAG.cs
index 96f4cb6..3aab7e4 100644
--- a/Assembly-CSharp/GAME_TAG.cs
+++ b/Assembly-CSharp/GAME_TAG.cs
@@ -1,229 +1,229 @@
 public enum GAME_TAG
 {
-	TAG_NOT_SET = 0,
-	TAG_SCRIPT_DATA_ENT_1 = 4,
-	TAG_SCRIPT_DATA_ENT_2 = 5,
-	TAG_SCRIPT_DATA_NUM_1 = 2,
-	TAG_SCRIPT_DATA_NUM_2 = 3,
-	TAG_SCRIPT_DATA_NUM_3 = 2889,
-	TAG_SCRIPT_DATA_NUM_4 = 2919,
-	TAG_SCRIPT_DATA_NUM_5 = 2920,
-	TAG_SCRIPT_DATA_NUM_6 = 2921,
-	TAG_TB_RANDOM_DECK_TIME_ID = 1358,
-	STATE = 204,
-	TURN = 20,
-	STEP = 19,
-	NEXT_STEP = 198,
-	ACTION_STEP_TYPE = 1700,
-	IS_CURRENT_TURN_AN_EXTRA_TURN = 547,
-	EXTRA_TURNS_TAKEN_THIS_GAME = 548,
-	WAIT_FOR_PLAYER_RECONNECT_PERIOD = 860,
-	PHASED_RESTART = 888,
-	SQUELCH_NON_GAME_TRIGGERS_AND_MODIFIERS = 1087,
-	SQUELCH_LIFETIME_EFFECTS = 1350,
-	BOARD_VISUAL_STATE = 1347,
-	ALLOW_MOVE_MINION = 1356,
+    TAG_NOT_SET = 0,
+    TAG_SCRIPT_DATA_ENT_1 = 4,
+    TAG_SCRIPT_DATA_ENT_2 = 5,
+    TAG_SCRIPT_DATA_NUM_1 = 2,
+    TAG_SCRIPT_DATA_NUM_2 = 3,
+    TAG_SCRIPT_DATA_NUM_3 = 2889,
+    TAG_SCRIPT_DATA_NUM_4 = 2919,
+    TAG_SCRIPT_DATA_NUM_5 = 2920,
+    TAG_SCRIPT_DATA_NUM_6 = 2921,
+    TAG_TB_RANDOM_DECK_TIME_ID = 1358,
+    STATE = 204,
+    TURN = 20,
+    STEP = 19,
+    NEXT_STEP = 198,
+    ACTION_STEP_TYPE = 1700,
+    IS_CURRENT_TURN_AN_EXTRA_TURN = 547,
+    EXTRA_TURNS_TAKEN_THIS_GAME = 548,
+    WAIT_FOR_PLAYER_RECONNECT_PERIOD = 860,
+    PHASED_RESTART = 888,
+    SQUELCH_NON_GAME_TRIGGERS_AND_MODIFIERS = 1087,
+    SQUELCH_LIFETIME_EFFECTS = 1350,
+    BOARD_VISUAL_STATE = 1347,
+    ALLOW_MOVE_MINION = 1356,
 	ALLOW_MOVE_BACON_SPELL = 3111,
-	CANT_MOVE_MINION = 1848,
-	USE_FAST_ACTOR_TRANSITION_ANIMATIONS = 1402,
-	HIGHLIGHT_ATTACKING_MINION_DURING_COMBAT = 1424,
-	DISABLE_NONHERO_GOLDEN_ANIMATIONS = 1514,
-	ALLOW_GAME_SPEEDUP = 1526,
-	SKIP_MULLIGAN = 1561,
-	DARKMOON_FAIRE_PRIZES_ACTIVE = 1895,
-	BACON_COMBAT_DAMAGE_CAP = 2089,
+    CANT_MOVE_MINION = 1848,
+    USE_FAST_ACTOR_TRANSITION_ANIMATIONS = 1402,
+    HIGHLIGHT_ATTACKING_MINION_DURING_COMBAT = 1424,
+    DISABLE_NONHERO_GOLDEN_ANIMATIONS = 1514,
+    ALLOW_GAME_SPEEDUP = 1526,
+    SKIP_MULLIGAN = 1561,
+    DARKMOON_FAIRE_PRIZES_ACTIVE = 1895,
+    BACON_COMBAT_DAMAGE_CAP = 2089,
 	BACON_COMBAT_DAMAGE_CAP_ENABLED = 3403,
-	GAME_SEED = 2042,
-	BACON_DIABLO_FIGHT_DIABLO_PLAYER_ID = 2226,
-	BACON_BUDDY_ENABLED = 2518,
-	BACON_EVOLUTION_CARD_ID = 2519,
-	BACON_QUESTS_ACTIVE = 2468,
-	BACON_MAX_LEADERBOARD_ARMOR = 2867,
+    GAME_SEED = 2042,
+    BACON_DIABLO_FIGHT_DIABLO_PLAYER_ID = 2226,
+    BACON_BUDDY_ENABLED = 2518,
+    BACON_EVOLUTION_CARD_ID = 2519,
+    BACON_QUESTS_ACTIVE = 2468,
+    BACON_MAX_LEADERBOARD_ARMOR = 2867,
 	BACON_USE_COIN_BASED_BUDDY_METER = 2935,
 	ANOMALY1 = 3182,
 	ANOMALY2 = 3183,
 	TEAM_ID = 31,
-	PLAYER_ID = 30,
-	STARTHANDSIZE = 29,
-	MAXHANDSIZE = 28,
-	MAXRESOURCES = 176,
-	MAXRESOURCES_BLOOD = 2188,
-	MAXRESOURCES_FROST = 2189,
-	MAXRESOURCES_UNHOLY = 2190,
-	MAXRESOURCES_DEATH = 2191,
-	TIMEOUT = 7,
-	TURN_START = 8,
-	TURN_TIMER_SLUSH = 9,
-	HEROPOWER_ADDITIONAL_ACTIVATIONS = 405,
-	HEROPOWER_ACTIVATIONS_THIS_TURN = 406,
-	BACON_DUMMY_PLAYER = 1349,
-	PROGRESSBAR_TOTAL = 1769,
-	PROGRESSBAR_PROGRESS = 1770,
-	PROGRESSBAR_CARDID = 1771,
-	PROGRESSBAR_SHOW = 1772,
-	PROGRESSBAR_TEXT = 1773,
-	EARLY_CONCEDE_POPUP_AVAILABLE = 2340,
-	BACON_NUMBER_HERO_REFRESH_AVAILABLE = 2452,
-	CARD_BACK_OVERRIDE = 2637,
-	CORPSES = 2186,
-	CORPSES_SPENT_THIS_GAME = 2639,
+    PLAYER_ID = 30,
+    STARTHANDSIZE = 29,
+    MAXHANDSIZE = 28,
+    MAXRESOURCES = 176,
+    MAXRESOURCES_BLOOD = 2188,
+    MAXRESOURCES_FROST = 2189,
+    MAXRESOURCES_UNHOLY = 2190,
+    MAXRESOURCES_DEATH = 2191,
+    TIMEOUT = 7,
+    TURN_START = 8,
+    TURN_TIMER_SLUSH = 9,
+    HEROPOWER_ADDITIONAL_ACTIVATIONS = 405,
+    HEROPOWER_ACTIVATIONS_THIS_TURN = 406,
+    BACON_DUMMY_PLAYER = 1349,
+    PROGRESSBAR_TOTAL = 1769,
+    PROGRESSBAR_PROGRESS = 1770,
+    PROGRESSBAR_CARDID = 1771,
+    PROGRESSBAR_SHOW = 1772,
+    PROGRESSBAR_TEXT = 1773,
+    EARLY_CONCEDE_POPUP_AVAILABLE = 2340,
+    BACON_NUMBER_HERO_REFRESH_AVAILABLE = 2452,
+    CARD_BACK_OVERRIDE = 2637,
+    CORPSES = 2186,
+    CORPSES_SPENT_THIS_GAME = 2639,
 	DECK_SWAP_ACTIVE = 2929,
 	CURRENT_EXCAVATE_TIER = 3249,
 	MAX_EXCAVATE_TIER = 3326,
 	DAMAGE_DEALT_TO_HERO_LAST_TURN = 2349,
-	FIRST_PLAYER = 24,
-	CURRENT_PLAYER = 23,
-	HERO_ENTITY = 27,
-	RESOURCES = 26,
-	RESOURCES_BLOOD = 2192,
-	RESOURCES_FROST = 2193,
-	RESOURCES_UNHOLY = 2194,
-	RESOURCES_DEATH = 2195,
-	RESOURCES_USED = 25,
-	FATIGUE = 22,
-	PLAYSTATE = 17,
+    FIRST_PLAYER = 24,
+    CURRENT_PLAYER = 23,
+    HERO_ENTITY = 27,
+    RESOURCES = 26,
+    RESOURCES_BLOOD = 2192,
+    RESOURCES_FROST = 2193,
+    RESOURCES_UNHOLY = 2194,
+    RESOURCES_DEATH = 2195,
+    RESOURCES_USED = 25,
+    FATIGUE = 22,
+    PLAYSTATE = 17,
 	CURRENT_SPELLPOWER_BASE = 291,
-	CURRENT_SPELLPOWER_ARCANE = 1936,
-	CURRENT_SPELLPOWER_FIRE = 1937,
-	CURRENT_SPELLPOWER_FROST = 1938,
-	CURRENT_SPELLPOWER_NATURE = 1939,
-	CURRENT_SPELLPOWER_HOLY = 1940,
-	CURRENT_SPELLPOWER_SHADOW = 1941,
-	CURRENT_SPELLPOWER_FEL = 1942,
-	CURRENT_SPELLPOWER_PHYSICAL = 1943,
+    CURRENT_SPELLPOWER_ARCANE = 1936,
+    CURRENT_SPELLPOWER_FIRE = 1937,
+    CURRENT_SPELLPOWER_FROST = 1938,
+    CURRENT_SPELLPOWER_NATURE = 1939,
+    CURRENT_SPELLPOWER_HOLY = 1940,
+    CURRENT_SPELLPOWER_SHADOW = 1941,
+    CURRENT_SPELLPOWER_FEL = 1942,
+    CURRENT_SPELLPOWER_PHYSICAL = 1943,
 	CURRENT_TEMP_SPELLPOWER_BASE = 2258,
-	CURRENT_TEMP_SPELLPOWER_ARCANE = 2250,
-	CURRENT_TEMP_SPELLPOWER_FEL = 2251,
-	CURRENT_TEMP_SPELLPOWER_FIRE = 2252,
-	CURRENT_TEMP_SPELLPOWER_FROST = 2253,
-	CURRENT_TEMP_SPELLPOWER_NATURE = 2254,
-	CURRENT_TEMP_SPELLPOWER_HOLY = 2255,
-	CURRENT_TEMP_SPELLPOWER_PHYSICAL = 2256,
-	CURRENT_TEMP_SPELLPOWER_SHADOW = 2257,
-	CURRENT_NEGATIVE_SPELLPOWER = 651,
-	CURRENT_HEALING_POWER = 2333,
-	MULLIGAN_STATE = 305,
-	ZONES_REVEALED = 348,
-	STEADY_SHOT_CAN_TARGET = 383,
-	OVERLOAD_THIS_GAME = 427,
-	SPELLS_COST_HEALTH = 431,
-	CANT_BE_FATIGUED = 456,
-	RED_MANA_CRYSTALS = 449,
-	WHIZBANG_DECK_ID = 1048,
-	EXTRA_BATTLECRIES_BASE = 411,
-	EXTRA_MINION_BATTLECRIES_BASE = 1112,
-	EXTRA_BATTLECRIES_ADDITIONAL = 1126,
-	EXTRA_DEATHRATTLES_BASE = 882,
-	EXTRA_MINION_DEATHRATTLES_BASE = 371,
-	EXTRA_DEATHRATTLES_ADDITIONAL = 1131,
-	AMOUNT_HEALED_THIS_GAME = 958,
-	NUM_HERO_POWER_DAMAGE_THIS_GAME = 1025,
-	MARK_OF_EVIL = 994,
-	HERO_FLYING = 1293,
-	AI_MAKES_DECISIONS_FOR_PLAYER = 1335,
-	DOUBLE_FATIGUE_DAMAGE = 1346,
-	PLAYER_LEADERBOARD_PLACE = 1373,
-	PLAYER_TECH_LEVEL = 1377,
-	PLAYER_TRIPLES = 1447,
-	NEXT_OPPONENT_PLAYER_ID = 1360,
+    CURRENT_TEMP_SPELLPOWER_ARCANE = 2250,
+    CURRENT_TEMP_SPELLPOWER_FEL = 2251,
+    CURRENT_TEMP_SPELLPOWER_FIRE = 2252,
+    CURRENT_TEMP_SPELLPOWER_FROST = 2253,
+    CURRENT_TEMP_SPELLPOWER_NATURE = 2254,
+    CURRENT_TEMP_SPELLPOWER_HOLY = 2255,
+    CURRENT_TEMP_SPELLPOWER_PHYSICAL = 2256,
+    CURRENT_TEMP_SPELLPOWER_SHADOW = 2257,
+    CURRENT_NEGATIVE_SPELLPOWER = 651,
+    CURRENT_HEALING_POWER = 2333,
+    MULLIGAN_STATE = 305,
+    ZONES_REVEALED = 348,
+    STEADY_SHOT_CAN_TARGET = 383,
+    OVERLOAD_THIS_GAME = 427,
+    SPELLS_COST_HEALTH = 431,
+    CANT_BE_FATIGUED = 456,
+    RED_MANA_CRYSTALS = 449,
+    WHIZBANG_DECK_ID = 1048,
+    EXTRA_BATTLECRIES_BASE = 411,
+    EXTRA_MINION_BATTLECRIES_BASE = 1112,
+    EXTRA_BATTLECRIES_ADDITIONAL = 1126,
+    EXTRA_DEATHRATTLES_BASE = 882,
+    EXTRA_MINION_DEATHRATTLES_BASE = 371,
+    EXTRA_DEATHRATTLES_ADDITIONAL = 1131,
+    AMOUNT_HEALED_THIS_GAME = 958,
+    NUM_HERO_POWER_DAMAGE_THIS_GAME = 1025,
+    MARK_OF_EVIL = 994,
+    HERO_FLYING = 1293,
+    AI_MAKES_DECISIONS_FOR_PLAYER = 1335,
+    DOUBLE_FATIGUE_DAMAGE = 1346,
+    PLAYER_LEADERBOARD_PLACE = 1373,
+    PLAYER_TECH_LEVEL = 1377,
+    PLAYER_TRIPLES = 1447,
+    NEXT_OPPONENT_PLAYER_ID = 1360,
 	NEXT_OPPONENT_TEAMMATE_PLAYER_ID = 2988,
-	BACON_ODD_PLAYER_OUT = 1415,
+    BACON_ODD_PLAYER_OUT = 1415,
 	BACON_DUO_TEAMMATE_PLAYER_ID = 2939,
 	BACON_DUO_TEAM_ID = 3095,
 	DUOS_QUEUED_NOT_ON_TEAM = 3478,
 	PLAYER_ABANDONED_BY_TEAMMATE = 3480,
 	BACON_MAX_PLAYER_TECH_LEVEL = 1494,
-	MAIN_GALAKROND = 1361,
-	PROXY_GALAKROND = 1190,
-	INVOKE_COUNTER = 1366,
-	GALAKROND_HERO_CARD = 1365,
-	BACON_HERO_POWER_ACTIVATED = 1398,
-	PROXY_CTHUN_SHATTERED = 1768,
-	PLAYED_CTHUN_EYE = 1764,
-	PLAYED_CTHUN_BODY = 1765,
-	PLAYED_CTHUN_MAW = 1766,
-	PLAYED_CTHUN_HEART = 1767,
-	NUM_SPELLS_PLAYED_THIS_GAME = 1780,
-	ARMOR_GAINED_THIS_GAME = 1828,
-	BACON_PLAYER_NUM_HERO_BUDDIES_GAINED = 2346,
-	BACON_HERO_BUDDY_PROGRESS = 2364,
-	MAX_SLOTS_PER_PLAYER_OVERRIDE = 2017,
+    MAIN_GALAKROND = 1361,
+    PROXY_GALAKROND = 1190,
+    INVOKE_COUNTER = 1366,
+    GALAKROND_HERO_CARD = 1365,
+    BACON_HERO_POWER_ACTIVATED = 1398,
+    PROXY_CTHUN_SHATTERED = 1768,
+    PLAYED_CTHUN_EYE = 1764,
+    PLAYED_CTHUN_BODY = 1765,
+    PLAYED_CTHUN_MAW = 1766,
+    PLAYED_CTHUN_HEART = 1767,
+    NUM_SPELLS_PLAYED_THIS_GAME = 1780,
+    ARMOR_GAINED_THIS_GAME = 1828,
+    BACON_PLAYER_NUM_HERO_BUDDIES_GAINED = 2346,
+    BACON_HERO_BUDDY_PROGRESS = 2364,
+    MAX_SLOTS_PER_PLAYER_OVERRIDE = 2017,
 	BACON_BLOODGEMBUFFATKVALUE = 1844,
 	BACON_BLOODGEMBUFFHEALTHVALUE = 2827,
 	BACON_DUO_PLAYER_FIGHTS_FIRST_NEXT_COMBAT = 2975,
 	BACON_TEAMMATE_BONUS_MINION_DAMAGE_LAST_COMBAT = 3492,
 	BACON_DUOS_PUNISH_LEAVERS = 3494,
-	CARDRACE = 200,
-	CARDTYPE = 202,
-	COST = 48,
-	COST_BLOOD = 2196,
-	COST_FROST = 2197,
-	COST_UNHOLY = 2198,
-	COST_DEATH = 2199,
-	HEALTH = 45,
-	ATK = 47,
-	DURABILITY = 187,
-	ARMOR = 292,
-	PREDAMAGE = 318,
-	PREHEALING = 425,
-	TAG_LAST_KNOWN_COST_IN_HAND = 466,
-	TARGETING_ARROW_TEXT = 325,
-	LAST_AFFECTED_BY = 18,
-	ENCHANTMENT_BIRTH_VISUAL = 330,
-	ENCHANTMENT_IDLE_VISUAL = 331,
-	PREMIUM = 12,
-	COLLECTIBLE = 321,
-	CARDTEXT = 184,
-	CUSTOMTEXT1 = 1093,
-	CUSTOMTEXT2 = 1094,
-	CUSTOMTEXT3 = 1095,
-	DECK_LIST_SORT_ORDER = 1125,
-	HERO_DECK_ID = 793,
-	GAME_MODE_BUTTON_SLOT = 1438,
-	TECH_LEVEL = 1440,
-	MOVE_MINION_HOVER_TARGET_SLOT = 1464,
-	BACON_ACTION_CARD = 1437,
-	IS_BACON_POOL_MINION = 1456,
-	BACON_HERO_CAN_BE_DRAFTED = 1491,
-	SPAWN_TIME_COUNT = 1556,
-	SPELL_SCHOOL = 1635,
-	BACON_PLAYER_RESULTS_HERO_OVERRIDE = 1649,
-	MINI_SET = 1824,
-	HAS_DIAMOND_QUALITY = 1932,
-	HAS_SIGNATURE_QUALITY = 2589,
-	BACON_SKIN = 2038,
-	BACON_SKIN_PARENT_ID = 2039,
-	BACON_BOB_SKIN = 2049,
+    CARDRACE = 200,
+    CARDTYPE = 202,
+    COST = 48,
+    COST_BLOOD = 2196,
+    COST_FROST = 2197,
+    COST_UNHOLY = 2198,
+    COST_DEATH = 2199,
+    HEALTH = 45,
+    ATK = 47,
+    DURABILITY = 187,
+    ARMOR = 292,
+    PREDAMAGE = 318,
+    PREHEALING = 425,
+    TAG_LAST_KNOWN_COST_IN_HAND = 466,
+    TARGETING_ARROW_TEXT = 325,
+    LAST_AFFECTED_BY = 18,
+    ENCHANTMENT_BIRTH_VISUAL = 330,
+    ENCHANTMENT_IDLE_VISUAL = 331,
+    PREMIUM = 12,
+    COLLECTIBLE = 321,
+    CARDTEXT = 184,
+    CUSTOMTEXT1 = 1093,
+    CUSTOMTEXT2 = 1094,
+    CUSTOMTEXT3 = 1095,
+    DECK_LIST_SORT_ORDER = 1125,
+    HERO_DECK_ID = 793,
+    GAME_MODE_BUTTON_SLOT = 1438,
+    TECH_LEVEL = 1440,
+    MOVE_MINION_HOVER_TARGET_SLOT = 1464,
+    BACON_ACTION_CARD = 1437,
+    IS_BACON_POOL_MINION = 1456,
+    BACON_HERO_CAN_BE_DRAFTED = 1491,
+    SPAWN_TIME_COUNT = 1556,
+    SPELL_SCHOOL = 1635,
+    BACON_PLAYER_RESULTS_HERO_OVERRIDE = 1649,
+    MINI_SET = 1824,
+    HAS_DIAMOND_QUALITY = 1932,
+    HAS_SIGNATURE_QUALITY = 2589,
+    BACON_SKIN = 2038,
+    BACON_SKIN_PARENT_ID = 2039,
+    BACON_BOB_SKIN = 2049,
 	BACON_COMBAT_PHASE_HERO = 3048,
-	TARGETING_ARROW_TYPE = 2108,
-	LOCATION_ACTION_COST = 2352,
-	LOCATION_ACTION_COOLDOWN = 2353,
-	IMP = 1965,
-	WHELP = 2355,
-	EVIL_TWIN_MUSTACHE = 2611,
+    TARGETING_ARROW_TYPE = 2108,
+    LOCATION_ACTION_COST = 2352,
+    LOCATION_ACTION_COOLDOWN = 2353,
+    IMP = 1965,
+    WHELP = 2355,
+    EVIL_TWIN_MUSTACHE = 2611,
 	SUPPRESS_EVIL_TWIN_MUSTACHE_SOUND = 3198,
-	HAS_BLOOD_PLAGUE = 2211,
-	HAS_FROST_PLAGUE = 2212,
-	HAS_UNHOLY_PLAGUE = 2213,
+    HAS_BLOOD_PLAGUE = 2211,
+    HAS_FROST_PLAGUE = 2212,
+    HAS_UNHOLY_PLAGUE = 2213,
 	HERO_ATTACK_GIVEN_ADDITIONAL = 2776,
 	HERO_ARMOR_GIVEN_ADDITIONAL = 2778,
-	HAS_ACTIVATE_POWER = 2840,
+    HAS_ACTIVATE_POWER = 2840,
 	BACON_COSTS_HEALTH_TO_BUY = 2911,
 	HERO_DOESNT_MOVE_ON_ATTACK = 3211,
 	OBFUSCATED = 391,
 	SUPPRESS_MILL_ANIMATION = 3481,
 	IGNORE_SUPPRESS_MILL_ANIMATION = 3482,
-	CARDTEXT_ENTITY_0 = 2655,
-	CARDTEXT_ENTITY_1 = 2656,
-	CARDTEXT_ENTITY_2 = 2657,
-	CARDTEXT_ENTITY_3 = 2658,
-	CARDTEXT_ENTITY_4 = 2659,
-	CARDTEXT_ENTITY_5 = 2660,
-	CARDTEXT_ENTITY_6 = 2661,
-	CARDTEXT_ENTITY_7 = 2662,
-	CARDTEXT_ENTITY_8 = 2663,
-	CARDTEXT_ENTITY_9 = 2664,
-	CARDTEXT_ENTITY_AS_NUMBERS = 2802,
+    CARDTEXT_ENTITY_0 = 2655,
+    CARDTEXT_ENTITY_1 = 2656,
+    CARDTEXT_ENTITY_2 = 2657,
+    CARDTEXT_ENTITY_3 = 2658,
+    CARDTEXT_ENTITY_4 = 2659,
+    CARDTEXT_ENTITY_5 = 2660,
+    CARDTEXT_ENTITY_6 = 2661,
+    CARDTEXT_ENTITY_7 = 2662,
+    CARDTEXT_ENTITY_8 = 2663,
+    CARDTEXT_ENTITY_9 = 2664,
+    CARDTEXT_ENTITY_AS_NUMBERS = 2802,
 	BACON_BUY_BUDDY = 2937,
 	BACON_BUY_BUDDY_2 = 2938,
 	BACON_SHOW_HEROPOWER_BUDDY_AS_EVOLVING_BIG_CARD = 2943,
@@ -232,102 +232,102 @@ public enum GAME_TAG
 	EMOTECLASS = 2851,
 	IS_ALTERNATE_HEROPOWER = 3130,
 	HERO_FRAME_TYPE = 3495,
-	ENTITY_ID = 53,
-	DEFINITION = 52,
-	OWNER = 51,
-	CONTROLLER = 50,
-	ZONE = 49,
-	EXHAUSTED = 43,
-	ATTACHED = 40,
-	PROPOSED_ATTACKER = 39,
-	ATTACKING = 38,
-	PROPOSED_DEFENDER = 37,
-	DEFENDING = 36,
-	PROTECTED = 35,
-	PROTECTING = 34,
-	RECENTLY_ARRIVED = 33,
-	DAMAGE = 44,
-	DATABASE_ID = 327,
-	MODULAR_ENTITY_PART_1 = 471,
-	MODULAR_ENTITY_PART_2 = 472,
-	QUEST_PROGRESS = 534,
-	QUEST_PROGRESS_TOTAL = 535,
-	QUEST_CONTRIBUTOR = 541,
-	QUEST_REWARD_DATABASE_ID = 1089,
-	QUESTLINE_FINAL_REWARD_DATABASE_ID = 1992,
-	QUESTLINE_PART = 1993,
-	QUESTLINE_REQUIREMENT_MET_1 = 1994,
-	QUESTLINE_REQUIREMENT_MET_2 = 1995,
-	QUESTLINE_REQUIREMENT_MET_3 = 1996,
-	SHIFTING = 438,
-	SHIFTING_MINION = 549,
-	SHIFTING_WEAPON = 550,
-	SHIFTING_SPELL = 936,
+    ENTITY_ID = 53,
+    DEFINITION = 52,
+    OWNER = 51,
+    CONTROLLER = 50,
+    ZONE = 49,
+    EXHAUSTED = 43,
+    ATTACHED = 40,
+    PROPOSED_ATTACKER = 39,
+    ATTACKING = 38,
+    PROPOSED_DEFENDER = 37,
+    DEFENDING = 36,
+    PROTECTED = 35,
+    PROTECTING = 34,
+    RECENTLY_ARRIVED = 33,
+    DAMAGE = 44,
+    DATABASE_ID = 327,
+    MODULAR_ENTITY_PART_1 = 471,
+    MODULAR_ENTITY_PART_2 = 472,
+    QUEST_PROGRESS = 534,
+    QUEST_PROGRESS_TOTAL = 535,
+    QUEST_CONTRIBUTOR = 541,
+    QUEST_REWARD_DATABASE_ID = 1089,
+    QUESTLINE_FINAL_REWARD_DATABASE_ID = 1992,
+    QUESTLINE_PART = 1993,
+    QUESTLINE_REQUIREMENT_MET_1 = 1994,
+    QUESTLINE_REQUIREMENT_MET_2 = 1995,
+    QUESTLINE_REQUIREMENT_MET_3 = 1996,
+    SHIFTING = 438,
+    SHIFTING_MINION = 549,
+    SHIFTING_WEAPON = 550,
+    SHIFTING_SPELL = 936,
 	SHIFTING_LOCATION = 2783,
-	TREASURE = 557,
-	TREASURE_DEFINTIONAL_ATTACK = 558,
-	TREASURE_DEFINTIONAL_COST = 559,
-	TREASURE_DEFINTIONAL_HEALTH = 560,
-	ACTS_LIKE_A_SPELL = 561,
-	EMPOWERED_TREASURE = 646,
-	ONE_SIDED_GHOSTLY = 648,
-	OPPONENT_SIDE_GHOSTLY = 1609,
-	IS_VAMPIRE = 680,
-	VALEERASHADOW = 779,
-	RECRUIT = 763,
-	LOOT_CARD_1 = 764,
-	LOOT_CARD_2 = 765,
-	LOOT_CARD_3 = 766,
-	OVERRIDECARDNAME = 781,
-	OVERRIDECARDTEXTBUILDER = 782,
-	USE_ALTERNATE_CARD_TEXT = 955,
-	TREAT_AS_PLAYED_HERO_CARD = 1016,
-	FLOOPY = 1097,
-	PLAYER_TAG_THRESHOLD_TAG_ID = 1115,
-	PLAYER_TAG_THRESHOLD_VALUE = 1116,
-	ENTITY_TAG_THRESHOLD_TAG_ID = 2459,
-	ENTITY_TAG_THRESHOLD_VALUE = 2460,
-	HIDE_WATERMARK = 1107,
-	WATERMARK_OVERRIDE_CARD_SET = 1517,
-	COPIED_BY_KHADGAR = 1326,
-	COLLECTION_RELATED_CARD_DATABASE_ID = 1452,
-	COPIED_FROM_ENTITY_ID = 1565,
-	USE_LEADERBOARD_AS_SPAWN_ORIGIN = 1628,
-	BACON_MUKLA_BANANA_SPAWN_COUNT = 1629,
-	BACON_QUEST_COMPLETED = 2633,
-	TRANSFORMED_FROM_CARD_VISUAL_TYPE = 1719,
-	DARKMOON_TICKET = 1776,
-	SHOW_DISCOVER_FROM_DECK = 1816,
-	CARD_NAME_DATA_1 = 2890,
+    TREASURE = 557,
+    TREASURE_DEFINTIONAL_ATTACK = 558,
+    TREASURE_DEFINTIONAL_COST = 559,
+    TREASURE_DEFINTIONAL_HEALTH = 560,
+    ACTS_LIKE_A_SPELL = 561,
+    EMPOWERED_TREASURE = 646,
+    ONE_SIDED_GHOSTLY = 648,
+    OPPONENT_SIDE_GHOSTLY = 1609,
+    IS_VAMPIRE = 680,
+    VALEERASHADOW = 779,
+    RECRUIT = 763,
+    LOOT_CARD_1 = 764,
+    LOOT_CARD_2 = 765,
+    LOOT_CARD_3 = 766,
+    OVERRIDECARDNAME = 781,
+    OVERRIDECARDTEXTBUILDER = 782,
+    USE_ALTERNATE_CARD_TEXT = 955,
+    TREAT_AS_PLAYED_HERO_CARD = 1016,
+    FLOOPY = 1097,
+    PLAYER_TAG_THRESHOLD_TAG_ID = 1115,
+    PLAYER_TAG_THRESHOLD_VALUE = 1116,
+    ENTITY_TAG_THRESHOLD_TAG_ID = 2459,
+    ENTITY_TAG_THRESHOLD_VALUE = 2460,
+    HIDE_WATERMARK = 1107,
+    WATERMARK_OVERRIDE_CARD_SET = 1517,
+    COPIED_BY_KHADGAR = 1326,
+    COLLECTION_RELATED_CARD_DATABASE_ID = 1452,
+    COPIED_FROM_ENTITY_ID = 1565,
+    USE_LEADERBOARD_AS_SPAWN_ORIGIN = 1628,
+    BACON_MUKLA_BANANA_SPAWN_COUNT = 1629,
+    BACON_QUEST_COMPLETED = 2633,
+    TRANSFORMED_FROM_CARD_VISUAL_TYPE = 1719,
+    DARKMOON_TICKET = 1776,
+    SHOW_DISCOVER_FROM_DECK = 1816,
+    CARD_NAME_DATA_1 = 2890,
 	HIDDEN_CHOICE_OVERRIDE = 2946,
 	COIN_CARD = 2088,
 	TRIGGER_VISUAL = 32,
-	TAG_ONE_TURN_EFFECT = 338,
-	TAUNT = 190,
-	SPELLPOWER = 192,
-	SPELLPOWER_ARCANE = 1945,
-	SPELLPOWER_FIRE = 1946,
-	SPELLPOWER_FROST = 1947,
-	SPELLPOWER_NATURE = 1948,
-	SPELLPOWER_HOLY = 1949,
-	SPELLPOWER_SHADOW = 1950,
-	SPELLPOWER_FEL = 1951,
-	SPELLPOWER_PHYSICAL = 1952,
-	DIVINE_SHIELD = 194,
-	CHARGE = 197,
-	SECRET = 219,
-	MORPH = 293,
-	TAUNT_READY = 306,
-	IGNORE_TAUNT = 433,
-	STEALTH_READY = 307,
-	CHARGE_READY = 308,
-	CREATOR = 313,
-	CREATOR_DBID = 1284,
+    TAG_ONE_TURN_EFFECT = 338,
+    TAUNT = 190,
+    SPELLPOWER = 192,
+    SPELLPOWER_ARCANE = 1945,
+    SPELLPOWER_FIRE = 1946,
+    SPELLPOWER_FROST = 1947,
+    SPELLPOWER_NATURE = 1948,
+    SPELLPOWER_HOLY = 1949,
+    SPELLPOWER_SHADOW = 1950,
+    SPELLPOWER_FEL = 1951,
+    SPELLPOWER_PHYSICAL = 1952,
+    DIVINE_SHIELD = 194,
+    CHARGE = 197,
+    SECRET = 219,
+    MORPH = 293,
+    TAUNT_READY = 306,
+    IGNORE_TAUNT = 433,
+    STEALTH_READY = 307,
+    CHARGE_READY = 308,
+    CREATOR = 313,
+    CREATOR_DBID = 1284,
 	START_OF_GAME_KEYWORD = 968,
-	HEALING_DOES_DAMAGE_HINT = 1117,
-	LIFESTEAL_DOES_DAMAGE_HINT = 1774,
-	AFFECTED_BY_HEALING_DOES_DAMAGE = 1118,
-	RULEBOOK = 1430,
+    HEALING_DOES_DAMAGE_HINT = 1117,
+    LIFESTEAL_DOES_DAMAGE_HINT = 1774,
+    AFFECTED_BY_HEALING_DOES_DAMAGE = 1118,
+    RULEBOOK = 1430,
 	SPELL_RESISTANCE_ARCANE = 2138,
 	SPELL_RESISTANCE_FIRE = 2139,
 	SPELL_RESISTANCE_FROST = 2140,
@@ -344,474 +344,474 @@ public enum GAME_TAG
 	SPELL_WEAKNESS_FEL = 2151,
 	LETTUCE_KEYWORD_ATTACK = 2159,
 	LETTUCE_KEYWORD_SPELL_COMBO = 2160,
-	LETTUCE_SPELLDAMAGEARCANE = 2171,
-	LETTUCE_SPELLDAMAGEFEL = 2172,
-	LETTUCE_SPELLDAMAGEFIRE = 2173,
-	LETTUCE_SPELLDAMAGEFROST = 2174,
-	LETTUCE_SPELLDAMAGEHOLY = 2175,
-	LETTUCE_SPELLDAMAGENATURE = 2176,
-	LETTUCE_SPELLDAMAGESHADOW = 2177,
-	DEATHBLOW = 2185,
+    LETTUCE_SPELLDAMAGEARCANE = 2171,
+    LETTUCE_SPELLDAMAGEFEL = 2172,
+    LETTUCE_SPELLDAMAGEFIRE = 2173,
+    LETTUCE_SPELLDAMAGEFROST = 2174,
+    LETTUCE_SPELLDAMAGEHOLY = 2175,
+    LETTUCE_SPELLDAMAGENATURE = 2176,
+    LETTUCE_SPELLDAMAGESHADOW = 2177,
+    DEATHBLOW = 2185,
 	LETTUCE_BLEED = 2214,
 	LETTUCE_KEYWORD_CRITICAL_DAMAGE = 2219,
 	LETTUCE_KEYWORD_ROOT = 2220,
-	LETTUCE_ALLIANCE = 2279,
-	LETTUCE_HORDE = 2280,
-	LETTUCE_REFRESH = 2312,
-	LETTUCE_ELVES = 2322,
-	REVIVE = 2369,
-	ALLIED = 2388,
+    LETTUCE_ALLIANCE = 2279,
+    LETTUCE_HORDE = 2280,
+    LETTUCE_REFRESH = 2312,
+    LETTUCE_ELVES = 2322,
+    REVIVE = 2369,
+    ALLIED = 2388,
 	LETTUCE_KEYWORD_HEALING_POWER = 2434,
 	MERCENARIES_SPELL_WEAKNESS = 2464,
 	MERCENARIES_SPELL_RESISTANCE = 2465,
-	MERCS_BENCH = 2570,
-	MERCS_EXPLORER = 2510,
+    MERCS_BENCH = 2570,
+    MERCS_EXPLORER = 2510,
 	LETTUCE_KEYWORD_SILENCE = 2631,
-	LETTUCE_CHARGE = 2779,
-	MERCENARIES_TREASURE_SCALE_LEVEL = 2810,
-	CANT_DRAW = 232,
-	CANT_PLAY = 231,
-	CANT_DISCARD = 230,
-	CANT_ATTACK = 227,
-	CANT_READY = 225,
-	CANT_REMOVE_FROM_GAME = 224,
-	CANT_SET_ASIDE = 223,
-	CANT_DAMAGE = 222,
-	CANT_HEAL = 221,
-	CANT_TRIGGER_DEATHRATTLE = 1831,
-	CANT_BE_DESTROYED = 247,
-	CANT_BE_TARGETED = 246,
-	CANT_BE_ATTACKED = 245,
-	CANT_BE_READIED = 243,
-	CANT_BE_REMOVED_FROM_GAME = 242,
-	CANT_BE_SET_ASIDE = 241,
-	IMMUNE = 240,
-	CANT_BE_HEALED = 239,
-	CANT_BE_SUMMONING_SICK = 253,
-	CANT_BE_SILENCED = 314,
-	APPEAR_FUNCTIONALLY_DEAD = 426,
-	FROZEN = 260,
-	JUST_PLAYED = 261,
-	LINKED_ENTITY = 262,
-	ZONE_POSITION = 263,
-	CANT_BE_FROZEN = 264,
-	COMBO_ACTIVE = 266,
-	CARD_TARGET = 267,
-	NUM_CARDS_PLAYED_THIS_TURN = 269,
-	CANT_BE_TARGETED_BY_OPPONENTS = 270,
-	NUM_TURNS_IN_PLAY = 271,
-	NUM_TURNS_IN_HAND = 273,
-	SUMMONED = 205,
-	ENRAGED = 212,
+    LETTUCE_CHARGE = 2779,
+    MERCENARIES_TREASURE_SCALE_LEVEL = 2810,
+    CANT_DRAW = 232,
+    CANT_PLAY = 231,
+    CANT_DISCARD = 230,
+    CANT_ATTACK = 227,
+    CANT_READY = 225,
+    CANT_REMOVE_FROM_GAME = 224,
+    CANT_SET_ASIDE = 223,
+    CANT_DAMAGE = 222,
+    CANT_HEAL = 221,
+    CANT_TRIGGER_DEATHRATTLE = 1831,
+    CANT_BE_DESTROYED = 247,
+    CANT_BE_TARGETED = 246,
+    CANT_BE_ATTACKED = 245,
+    CANT_BE_READIED = 243,
+    CANT_BE_REMOVED_FROM_GAME = 242,
+    CANT_BE_SET_ASIDE = 241,
+    IMMUNE = 240,
+    CANT_BE_HEALED = 239,
+    CANT_BE_SUMMONING_SICK = 253,
+    CANT_BE_SILENCED = 314,
+    APPEAR_FUNCTIONALLY_DEAD = 426,
+    FROZEN = 260,
+    JUST_PLAYED = 261,
+    LINKED_ENTITY = 262,
+    ZONE_POSITION = 263,
+    CANT_BE_FROZEN = 264,
+    COMBO_ACTIVE = 266,
+    CARD_TARGET = 267,
+    NUM_CARDS_PLAYED_THIS_TURN = 269,
+    CANT_BE_TARGETED_BY_OPPONENTS = 270,
+    NUM_TURNS_IN_PLAY = 271,
+    NUM_TURNS_IN_HAND = 273,
+    SUMMONED = 205,
+    ENRAGED = 212,
 	ENRAGE_TOOLTIP = 1954,
-	SILENCED = 188,
-	WINDFURY = 189,
-	MEGA_WINDFURY = 1207,
+    SILENCED = 188,
+    WINDFURY = 189,
+    MEGA_WINDFURY = 1207,
 	ELUSIVE = 1211,
-	LOYALTY = 216,
-	DEATHRATTLE = 217,
-	ADJACENT_BUFF = 350,
-	STEALTH = 191,
-	BATTLECRY = 218,
-	NUM_TURNS_LEFT = 272,
+    LOYALTY = 216,
+    DEATHRATTLE = 217,
+    ADJACENT_BUFF = 350,
+    STEALTH = 191,
+    BATTLECRY = 218,
+    NUM_TURNS_LEFT = 272,
 	NUM_TURNS_LAST_AFFECTED_BY = 3464,
-	IS_MORPHED = 294,
-	TEMP_RESOURCES = 295,
-	OVERLOAD_OWED = 296,
-	NUM_ATTACKS_THIS_TURN = 297,
-	NEXT_ALLY_BUFF = 302,
-	MAGNET = 303,
-	FIRST_CARD_PLAYED_THIS_TURN = 304,
-	CANT_BE_TARGETED_BY_SPELLS = 311,
-	SHOULDEXITCOMBAT = 312,
-	PARENT_CARD = 316,
-	NUM_MINIONS_PLAYED_THIS_TURN = 317,
-	CANT_BE_TARGETED_BY_HERO_POWERS = 332,
-	CANT_BE_TARGETED_BY_BATTLECRIES = 379,
-	CANNOT_ATTACK_HEROES = 413,
-	UNTOUCHABLE = 448,
-	QUEST = 462,
+    IS_MORPHED = 294,
+    TEMP_RESOURCES = 295,
+    OVERLOAD_OWED = 296,
+    NUM_ATTACKS_THIS_TURN = 297,
+    NEXT_ALLY_BUFF = 302,
+    MAGNET = 303,
+    FIRST_CARD_PLAYED_THIS_TURN = 304,
+    CANT_BE_TARGETED_BY_SPELLS = 311,
+    SHOULDEXITCOMBAT = 312,
+    PARENT_CARD = 316,
+    NUM_MINIONS_PLAYED_THIS_TURN = 317,
+    CANT_BE_TARGETED_BY_HERO_POWERS = 332,
+    CANT_BE_TARGETED_BY_BATTLECRIES = 379,
+    CANNOT_ATTACK_HEROES = 413,
+    UNTOUCHABLE = 448,
+    QUEST = 462,
 	SIDE_QUEST = 1192,
-	SIGIL = 1749,
-	OBJECTIVE = 2311,
-	OBJECTIVE_AURA = 2329,
+    SIGIL = 1749,
+    OBJECTIVE = 2311,
+    OBJECTIVE_AURA = 2329,
 	PALADIN_AURA = 3374,
-	FINISH_ATTACK_SPELL_ON_DAMAGE = 470,
-	ADAPT = 546,
-	GEARS = 1052,
-	GOOD_OL_GENERIC_FRIENDLY_DRAGON_DISCOVER_VISUALS = 1364,
-	DISCOVER_STUDIES_VISUAL = 1650,
-	DUNGEON_PASSIVE_BUFF = 783,
-	HEALING_DOES_DAMAGE = 326,
-	ALTERNATE_CHAPTER_VO = 1334,
-	LIFESTEAL_DAMAGES_OPPOSING_HERO = 1675,
+    FINISH_ATTACK_SPELL_ON_DAMAGE = 470,
+    ADAPT = 546,
+    GEARS = 1052,
+    GOOD_OL_GENERIC_FRIENDLY_DRAGON_DISCOVER_VISUALS = 1364,
+    DISCOVER_STUDIES_VISUAL = 1650,
+    DUNGEON_PASSIVE_BUFF = 783,
+    HEALING_DOES_DAMAGE = 326,
+    ALTERNATE_CHAPTER_VO = 1334,
+    LIFESTEAL_DAMAGES_OPPOSING_HERO = 1675,
 	MAGNETIC = 849,
 	TITAN = 2772,
 	TITAN_ABILITY_USED_1 = 3140,
 	TITAN_ABILITY_USED_2 = 3141,
 	TITAN_ABILITY_USED_3 = 3142,
-	SCORE_LABELID_1 = 450,
-	SCORE_LABELID_2 = 452,
-	SCORE_LABELID_3 = 454,
-	SCORE_VALUE_1 = 451,
-	SCORE_VALUE_2 = 453,
-	SCORE_VALUE_3 = 455,
-	SCORE_FOOTERID = 751,
-	ZOMBEAST_DEBUG_CURRENT_BEAST_DATABASE_ID = 964,
-	ZOMBEAST_DEBUG_CURRENT_ITERATION = 965,
-	ZOMBEAST_DEBUG_MAX_ITERATIONS = 966,
-	DRUSTVAR_HORROR_DEBUG_CURRENT_SPELL_DATABASE_ID = 1280,
-	DRUSTVAR_HORROR_DEBUG_CURRENT_ITERATION = 1281,
-	DRUSTVAR_HORROR_DEBUG_MAX_ITERATIONS = 1283,
-	DEBUG_DISPLAY_TAG_BOTTOM_RIGHT = 1313,
-	DEBUG_DISPLAY_TAG_TOP_RIGHT = 1314,
-	SMART_DISCOVER_DEBUG_ENTITY_1 = 1318,
-	SMART_DISCOVER_DEBUG_ENTITY_2 = 1319,
-	SMART_DISCOVER_DEBUG_ENTITY_3 = 1320,
-	SMART_DISCOVER_DEBUG_TEST_COMPLETE = 1324,
-	SMART_DISCOVER_DEBUG_PASSIVE_EVAL_RESULT_1 = 1328,
-	SMART_DISCOVER_DEBUG_PASSIVE_EVAL_RESULT_2 = 1329,
-	SMART_DISCOVER_DEBUG_PASSIVE_EVAL_RESULT_3 = 1330,
-	CHOICE_NAME_DISPLAY_TYPE = 1687,
-	CHOICE_ACTOR_TYPE = 1692,
-	COMBO = 220,
-	ELITE = 114,
-	CARD_SET = 183,
-	FACTION = 201,
-	RARITY = 203,
-	CLASS = 199,
-	MISSION_EVENT = 6,
-	FREEZE = 208,
-	OVERLOAD = 215,
-	SILENCE = 339,
-	COUNTER = 340,
-	FORCED_PLAY = 352,
-	LOW_HEALTH_THRESHOLD = 353,
-	SPELLPOWER_DOUBLE = 356,
-	SPELL_HEALING_DOUBLE = 357,
-	ALL_HEALING_DOUBLE = 1058,
-	NUM_OPTIONS_PLAYED_THIS_TURN = 358,
-	TO_BE_DESTROYED = 360,
-	HEALTH_MINIMUM = 337,
-	AURA = 362,
-	POISONOUS = 363,
-	NON_KEYWORD_POISONOUS = 1944,
-	HERO_POWER_DOUBLE = 366,
-	AI_MUST_PLAY = 367,
-	NUM_MINIONS_PLAYER_KILLED_THIS_TURN = 368,
-	NUM_MINIONS_KILLED_THIS_TURN = 369,
-	AFFECTED_BY_SPELL_POWER = 370,
-	SOURCE_OVERRIDE_FOR_MODIFIER_TEXT = 1694,
-	START_WITH_1_HEALTH = 372,
-	IMMUNE_WHILE_ATTACKING = 373,
-	MULTIPLY_HERO_DAMAGE = 374,
-	MULTIPLY_BUFF_VALUE = 375,
-	CUSTOM_KEYWORD_EFFECT = 376,
-	HERO_POWER = 380,
-	HERO_POWER_ENTITY = 1646,
-	DEATHRATTLE_RETURN_ZONE = 382,
-	DISPLAYED_CREATOR = 385,
-	POWERED_UP = 386,
-	SPARE_PART = 388,
-	FORGETFUL = 389,
+    SCORE_LABELID_1 = 450,
+    SCORE_LABELID_2 = 452,
+    SCORE_LABELID_3 = 454,
+    SCORE_VALUE_1 = 451,
+    SCORE_VALUE_2 = 453,
+    SCORE_VALUE_3 = 455,
+    SCORE_FOOTERID = 751,
+    ZOMBEAST_DEBUG_CURRENT_BEAST_DATABASE_ID = 964,
+    ZOMBEAST_DEBUG_CURRENT_ITERATION = 965,
+    ZOMBEAST_DEBUG_MAX_ITERATIONS = 966,
+    DRUSTVAR_HORROR_DEBUG_CURRENT_SPELL_DATABASE_ID = 1280,
+    DRUSTVAR_HORROR_DEBUG_CURRENT_ITERATION = 1281,
+    DRUSTVAR_HORROR_DEBUG_MAX_ITERATIONS = 1283,
+    DEBUG_DISPLAY_TAG_BOTTOM_RIGHT = 1313,
+    DEBUG_DISPLAY_TAG_TOP_RIGHT = 1314,
+    SMART_DISCOVER_DEBUG_ENTITY_1 = 1318,
+    SMART_DISCOVER_DEBUG_ENTITY_2 = 1319,
+    SMART_DISCOVER_DEBUG_ENTITY_3 = 1320,
+    SMART_DISCOVER_DEBUG_TEST_COMPLETE = 1324,
+    SMART_DISCOVER_DEBUG_PASSIVE_EVAL_RESULT_1 = 1328,
+    SMART_DISCOVER_DEBUG_PASSIVE_EVAL_RESULT_2 = 1329,
+    SMART_DISCOVER_DEBUG_PASSIVE_EVAL_RESULT_3 = 1330,
+    CHOICE_NAME_DISPLAY_TYPE = 1687,
+    CHOICE_ACTOR_TYPE = 1692,
+    COMBO = 220,
+    ELITE = 114,
+    CARD_SET = 183,
+    FACTION = 201,
+    RARITY = 203,
+    CLASS = 199,
+    MISSION_EVENT = 6,
+    FREEZE = 208,
+    OVERLOAD = 215,
+    SILENCE = 339,
+    COUNTER = 340,
+    FORCED_PLAY = 352,
+    LOW_HEALTH_THRESHOLD = 353,
+    SPELLPOWER_DOUBLE = 356,
+    SPELL_HEALING_DOUBLE = 357,
+    ALL_HEALING_DOUBLE = 1058,
+    NUM_OPTIONS_PLAYED_THIS_TURN = 358,
+    TO_BE_DESTROYED = 360,
+    HEALTH_MINIMUM = 337,
+    AURA = 362,
+    POISONOUS = 363,
+    NON_KEYWORD_POISONOUS = 1944,
+    HERO_POWER_DOUBLE = 366,
+    AI_MUST_PLAY = 367,
+    NUM_MINIONS_PLAYER_KILLED_THIS_TURN = 368,
+    NUM_MINIONS_KILLED_THIS_TURN = 369,
+    AFFECTED_BY_SPELL_POWER = 370,
+    SOURCE_OVERRIDE_FOR_MODIFIER_TEXT = 1694,
+    START_WITH_1_HEALTH = 372,
+    IMMUNE_WHILE_ATTACKING = 373,
+    MULTIPLY_HERO_DAMAGE = 374,
+    MULTIPLY_BUFF_VALUE = 375,
+    CUSTOM_KEYWORD_EFFECT = 376,
+    HERO_POWER = 380,
+    HERO_POWER_ENTITY = 1646,
+    DEATHRATTLE_RETURN_ZONE = 382,
+    DISPLAYED_CREATOR = 385,
+    POWERED_UP = 386,
+    SPARE_PART = 388,
+    FORGETFUL = 389,
 	FORGETFUL_ATTACK_VISUAL = 3460,
-	CAN_SUMMON_MAXPLUSONE_MINION = 390,
-	BURNING = 392,
-	OVERLOAD_LOCKED = 393,
-	NUM_TIMES_HERO_POWER_USED_THIS_GAME = 394,
-	CURRENT_HEROPOWER_DAMAGE_BONUS = 395,
-	HEROPOWER_DAMAGE = 396,
-	NUM_FRIENDLY_MINIONS_THAT_DIED_THIS_TURN = 398,
-	NUM_CARDS_DRAWN_THIS_TURN = 399,
-	AI_ONE_SHOT_KILL = 400,
-	EVIL_GLOW = 401,
-	HIDE_STATS = 402,
-	IGNORE_HIDE_STATS_FOR_BIG_CARD = 857,
-	INSPIRE = 403,
-	RECEIVES_DOUBLE_SPELLDAMAGE_BONUS = 404,
-	REVEALED = 410,
+    CAN_SUMMON_MAXPLUSONE_MINION = 390,
+    BURNING = 392,
+    OVERLOAD_LOCKED = 393,
+    NUM_TIMES_HERO_POWER_USED_THIS_GAME = 394,
+    CURRENT_HEROPOWER_DAMAGE_BONUS = 395,
+    HEROPOWER_DAMAGE = 396,
+    NUM_FRIENDLY_MINIONS_THAT_DIED_THIS_TURN = 398,
+    NUM_CARDS_DRAWN_THIS_TURN = 399,
+    AI_ONE_SHOT_KILL = 400,
+    EVIL_GLOW = 401,
+    HIDE_STATS = 402,
+    IGNORE_HIDE_STATS_FOR_BIG_CARD = 857,
+    INSPIRE = 403,
+    RECEIVES_DOUBLE_SPELLDAMAGE_BONUS = 404,
+    REVEALED = 410,
 	FORGE_REVEALED = 3070,
-	NUM_FRIENDLY_MINIONS_THAT_DIED_THIS_GAME = 412,
-	LOCK_AND_LOAD = 414,
-	DISCOVER = 415,
-	USE_DISCOVER_VISUALS = 1342,
-	SHADOWFORM = 416,
-	DEATH_KNIGHT = 554,
-	HISTORY_PROXY = 54,
-	DONT_SHOW_IN_HISTORY = 2015,
-	NUM_FRIENDLY_MINIONS_THAT_ATTACKED_THIS_TURN = 417,
-	NUM_RESOURCES_SPENT_THIS_GAME = 418,
-	CHOOSE_BOTH = 419,
-	ELECTRIC_CHARGE_LEVEL = 420,
-	HEAVILY_ARMORED = 421,
-	DONT_SHOW_IMMUNE = 422,
-	HISTORY_PROXY_NO_BIG_CARD = 432,
-	TRANSFORMED_FROM_CARD = 435,
-	PENDING_TRANSFORM_TO_CARD = 1716,
+    NUM_FRIENDLY_MINIONS_THAT_DIED_THIS_GAME = 412,
+    LOCK_AND_LOAD = 414,
+    DISCOVER = 415,
+    USE_DISCOVER_VISUALS = 1342,
+    SHADOWFORM = 416,
+    DEATH_KNIGHT = 554,
+    HISTORY_PROXY = 54,
+    DONT_SHOW_IN_HISTORY = 2015,
+    NUM_FRIENDLY_MINIONS_THAT_ATTACKED_THIS_TURN = 417,
+    NUM_RESOURCES_SPENT_THIS_GAME = 418,
+    CHOOSE_BOTH = 419,
+    ELECTRIC_CHARGE_LEVEL = 420,
+    HEAVILY_ARMORED = 421,
+    DONT_SHOW_IMMUNE = 422,
+    HISTORY_PROXY_NO_BIG_CARD = 432,
+    TRANSFORMED_FROM_CARD = 435,
+    PENDING_TRANSFORM_TO_CARD = 1716,
 	RITUALIST_MINION = 3078,
-	CTHUN = 436,
+    CTHUN = 436,
 	CTHUN_ATTACK_BUFF = 3054,
 	CTHUN_HEALTH_BUFF = 3053,
 	CTHUN_TAUNT_BUFF = 3034,
-	CAST_RANDOM_SPELLS = 437,
-	EMBRACE_THE_SHADOW = 442,
-	CHOOSE_ONE = 443,
+    CAST_RANDOM_SPELLS = 437,
+    EMBRACE_THE_SHADOW = 442,
+    CHOOSE_ONE = 443,
 	AUTO_ATTACK = 457,
-	EXTRA_ATTACKS_THIS_TURN = 444,
-	SEEN_CTHUN = 445,
-	MINION_TYPE_REFERENCE = 447,
-	JADE_GOLEM = 441,
-	ARMS_DEALING = 458,
-	MINION_IN_HAND_BUFF = 845,
-	DEFINING_ENCHANTMENT = 469,
-	MODIFY_DEFINITION_ATTACK = 473,
-	MODIFY_DEFINITION_HEALTH = 474,
-	MODIFY_DEFINITION_COST = 475,
-	MULTIPLE_CLASSES = 476,
-	MULTI_CLASS_GROUP = 480,
-	ALL_TARGETS_RANDOM = 477,
-	CARD_COSTS_HEALTH = 481,
-	CARD_COSTS_ARMOR = 2811,
-	GRIMY_GOONS = 482,
-	JADE_LOTUS = 483,
-	KABAL = 484,
-	ADDITIONAL_PLAY_REQS_1 = 515,
-	ADDITIONAL_PLAY_REQS_2 = 516,
-	ELEMENTAL_POWERED_UP = 532,
-	BOSS = 556,
-	STAMPEDE = 564,
-	CORRUPTED = 681,
-	HIDE_HEALTH = 682,
+    EXTRA_ATTACKS_THIS_TURN = 444,
+    SEEN_CTHUN = 445,
+    MINION_TYPE_REFERENCE = 447,
+    JADE_GOLEM = 441,
+    ARMS_DEALING = 458,
+    MINION_IN_HAND_BUFF = 845,
+    DEFINING_ENCHANTMENT = 469,
+    MODIFY_DEFINITION_ATTACK = 473,
+    MODIFY_DEFINITION_HEALTH = 474,
+    MODIFY_DEFINITION_COST = 475,
+    MULTIPLE_CLASSES = 476,
+    MULTI_CLASS_GROUP = 480,
+    ALL_TARGETS_RANDOM = 477,
+    CARD_COSTS_HEALTH = 481,
+    CARD_COSTS_ARMOR = 2811,
+    GRIMY_GOONS = 482,
+    JADE_LOTUS = 483,
+    KABAL = 484,
+    ADDITIONAL_PLAY_REQS_1 = 515,
+    ADDITIONAL_PLAY_REQS_2 = 516,
+    ELEMENTAL_POWERED_UP = 532,
+    BOSS = 556,
+    STAMPEDE = 564,
+    CORRUPTED = 681,
+    HIDE_HEALTH = 682,
 	HIDE_HEALTH_NUMBER = 3471,
-	HIDE_ATTACK = 683,
+    HIDE_ATTACK = 683,
 	HIDE_ATTACK_NUMBER = 3472,
-	HIDE_COST = 684,
-	LIFESTEAL = 685,
-	GHOSTLY = 785,
-	DISGUISED_TWIN = 788,
-	SECRET_DEATHRATTLE = 789,
-	ZOMBEAST = 823,
-	HERO_EMOTE_SILENCED = 832,
-	MODULAR = 849,
-	GLORIOUSGLOOP = 1044,
-	REBORN = 1085,
-	HAS_BEEN_REBORN = 1336,
-	POISONOUS_INSTANT = 1528,
-	REPLACEMENT_ENTITY = 1632,
-	SPELLS_CAST_TWICE = 1681,
+    HIDE_COST = 684,
+    LIFESTEAL = 685,
+    GHOSTLY = 785,
+    DISGUISED_TWIN = 788,
+    SECRET_DEATHRATTLE = 789,
+    ZOMBEAST = 823,
+    HERO_EMOTE_SILENCED = 832,
+    MODULAR = 849,
+    GLORIOUSGLOOP = 1044,
+    REBORN = 1085,
+    HAS_BEEN_REBORN = 1336,
+    POISONOUS_INSTANT = 1528,
+    REPLACEMENT_ENTITY = 1632,
+    SPELLS_CAST_TWICE = 1681,
 	DONT_PICK_FROM_SUBSETS = 676,
-	LUNAHIGHLIGHTHINT = 1054,
-	EMPOWER = 1263,
-	EMPOWER_PRIEST = 1264,
-	EMPOWER_ROGUE = 1265,
-	EMPOWER_SHAMAN = 1266,
-	EMPOWER_WARLOCK = 1267,
-	EMPOWER_WARRIOR = 1268,
-	GOLDSPARKLES_HINT = 1984,
+    LUNAHIGHLIGHTHINT = 1054,
+    EMPOWER = 1263,
+    EMPOWER_PRIEST = 1264,
+    EMPOWER_ROGUE = 1265,
+    EMPOWER_SHAMAN = 1266,
+    EMPOWER_WARLOCK = 1267,
+    EMPOWER_WARRIOR = 1268,
+    GOLDSPARKLES_HINT = 1984,
 	CASTS_WHEN_DRAWN = 1077,
-	DORMANT_VISUAL = 1090,
-	DORMANT = 1518,
-	DORMANT_AWAKEN_CONDITION_ENCHANT = 1519,
-	SHRINE = 1057,
+    DORMANT_VISUAL = 1090,
+    DORMANT = 1518,
+    DORMANT_AWAKEN_CONDITION_ENCHANT = 1519,
+    SHRINE = 1057,
 	FATIGUE_REFERENCE = 1290,
-	WAND = 1015,
-	TWINSPELL = 1193,
-	TWINSPELL_COPY = 1186,
-	TWINSPELLPENDING = 1269,
+    WAND = 1015,
+    TWINSPELL = 1193,
+    TWINSPELL_COPY = 1186,
+    TWINSPELLPENDING = 1269,
 	CREATED_BY_TWINSPELL = 3432,
 	CREATED_BY_MINIATURIZE = 3433,
-	EVILZUG = 994,
-	OVERRIDE_EMOTE_0 = 740,
-	OVERRIDE_EMOTE_1 = 741,
-	OVERRIDE_EMOTE_2 = 742,
-	OVERRIDE_EMOTE_3 = 743,
-	OVERRIDE_EMOTE_4 = 744,
-	OVERRIDE_EMOTE_5 = 745,
-	HERO_POWER_DISABLED = 777,
-	RUSH = 791,
-	ATTACKABLE_BY_RUSH = 930,
-	ECHO = 846,
-	NON_KEYWORD_ECHO = 1114,
-	OVERKILL = 923,
-	PROPHECY = 924,
-	ETHEREAL = 880,
-	REVEAL_CHOICES = 792,
-	HIDDEN_CHOICE = 813,
-	REAL_TIME_TRANSFORM = 859,
-	HEALTH_DISPLAY = 917,
-	ENABLE_HEALTH_DISPLAY = 920,
-	HEALTH_DISPLAY_COLOR = 1046,
-	HEALTH_DISPLAY_NEGATIVE = 1047,
-	VOODOO_LINK = 921,
+    EVILZUG = 994,
+    OVERRIDE_EMOTE_0 = 740,
+    OVERRIDE_EMOTE_1 = 741,
+    OVERRIDE_EMOTE_2 = 742,
+    OVERRIDE_EMOTE_3 = 743,
+    OVERRIDE_EMOTE_4 = 744,
+    OVERRIDE_EMOTE_5 = 745,
+    HERO_POWER_DISABLED = 777,
+    RUSH = 791,
+    ATTACKABLE_BY_RUSH = 930,
+    ECHO = 846,
+    NON_KEYWORD_ECHO = 1114,
+    OVERKILL = 923,
+    PROPHECY = 924,
+    ETHEREAL = 880,
+    REVEAL_CHOICES = 792,
+    HIDDEN_CHOICE = 813,
+    REAL_TIME_TRANSFORM = 859,
+    HEALTH_DISPLAY = 917,
+    ENABLE_HEALTH_DISPLAY = 920,
+    HEALTH_DISPLAY_COLOR = 1046,
+    HEALTH_DISPLAY_NEGATIVE = 1047,
+    VOODOO_LINK = 921,
 	FAN_LINK = 3052,
-	COLLECTIONMANAGER_FILTER_MANA_EVEN = 956,
-	COLLECTIONMANAGER_FILTER_MANA_ODD = 957,
-	SUPPRESS_DEATH_SOUND = 959,
-	ECHOING_OOZE_SPELL = 963,
-	ENCHANTMENT_INVISIBLE = 976,
-	WILD = 991,
-	HALL_OF_FAME = 992,
-	FAST_BATTLECRY = 998,
-	CARD_DOES_NOTHING = 1075,
-	FORCE_NO_CUSTOM_SPELLS = 1529,
-	FORCE_NO_CUSTOM_SUMMON_SPELLS = 1614,
-	FORCE_NO_CUSTOM_LIFETIME_SPELLS = 1613,
-	FORCE_NO_CUSTOM_KEYWORD_SPELLS = 1615,
-	FORCE_GREEN_GLOW_ACTIVE = 1693,
-	START_OF_COMBAT = 1531,
-	PUZZLE = 979,
-	PUZZLE_PROGRESS = 980,
-	PUZZLE_PROGRESS_TOTAL = 981,
-	PUZZLE_TYPE = 982,
-	PUZZLE_COMPLETED = 984,
-	PUZZLE_NAME = 1026,
-	PREVIOUS_PUZZLE_COMPLETED = 1042,
-	PUZZLE_MODE = 1073,
-	CONCEDE_BUTTON_ALTERNATIVE_TEXT = 985,
-	HIDE_RESTART_BUTTON = 990,
-	END_TURN_BUTTON_ALTERNATIVE_APPEARANCE = 1000,
-	TURN_INDICATOR_ALTERNATIVE_APPEARANCE = 1027,
-	DISABLE_TURN_INDICATORS = 1448,
-	DECK_RULE_MOD_DECK_SIZE = 997,
-	DECK_RULE_COUNT_AS_COPY_OF_CARD_ID = 1413,
-	IGNORE_DECK_RULESET = 1896,
-	HIDE_OUT_OF_CARDS_WARNING = 1050,
-	SUPPRESS_JOBS_DONE_VO = 1055,
-	BLOCK_ALL_INPUT = 1071,
-	SUPPRESS_ALL_SUMMON_VO = 1458,
-	SUPPRESS_SUMMON_VO_FOR_PLAYER = 1521,
+    COLLECTIONMANAGER_FILTER_MANA_EVEN = 956,
+    COLLECTIONMANAGER_FILTER_MANA_ODD = 957,
+    SUPPRESS_DEATH_SOUND = 959,
+    ECHOING_OOZE_SPELL = 963,
+    ENCHANTMENT_INVISIBLE = 976,
+    WILD = 991,
+    HALL_OF_FAME = 992,
+    FAST_BATTLECRY = 998,
+    CARD_DOES_NOTHING = 1075,
+    FORCE_NO_CUSTOM_SPELLS = 1529,
+    FORCE_NO_CUSTOM_SUMMON_SPELLS = 1614,
+    FORCE_NO_CUSTOM_LIFETIME_SPELLS = 1613,
+    FORCE_NO_CUSTOM_KEYWORD_SPELLS = 1615,
+    FORCE_GREEN_GLOW_ACTIVE = 1693,
+    START_OF_COMBAT = 1531,
+    PUZZLE = 979,
+    PUZZLE_PROGRESS = 980,
+    PUZZLE_PROGRESS_TOTAL = 981,
+    PUZZLE_TYPE = 982,
+    PUZZLE_COMPLETED = 984,
+    PUZZLE_NAME = 1026,
+    PREVIOUS_PUZZLE_COMPLETED = 1042,
+    PUZZLE_MODE = 1073,
+    CONCEDE_BUTTON_ALTERNATIVE_TEXT = 985,
+    HIDE_RESTART_BUTTON = 990,
+    END_TURN_BUTTON_ALTERNATIVE_APPEARANCE = 1000,
+    TURN_INDICATOR_ALTERNATIVE_APPEARANCE = 1027,
+    DISABLE_TURN_INDICATORS = 1448,
+    DECK_RULE_MOD_DECK_SIZE = 997,
+    DECK_RULE_COUNT_AS_COPY_OF_CARD_ID = 1413,
+    IGNORE_DECK_RULESET = 1896,
+    HIDE_OUT_OF_CARDS_WARNING = 1050,
+    SUPPRESS_JOBS_DONE_VO = 1055,
+    BLOCK_ALL_INPUT = 1071,
+    SUPPRESS_ALL_SUMMON_VO = 1458,
+    SUPPRESS_SUMMON_VO_FOR_PLAYER = 1521,
 	SUPPRES_ALL_SOUNDS_FOR_ENTITY = 3093,
-	DONT_SUPPRESS_SUMMON_VO = 2440,
-	DONT_SUPPRESS_KEYWORD_VO = 2636,
-	PLAYER_BASE_SHRINE_DECK_ID = 1099,
-	DISPLAY_CARD_ON_MOUSEOVER = 1078,
-	DECK_POWER_UP = 1080,
-	SIDEKICK = 1081,
-	SIDEKICK_HERO_POWER = 1082,
-	RUN_PROGRESS = 1113,
-	ALTERNATE_MOUSE_OVER_CARD = 1132,
-	ENCHANTMENT_BANNER_TEXT = 1135,
-	MOUSE_OVER_CARD_APPEARANCE = 1142,
-	IS_ADVENTURE_SCENARIO = 1172,
-	COIN_MANA_GEM = 1199,
-	COIN_MANA_GEM_FOR_CHOICE_CARDS = 1643,
-	TECH_LEVEL_MANA_GEM = 1442,
-	BACON_COIN_ON_ENEMY_MINIONS = 1467,
-	ALWAYS_USE_FAST_ACTOR_TRIGGERS = 1473,
-	HEROIC_HERO_POWER = 1282,
-	UI_BUFF_ATK_UP = 1297,
-	UI_BUFF_COST_DOWN = 1296,
-	UI_BUFF_COST_UP = 1298,
-	UI_BUFF_HEALTH_UP = 1294,
-	UI_BUFF_SET_COST_ZERO = 1295,
-	UI_BUFF_DURABILITY_UP = 1443,
-	GALAKROND_IN_PLAY = 1194,
-	OUTCAST = 1333,
-	STUDY = 1414,
-	SPELLBURST = 1427,
-	NON_KEYWORD_SPELLBURST = 2672,
-	CORRUPT = 1524,
+    DONT_SUPPRESS_SUMMON_VO = 2440,
+    DONT_SUPPRESS_KEYWORD_VO = 2636,
+    PLAYER_BASE_SHRINE_DECK_ID = 1099,
+    DISPLAY_CARD_ON_MOUSEOVER = 1078,
+    DECK_POWER_UP = 1080,
+    SIDEKICK = 1081,
+    SIDEKICK_HERO_POWER = 1082,
+    RUN_PROGRESS = 1113,
+    ALTERNATE_MOUSE_OVER_CARD = 1132,
+    ENCHANTMENT_BANNER_TEXT = 1135,
+    MOUSE_OVER_CARD_APPEARANCE = 1142,
+    IS_ADVENTURE_SCENARIO = 1172,
+    COIN_MANA_GEM = 1199,
+    COIN_MANA_GEM_FOR_CHOICE_CARDS = 1643,
+    TECH_LEVEL_MANA_GEM = 1442,
+    BACON_COIN_ON_ENEMY_MINIONS = 1467,
+    ALWAYS_USE_FAST_ACTOR_TRIGGERS = 1473,
+    HEROIC_HERO_POWER = 1282,
+    UI_BUFF_ATK_UP = 1297,
+    UI_BUFF_COST_DOWN = 1296,
+    UI_BUFF_COST_UP = 1298,
+    UI_BUFF_HEALTH_UP = 1294,
+    UI_BUFF_SET_COST_ZERO = 1295,
+    UI_BUFF_DURABILITY_UP = 1443,
+    GALAKROND_IN_PLAY = 1194,
+    OUTCAST = 1333,
+    STUDY = 1414,
+    SPELLBURST = 1427,
+    NON_KEYWORD_SPELLBURST = 2672,
+    CORRUPT = 1524,
 	CORRUPTED_CARD = 1551,
-	FRENZY = 1637,
-	TRADEABLE = 1720,
+    FRENZY = 1637,
+    TRADEABLE = 1720,
 	FORGE = 2785,
 	FORGED = 3011,
 	FORGES_INTO = 3074,
 	BACON_DUO_PASSABLE = 3178,
 	DECK_ACTION_COST = 1743,
-	IS_USING_TRADE_OPTION = 2045,
+    IS_USING_TRADE_OPTION = 2045,
 	IS_USING_FORGE_OPTION = 2869,
 	IS_USING_PASS_OPTION = 3185,
-	TOOL = 1722,
-	QUESTLINE = 1725,
+    TOOL = 1722,
+    QUESTLINE = 1725,
 	HONORABLE_KILL = 1920,
-	COLOSSAL = 2247,
-	COLOSSAL_LIMB = 2248,
-	COLOSSAL_LIMB_ON_LEFT = 2469,
-	DREDGE = 2332,
-	INFUSE = 2456,
-	INFUSED = 2457,
-	CORPSE = 2559,
-	MANATHIRST = 2498,
-	MAGNETIC_TO_RACE = 2859,
+    COLOSSAL = 2247,
+    COLOSSAL_LIMB = 2248,
+    COLOSSAL_LIMB_ON_LEFT = 2469,
+    DREDGE = 2332,
+    INFUSE = 2456,
+    INFUSED = 2457,
+    CORPSE = 2559,
+    MANATHIRST = 2498,
+    MAGNETIC_TO_RACE = 2859,
 	MAX_SIDEBOARD_CARDS = 2931,
 	MIN_SIDEBOARD_CARDS = 3459,
 	FINALE = 2820,
 	OVERHEAL = 2821,
 	BONUS_EFFECTS = 2934,
 	SIDEBOARD_TYPE = 3427,
-	RED_MANA_GEM = 449,
-	BACON_IS_KEL_THUZAD = 1423,
+    RED_MANA_GEM = 449,
+    BACON_IS_KEL_THUZAD = 1423,
 	BACON_TRIPLE_UPGRADE_MINION_ID = 1429,
-	BACON_TRIPLE_CANDIDATE = 1460,
+    BACON_TRIPLE_CANDIDATE = 1460,
 	BACON_TRIPLED_BASE_MINION_ID = 1471,
 	BACON_TRIPLED_BASE_MINION_ID2 = 3499,
 	BACON_TRIPLED_BASE_MINION_ID3 = 3500,
 	BACON_PAIR_CANDIDATE = 3031,
 	BACON_DUO_TRIPLE_CANDIDATE_TEAMMATE = 3145,
 	BACON_DUO_PAIR_CANDIDATE_TEAMMATE = 3146,
-	BATTLEGROUNDS_PREMIUM_EMOTES = 1463,
-	PLAYER_ID_LOOKUP = 1740,
+    BATTLEGROUNDS_PREMIUM_EMOTES = 1463,
+    PLAYER_ID_LOOKUP = 1740,
 	BACON_BLOOD_GEM_TOOLTIP = 1966,
 	BACON_REFRESH_TOOLTIP = 2104,
-	AVENGE = 2129,
+    AVENGE = 2129,
 	BACON_SPELLCRAFT_ID = 2359,
 	VENOMOUS = 2853,
-	BACON_HERO_EARLY_ACCESS = 1554,
-	BACON_STARSTOBOUNCEOFF = 2155,
-	BACON_CHOSEN_BOARD_SKIN_ID = 2264,
-	BACON_COMPANION_ID = 2130,
-	BACON_BUDDY = 2154,
-	BATTLEGROUNDS_FAVORITE_FINISHER = 2348,
-	BACON_OMIT_WHEN_OUT_OF_ROTATION = 2387,
-	BACON_FREEZE_TOOLTIP = 2455,
-	BACON_STEALTH_TOOLTIP = 2704,
-	BACON_QUEST_TOOLTIP = 2705,
-	BACON_REBORN_TOOLTIP = 2870,
+    BACON_HERO_EARLY_ACCESS = 1554,
+    BACON_STARSTOBOUNCEOFF = 2155,
+    BACON_CHOSEN_BOARD_SKIN_ID = 2264,
+    BACON_COMPANION_ID = 2130,
+    BACON_BUDDY = 2154,
+    BATTLEGROUNDS_FAVORITE_FINISHER = 2348,
+    BACON_OMIT_WHEN_OUT_OF_ROTATION = 2387,
+    BACON_FREEZE_TOOLTIP = 2455,
+    BACON_STEALTH_TOOLTIP = 2704,
+    BACON_QUEST_TOOLTIP = 2705,
+    BACON_REBORN_TOOLTIP = 2870,
 	BACON_PUTRICIDES_CREATION_TOOLTIP = 2875,
-	BACON_MINION_TYPE_REWARD = 2571,
-	BACON_CARD_DBID_REWARD = 2673,
-	BACON_IS_HEROPOWER_QUESTREWARD = 2706,
-	BACON_HERO_QUEST_REWARD_DATABASE_ID = 2713,
-	BACON_HERO_HEROPOWER_QUEST_REWARD_DATABASE_ID = 2714,
-	BACON_HERO_QUEST_REWARD_COMPLETED = 2715,
-	BACON_HERO_HEROPOWER_QUEST_REWARD_COMPLETED = 2716,
-	BACON_DOUBLE_QUEST_HERO_POWER = 2803,
-	BACON_IS_BOB_QUEST = 2732,
-	BACON_HERO_REWARD_CARD_DBID = 2748,
-	BACON_HERO_HEROPOWER_REWARD_CARD_DBID = 2749,
-	BACON_HERO_REWARD_MINION_TYPE = 2750,
-	BACON_HERO_HEROPOWER_REWARD_MINION_TYPE = 2751,
-	BACON_DIED_LAST_COMBAT = 2483,
+    BACON_MINION_TYPE_REWARD = 2571,
+    BACON_CARD_DBID_REWARD = 2673,
+    BACON_IS_HEROPOWER_QUESTREWARD = 2706,
+    BACON_HERO_QUEST_REWARD_DATABASE_ID = 2713,
+    BACON_HERO_HEROPOWER_QUEST_REWARD_DATABASE_ID = 2714,
+    BACON_HERO_QUEST_REWARD_COMPLETED = 2715,
+    BACON_HERO_HEROPOWER_QUEST_REWARD_COMPLETED = 2716,
+    BACON_DOUBLE_QUEST_HERO_POWER = 2803,
+    BACON_IS_BOB_QUEST = 2732,
+    BACON_HERO_REWARD_CARD_DBID = 2748,
+    BACON_HERO_HEROPOWER_REWARD_CARD_DBID = 2749,
+    BACON_HERO_REWARD_MINION_TYPE = 2750,
+    BACON_HERO_HEROPOWER_REWARD_MINION_TYPE = 2751,
+    BACON_DIED_LAST_COMBAT = 2483,
 	BACON_GLOBAL_ANOMALY_DBID = 2897,
-	HAS_DRAG_TO_BUY = 2458,
-	TRANSIENT_ENTITY = 1493,
+    HAS_DRAG_TO_BUY = 2458,
+    TRANSIENT_ENTITY = 1493,
 	BACON_TRIGGER_UPBEAT = 3046,
 	BACON_TRIGGER_XY = 3047,
 	BACON_SELL_VALUE = 1587,
 	BACON_CURRENT_COMBAT_PLAYER_ID = 2989,
 	BACON_CONSUME_TOOLTIP = 3254,
-	FX_DATANUM_1 = 1436,
+    FX_DATANUM_1 = 1436,
 	FX_DATANUM_2 = 3077,
 	FX_DATANUM_3 = 3109,
-	BACON_VERDANTSPHERES = 1598,
-	METAMORPHOSIS = 1644,
-	BACON_AVALANCHE = 1744,
-	BACON_COMEONECOMEALL = 1789,
-	BACON_DIED_LAST_COMBAT_HINT = 2780,
-	ROOTED = 2179,
-	VULNERABLE = 2180,
-	IMMOLATING = 2505,
-	SPELLCRAFT_HINT = 2557,
-	COPIED_HINT = 2572,
-	BLEEDING = 2575,
-	IMMOLATESTAGE = 2600,
-	SINFUL_BRAND = 2613,
-	HAUNTED_SECRET = 2634,
-	SECRET_LOCKED = 2676,
+    BACON_VERDANTSPHERES = 1598,
+    METAMORPHOSIS = 1644,
+    BACON_AVALANCHE = 1744,
+    BACON_COMEONECOMEALL = 1789,
+    BACON_DIED_LAST_COMBAT_HINT = 2780,
+    ROOTED = 2179,
+    VULNERABLE = 2180,
+    IMMOLATING = 2505,
+    SPELLCRAFT_HINT = 2557,
+    COPIED_HINT = 2572,
+    BLEEDING = 2575,
+    IMMOLATESTAGE = 2600,
+    SINFUL_BRAND = 2613,
+    HAUNTED_SECRET = 2634,
+    SECRET_LOCKED = 2676,
 	LITERALLY_UNPLAYABLE = 1020,
-	UNPLAYABLE_VISUALS = 2798,
-	DEATH_SPELL_OVERRIDE = 2722,
+    UNPLAYABLE_VISUALS = 2798,
+    DEATH_SPELL_OVERRIDE = 2722,
 	EXTRA_TURNS_SPELL_OVERRIDE = 3465,
 	BUILDING_UP = 3016,
 	TUTORIAL_TARGET_OPPONENT_ANIM = 3192,
@@ -822,52 +822,52 @@ public enum GAME_TAG
 	ALONE_RANGER = 3258,
 	SUPPRESS_HERO_STANDARD_SUMMON_FX = 3438,
 	SHUDDERWOCKHIGHLIGHTHINT = 3463,
-	FAKE_ZONE = 1702,
-	FAKE_ZONE_POSITION = 1703,
-	FAKE_CONTROLLER = 2032,
+    FAKE_ZONE = 1702,
+    FAKE_ZONE_POSITION = 1703,
+    FAKE_CONTROLLER = 2032,
 	CUTSCENE_CARD_TYPE = 3265,
-	LETTUCE_CONTROLLER = 1653,
-	LETTUCE_MERCENARY = 1665,
-	LETTUCE_ABILITY_OWNER = 1654,
-	LETTUCE_SELECTED_TARGET = 1657,
-	LETTUCE_SELECTED_SUBCARD_INDEX = 1661,
-	LETTUCE_ROLE = 1666,
-	LETTUCE_IS_COMBAT_ACTION_TAKEN = 1668,
-	LETTUCE_COOLDOWN_CONFIG = 1669,
-	LETTUCE_CURRENT_COOLDOWN = 1670,
-	LETTUCE_ABILITY_SUMMONED_MINION = 1676,
-	LETTUCE_ABILITY_TILE_VISUAL_SELF_ONLY = 1697,
-	LETTUCE_ABILITY_TILE_VISUAL_ALL_VISIBLE = 1698,
-	LETTUCE_MAX_IN_PLAY_MERCENARIES = 1704,
-	LETTUCE_MERCENARIES_TO_NOMINATE = 1705,
-	LETTUCE_COOLDOWN_WHILE_BENCHED = 1708,
-	LETTUCE_MERCENARY_RESERVE = 1731,
-	LETTUCE_SKIP_MERCENARY_RESERVE = 1732,
-	LETTUCE_DISABLE_AUTO_SELECT_NEXT_MERC = 1753,
-	LETTUCE_ABILITY_USED_LAST_TURN = 1807,
-	LETTUCE_MERCENARY_EXPERIENCE = 1852,
-	LETTUCE_IS_EQUPIMENT = 1855,
-	LETTUCE_EQUIPMENT_ID = 1856,
-	LETTUCE_SELECTED_ABILITY_QUEUE_ORDER = 1991,
-	LETTUCE_HAS_MANUALLY_SELECTED_ABILITY = 1967,
-	LETTUCE_KEEP_LAST_STANDING_MINION_ACTOR = 1976,
-	LETTUCE_USE_DETERMINISTIC_TEAM_ABILITY_QUEUING = 1990,
-	LETTUCE_NODE_TYPE = 1808,
-	LETTUCE_PASSIVE_ABILITY = 1671,
-	LETTUCE_BOUNTY_BOSS = 2168,
-	LETTUCE_IS_TREASURE_CARD = 2170,
-	LETTUCE_CURRENT_BOUNTY_ID = 2120,
-	LETTUCE_SHOW_OPPOSING_FAKE_HAND = 2224,
-	LETTUCE_VERSUS_SPELL_STATE = 2228,
-	LETTUCE_START_OF_GAME_ABILITY = 2241,
-	LETTUCE_CURSED_ABILITY_VISUAL = 2381,
-	LETTUCE_OVERTIME = 2123,
-	LETTUCE_ABILITY_TILE_VISUAL_PUBLIC_SPEED = 2470,
-	LETTUCE_FACTION = 2720,
-	LETTUCE_COMBAT_FROM_HIGH_TO_LOW = 1712,
-	LETTUCE_ABILITY_TIER = 2493,
-	LETTUCE_EQUIPMENT_TIER = 2494,
-	MERCENARIES_DISCOVER_SOURCE = 2752,
+    LETTUCE_CONTROLLER = 1653,
+    LETTUCE_MERCENARY = 1665,
+    LETTUCE_ABILITY_OWNER = 1654,
+    LETTUCE_SELECTED_TARGET = 1657,
+    LETTUCE_SELECTED_SUBCARD_INDEX = 1661,
+    LETTUCE_ROLE = 1666,
+    LETTUCE_IS_COMBAT_ACTION_TAKEN = 1668,
+    LETTUCE_COOLDOWN_CONFIG = 1669,
+    LETTUCE_CURRENT_COOLDOWN = 1670,
+    LETTUCE_ABILITY_SUMMONED_MINION = 1676,
+    LETTUCE_ABILITY_TILE_VISUAL_SELF_ONLY = 1697,
+    LETTUCE_ABILITY_TILE_VISUAL_ALL_VISIBLE = 1698,
+    LETTUCE_MAX_IN_PLAY_MERCENARIES = 1704,
+    LETTUCE_MERCENARIES_TO_NOMINATE = 1705,
+    LETTUCE_COOLDOWN_WHILE_BENCHED = 1708,
+    LETTUCE_MERCENARY_RESERVE = 1731,
+    LETTUCE_SKIP_MERCENARY_RESERVE = 1732,
+    LETTUCE_DISABLE_AUTO_SELECT_NEXT_MERC = 1753,
+    LETTUCE_ABILITY_USED_LAST_TURN = 1807,
+    LETTUCE_MERCENARY_EXPERIENCE = 1852,
+    LETTUCE_IS_EQUPIMENT = 1855,
+    LETTUCE_EQUIPMENT_ID = 1856,
+    LETTUCE_SELECTED_ABILITY_QUEUE_ORDER = 1991,
+    LETTUCE_HAS_MANUALLY_SELECTED_ABILITY = 1967,
+    LETTUCE_KEEP_LAST_STANDING_MINION_ACTOR = 1976,
+    LETTUCE_USE_DETERMINISTIC_TEAM_ABILITY_QUEUING = 1990,
+    LETTUCE_NODE_TYPE = 1808,
+    LETTUCE_PASSIVE_ABILITY = 1671,
+    LETTUCE_BOUNTY_BOSS = 2168,
+    LETTUCE_IS_TREASURE_CARD = 2170,
+    LETTUCE_CURRENT_BOUNTY_ID = 2120,
+    LETTUCE_SHOW_OPPOSING_FAKE_HAND = 2224,
+    LETTUCE_VERSUS_SPELL_STATE = 2228,
+    LETTUCE_START_OF_GAME_ABILITY = 2241,
+    LETTUCE_CURSED_ABILITY_VISUAL = 2381,
+    LETTUCE_OVERTIME = 2123,
+    LETTUCE_ABILITY_TILE_VISUAL_PUBLIC_SPEED = 2470,
+    LETTUCE_FACTION = 2720,
+    LETTUCE_COMBAT_FROM_HIGH_TO_LOW = 1712,
+    LETTUCE_ABILITY_TIER = 2493,
+    LETTUCE_EQUIPMENT_TIER = 2494,
+    MERCENARIES_DISCOVER_SOURCE = 2752,
 	SUMMONED_WHEN_DRAWN = 3128,
 	QUICKDRAW = 2905,
 	EXCAVATE = 3114,
@@ -878,5 +878,6 @@ public enum GAME_TAG
 	ZILLIAX_CUSTOMIZABLE_FUNCTIONALMODULE = 3377,
 	ZILLIAX_CUSTOMIZABLE_LINKED_COSMETICMOUDLE = 3450,
 	ZILLIAX_CUSTOMIZABLE_LINKED_FUNCTIONALMOUDLE = 3470,
-	ZILLIAX_CUSTOMIZABLE_SAVED_VERSION = 3477
+	ZILLIAX_CUSTOMIZABLE_SAVED_VERSION = 3477,
+    EOE
 }
diff --git a/Assembly-CSharp/Game/PackOpening/HiddenCards.cs b/Assembly-CSharp/Game/PackOpening/HiddenCards.cs
index c20db67..f4c443c 100644
--- a/Assembly-CSharp/Game/PackOpening/HiddenCards.cs
+++ b/Assembly-CSharp/Game/PackOpening/HiddenCards.cs
@@ -11,7 +11,7 @@ namespace Game.PackOpening
 {
 	public class HiddenCards
 	{
-		protected List<PackOpeningCard> m_cards = new List<PackOpeningCard>();
+		internal List<PackOpeningCard> m_cards = new List<PackOpeningCard>();
 
 		public int Count => m_cards.Count;
 
diff --git a/Assembly-CSharp/GameEntity.cs b/Assembly-CSharp/GameEntity.cs
index 5a53c18..c9b7223 100644
--- a/Assembly-CSharp/GameEntity.cs
+++ b/Assembly-CSharp/GameEntity.cs
@@ -1704,4 +1704,22 @@ public class GameEntity : Entity
 	public virtual void UpdateNameDisplay()
 	{
 	}
+
+    #region Turn Counter missions
+
+    public virtual bool IsTurnCounterBasedMission()
+    {
+		return false;
+    }
+
+	#endregion
+
+	#region Accessibility
+
+	internal int GetAnomalyId()
+	{
+		return GetTag(GAME_TAG.BACON_GLOBAL_ANOMALY_DBID);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/GameMenu.cs b/Assembly-CSharp/GameMenu.cs
index 3155b87..3434e46 100644
--- a/Assembly-CSharp/GameMenu.cs
+++ b/Assembly-CSharp/GameMenu.cs
@@ -4,9 +4,11 @@ using Hearthstone;
 using Hearthstone.Progression;
 using Hearthstone.Streaming;
 using UnityEngine;
+using Accessibility;
+using System;
 
 [CustomEditClass]
-public class GameMenu : ButtonListMenu, GameMenuInterface
+public class GameMenu : ButtonListMenu, GameMenuInterface, AccessibleUI
 {
 	private enum CONCEDE_WARNING
 	{
@@ -109,14 +111,18 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 			m_switchAccountButton = CreateMenuButton("LogoutButton", Network.ShouldBeConnectedToAurora() ? "GLOBAL_SWITCH_ACCOUNT" : "GLOBAL_LOGIN", LogoutButtonPressed);
 			m_loginButton = CreateMenuButton("LoginButton", "GLOBAL_LOGIN", LoginButtonPressed);
 		}
+		if (m_menu.m_templateSignUpButton != null)
+		{
+			m_signUpButton = CreateMenuButton("SignUpButton", "GLUE_TEMPORARY_ACCOUNT_SIGN_UP", OnSignUpPressed, m_menu.m_templateSignUpButton);
+		}
 		m_optionsButton = CreateMenuButton("OptionsButton", "GLOBAL_OPTIONS", OptionsButtonPressed);
 		if (m_menu.m_templateDownloadButton != null)
 		{
 			m_downloadManagerButton = CreateMenuButton("DownloadManagerButton", "GLOBAL_GAME_MENU_BUTTON_DOWNLOAD_MANAGER", DownloadManagerPressed, m_menu.m_templateDownloadButton);
 		}
-		if (m_menu.m_templateSignUpButton != null)
+		if ((bool)HearthstoneApplication.CanQuitGame)
 		{
-			m_signUpButton = CreateMenuButton("SignUpButton", "GLUE_TEMPORARY_ACCOUNT_SIGN_UP", OnSignUpPressed, m_menu.m_templateSignUpButton);
+			m_quitButton = CreateMenuButton("QuitButton", "GLOBAL_QUIT", QuitButtonPressed);
 		}
 		m_menu.m_headerText.Text = GameStrings.Get("GLOBAL_GAME_MENU");
 		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
@@ -205,6 +211,8 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		ShowCursorIfNeeded();
 		ShowLoginTooltipIfNeeded();
 		BnetBar.Get().m_menuButton.SetSelected(enable: true);
+
+		ReadMenu();
 	}
 
 	public override void Hide()
@@ -212,6 +220,12 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		base.Hide();
 		HideLoginTooltip();
 		BnetBar.Get().m_menuButton.SetSelected(enable: false);
+
+		if (!m_gameMenuBase.TransitioningToOptionsMenu)
+		{
+			// Don't hide when transitioning as we would just regain + lose focus on the main menu screen instantly (causing us to start reading it)
+			AccessibilityMgr.HideUI(this);
+		}
 	}
 
 	public void ShowCursorIfNeeded()
@@ -351,18 +365,18 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		}
 		bool num = DemoMgr.Get().IsExpoDemo();
 		if (!num && !flag3 && CanLogInOrCreateAccount() && (PlatformSettings.IsMobile() || PlatformSettings.IsSteam))
-		{
-			if ((bool)HearthstoneApplication.CanQuitGame)
-			{
-				list.Add(m_switchAccountButton);
-			}
-			else if (!flag)
-			{
-				list.Add(m_switchAccountButton);
-			}
-		}
+				{
+					if ((bool)HearthstoneApplication.CanQuitGame)
+					{
+						list.Add(m_switchAccountButton);
+					}
+					else if (!flag)
+					{
+						list.Add(m_switchAccountButton);
+					}
+				}
 		if (!num && !(flag3 && flag4))
-		{
+				{
 			list.Add(m_optionsButton);
 		}
 		if (m_downloadManagerButton != null && PlatformSettings.IsMobile() && DownloadManager != null && DownloadManager.IsReadyToPlay && !(flag3 && flag4))
@@ -375,8 +389,8 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 			{
 				list.Add(null);
 			}
-			list.Add(m_quitButton);
-		}
+					list.Add(m_quitButton);
+				}
 		return list;
 	}
 
@@ -458,7 +472,7 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 			if (friendlySidePlayer.HasTag(GAME_TAG.DUOS_QUEUED_NOT_ON_TEAM) && !flag && tB_BaconShopDuos.HasTag(GAME_TAG.BACON_DUOS_PUNISH_LEAVERS))
 			{
 				warning |= CONCEDE_WARNING.LEAVE_TEAMMATE_PENALTY;
-			}
+		}
 		}
 		if (friendlySidePlayer != null && friendlySidePlayer.IsEarlyConcedePopupAvailable() && (friendlySidePlayer.GetHero()?.GetCurrentHealth() ?? 0) > m_minHPForProgressAfterConcede && turn < num)
 		{
@@ -466,8 +480,8 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		}
 		if (warning == CONCEDE_WARNING.NONE)
 		{
-			return true;
-		}
+		return true;
+	}
 		return false;
 	}
 
@@ -478,16 +492,16 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		{
 		case CONCEDE_WARNING.NO_QUEST_PROGRESS:
 			info = new AlertPopup.PopupInfo
-			{
-				m_headerText = GameStrings.Get("GLUE_PROGRESSION_NO_QUEST_PROGRESS_FOR_CONCEDE_HEADER"),
-				m_text = GameStrings.Get("GLUE_PROGRESSION_NO_QUEST_PROGRESS_FOR_CONCEDE_BODY"),
-				m_confirmText = GameStrings.Get("GLUE_PROGRESSION_NO_QUEST_PROGRESS_FOR_CONCEDE_CONFIRM"),
-				m_cancelText = GameStrings.Get("GLUE_PROGRESSION_NO_QUEST_PROGRESS_FOR_CONCEDE_CANCEL"),
-				m_showAlertIcon = true,
-				m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
-				m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL,
-				m_responseCallback = OnConcededWarningAlertAnswered
-			};
+		{
+			m_headerText = GameStrings.Get("GLUE_PROGRESSION_NO_QUEST_PROGRESS_FOR_CONCEDE_HEADER"),
+			m_text = GameStrings.Get("GLUE_PROGRESSION_NO_QUEST_PROGRESS_FOR_CONCEDE_BODY"),
+			m_confirmText = GameStrings.Get("GLUE_PROGRESSION_NO_QUEST_PROGRESS_FOR_CONCEDE_CONFIRM"),
+			m_cancelText = GameStrings.Get("GLUE_PROGRESSION_NO_QUEST_PROGRESS_FOR_CONCEDE_CANCEL"),
+			m_showAlertIcon = true,
+			m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle,
+			m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL,
+			m_responseCallback = OnConcededWarningAlertAnswered
+		};
 			break;
 		case CONCEDE_WARNING.LEAVE_TEAMMATE_PENALTY:
 		{
@@ -525,16 +539,16 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 	{
 		switch (response)
 		{
-		case AlertPopup.Response.OK:
-		case AlertPopup.Response.CONFIRM:
-			if (GameState.Get() != null)
-			{
-				GameState.Get().Concede();
-			}
-			break;
-		case AlertPopup.Response.CANCEL:
-			OnConcededWarningAlertCanceled();
-			break;
+			case AlertPopup.Response.OK:
+			case AlertPopup.Response.CONFIRM:
+				if (GameState.Get() != null)
+				{
+					GameState.Get().Concede();
+				}
+				break;
+			case AlertPopup.Response.CANCEL:
+				OnConcededWarningAlertCanceled();
+				break;
 		}
 		Hide();
 	}
@@ -600,7 +614,7 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		{
 			return;
 		}
-		AssetLoader.Get().InstantiatePrefab("Korean_Ratings_OptionsScreen.prefab:aea866fab02b24ca697ede020cd85772", delegate(AssetReference name, GameObject go, object data)
+		AssetLoader.Get().InstantiatePrefab("Korean_Ratings_OptionsScreen.prefab:aea866fab02b24ca697ede020cd85772", delegate (AssetReference name, GameObject go, object data)
 		{
 			if (!(go == null))
 			{
@@ -637,26 +651,27 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 		{
 			switch (gameEntity.GetTag(GAME_TAG.CONCEDE_BUTTON_ALTERNATIVE_TEXT))
 			{
-			case 0:
-				m_concedeButton.SetText(GameStrings.Get("GLOBAL_CONCEDE"));
-				break;
-			case 1:
-				m_concedeButton.SetText(GameStrings.Get("GLOBAL_LEAVE"));
-				break;
-			case 2:
-				m_concedeButton.SetText(GameStrings.Get("GLOBAL_LEAVE_TUTORIAL"));
-				break;
-			case 3:
-				m_concedeButton.SetText(GameStrings.Get("GLOBAL_SKIP_TUTORIAL"));
-				break;
-			default:
-				m_concedeButton.SetText(GameStrings.Get("GLOBAL_CONCEDE"));
-				Log.Gameplay.PrintError($"GameMenu.UpdateConcedeButtonAlternativeText() - invalid concede button alternative text");
-				break;
+				case 0:
+					m_concedeButton.SetText(GameStrings.Get("GLOBAL_CONCEDE"));
+					break;
+				case 1:
+					m_concedeButton.SetText(GameStrings.Get("GLOBAL_LEAVE"));
+					break;
+				case 2:
+					m_concedeButton.SetText(GameStrings.Get("GLOBAL_LEAVE_TUTORIAL"));
+					break;
+				case 3:
+					m_concedeButton.SetText(GameStrings.Get("GLOBAL_SKIP_TUTORIAL"));
+					break;
+				default:
+					m_concedeButton.SetText(GameStrings.Get("GLOBAL_CONCEDE"));
+					Log.Gameplay.PrintError($"GameMenu.UpdateConcedeButtonAlternativeText() - invalid concede button alternative text");
+					break;
 			}
 		}
 	}
 
+
 	private void OnSkipNprButtonReleased(UIEvent e)
 	{
 		Hide();
@@ -683,4 +698,41 @@ public class GameMenu : ButtonListMenu, GameMenuInterface
 	{
 		RankMgr.Get().RequestSkipApprentice();
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadMenu()
+	{
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GAME_MENU_TITLE, CloseMainMenu, true);
+
+		foreach (var btn in m_allButtons)
+		{
+			if (btn.gameObject.activeInHierarchy && btn.IsEnabled())
+			{
+				m_accessibleMenu.AddOption(btn.GetText(), () => btn.TriggerRelease());
+			}
+		}
+
+		AccessibilityMgr.ShowUI(this);
+		m_accessibleMenu.StartReading();
+	}
+
+	public void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	private void CloseMainMenu()
+	{
+		BnetBar.Get().HideGameMenu();
+	}
+
+	public string GetAccessibleHelp()
+	{
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/GameMenuBase.cs b/Assembly-CSharp/GameMenuBase.cs
index 9f54d99..03dd229 100644
--- a/Assembly-CSharp/GameMenuBase.cs
+++ b/Assembly-CSharp/GameMenuBase.cs
@@ -19,7 +19,9 @@ public class GameMenuBase
 
 	public void ShowOptionsMenu()
 	{
-		if (m_hideCallback != null)
+        TransitioningToOptionsMenu = true;
+
+        if (m_hideCallback != null)
 		{
 			m_hideCallback();
 		}
@@ -36,9 +38,11 @@ public class GameMenuBase
 		{
 			SwitchToOptionsMenu();
 		}
-	}
 
-	public void DestroyOptionsMenu()
+        TransitioningToOptionsMenu = false;
+    }
+
+    public void DestroyOptionsMenu()
 	{
 		if (m_optionsMenu != null)
 		{
@@ -75,4 +79,8 @@ public class GameMenuBase
 			m_showCallback();
 		}
 	}
+
+	#region Accessibility
+	internal bool TransitioningToOptionsMenu { get; set; }
+	#endregion
 }
diff --git a/Assembly-CSharp/GameMgr.cs b/Assembly-CSharp/GameMgr.cs
index bc1828b..31da95a 100644
--- a/Assembly-CSharp/GameMgr.cs
+++ b/Assembly-CSharp/GameMgr.cs
@@ -16,6 +16,7 @@ using PegasusShared;
 using PegasusUtil;
 using SpectatorProto;
 using UnityEngine;
+using Accessibility;
 
 public class GameMgr : IService
 {
@@ -582,42 +583,42 @@ public class GameMgr : IService
 		m_nextMissionId = missionId;
 		m_nextBrawlLibraryItemId = brawlLibraryItemId;
 		m_lastEnterGameError = 0u;
-		switch (partyType)
-		{
-		case PartyType.BATTLEGROUNDS_PARTY:
-			if (!PartyManager.Get().IsInPrivateBattlegroundsParty())
+			switch (partyType)
 			{
-				m_nextGameType = GameType.GT_BATTLEGROUNDS;
+			case PartyType.BATTLEGROUNDS_PARTY:
+			if (!PartyManager.Get().IsInPrivateBattlegroundsParty())
+				{
+					m_nextGameType = GameType.GT_BATTLEGROUNDS;
 				string value = "solo";
 				if (BattleNet.GetPartyAttribute(PartyManager.Get().GetCurrentPartyId(), "battlegrounds_mode", out value))
 				{
 					m_nextGameType = ((value == "duos") ? GameType.GT_BATTLEGROUNDS_DUO : GameType.GT_BATTLEGROUNDS);
 				}
-			}
-			else
-			{
-				m_nextGameType = GameType.GT_BATTLEGROUNDS_FRIENDLY;
+				}
+				else
+				{
+					m_nextGameType = GameType.GT_BATTLEGROUNDS_FRIENDLY;
 				string value2 = "solo";
 				if (BattleNet.GetPartyAttribute(PartyManager.Get().GetCurrentPartyId(), "battlegrounds_mode", out value2))
 				{
 					m_nextGameType = ((value2 == "duos") ? GameType.GT_BATTLEGROUNDS_DUO_FRIENDLY : GameType.GT_BATTLEGROUNDS_FRIENDLY);
 				}
+				}
+				ChangeFindGameState(FindGameState.BNET_QUEUE_ENTERED);
+				break;
+			case PartyType.MERCENARIES_COOP_PARTY:
+				m_nextGameType = GameType.GT_MERCENARIES_PVE_COOP;
+				ChangeFindGameState(FindGameState.CLIENT_STARTED);
+				break;
+			case PartyType.MERCENARIES_FRIENDLY_CHALLENGE:
+				m_nextGameType = GameType.GT_MERCENARIES_FRIENDLY;
+				ChangeFindGameState(FindGameState.CLIENT_STARTED);
+				break;
+			default:
+				m_nextGameType = GameType.GT_VS_FRIEND;
+				ChangeFindGameState(FindGameState.CLIENT_STARTED);
+				break;
 			}
-			ChangeFindGameState(FindGameState.BNET_QUEUE_ENTERED);
-			break;
-		case PartyType.MERCENARIES_COOP_PARTY:
-			m_nextGameType = GameType.GT_MERCENARIES_PVE_COOP;
-			ChangeFindGameState(FindGameState.CLIENT_STARTED);
-			break;
-		case PartyType.MERCENARIES_FRIENDLY_CHALLENGE:
-			m_nextGameType = GameType.GT_MERCENARIES_FRIENDLY;
-			ChangeFindGameState(FindGameState.CLIENT_STARTED);
-			break;
-		default:
-			m_nextGameType = GameType.GT_VS_FRIEND;
-			ChangeFindGameState(FindGameState.CLIENT_STARTED);
-			break;
-		}
 		string text = DetermineTransitionPopupForFindGame(m_nextGameType, missionId);
 		if (text != null)
 		{
@@ -2684,7 +2685,7 @@ public class GameMgr : IService
 			{
 				presenceMgr.SetStatus(Global.PresenceStatus.SPECTATING_GAME_TUTORIAL);
 			}
-			else if (IsBattlegrounds() || m_missionId == 3539)
+			else if (IsPlayingBattlegrounds())
 			{
 				PresenceMgr.Get().SetStatus(Global.PresenceStatus.SPECTATING_GAME_BATTLEGROUNDS);
 			}
@@ -3564,4 +3565,13 @@ public class GameMgr : IService
 		m_gameSetup = null;
 		m_lastDisplayedPlayerNames.Clear();
 	}
+
+	#region Accessibility
+
+	internal bool IsPlayingBattlegrounds()
+	{
+		return IsBattlegrounds() || m_missionId == 3539;
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/GameModeDisplay.cs b/Assembly-CSharp/GameModeDisplay.cs
index 8110622..1e11b2d 100644
--- a/Assembly-CSharp/GameModeDisplay.cs
+++ b/Assembly-CSharp/GameModeDisplay.cs
@@ -8,6 +8,7 @@ using Hearthstone.DataModels;
 using Hearthstone.Streaming;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class GameModeDisplay : MonoBehaviour
 {
@@ -49,11 +50,11 @@ public class GameModeDisplay : MonoBehaviour
 	[SerializeField]
 	private Widget m_downloadPopupWidget;
 
-	private PlayButton m_playButton;
+	internal PlayButton m_playButton;
 
 	private UIBButton m_downloadButton;
 
-	private UIBButton m_backButton;
+	internal UIBButton m_backButton;
 
 	private bool m_playButtonFinishedLoading;
 
@@ -156,15 +157,15 @@ public class GameModeDisplay : MonoBehaviour
 	{
 		switch (eventName)
 		{
-		case "CHOOSE":
-			NavigateToSelectedMode();
-			break;
-		case "BACK":
-			GoToHub();
-			break;
-		case "GAME_MODE_CLICKED":
-			OnGameModeSelected();
-			break;
+			case "CHOOSE":
+				NavigateToSelectedMode();
+				break;
+			case "BACK":
+				GoToHub();
+				break;
+			case "GAME_MODE_CLICKED":
+				OnGameModeSelected();
+				break;
 		}
 	}
 
@@ -292,6 +293,8 @@ public class GameModeDisplay : MonoBehaviour
 				ModuleTag = tagString
 			});
 		}
+
+		AccessibleGameModeScene.Get().OnDisplayReady(gameModeSceneDataModel);
 	}
 
 	private bool ShouldShowNewBanner(GameModeDbfRecord gameModeRecord)
@@ -332,7 +335,7 @@ public class GameModeDisplay : MonoBehaviour
 		return false;
 	}
 
-	private bool CanEnterMode(out string reason, out ModeLockedStatus lockedStatus)
+	internal bool CanEnterMode(out string reason, out ModeLockedStatus lockedStatus)
 	{
 		reason = "";
 		lockedStatus = ModeLockedStatus.Locked;
@@ -553,38 +556,38 @@ public class GameModeDisplay : MonoBehaviour
 		SceneMgr.Mode mode = EnumUtils.Parse<SceneMgr.Mode>(record.LinkedScene);
 		switch (mode)
 		{
-		case SceneMgr.Mode.DRAFT:
-		{
-			ulong secondsUntilEndOfSeason = DraftManager.Get().SecondsUntilEndOfSeason;
-			NetCache.NetCacheFeatures netObject2 = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-			if (!DraftManager.Get().HasActiveRun && secondsUntilEndOfSeason <= netObject2.ArenaClosedToNewSessionsSeconds)
-			{
-				AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
-				popupInfo.m_headerText = GameStrings.Get("GLUE_ARENA_1ST_TIME_HEADER");
-				popupInfo.m_text = GameStrings.Get("GLUE_ARENA_SIGNUPS_CLOSED");
-				popupInfo.m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle;
-				popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
-				DialogManager.Get().ShowPopup(popupInfo);
-				return;
-			}
-			break;
-		}
-		case SceneMgr.Mode.LETTUCE_VILLAGE:
-		{
-			NetCache.NetCacheMercenariesPlayerInfo netObject = NetCache.Get().GetNetObject<NetCache.NetCacheMercenariesPlayerInfo>();
-			if (netObject == null)
-			{
-				Debug.LogWarning("GameModeDisplay: Mercenaries Player info has not loaded yet.");
-				return;
-			}
-			if (!GameUtils.IsMercenariesPrologueBountyComplete(netObject))
-			{
-				StartMercenariesTutorial();
-				return;
-			}
-			NarrativeManager.Get().PreloadMercenaryTutorialDialogue();
-			break;
-		}
+			case SceneMgr.Mode.DRAFT:
+				{
+					ulong secondsUntilEndOfSeason = DraftManager.Get().SecondsUntilEndOfSeason;
+					NetCache.NetCacheFeatures netObject2 = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+					if (!DraftManager.Get().HasActiveRun && secondsUntilEndOfSeason <= netObject2.ArenaClosedToNewSessionsSeconds)
+					{
+						AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
+						popupInfo.m_headerText = GameStrings.Get("GLUE_ARENA_1ST_TIME_HEADER");
+						popupInfo.m_text = GameStrings.Get("GLUE_ARENA_SIGNUPS_CLOSED");
+						popupInfo.m_alertTextAlignmentAnchor = UberText.AnchorOptions.Middle;
+						popupInfo.m_responseDisplay = AlertPopup.ResponseDisplay.OK;
+						DialogManager.Get().ShowPopup(popupInfo);
+						return;
+					}
+					break;
+				}
+			case SceneMgr.Mode.LETTUCE_VILLAGE:
+				{
+					NetCache.NetCacheMercenariesPlayerInfo netObject = NetCache.Get().GetNetObject<NetCache.NetCacheMercenariesPlayerInfo>();
+					if (netObject == null)
+					{
+						Debug.LogWarning("GameModeDisplay: Mercenaries Player info has not loaded yet.");
+						return;
+					}
+					if (!GameUtils.IsMercenariesPrologueBountyComplete(netObject))
+					{
+						StartMercenariesTutorial();
+						return;
+					}
+					NarrativeManager.Get().PreloadMercenaryTutorialDialogue();
+					break;
+				}
 		}
 		m_clickBlocker.SetActive(value: true);
 		SceneMgr.Get().SetNextMode(mode, SceneMgr.TransitionHandlerType.CURRENT_SCENE, OnSceneLoadCompleteHandleTransition);
@@ -615,6 +618,12 @@ public class GameModeDisplay : MonoBehaviour
 
 	public static bool ShouldSeeNewTavernBrawlBanner()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Not implemented yet
+			return false;
+		}
+
 		TavernBrawlManager tavernBrawlManager = TavernBrawlManager.Get();
 		if (s_hasAlreadyShownTavernBrawlNewBanner || tavernBrawlManager == null)
 		{
@@ -660,37 +669,8 @@ public class GameModeDisplay : MonoBehaviour
 			return;
 		}
 		m_selectedGameModeButtonDataModel = (GameModeButtonDataModel)eventDataModel.Payload;
-		GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.GAME_MODE_SCENE, GameSaveKeySubkeyId.GAME_MODE_SCENE_LAST_SELECTED_GAME_MODE, m_selectedGameModeButtonDataModel.GameModeRecordId));
-		GameModeSceneDataModel gameModeSceneDataModel = GetGameModeSceneDataModel();
-		if (gameModeSceneDataModel != null)
-		{
-			gameModeSceneDataModel.LastSelectedGameModeRecordId = m_selectedGameModeButtonDataModel.GameModeRecordId;
-		}
-		if (!CanEnterMode(out var reason, out var lockedStatus))
-		{
-			m_lockedNameText.Text = GameStrings.Format(reason, m_selectedGameModeButtonDataModel.Name);
-			switch (lockedStatus)
-			{
-			case ModeLockedStatus.DownloadRequired:
-				m_selectedGameModeButtonDataModel.IsDownloadRequired = true;
-				m_gameModeButtonController.SetState("GAME_MODE_DOWNLOAD_REQUIRED");
-				break;
-			case ModeLockedStatus.Downloading:
-				m_selectedGameModeButtonDataModel.IsDownloading = true;
-				m_gameModeButtonController.SetState("GAME_MODE_DOWNLOADING");
-				m_playButton.Disable(keepLabelTextVisible: true);
-				break;
-			default:
-				m_playButton.Disable(keepLabelTextVisible: true);
-				m_gameModeButtonController.SetState("GAME_MODE_LOCKED");
-				break;
-			}
-		}
-		else
-		{
-			m_playButton.Enable();
-			m_gameModeButtonController.SetState("GAME_MODE_ACTIVE");
-		}
+
+		OnGameModeSelectedPart2();
 	}
 
 	private void ShowDisabledPopupForCurrentMode(string lockReason)
@@ -717,4 +697,47 @@ public class GameModeDisplay : MonoBehaviour
 		};
 		DialogManager.Get().ShowPopup(info);
 	}
+
+	#region Accessibility
+	internal void SelectMode(GameModeButtonDataModel gameModeButtonDataModel)
+	{
+		m_selectedGameModeButtonDataModel = gameModeButtonDataModel;
+		OnGameModeSelectedPart2();
+	}
+
+	private void OnGameModeSelectedPart2()
+	{
+		GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.GAME_MODE_SCENE, GameSaveKeySubkeyId.GAME_MODE_SCENE_LAST_SELECTED_GAME_MODE, m_selectedGameModeButtonDataModel.GameModeRecordId));
+		GameModeSceneDataModel gameModeSceneDataModel = GetGameModeSceneDataModel();
+		if (gameModeSceneDataModel != null)
+		{
+			gameModeSceneDataModel.LastSelectedGameModeRecordId = m_selectedGameModeButtonDataModel.GameModeRecordId;
+		}
+		if (!CanEnterMode(out var reason, out var lockedStatus))
+		{
+			m_lockedNameText.Text = GameStrings.Format(reason, m_selectedGameModeButtonDataModel.Name);
+			switch (lockedStatus)
+			{
+				case ModeLockedStatus.DownloadRequired:
+					m_selectedGameModeButtonDataModel.IsDownloadRequired = true;
+					m_gameModeButtonController.SetState("GAME_MODE_DOWNLOAD_REQUIRED");
+					break;
+				case ModeLockedStatus.Downloading:
+					m_selectedGameModeButtonDataModel.IsDownloading = true;
+					m_gameModeButtonController.SetState("GAME_MODE_DOWNLOADING");
+					m_playButton.Disable(keepLabelTextVisible: true);
+					break;
+				default:
+					m_playButton.Disable(keepLabelTextVisible: true);
+					m_gameModeButtonController.SetState("GAME_MODE_LOCKED");
+					break;
+			}
+		}
+		else
+		{
+			m_playButton.Enable();
+			m_gameModeButtonController.SetState("GAME_MODE_ACTIVE");
+		}
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/GameState.cs b/Assembly-CSharp/GameState.cs
index 7365968..3574545 100644
--- a/Assembly-CSharp/GameState.cs
+++ b/Assembly-CSharp/GameState.cs
@@ -11,6 +11,7 @@ using Blizzard.T5.Core;
 using Cysharp.Threading.Tasks;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class GameState
 {
@@ -20,14 +21,16 @@ public class GameState
 		OPTION,
 		SUB_OPTION,
 		OPTION_TARGET,
-		CHOICE
+		CHOICE,
+		EOE
 	}
 
 	public enum CreateGamePhase
 	{
 		INVALID,
 		CREATING,
-		CREATED
+		CREATED,
+		EOE
 	}
 
 	public delegate void GameStateInitializedCallback(GameState instance, object userData);
@@ -973,7 +976,7 @@ public class GameState
 			}
 			break;
 		default:
-			Debug.LogWarning($"GameState.IsResponsePacketBlocked() - unhandled response mode {m_responseMode}");
+			UnityEngine.Debug.LogWarning($"GameState.IsResponsePacketBlocked() - unhandled response mode {m_responseMode}");
 			break;
 		}
 		return false;
@@ -1019,7 +1022,7 @@ public class GameState
 		int playerId = playerInfo.GetPlayerId();
 		if (m_playerInfoMap.ContainsKey(playerId))
 		{
-			Debug.LogWarning($"GameState.AddPlayerInfo() - playerInfo {playerInfo} has already been added");
+			UnityEngine.Debug.LogWarning($"GameState.AddPlayerInfo() - playerInfo {playerInfo} has already been added");
 		}
 		else
 		{
@@ -1604,6 +1607,12 @@ public class GameState
 
 	public bool CanShowScoreScreen()
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+            // The modes that use this screen are not implemented yet
+            return false;
+        }
+
 		if (HasScoreLabels(m_gameEntity))
 		{
 			return true;
@@ -2026,6 +2035,14 @@ public class GameState
 		{
 			return false;
 		}
+		if (AccessibilityMgr.IsAccessibilityEnabled() && AccessiblePowerTaskListDescriber.Get().IsBusy())
+        {
+			return false;
+        }
+		if (AccessibilityMgr.IsAccessibilityEnabled() && AccessiblePlayDescriber.Get().IsBusy())
+        {
+			return false;
+        }
 		return true;
 	}
 
@@ -2774,6 +2791,7 @@ public class GameState
 
 	private void FireCreateGameEvent()
 	{
+		AccessiblePowerTaskListDescriber.Get().OnGameStart();
 		CreateGameListener[] array = m_createGameListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
@@ -2871,7 +2889,7 @@ public class GameState
 		TurnTimerUpdateListener[] array = null;
 		if (GetGameEntity() == null)
 		{
-			Debug.LogWarning("FireTurnTimerUpdateEvent - Turn timer update received before game entity created.");
+			UnityEngine.Debug.LogWarning("FireTurnTimerUpdateEvent - Turn timer update received before game entity created.");
 			return;
 		}
 		array = ((!GetGameEntity().IsMulliganActiveRealTime()) ? m_turnTimerUpdateListeners.ToArray() : m_mulliganTimerUpdateListeners.ToArray());
@@ -3032,26 +3050,26 @@ public class GameState
 		m_responseMode = ResponseMode.OPTION;
 		if (m_selectedOption.m_main >= 0 && m_selectedOption.m_main < m_options.List.Count)
 		{
-			switch (responseMode)
-			{
-			case ResponseMode.SUB_OPTION:
-			{
-				Network.Options.Option option2 = m_options.List[m_selectedOption.m_main];
-				UpdateSubOptionHighlights(option2);
-				break;
-			}
-			case ResponseMode.OPTION_TARGET:
+		switch (responseMode)
+		{
+		case ResponseMode.SUB_OPTION:
+		{
+			Network.Options.Option option2 = m_options.List[m_selectedOption.m_main];
+			UpdateSubOptionHighlights(option2);
+			break;
+		}
+		case ResponseMode.OPTION_TARGET:
+		{
+			Network.Options.Option option = m_options.List[m_selectedOption.m_main];
+			UpdateTargetHighlights(option.Main);
+			if (m_selectedOption.m_sub != -1)
 			{
-				Network.Options.Option option = m_options.List[m_selectedOption.m_main];
-				UpdateTargetHighlights(option.Main);
-				if (m_selectedOption.m_sub != -1)
-				{
-					Network.Options.Option.SubOption subOption = option.Subs[m_selectedOption.m_sub];
-					UpdateTargetHighlights(subOption);
-				}
-				break;
-			}
+				Network.Options.Option.SubOption subOption = option.Subs[m_selectedOption.m_sub];
+				UpdateTargetHighlights(subOption);
 			}
+			break;
+		}
+		}
 		}
 		UpdateOptionHighlights(m_lastOptions);
 		UpdateOptionHighlights();
@@ -3839,13 +3857,13 @@ public class GameState
 			{
 				continue;
 			}
-			bool flag = option.Main.IsValidTarget(movedEntity.GetEntityId());
-			cardDefComponent.Fsm.GetFsmGameObject("HoverTargetCard").Value = card.gameObject;
-			cardDefComponent.Fsm.GetFsmBool("SuppressGlow").Value = suppressGlow || !flag;
+				bool flag = option.Main.IsValidTarget(movedEntity.GetEntityId());
+				cardDefComponent.Fsm.GetFsmGameObject("HoverTargetCard").Value = card.gameObject;
+				cardDefComponent.Fsm.GetFsmBool("SuppressGlow").Value = suppressGlow || !flag;
 			SetCustomMoveMinionTargetSpellVariables(cardDefComponent, movedEntity);
-			cardDefComponent.SendEvent("Action");
-			if (flag)
-			{
+				cardDefComponent.SendEvent("Action");
+				if (flag)
+				{
 				if (!movedEntity.HasTag(GAME_TAG.BACON_COSTS_HEALTH_TO_BUY))
 				{
 					ManaCrystalMgr.Get().ProposeManaCrystalUsage(card.GetEntity());
@@ -3921,7 +3939,7 @@ public class GameState
 			{
 				continue;
 			}
-			Card card = moveMinionHoverTargetsInPlay.FirstOrDefault((Card t) => t.GetEntity().GetEntityId() == option.Main.ID);
+				Card card = moveMinionHoverTargetsInPlay.FirstOrDefault((Card t) => t.GetEntity().GetEntityId() == option.Main.ID);
 			if (!(card == null))
 			{
 				if (heldEntity.HasTag(GAME_TAG.BACON_COSTS_HEALTH_TO_BUY))
@@ -4321,7 +4339,7 @@ public class GameState
 		Entity entity = GetEntity(netChange.Entity);
 		if (entity == null)
 		{
-			Debug.LogWarningFormat("GameState.OnTagChange() - WARNING Entity {0} does not exist", netChange.Entity);
+			UnityEngine.Debug.LogWarningFormat("GameState.OnTagChange() - WARNING Entity {0} does not exist", netChange.Entity);
 			return false;
 		}
 		TagDelta tagDelta = new TagDelta();
@@ -4358,7 +4376,7 @@ public class GameState
 		Entity entity = GetEntity(netChange.Entity);
 		if (entity == null)
 		{
-			Debug.LogWarningFormat("GameState.OnCachedTagForDormantChange() - WARNING Entity {0} does not exist", netChange.Entity);
+			UnityEngine.Debug.LogWarningFormat("GameState.OnCachedTagForDormantChange() - WARNING Entity {0} does not exist", netChange.Entity);
 			return false;
 		}
 		TagDelta tagDelta = new TagDelta();
@@ -4374,7 +4392,7 @@ public class GameState
 		Player player = GetPlayer(shuffleDeck.PlayerID);
 		if (player == null)
 		{
-			Debug.LogWarningFormat("GameState.OnShuffleDeck() - WARNING Player for ID {0} does not exist", shuffleDeck.PlayerID);
+			UnityEngine.Debug.LogWarningFormat("GameState.OnShuffleDeck() - WARNING Player for ID {0} does not exist", shuffleDeck.PlayerID);
 			return false;
 		}
 		if (EntityRemovedFromGame(player.GetEntityId()))
@@ -4389,13 +4407,13 @@ public class GameState
 	{
 		if (go == null)
 		{
-			Debug.LogWarning($"{MethodBase.GetCurrentMethod().Name} - FAILED to load \"{assetRef}\"");
+			UnityEngine.Debug.LogWarning($"{MethodBase.GetCurrentMethod().Name} - FAILED to load \"{assetRef}\"");
 			return;
 		}
 		AudioSource component = go.GetComponent<AudioSource>();
 		if (component == null)
 		{
-			Debug.LogWarning(string.Format("{0} - ERROR \"{1}\" has no {2} component", assetRef, MethodBase.GetCurrentMethod().Name, "AudioSource"));
+			UnityEngine.Debug.LogWarning(string.Format("{0} - ERROR \"{1}\" has no {2} component", assetRef, MethodBase.GetCurrentMethod().Name, "AudioSource"));
 		}
 		else if (callbackData is Network.HistVoSpell histVoSpell)
 		{
@@ -4532,7 +4550,7 @@ public class GameState
 		Entity entity = GetEntity(netChange.Entity);
 		if (entity == null)
 		{
-			Debug.LogWarningFormat("GameState.OnEarlyConcedeTagChange() - WARNING Entity {0} does not exist", netChange.Entity);
+			UnityEngine.Debug.LogWarningFormat("GameState.OnEarlyConcedeTagChange() - WARNING Entity {0} does not exist", netChange.Entity);
 			return false;
 		}
 		TagDelta tagDelta = new TagDelta();
@@ -4609,7 +4627,7 @@ public class GameState
 			{
 				if (!EntityRemovedFromGame(num))
 				{
-					Debug.LogWarning($"GameState.OnMetaData() - WARNING Entity {num} does not exist");
+					UnityEngine.Debug.LogWarning($"GameState.OnMetaData() - WARNING Entity {num} does not exist");
 				}
 				return false;
 			}
@@ -4624,7 +4642,7 @@ public class GameState
 				{
 					if (!EntityRemovedFromGame(item))
 					{
-						Debug.LogWarning($"GameState.OnMetaData() - WARNING Entity {item} does not exist");
+						UnityEngine.Debug.LogWarning($"GameState.OnMetaData() - WARNING Entity {item} does not exist");
 					}
 					return false;
 				}
@@ -4649,6 +4667,7 @@ public class GameState
 				m_createGameListeners.Clear();
 			}
 		}
+		taskList.FireCompleteEvent();
 		RemoveQueuedEntitiesFromGame();
 	}
 
@@ -4699,7 +4718,7 @@ public class GameState
 		}
 		if (GameScenarioAllowsPowerPrinting())
 		{
-			DebugPrintOptions(Log.Power);
+		DebugPrintOptions(Log.Power);
 		}
 		if (InputManager.Get().IsPaused())
 		{
@@ -4707,7 +4726,7 @@ public class GameState
 			if (!ResolveExistingTargetWithNewOptions())
 			{
 				InputManager.Get().CancelTargetMode();
-				EnterMainOptionMode();
+		EnterMainOptionMode();
 			}
 			else
 			{
@@ -4773,7 +4792,7 @@ public class GameState
 		{
 			if (GameScenarioAllowsPowerPrinting())
 			{
-				Log.Power.Print("GameState.OnEntityChoices() - id={0} playerId={1} queued", choices.ID, choices.PlayerId);
+			Log.Power.Print("GameState.OnEntityChoices() - id={0} playerId={1} queued", choices.ID, choices.PlayerId);
 			}
 			QueuedChoice item = new QueuedChoice
 			{
@@ -4795,7 +4814,7 @@ public class GameState
 		{
 			if (GameScenarioAllowsPowerPrinting())
 			{
-				Log.Power.Print("GameState.OnEntitiesChosen() - id={0} playerId={1} queued", chosen.ID, chosen.PlayerId);
+			Log.Power.Print("GameState.OnEntitiesChosen() - id={0} playerId={1} queued", chosen.ID, chosen.PlayerId);
 			}
 			QueuedChoice item = new QueuedChoice
 			{
@@ -5013,11 +5032,11 @@ public class GameState
 	{
 		if (m_lastSelectedOption == null)
 		{
-			Debug.LogError("GameState.OnOptionRejected() - got an option rejection without a last selected option");
+			UnityEngine.Debug.LogError("GameState.OnOptionRejected() - got an option rejection without a last selected option");
 		}
 		else if (m_lastOptions.ID != optionId)
 		{
-			Debug.LogErrorFormat("GameState.OnOptionRejected() - rejected option id ({0}) does not match last option id ({1})", optionId, m_lastOptions.ID);
+			UnityEngine.Debug.LogErrorFormat("GameState.OnOptionRejected() - rejected option id ({0}) does not match last option id ({1})", optionId, m_lastOptions.ID);
 		}
 		else
 		{
@@ -5069,29 +5088,29 @@ public class GameState
 		{
 			return;
 		}
-		ChoiceCardMgr.Get().OnSendChoices(friendlyEntityChoices, m_chosenEntities);
+			ChoiceCardMgr.Get().OnSendChoices(friendlyEntityChoices, m_chosenEntities);
 		bool flag = GameScenarioAllowsPowerPrinting();
 		if (flag)
 		{
 			Log.Power.Print("GameState.SendChoices() - id={0} ChoiceType={1}", friendlyEntityChoices.ID, friendlyEntityChoices.ChoiceType);
 		}
-		List<int> list = new List<int>();
-		for (int i = 0; i < m_chosenEntities.Count; i++)
-		{
-			Entity entity = m_chosenEntities[i];
-			int entityId = entity.GetEntityId();
+			List<int> list = new List<int>();
+			for (int i = 0; i < m_chosenEntities.Count; i++)
+			{
+				Entity entity = m_chosenEntities[i];
+				int entityId = entity.GetEntityId();
 			if (flag)
 			{
 				Log.Power.Print("GameState.SendChoices() -   m_chosenEntities[{0}]={1}", i, entity);
 			}
-			list.Add(entityId);
-		}
-		if (!GameMgr.Get().IsSpectator())
-		{
-			Network.Get().SendChoices(friendlyEntityChoices.ID, list);
+				list.Add(entityId);
+			}
+			if (!GameMgr.Get().IsSpectator())
+			{
+				Network.Get().SendChoices(friendlyEntityChoices.ID, list);
+			}
+			ClearResponseMode();
 		}
-		ClearResponseMode();
-	}
 
 	public void OnEntitiesChosenProcessed(Network.EntitiesChosen chosen)
 	{
@@ -5119,8 +5138,8 @@ public class GameState
 			Network.Get().SendOption(m_options.ID, m_selectedOption.m_main, m_selectedOption.m_target, m_selectedOption.m_sub, m_selectedOption.m_position);
 			if (GameScenarioAllowsPowerPrinting())
 			{
-				Log.Power.Print("GameState.SendOption() - selectedOption={0} selectedSubOption={1} selectedTarget={2} selectedPosition={3}", m_selectedOption.m_main, m_selectedOption.m_sub, m_selectedOption.m_target, m_selectedOption.m_position);
-			}
+			Log.Power.Print("GameState.SendOption() - selectedOption={0} selectedSubOption={1} selectedTarget={2} selectedPosition={3}", m_selectedOption.m_main, m_selectedOption.m_sub, m_selectedOption.m_target, m_selectedOption.m_position);
+		}
 		}
 		OnSelectedOptionsSent();
 		Network.Options.Option option = m_lastOptions.List[m_lastSelectedOption.m_main];
diff --git a/Assembly-CSharp/GameStrings.cs b/Assembly-CSharp/GameStrings.cs
index 9b0171e..9e8795a 100644
--- a/Assembly-CSharp/GameStrings.cs
+++ b/Assembly-CSharp/GameStrings.cs
@@ -1207,6 +1207,8 @@ public class GameStrings
 		}
 		float realtimeSinceStartup2 = Time.realtimeSinceStartup;
 		Log.Performance.Print($"Loading All GameStrings took {realtimeSinceStartup2 - realtimeSinceStartup}s)");
+
+		DefaultGameStrings.LoadAll(); // Accessibility
 	}
 
 	public static IEnumerator<IAsyncJobResult> Job_LoadAll()
@@ -1217,7 +1219,12 @@ public class GameStrings
 			if (value != 0)
 			{
 				jobResultCollection.Add(CreateLoadCategoryJob(value, native: false));
-			}
+
+				if (value == Global.GameStringCategory.ACCESSIBILITY)
+                {
+                    jobResultCollection.Add(DefaultGameStrings.CreateLoadCategoryJob(value, native: false));
+                }
+            }
 		}
 		yield return jobResultCollection;
 	}
@@ -1263,6 +1270,7 @@ public class GameStrings
 	public static void LoadNative()
 	{
 		ReloadAllInternal(native: true);
+		DefaultGameStrings.LoadNative();
 	}
 
 	public static string GetAssetPath(Locale locale, string fileName, bool native = false)
@@ -1553,16 +1561,16 @@ public class GameStrings
 			{
 				SceneMgr sceneMgr2 = SceneMgr.Get();
 				if (sceneMgr2 == null || sceneMgr2.GetMode() != SceneMgr.Mode.LETTUCE_MAP)
-				{
+		{
 					goto IL_005f;
 				}
 			}
 		}
-		string text = key + "_MERC";
-		if (HasKey(text))
-		{
-			return text;
-		}
+			string text = key + "_MERC";
+			if (HasKey(text))
+			{
+				return text;
+			}
 		goto IL_005f;
 		IL_005f:
 		return key;
@@ -2379,4 +2387,31 @@ public class GameStrings
 			return 1;
 		}
 	}
+
+	#region Accessibility - Used for regression testing
+
+	public static List<string> FindKeysWithValue(string value)
+	{
+		var ret = new List<string>();
+		foreach (GameStringTable table in s_tables.Values)
+		{
+			var values = table.GetAll();
+
+			foreach (var entry in values)
+            {
+				if (entry.Value.Equals(value))
+                {
+					ret.Add(entry.Key);
+                }
+            }
+		}
+		return ret;
+	}
+
+    internal static string Get(string v, object readProfile)
+    {
+        throw new NotImplementedException();
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/GameUtils.cs b/Assembly-CSharp/GameUtils.cs
index d364716..8ecb71b 100644
--- a/Assembly-CSharp/GameUtils.cs
+++ b/Assembly-CSharp/GameUtils.cs
@@ -13,3483 +13,3583 @@ using PegasusLettuce;
 using PegasusShared;
 using UnityEngine;
 using UnityEngine.Events;
+using Accessibility;
 
 public class GameUtils
 {
-	[Serializable]
-	public class StringEvent : UnityEvent<string>
-	{
-	}
+    [Serializable]
+    public class StringEvent : UnityEvent<string>
+    {
+    }
 
-	public delegate void EmoteSoundLoaded(CardSoundSpell emoteObj);
+    public delegate void EmoteSoundLoaded(CardSoundSpell emoteObj);
 
-	public delegate void LoadActorCallback(Actor actor);
+    public delegate void LoadActorCallback(Actor actor);
 
-	public class HeroSkinAchievements
-	{
-		public int Golden500Win { get; set; }
+    public class HeroSkinAchievements
+    {
+        public int Golden500Win { get; set; }
 
-		public int Honored1kWin { get; set; }
-	}
+        public int Honored1kWin { get; set; }
+    }
 
-	private class LoadActorCallbackInfo
-	{
-		public DefLoader.DisposableFullDef fullDef;
+    private class LoadActorCallbackInfo
+    {
+        public DefLoader.DisposableFullDef fullDef;
 
-		public TAG_PREMIUM premium;
-	}
+        public TAG_PREMIUM premium;
+    }
 
-	public static StringEvent OnAnimationExitEvent = new StringEvent();
+    public static StringEvent OnAnimationExitEvent = new StringEvent();
 
 	private const int TAG_BANNED_IN_TWIST = 3108;
 
-	public static readonly TAG_CLASS[] ORDERED_HERO_CLASSES = new TAG_CLASS[11]
-	{
-		TAG_CLASS.DEATHKNIGHT,
-		TAG_CLASS.DEMONHUNTER,
-		TAG_CLASS.DRUID,
-		TAG_CLASS.HUNTER,
-		TAG_CLASS.MAGE,
-		TAG_CLASS.PALADIN,
-		TAG_CLASS.PRIEST,
-		TAG_CLASS.ROGUE,
-		TAG_CLASS.SHAMAN,
-		TAG_CLASS.WARLOCK,
-		TAG_CLASS.WARRIOR
-	};
+    public static readonly TAG_CLASS[] ORDERED_HERO_CLASSES = new TAG_CLASS[11]
+    {
+        TAG_CLASS.DEATHKNIGHT,
+        TAG_CLASS.DEMONHUNTER,
+        TAG_CLASS.DRUID,
+        TAG_CLASS.HUNTER,
+        TAG_CLASS.MAGE,
+        TAG_CLASS.PALADIN,
+        TAG_CLASS.PRIEST,
+        TAG_CLASS.ROGUE,
+        TAG_CLASS.SHAMAN,
+        TAG_CLASS.WARLOCK,
+        TAG_CLASS.WARRIOR
+    };
 
 	public static readonly TAG_CLASS[] DEFAULT_HERO_CLASSES = new TAG_CLASS[11]
-	{
+    {
 		TAG_CLASS.DEATHKNIGHT,
-		TAG_CLASS.DEMONHUNTER,
-		TAG_CLASS.DRUID,
-		TAG_CLASS.HUNTER,
-		TAG_CLASS.MAGE,
-		TAG_CLASS.PALADIN,
-		TAG_CLASS.PRIEST,
-		TAG_CLASS.ROGUE,
-		TAG_CLASS.SHAMAN,
-		TAG_CLASS.WARLOCK,
-		TAG_CLASS.WARRIOR
-	};
-
-	public static readonly TAG_CLASS[] CLASSIC_ORDERED_HERO_CLASSES = new TAG_CLASS[9]
-	{
-		TAG_CLASS.DRUID,
-		TAG_CLASS.HUNTER,
-		TAG_CLASS.MAGE,
-		TAG_CLASS.PALADIN,
-		TAG_CLASS.PRIEST,
-		TAG_CLASS.ROGUE,
-		TAG_CLASS.SHAMAN,
-		TAG_CLASS.WARLOCK,
-		TAG_CLASS.WARRIOR
-	};
-
-	public static readonly Dictionary<TAG_CLASS, HeroSkinAchievements> HERO_SKIN_ACHIEVEMENTS = new Dictionary<TAG_CLASS, HeroSkinAchievements>
-	{
-		{
-			TAG_CLASS.MAGE,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 179,
-				Honored1kWin = 180
-			}
-		},
-		{
-			TAG_CLASS.PRIEST,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 196,
-				Honored1kWin = 197
-			}
-		},
-		{
-			TAG_CLASS.WARLOCK,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 213,
-				Honored1kWin = 214
-			}
-		},
-		{
-			TAG_CLASS.ROGUE,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 230,
-				Honored1kWin = 231
-			}
-		},
-		{
-			TAG_CLASS.DRUID,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 247,
-				Honored1kWin = 248
-			}
-		},
-		{
-			TAG_CLASS.DEMONHUNTER,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 264,
-				Honored1kWin = 265
-			}
-		},
-		{
-			TAG_CLASS.DEATHKNIGHT,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 5520,
-				Honored1kWin = 5521
-			}
-		},
-		{
-			TAG_CLASS.SHAMAN,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 281,
-				Honored1kWin = 282
-			}
-		},
-		{
-			TAG_CLASS.HUNTER,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 298,
-				Honored1kWin = 299
-			}
-		},
-		{
-			TAG_CLASS.PALADIN,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 315,
-				Honored1kWin = 316
-			}
-		},
-		{
-			TAG_CLASS.WARRIOR,
-			new HeroSkinAchievements
-			{
-				Golden500Win = 332,
-				Honored1kWin = 333
-			}
-		}
-	};
-
-	private static ReactiveNetCacheObject<NetCache.NetCacheProfileProgress> s_profileProgress = ReactiveNetCacheObject<NetCache.NetCacheProfileProgress>.CreateInstance();
-
-	private static Comparison<BoosterDbfRecord> SortBoostersDescending = (BoosterDbfRecord a, BoosterDbfRecord b) => b.LatestExpansionOrder.CompareTo(a.LatestExpansionOrder);
-
-	private const int RANKED_SEASON_ID_START = 6;
-
-	private const int RANKED_SEASON_MONTH_START = 4;
-
-	private const int RANKED_SEASON_YEAR_START = 2014;
+        TAG_CLASS.DEMONHUNTER,
+        TAG_CLASS.DRUID,
+        TAG_CLASS.HUNTER,
+        TAG_CLASS.MAGE,
+        TAG_CLASS.PALADIN,
+        TAG_CLASS.PRIEST,
+        TAG_CLASS.ROGUE,
+        TAG_CLASS.SHAMAN,
+        TAG_CLASS.WARLOCK,
+        TAG_CLASS.WARRIOR
+    };
+
+    public static readonly TAG_CLASS[] CLASSIC_ORDERED_HERO_CLASSES = new TAG_CLASS[9]
+    {
+        TAG_CLASS.DRUID,
+        TAG_CLASS.HUNTER,
+        TAG_CLASS.MAGE,
+        TAG_CLASS.PALADIN,
+        TAG_CLASS.PRIEST,
+        TAG_CLASS.ROGUE,
+        TAG_CLASS.SHAMAN,
+        TAG_CLASS.WARLOCK,
+        TAG_CLASS.WARRIOR
+    };
+
+    public static readonly Dictionary<TAG_CLASS, HeroSkinAchievements> HERO_SKIN_ACHIEVEMENTS = new Dictionary<TAG_CLASS, HeroSkinAchievements>
+    {
+        {
+            TAG_CLASS.MAGE,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 179,
+                Honored1kWin = 180
+            }
+        },
+        {
+            TAG_CLASS.PRIEST,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 196,
+                Honored1kWin = 197
+            }
+        },
+        {
+            TAG_CLASS.WARLOCK,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 213,
+                Honored1kWin = 214
+            }
+        },
+        {
+            TAG_CLASS.ROGUE,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 230,
+                Honored1kWin = 231
+            }
+        },
+        {
+            TAG_CLASS.DRUID,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 247,
+                Honored1kWin = 248
+            }
+        },
+        {
+            TAG_CLASS.DEMONHUNTER,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 264,
+                Honored1kWin = 265
+            }
+        },
+        {
+            TAG_CLASS.DEATHKNIGHT,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 5520,
+                Honored1kWin = 5521
+            }
+        },
+        {
+            TAG_CLASS.SHAMAN,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 281,
+                Honored1kWin = 282
+            }
+        },
+        {
+            TAG_CLASS.HUNTER,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 298,
+                Honored1kWin = 299
+            }
+        },
+        {
+            TAG_CLASS.PALADIN,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 315,
+                Honored1kWin = 316
+            }
+        },
+        {
+            TAG_CLASS.WARRIOR,
+            new HeroSkinAchievements
+            {
+                Golden500Win = 332,
+                Honored1kWin = 333
+            }
+        }
+    };
+
+    private static ReactiveNetCacheObject<NetCache.NetCacheProfileProgress> s_profileProgress = ReactiveNetCacheObject<NetCache.NetCacheProfileProgress>.CreateInstance();
+
+    private static Comparison<BoosterDbfRecord> SortBoostersDescending = (BoosterDbfRecord a, BoosterDbfRecord b) => b.LatestExpansionOrder.CompareTo(a.LatestExpansionOrder);
+
+    private const int RANKED_SEASON_ID_START = 6;
+
+    private const int RANKED_SEASON_MONTH_START = 4;
+
+    private const int RANKED_SEASON_YEAR_START = 2014;
+
+    private const int MERCENARIES_SEASON_ID_START = 1;
+
+    private const int MERCENARIES_SEASON_MONTH_START = 11;
+
+    private const int MERCENARIES_SEASON_YEAR_START = 2021;
+
+    public static string TranslateDbIdToCardId(int dbId, bool showWarning = false)
+    {
+        CardDbfRecord record = GameDbf.Card.GetRecord(dbId);
+        if (record == null)
+        {
+            if (showWarning)
+            {
+                Log.All.PrintError("GameUtils.TranslateDbIdToCardId() - Failed to find card with database id {0} in the Card DBF.", dbId);
+            }
+            return null;
+        }
+        string noteMiniGuid = record.NoteMiniGuid;
+        if (noteMiniGuid == null)
+        {
+            if (showWarning)
+            {
+                Log.All.PrintError("GameUtils.TranslateDbIdToCardId() - Card with database id {0} has no NOTE_MINI_GUID field in the Card DBF.", dbId);
+            }
+            return null;
+        }
+        return noteMiniGuid;
+    }
+
+    public static int TranslateCardIdToDbId(string cardId, bool showWarning = false)
+    {
+        CardDbfRecord cardRecord = GetCardRecord(cardId);
+        if (cardRecord == null)
+        {
+            if (showWarning)
+            {
+                Log.All.PrintError("GameUtils.TranslateCardIdToDbId() - There is no card with NOTE_MINI_GUID {0} in the Card DBF.", cardId);
+            }
+            return 0;
+        }
+        return cardRecord.ID;
+    }
+
+    public static bool IsCardCollectible(string cardId)
+    {
+        return GetCardTagValue(cardId, GAME_TAG.COLLECTIBLE) == 1;
+    }
+
+    public static bool IsCardInBattlegroundsPool(string cardId)
+    {
+        if (GetCardTagValue(cardId, GAME_TAG.IS_BACON_POOL_MINION) != 1)
+        {
+            return GetCardTagValue(cardId, GAME_TAG.BACON_HERO_CAN_BE_DRAFTED) == 1;
+        }
+        return true;
+    }
+
+    public static bool IsAdventureRotated(AdventureDbId adventureID)
+    {
+        return IsAdventureRotated(adventureID, DateTime.UtcNow);
+    }
+
+    public static bool IsAdventureRotated(AdventureDbId adventureID, DateTime utcTimestamp)
+    {
+        AdventureDbfRecord record = GameDbf.Adventure.GetRecord((int)adventureID);
+        if (record == null)
+        {
+            return false;
+        }
+		return !EventTimingManager.Get().IsEventActive(record.StandardEvent, utcTimestamp);
+    }
+
+    public static bool IsBoosterRotated(BoosterDbId boosterID, DateTime utcTimestamp)
+    {
+        BoosterDbfRecord record = GameDbf.Booster.GetRecord((int)boosterID);
+        if (record == null)
+        {
+            return false;
+        }
+		return !EventTimingManager.Get().IsEventActive(record.StandardEvent, utcTimestamp);
+    }
 
-	private const int MERCENARIES_SEASON_ID_START = 1;
+	public static bool IsBoosterCatchupPack(BoosterDbId boosterID)
+	{
+		return GameDbf.Booster.GetRecord((int)boosterID)?.IsCatchupPack ?? false;
+	}
 
-	private const int MERCENARIES_SEASON_MONTH_START = 11;
+    public static FormatType GetCardSetFormat(TAG_CARD_SET cardSet)
+    {
+        if (cardSet == TAG_CARD_SET.VANILLA)
+        {
+            return FormatType.FT_CLASSIC;
+        }
+        if (IsSetRotated(cardSet))
+        {
+            return FormatType.FT_WILD;
+        }
+        return FormatType.FT_STANDARD;
+    }
+
+    public static TAG_CARD_SET[] GetCardSetsInFormat(FormatType formatType)
+    {
+        TAG_CARD_SET[] result = null;
+        switch (formatType)
+        {
+            case FormatType.FT_CLASSIC:
+                result = GetClassicSets();
+                break;
+            case FormatType.FT_STANDARD:
+                result = GetStandardSets();
+                break;
+            case FormatType.FT_WILD:
+                result = GetAllWildPlayableSets();
+                break;
+        }
+        return result;
+    }
+
+    public static bool IsCardSetValidForFormat(FormatType formatType, TAG_CARD_SET cardSet)
+    {
+        switch (formatType)
+        {
+            case FormatType.FT_CLASSIC:
+                return IsClassicCardSet(cardSet);
+            case FormatType.FT_WILD:
+                if (!IsWildCardSet(cardSet))
+                {
+                    return IsStandardCardSet(cardSet);
+                }
+                return true;
+            case FormatType.FT_STANDARD:
+                return IsStandardCardSet(cardSet);
+            default:
+                return false;
+        }
+    }
+
+    public static bool IsCardValidForFormat(FormatType formatType, int cardDbId)
+    {
+        EntityDef entityDef = DefLoader.Get().GetEntityDef(cardDbId);
+        return IsCardValidForFormat(formatType, entityDef);
+    }
+
+    public static bool IsCardValidForFormat(FormatType formatType, string cardId)
+    {
+        EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+        return IsCardValidForFormat(formatType, entityDef);
+    }
+
+    public static bool IsCardValidForFormat(FormatType formatType, EntityDef def)
+    {
+        if (def != null)
+        {
+            return IsCardSetValidForFormat(formatType, def.GetCardSet());
+        }
+        return false;
+    }
+
+    public static bool IsWildCardSet(TAG_CARD_SET cardSet)
+    {
+        return GetCardSetFormat(cardSet) == FormatType.FT_WILD;
+    }
+
+    public static bool IsWildCard(int cardDbId)
+    {
+        return IsWildCard(DefLoader.Get().GetEntityDef(cardDbId));
+    }
+
+    public static bool IsWildCard(string cardId)
+    {
+        return IsWildCard(DefLoader.Get().GetEntityDef(cardId));
+    }
+
+    public static bool IsWildCard(EntityDef def)
+    {
+        if (def != null)
+        {
+            return IsWildCardSet(def.GetCardSet());
+        }
+        return false;
+    }
 
-	private const int MERCENARIES_SEASON_YEAR_START = 2021;
+	public static bool IsTwistCard(int cardDbId)
+	{
+		return IsTwistCard(DefLoader.Get().GetEntityDef(cardDbId));
+	}
 
-	public static string TranslateDbIdToCardId(int dbId, bool showWarning = false)
+	public static bool IsTwistCard(string cardId)
 	{
-		CardDbfRecord record = GameDbf.Card.GetRecord(dbId);
-		if (record == null)
-		{
-			if (showWarning)
-			{
-				Log.All.PrintError("GameUtils.TranslateDbIdToCardId() - Failed to find card with database id {0} in the Card DBF.", dbId);
-			}
-			return null;
-		}
-		string noteMiniGuid = record.NoteMiniGuid;
-		if (noteMiniGuid == null)
-		{
-			if (showWarning)
-			{
-				Log.All.PrintError("GameUtils.TranslateDbIdToCardId() - Card with database id {0} has no NOTE_MINI_GUID field in the Card DBF.", dbId);
-			}
-			return null;
-		}
-		return noteMiniGuid;
+		return IsTwistCard(DefLoader.Get().GetEntityDef(cardId));
 	}
 
-	public static int TranslateCardIdToDbId(string cardId, bool showWarning = false)
+	public static bool IsTwistCard(EntityDef def)
 	{
-		CardDbfRecord cardRecord = GetCardRecord(cardId);
-		if (cardRecord == null)
+		TAG_CARD_SET[] twistSets = GetTwistSets();
+		if (def != null)
 		{
-			if (showWarning)
+			for (int i = 0; i < twistSets.Length; i++)
 			{
-				Log.All.PrintError("GameUtils.TranslateCardIdToDbId() - There is no card with NOTE_MINI_GUID {0} in the Card DBF.", cardId);
+				if (def.GetCardSet() == twistSets[i])
+				{
+					return true;
+				}
 			}
-			return 0;
 		}
-		return cardRecord.ID;
+		return false;
 	}
 
-	public static bool IsCardCollectible(string cardId)
+    public static bool IsClassicCardSet(TAG_CARD_SET cardSet)
+    {
+        return GetCardSetFormat(cardSet) == FormatType.FT_CLASSIC;
+    }
+
+    public static bool IsClassicCard(int cardDbId)
+    {
+        return IsClassicCard(DefLoader.Get().GetEntityDef(cardDbId));
+    }
+
+    public static bool IsClassicCard(string cardId)
+    {
+        return IsClassicCard(DefLoader.Get().GetEntityDef(cardId));
+    }
+
+    public static bool IsClassicCard(EntityDef def)
+    {
+        if (def != null)
+        {
+            return IsClassicCardSet(def.GetCardSet());
+        }
+        return false;
+    }
+
+    public static bool IsCoreCard(string cardId)
+    {
+        return IsCoreCard(DefLoader.Get().GetEntityDef(cardId));
+    }
+
+    public static bool IsCoreCard(EntityDef def)
+    {
+        return def?.IsCoreCard() ?? false;
+    }
+
+    public static bool IsStandardCardSet(TAG_CARD_SET cardSet)
+    {
+        return GetCardSetFormat(cardSet) == FormatType.FT_STANDARD;
+    }
+
+    public static bool IsStandardCard(int cardDbId)
+    {
+        return IsStandardCard(DefLoader.Get().GetEntityDef(cardDbId));
+    }
+
+    public static bool IsStandardCard(string cardId)
+    {
+        return IsStandardCard(DefLoader.Get().GetEntityDef(cardId));
+    }
+
+    public static bool IsStandardCard(EntityDef def)
+    {
+        if (def != null)
+        {
+            return IsStandardCardSet(def.GetCardSet());
+        }
+        return false;
+    }
+
+    public static string GetCardSetFormatAsString(TAG_CARD_SET cardSet)
+    {
+        return GetCardSetFormat(cardSet).ToString().Replace("FT_", "");
+    }
+
+    public static bool IsSetRotated(TAG_CARD_SET set)
+    {
+        return IsSetRotated(set, DateTime.UtcNow);
+    }
+
+    public static bool IsSetRotated(TAG_CARD_SET set, DateTime utcTimestamp)
+    {
+        CardSetDbfRecord cardSet = GameDbf.GetIndex().GetCardSet(set);
+        if (cardSet == null)
+        {
+            return false;
+        }
+		EventTimingManager eventTimingManager = EventTimingManager.Get();
+		if (!eventTimingManager.IsEventActive(cardSet.StandardEvent, utcTimestamp))
+        {
+			return eventTimingManager.HasEventStarted(cardSet.StandardEvent);
+        }
+        return false;
+    }
+
+    public static bool IsCardRotated(int cardDbId)
+    {
+        return IsCardRotated(DefLoader.Get().GetEntityDef(cardDbId));
+    }
+
+    public static bool IsCardRotated(string cardId)
+    {
+        return IsCardRotated(DefLoader.Get().GetEntityDef(cardId));
+    }
+
+    public static bool IsCardRotated(EntityDef def)
+    {
+        return IsCardRotated(def, DateTime.UtcNow);
+    }
+
+    public static bool IsCardRotated(EntityDef def, DateTime utcTimestamp)
+    {
+        return IsSetRotated(def.GetCardSet(), utcTimestamp);
+    }
+
+    public static bool IsLegacySet(TAG_CARD_SET set)
+    {
+        return IsLegacySet(set, DateTime.UtcNow);
+    }
+
+    public static bool IsLegacySet(TAG_CARD_SET set, DateTime utcTimestamp)
+    {
+        CardSetDbfRecord cardSet = GameDbf.GetIndex().GetCardSet(set);
+        if (cardSet == null)
+        {
+            return false;
+        }
+		return EventTimingManager.Get().IsEventActive(cardSet.LegacyCardSetEvent, utcTimestamp);
+    }
+
+    public static bool IsBannedByConstructedDenylist(CollectionDeck deck, string designerCardId)
+    {
+        if (!deck.IsConstructedDeck)
+        {
+            return false;
+        }
+        NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+        int item = TranslateCardIdToDbId(designerCardId);
+        return netObject.ConstructedCardDenylist.Contains(item);
+    }
+
+	public static bool IsBannedBySideBoardDenylist(CollectionDeck deck, string designerCardId)
 	{
-		return GetCardTagValue(cardId, GAME_TAG.COLLECTIBLE) == 1;
+		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+		int item = TranslateCardIdToDbId(designerCardId);
+		return netObject.SideboardCardDenylist.Contains(item);
 	}
 
-	public static bool IsCardInBattlegroundsPool(string cardId)
+	public static bool IsBannedByTwistDenylist(CollectionDeck deck, string designerCardId)
 	{
-		if (GetCardTagValue(cardId, GAME_TAG.IS_BACON_POOL_MINION) != 1)
+		if (!deck.IsTwistDeck)
 		{
-			return GetCardTagValue(cardId, GAME_TAG.BACON_HERO_CAN_BE_DRAFTED) == 1;
+			return false;
 		}
-		return true;
+		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+		int item = TranslateCardIdToDbId(designerCardId);
+		return netObject.TwistCardDenylist.Contains(item);
 	}
 
-	public static bool IsAdventureRotated(AdventureDbId adventureID)
+    public static bool IsBannedByDuelsDenylist(CollectionDeck deck, string designerCardId)
+    {
+        if (!deck.IsDuelsDeck)
+        {
+            return false;
+        }
+        NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+        int item = TranslateCardIdToDbId(designerCardId);
+        return netObject.DuelsCardDenylist.Contains(item);
+    }
+
+    public static bool IsBanned(CollectionDeck deck, EntityDef def)
+    {
+        string cardId = def.GetCardId();
+		if (!RankMgr.Get().IsCardBannedInCurrentLeague(def) && !IsBannedByDuelsDenylist(deck, cardId) && !IsBannedByConstructedDenylist(deck, cardId))
+        {
+			return IsBannedByTwistDenylist(deck, cardId);
+        }
+        return true;
+    }
+
+    public static bool IsCardGameplayEventActive(EntityDef def)
+    {
+        return IsCardGameplayEventActive(def.GetCardId());
+    }
+
+    public static bool IsCardGameplayEventActive(string cardId)
+    {
+        CardDbfRecord cardRecord = GetCardRecord(cardId);
+        if (cardRecord == null)
+        {
+            Debug.LogWarning($"GameUtils.IsCardGameplayEventActive could not find DBF record for card {cardId}");
+            return false;
+        }
+		EventTimingType eventTimingType = cardRecord.GameplayEvent;
+		if (eventTimingType == EventTimingType.UNKNOWN)
+        {
+            CardSetDbfRecord cardSetRecord = GetCardSetRecord(cardId);
+            if (cardSetRecord != null)
+            {
+				eventTimingType = cardSetRecord.ContentLaunchEvent;
+            }
+        }
+		return EventTimingManager.Get().IsEventActive(eventTimingType);
+    }
+
+	public static bool IsCardGameplayEventEverActive(EntityDef def)
 	{
-		return IsAdventureRotated(adventureID, DateTime.UtcNow);
+		return IsCardGameplayEventEverActive(def.GetCardId());
 	}
 
-	public static bool IsAdventureRotated(AdventureDbId adventureID, DateTime utcTimestamp)
+	public static bool IsCardGameplayEventEverActive(string cardId)
 	{
-		AdventureDbfRecord record = GameDbf.Adventure.GetRecord((int)adventureID);
-		if (record == null)
+		CardDbfRecord cardRecord = GetCardRecord(cardId);
+		if (cardRecord == null)
 		{
+			Debug.LogWarning($"GameUtils.IsCardGameplayEventActive could not find DBF record for card {cardId}");
 			return false;
 		}
-		return !EventTimingManager.Get().IsEventActive(record.StandardEvent, utcTimestamp);
+		EventTimingType eventTimingType = cardRecord.GameplayEvent;
+		if (eventTimingType == EventTimingType.UNKNOWN)
+		{
+			CardSetDbfRecord cardSetRecord = GetCardSetRecord(cardId);
+			if (cardSetRecord != null)
+			{
+				eventTimingType = cardSetRecord.ContentLaunchEvent;
+			}
+		}
+		return eventTimingType != EventTimingType.SPECIAL_EVENT_NEVER;
 	}
 
-	public static bool IsBoosterRotated(BoosterDbId boosterID, DateTime utcTimestamp)
+	public static bool IsCardBannedInTwist(EntityDef def)
 	{
-		BoosterDbfRecord record = GameDbf.Booster.GetRecord((int)boosterID);
-		if (record == null)
+		if (def == null)
 		{
+			Debug.LogError("Invalid entity used for checking Banned Tag");
 			return false;
 		}
-		return !EventTimingManager.Get().IsEventActive(record.StandardEvent, utcTimestamp);
+		return def.GetTag(3108) > 0;
 	}
 
-	public static bool IsBoosterCatchupPack(BoosterDbId boosterID)
-	{
-		return GameDbf.Booster.GetRecord((int)boosterID)?.IsCatchupPack ?? false;
-	}
+    public static bool IsCardSetFilterEventActive(string cardId)
+    {
+        CardSetDbfRecord cardSetRecord = GetCardSetRecord(cardId);
+        if (cardSetRecord == null)
+        {
+            return false;
+        }
+		return EventTimingManager.Get().IsEventActive(cardSetRecord.SetFilterEvent);
+    }
+
+    public static bool IsCardCraftableWhenWild(string cardId)
+    {
+        EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
+        if (entityDef == null)
+        {
+            return false;
+        }
+        return GameDbf.GetIndex().GetCardSet(entityDef.GetCardSet())?.CraftableWhenWild ?? false;
+    }
+
+    public static bool DeckIncludesRotatedCards(int deckId)
+    {
+        DeckDbfRecord record = GameDbf.Deck.GetRecord(deckId);
+        if (record == null)
+        {
+            Log.Decks.PrintWarning("DeckRuleset.IsDeckWild(): {0} is invalid deck id", deckId);
+            return false;
+        }
+        foreach (DeckCardDbfRecord card in record.Cards)
+        {
+            if (IsCardRotated(card.CardId))
+            {
+                return true;
+            }
+        }
+        return false;
+    }
 
-	public static FormatType GetCardSetFormat(TAG_CARD_SET cardSet)
+	public static bool DeckIncludesTwistCards(int deckId)
 	{
-		if (cardSet == TAG_CARD_SET.VANILLA)
+		DeckDbfRecord record = GameDbf.Deck.GetRecord(deckId);
+		if (record == null)
 		{
-			return FormatType.FT_CLASSIC;
+			Log.Decks.PrintWarning("DeckRuleset.IsDeckTwist(): {0} is invalid deck id", deckId);
+			return false;
 		}
-		if (IsSetRotated(cardSet))
+		foreach (DeckCardDbfRecord card in record.Cards)
 		{
-			return FormatType.FT_WILD;
+			if (!IsTwistCard(card.CardId))
+			{
+				return false;
+			}
 		}
-		return FormatType.FT_STANDARD;
+		return true;
 	}
 
-	public static TAG_CARD_SET[] GetCardSetsInFormat(FormatType formatType)
+    public static TAG_CARD_SET[] GetStandardSets()
+    {
+        List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
+        foreach (TAG_CARD_SET displayableCardSet in CollectionManager.Get().GetDisplayableCardSets())
+        {
+            if (GetCardSetFormat(displayableCardSet) == FormatType.FT_STANDARD)
+            {
+                list.Add(displayableCardSet);
+            }
+        }
+        return list.ToArray();
+    }
+
+    public static TAG_CARD_SET[] GetWildSets()
+    {
+        List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
+        foreach (TAG_CARD_SET displayableCardSet in CollectionManager.Get().GetDisplayableCardSets())
+        {
+            if (GetCardSetFormat(displayableCardSet) == FormatType.FT_WILD)
+            {
+                list.Add(displayableCardSet);
+            }
+        }
+        return list.ToArray();
+    }
+
+    public static TAG_CARD_SET[] GetAllWildPlayableSets()
+    {
+        List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
+        list.AddRange(GetStandardSets());
+        list.AddRange(GetWildSets());
+        return list.ToArray();
+    }
+
+    public static TAG_CARD_SET[] GetLegacySets()
+    {
+        List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
+        foreach (TAG_CARD_SET displayableCardSet in CollectionManager.Get().GetDisplayableCardSets())
+        {
+            if (IsLegacySet(displayableCardSet))
+            {
+                list.Add(displayableCardSet);
+            }
+        }
+        return list.ToArray();
+    }
+
+    public static TAG_CARD_SET[] GetClassicSets()
+    {
+        return (from cardSet in CollectionManager.Get().GetDisplayableCardSets()
+                where IsClassicCardSet(cardSet)
+                select cardSet).ToArray();
+    }
+
+	public static TAG_CARD_SET[] GetTwistSets()
 	{
-		TAG_CARD_SET[] result = null;
-		switch (formatType)
+		DeckRuleset ruleset = DeckRuleset.GetRuleset(FormatType.FT_TWIST);
+		List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
+		if (ruleset != null)
 		{
-		case FormatType.FT_CLASSIC:
-			result = GetClassicSets();
-			break;
-		case FormatType.FT_STANDARD:
-			result = GetStandardSets();
-			break;
-		case FormatType.FT_WILD:
-			result = GetAllWildPlayableSets();
-			break;
+			List<TAG_CARD_SET> displayableCardSets = CollectionManager.Get().GetDisplayableCardSets();
+			foreach (TAG_CARD_SET allowedCardSet in ruleset.GetAllowedCardSets())
+			{
+				if (displayableCardSets.Contains(allowedCardSet))
+				{
+					list.Add(allowedCardSet);
+				}
+			}
 		}
-		return result;
+		return list.ToArray();
 	}
 
-	public static bool IsCardSetValidForFormat(FormatType formatType, TAG_CARD_SET cardSet)
+	public static List<TAG_CARD_SET> GetTwistSetsWithFilter(List<HiddenCardSetsDbfRecord> hiddenTwistSetsRecord)
 	{
-		switch (formatType)
+		TAG_CARD_SET[] twistSets = GetTwistSets();
+		HashSet<TAG_CARD_SET> hashSet = new HashSet<TAG_CARD_SET>();
+		List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
+		if (hiddenTwistSetsRecord != null)
 		{
-		case FormatType.FT_CLASSIC:
-			return IsClassicCardSet(cardSet);
-		case FormatType.FT_WILD:
-			if (!IsWildCardSet(cardSet))
+			for (int i = 0; i < hiddenTwistSetsRecord.Count; i++)
 			{
-				return IsStandardCardSet(cardSet);
+				hashSet.Add((TAG_CARD_SET)hiddenTwistSetsRecord[i].CardSetId);
 			}
-			return true;
-		case FormatType.FT_STANDARD:
-			return IsStandardCardSet(cardSet);
-		default:
-			return false;
 		}
+		for (int j = 0; j < twistSets.Length; j++)
+		{
+			if (!hashSet.Contains(twistSets[j]))
+			{
+				list.Add(twistSets[j]);
+			}
+		}
+		return list;
 	}
 
-	public static bool IsCardValidForFormat(FormatType formatType, int cardDbId)
-	{
-		EntityDef entityDef = DefLoader.Get().GetEntityDef(cardDbId);
-		return IsCardValidForFormat(formatType, entityDef);
-	}
-
-	public static bool IsCardValidForFormat(FormatType formatType, string cardId)
-	{
-		EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
-		return IsCardValidForFormat(formatType, entityDef);
-	}
-
-	public static bool IsCardValidForFormat(FormatType formatType, EntityDef def)
+	public static void FillTwistDataModelWithValidSets(TwistSeasonInfoDataModel dataModel, List<TAG_CARD_SET> validSets)
 	{
-		if (def != null)
+		if (dataModel == null || validSets == null)
 		{
-			return IsCardSetValidForFormat(formatType, def.GetCardSet());
+			return;
+		}
+		int num = 0;
+		while (num < validSets.Count)
+		{
+			ValidSetDataModel validSetDataModel = new ValidSetDataModel();
+			validSetDataModel.SetNameLeft = GameStrings.GetCardSetName(validSets[num]);
+			validSetDataModel.SetIconNameLeft = validSets[num].ToString();
+			num++;
+			if (num < validSets.Count)
+			{
+				validSetDataModel.SetNameRight = GameStrings.GetCardSetName(validSets[num]);
+				validSetDataModel.SetIconNameRight = validSets[num].ToString();
+				num++;
+			}
+			dataModel.TwistValidSets.Add(validSetDataModel);
 		}
-		return false;
 	}
 
-	public static bool IsWildCardSet(TAG_CARD_SET cardSet)
-	{
-		return GetCardSetFormat(cardSet) == FormatType.FT_WILD;
-	}
+    public static TAG_CLASS GetTagClassFromCardId(string cardId)
+    {
+        return DefLoader.Get().GetEntityDef(cardId)?.GetClass() ?? TAG_CLASS.INVALID;
+    }
+
+    public static TAG_CLASS GetTagClassFromCardDbId(int cardDbId)
+    {
+        return (TAG_CLASS)GameDbf.GetIndex().GetCardTagValue(cardDbId, GAME_TAG.CLASS);
+    }
+
+    public static int CountAllCollectibleCards()
+    {
+        return GameDbf.GetIndex().GetCollectibleCardCount();
+    }
+
+    public static List<string> GetAllCardIds()
+    {
+        return GameDbf.GetIndex().GetAllCardIds();
+    }
+
+    public static List<string> GetAllCollectibleCardIds()
+    {
+        return GameDbf.GetIndex().GetCollectibleCardIds();
+    }
+
+    public static List<int> GetAllCollectibleCardDbIds()
+    {
+        return GameDbf.GetIndex().GetCollectibleCardDbIds();
+    }
+
+    public static List<string> GetNonHeroSkinCollectibleCardIds()
+    {
+        List<string> list = new List<string>();
+        foreach (string allCollectibleCardId in GetAllCollectibleCardIds())
+        {
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(allCollectibleCardId);
+            if (entityDef != null && !entityDef.IsHeroSkin())
+            {
+                list.Add(allCollectibleCardId);
+            }
+        }
+        return list;
+    }
+
+    public static List<string> GetNonHeroSkinAllCardIds()
+    {
+        List<string> list = new List<string>();
+        foreach (string allCardId in GetAllCardIds())
+        {
+            EntityDef entityDef = DefLoader.Get().GetEntityDef(allCardId);
+            if (entityDef != null && !entityDef.IsHeroSkin() && entityDef.GetCardType() != TAG_CARDTYPE.ENCHANTMENT)
+            {
+                list.Add(allCardId);
+            }
+        }
+        return list;
+    }
+
+    public static CardDbfRecord GetCardRecord(string cardId)
+    {
+        if (cardId == null)
+        {
+            return null;
+        }
+        return GameDbf.GetIndex().GetCardRecord(cardId);
+    }
+
+    public static CardSetDbfRecord GetCardSetRecord(string cardId)
+    {
+        return GetCardSetRecord(GetCardSetFromCardID(cardId));
+    }
+
+    public static CardSetDbfRecord GetCardSetRecord(TAG_CARD_SET cardSetId)
+    {
+        if (cardSetId == TAG_CARD_SET.INVALID)
+        {
+            return null;
+        }
+        return GameDbf.GetIndex().GetCardSet(cardSetId);
+    }
+
+    public static int GetCardTagValue(string cardId, GAME_TAG tagId)
+    {
+        int cardDbId = TranslateCardIdToDbId(cardId);
+        return GameDbf.GetIndex().GetCardTagValue(cardDbId, tagId);
+    }
+
+    public static int GetCardTagValue(int cardDbId, GAME_TAG tagId)
+    {
+        return GameDbf.GetIndex().GetCardTagValue(cardDbId, tagId);
+    }
 
-	public static bool IsWildCard(int cardDbId)
+	public static List<CounterpartCardsDbfRecord> GetCardCounterpartCards(int cardDbId)
 	{
-		return IsWildCard(DefLoader.Get().GetEntityDef(cardDbId));
+		return GetCardCounterpartCards(TranslateDbIdToCardId(cardDbId));
 	}
 
-	public static bool IsWildCard(string cardId)
+	public static List<CounterpartCardsDbfRecord> GetCardCounterpartCards(string cardId)
 	{
-		return IsWildCard(DefLoader.Get().GetEntityDef(cardId));
+		CardDbfRecord cardRecord = GetCardRecord(cardId);
+		if (cardRecord == null)
+		{
+			Debug.LogWarning($"GameUtils.GetCardCounterpartCards could not find DBF record for card {cardId}");
+			return null;
+		}
+		return cardRecord.CounterpartCards;
 	}
 
-	public static bool IsWildCard(EntityDef def)
-	{
-		if (def != null)
+    public static bool TryGetCardTagRecords(string cardId, out List<CardTagDbfRecord> tagDbfRecords)
+    {
+        int cardDbId = TranslateCardIdToDbId(cardId);
+        return GameDbf.GetIndex().TryGetCardTagRecords(cardDbId, out tagDbfRecords);
+    }
+
+    public static string GetHeroPowerCardIdFromHero(string heroCardId)
+    {
+        int cardTagValue = GetCardTagValue(heroCardId, GAME_TAG.HERO_POWER);
+        if (cardTagValue == 0)
+        {
+            return string.Empty;
+        }
+        return TranslateDbIdToCardId(cardTagValue);
+    }
+
+    public static string GetHeroBuddyCardIdFromHero(string heroCardId)
+    {
+        int cardTagValue = GetCardTagValue(heroCardId, GAME_TAG.BACON_COMPANION_ID);
+        if (cardTagValue == 0)
+        {
+            return string.Empty;
+        }
+        return TranslateDbIdToCardId(cardTagValue);
+    }
+
+    public static string GetHeroPowerCardIdFromHero(int heroDbId)
+    {
+        if (GameDbf.Card.GetRecord(heroDbId) == null)
+        {
+            Debug.LogError($"GameUtils.GetHeroPowerCardIdFromHero() - failed to find record for heroDbId {heroDbId}");
+            return string.Empty;
+        }
+        return TranslateDbIdToCardId(GetCardTagValue(heroDbId, GAME_TAG.HERO_POWER));
+    }
+
+    public static string GetCardIdFromHeroDbId(int heroDbId)
+    {
+        CardHeroDbfRecord record = GameDbf.CardHero.GetRecord(heroDbId);
+        if (record == null)
+        {
+            Debug.LogError($"GameUtils.GetCardIdFromHeroDbId() - failed to find record for heroDbId {heroDbId}");
+            return string.Empty;
+        }
+        return TranslateDbIdToCardId(record.CardId);
+    }
+
+    public static TAG_CARD_SET GetCardSetFromCardID(string cardID)
+    {
+        EntityDef entityDef = DefLoader.Get().GetEntityDef(cardID);
+        if (entityDef == null)
+        {
+            Debug.LogError($"Null EntityDef in GetCardSetFromCardID() for {cardID}");
+            return TAG_CARD_SET.INVALID;
+        }
+        return entityDef.GetCardSet();
+    }
+
+    public static int GetCardIdFromGuestHeroDbId(int guestHeroDbId)
+    {
+        GuestHeroDbfRecord record = GameDbf.GuestHero.GetRecord(guestHeroDbId);
+        if (record == null)
+        {
+            Debug.LogError($"GameUtils.GetCardIdFromGuestHeroDbId() - failed to find record for guestHeroDbId {guestHeroDbId}");
+            return 0;
+        }
+        return record.CardId;
+    }
+
+    public static int GetFavoriteHeroCardDBIdFromClass(TAG_CLASS classTag)
+    {
+        string text = CollectionManager.Get().GetRandomFavoriteHero(classTag)?.Name;
+        if (string.IsNullOrEmpty(text))
+        {
+            text = CollectionManager.GetVanillaHero(classTag);
+        }
+        return TranslateCardIdToDbId(text);
+    }
+
+    public static CardHero.HeroType? GetHeroType(CardRewardData cardRewardData)
+    {
+        return GetHeroType(cardRewardData.CardID);
+    }
+
+    public static CardHero.HeroType? GetHeroType(string cardId)
+    {
+        return GetHeroType(TranslateCardIdToDbId(cardId));
+    }
+
+    public static CardHero.HeroType? GetHeroType(int cardDbId)
+    {
+        return GetHeroType(GameDbf.Card.GetRecord(cardDbId));
+    }
+
+    public static CardHero.HeroType? GetHeroType(CardDbfRecord cardRecord)
+    {
+        return GetHeroType(cardRecord?.CardHero);
+    }
+
+    public static CardHero.HeroType? GetHeroType(CardHeroDbfRecord heroRecord)
+    {
+        return heroRecord?.HeroType;
+    }
+
+    public static bool IsVanillaHero(string cardId)
+    {
+        return IsVanillaHero(TranslateCardIdToDbId(cardId));
+    }
+
+    public static bool IsVanillaHero(int cardDbId)
+    {
+        return IsVanillaHero(GameDbf.Card.GetRecord(cardDbId));
+    }
+
+    public static bool IsVanillaHero(CardDbfRecord cardRecord)
+    {
+        return IsVanillaHero(cardRecord?.CardHero);
+    }
+
+    public static bool IsVanillaHero(CardHeroDbfRecord heroRecord)
+    {
+        return IsVanillaHero(GetHeroType(heroRecord));
+    }
+
+    public static bool IsVanillaHero(CardHero.HeroType? heroType)
+    {
+        return heroType == CardHero.HeroType.VANILLA;
+    }
+
+    public static bool IsBattlegroundsHero(string cardId)
+    {
+        return IsBattlegroundsHero(TranslateCardIdToDbId(cardId));
+    }
+
+    public static bool IsBattlegroundsHero(int cardDbId)
+    {
+        return IsBattlegroundsHero(GameDbf.Card.GetRecord(cardDbId));
+    }
+
+    public static bool IsBattlegroundsHero(CardDbfRecord cardRecord)
+    {
+        return IsBattlegroundsHero(cardRecord?.CardHero);
+    }
+
+    public static bool IsBattlegroundsHero(CardHeroDbfRecord heroRecord)
+    {
+        return IsBattlegroundsHero(GetHeroType(heroRecord));
+    }
+
+    public static bool IsBattlegroundsHero(CardHero.HeroType? heroType)
+    {
+        return heroType == CardHero.HeroType.BATTLEGROUNDS_HERO;
+    }
+
+    public static bool IsBattlegroundsGuide(string cardId)
+    {
+        return IsBattlegroundsGuide(TranslateCardIdToDbId(cardId));
+    }
+
+    public static bool IsBattlegroundsGuide(int cardDbId)
+    {
+        return IsBattlegroundsGuide(GameDbf.Card.GetRecord(cardDbId));
+    }
+
+    public static bool IsBattlegroundsGuide(CardDbfRecord cardRecord)
+    {
+        return IsBattlegroundsGuide(cardRecord?.CardHero);
+    }
+
+    public static bool IsBattlegroundsGuide(CardHeroDbfRecord heroRecord)
+    {
+        return IsBattlegroundsGuide(GetHeroType(heroRecord));
+    }
+
+    public static bool IsBattlegroundsGuide(CardHero.HeroType? heroType)
+    {
+        return heroType == CardHero.HeroType.BATTLEGROUNDS_GUIDE;
+    }
+
+    public static string GetGalakrondCardIdByClass(TAG_CLASS classTag)
+    {
+        string result = "";
+        switch (classTag)
+        {
+            case TAG_CLASS.PRIEST:
+                result = "DRG_660";
+                break;
+            case TAG_CLASS.ROGUE:
+                result = "DRG_610";
+                break;
+            case TAG_CLASS.SHAMAN:
+                result = "DRG_620";
+                break;
+            case TAG_CLASS.WARLOCK:
+                result = "DRG_600";
+                break;
+            case TAG_CLASS.WARRIOR:
+                result = "DRG_650";
+                break;
+        }
+        return result;
+    }
+
+    public static NetCache.HeroLevel GetHeroLevel(TAG_CLASS heroClass)
+    {
+        if (s_cheatMockLevels)
+        {
+            return Cheat_GetHeroLevel(heroClass);
+        }
+
+        NetCache.NetCacheHeroLevels netObject = NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>();
+        if (netObject == null)
+        {
+            Debug.LogWarning("GameUtils.GetHeroLevel() - NetCache.NetCacheHeroLevels is null");
+            return null;
+        }
+        return netObject.Levels.Find((NetCache.HeroLevel obj) => obj.Class == heroClass);
+    }
+
+    public static int? GetTotalHeroLevel()
+    {
+		int? num = null;
+        NetCache.NetCacheHeroLevels netObject = NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>();
+        if (netObject != null)
+        {
+			num = 0;
+                foreach (NetCache.HeroLevel level in netObject.Levels)
+                {
+				num += level.CurrentLevel.Level;
+            }
+        }
+		else
 		{
-			return IsWildCardSet(def.GetCardSet());
+		Debug.LogError("GameUtils.GetTotalHeroLevel() - NetCache.NetCacheHeroLevels is null");
 		}
-		return false;
-	}
+		return num;
+    }
 
-	public static bool IsTwistCard(int cardDbId)
-	{
-		return IsTwistCard(DefLoader.Get().GetEntityDef(cardDbId));
-	}
+    public static bool HasUnlockedClass(TAG_CLASS heroClass)
+    {
+        return GetHeroLevel(heroClass) != null;
+    }
 
-	public static bool IsTwistCard(string cardId)
+	public static bool HasEarnedAllCardsForClass(TAG_CLASS heroClass)
 	{
-		return IsTwistCard(DefLoader.Get().GetEntityDef(cardId));
+		NetCache.HeroLevel heroLevel = GetHeroLevel(heroClass);
+		if (heroLevel == null)
+		{
+			return false;
+		}
+		int nextRewardLevel;
+		return FixedRewardsMgr.Get().GetNextHeroLevelReward(heroClass, heroLevel.CurrentLevel.Level, out nextRewardLevel) == null;
 	}
 
-	public static bool IsTwistCard(EntityDef def)
+	public static bool HasEarnedAllVanillaClassCards()
 	{
-		TAG_CARD_SET[] twistSets = GetTwistSets();
-		if (def != null)
+		TAG_CLASS[] dEFAULT_HERO_CLASSES = DEFAULT_HERO_CLASSES;
+		for (int i = 0; i < dEFAULT_HERO_CLASSES.Length; i++)
 		{
-			for (int i = 0; i < twistSets.Length; i++)
-			{
-				if (def.GetCardSet() == twistSets[i])
-				{
-					return true;
-				}
-			}
-		}
-		return false;
-	}
-
-	public static bool IsClassicCardSet(TAG_CARD_SET cardSet)
-	{
-		return GetCardSetFormat(cardSet) == FormatType.FT_CLASSIC;
-	}
-
-	public static bool IsClassicCard(int cardDbId)
-	{
-		return IsClassicCard(DefLoader.Get().GetEntityDef(cardDbId));
-	}
-
-	public static bool IsClassicCard(string cardId)
-	{
-		return IsClassicCard(DefLoader.Get().GetEntityDef(cardId));
-	}
-
-	public static bool IsClassicCard(EntityDef def)
-	{
-		if (def != null)
-		{
-			return IsClassicCardSet(def.GetCardSet());
-		}
-		return false;
-	}
-
-	public static bool IsCoreCard(string cardId)
-	{
-		return IsCoreCard(DefLoader.Get().GetEntityDef(cardId));
-	}
-
-	public static bool IsCoreCard(EntityDef def)
-	{
-		return def?.IsCoreCard() ?? false;
-	}
-
-	public static bool IsStandardCardSet(TAG_CARD_SET cardSet)
-	{
-		return GetCardSetFormat(cardSet) == FormatType.FT_STANDARD;
-	}
-
-	public static bool IsStandardCard(int cardDbId)
-	{
-		return IsStandardCard(DefLoader.Get().GetEntityDef(cardDbId));
-	}
-
-	public static bool IsStandardCard(string cardId)
-	{
-		return IsStandardCard(DefLoader.Get().GetEntityDef(cardId));
-	}
-
-	public static bool IsStandardCard(EntityDef def)
-	{
-		if (def != null)
-		{
-			return IsStandardCardSet(def.GetCardSet());
-		}
-		return false;
-	}
-
-	public static string GetCardSetFormatAsString(TAG_CARD_SET cardSet)
-	{
-		return GetCardSetFormat(cardSet).ToString().Replace("FT_", "");
-	}
-
-	public static bool IsSetRotated(TAG_CARD_SET set)
-	{
-		return IsSetRotated(set, DateTime.UtcNow);
-	}
-
-	public static bool IsSetRotated(TAG_CARD_SET set, DateTime utcTimestamp)
-	{
-		CardSetDbfRecord cardSet = GameDbf.GetIndex().GetCardSet(set);
-		if (cardSet == null)
-		{
-			return false;
-		}
-		EventTimingManager eventTimingManager = EventTimingManager.Get();
-		if (!eventTimingManager.IsEventActive(cardSet.StandardEvent, utcTimestamp))
-		{
-			return eventTimingManager.HasEventStarted(cardSet.StandardEvent);
-		}
-		return false;
-	}
-
-	public static bool IsCardRotated(int cardDbId)
-	{
-		return IsCardRotated(DefLoader.Get().GetEntityDef(cardDbId));
-	}
-
-	public static bool IsCardRotated(string cardId)
-	{
-		return IsCardRotated(DefLoader.Get().GetEntityDef(cardId));
-	}
-
-	public static bool IsCardRotated(EntityDef def)
-	{
-		return IsCardRotated(def, DateTime.UtcNow);
-	}
-
-	public static bool IsCardRotated(EntityDef def, DateTime utcTimestamp)
-	{
-		return IsSetRotated(def.GetCardSet(), utcTimestamp);
-	}
-
-	public static bool IsLegacySet(TAG_CARD_SET set)
-	{
-		return IsLegacySet(set, DateTime.UtcNow);
-	}
-
-	public static bool IsLegacySet(TAG_CARD_SET set, DateTime utcTimestamp)
-	{
-		CardSetDbfRecord cardSet = GameDbf.GetIndex().GetCardSet(set);
-		if (cardSet == null)
-		{
-			return false;
-		}
-		return EventTimingManager.Get().IsEventActive(cardSet.LegacyCardSetEvent, utcTimestamp);
-	}
-
-	public static bool IsBannedByConstructedDenylist(CollectionDeck deck, string designerCardId)
-	{
-		if (!deck.IsConstructedDeck)
-		{
-			return false;
-		}
-		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-		int item = TranslateCardIdToDbId(designerCardId);
-		return netObject.ConstructedCardDenylist.Contains(item);
-	}
-
-	public static bool IsBannedBySideBoardDenylist(CollectionDeck deck, string designerCardId)
-	{
-		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-		int item = TranslateCardIdToDbId(designerCardId);
-		return netObject.SideboardCardDenylist.Contains(item);
-	}
-
-	public static bool IsBannedByTwistDenylist(CollectionDeck deck, string designerCardId)
-	{
-		if (!deck.IsTwistDeck)
-		{
-			return false;
-		}
-		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-		int item = TranslateCardIdToDbId(designerCardId);
-		return netObject.TwistCardDenylist.Contains(item);
-	}
-
-	public static bool IsBannedByDuelsDenylist(CollectionDeck deck, string designerCardId)
-	{
-		if (!deck.IsDuelsDeck)
-		{
-			return false;
-		}
-		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-		int item = TranslateCardIdToDbId(designerCardId);
-		return netObject.DuelsCardDenylist.Contains(item);
-	}
-
-	public static bool IsBanned(CollectionDeck deck, EntityDef def)
-	{
-		string cardId = def.GetCardId();
-		if (!RankMgr.Get().IsCardBannedInCurrentLeague(def) && !IsBannedByDuelsDenylist(deck, cardId) && !IsBannedByConstructedDenylist(deck, cardId))
-		{
-			return IsBannedByTwistDenylist(deck, cardId);
-		}
-		return true;
-	}
-
-	public static bool IsCardGameplayEventActive(EntityDef def)
-	{
-		return IsCardGameplayEventActive(def.GetCardId());
-	}
-
-	public static bool IsCardGameplayEventActive(string cardId)
-	{
-		CardDbfRecord cardRecord = GetCardRecord(cardId);
-		if (cardRecord == null)
-		{
-			Debug.LogWarning($"GameUtils.IsCardGameplayEventActive could not find DBF record for card {cardId}");
-			return false;
-		}
-		EventTimingType eventTimingType = cardRecord.GameplayEvent;
-		if (eventTimingType == EventTimingType.UNKNOWN)
-		{
-			CardSetDbfRecord cardSetRecord = GetCardSetRecord(cardId);
-			if (cardSetRecord != null)
-			{
-				eventTimingType = cardSetRecord.ContentLaunchEvent;
-			}
-		}
-		return EventTimingManager.Get().IsEventActive(eventTimingType);
-	}
-
-	public static bool IsCardGameplayEventEverActive(EntityDef def)
-	{
-		return IsCardGameplayEventEverActive(def.GetCardId());
-	}
-
-	public static bool IsCardGameplayEventEverActive(string cardId)
-	{
-		CardDbfRecord cardRecord = GetCardRecord(cardId);
-		if (cardRecord == null)
-		{
-			Debug.LogWarning($"GameUtils.IsCardGameplayEventActive could not find DBF record for card {cardId}");
-			return false;
-		}
-		EventTimingType eventTimingType = cardRecord.GameplayEvent;
-		if (eventTimingType == EventTimingType.UNKNOWN)
-		{
-			CardSetDbfRecord cardSetRecord = GetCardSetRecord(cardId);
-			if (cardSetRecord != null)
-			{
-				eventTimingType = cardSetRecord.ContentLaunchEvent;
-			}
-		}
-		return eventTimingType != EventTimingType.SPECIAL_EVENT_NEVER;
-	}
-
-	public static bool IsCardBannedInTwist(EntityDef def)
-	{
-		if (def == null)
-		{
-			Debug.LogError("Invalid entity used for checking Banned Tag");
-			return false;
-		}
-		return def.GetTag(3108) > 0;
-	}
-
-	public static bool IsCardSetFilterEventActive(string cardId)
-	{
-		CardSetDbfRecord cardSetRecord = GetCardSetRecord(cardId);
-		if (cardSetRecord == null)
-		{
-			return false;
-		}
-		return EventTimingManager.Get().IsEventActive(cardSetRecord.SetFilterEvent);
-	}
-
-	public static bool IsCardCraftableWhenWild(string cardId)
-	{
-		EntityDef entityDef = DefLoader.Get().GetEntityDef(cardId);
-		if (entityDef == null)
-		{
-			return false;
-		}
-		return GameDbf.GetIndex().GetCardSet(entityDef.GetCardSet())?.CraftableWhenWild ?? false;
-	}
-
-	public static bool DeckIncludesRotatedCards(int deckId)
-	{
-		DeckDbfRecord record = GameDbf.Deck.GetRecord(deckId);
-		if (record == null)
-		{
-			Log.Decks.PrintWarning("DeckRuleset.IsDeckWild(): {0} is invalid deck id", deckId);
-			return false;
-		}
-		foreach (DeckCardDbfRecord card in record.Cards)
-		{
-			if (IsCardRotated(card.CardId))
-			{
-				return true;
-			}
-		}
-		return false;
-	}
-
-	public static bool DeckIncludesTwistCards(int deckId)
-	{
-		DeckDbfRecord record = GameDbf.Deck.GetRecord(deckId);
-		if (record == null)
-		{
-			Log.Decks.PrintWarning("DeckRuleset.IsDeckTwist(): {0} is invalid deck id", deckId);
-			return false;
-		}
-		foreach (DeckCardDbfRecord card in record.Cards)
-		{
-			if (!IsTwistCard(card.CardId))
-			{
-				return false;
-			}
-		}
-		return true;
-	}
-
-	public static TAG_CARD_SET[] GetStandardSets()
-	{
-		List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
-		foreach (TAG_CARD_SET displayableCardSet in CollectionManager.Get().GetDisplayableCardSets())
-		{
-			if (GetCardSetFormat(displayableCardSet) == FormatType.FT_STANDARD)
-			{
-				list.Add(displayableCardSet);
-			}
-		}
-		return list.ToArray();
-	}
-
-	public static TAG_CARD_SET[] GetWildSets()
-	{
-		List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
-		foreach (TAG_CARD_SET displayableCardSet in CollectionManager.Get().GetDisplayableCardSets())
-		{
-			if (GetCardSetFormat(displayableCardSet) == FormatType.FT_WILD)
-			{
-				list.Add(displayableCardSet);
-			}
-		}
-		return list.ToArray();
-	}
-
-	public static TAG_CARD_SET[] GetAllWildPlayableSets()
-	{
-		List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
-		list.AddRange(GetStandardSets());
-		list.AddRange(GetWildSets());
-		return list.ToArray();
-	}
-
-	public static TAG_CARD_SET[] GetLegacySets()
-	{
-		List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
-		foreach (TAG_CARD_SET displayableCardSet in CollectionManager.Get().GetDisplayableCardSets())
-		{
-			if (IsLegacySet(displayableCardSet))
-			{
-				list.Add(displayableCardSet);
-			}
-		}
-		return list.ToArray();
-	}
-
-	public static TAG_CARD_SET[] GetClassicSets()
-	{
-		return (from cardSet in CollectionManager.Get().GetDisplayableCardSets()
-			where IsClassicCardSet(cardSet)
-			select cardSet).ToArray();
-	}
-
-	public static TAG_CARD_SET[] GetTwistSets()
-	{
-		DeckRuleset ruleset = DeckRuleset.GetRuleset(FormatType.FT_TWIST);
-		List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
-		if (ruleset != null)
-		{
-			List<TAG_CARD_SET> displayableCardSets = CollectionManager.Get().GetDisplayableCardSets();
-			foreach (TAG_CARD_SET allowedCardSet in ruleset.GetAllowedCardSets())
-			{
-				if (displayableCardSets.Contains(allowedCardSet))
-				{
-					list.Add(allowedCardSet);
-				}
-			}
-		}
-		return list.ToArray();
-	}
-
-	public static List<TAG_CARD_SET> GetTwistSetsWithFilter(List<HiddenCardSetsDbfRecord> hiddenTwistSetsRecord)
-	{
-		TAG_CARD_SET[] twistSets = GetTwistSets();
-		HashSet<TAG_CARD_SET> hashSet = new HashSet<TAG_CARD_SET>();
-		List<TAG_CARD_SET> list = new List<TAG_CARD_SET>();
-		if (hiddenTwistSetsRecord != null)
-		{
-			for (int i = 0; i < hiddenTwistSetsRecord.Count; i++)
-			{
-				hashSet.Add((TAG_CARD_SET)hiddenTwistSetsRecord[i].CardSetId);
-			}
-		}
-		for (int j = 0; j < twistSets.Length; j++)
-		{
-			if (!hashSet.Contains(twistSets[j]))
-			{
-				list.Add(twistSets[j]);
-			}
-		}
-		return list;
-	}
-
-	public static void FillTwistDataModelWithValidSets(TwistSeasonInfoDataModel dataModel, List<TAG_CARD_SET> validSets)
-	{
-		if (dataModel == null || validSets == null)
-		{
-			return;
-		}
-		int num = 0;
-		while (num < validSets.Count)
-		{
-			ValidSetDataModel validSetDataModel = new ValidSetDataModel();
-			validSetDataModel.SetNameLeft = GameStrings.GetCardSetName(validSets[num]);
-			validSetDataModel.SetIconNameLeft = validSets[num].ToString();
-			num++;
-			if (num < validSets.Count)
-			{
-				validSetDataModel.SetNameRight = GameStrings.GetCardSetName(validSets[num]);
-				validSetDataModel.SetIconNameRight = validSets[num].ToString();
-				num++;
-			}
-			dataModel.TwistValidSets.Add(validSetDataModel);
-		}
-	}
-
-	public static TAG_CLASS GetTagClassFromCardId(string cardId)
-	{
-		return DefLoader.Get().GetEntityDef(cardId)?.GetClass() ?? TAG_CLASS.INVALID;
-	}
-
-	public static TAG_CLASS GetTagClassFromCardDbId(int cardDbId)
-	{
-		return (TAG_CLASS)GameDbf.GetIndex().GetCardTagValue(cardDbId, GAME_TAG.CLASS);
-	}
-
-	public static int CountAllCollectibleCards()
-	{
-		return GameDbf.GetIndex().GetCollectibleCardCount();
-	}
-
-	public static List<string> GetAllCardIds()
-	{
-		return GameDbf.GetIndex().GetAllCardIds();
-	}
-
-	public static List<string> GetAllCollectibleCardIds()
-	{
-		return GameDbf.GetIndex().GetCollectibleCardIds();
-	}
-
-	public static List<int> GetAllCollectibleCardDbIds()
-	{
-		return GameDbf.GetIndex().GetCollectibleCardDbIds();
-	}
-
-	public static List<string> GetNonHeroSkinCollectibleCardIds()
-	{
-		List<string> list = new List<string>();
-		foreach (string allCollectibleCardId in GetAllCollectibleCardIds())
-		{
-			EntityDef entityDef = DefLoader.Get().GetEntityDef(allCollectibleCardId);
-			if (entityDef != null && !entityDef.IsHeroSkin())
-			{
-				list.Add(allCollectibleCardId);
-			}
-		}
-		return list;
-	}
-
-	public static List<string> GetNonHeroSkinAllCardIds()
-	{
-		List<string> list = new List<string>();
-		foreach (string allCardId in GetAllCardIds())
-		{
-			EntityDef entityDef = DefLoader.Get().GetEntityDef(allCardId);
-			if (entityDef != null && !entityDef.IsHeroSkin() && entityDef.GetCardType() != TAG_CARDTYPE.ENCHANTMENT)
-			{
-				list.Add(allCardId);
-			}
-		}
-		return list;
-	}
-
-	public static CardDbfRecord GetCardRecord(string cardId)
-	{
-		if (cardId == null)
-		{
-			return null;
-		}
-		return GameDbf.GetIndex().GetCardRecord(cardId);
-	}
-
-	public static CardSetDbfRecord GetCardSetRecord(string cardId)
-	{
-		return GetCardSetRecord(GetCardSetFromCardID(cardId));
-	}
-
-	public static CardSetDbfRecord GetCardSetRecord(TAG_CARD_SET cardSetId)
-	{
-		if (cardSetId == TAG_CARD_SET.INVALID)
-		{
-			return null;
-		}
-		return GameDbf.GetIndex().GetCardSet(cardSetId);
-	}
-
-	public static int GetCardTagValue(string cardId, GAME_TAG tagId)
-	{
-		int cardDbId = TranslateCardIdToDbId(cardId);
-		return GameDbf.GetIndex().GetCardTagValue(cardDbId, tagId);
-	}
-
-	public static int GetCardTagValue(int cardDbId, GAME_TAG tagId)
-	{
-		return GameDbf.GetIndex().GetCardTagValue(cardDbId, tagId);
-	}
-
-	public static List<CounterpartCardsDbfRecord> GetCardCounterpartCards(int cardDbId)
-	{
-		return GetCardCounterpartCards(TranslateDbIdToCardId(cardDbId));
-	}
-
-	public static List<CounterpartCardsDbfRecord> GetCardCounterpartCards(string cardId)
-	{
-		CardDbfRecord cardRecord = GetCardRecord(cardId);
-		if (cardRecord == null)
-		{
-			Debug.LogWarning($"GameUtils.GetCardCounterpartCards could not find DBF record for card {cardId}");
-			return null;
-		}
-		return cardRecord.CounterpartCards;
-	}
-
-	public static bool TryGetCardTagRecords(string cardId, out List<CardTagDbfRecord> tagDbfRecords)
-	{
-		int cardDbId = TranslateCardIdToDbId(cardId);
-		return GameDbf.GetIndex().TryGetCardTagRecords(cardDbId, out tagDbfRecords);
-	}
-
-	public static string GetHeroPowerCardIdFromHero(string heroCardId)
-	{
-		int cardTagValue = GetCardTagValue(heroCardId, GAME_TAG.HERO_POWER);
-		if (cardTagValue == 0)
-		{
-			return string.Empty;
-		}
-		return TranslateDbIdToCardId(cardTagValue);
-	}
-
-	public static string GetHeroPowerCardIdFromHero(int heroDbId)
-	{
-		if (GameDbf.Card.GetRecord(heroDbId) == null)
-		{
-			Debug.LogError($"GameUtils.GetHeroPowerCardIdFromHero() - failed to find record for heroDbId {heroDbId}");
-			return string.Empty;
-		}
-		return TranslateDbIdToCardId(GetCardTagValue(heroDbId, GAME_TAG.HERO_POWER));
-	}
-
-	public static string GetCardIdFromHeroDbId(int heroDbId)
-	{
-		CardHeroDbfRecord record = GameDbf.CardHero.GetRecord(heroDbId);
-		if (record == null)
-		{
-			Debug.LogError($"GameUtils.GetCardIdFromHeroDbId() - failed to find record for heroDbId {heroDbId}");
-			return string.Empty;
-		}
-		return TranslateDbIdToCardId(record.CardId);
-	}
-
-	public static TAG_CARD_SET GetCardSetFromCardID(string cardID)
-	{
-		EntityDef entityDef = DefLoader.Get().GetEntityDef(cardID);
-		if (entityDef == null)
-		{
-			Debug.LogError($"Null EntityDef in GetCardSetFromCardID() for {cardID}");
-			return TAG_CARD_SET.INVALID;
-		}
-		return entityDef.GetCardSet();
-	}
-
-	public static int GetCardIdFromGuestHeroDbId(int guestHeroDbId)
-	{
-		GuestHeroDbfRecord record = GameDbf.GuestHero.GetRecord(guestHeroDbId);
-		if (record == null)
-		{
-			Debug.LogError($"GameUtils.GetCardIdFromGuestHeroDbId() - failed to find record for guestHeroDbId {guestHeroDbId}");
-			return 0;
-		}
-		return record.CardId;
-	}
-
-	public static int GetFavoriteHeroCardDBIdFromClass(TAG_CLASS classTag)
-	{
-		string text = CollectionManager.Get().GetRandomFavoriteHero(classTag)?.Name;
-		if (string.IsNullOrEmpty(text))
-		{
-			text = CollectionManager.GetVanillaHero(classTag);
-		}
-		return TranslateCardIdToDbId(text);
-	}
-
-	public static CardHero.HeroType? GetHeroType(CardRewardData cardRewardData)
-	{
-		return GetHeroType(cardRewardData.CardID);
-	}
-
-	public static CardHero.HeroType? GetHeroType(string cardId)
-	{
-		return GetHeroType(TranslateCardIdToDbId(cardId));
-	}
-
-	public static CardHero.HeroType? GetHeroType(int cardDbId)
-	{
-		return GetHeroType(GameDbf.Card.GetRecord(cardDbId));
-	}
-
-	public static CardHero.HeroType? GetHeroType(CardDbfRecord cardRecord)
-	{
-		return GetHeroType(cardRecord?.CardHero);
-	}
-
-	public static CardHero.HeroType? GetHeroType(CardHeroDbfRecord heroRecord)
-	{
-		return heroRecord?.HeroType;
-	}
-
-	public static bool IsVanillaHero(string cardId)
-	{
-		return IsVanillaHero(TranslateCardIdToDbId(cardId));
-	}
-
-	public static bool IsVanillaHero(int cardDbId)
-	{
-		return IsVanillaHero(GameDbf.Card.GetRecord(cardDbId));
-	}
-
-	public static bool IsVanillaHero(CardDbfRecord cardRecord)
-	{
-		return IsVanillaHero(cardRecord?.CardHero);
-	}
-
-	public static bool IsVanillaHero(CardHeroDbfRecord heroRecord)
-	{
-		return IsVanillaHero(GetHeroType(heroRecord));
-	}
-
-	public static bool IsVanillaHero(CardHero.HeroType? heroType)
-	{
-		return heroType == CardHero.HeroType.VANILLA;
-	}
-
-	public static bool IsBattlegroundsHero(string cardId)
-	{
-		return IsBattlegroundsHero(TranslateCardIdToDbId(cardId));
-	}
-
-	public static bool IsBattlegroundsHero(int cardDbId)
-	{
-		return IsBattlegroundsHero(GameDbf.Card.GetRecord(cardDbId));
-	}
-
-	public static bool IsBattlegroundsHero(CardDbfRecord cardRecord)
-	{
-		return IsBattlegroundsHero(cardRecord?.CardHero);
-	}
-
-	public static bool IsBattlegroundsHero(CardHeroDbfRecord heroRecord)
-	{
-		return IsBattlegroundsHero(GetHeroType(heroRecord));
-	}
-
-	public static bool IsBattlegroundsHero(CardHero.HeroType? heroType)
-	{
-		return heroType == CardHero.HeroType.BATTLEGROUNDS_HERO;
-	}
-
-	public static bool IsBattlegroundsGuide(string cardId)
-	{
-		return IsBattlegroundsGuide(TranslateCardIdToDbId(cardId));
-	}
-
-	public static bool IsBattlegroundsGuide(int cardDbId)
-	{
-		return IsBattlegroundsGuide(GameDbf.Card.GetRecord(cardDbId));
-	}
-
-	public static bool IsBattlegroundsGuide(CardDbfRecord cardRecord)
-	{
-		return IsBattlegroundsGuide(cardRecord?.CardHero);
-	}
-
-	public static bool IsBattlegroundsGuide(CardHeroDbfRecord heroRecord)
-	{
-		return IsBattlegroundsGuide(GetHeroType(heroRecord));
-	}
-
-	public static bool IsBattlegroundsGuide(CardHero.HeroType? heroType)
-	{
-		return heroType == CardHero.HeroType.BATTLEGROUNDS_GUIDE;
-	}
-
-	public static string GetGalakrondCardIdByClass(TAG_CLASS classTag)
-	{
-		string result = "";
-		switch (classTag)
-		{
-		case TAG_CLASS.PRIEST:
-			result = "DRG_660";
-			break;
-		case TAG_CLASS.ROGUE:
-			result = "DRG_610";
-			break;
-		case TAG_CLASS.SHAMAN:
-			result = "DRG_620";
-			break;
-		case TAG_CLASS.WARLOCK:
-			result = "DRG_600";
-			break;
-		case TAG_CLASS.WARRIOR:
-			result = "DRG_650";
-			break;
-		}
-		return result;
-	}
-
-	public static NetCache.HeroLevel GetHeroLevel(TAG_CLASS heroClass)
-	{
-		NetCache.NetCacheHeroLevels netObject = NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>();
-		if (netObject == null)
-		{
-			Debug.LogWarning("GameUtils.GetHeroLevel() - NetCache.NetCacheHeroLevels is null");
-			return null;
-		}
-		return netObject.Levels.Find((NetCache.HeroLevel obj) => obj.Class == heroClass);
-	}
-
-	public static int? GetTotalHeroLevel()
-	{
-		int? num = null;
-		NetCache.NetCacheHeroLevels netObject = NetCache.Get().GetNetObject<NetCache.NetCacheHeroLevels>();
-		if (netObject != null)
-		{
-			num = 0;
-			foreach (NetCache.HeroLevel level in netObject.Levels)
-			{
-				num += level.CurrentLevel.Level;
-			}
-		}
-		else
-		{
-			Debug.LogError("GameUtils.GetTotalHeroLevel() - NetCache.NetCacheHeroLevels is null");
-		}
-		return num;
-	}
-
-	public static bool HasUnlockedClass(TAG_CLASS heroClass)
-	{
-		return GetHeroLevel(heroClass) != null;
-	}
-
-	public static bool HasEarnedAllCardsForClass(TAG_CLASS heroClass)
-	{
-		NetCache.HeroLevel heroLevel = GetHeroLevel(heroClass);
-		if (heroLevel == null)
-		{
-			return false;
-		}
-		int nextRewardLevel;
-		return FixedRewardsMgr.Get().GetNextHeroLevelReward(heroClass, heroLevel.CurrentLevel.Level, out nextRewardLevel) == null;
-	}
-
-	public static bool HasEarnedAllVanillaClassCards()
-	{
-		TAG_CLASS[] dEFAULT_HERO_CLASSES = DEFAULT_HERO_CLASSES;
-		for (int i = 0; i < dEFAULT_HERO_CLASSES.Length; i++)
-		{
-			if (!HasEarnedAllCardsForClass(dEFAULT_HERO_CLASSES[i]))
-			{
-				return false;
-			}
-		}
-		return true;
-	}
-
-	public static int CardPremiumSortComparisonAsc(TAG_PREMIUM premium1, TAG_PREMIUM premium2)
-	{
-		return premium1 - premium2;
-	}
-
-	public static int CardPremiumSortComparisonDesc(TAG_PREMIUM premium1, TAG_PREMIUM premium2)
-	{
-		return premium2 - premium1;
-	}
-
-	public static bool CanConcedeCurrentMission()
-	{
-		if (GameState.Get() == null)
-		{
-			return false;
-		}
-		if (GameMgr.Get().IsTraditionalTutorial())
-		{
-			if (NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().SkippableTutorialEnabled)
-			{
-				if (!(GameState.Get().GetGameEntity() is TutorialEntity tutorialEntity))
-				{
-					return false;
-				}
-				return tutorialEntity.IsCustomIntroFinished();
-			}
-			return false;
-		}
-		if (GameMgr.Get().IsSpectator())
-		{
-			return false;
-		}
-		if (GameMgr.Get().IsLettuceTutorial())
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public static bool CanRestartCurrentMission(bool checkTutorial = true)
-	{
-		if (GameState.Get() == null)
-		{
-			return false;
-		}
-		if (GameState.Get().GetBooleanGameOption(GameEntityOption.DISABLE_RESTART_BUTTON))
-		{
-			return false;
-		}
-		if (checkTutorial && GameMgr.Get().IsTraditionalTutorial())
-		{
-			return false;
-		}
-		if (GameMgr.Get().IsSpectator())
-		{
-			return false;
-		}
-		if (!GameMgr.Get().IsAI())
-		{
-			return false;
-		}
-		if (!GameMgr.Get().HasLastPlayedDeckId())
-		{
-			return false;
-		}
-		if (!BattleNet.IsConnected())
-		{
-			return false;
-		}
-		if (DemoMgr.Get().IsDemo() && !DemoMgr.Get().CanRestartMissions())
-		{
-			return false;
-		}
-		if (GameMgr.Get().IsDungeonCrawlMission())
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public static bool IsWaitingForOpponentReconnect()
-	{
-		if (GameState.Get() == null)
-		{
-			return false;
-		}
-		return GameState.Get().GetGameEntity().HasTag(GAME_TAG.WAIT_FOR_PLAYER_RECONNECT_PERIOD);
-	}
-
-	public static Card GetJoustWinner(Network.HistMetaData metaData)
-	{
-		if (metaData == null)
-		{
-			return null;
-		}
-		if (metaData.MetaType != HistoryMeta.Type.JOUST)
-		{
-			return null;
-		}
-		return GameState.Get().GetEntity(metaData.Data)?.GetCard();
-	}
-
-	public static bool IsHistoryDeathTagChange(Network.HistTagChange tagChange)
-	{
-		Entity entity = GameState.Get().GetEntity(tagChange.Entity);
-		if (entity == null)
-		{
-			return false;
-		}
-		if (entity.IsEnchantment())
-		{
-			return false;
-		}
-		if (entity.GetCardType() == TAG_CARDTYPE.INVALID)
-		{
-			return false;
-		}
-		if (tagChange.Tag == 360 && tagChange.Value == 1)
-		{
-			return true;
-		}
-		if (entity.IsMinion() && tagChange.Tag == 49 && tagChange.Value == 4 && entity.GetZone() == TAG_ZONE.PLAY)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static bool IsHistoryDiscardTagChange(Network.HistTagChange tagChange)
-	{
-		if (tagChange.Tag != 49)
-		{
-			return false;
-		}
-		if (GameState.Get().GetEntity(tagChange.Entity).GetZone() != TAG_ZONE.HAND)
-		{
-			return false;
-		}
-		if (tagChange.Value != 4)
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public static bool IsHistoryMovedToSetAsideTagChange(Network.HistTagChange tagChange)
-	{
-		if (tagChange.Tag != 49)
-		{
-			return false;
-		}
-		if (tagChange.Value != 6)
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public static bool IsEntityDeathTagChange(Network.HistTagChange tagChange)
-	{
-		if (tagChange.Tag != 49)
-		{
-			return false;
-		}
-		if (tagChange.Value != 4)
-		{
-			return false;
-		}
-		if (GameState.Get().GetEntity(tagChange.Entity) == null)
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public static bool IsCharacterDeathTagChange(Network.HistTagChange tagChange)
-	{
-		if (tagChange.Tag != 49)
-		{
-			return false;
-		}
-		if (tagChange.Value != 4)
-		{
-			return false;
-		}
-		Entity entity = GameState.Get().GetEntity(tagChange.Entity);
-		if (entity == null)
-		{
-			return false;
-		}
-		if (!entity.IsCharacter())
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public static bool IsPreGameOverPlayState(TAG_PLAYSTATE playState)
-	{
-		if ((uint)(playState - 2) <= 1u || (uint)(playState - 7) <= 1u)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static bool IsGameOverTag(int entityId, int tag, int val)
-	{
-		return IsGameOverTag(GameState.Get().GetEntity(entityId) as Player, tag, val);
-	}
-
-	public static bool IsGameOverTag(Player player, int tag, int val)
-	{
-		if (player == null)
-		{
-			return false;
-		}
-		if (tag != 17)
-		{
-			return false;
-		}
-		if (!player.IsFriendlySide() || !player.IsTeamLeader())
-		{
-			return false;
-		}
-		if ((uint)(val - 4) <= 2u)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static bool IsFriendlyConcede(Network.HistTagChange tagChange)
-	{
-		if (tagChange.Tag != 17)
-		{
-			return false;
-		}
-		if (!(GameState.Get().GetEntity(tagChange.Entity) is Player player))
-		{
-			return false;
-		}
-		if (!player.IsFriendlySide())
-		{
-			return false;
-		}
-		return tagChange.Value == 8;
-	}
-
-	public static bool IsBeginPhase(TAG_STEP step)
-	{
-		if ((uint)step <= 4u)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static bool IsPastBeginPhase(TAG_STEP step)
-	{
-		return !IsBeginPhase(step);
-	}
-
-	public static bool IsMainPhase(TAG_STEP step)
-	{
-		if ((uint)(step - 5) <= 8u || (uint)(step - 16) <= 4u)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static List<Entity> GetEntitiesKilledBySourceAmongstTargets(int damageSourceID, List<Entity> targetEntities)
-	{
-		List<Entity> list = new List<Entity>();
-		foreach (Entity targetEntity in targetEntities)
-		{
-			if (targetEntity != null)
-			{
-				list.Add(targetEntity.CloneForZoneMgr());
-			}
-		}
-		List<Entity> list2 = new List<Entity>();
-		PowerProcessor powerProcessor = GameState.Get().GetPowerProcessor();
-		List<PowerTaskList> list3 = new List<PowerTaskList>();
-		if (powerProcessor.GetCurrentTaskList() != null)
-		{
-			list3.Add(powerProcessor.GetCurrentTaskList());
-		}
-		list3.AddRange(powerProcessor.GetPowerQueue().GetList());
-		for (int i = 0; i < list3.Count; i++)
-		{
-			List<PowerTask> taskList = list3[i].GetTaskList();
-			for (int j = 0; j < taskList.Count; j++)
-			{
-				PowerTask powerTask = taskList[j];
-				Network.HistTagChange tagChange = powerTask.GetPower() as Network.HistTagChange;
-				if (tagChange == null)
-				{
-					continue;
-				}
-				if (tagChange.Tag == 18)
-				{
-					list.Find((Entity targetEntity) => targetEntity.GetEntityId() == tagChange.Entity)?.SetTag(18, tagChange.Value);
-				}
-				else if (tagChange.Tag == 49 && tagChange.Value == 4)
-				{
-					Entity entity = list.Find((Entity targetEntity) => targetEntity.GetEntityId() == tagChange.Entity);
-					if (entity != null && entity.GetTag(GAME_TAG.LAST_AFFECTED_BY) == damageSourceID)
-					{
-						list2.Add(entity);
-					}
-				}
-			}
-		}
-		return list2;
-	}
-
-	public static void ApplyPower(Entity entity, Network.PowerHistory power)
-	{
-		switch (power.Type)
-		{
-		case Network.PowerType.SHOW_ENTITY:
-			ApplyShowEntity(entity, (Network.HistShowEntity)power);
-			break;
-		case Network.PowerType.HIDE_ENTITY:
-			ApplyHideEntity(entity, (Network.HistHideEntity)power);
-			break;
-		case Network.PowerType.TAG_CHANGE:
-			ApplyTagChange(entity, (Network.HistTagChange)power);
-			break;
-		}
-	}
-
-	public static void ApplyShowEntity(Entity entity, Network.HistShowEntity showEntity)
-	{
-		foreach (Network.Entity.Tag tag in showEntity.Entity.Tags)
-		{
-			entity.SetTag(tag.Name, tag.Value);
-		}
-	}
-
-	public static void ApplyHideEntity(Entity entity, Network.HistHideEntity hideEntity)
-	{
-		entity.SetTag(GAME_TAG.ZONE, hideEntity.Zone);
-	}
-
-	public static void ApplyTagChange(Entity entity, Network.HistTagChange tagChange)
-	{
-		entity.SetTag(tagChange.Tag, tagChange.Value);
-	}
-
-	public static TAG_ZONE GetFinalZoneForEntity(Entity entity)
-	{
-		PowerProcessor powerProcessor = GameState.Get().GetPowerProcessor();
-		List<PowerTaskList> list = new List<PowerTaskList>();
-		if (powerProcessor.GetCurrentTaskList() != null)
-		{
-			list.Add(powerProcessor.GetCurrentTaskList());
-		}
-		list.AddRange(powerProcessor.GetPowerQueue().GetList());
-		for (int num = list.Count - 1; num >= 0; num--)
-		{
-			List<PowerTask> taskList = list[num].GetTaskList();
-			for (int num2 = taskList.Count - 1; num2 >= 0; num2--)
-			{
-				if (taskList[num2].GetPower() is Network.HistTagChange histTagChange && histTagChange.Entity == entity.GetEntityId() && (histTagChange.Tag == 49 || histTagChange.Tag == 1702))
-				{
-					return (TAG_ZONE)histTagChange.Value;
-				}
-			}
-		}
-		TAG_ZONE tag = entity.GetTag<TAG_ZONE>(GAME_TAG.FAKE_ZONE);
-		if (tag != 0)
-		{
-			return tag;
-		}
-		return entity.GetZone();
-	}
-
-	public static bool IsEntityHiddenAfterCurrentTasklist(Entity entity)
-	{
-		if (!entity.IsHidden())
-		{
-			return false;
-		}
-		PowerProcessor powerProcessor = GameState.Get().GetPowerProcessor();
-		if (powerProcessor.GetCurrentTaskList() != null)
-		{
-			foreach (PowerTask task in powerProcessor.GetCurrentTaskList().GetTaskList())
-			{
-				if (task.GetPower() is Network.HistShowEntity histShowEntity && histShowEntity.Entity.ID == entity.GetEntityId() && !string.IsNullOrEmpty(histShowEntity.Entity.CardID))
-				{
-					return false;
-				}
-			}
-		}
-		return true;
-	}
-
-	public static bool IsGalakrond(string cardId)
-	{
-		switch (cardId)
-		{
-		case "DRG_600":
-		case "DRG_600t2":
-		case "DRG_600t3":
-		case "DRG_650":
-		case "DRG_650t2":
-		case "DRG_650t3":
-		case "DRG_620":
-		case "DRG_620t2":
-		case "DRG_620t3":
-		case "DRG_660":
-		case "DRG_660t2":
-		case "DRG_660t3":
-		case "DRG_610":
-		case "DRG_610t2":
-		case "DRG_610t3":
-			return true;
-		default:
-			return false;
-		}
-	}
-
-	public static bool IsGalakrondInPlay(Player player)
-	{
-		if (player == null)
-		{
-			return false;
-		}
-		Entity hero = player.GetHero();
-		if (hero == null)
-		{
-			return false;
-		}
-		return IsGalakrond(hero.GetCardId());
-	}
-
-	public static void DoDamageTasks(PowerTaskList powerTaskList, Card sourceCard, Card targetCard)
-	{
-		List<PowerTask> taskList = powerTaskList.GetTaskList();
-		if (taskList == null || taskList.Count == 0)
-		{
-			return;
-		}
-		int entityId = sourceCard.GetEntity().GetEntityId();
-		int entityId2 = targetCard.GetEntity().GetEntityId();
-		foreach (PowerTask item in taskList)
-		{
-			Network.PowerHistory power = item.GetPower();
-			if (power.Type == Network.PowerType.META_DATA)
-			{
-				Network.HistMetaData histMetaData = (Network.HistMetaData)power;
-				if (histMetaData.MetaType != HistoryMeta.Type.DAMAGE && histMetaData.MetaType != HistoryMeta.Type.HEALING)
-				{
-					continue;
-				}
-				foreach (int item2 in histMetaData.Info)
-				{
-					if (item2 == entityId || item2 == entityId2)
-					{
-						item.DoTask();
-					}
-				}
-			}
-			else
-			{
-				if (power.Type != Network.PowerType.TAG_CHANGE)
-				{
-					continue;
-				}
-				Network.HistTagChange histTagChange = (Network.HistTagChange)power;
-				if (histTagChange.Entity == entityId || histTagChange.Entity == entityId2)
-				{
-					GAME_TAG tag = (GAME_TAG)histTagChange.Tag;
-					if (tag == GAME_TAG.DAMAGE || tag == GAME_TAG.EXHAUSTED)
-					{
-						item.DoTask();
-					}
-				}
-			}
-		}
-	}
-
-	public static AdventureDbfRecord GetAdventureRecordFromMissionId(int missionId)
-	{
-		ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
-		if (record == null)
-		{
-			return null;
-		}
-		int adventureId = record.AdventureId;
-		return GameDbf.Adventure.GetRecord(adventureId);
-	}
-
-	public static WingDbfRecord GetWingRecordFromMissionId(int missionId)
-	{
-		WingDbId wingIdFromMissionId = GetWingIdFromMissionId((ScenarioDbId)missionId);
-		if (wingIdFromMissionId == WingDbId.INVALID)
-		{
-			return null;
-		}
-		return GameDbf.Wing.GetRecord((int)wingIdFromMissionId);
-	}
-
-	public static WingDbId GetWingIdFromMissionId(ScenarioDbId missionId)
-	{
-		return (WingDbId)(GameDbf.Scenario.GetRecord((int)missionId)?.WingId ?? 0);
-	}
-
-	public static AdventureDataDbfRecord GetAdventureDataRecord(int adventureId, int modeId)
-	{
-		foreach (AdventureDataDbfRecord record in GameDbf.AdventureData.GetRecords())
-		{
-			if (record.AdventureId == adventureId && record.ModeId == modeId)
-			{
-				return record;
-			}
-		}
-		return null;
-	}
-
-	public static List<ScenarioDbfRecord> GetClassChallengeRecords(int adventureId, int wingId)
-	{
-		List<ScenarioDbfRecord> list = new List<ScenarioDbfRecord>();
-		foreach (ScenarioDbfRecord record in GameDbf.Scenario.GetRecords())
-		{
-			if (record.ModeId == 4 && record.AdventureId == adventureId && record.WingId == wingId)
-			{
-				list.Add(record);
-			}
-		}
-		return list;
-	}
-
-	public static TAG_CLASS GetClassChallengeHeroClass(ScenarioDbfRecord rec)
-	{
-		if (rec.ModeId != 4)
-		{
-			return TAG_CLASS.INVALID;
-		}
-		int player1HeroCardId = rec.Player1HeroCardId;
-		return DefLoader.Get().GetEntityDef(player1HeroCardId)?.GetClass() ?? TAG_CLASS.INVALID;
-	}
-
-	public static List<TAG_CLASS> GetClassChallengeHeroClasses(int adventureId, int wingId)
-	{
-		List<ScenarioDbfRecord> classChallengeRecords = GetClassChallengeRecords(adventureId, wingId);
-		List<TAG_CLASS> list = new List<TAG_CLASS>();
-		foreach (ScenarioDbfRecord item in classChallengeRecords)
-		{
-			list.Add(GetClassChallengeHeroClass(item));
-		}
-		return list;
-	}
-
-	public static bool IsAIMission(int missionId)
-	{
-		ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
-		if (record == null)
-		{
-			return false;
-		}
-		if (record.Players == 1)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static bool IsCoopMission(int missionId)
-	{
-		return GameDbf.Scenario.GetRecord(missionId)?.IsCoop ?? false;
-	}
-
-	public static bool IsMercenariesMission(int missionid)
-	{
-		if (missionid != 3778 && missionid != 3900 && missionid != 3901 && missionid != 4067 && missionid != 3779 && missionid != 3744 && missionid != 3792 && missionid != 3790 && missionid != 3899)
-		{
-			return missionid == 3862;
-		}
-		return true;
-	}
-
-	public static string GetMissionHeroCardId(int missionId)
-	{
-		ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
-		if (record == null)
-		{
-			return null;
-		}
-		int num = record.ClientPlayer2HeroCardId;
-		if (num == 0)
-		{
-			num = record.Player2HeroCardId;
-		}
-		return TranslateDbIdToCardId(num);
-	}
-
-	public static string GetMissionHeroName(int missionId)
-	{
-		string missionHeroCardId = GetMissionHeroCardId(missionId);
-		if (missionHeroCardId == null)
-		{
-			return null;
-		}
-		EntityDef entityDef = DefLoader.Get().GetEntityDef(missionHeroCardId);
-		if (entityDef == null)
-		{
-			Debug.LogError($"GameUtils.GetMissionHeroName() - hero {missionHeroCardId} for mission {missionId} has no EntityDef");
-			return null;
-		}
-		return entityDef.GetName();
-	}
-
-	public static string GetMissionHeroPowerCardId(int missionId)
-	{
-		ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
-		if (record == null)
-		{
-			return null;
-		}
-		int clientPlayer2HeroPowerCardId = record.ClientPlayer2HeroPowerCardId;
-		if (clientPlayer2HeroPowerCardId != 0)
-		{
-			return TranslateDbIdToCardId(clientPlayer2HeroPowerCardId);
-		}
-		int num = record.ClientPlayer2HeroCardId;
-		if (num == 0)
-		{
-			num = record.Player2HeroCardId;
-		}
-		return GetHeroPowerCardIdFromHero(num);
-	}
-
-	public static bool IsMissionForAdventure(int missionId, int adventureId)
-	{
-		ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
-		if (record == null)
-		{
-			return false;
-		}
-		return adventureId == record.AdventureId;
-	}
-
-	public static bool IsTutorialMission(int missionId)
-	{
-		return IsMissionForAdventure(missionId, 1);
-	}
-
-	public static bool IsPracticeMission(int missionId)
-	{
-		return IsMissionForAdventure(missionId, 2);
-	}
-
-	public static bool IsDungeonCrawlMission(int missionId)
-	{
-		ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
-		if (record == null)
-		{
-			return false;
-		}
-		return DoesAdventureModeUseDungeonCrawlFormat((AdventureModeDbId)record.ModeId);
-	}
-
-	public static bool DoesAdventureModeUseDungeonCrawlFormat(AdventureModeDbId modeId)
-	{
-		if (modeId != AdventureModeDbId.DUNGEON_CRAWL)
-		{
-			return modeId == AdventureModeDbId.DUNGEON_CRAWL_HEROIC;
-		}
-		return true;
-	}
-
-	public static bool IsBoosterLatestActiveExpansion(int boosterId)
-	{
-		return boosterId == (int)GetLatestRewardableBooster();
-	}
-
-	public static BoosterDbId GetLatestRewardableBooster()
-	{
-		return GetRewardableBoosterOffsetFromLatest(0);
-	}
-
-	public static BoosterDbId GetRewardableBoosterOffsetFromLatest(int offset)
-	{
-		List<BoosterDbfRecord> rewardableBoosters = GetRewardableBoosters();
-		if (rewardableBoosters.Count <= 0)
-		{
-			Debug.LogError("No active Booster sets found");
-			return BoosterDbId.INVALID;
-		}
-		offset = Mathf.Clamp(offset, 0, rewardableBoosters.Count - 1);
-		return (BoosterDbId)rewardableBoosters[offset].ID;
-	}
-
-	public static BoosterDbId GetLatestCatchupPack()
-	{
-		BoosterDbfRecord boosterDbfRecord = null;
-		DateTime? dateTime = null;
-		foreach (BoosterDbfRecord record in GameDbf.Booster.GetRecords())
-		{
-			if (!record.IsCatchupPack)
-			{
-				continue;
-			}
-			DateTime? eventStartTimeUtc = EventTimingManager.Get().GetEventStartTimeUtc(record.ShownToClientEvent);
-			if (!eventStartTimeUtc.HasValue || eventStartTimeUtc > DateTime.UtcNow)
-			{
-				DateTime? eventStartTimeUtc2 = EventTimingManager.Get().GetEventStartTimeUtc(record.OpenPackEvent);
-				if (boosterDbfRecord == null || (eventStartTimeUtc2.HasValue && EventTimingManager.Get().IsEventActive(record.OpenPackEvent) && eventStartTimeUtc2.Value > dateTime.Value))
-				{
-					boosterDbfRecord = record;
-					dateTime = eventStartTimeUtc2;
-				}
-			}
-		}
-		return (BoosterDbId)boosterDbfRecord.ID;
-	}
-
-	public static BoosterDbId GetRewardableBoosterFromSelector(RewardItem.BoosterSelector selector)
-	{
-		switch (selector)
-		{
-		case RewardItem.BoosterSelector.LATEST:
-			return GetRewardableBoosterOffsetFromLatest(0);
-		case RewardItem.BoosterSelector.LATEST_OFFSET_BY_1:
-			return GetRewardableBoosterOffsetFromLatest(1);
-		case RewardItem.BoosterSelector.LATEST_OFFSET_BY_2:
-			return GetRewardableBoosterOffsetFromLatest(2);
-		case RewardItem.BoosterSelector.LATEST_OFFSET_BY_3:
-			return GetRewardableBoosterOffsetFromLatest(3);
-		case RewardItem.BoosterSelector.LATEST_CATCHUP_PACK:
-			return GetLatestCatchupPack();
-		default:
-			Debug.LogError($"Unknown BoosterSelector {selector}");
-			return BoosterDbId.INVALID;
-		}
-	}
-
-	public static AdventureDbId GetLatestActiveAdventure()
-	{
-		AdventureDbId adventureDbId = AdventureDbId.INVALID;
-		foreach (AdventureDbfRecord record in GameDbf.Adventure.GetRecords())
-		{
-			AdventureDbId iD = (AdventureDbId)record.ID;
-			if (!AdventureConfig.IsAdventureComingSoon(iD) && AdventureConfig.IsAdventureEventActive(iD) && iD > adventureDbId)
-			{
-				adventureDbId = iD;
-			}
-		}
-		return adventureDbId;
-	}
-
-	public static bool IsExpansionMission(int missionId)
-	{
-		ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
-		if (record == null)
-		{
-			return false;
-		}
-		int adventureId = record.AdventureId;
-		if (adventureId == 0)
-		{
-			return false;
-		}
-		return IsExpansionAdventure((AdventureDbId)adventureId);
-	}
-
-	public static bool IsExpansionAdventure(AdventureDbId adventureId)
-	{
-		switch (adventureId)
-		{
-		case AdventureDbId.INVALID:
-		case AdventureDbId.TUTORIAL:
-		case AdventureDbId.PRACTICE:
-		case AdventureDbId.TAVERN_BRAWL:
-		case AdventureDbId.RETURNING_PLAYER:
-		case AdventureDbId.MERCENARY_PVE:
-		case AdventureDbId.BOTS_ON_LADDER:
-			return false;
-		default:
-			return true;
-		}
-	}
-
-	public static string GetAdventureProductStringKey(int wingID)
-	{
-		AdventureDbId adventureIdByWingId = GetAdventureIdByWingId(wingID);
-		if (adventureIdByWingId != 0)
-		{
-			return GameDbf.Adventure.GetRecord((int)adventureIdByWingId).ProductStringKey;
-		}
-		return string.Empty;
-	}
-
-	public static AdventureDbId GetAdventureId(int missionId)
-	{
-		return (AdventureDbId)(GameDbf.Scenario.GetRecord(missionId)?.AdventureId ?? 0);
-	}
-
-	public static AdventureDbId GetAdventureIdByWingId(int wingID)
-	{
-		WingDbfRecord record = GameDbf.Wing.GetRecord(wingID);
-		if (record == null)
-		{
-			return AdventureDbId.INVALID;
-		}
-		AdventureDbId adventureId = (AdventureDbId)record.AdventureId;
-		if (!IsExpansionAdventure(adventureId))
-		{
-			return AdventureDbId.INVALID;
-		}
-		return adventureId;
-	}
-
-	public static AdventureModeDbId GetAdventureModeId(int missionId)
-	{
-		return (AdventureModeDbId)(GameDbf.Scenario.GetRecord(missionId)?.ModeId ?? 0);
-	}
-
-	public static bool IsHeroicAdventureMission(int missionId)
-	{
-		return IsModeHeroic(GetAdventureModeId(missionId));
-	}
-
-	public static bool IsModeHeroic(AdventureModeDbId mode)
-	{
-		if (mode != AdventureModeDbId.LINEAR_HEROIC)
-		{
-			return mode == AdventureModeDbId.DUNGEON_CRAWL_HEROIC;
-		}
-		return true;
-	}
-
-	public static AdventureModeDbId GetNormalModeFromHeroicMode(AdventureModeDbId mode)
-	{
-		return mode switch
-		{
-			AdventureModeDbId.DUNGEON_CRAWL_HEROIC => AdventureModeDbId.DUNGEON_CRAWL, 
-			AdventureModeDbId.LINEAR_HEROIC => AdventureModeDbId.LINEAR, 
-			_ => mode, 
-		};
-	}
-
-	public static bool IsClassChallengeMission(int missionId)
-	{
-		return GetAdventureModeId(missionId) == AdventureModeDbId.CLASS_CHALLENGE;
-	}
-
-	public static int GetSortedWingUnlockIndex(WingDbfRecord wingRecord)
-	{
-		List<WingDbfRecord> records = GameDbf.Wing.GetRecords((WingDbfRecord r) => r.AdventureId == wingRecord.AdventureId);
-		bool wingsHaveSameUnlockOrder = false;
-		records.Sort(delegate(WingDbfRecord l, WingDbfRecord r)
-		{
-			int num = l.UnlockOrder - r.UnlockOrder;
-			if (num == 0 && l.ID != r.ID)
-			{
-				wingsHaveSameUnlockOrder = true;
-			}
-			return num;
-		});
-		if (wingsHaveSameUnlockOrder)
-		{
-			return 0;
-		}
-		return records.FindIndex((WingDbfRecord r) => r.ID == wingRecord.ID);
-	}
-
-	public static int GetNumWingsInAdventure(AdventureDbId adventureId)
-	{
-		return GameDbf.Wing.GetRecords((WingDbfRecord r) => r.AdventureId == (int)adventureId).Count;
-	}
-
-	public static void ReplayTraditionalTutorial()
-	{
-		if (s_profileProgress.Value != null)
-		{
-			SetTutorialProgress(TutorialProgress.NOTHING_COMPLETE, tutorialComplete: false);
-			if (!TutorialProgressScreen.HasEverOpenedRewardChest())
-			{
-				TutorialProgressScreen.SetHasEverOpenedRewardChest();
-			}
-			if (Network.ShouldBeConnectedToAurora() && Network.IsLoggedIn())
-			{
-				BnetPresenceMgr.Get().SetGameField(15u, 0);
-			}
-			GameMgr.Get().FindGame(GameType.GT_TUTORIAL, FormatType.FT_WILD, GetNextTutorial(), 0, 0L, null, null, restoreSavedGameState: false, null, null, 0L);
-		}
-	}
-
-	public static void CompleteTraditionalTutorial()
-	{
-		NetCache.NetCacheProfileProgress value = s_profileProgress.Value;
-		if (value != null && !IsTraditionalTutorialComplete(value))
-		{
-			if (GameState.Get().GetGameEntity() is TutorialEntity tutorialEntity)
-			{
-				tutorialEntity.ClearPreTutorialNotification();
-			}
-			SetTutorialProgress(TutorialProgress.LICH_KING_COMPLETE, tutorialComplete: true);
-			if (Network.ShouldBeConnectedToAurora() && Network.IsLoggedIn())
-			{
-				BnetPresenceMgr.Get().SetGameField(15u, 1);
-			}
-			NotificationManager.Get().DestroyAllPopUps();
-			BnetBar bnetBar = BnetBar.Get();
-			if (bnetBar != null)
-			{
-				bnetBar.HideSkipTutorialButton();
-			}
-			if (!DialogManager.Get().ShowInitialDownloadPopupDuringDownload())
-			{
-				SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
-			}
-		}
-	}
-
-	public static void SetTutorialProgress(TutorialProgress progress, bool tutorialComplete)
-	{
-		if (!GameMgr.Get().IsSpectator())
-		{
-			AdTrackingManager.Get().TrackTutorialProgress(progress);
-			NetCache.NetCacheProfileProgress netObject = NetCache.Get().GetNetObject<NetCache.NetCacheProfileProgress>();
-			if (netObject != null)
-			{
-				netObject.CampaignProgress = progress;
-				netObject.TutorialComplete = tutorialComplete;
-			}
-			NetCache.Get().NetCacheChanged<NetCache.NetCacheProfileProgress>();
-		}
-	}
-
-	public static bool IsTraditionalTutorialComplete()
-	{
-		NetCache.NetCacheProfileProgress value = s_profileProgress.Value;
-		if (value != null)
-		{
-			return IsTraditionalTutorialComplete(value);
-		}
-		return false;
-	}
-
-	public static bool HasEverCompletedTraditionalTutorial()
-	{
-		if (!GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.PLAYER_FLAGS, GameSaveKeySubkeyId.PLAYER_FLAGS_HAS_EVER_COMPLETED_TRADITIONAL_TUTORIAL, out long value))
-		{
-			return false;
-		}
-		return value != 0;
-	}
-
-	public static bool AreAllTutorialsComplete(NetCache.NetCacheProfileProgress profileProgress)
-	{
-		if (!IsTraditionalTutorialComplete(profileProgress))
-		{
-			return false;
-		}
-		if (!IsBattleGroundsTutorialComplete())
-		{
-			return false;
-		}
-		return IsMercenariesVillageTutorialComplete();
-	}
-
-	public static bool IsTraditionalTutorialComplete(NetCache.NetCacheProfileProgress profileProgress)
-	{
-		if (DemoMgr.Get().GetMode() == DemoMode.BLIZZ_MUSEUM)
-		{
-			return false;
-		}
-		if (!profileProgress.TutorialComplete)
-		{
-			return profileProgress.CampaignProgress >= TutorialProgress.LICH_KING_COMPLETE;
-		}
-		return true;
-	}
-
-	public static bool CanCheckTutorialCompletion()
-	{
-		if (!GameSaveDataManager.Get().IsDataReady(GameSaveKeyId.BACON))
-		{
-			return false;
-		}
-		if (!GameSaveDataManager.Get().IsDataReady(GameSaveKeyId.MERCENARIES))
-		{
-			return false;
-		}
-		if (s_profileProgress.Value == null)
-		{
-			return false;
-		}
-		return true;
-	}
-
-	public static bool IsAnyTutorialComplete()
-	{
-		if (IsBattleGroundsTutorialComplete())
-		{
-			return true;
-		}
-		if (IsMercenariesVillageTutorialComplete())
-		{
-			return true;
-		}
-		NetCache.NetCacheProfileProgress value = s_profileProgress.Value;
-		if (value == null)
-		{
-			return false;
-		}
-		return IsTraditionalTutorialComplete(value);
-	}
-
-	public static bool IsBattleGroundsTutorialComplete()
-	{
-		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-		bool flag = false;
-		if (netObject != null)
-		{
-			flag = !netObject.Games.BattlegroundsTutorial;
-		}
-		if (flag)
-		{
-			return false;
-		}
-		if (GameSaveDataManager.Get() == null || !GameSaveDataManager.Get().IsDataReady(GameSaveKeyId.BACON))
-		{
-			return false;
-		}
-		long value = 0L;
-		GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.BACON, GameSaveKeySubkeyId.BACON_HAS_SEEN_TUTORIAL, out value);
-		return value > 0;
-	}
-
-	public static bool IsMercenariesPrologueBountyComplete(NetCache.NetCacheMercenariesPlayerInfo playerInfo)
-	{
-		if (playerInfo == null)
-		{
-			Debug.LogError("Player Info was null when check prologue bounty completion.  This should be checked before entering this function or undesirable results may occur");
-			return false;
-		}
-		List<LettuceBountyDbfRecord> list = GameDbf.LettuceBounty.GetRecords((LettuceBountyDbfRecord r) => r.BountySetRecord != null && r.BountySetRecord.IsTutorial && r.Enabled).ToList();
-		if (list.Count <= 0)
-		{
-			return false;
-		}
-		return MercenariesDataUtil.IsBountyComplete(list[0].ID, playerInfo);
-	}
-
-	public static bool IsMercenariesVillageTutorialComplete()
-	{
-		return LettuceTutorialUtils.IsSpecificEventComplete(LettuceTutorialVo.LettuceTutorialEvent.VILLAGE_TUTORIAL_END);
-	}
-
-	public static bool HasCompletedApprentice()
-	{
-		GameSaveDataManager gameSaveDataManager = GameSaveDataManager.Get();
-		if (!gameSaveDataManager.IsDataReady(GameSaveKeyId.PLAYER_FLAGS))
-		{
-			return true;
-		}
-		if (gameSaveDataManager.GetSubkeyValue(GameSaveKeyId.PLAYER_FLAGS, GameSaveKeySubkeyId.PLAYER_FLAGS_HAS_COMPLETED_APPRENTICE, out long value))
-		{
-			return value > 0;
-		}
-		return false;
-	}
-
-	public static bool CanSkipApprentice()
-	{
-		if (!HasCompletedApprentice())
-		{
-			return IsTraditionalTutorialComplete();
-		}
-		return false;
-	}
-
-	public static bool ShouldSkipRailroading()
-	{
-		GameSaveDataManager gameSaveDataManager = GameSaveDataManager.Get();
-		if (!gameSaveDataManager.IsDataReady(GameSaveKeyId.FTUE))
-		{
-			return true;
-		}
-		gameSaveDataManager.GetSubkeyValue(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.SHOULD_SKIP_RAILROADING, out long value);
-		return value == 1;
-	}
-
-	public static bool AreAllTutorialsComplete()
-	{
-		NetCache.NetCacheProfileProgress value = s_profileProgress.Value;
-		if (value != null)
-		{
-			return AreAllTutorialsComplete(value);
-		}
-		return false;
-	}
-
-	public static bool TutorialPreviewVideosEnabled()
-	{
-		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-		if (netObject == null)
-		{
-			Log.All.Print(" Could not get NetCacheFeatures Object");
-			return true;
-		}
-		return netObject.TutorialPreviewVideosEnabled;
-	}
-
-	public static float TutorialPreviewVideosTimeout()
-	{
-		NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
-		if (netObject == null)
-		{
-			Log.All.Print(" Could not get NetCacheFeatures Object");
-			return NetCache.NetCacheFeatures.Defaults.TutorialPreviewVideosTimeout;
-		}
-		return netObject.TutorialPreviewVideosTimeout;
-	}
-
-	public static int GetNextTutorial(NetCache.NetCacheProfileProgress progress)
-	{
-		if (progress.TutorialComplete)
-		{
-			return 0;
-		}
-		if (progress.CampaignProgress == TutorialProgress.NOTHING_COMPLETE)
-		{
-			return 5287;
-		}
-		if (progress.CampaignProgress == TutorialProgress.REXXAR_COMPLETE)
-		{
-			return 5289;
-		}
-		if (progress.CampaignProgress == TutorialProgress.GARROSH_COMPLETE)
-		{
-			return 5290;
-		}
-		return 0;
-	}
-
-	public static int GetNextTutorial()
-	{
-		NetCache.NetCacheProfileProgress netCacheProfileProgress = s_profileProgress.Value;
-		if (netCacheProfileProgress == null)
-		{
-			netCacheProfileProgress = new NetCache.NetCacheProfileProgress
-			{
-				CampaignProgress = Options.Get().GetEnum<TutorialProgress>(Option.LOCAL_TUTORIAL_PROGRESS),
-				TutorialComplete = false
-			};
-		}
-		return GetNextTutorial(netCacheProfileProgress);
-	}
-
-	public static string GetTutorialCardRewardDetails(int missionId)
-	{
-		switch ((ScenarioDbId)missionId)
-		{
-		case ScenarioDbId.TUTORIAL_REXXAR:
-			return GameStrings.Get("GLOBAL_REWARD_CARD_DETAILS_TUTORIAL01");
-		case ScenarioDbId.TUTORIAL_GARROSH:
-			return GameStrings.Get("GLOBAL_REWARD_CARD_DETAILS_TUTORIAL02");
-		case ScenarioDbId.TUTORIAL_LICH_KING:
-			return GameStrings.Get("GLOBAL_REWARD_CARD_DETAILS_TUTORIAL03");
-		default:
-			Debug.LogWarning($"GameUtils.GetTutorialCardRewardDetails(): no card reward details for mission {missionId}");
-			return "";
-		}
-	}
-
-	public static string GetCurrentTutorialCardRewardDetails()
-	{
-		return GetTutorialCardRewardDetails(GameMgr.Get().GetMissionId());
-	}
-
-	public static int MissionSortComparison(ScenarioDbfRecord rec1, ScenarioDbfRecord rec2)
-	{
-		return rec1.SortOrder - rec2.SortOrder;
-	}
-
-	public static List<ScenarioGuestHeroesDbfRecord> GetScenarioGuestHeroes(int scenarioId)
-	{
-		return GameDbf.ScenarioGuestHeroes.GetRecords((ScenarioGuestHeroesDbfRecord r) => r.ScenarioId == scenarioId);
-	}
-
-	public static int GetDefeatedBossCount()
-	{
-		int @int = Options.Get().GetInt(Option.SELECTED_ADVENTURE);
-		AdventureModeDbId int2 = (AdventureModeDbId)Options.Get().GetInt(Option.SELECTED_ADVENTURE_MODE);
-		AdventureDataDbfRecord adventureDataRecord = GetAdventureDataRecord(@int, (int)int2);
-		if (adventureDataRecord == null)
-		{
-			return 0;
-		}
-		GameSaveKeyId gameSaveDataServerKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataServerKey;
-		if (!DungeonCrawlUtil.IsDungeonRunActive(gameSaveDataServerKey))
-		{
-			return 0;
-		}
-		List<long> values = null;
-		GameSaveDataManager.Get().GetSubkeyValue(gameSaveDataServerKey, GameSaveKeySubkeyId.DUNGEON_CRAWL_BOSSES_DEFEATED, out values);
-		return values?.Count ?? 0;
-	}
-
-	public static List<FixedRewardActionDbfRecord> GetFixedActionRecords(FixedRewardAction.Type actionType)
-	{
-		return GameDbf.GetIndex().GetFixedActionRecordsForType(actionType);
-	}
-
-	public static FixedRewardDbfRecord GetFixedRewardForCard(string cardID, TAG_PREMIUM premium)
-	{
-		int cardId = TranslateCardIdToDbId(cardID);
-		return GameDbf.GetIndex().GetFixedRewardRecordsForCardId(cardId, (int)premium);
-	}
-
-	public static List<FixedRewardMapDbfRecord> GetFixedRewardMapRecordsForAction(int actionID)
-	{
-		return GameDbf.GetIndex().GetFixedRewardMapRecordsForAction(actionID);
-	}
-
-	public static int GetFixedRewardCounterpartCardID(int cardID)
-	{
-		foreach (FixedRewardActionDbfRecord fixedActionRecord in GetFixedActionRecords(FixedRewardAction.Type.OWNS_COUNTERPART_CARD))
-		{
-			if (!EventTimingManager.Get().IsEventActive(fixedActionRecord.ActiveEvent))
-			{
-				continue;
-			}
-			foreach (FixedRewardMapDbfRecord item in GetFixedRewardMapRecordsForAction(fixedActionRecord.ID))
-			{
-				FixedRewardDbfRecord record = GameDbf.FixedReward.GetRecord(item.RewardId);
-				if (GetCardTagValue(record.CardId, GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID) == cardID)
-				{
-					return record.CardId;
-				}
-			}
-		}
-		return 0;
-	}
-
-	public static string GetOwnedCounterpartCardIDForFormat(EntityDef cardDef, FormatType formatType, int minOwned)
-	{
-		string text = TranslateDbIdToCardId(cardDef.GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
-		if (text != null)
-		{
-			return text;
-		}
-		TAG_CARD_SET[] cardSetsInFormat = GetCardSetsInFormat(formatType);
-		CollectionManager collectionManager = CollectionManager.Get();
-		int? minOwned2 = minOwned;
-		TAG_CARD_SET[] theseCardSets = cardSetsInFormat;
-		foreach (CollectibleCard card in collectionManager.FindCards(null, null, null, theseCardSets, null, null, null, null, null, null, minOwned2).m_cards)
-		{
-			if (TranslateDbIdToCardId(card.GetEntityDef().GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID)) == cardDef.GetCardId())
-			{
-				text = card.CardId;
-				break;
-			}
-		}
-		return text;
-	}
-
-	public static bool IsMatchmadeGameType(GameType gameType, int? missionId = null)
-	{
-		switch (gameType)
-		{
-		case GameType.GT_PVPDR_PAID:
-		case GameType.GT_PVPDR:
-			if (missionId.HasValue && DungeonCrawlUtil.IsPVPDRFriendlyEncounter(missionId.Value))
-			{
-				return false;
-			}
-			return true;
-		case GameType.GT_ARENA:
-		case GameType.GT_RANKED:
-		case GameType.GT_CASUAL:
-		case GameType.GT_BATTLEGROUNDS:
-		case GameType.GT_MERCENARIES_PVP:
-		case GameType.GT_BATTLEGROUNDS_DUO:
-		case GameType.GT_BATTLEGROUNDS_DUO_VS_AI:
-			return true;
-		case GameType.GT_VS_AI:
-		case GameType.GT_VS_FRIEND:
-		case GameType.GT_TUTORIAL:
-		case GameType.GT_BATTLEGROUNDS_FRIENDLY:
-		case GameType.GT_MERCENARIES_PVE:
-		case GameType.GT_MERCENARIES_PVE_COOP:
-		case GameType.GT_BATTLEGROUNDS_DUO_FRIENDLY:
-			return false;
-		default:
-			if (IsTavernBrawlGameType(gameType))
-			{
-				int num = 0;
-				if (missionId.HasValue)
-				{
-					num = missionId.Value;
-				}
-				else
-				{
-					TavernBrawlMission tavernBrawlMission = TavernBrawlManager.Get().CurrentMission();
-					if (tavernBrawlMission == null)
-					{
-						return true;
-					}
-					num = tavernBrawlMission.missionId;
-				}
-				if (IsAIMission(num))
-				{
-					return false;
-				}
-				return true;
-			}
-			return false;
-		}
-	}
-
-	public static bool IsBattlegroundsGameType(GameType gametype)
-	{
-		if (gametype != GameType.GT_BATTLEGROUNDS && gametype != GameType.GT_BATTLEGROUNDS_FRIENDLY && gametype != GameType.GT_BATTLEGROUNDS_PLAYER_VS_AI && gametype != GameType.GT_BATTLEGROUNDS_AI_VS_AI && gametype != GameType.GT_BATTLEGROUNDS_DUO && gametype != GameType.GT_BATTLEGROUNDS_DUO_VS_AI)
-		{
-			return gametype == GameType.GT_BATTLEGROUNDS_DUO_FRIENDLY;
-		}
-		return true;
-	}
-
-	public static bool IsTavernBrawlGameType(GameType gameType)
-	{
-		if ((uint)(gameType - 16) <= 2u)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static bool IsPvpDrGameType(GameType gameType)
-	{
-		if ((uint)(gameType - 28) <= 1u)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static bool IsMercenariesGameType(GameType gameType)
-	{
-		if ((uint)(gameType - 30) <= 4u)
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static bool ShouldShowArenaModeIcon()
-	{
-		return GameMgr.Get().GetGameType() == GameType.GT_ARENA;
-	}
-
-	public static bool ShouldShowCasualModeIcon()
-	{
-		return GameMgr.Get().GetGameType() == GameType.GT_CASUAL;
-	}
-
-	public static bool ShouldShowFriendlyChallengeIcon()
-	{
-		if (GameMgr.Get().GetGameType() == GameType.GT_VS_FRIEND)
-		{
-			if (FriendChallengeMgr.Get().IsChallengeTavernBrawl())
-			{
-				return false;
-			}
-			return true;
-		}
-		return false;
-	}
-
-	public static bool ShouldShowTavernBrawlModeIcon()
-	{
-		GameType gameType = GameMgr.Get().GetGameType();
-		if (gameType == GameType.GT_VS_FRIEND && FriendChallengeMgr.Get().IsChallengeTavernBrawl())
-		{
-			return true;
-		}
-		if (IsTavernBrawlGameType(gameType))
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static bool ShouldShowAdventureModeIcon()
-	{
-		int missionId = GameMgr.Get().GetMissionId();
-		GameType gameType = GameMgr.Get().GetGameType();
-		AdventureDbId adventureId = GetAdventureId(missionId);
-		if (IsExpansionMission(missionId) && adventureId != AdventureDbId.TAVERN_BRAWL && !AdventureUtils.IsDuelsAdventure(adventureId) && !IsTavernBrawlGameType(gameType))
-		{
-			return !IsMercenariesGameType(gameType);
-		}
-		return false;
-	}
-
-	public static bool ShouldShowPvpDrModeIcon()
-	{
-		return AdventureUtils.IsDuelsAdventure(GetAdventureId(GameMgr.Get().GetMissionId()));
-	}
-
-	public static bool IsGameTypeRanked()
-	{
-		return IsGameTypeRanked(GameMgr.Get().GetGameType());
-	}
-
-	public static bool IsGameTypeRanked(GameType gameType)
-	{
-		if (DemoMgr.Get().IsExpoDemo())
-		{
-			return false;
-		}
-		return gameType == GameType.GT_RANKED;
-	}
-
-	public static void RequestPlayerPresence(BnetGameAccountId gameAccountId)
-	{
-		List<PresenceFieldKey> list = new List<PresenceFieldKey>();
-		PresenceFieldKey item = default(PresenceFieldKey);
-		item.programId = BnetProgramId.BNET.GetValue();
-		item.groupId = 2u;
-		item.fieldId = 7u;
-		item.uniqueId = 0uL;
-		list.Add(item);
-		item.programId = BnetProgramId.BNET.GetValue();
-		item.groupId = 2u;
-		item.fieldId = 3u;
-		item.uniqueId = 0uL;
-		list.Add(item);
-		item.programId = BnetProgramId.BNET.GetValue();
-		item.groupId = 2u;
-		item.fieldId = 5u;
-		item.uniqueId = 0uL;
-		list.Add(item);
-		if (IsGameTypeRanked())
-		{
-			PresenceFieldKey item2 = default(PresenceFieldKey);
-			item2.programId = BnetProgramId.HEARTHSTONE.GetValue();
-			item2.groupId = 2u;
-			item2.fieldId = 18u;
-			item2.uniqueId = 0uL;
-			list.Add(item2);
-		}
-		PresenceFieldKey[] fieldList = list.ToArray();
-		BattleNet.RequestPresenceFields(isGameAccountEntityId: true, gameAccountId, fieldList);
-	}
-
-	public static bool IsAIPlayer(BnetGameAccountId gameAccountId)
-	{
-		if (gameAccountId == null)
-		{
-			return false;
-		}
-		return !gameAccountId.IsValid();
-	}
-
-	public static bool IsHumanPlayer(BnetGameAccountId gameAccountId)
-	{
-		if (gameAccountId == null)
-		{
-			return false;
-		}
-		return gameAccountId.IsValid();
-	}
-
-	public static bool IsBnetPlayer(BnetGameAccountId gameAccountId)
-	{
-		if (!IsHumanPlayer(gameAccountId))
-		{
-			return false;
-		}
-		return Network.ShouldBeConnectedToAurora();
-	}
-
-	public static bool IsGuestPlayer(BnetGameAccountId gameAccountId)
-	{
-		if (!IsHumanPlayer(gameAccountId))
-		{
-			return false;
-		}
-		return !Network.ShouldBeConnectedToAurora();
-	}
-
-	public static bool IsAnyTransitionActive()
-	{
-		SceneMgr sceneMgr = SceneMgr.Get();
-		if (sceneMgr != null)
-		{
-			if (sceneMgr.IsTransitionNowOrPending())
-			{
-				return true;
-			}
-			PegasusScene scene = sceneMgr.GetScene();
-			if (scene != null && scene.IsTransitioning())
-			{
-				return true;
-			}
-		}
-		Box box = Box.Get();
-		if (box != null && box.IsTransitioningToSceneMode())
-		{
-			return true;
-		}
-		LoadingScreen loadingScreen = LoadingScreen.Get();
-		if (loadingScreen != null && loadingScreen.IsTransitioning())
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static void ExitConfirmation(AlertPopup.ResponseCallback responseCallback)
-	{
-		AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
-		{
-			m_headerText = GameStrings.Format("GLOBAL_EXIT_CONFIRM_TITLE"),
-			m_text = GameStrings.Format("GLOBAL_EXIT_CONFIRM_MESSAGE"),
-			m_alertTextAlignment = UberText.AlignmentOptions.Center,
-			m_showAlertIcon = false,
-			m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL,
-			m_responseCallback = responseCallback
-		};
-		DialogManager.Get().ShowPopup(info);
-	}
-
-	public static void LogoutConfirmation()
-	{
-		AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
-		{
-			m_headerText = GameStrings.Get(Network.ShouldBeConnectedToAurora() ? "GLOBAL_SWITCH_ACCOUNT" : "GLOBAL_LOGIN_CONFIRM_TITLE"),
-			m_text = GameStrings.Get(Network.ShouldBeConnectedToAurora() ? "GLOBAL_LOGOUT_CONFIRM_MESSAGE" : "GLOBAL_LOGIN_CONFIRM_MESSAGE"),
-			m_alertTextAlignment = UberText.AlignmentOptions.Center,
-			m_showAlertIcon = false,
-			m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL,
-			m_responseCallback = OnLogoutConfirmationResponse
-		};
-		DialogManager.Get().ShowPopup(info);
-	}
-
-	private static void OnLogoutConfirmationResponse(AlertPopup.Response response, object userData)
-	{
-		if (response != AlertPopup.Response.CANCEL)
-		{
-			Logout();
-		}
-	}
-
-	public static void Logout()
-	{
-		GameMgr.Get().SetPendingAutoConcede(pendingAutoConcede: true);
-		if (Network.ShouldBeConnectedToAurora())
-		{
-			ServiceManager.Get<ILoginService>()?.ClearAuthentication();
-		}
-		HearthstoneApplication.Get().ResetAndForceLogin();
-	}
-
-	public static PackOpeningRarity GetPackOpeningRarity(TAG_RARITY tag)
-	{
-		return tag switch
-		{
-			TAG_RARITY.COMMON => PackOpeningRarity.COMMON, 
-			TAG_RARITY.FREE => PackOpeningRarity.COMMON, 
-			TAG_RARITY.RARE => PackOpeningRarity.RARE, 
-			TAG_RARITY.EPIC => PackOpeningRarity.EPIC, 
-			TAG_RARITY.LEGENDARY => PackOpeningRarity.LEGENDARY, 
-			_ => PackOpeningRarity.NONE, 
-		};
-	}
-
-	public static List<BoosterDbfRecord> GetPackRecordsWithStorePrefab()
-	{
-		return GameDbf.Booster.GetRecords((BoosterDbfRecord r) => !string.IsNullOrEmpty(r.StorePrefab));
-	}
-
-	public static List<AdventureDbfRecord> GetSortedAdventureRecordsWithStorePrefab()
-	{
-		List<AdventureDbfRecord> records = GameDbf.Adventure.GetRecords((AdventureDbfRecord r) => !string.IsNullOrEmpty(r.StorePrefab));
-		records.Sort((AdventureDbfRecord l, AdventureDbfRecord r) => r.SortOrder - l.SortOrder);
-		return records;
-	}
-
-	public static List<AdventureDbfRecord> GetAdventureRecordsWithDefPrefab()
-	{
-		return GameDbf.Adventure.GetRecords((AdventureDbfRecord r) => !string.IsNullOrEmpty(r.AdventureDefPrefab));
-	}
-
-	public static List<AdventureDataDbfRecord> GetAdventureDataRecordsWithSubDefPrefab()
-	{
-		return GameDbf.AdventureData.GetRecords((AdventureDataDbfRecord r) => !string.IsNullOrEmpty(r.AdventureSubDefPrefab));
-	}
-
-	public static int PackSortingPredicate(BoosterDbfRecord left, BoosterDbfRecord right)
-	{
-		if (right.ListDisplayOrderCategory != left.ListDisplayOrderCategory)
-		{
-			return Mathf.Clamp(right.ListDisplayOrderCategory - left.ListDisplayOrderCategory, -1, 1);
-		}
-		if (right.ListDisplayOrder != left.ListDisplayOrder)
-		{
-			return Mathf.Clamp(right.ListDisplayOrder - left.ListDisplayOrder, -1, 1);
-		}
-		return Mathf.Clamp(right.ID - left.ID, -1, 1);
-	}
-
-	public static List<int> GetSortedPackIds(bool ascending = true)
-	{
-		List<BoosterDbfRecord> records = GameDbf.Booster.GetRecords();
-		if (ascending)
-		{
-			records.Sort((BoosterDbfRecord l, BoosterDbfRecord r) => PackSortingPredicate(r, l));
-		}
-		else
-		{
-			records.Sort((BoosterDbfRecord l, BoosterDbfRecord r) => PackSortingPredicate(l, r));
-		}
-		return records.Select((BoosterDbfRecord b) => b.ID).ToList();
-	}
-
-	public static bool IsFakePackOpeningEnabled()
-	{
-		if (!HearthstoneApplication.IsInternal())
-		{
-			return false;
-		}
-		return Options.Get().GetBool(Option.FAKE_PACK_OPENING);
-	}
-
-	public static int GetFakePackCount()
-	{
-		if (!HearthstoneApplication.IsInternal())
-		{
-			return 0;
-		}
-		return Options.Get().GetInt(Option.FAKE_PACK_COUNT);
-	}
-
-	public static bool IsFirstPurchaseBundleBooster(StorePackId storePackId)
-	{
-		if (storePackId.Type == StorePackType.BOOSTER)
-		{
-			return 181 == storePackId.Id;
-		}
-		return false;
-	}
-
-	public static bool IsMammothBundleBooster(StorePackId storePackId)
-	{
-		if (storePackId.Type == StorePackType.BOOSTER)
-		{
-			return 41 == storePackId.Id;
-		}
-		return false;
-	}
-
-	public static bool IsHiddenLicenseBundleBooster(StorePackId storePackId)
-	{
-		if (storePackId.Type == StorePackType.BOOSTER)
-		{
-			BoosterDbId id = (BoosterDbId)storePackId.Id;
-			if (id == BoosterDbId.MAMMOTH_BUNDLE || id == BoosterDbId.FIRST_PURCHASE)
-			{
-				return true;
-			}
-			return false;
-		}
-		return false;
-	}
-
-	public static int GetProductDataFromStorePackId(StorePackId storePackId, int selectedIndex = 0)
-	{
-		if (storePackId.Type == StorePackType.BOOSTER)
-		{
-			if (storePackId.Id == 181)
-			{
-				return 40;
-			}
-			if (storePackId.Id == 41)
-			{
-				return 27;
-			}
-			return storePackId.Id;
-		}
-		return 0;
-	}
-
-	public static int GetProductDataCountFromStorePackId(StorePackId storePackId)
-	{
-		if (storePackId.Type == StorePackType.BOOSTER)
-		{
-			return 1;
-		}
-		return 0;
-	}
-
-	public static List<BoosterDbfRecord> GetRewardableBoosters()
-	{
-		List<BoosterDbfRecord> list = new List<BoosterDbfRecord>();
-		DateTime utcNow = DateTime.UtcNow;
-		foreach (BoosterDbfRecord record in GameDbf.Booster.GetRecords())
-		{
-			if (!IsBoosterRotated((BoosterDbId)record.ID, utcNow) && EventTimingManager.Get().IsEventActive(record.RewardableEvent, utcNow))
-			{
-				list.Add(record);
-			}
-		}
-		list.Sort(SortBoostersDescending);
-		return list;
-	}
-
-	public static int GetBoardIdFromAssetName(string name)
-	{
-		foreach (BoardDbfRecord record in GameDbf.Board.GetRecords())
-		{
-			string prefab = record.Prefab;
-			if (!(name != prefab))
-			{
-				return record.ID;
-			}
-		}
-		return 0;
-	}
-
-	public static UnityEngine.Object Instantiate(GameObject original, GameObject parent, bool withRotation = false)
-	{
-		if (original == null)
-		{
-			return null;
-		}
-		GameObject gameObject = UnityEngine.Object.Instantiate(original);
-		SetParent(gameObject, parent, withRotation);
-		return gameObject;
-	}
-
-	public static UnityEngine.Object Instantiate(Component original, GameObject parent, bool withRotation = false)
-	{
-		if (original == null)
-		{
-			return null;
-		}
-		Component component = UnityEngine.Object.Instantiate(original);
-		SetParent(component, parent, withRotation);
-		return component;
-	}
-
-	public static UnityEngine.Object Instantiate(UnityEngine.Object original)
-	{
-		if (original == null)
-		{
-			return null;
-		}
-		return UnityEngine.Object.Instantiate(original);
-	}
-
-	public static UnityEngine.Object InstantiateGameObject(string path, GameObject parent = null, bool withRotation = false)
-	{
-		if (path == null)
-		{
-			return null;
-		}
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab(path);
-		if (parent != null)
-		{
-			SetParent(gameObject, parent, withRotation);
-		}
-		return gameObject;
-	}
-
-	public static void SetParent(Component child, Component parent, bool withRotation = false)
-	{
-		SetParent(child.transform, parent.transform, withRotation);
-	}
-
-	public static void SetParent(GameObject child, Component parent, bool withRotation = false)
-	{
-		SetParent(child.transform, parent.transform, withRotation);
-	}
-
-	public static void SetParent(Component child, GameObject parent, bool withRotation = false)
-	{
-		SetParent(child.transform, parent.transform, withRotation);
-	}
-
-	public static void SetParent(GameObject child, GameObject parent, bool withRotation = false)
-	{
-		SetParent(child.transform, parent.transform, withRotation);
-	}
-
-	private static void SetParent(Transform child, Transform parent, bool withRotation)
-	{
-		Vector3 localScale = child.localScale;
-		Quaternion localRotation = child.localRotation;
-		child.parent = parent;
-		child.localPosition = Vector3.zero;
-		child.localScale = localScale;
-		if (withRotation)
-		{
-			child.localRotation = localRotation;
-		}
-	}
-
-	public static void ResetTransform(GameObject obj)
-	{
-		obj.transform.localPosition = Vector3.zero;
-		obj.transform.localScale = Vector3.one;
-		obj.transform.localRotation = Quaternion.identity;
-	}
-
-	public static void ResetTransform(Component comp)
-	{
-		ResetTransform(comp.gameObject);
-	}
-
-	public static T LoadGameObjectWithComponent<T>(string assetPath) where T : Component
-	{
-		GameObject gameObject = AssetLoader.Get().InstantiatePrefab(assetPath);
-		if (gameObject == null)
-		{
-			return null;
-		}
-		T component = gameObject.GetComponent<T>();
-		if (component == null)
-		{
-			Debug.LogError($"{assetPath} object does not contain {typeof(T)} component.");
-			UnityEngine.Object.Destroy(gameObject);
-			return null;
-		}
-		return component;
-	}
-
-	public static T FindChildByName<T>(Transform transform, string name) where T : Component
-	{
-		foreach (Transform item in transform)
-		{
-			if (item.name == name)
-			{
-				return item.GetComponent<T>();
-			}
-			T val = FindChildByName<T>(item, name);
-			if (val != null)
-			{
-				return val;
-			}
-		}
-		return null;
-	}
-
-	public static void PlayCardEffectDefSounds(CardEffectDef cardEffectDef)
-	{
-		if (cardEffectDef == null)
-		{
-			return;
-		}
-		foreach (string soundSpellPath in cardEffectDef.m_SoundSpellPaths)
-		{
-			AssetLoader.Get().InstantiatePrefab(soundSpellPath, delegate(AssetReference name, GameObject go, object data)
-			{
-				if (go == null)
-				{
-					Debug.LogError($"Unable to load spell object: {name}");
-				}
-				else
-				{
-					GameObject destroyObj = go;
-					CardSoundSpell component = go.GetComponent<CardSoundSpell>();
-					if (component == null)
-					{
-						Debug.LogError($"Card sound spell component not found: {name}");
-						UnityEngine.Object.Destroy(destroyObj);
-					}
-					else
-					{
-						component.AddStateFinishedCallback(delegate(Spell spell, SpellStateType prevStateType, object userData)
-						{
-							if (spell.GetActiveState() == SpellStateType.NONE)
-							{
-								UnityEngine.Object.Destroy(destroyObj);
-							}
-						});
-						component.ForceDefaultAudioSource();
-						component.Activate();
-					}
-				}
-			});
-		}
-	}
-
-	public static bool LoadCardDefEmoteSound(List<EmoteEntryDef> emoteDefs, EmoteType type, EmoteSoundLoaded callback)
-	{
-		if (callback == null)
-		{
-			Debug.LogError("No callback provided for LoadEmote!");
-			return false;
-		}
-		if (emoteDefs == null)
-		{
-			return false;
-		}
-		EmoteEntryDef emoteEntryDef = emoteDefs.Find((EmoteEntryDef e) => e.m_emoteType == type);
-		if (emoteEntryDef == null)
-		{
-			return false;
-		}
-		AssetLoader.Get().InstantiatePrefab(emoteEntryDef.m_emoteSoundSpellPath, delegate(AssetReference assetRef, GameObject go, object callbackData)
-		{
-			if (go == null)
-			{
-				callback(null);
-			}
-			else
-			{
-				callback(go.GetComponent<CardSoundSpell>());
-			}
-		});
-		return true;
-	}
-
-	public static string GetCardIdFromMercenaryId(int mercenaryId)
-	{
-		MercenaryArtVariationDbfRecord defaultArtVariationRecord = LettuceMercenary.GetDefaultArtVariationRecord(mercenaryId);
-		if (defaultArtVariationRecord == null)
-		{
-			Debug.LogErrorFormat("GetCardIdFromMercenaryId() - No record found for merc: {0}", mercenaryId);
-			return null;
-		}
-		return TranslateDbIdToCardId(defaultArtVariationRecord.CardId);
-	}
-
-	public static int GetMercenaryIdFromCardId(int cardId)
-	{
-		foreach (LettuceMercenaryDbfRecord record in GameDbf.LettuceMercenary.GetRecords())
-		{
-			foreach (MercenaryArtVariationDbfRecord mercenaryArtVariation in record.MercenaryArtVariations)
-			{
-				if (mercenaryArtVariation.CardId == cardId)
-				{
-					return record.ID;
-				}
-			}
-		}
-		return 0;
-	}
-
-	public static int GetMaxMercenaryLevel()
-	{
-		return GameDbf.GetIndex().GetMercenaryMaxLevel();
-	}
-
-	public static int GetMercenaryLevelFromExperience(int experience)
-	{
-		int maxMercenaryLevel = GetMaxMercenaryLevel();
-		List<LettuceMercenaryLevelDbfRecord> records = GameDbf.LettuceMercenaryLevel.GetRecords();
-		for (int i = 1; i <= maxMercenaryLevel; i++)
-		{
-			LettuceMercenaryLevelDbfRecord lettuceMercenaryLevelDbfRecord = null;
-			int j = 0;
-			for (int count = records.Count; j < count; j++)
-			{
-				if (records[j].Level == i)
-				{
-					lettuceMercenaryLevelDbfRecord = records[j];
-					break;
-				}
-			}
-			if (lettuceMercenaryLevelDbfRecord == null)
-			{
-				Log.Lettuce.PrintError("GetMercenaryLevelFromExperience - Missing mercenary level data!");
-				break;
-			}
-			if (experience < lettuceMercenaryLevelDbfRecord.TotalXpRequired)
-			{
-				return i - 1;
-			}
-		}
-		return maxMercenaryLevel;
-	}
-
-	public static float GetExperiencePercentageFromExperienceValue(int experience)
-	{
-		int currentLevel = GetMercenaryLevelFromExperience(experience);
-		if (currentLevel < GetMaxMercenaryLevel())
-		{
-			LettuceMercenaryLevelDbfRecord record = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == currentLevel);
-			return Mathf.InverseLerp(b: GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == currentLevel + 1).TotalXpRequired, a: record.TotalXpRequired, value: experience);
-		}
-		return 1f;
-	}
-
-	public static bool IsActorInMiniHand(Actor actor)
-	{
-		Entity entity = actor.GetEntity();
-		if (entity == null)
-		{
-			return false;
-		}
-		ZoneHand zoneHand = entity.GetCard().GetZone() as ZoneHand;
-		if (zoneHand != null && !zoneHand.HandEnlarged())
-		{
-			return true;
-		}
-		return false;
-	}
-
-	public static float GetExperiencePercentageDelta(int startingExperience, int experienceDelta)
-	{
-		int maxMercenaryLevel = GetMaxMercenaryLevel();
-		if (experienceDelta == 0)
-		{
-			return 0f;
-		}
-		int num = startingExperience + experienceDelta;
-		int startingLevel = maxMercenaryLevel;
-		int currentLevel = maxMercenaryLevel;
-		int nextLevel = maxMercenaryLevel;
-		int level;
-		for (level = 1; level <= maxMercenaryLevel; level++)
-		{
-			LettuceMercenaryLevelDbfRecord record = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == level);
-			if (record == null)
-			{
-				Log.Lettuce.PrintError("GetMercenaryLevelFromExperience - Missing mercenary level data!");
-				break;
-			}
-			if (startingExperience < record.TotalXpRequired)
-			{
-				if (level <= startingLevel)
-				{
-					startingLevel = level - 1;
-				}
-				if (num <= record.TotalXpRequired)
-				{
-					currentLevel = level - 1;
-					nextLevel = level;
-					break;
-				}
-			}
-		}
-		LettuceMercenaryLevelDbfRecord record2 = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == startingLevel);
-		LettuceMercenaryLevelDbfRecord record3 = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == nextLevel);
-		if (startingLevel == currentLevel)
-		{
-			float num2 = Mathf.InverseLerp(record2.TotalXpRequired, record3.TotalXpRequired, startingExperience);
-			return Mathf.InverseLerp(record2.TotalXpRequired, record3.TotalXpRequired, num) - num2;
-		}
-		LettuceMercenaryLevelDbfRecord record4 = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == startingLevel + 1);
-		LettuceMercenaryLevelDbfRecord record5 = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == currentLevel);
-		int num3 = currentLevel - startingLevel - 1;
-		float num4 = 1f - Mathf.InverseLerp(record2.TotalXpRequired, record4.TotalXpRequired, startingExperience);
-		float num5 = Mathf.InverseLerp(record5.TotalXpRequired, record3.TotalXpRequired, num);
-		return (float)num3 + num4 + num5;
-	}
-
-	public static LettuceMercenaryLevelStatsDbfRecord GetMercenaryStatsByLevel(int mercenaryId, int level, out bool isMaxLevel)
-	{
-		int maxMercenaryLevel = GetMaxMercenaryLevel();
-		int num = Mathf.Clamp(level, 1, maxMercenaryLevel);
-		isMaxLevel = num == maxMercenaryLevel;
-		LettuceMercenaryLevelDbfRecord lettuceMercenaryLevelDbfRecord = null;
-		List<LettuceMercenaryLevelDbfRecord> records = GameDbf.LettuceMercenaryLevel.GetRecords();
-		int i = 0;
-		for (int count = records.Count; i < count; i++)
-		{
-			LettuceMercenaryLevelDbfRecord lettuceMercenaryLevelDbfRecord2 = records[i];
-			if (lettuceMercenaryLevelDbfRecord2.Level == num)
-			{
-				lettuceMercenaryLevelDbfRecord = lettuceMercenaryLevelDbfRecord2;
-				break;
-			}
-		}
-		if (lettuceMercenaryLevelDbfRecord == null)
-		{
-			Log.Lettuce.PrintError("GetMercenaryStatsByLevel() - Unable to get level dbf record for level {0}", level);
-			return null;
-		}
-		LettuceMercenaryLevelStatsDbfRecord lettuceMercenaryLevelStatsDbfRecord = null;
-		List<LettuceMercenaryLevelStatsDbfRecord> records2 = GameDbf.LettuceMercenaryLevelStats.GetRecords();
-		int j = 0;
-		for (int count2 = records2.Count; j < count2; j++)
-		{
-			LettuceMercenaryLevelStatsDbfRecord lettuceMercenaryLevelStatsDbfRecord2 = records2[j];
-			if (lettuceMercenaryLevelStatsDbfRecord2.LettuceMercenaryId == mercenaryId && lettuceMercenaryLevelStatsDbfRecord2.LettuceMercenaryLevelId == lettuceMercenaryLevelDbfRecord.ID)
+			if (!HasEarnedAllCardsForClass(dEFAULT_HERO_CLASSES[i]))
 			{
-				lettuceMercenaryLevelStatsDbfRecord = lettuceMercenaryLevelStatsDbfRecord2;
-				break;
+				return false;
 			}
 		}
-		if (lettuceMercenaryLevelStatsDbfRecord == null)
-		{
-			Log.Lettuce.PrintError("GetMercenaryStatsByLevel() - Unable to get level stats dbf record for level {0}", num);
-		}
-		return lettuceMercenaryLevelStatsDbfRecord;
-	}
-
-	public static bool IsFinalBossNodeType(int nodeTypeId)
-	{
-		LettuceMapNodeTypeDbfRecord record = GameDbf.LettuceMapNodeType.GetRecord(nodeTypeId);
-		if (record == null)
-		{
-			return false;
-		}
-		return record.BossType == LettuceMapNodeType.LettuceMapBossType.FINAL_BOSS;
+		return true;
 	}
 
-	public static TAG_ROLE GetMercenaryTagRoleFromProtoRole(Mercenary.Role role)
-	{
-		return role switch
-		{
-			Mercenary.Role.ROLE_NEUTRAL => TAG_ROLE.NEUTRAL, 
-			Mercenary.Role.ROLE_CASTER => TAG_ROLE.CASTER, 
-			Mercenary.Role.ROLE_STRIKER => TAG_ROLE.FIGHTER, 
-			Mercenary.Role.ROLE_PROTECTOR => TAG_ROLE.TANK, 
-			_ => TAG_ROLE.INVALID, 
-		};
-	}
+    public static int CardPremiumSortComparisonAsc(TAG_PREMIUM premium1, TAG_PREMIUM premium2)
+    {
+        return premium1 - premium2;
+    }
+
+    public static int CardPremiumSortComparisonDesc(TAG_PREMIUM premium1, TAG_PREMIUM premium2)
+    {
+        return premium2 - premium1;
+    }
+
+    public static bool CanConcedeCurrentMission()
+    {
+        if (GameState.Get() == null)
+        {
+            return false;
+        }
+        if (GameMgr.Get().IsTraditionalTutorial())
+        {
+            if (NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().SkippableTutorialEnabled)
+            {
+				if (!(GameState.Get().GetGameEntity() is TutorialEntity tutorialEntity))
+				{
+					return false;
+				}
+				return tutorialEntity.IsCustomIntroFinished();
+            }
+            return false;
+        }
+        if (GameMgr.Get().IsSpectator())
+        {
+            return false;
+        }
+        if (GameMgr.Get().IsLettuceTutorial())
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public static bool CanRestartCurrentMission(bool checkTutorial = true)
+    {
+        if (GameState.Get() == null)
+        {
+            return false;
+        }
+        if (GameState.Get().GetBooleanGameOption(GameEntityOption.DISABLE_RESTART_BUTTON))
+        {
+            return false;
+        }
+        if (checkTutorial && GameMgr.Get().IsTraditionalTutorial())
+        {
+            return false;
+        }
+        if (GameMgr.Get().IsSpectator())
+        {
+            return false;
+        }
+        if (!GameMgr.Get().IsAI())
+        {
+            return false;
+        }
+        if (!GameMgr.Get().HasLastPlayedDeckId())
+        {
+            return false;
+        }
+        if (!BattleNet.IsConnected())
+        {
+            return false;
+        }
+        if (DemoMgr.Get().IsDemo() && !DemoMgr.Get().CanRestartMissions())
+        {
+            return false;
+        }
+        if (GameMgr.Get().IsDungeonCrawlMission())
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public static bool IsWaitingForOpponentReconnect()
+    {
+        if (GameState.Get() == null)
+        {
+            return false;
+        }
+        return GameState.Get().GetGameEntity().HasTag(GAME_TAG.WAIT_FOR_PLAYER_RECONNECT_PERIOD);
+    }
+
+    public static Card GetJoustWinner(Network.HistMetaData metaData)
+    {
+        if (metaData == null)
+        {
+            return null;
+        }
+        if (metaData.MetaType != HistoryMeta.Type.JOUST)
+        {
+            return null;
+        }
+        return GameState.Get().GetEntity(metaData.Data)?.GetCard();
+    }
+
+    public static bool IsHistoryDeathTagChange(Network.HistTagChange tagChange)
+    {
+        Entity entity = GameState.Get().GetEntity(tagChange.Entity);
+        if (entity == null)
+        {
+            return false;
+        }
+        if (entity.IsEnchantment())
+        {
+            return false;
+        }
+        if (entity.GetCardType() == TAG_CARDTYPE.INVALID)
+        {
+            return false;
+        }
+        if (tagChange.Tag == 360 && tagChange.Value == 1)
+        {
+            return true;
+        }
+        if (entity.IsMinion() && tagChange.Tag == 49 && tagChange.Value == 4 && entity.GetZone() == TAG_ZONE.PLAY)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static bool IsHistoryDiscardTagChange(Network.HistTagChange tagChange)
+    {
+        if (tagChange.Tag != 49)
+        {
+            return false;
+        }
+        if (GameState.Get().GetEntity(tagChange.Entity).GetZone() != TAG_ZONE.HAND)
+        {
+            return false;
+        }
+        if (tagChange.Value != 4)
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public static bool IsHistoryMovedToSetAsideTagChange(Network.HistTagChange tagChange)
+    {
+        if (tagChange.Tag != 49)
+        {
+            return false;
+        }
+        if (tagChange.Value != 6)
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public static bool IsEntityDeathTagChange(Network.HistTagChange tagChange)
+    {
+        if (tagChange.Tag != 49)
+        {
+            return false;
+        }
+        if (tagChange.Value != 4)
+        {
+            return false;
+        }
+        if (GameState.Get().GetEntity(tagChange.Entity) == null)
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public static bool IsCharacterDeathTagChange(Network.HistTagChange tagChange)
+    {
+        if (tagChange.Tag != 49)
+        {
+            return false;
+        }
+        if (tagChange.Value != 4)
+        {
+            return false;
+        }
+        Entity entity = GameState.Get().GetEntity(tagChange.Entity);
+        if (entity == null)
+        {
+            return false;
+        }
+        if (!entity.IsCharacter())
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public static bool IsPreGameOverPlayState(TAG_PLAYSTATE playState)
+    {
+        if ((uint)(playState - 2) <= 1u || (uint)(playState - 7) <= 1u)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static bool IsGameOverTag(int entityId, int tag, int val)
+    {
+        return IsGameOverTag(GameState.Get().GetEntity(entityId) as Player, tag, val);
+    }
+
+    public static bool IsGameOverTag(Player player, int tag, int val)
+    {
+        if (player == null)
+        {
+            return false;
+        }
+        if (tag != 17)
+        {
+            return false;
+        }
+        if (!player.IsFriendlySide() || !player.IsTeamLeader())
+        {
+            return false;
+        }
+        if ((uint)(val - 4) <= 2u)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static bool IsFriendlyConcede(Network.HistTagChange tagChange)
+    {
+        if (tagChange.Tag != 17)
+        {
+            return false;
+        }
+		if (!(GameState.Get().GetEntity(tagChange.Entity) is Player player))
+        {
+            return false;
+        }
+        if (!player.IsFriendlySide())
+        {
+            return false;
+        }
+        return tagChange.Value == 8;
+    }
+
+    public static bool IsBeginPhase(TAG_STEP step)
+    {
+        if ((uint)step <= 4u)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static bool IsPastBeginPhase(TAG_STEP step)
+    {
+        return !IsBeginPhase(step);
+    }
+
+    public static bool IsMainPhase(TAG_STEP step)
+    {
+        if ((uint)(step - 5) <= 8u || (uint)(step - 16) <= 4u)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static List<Entity> GetEntitiesKilledBySourceAmongstTargets(int damageSourceID, List<Entity> targetEntities)
+    {
+        List<Entity> list = new List<Entity>();
+        foreach (Entity targetEntity in targetEntities)
+        {
+            if (targetEntity != null)
+            {
+                list.Add(targetEntity.CloneForZoneMgr());
+            }
+        }
+        List<Entity> list2 = new List<Entity>();
+        PowerProcessor powerProcessor = GameState.Get().GetPowerProcessor();
+        List<PowerTaskList> list3 = new List<PowerTaskList>();
+        if (powerProcessor.GetCurrentTaskList() != null)
+        {
+            list3.Add(powerProcessor.GetCurrentTaskList());
+        }
+        list3.AddRange(powerProcessor.GetPowerQueue().GetList());
+        for (int i = 0; i < list3.Count; i++)
+        {
+            List<PowerTask> taskList = list3[i].GetTaskList();
+            for (int j = 0; j < taskList.Count; j++)
+            {
+                PowerTask powerTask = taskList[j];
+                Network.HistTagChange tagChange = powerTask.GetPower() as Network.HistTagChange;
+                if (tagChange == null)
+                {
+                    continue;
+                }
+                if (tagChange.Tag == 18)
+                {
+                    list.Find((Entity targetEntity) => targetEntity.GetEntityId() == tagChange.Entity)?.SetTag(18, tagChange.Value);
+                }
+                else if (tagChange.Tag == 49 && tagChange.Value == 4)
+                {
+                    Entity entity = list.Find((Entity targetEntity) => targetEntity.GetEntityId() == tagChange.Entity);
+                    if (entity != null && entity.GetTag(GAME_TAG.LAST_AFFECTED_BY) == damageSourceID)
+                    {
+                        list2.Add(entity);
+                    }
+                }
+            }
+        }
+        return list2;
+    }
+
+    public static void ApplyPower(Entity entity, Network.PowerHistory power)
+    {
+        switch (power.Type)
+        {
+            case Network.PowerType.SHOW_ENTITY:
+                ApplyShowEntity(entity, (Network.HistShowEntity)power);
+                break;
+            case Network.PowerType.HIDE_ENTITY:
+                ApplyHideEntity(entity, (Network.HistHideEntity)power);
+                break;
+            case Network.PowerType.TAG_CHANGE:
+                ApplyTagChange(entity, (Network.HistTagChange)power);
+                break;
+        }
+    }
+
+    public static void ApplyShowEntity(Entity entity, Network.HistShowEntity showEntity)
+    {
+        foreach (Network.Entity.Tag tag in showEntity.Entity.Tags)
+        {
+            entity.SetTag(tag.Name, tag.Value);
+        }
+    }
+
+    public static void ApplyHideEntity(Entity entity, Network.HistHideEntity hideEntity)
+    {
+        entity.SetTag(GAME_TAG.ZONE, hideEntity.Zone);
+    }
+
+    public static void ApplyTagChange(Entity entity, Network.HistTagChange tagChange)
+    {
+        entity.SetTag(tagChange.Tag, tagChange.Value);
+    }
+
+    public static TAG_ZONE GetFinalZoneForEntity(Entity entity)
+    {
+        PowerProcessor powerProcessor = GameState.Get().GetPowerProcessor();
+        List<PowerTaskList> list = new List<PowerTaskList>();
+        if (powerProcessor.GetCurrentTaskList() != null)
+        {
+            list.Add(powerProcessor.GetCurrentTaskList());
+        }
+        list.AddRange(powerProcessor.GetPowerQueue().GetList());
+        for (int num = list.Count - 1; num >= 0; num--)
+        {
+            List<PowerTask> taskList = list[num].GetTaskList();
+            for (int num2 = taskList.Count - 1; num2 >= 0; num2--)
+            {
+				if (taskList[num2].GetPower() is Network.HistTagChange histTagChange && histTagChange.Entity == entity.GetEntityId() && (histTagChange.Tag == 49 || histTagChange.Tag == 1702))
+                {
+                    return (TAG_ZONE)histTagChange.Value;
+                }
+            }
+        }
+        TAG_ZONE tag = entity.GetTag<TAG_ZONE>(GAME_TAG.FAKE_ZONE);
+        if (tag != 0)
+        {
+            return tag;
+        }
+        return entity.GetZone();
+    }
+
+    public static bool IsEntityHiddenAfterCurrentTasklist(Entity entity)
+    {
+        if (!entity.IsHidden())
+        {
+            return false;
+        }
+        PowerProcessor powerProcessor = GameState.Get().GetPowerProcessor();
+        if (powerProcessor.GetCurrentTaskList() != null)
+        {
+            foreach (PowerTask task in powerProcessor.GetCurrentTaskList().GetTaskList())
+            {
+				if (task.GetPower() is Network.HistShowEntity histShowEntity && histShowEntity.Entity.ID == entity.GetEntityId() && !string.IsNullOrEmpty(histShowEntity.Entity.CardID))
+                {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    public static bool IsGalakrond(string cardId)
+    {
+        switch (cardId)
+        {
+            case "DRG_600":
+            case "DRG_600t2":
+            case "DRG_600t3":
+            case "DRG_650":
+            case "DRG_650t2":
+            case "DRG_650t3":
+            case "DRG_620":
+            case "DRG_620t2":
+            case "DRG_620t3":
+            case "DRG_660":
+            case "DRG_660t2":
+            case "DRG_660t3":
+            case "DRG_610":
+            case "DRG_610t2":
+            case "DRG_610t3":
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    public static bool IsGalakrondInPlay(Player player)
+    {
+        if (player == null)
+        {
+            return false;
+        }
+        Entity hero = player.GetHero();
+        if (hero == null)
+        {
+            return false;
+        }
+        return IsGalakrond(hero.GetCardId());
+    }
+
+    public static void DoDamageTasks(PowerTaskList powerTaskList, Card sourceCard, Card targetCard)
+    {
+        List<PowerTask> taskList = powerTaskList.GetTaskList();
+        if (taskList == null || taskList.Count == 0)
+        {
+            return;
+        }
+        int entityId = sourceCard.GetEntity().GetEntityId();
+        int entityId2 = targetCard.GetEntity().GetEntityId();
+        foreach (PowerTask item in taskList)
+        {
+            Network.PowerHistory power = item.GetPower();
+            if (power.Type == Network.PowerType.META_DATA)
+            {
+                Network.HistMetaData histMetaData = (Network.HistMetaData)power;
+                if (histMetaData.MetaType != HistoryMeta.Type.DAMAGE && histMetaData.MetaType != HistoryMeta.Type.HEALING)
+                {
+                    continue;
+                }
+                foreach (int item2 in histMetaData.Info)
+                {
+                    if (item2 == entityId || item2 == entityId2)
+                    {
+                        item.DoTask();
+                    }
+                }
+            }
+            else
+            {
+                if (power.Type != Network.PowerType.TAG_CHANGE)
+                {
+                    continue;
+                }
+                Network.HistTagChange histTagChange = (Network.HistTagChange)power;
+                if (histTagChange.Entity == entityId || histTagChange.Entity == entityId2)
+                {
+                    GAME_TAG tag = (GAME_TAG)histTagChange.Tag;
+                    if (tag == GAME_TAG.DAMAGE || tag == GAME_TAG.EXHAUSTED)
+                    {
+                        item.DoTask();
+                    }
+                }
+            }
+        }
+    }
+
+    public static AdventureDbfRecord GetAdventureRecordFromMissionId(int missionId)
+    {
+        ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
+        if (record == null)
+        {
+            return null;
+        }
+        int adventureId = record.AdventureId;
+        return GameDbf.Adventure.GetRecord(adventureId);
+    }
+
+    public static WingDbfRecord GetWingRecordFromMissionId(int missionId)
+    {
+        WingDbId wingIdFromMissionId = GetWingIdFromMissionId((ScenarioDbId)missionId);
+        if (wingIdFromMissionId == WingDbId.INVALID)
+        {
+            return null;
+        }
+        return GameDbf.Wing.GetRecord((int)wingIdFromMissionId);
+    }
+
+    public static WingDbId GetWingIdFromMissionId(ScenarioDbId missionId)
+    {
+        return (WingDbId)(GameDbf.Scenario.GetRecord((int)missionId)?.WingId ?? 0);
+    }
+
+    public static AdventureDataDbfRecord GetAdventureDataRecord(int adventureId, int modeId)
+    {
+        foreach (AdventureDataDbfRecord record in GameDbf.AdventureData.GetRecords())
+        {
+            if (record.AdventureId == adventureId && record.ModeId == modeId)
+            {
+                return record;
+            }
+        }
+        return null;
+    }
+
+    public static List<ScenarioDbfRecord> GetClassChallengeRecords(int adventureId, int wingId)
+    {
+        List<ScenarioDbfRecord> list = new List<ScenarioDbfRecord>();
+        foreach (ScenarioDbfRecord record in GameDbf.Scenario.GetRecords())
+        {
+            if (record.ModeId == 4 && record.AdventureId == adventureId && record.WingId == wingId)
+            {
+                list.Add(record);
+            }
+        }
+        return list;
+    }
+
+    public static TAG_CLASS GetClassChallengeHeroClass(ScenarioDbfRecord rec)
+    {
+        if (rec.ModeId != 4)
+        {
+            return TAG_CLASS.INVALID;
+        }
+        int player1HeroCardId = rec.Player1HeroCardId;
+        return DefLoader.Get().GetEntityDef(player1HeroCardId)?.GetClass() ?? TAG_CLASS.INVALID;
+    }
+
+    public static List<TAG_CLASS> GetClassChallengeHeroClasses(int adventureId, int wingId)
+    {
+        List<ScenarioDbfRecord> classChallengeRecords = GetClassChallengeRecords(adventureId, wingId);
+        List<TAG_CLASS> list = new List<TAG_CLASS>();
+        foreach (ScenarioDbfRecord item in classChallengeRecords)
+        {
+            list.Add(GetClassChallengeHeroClass(item));
+        }
+        return list;
+    }
+
+    public static bool IsAIMission(int missionId)
+    {
+        ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
+        if (record == null)
+        {
+            return false;
+        }
+        if (record.Players == 1)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static bool IsCoopMission(int missionId)
+    {
+        return GameDbf.Scenario.GetRecord(missionId)?.IsCoop ?? false;
+    }
+
+    public static bool IsMercenariesMission(int missionid)
+    {
+        if (missionid != 3778 && missionid != 3900 && missionid != 3901 && missionid != 4067 && missionid != 3779 && missionid != 3744 && missionid != 3792 && missionid != 3790 && missionid != 3899)
+        {
+            return missionid == 3862;
+        }
+        return true;
+    }
+
+    public static string GetMissionHeroCardId(int missionId)
+    {
+        ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
+        if (record == null)
+        {
+            return null;
+        }
+        int num = record.ClientPlayer2HeroCardId;
+        if (num == 0)
+        {
+            num = record.Player2HeroCardId;
+        }
+        return TranslateDbIdToCardId(num);
+    }
+
+    public static string GetMissionHeroName(int missionId)
+    {
+        string missionHeroCardId = GetMissionHeroCardId(missionId);
+        if (missionHeroCardId == null)
+        {
+            return null;
+        }
+        EntityDef entityDef = DefLoader.Get().GetEntityDef(missionHeroCardId);
+        if (entityDef == null)
+        {
+            Debug.LogError($"GameUtils.GetMissionHeroName() - hero {missionHeroCardId} for mission {missionId} has no EntityDef");
+            return null;
+        }
+        return entityDef.GetName();
+    }
+
+    public static string GetMissionHeroPowerCardId(int missionId)
+    {
+        ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
+        if (record == null)
+        {
+            return null;
+        }
+        int clientPlayer2HeroPowerCardId = record.ClientPlayer2HeroPowerCardId;
+        if (clientPlayer2HeroPowerCardId != 0)
+        {
+            return TranslateDbIdToCardId(clientPlayer2HeroPowerCardId);
+        }
+        int num = record.ClientPlayer2HeroCardId;
+        if (num == 0)
+        {
+            num = record.Player2HeroCardId;
+        }
+        return GetHeroPowerCardIdFromHero(num);
+    }
+
+    public static bool IsMissionForAdventure(int missionId, int adventureId)
+    {
+        ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
+        if (record == null)
+        {
+            return false;
+        }
+        return adventureId == record.AdventureId;
+    }
+
+    public static bool IsTutorialMission(int missionId)
+    {
+        return IsMissionForAdventure(missionId, 1);
+    }
+
+    public static bool IsPracticeMission(int missionId)
+    {
+        return IsMissionForAdventure(missionId, 2);
+    }
+
+    public static bool IsDungeonCrawlMission(int missionId)
+    {
+        ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
+        if (record == null)
+        {
+            return false;
+        }
+        return DoesAdventureModeUseDungeonCrawlFormat((AdventureModeDbId)record.ModeId);
+    }
+
+    public static bool DoesAdventureModeUseDungeonCrawlFormat(AdventureModeDbId modeId)
+    {
+        if (modeId != AdventureModeDbId.DUNGEON_CRAWL)
+        {
+            return modeId == AdventureModeDbId.DUNGEON_CRAWL_HEROIC;
+        }
+        return true;
+    }
+
+    public static bool IsBoosterLatestActiveExpansion(int boosterId)
+    {
+        return boosterId == (int)GetLatestRewardableBooster();
+    }
+
+    public static BoosterDbId GetLatestRewardableBooster()
+    {
+        return GetRewardableBoosterOffsetFromLatest(0);
+    }
+
+    public static BoosterDbId GetRewardableBoosterOffsetFromLatest(int offset)
+    {
+        List<BoosterDbfRecord> rewardableBoosters = GetRewardableBoosters();
+        if (rewardableBoosters.Count <= 0)
+        {
+            Debug.LogError("No active Booster sets found");
+            return BoosterDbId.INVALID;
+        }
+        offset = Mathf.Clamp(offset, 0, rewardableBoosters.Count - 1);
+        return (BoosterDbId)rewardableBoosters[offset].ID;
+    }
 
-	public static bool LoadAndPositionCardActor(string actorName, string heroCardID, TAG_PREMIUM premium, LoadActorCallback callback)
+	public static BoosterDbId GetLatestCatchupPack()
 	{
-		if (!string.IsNullOrEmpty(heroCardID))
+		BoosterDbfRecord boosterDbfRecord = null;
+		DateTime? dateTime = null;
+		foreach (BoosterDbfRecord record in GameDbf.Booster.GetRecords())
 		{
-			DefLoader.Get().LoadFullDef(heroCardID, delegate(string cardID, DefLoader.DisposableFullDef def, object userData)
+			if (!record.IsCatchupPack)
 			{
-				LoadAndPositionCardActor_OnFullDefLoaded(actorName, cardID, def, userData, callback);
-			}, premium);
-			return true;
+				continue;
+			}
+			DateTime? eventStartTimeUtc = EventTimingManager.Get().GetEventStartTimeUtc(record.ShownToClientEvent);
+			if (!eventStartTimeUtc.HasValue || eventStartTimeUtc > DateTime.UtcNow)
+			{
+				DateTime? eventStartTimeUtc2 = EventTimingManager.Get().GetEventStartTimeUtc(record.OpenPackEvent);
+				if (boosterDbfRecord == null || (eventStartTimeUtc2.HasValue && EventTimingManager.Get().IsEventActive(record.OpenPackEvent) && eventStartTimeUtc2.Value > dateTime.Value))
+				{
+					boosterDbfRecord = record;
+					dateTime = eventStartTimeUtc2;
+				}
+			}
 		}
-		return false;
+		return (BoosterDbId)boosterDbfRecord.ID;
 	}
 
-	private static void LoadAndPositionCardActor_OnFullDefLoaded(string actorName, string cardID, DefLoader.DisposableFullDef def, object userData, LoadActorCallback callback)
-	{
-		TAG_PREMIUM premium = (TAG_PREMIUM)userData;
-		LoadActorCallbackInfo callbackData2 = new LoadActorCallbackInfo
-		{
-			fullDef = def,
-			premium = premium
+    public static BoosterDbId GetRewardableBoosterFromSelector(RewardItem.BoosterSelector selector)
+    {
+        switch (selector)
+        {
+            case RewardItem.BoosterSelector.LATEST:
+                return GetRewardableBoosterOffsetFromLatest(0);
+            case RewardItem.BoosterSelector.LATEST_OFFSET_BY_1:
+                return GetRewardableBoosterOffsetFromLatest(1);
+            case RewardItem.BoosterSelector.LATEST_OFFSET_BY_2:
+                return GetRewardableBoosterOffsetFromLatest(2);
+            case RewardItem.BoosterSelector.LATEST_OFFSET_BY_3:
+                return GetRewardableBoosterOffsetFromLatest(3);
+		case RewardItem.BoosterSelector.LATEST_CATCHUP_PACK:
+			return GetLatestCatchupPack();
+            default:
+                Debug.LogError($"Unknown BoosterSelector {selector}");
+                return BoosterDbId.INVALID;
+        }
+    }
+
+    public static AdventureDbId GetLatestActiveAdventure()
+    {
+        AdventureDbId adventureDbId = AdventureDbId.INVALID;
+        foreach (AdventureDbfRecord record in GameDbf.Adventure.GetRecords())
+        {
+            AdventureDbId iD = (AdventureDbId)record.ID;
+            if (!AdventureConfig.IsAdventureComingSoon(iD) && AdventureConfig.IsAdventureEventActive(iD) && iD > adventureDbId)
+            {
+                adventureDbId = iD;
+            }
+        }
+        return adventureDbId;
+    }
+
+    public static bool IsExpansionMission(int missionId)
+    {
+        ScenarioDbfRecord record = GameDbf.Scenario.GetRecord(missionId);
+        if (record == null)
+        {
+            return false;
+        }
+        int adventureId = record.AdventureId;
+        if (adventureId == 0)
+        {
+            return false;
+        }
+        return IsExpansionAdventure((AdventureDbId)adventureId);
+    }
+
+    public static bool IsExpansionAdventure(AdventureDbId adventureId)
+    {
+		switch (adventureId)
+        {
+		case AdventureDbId.INVALID:
+		case AdventureDbId.TUTORIAL:
+		case AdventureDbId.PRACTICE:
+		case AdventureDbId.TAVERN_BRAWL:
+		case AdventureDbId.RETURNING_PLAYER:
+		case AdventureDbId.MERCENARY_PVE:
+		case AdventureDbId.BOTS_ON_LADDER:
+            return false;
+		default:
+        return true;
+    }
+	}
+
+    public static string GetAdventureProductStringKey(int wingID)
+    {
+        AdventureDbId adventureIdByWingId = GetAdventureIdByWingId(wingID);
+        if (adventureIdByWingId != 0)
+        {
+            return GameDbf.Adventure.GetRecord((int)adventureIdByWingId).ProductStringKey;
+        }
+        return string.Empty;
+    }
+
+    public static AdventureDbId GetAdventureId(int missionId)
+    {
+        return (AdventureDbId)(GameDbf.Scenario.GetRecord(missionId)?.AdventureId ?? 0);
+    }
+
+    public static AdventureDbId GetAdventureIdByWingId(int wingID)
+    {
+        WingDbfRecord record = GameDbf.Wing.GetRecord(wingID);
+        if (record == null)
+        {
+            return AdventureDbId.INVALID;
+        }
+        AdventureDbId adventureId = (AdventureDbId)record.AdventureId;
+        if (!IsExpansionAdventure(adventureId))
+        {
+            return AdventureDbId.INVALID;
+        }
+        return adventureId;
+    }
+
+    public static AdventureModeDbId GetAdventureModeId(int missionId)
+    {
+        return (AdventureModeDbId)(GameDbf.Scenario.GetRecord(missionId)?.ModeId ?? 0);
+    }
+
+    public static bool IsHeroicAdventureMission(int missionId)
+    {
+        return IsModeHeroic(GetAdventureModeId(missionId));
+    }
+
+    public static bool IsModeHeroic(AdventureModeDbId mode)
+    {
+        if (mode != AdventureModeDbId.LINEAR_HEROIC)
+        {
+            return mode == AdventureModeDbId.DUNGEON_CRAWL_HEROIC;
+        }
+        return true;
+    }
+
+    public static AdventureModeDbId GetNormalModeFromHeroicMode(AdventureModeDbId mode)
+    {
+		return mode switch
+        {
+			AdventureModeDbId.DUNGEON_CRAWL_HEROIC => AdventureModeDbId.DUNGEON_CRAWL, 
+			AdventureModeDbId.LINEAR_HEROIC => AdventureModeDbId.LINEAR, 
+			_ => mode, 
 		};
-		AssetLoader.Get().InstantiatePrefab(actorName, delegate(AssetReference assetRef, GameObject go, object callbackData)
-		{
-			LoadAndPositionActorCard_OnActorLoaded(assetRef, go, callbackData, callback);
-		}, callbackData2, AssetLoadingOptions.IgnorePrefabPosition);
-	}
+    }
+
+    public static bool IsClassChallengeMission(int missionId)
+    {
+        return GetAdventureModeId(missionId) == AdventureModeDbId.CLASS_CHALLENGE;
+    }
+
+    public static int GetSortedWingUnlockIndex(WingDbfRecord wingRecord)
+    {
+        List<WingDbfRecord> records = GameDbf.Wing.GetRecords((WingDbfRecord r) => r.AdventureId == wingRecord.AdventureId);
+        bool wingsHaveSameUnlockOrder = false;
+        records.Sort(delegate (WingDbfRecord l, WingDbfRecord r)
+        {
+            int num = l.UnlockOrder - r.UnlockOrder;
+            if (num == 0 && l.ID != r.ID)
+            {
+                wingsHaveSameUnlockOrder = true;
+            }
+            return num;
+        });
+        if (wingsHaveSameUnlockOrder)
+        {
+            return 0;
+        }
+        return records.FindIndex((WingDbfRecord r) => r.ID == wingRecord.ID);
+    }
+
+    public static int GetNumWingsInAdventure(AdventureDbId adventureId)
+    {
+        return GameDbf.Wing.GetRecords((WingDbfRecord r) => r.AdventureId == (int)adventureId).Count;
+    }
 
-	private static void LoadAndPositionActorCard_OnActorLoaded(AssetReference assetRef, GameObject go, object callbackData, LoadActorCallback callback)
+	public static void ReplayTraditionalTutorial()
 	{
-		LoadActorCallbackInfo loadActorCallbackInfo = callbackData as LoadActorCallbackInfo;
-		using (loadActorCallbackInfo.fullDef)
+		if (s_profileProgress.Value != null)
 		{
-			if (go == null)
+			SetTutorialProgress(TutorialProgress.NOTHING_COMPLETE, tutorialComplete: false);
+			if (!TutorialProgressScreen.HasEverOpenedRewardChest())
 			{
-				Debug.LogWarning($"GameUtils.OnHeroActorLoaded() - FAILED to load actor \"{assetRef}\"");
-				return;
+				TutorialProgressScreen.SetHasEverOpenedRewardChest();
 			}
-			Actor component = go.GetComponent<Actor>();
-			if (component == null)
+			if (Network.ShouldBeConnectedToAurora() && Network.IsLoggedIn())
 			{
-				Debug.LogWarning($"GameUtils.OnActorLoaded() - ERROR actor \"{assetRef}\" has no Actor component");
-				return;
+				BnetPresenceMgr.Get().SetGameField(15u, 0);
 			}
-			component.SetPremium(loadActorCallbackInfo.premium);
-			component.SetEntityDef(loadActorCallbackInfo.fullDef.EntityDef);
-			component.SetCardDef(loadActorCallbackInfo.fullDef.DisposableCardDef);
-			component.UpdateAllComponents();
-			component.gameObject.name = loadActorCallbackInfo.fullDef.CardDef.name + "_actor";
-			if ((bool)UniversalInputManager.UsePhoneUI)
+			GameMgr.Get().FindGame(GameType.GT_TUTORIAL, FormatType.FT_WILD, GetNextTutorial(), 0, 0L, null, null, restoreSavedGameState: false, null, null, 0L);
+		}
+	}
+
+    public static void CompleteTraditionalTutorial()
+    {
+        NetCache.NetCacheProfileProgress value = s_profileProgress.Value;
+		if (value != null && !IsTraditionalTutorialComplete(value))
+        {
+			if (GameState.Get().GetGameEntity() is TutorialEntity tutorialEntity)
 			{
-				LayerUtils.SetLayer(component.gameObject, GameLayer.IgnoreFullScreenEffects);
+				tutorialEntity.ClearPreTutorialNotification();
 			}
-			GemObject healthObject = component.GetHealthObject();
-			if (healthObject != null)
+			SetTutorialProgress(TutorialProgress.LICH_KING_COMPLETE, tutorialComplete: true);
+            if (Network.ShouldBeConnectedToAurora() && Network.IsLoggedIn())
+            {
+                BnetPresenceMgr.Get().SetGameField(15u, 1);
+            }
+            NotificationManager.Get().DestroyAllPopUps();
+			BnetBar bnetBar = BnetBar.Get();
+			if (bnetBar != null)
 			{
-				healthObject.Hide();
+				bnetBar.HideSkipTutorialButton();
 			}
-			callback?.Invoke(component);
-		}
+			if (!DialogManager.Get().ShowInitialDownloadPopupDuringDownload())
+			{
+            SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
+        }
+    }
 	}
 
-	public static bool IsBoosterWild(BoosterDbId boosterId)
+	public static void SetTutorialProgress(TutorialProgress progress, bool tutorialComplete)
+    {
+        if (!GameMgr.Get().IsSpectator())
+        {
+			AdTrackingManager.Get().TrackTutorialProgress(progress);
+            NetCache.NetCacheProfileProgress netObject = NetCache.Get().GetNetObject<NetCache.NetCacheProfileProgress>();
+            if (netObject != null)
+            {
+				netObject.CampaignProgress = progress;
+				netObject.TutorialComplete = tutorialComplete;
+            }
+            NetCache.Get().NetCacheChanged<NetCache.NetCacheProfileProgress>();
+        }
+    }
+
+    public static bool IsTraditionalTutorialComplete()
+    {
+        NetCache.NetCacheProfileProgress value = s_profileProgress.Value;
+        if (value != null)
+        {
+			return IsTraditionalTutorialComplete(value);
+        }
+        return false;
+    }
+
+	public static bool HasEverCompletedTraditionalTutorial()
 	{
-		if (boosterId == BoosterDbId.INVALID)
+		if (!GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.PLAYER_FLAGS, GameSaveKeySubkeyId.PLAYER_FLAGS_HAS_EVER_COMPLETED_TRADITIONAL_TUTORIAL, out long value))
 		{
 			return false;
 		}
-		return IsBoosterWild(GameDbf.Booster.GetRecord((int)boosterId));
+		return value != 0;
 	}
 
-	public static bool IsBoosterWild(BoosterDbfRecord boosterRecord)
-	{
-		if (boosterRecord != null)
+	public static bool AreAllTutorialsComplete(NetCache.NetCacheProfileProgress profileProgress)
+    {
+		if (!IsTraditionalTutorialComplete(profileProgress))
+        {
+            return false;
+        }
+        if (!IsBattleGroundsTutorialComplete())
+        {
+            return false;
+        }
+        return IsMercenariesVillageTutorialComplete();
+    }
+
+	public static bool IsTraditionalTutorialComplete(NetCache.NetCacheProfileProgress profileProgress)
+    {
+        if (DemoMgr.Get().GetMode() == DemoMode.BLIZZ_MUSEUM)
+        {
+            return false;
+        }
+		if (!profileProgress.TutorialComplete)
 		{
-			EventTimingType standardEvent = boosterRecord.StandardEvent;
-			if (standardEvent != EventTimingType.UNKNOWN && standardEvent != 0 && EventTimingManager.Get().HasEventEnded(standardEvent))
-			{
-				return true;
-			}
+			return profileProgress.CampaignProgress >= TutorialProgress.LICH_KING_COMPLETE;
 		}
-		return false;
-	}
+		return true;
+    }
+
+    public static bool CanCheckTutorialCompletion()
+    {
+        if (!GameSaveDataManager.Get().IsDataReady(GameSaveKeyId.BACON))
+        {
+            return false;
+        }
+        if (!GameSaveDataManager.Get().IsDataReady(GameSaveKeyId.MERCENARIES))
+        {
+            return false;
+        }
+        if (s_profileProgress.Value == null)
+        {
+            return false;
+        }
+        return true;
+    }
+
+    public static bool IsAnyTutorialComplete()
+    {
+        if (IsBattleGroundsTutorialComplete())
+        {
+            return true;
+        }
+        if (IsMercenariesVillageTutorialComplete())
+        {
+            return true;
+        }
+        NetCache.NetCacheProfileProgress value = s_profileProgress.Value;
+        if (value == null)
+        {
+            return false;
+        }
+		return IsTraditionalTutorialComplete(value);
+    }
+
+    public static bool IsBattleGroundsTutorialComplete()
+    {
+        NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+        bool flag = false;
+        if (netObject != null)
+        {
+            flag = !netObject.Games.BattlegroundsTutorial;
+        }
+        if (flag)
+        {
+            return false;
+        }
+		if (GameSaveDataManager.Get() == null || !GameSaveDataManager.Get().IsDataReady(GameSaveKeyId.BACON))
+		{
+			return false;
+		}
+        long value = 0L;
+        GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.BACON, GameSaveKeySubkeyId.BACON_HAS_SEEN_TUTORIAL, out value);
+        return value > 0;
+    }
+
+    public static bool IsMercenariesPrologueBountyComplete(NetCache.NetCacheMercenariesPlayerInfo playerInfo)
+    {
+        if (playerInfo == null)
+        {
+            Debug.LogError("Player Info was null when check prologue bounty completion.  This should be checked before entering this function or undesirable results may occur");
+            return false;
+        }
+        List<LettuceBountyDbfRecord> list = GameDbf.LettuceBounty.GetRecords((LettuceBountyDbfRecord r) => r.BountySetRecord != null && r.BountySetRecord.IsTutorial && r.Enabled).ToList();
+        if (list.Count <= 0)
+        {
+            return false;
+        }
+        return MercenariesDataUtil.IsBountyComplete(list[0].ID, playerInfo);
+    }
+
+    public static bool IsMercenariesVillageTutorialComplete()
+    {
+        return LettuceTutorialUtils.IsSpecificEventComplete(LettuceTutorialVo.LettuceTutorialEvent.VILLAGE_TUTORIAL_END);
+    }
 
-	public static bool IsAdventureWild(AdventureDbId adventureId)
+	public static bool HasCompletedApprentice()
 	{
-		if (adventureId == AdventureDbId.INVALID)
+		GameSaveDataManager gameSaveDataManager = GameSaveDataManager.Get();
+		if (!gameSaveDataManager.IsDataReady(GameSaveKeyId.PLAYER_FLAGS))
 		{
-			return false;
+			return true;
 		}
-		AdventureDbfRecord record = GameDbf.Adventure.GetRecord((int)adventureId);
-		if (record != null)
+		if (gameSaveDataManager.GetSubkeyValue(GameSaveKeyId.PLAYER_FLAGS, GameSaveKeySubkeyId.PLAYER_FLAGS_HAS_COMPLETED_APPRENTICE, out long value))
 		{
-			EventTimingType standardEvent = record.StandardEvent;
-			if (standardEvent != EventTimingType.UNKNOWN && standardEvent != 0 && EventTimingManager.Get().HasEventEnded(standardEvent))
-			{
-				return true;
-			}
+			return value > 0;
 		}
 		return false;
 	}
 
-	private static bool GetSeasonMonthAndYear(int seasonId, int startId, int startMonth, int startYear, out int month, out int year)
+	public static bool CanSkipApprentice()
 	{
-		month = 0;
-		year = 0;
-		if (seasonId < startId)
+		if (!HasCompletedApprentice())
 		{
-			Debug.LogFormat("GetSeasonMonthAndYear called with invalid seasonId {0}. Launch season is 6.", seasonId);
-			return false;
+			return IsTraditionalTutorialComplete();
 		}
-		int num = seasonId - startId + startMonth - 1;
-		month = num % 12 + 1;
-		year = startYear + num / 12;
-		return true;
+		return false;
 	}
 
-	private static string GetSeasonName(int seasonId, int startId, int startMonth, int startYear)
+	public static bool ShouldSkipRailroading()
 	{
-		if (!GetSeasonMonthAndYear(seasonId, startId, startMonth, startYear, out var month, out var year))
-		{
-			return null;
-		}
-		string key = $"GLUE_RANKED_SEASON_NAME_{seasonId}";
-		string monthFromDigits = GameStrings.GetMonthFromDigits(month);
-		if (GameStrings.HasKey(key))
+		GameSaveDataManager gameSaveDataManager = GameSaveDataManager.Get();
+		if (!gameSaveDataManager.IsDataReady(GameSaveKeyId.FTUE))
 		{
-			return GameStrings.Format(key, monthFromDigits, year, seasonId);
+			return true;
 		}
-		return GameStrings.Format("GLUE_RANKED_SEASON_NAME_GENERIC", monthFromDigits, year, seasonId);
-	}
-
-	public static string GetRankedSeasonName(int seasonId)
-	{
-		return GetSeasonName(seasonId, 6, 4, 2014);
+		gameSaveDataManager.GetSubkeyValue(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.SHOULD_SKIP_RAILROADING, out long value);
+		return value == 1;
 	}
 
-	public static string GetMercenariesSeasonName(int seasonId)
-	{
-		return GetSeasonName(seasonId, 1, 11, 2021);
-	}
+    public static bool AreAllTutorialsComplete()
+    {
+        NetCache.NetCacheProfileProgress value = s_profileProgress.Value;
+        if (value != null)
+        {
+			return AreAllTutorialsComplete(value);
+        }
+        return false;
+    }
+
+    public static bool TutorialPreviewVideosEnabled()
+    {
+        // These videos are not accessible and they break tutorials
+        return false;
+
+        NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+        if (netObject == null)
+        {
+            Log.All.Print(" Could not get NetCacheFeatures Object");
+            return true;
+        }
+        return netObject.TutorialPreviewVideosEnabled;
+    }
+
+    public static float TutorialPreviewVideosTimeout()
+    {
+        NetCache.NetCacheFeatures netObject = NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>();
+        if (netObject == null)
+        {
+            Log.All.Print(" Could not get NetCacheFeatures Object");
+            return NetCache.NetCacheFeatures.Defaults.TutorialPreviewVideosTimeout;
+        }
+        return netObject.TutorialPreviewVideosTimeout;
+    }
 
-	public static string GetMercenariesSeasonEndDescription(int seasonId, int highestRating)
-	{
-		if (!GetSeasonMonthAndYear(seasonId, 1, 11, 2021, out var month, out var year))
+	public static int GetNextTutorial(NetCache.NetCacheProfileProgress progress)
+    {
+		if (progress.TutorialComplete)
+        {
+                return 0;
+        }
+		if (progress.CampaignProgress == TutorialProgress.NOTHING_COMPLETE)
 		{
-			return null;
+			return 5287;
 		}
-		string monthFromDigits = GameStrings.GetMonthFromDigits(month);
-		return GameStrings.Format("GLUE_LETTUCE_SEASON_ROLL_DESC", monthFromDigits, year, highestRating);
-	}
-
-	public static bool IsGSDFlagSet(GameSaveKeyId saveKey, GameSaveKeySubkeyId subkey)
-	{
-		if (!GameSaveDataManager.Get().IsDataReady(saveKey))
+		if (progress.CampaignProgress == TutorialProgress.REXXAR_COMPLETE)
 		{
-			return false;
+			return 5289;
 		}
-		GameSaveDataManager.Get().GetSubkeyValue(saveKey, subkey, out long value);
-		return value > 0;
-	}
-
-	public static void SetGSDFlag(GameSaveKeyId saveKey, GameSaveKeySubkeyId subkey, bool enableFlag)
-	{
-		if (IsGSDFlagSet(saveKey, subkey) != enableFlag)
+		if (progress.CampaignProgress == TutorialProgress.GARROSH_COMPLETE)
 		{
-			int num = (enableFlag ? 1 : 0);
-			GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(saveKey, subkey, num));
+			return 5290;
 		}
-	}
+		return 0;
+    }
+
+    public static int GetNextTutorial()
+    {
+		NetCache.NetCacheProfileProgress netCacheProfileProgress = s_profileProgress.Value;
+		if (netCacheProfileProgress == null)
+        {
+			netCacheProfileProgress = new NetCache.NetCacheProfileProgress
+			{
+				CampaignProgress = Options.Get().GetEnum<TutorialProgress>(Option.LOCAL_TUTORIAL_PROGRESS),
+				TutorialComplete = false
+			};
+        }
+		return GetNextTutorial(netCacheProfileProgress);
+    }
+
+    public static string GetTutorialCardRewardDetails(int missionId)
+    {
+		switch ((ScenarioDbId)missionId)
+        {
+		case ScenarioDbId.TUTORIAL_REXXAR:
+                return GameStrings.Get("GLOBAL_REWARD_CARD_DETAILS_TUTORIAL01");
+		case ScenarioDbId.TUTORIAL_GARROSH:
+                return GameStrings.Get("GLOBAL_REWARD_CARD_DETAILS_TUTORIAL02");
+		case ScenarioDbId.TUTORIAL_LICH_KING:
+                return GameStrings.Get("GLOBAL_REWARD_CARD_DETAILS_TUTORIAL03");
+            default:
+                Debug.LogWarning($"GameUtils.GetTutorialCardRewardDetails(): no card reward details for mission {missionId}");
+                return "";
+        }
+    }
+
+    public static string GetCurrentTutorialCardRewardDetails()
+    {
+        return GetTutorialCardRewardDetails(GameMgr.Get().GetMissionId());
+    }
+
+    public static int MissionSortComparison(ScenarioDbfRecord rec1, ScenarioDbfRecord rec2)
+    {
+        return rec1.SortOrder - rec2.SortOrder;
+    }
+
+    public static List<ScenarioGuestHeroesDbfRecord> GetScenarioGuestHeroes(int scenarioId)
+    {
+        return GameDbf.ScenarioGuestHeroes.GetRecords((ScenarioGuestHeroesDbfRecord r) => r.ScenarioId == scenarioId);
+    }
+
+    public static int GetDefeatedBossCount()
+    {
+        int @int = Options.Get().GetInt(Option.SELECTED_ADVENTURE);
+        AdventureModeDbId int2 = (AdventureModeDbId)Options.Get().GetInt(Option.SELECTED_ADVENTURE_MODE);
+        AdventureDataDbfRecord adventureDataRecord = GetAdventureDataRecord(@int, (int)int2);
+        if (adventureDataRecord == null)
+        {
+            return 0;
+        }
+        GameSaveKeyId gameSaveDataServerKey = (GameSaveKeyId)adventureDataRecord.GameSaveDataServerKey;
+        if (!DungeonCrawlUtil.IsDungeonRunActive(gameSaveDataServerKey))
+        {
+            return 0;
+        }
+        List<long> values = null;
+        GameSaveDataManager.Get().GetSubkeyValue(gameSaveDataServerKey, GameSaveKeySubkeyId.DUNGEON_CRAWL_BOSSES_DEFEATED, out values);
+        return values?.Count ?? 0;
+    }
+
+    public static List<FixedRewardActionDbfRecord> GetFixedActionRecords(FixedRewardAction.Type actionType)
+    {
+        return GameDbf.GetIndex().GetFixedActionRecordsForType(actionType);
+    }
+
+    public static FixedRewardDbfRecord GetFixedRewardForCard(string cardID, TAG_PREMIUM premium)
+    {
+        int cardId = TranslateCardIdToDbId(cardID);
+        return GameDbf.GetIndex().GetFixedRewardRecordsForCardId(cardId, (int)premium);
+    }
+
+    public static List<FixedRewardMapDbfRecord> GetFixedRewardMapRecordsForAction(int actionID)
+    {
+        return GameDbf.GetIndex().GetFixedRewardMapRecordsForAction(actionID);
+    }
+
+    public static int GetFixedRewardCounterpartCardID(int cardID)
+    {
+        foreach (FixedRewardActionDbfRecord fixedActionRecord in GetFixedActionRecords(FixedRewardAction.Type.OWNS_COUNTERPART_CARD))
+        {
+			if (!EventTimingManager.Get().IsEventActive(fixedActionRecord.ActiveEvent))
+            {
+                continue;
+            }
+            foreach (FixedRewardMapDbfRecord item in GetFixedRewardMapRecordsForAction(fixedActionRecord.ID))
+            {
+                FixedRewardDbfRecord record = GameDbf.FixedReward.GetRecord(item.RewardId);
+                if (GetCardTagValue(record.CardId, GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID) == cardID)
+                {
+                    return record.CardId;
+                }
+            }
+        }
+        return 0;
+    }
+
+    public static string GetOwnedCounterpartCardIDForFormat(EntityDef cardDef, FormatType formatType, int minOwned)
+    {
+        string text = TranslateDbIdToCardId(cardDef.GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID));
+        if (text != null)
+        {
+            return text;
+        }
+        TAG_CARD_SET[] cardSetsInFormat = GetCardSetsInFormat(formatType);
+        CollectionManager collectionManager = CollectionManager.Get();
+        int? minOwned2 = minOwned;
+		TAG_CARD_SET[] theseCardSets = cardSetsInFormat;
+		foreach (CollectibleCard card in collectionManager.FindCards(null, null, null, theseCardSets, null, null, null, null, null, null, minOwned2).m_cards)
+        {
+            if (TranslateDbIdToCardId(card.GetEntityDef().GetTag(GAME_TAG.DECK_RULE_COUNT_AS_COPY_OF_CARD_ID)) == cardDef.GetCardId())
+            {
+				text = card.CardId;
+				break;
+            }
+        }
+        return text;
+    }
+
+    public static bool IsMatchmadeGameType(GameType gameType, int? missionId = null)
+    {
+        switch (gameType)
+        {
+            case GameType.GT_PVPDR_PAID:
+            case GameType.GT_PVPDR:
+                if (missionId.HasValue && DungeonCrawlUtil.IsPVPDRFriendlyEncounter(missionId.Value))
+                {
+                    return false;
+                }
+                return true;
+            case GameType.GT_ARENA:
+            case GameType.GT_RANKED:
+            case GameType.GT_CASUAL:
+            case GameType.GT_BATTLEGROUNDS:
+            case GameType.GT_MERCENARIES_PVP:
+		case GameType.GT_BATTLEGROUNDS_DUO:
+		case GameType.GT_BATTLEGROUNDS_DUO_VS_AI:
+                return true;
+            case GameType.GT_VS_AI:
+            case GameType.GT_VS_FRIEND:
+            case GameType.GT_TUTORIAL:
+            case GameType.GT_BATTLEGROUNDS_FRIENDLY:
+            case GameType.GT_MERCENARIES_PVE:
+            case GameType.GT_MERCENARIES_PVE_COOP:
+		case GameType.GT_BATTLEGROUNDS_DUO_FRIENDLY:
+                return false;
+            default:
+                if (IsTavernBrawlGameType(gameType))
+                {
+                    int num = 0;
+                    if (missionId.HasValue)
+                    {
+                        num = missionId.Value;
+                    }
+                    else
+                    {
+                        TavernBrawlMission tavernBrawlMission = TavernBrawlManager.Get().CurrentMission();
+                        if (tavernBrawlMission == null)
+                        {
+                            return true;
+                        }
+                        num = tavernBrawlMission.missionId;
+                    }
+                    if (IsAIMission(num))
+                    {
+                        return false;
+                    }
+                    return true;
+                }
+                return false;
+        }
+    }
 
-	public static bool IsGolden500HeroSkinAchievement(int achievementId)
+	public static bool IsBattlegroundsGameType(GameType gametype)
 	{
-		foreach (KeyValuePair<TAG_CLASS, HeroSkinAchievements> hERO_SKIN_ACHIEVEMENT in HERO_SKIN_ACHIEVEMENTS)
+		if (gametype != GameType.GT_BATTLEGROUNDS && gametype != GameType.GT_BATTLEGROUNDS_FRIENDLY && gametype != GameType.GT_BATTLEGROUNDS_PLAYER_VS_AI && gametype != GameType.GT_BATTLEGROUNDS_AI_VS_AI && gametype != GameType.GT_BATTLEGROUNDS_DUO && gametype != GameType.GT_BATTLEGROUNDS_DUO_VS_AI)
 		{
-			if (hERO_SKIN_ACHIEVEMENT.Value.Golden500Win == achievementId)
-			{
-				return true;
-			}
+			return gametype == GameType.GT_BATTLEGROUNDS_DUO_FRIENDLY;
 		}
-		return false;
+		return true;
 	}
 
-	public static bool IsHonored1KHeroSkinAchievement(int achievementId)
+    public static bool IsTavernBrawlGameType(GameType gameType)
+    {
+		if ((uint)(gameType - 16) <= 2u)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static bool IsPvpDrGameType(GameType gameType)
+    {
+        if ((uint)(gameType - 28) <= 1u)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static bool IsMercenariesGameType(GameType gameType)
+    {
+        if ((uint)(gameType - 30) <= 4u)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static bool ShouldShowArenaModeIcon()
+    {
+        return GameMgr.Get().GetGameType() == GameType.GT_ARENA;
+    }
+
+    public static bool ShouldShowCasualModeIcon()
+    {
+        return GameMgr.Get().GetGameType() == GameType.GT_CASUAL;
+    }
+
+    public static bool ShouldShowFriendlyChallengeIcon()
+    {
+        if (GameMgr.Get().GetGameType() == GameType.GT_VS_FRIEND)
+        {
+            if (FriendChallengeMgr.Get().IsChallengeTavernBrawl())
+            {
+                return false;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    public static bool ShouldShowTavernBrawlModeIcon()
+    {
+        GameType gameType = GameMgr.Get().GetGameType();
+        if (gameType == GameType.GT_VS_FRIEND && FriendChallengeMgr.Get().IsChallengeTavernBrawl())
+        {
+            return true;
+        }
+        if (IsTavernBrawlGameType(gameType))
+        {
+            return true;
+        }
+        return false;
+    }
+
+    public static bool ShouldShowAdventureModeIcon()
+    {
+        int missionId = GameMgr.Get().GetMissionId();
+        GameType gameType = GameMgr.Get().GetGameType();
+        AdventureDbId adventureId = GetAdventureId(missionId);
+        if (IsExpansionMission(missionId) && adventureId != AdventureDbId.TAVERN_BRAWL && !AdventureUtils.IsDuelsAdventure(adventureId) && !IsTavernBrawlGameType(gameType))
+        {
+            return !IsMercenariesGameType(gameType);
+        }
+        return false;
+    }
+
+    public static bool ShouldShowPvpDrModeIcon()
+    {
+        return AdventureUtils.IsDuelsAdventure(GetAdventureId(GameMgr.Get().GetMissionId()));
+    }
+
+    public static bool IsGameTypeRanked()
+    {
+        return IsGameTypeRanked(GameMgr.Get().GetGameType());
+    }
+
+    public static bool IsGameTypeRanked(GameType gameType)
+    {
+        if (DemoMgr.Get().IsExpoDemo())
+        {
+            return false;
+        }
+        return gameType == GameType.GT_RANKED;
+    }
+
+    public static void RequestPlayerPresence(BnetGameAccountId gameAccountId)
+    {
+        List<PresenceFieldKey> list = new List<PresenceFieldKey>();
+        PresenceFieldKey item = default(PresenceFieldKey);
+        item.programId = BnetProgramId.BNET.GetValue();
+        item.groupId = 2u;
+        item.fieldId = 7u;
+        item.uniqueId = 0uL;
+        list.Add(item);
+        item.programId = BnetProgramId.BNET.GetValue();
+        item.groupId = 2u;
+        item.fieldId = 3u;
+        item.uniqueId = 0uL;
+        list.Add(item);
+        item.programId = BnetProgramId.BNET.GetValue();
+        item.groupId = 2u;
+        item.fieldId = 5u;
+        item.uniqueId = 0uL;
+        list.Add(item);
+        if (IsGameTypeRanked())
+        {
+            PresenceFieldKey item2 = default(PresenceFieldKey);
+            item2.programId = BnetProgramId.HEARTHSTONE.GetValue();
+            item2.groupId = 2u;
+            item2.fieldId = 18u;
+            item2.uniqueId = 0uL;
+            list.Add(item2);
+        }
+        PresenceFieldKey[] fieldList = list.ToArray();
+        BattleNet.RequestPresenceFields(isGameAccountEntityId: true, gameAccountId, fieldList);
+    }
+
+    public static bool IsAIPlayer(BnetGameAccountId gameAccountId)
+    {
+        if (gameAccountId == null)
+        {
+            return false;
+        }
+        return !gameAccountId.IsValid();
+    }
+
+    public static bool IsHumanPlayer(BnetGameAccountId gameAccountId)
+    {
+        if (gameAccountId == null)
+        {
+            return false;
+        }
+        return gameAccountId.IsValid();
+    }
+
+    public static bool IsBnetPlayer(BnetGameAccountId gameAccountId)
+    {
+        if (!IsHumanPlayer(gameAccountId))
+        {
+            return false;
+        }
+        return Network.ShouldBeConnectedToAurora();
+    }
+
+    public static bool IsGuestPlayer(BnetGameAccountId gameAccountId)
+    {
+        if (!IsHumanPlayer(gameAccountId))
+        {
+            return false;
+        }
+        return !Network.ShouldBeConnectedToAurora();
+    }
+
+    public static bool IsAnyTransitionActive()
+    {
+        SceneMgr sceneMgr = SceneMgr.Get();
+        if (sceneMgr != null)
+        {
+            if (sceneMgr.IsTransitionNowOrPending())
+            {
+                return true;
+            }
+            PegasusScene scene = sceneMgr.GetScene();
+            if (scene != null && scene.IsTransitioning())
+            {
+                return true;
+            }
+        }
+        Box box = Box.Get();
+        if (box != null && box.IsTransitioningToSceneMode())
+        {
+            return true;
+        }
+        LoadingScreen loadingScreen = LoadingScreen.Get();
+        if (loadingScreen != null && loadingScreen.IsTransitioning())
+        {
+            return true;
+        }
+        return false;
+    }
+
+	public static void ExitConfirmation(AlertPopup.ResponseCallback responseCallback)
 	{
-		foreach (KeyValuePair<TAG_CLASS, HeroSkinAchievements> hERO_SKIN_ACHIEVEMENT in HERO_SKIN_ACHIEVEMENTS)
+		AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
 		{
-			if (hERO_SKIN_ACHIEVEMENT.Value.Honored1kWin == achievementId)
-			{
-				return true;
-			}
-		}
-		return false;
+			m_headerText = GameStrings.Format("GLOBAL_EXIT_CONFIRM_TITLE"),
+			m_text = GameStrings.Format("GLOBAL_EXIT_CONFIRM_MESSAGE"),
+			m_alertTextAlignment = UberText.AlignmentOptions.Center,
+			m_showAlertIcon = false,
+			m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL,
+			m_responseCallback = responseCallback
+		};
+		DialogManager.Get().ShowPopup(info);
 	}
 
-	public static bool HasClassTag(TAG_CLASS classTag, List<TAG_CLASS> tagsToCheck)
+    public static void LogoutConfirmation()
+    {
+        AlertPopup.PopupInfo info = new AlertPopup.PopupInfo
+        {
+            m_headerText = GameStrings.Get(Network.ShouldBeConnectedToAurora() ? "GLOBAL_SWITCH_ACCOUNT" : "GLOBAL_LOGIN_CONFIRM_TITLE"),
+            m_text = GameStrings.Get(Network.ShouldBeConnectedToAurora() ? "GLOBAL_LOGOUT_CONFIRM_MESSAGE" : "GLOBAL_LOGIN_CONFIRM_MESSAGE"),
+            m_alertTextAlignment = UberText.AlignmentOptions.Center,
+            m_showAlertIcon = false,
+            m_responseDisplay = AlertPopup.ResponseDisplay.CONFIRM_CANCEL,
+            m_responseCallback = OnLogoutConfirmationResponse
+        };
+        DialogManager.Get().ShowPopup(info);
+    }
+
+    private static void OnLogoutConfirmationResponse(AlertPopup.Response response, object userData)
+    {
+        if (response != AlertPopup.Response.CANCEL)
+        {
+            Logout();
+        }
+    }
+
+    public static void Logout()
+    {
+        GameMgr.Get().SetPendingAutoConcede(pendingAutoConcede: true);
+        if (Network.ShouldBeConnectedToAurora())
+        {
+            ServiceManager.Get<ILoginService>()?.ClearAuthentication();
+        }
+        HearthstoneApplication.Get().ResetAndForceLogin();
+    }
+
+    public static PackOpeningRarity GetPackOpeningRarity(TAG_RARITY tag)
+    {
+		return tag switch
+        {
+			TAG_RARITY.COMMON => PackOpeningRarity.COMMON, 
+			TAG_RARITY.FREE => PackOpeningRarity.COMMON, 
+			TAG_RARITY.RARE => PackOpeningRarity.RARE, 
+			TAG_RARITY.EPIC => PackOpeningRarity.EPIC, 
+			TAG_RARITY.LEGENDARY => PackOpeningRarity.LEGENDARY, 
+			_ => PackOpeningRarity.NONE, 
+		};
+    }
+
+    public static List<BoosterDbfRecord> GetPackRecordsWithStorePrefab()
+    {
+        return GameDbf.Booster.GetRecords((BoosterDbfRecord r) => !string.IsNullOrEmpty(r.StorePrefab));
+    }
+
+    public static List<AdventureDbfRecord> GetSortedAdventureRecordsWithStorePrefab()
+    {
+        List<AdventureDbfRecord> records = GameDbf.Adventure.GetRecords((AdventureDbfRecord r) => !string.IsNullOrEmpty(r.StorePrefab));
+        records.Sort((AdventureDbfRecord l, AdventureDbfRecord r) => r.SortOrder - l.SortOrder);
+        return records;
+    }
+
+    public static List<AdventureDbfRecord> GetAdventureRecordsWithDefPrefab()
+    {
+        return GameDbf.Adventure.GetRecords((AdventureDbfRecord r) => !string.IsNullOrEmpty(r.AdventureDefPrefab));
+    }
+
+    public static List<AdventureDataDbfRecord> GetAdventureDataRecordsWithSubDefPrefab()
+    {
+        return GameDbf.AdventureData.GetRecords((AdventureDataDbfRecord r) => !string.IsNullOrEmpty(r.AdventureSubDefPrefab));
+    }
+
+    public static int PackSortingPredicate(BoosterDbfRecord left, BoosterDbfRecord right)
+    {
+        if (right.ListDisplayOrderCategory != left.ListDisplayOrderCategory)
+        {
+            return Mathf.Clamp(right.ListDisplayOrderCategory - left.ListDisplayOrderCategory, -1, 1);
+        }
+        if (right.ListDisplayOrder != left.ListDisplayOrder)
+        {
+            return Mathf.Clamp(right.ListDisplayOrder - left.ListDisplayOrder, -1, 1);
+        }
+        return Mathf.Clamp(right.ID - left.ID, -1, 1);
+    }
+
+	public static List<int> GetSortedPackIds(bool ascending = true)
+    {
+        List<BoosterDbfRecord> records = GameDbf.Booster.GetRecords();
+        if (ascending)
+        {
+            records.Sort((BoosterDbfRecord l, BoosterDbfRecord r) => PackSortingPredicate(r, l));
+        }
+        else
+        {
+            records.Sort((BoosterDbfRecord l, BoosterDbfRecord r) => PackSortingPredicate(l, r));
+        }
+		return records.Select((BoosterDbfRecord b) => b.ID).ToList();
+    }
+
+    public static bool IsFakePackOpeningEnabled()
+    {
+        if (HearthstoneAccessConstants.DEV_MODE)
+        {
+            return true;
+        }
+
+        return Options.Get().GetBool(Option.FAKE_PACK_OPENING);
+    }
+
+    public static int GetFakePackCount()
+    {
+        if (!HearthstoneApplication.IsInternal())
+        {
+            return 0;
+        }
+
+        if (HearthstoneAccessConstants.DEV_MODE)
+        {
+            return 17;
+        }
+
+        return Options.Get().GetInt(Option.FAKE_PACK_COUNT);
+    }
+
+    public static bool IsFirstPurchaseBundleBooster(StorePackId storePackId)
+    {
+        if (storePackId.Type == StorePackType.BOOSTER)
+        {
+            return 181 == storePackId.Id;
+        }
+        return false;
+    }
+
+    public static bool IsMammothBundleBooster(StorePackId storePackId)
+    {
+        if (storePackId.Type == StorePackType.BOOSTER)
+        {
+            return 41 == storePackId.Id;
+        }
+        return false;
+    }
+
+    public static bool IsHiddenLicenseBundleBooster(StorePackId storePackId)
+    {
+        if (storePackId.Type == StorePackType.BOOSTER)
+        {
+            BoosterDbId id = (BoosterDbId)storePackId.Id;
+            if (id == BoosterDbId.MAMMOTH_BUNDLE || id == BoosterDbId.FIRST_PURCHASE)
+            {
+                return true;
+            }
+            return false;
+        }
+        return false;
+    }
+
+    public static int GetProductDataFromStorePackId(StorePackId storePackId, int selectedIndex = 0)
+    {
+        if (storePackId.Type == StorePackType.BOOSTER)
+        {
+            if (storePackId.Id == 181)
+            {
+                return 40;
+            }
+            if (storePackId.Id == 41)
+            {
+                return 27;
+            }
+            return storePackId.Id;
+        }
+        return 0;
+    }
+
+    public static int GetProductDataCountFromStorePackId(StorePackId storePackId)
+    {
+        if (storePackId.Type == StorePackType.BOOSTER)
+        {
+            return 1;
+        }
+        return 0;
+    }
+
+    public static List<BoosterDbfRecord> GetRewardableBoosters()
+    {
+        List<BoosterDbfRecord> list = new List<BoosterDbfRecord>();
+        DateTime utcNow = DateTime.UtcNow;
+        foreach (BoosterDbfRecord record in GameDbf.Booster.GetRecords())
+        {
+			if (!IsBoosterRotated((BoosterDbId)record.ID, utcNow) && EventTimingManager.Get().IsEventActive(record.RewardableEvent, utcNow))
+            {
+                list.Add(record);
+            }
+        }
+        list.Sort(SortBoostersDescending);
+        return list;
+    }
+
+    public static int GetBoardIdFromAssetName(string name)
+    {
+        foreach (BoardDbfRecord record in GameDbf.Board.GetRecords())
+        {
+            string prefab = record.Prefab;
+            if (!(name != prefab))
+            {
+                return record.ID;
+            }
+        }
+        return 0;
+    }
+
+    public static UnityEngine.Object Instantiate(GameObject original, GameObject parent, bool withRotation = false)
+    {
+        if (original == null)
+        {
+            return null;
+        }
+        GameObject gameObject = UnityEngine.Object.Instantiate(original);
+        SetParent(gameObject, parent, withRotation);
+        return gameObject;
+    }
+
+    public static UnityEngine.Object Instantiate(Component original, GameObject parent, bool withRotation = false)
+    {
+        if (original == null)
+        {
+            return null;
+        }
+        Component component = UnityEngine.Object.Instantiate(original);
+        SetParent(component, parent, withRotation);
+        return component;
+    }
+
+    public static UnityEngine.Object Instantiate(UnityEngine.Object original)
+    {
+        if (original == null)
+        {
+            return null;
+        }
+        return UnityEngine.Object.Instantiate(original);
+    }
+
+    public static UnityEngine.Object InstantiateGameObject(string path, GameObject parent = null, bool withRotation = false)
+    {
+        if (path == null)
+        {
+            return null;
+        }
+        GameObject gameObject = AssetLoader.Get().InstantiatePrefab(path);
+        if (parent != null)
+        {
+            SetParent(gameObject, parent, withRotation);
+        }
+        return gameObject;
+    }
+
+    public static void SetParent(Component child, Component parent, bool withRotation = false)
+    {
+        SetParent(child.transform, parent.transform, withRotation);
+    }
+
+    public static void SetParent(GameObject child, Component parent, bool withRotation = false)
+    {
+        SetParent(child.transform, parent.transform, withRotation);
+    }
+
+    public static void SetParent(Component child, GameObject parent, bool withRotation = false)
+    {
+        SetParent(child.transform, parent.transform, withRotation);
+    }
+
+    public static void SetParent(GameObject child, GameObject parent, bool withRotation = false)
+    {
+        SetParent(child.transform, parent.transform, withRotation);
+    }
+
+    private static void SetParent(Transform child, Transform parent, bool withRotation)
+    {
+        Vector3 localScale = child.localScale;
+        Quaternion localRotation = child.localRotation;
+        child.parent = parent;
+        child.localPosition = Vector3.zero;
+        child.localScale = localScale;
+        if (withRotation)
+        {
+            child.localRotation = localRotation;
+        }
+    }
+
+    public static void ResetTransform(GameObject obj)
+    {
+        obj.transform.localPosition = Vector3.zero;
+        obj.transform.localScale = Vector3.one;
+        obj.transform.localRotation = Quaternion.identity;
+    }
+
+    public static void ResetTransform(Component comp)
+    {
+        ResetTransform(comp.gameObject);
+    }
+
+    public static T LoadGameObjectWithComponent<T>(string assetPath) where T : Component
+    {
+        GameObject gameObject = AssetLoader.Get().InstantiatePrefab(assetPath);
+        if (gameObject == null)
+        {
+            return null;
+        }
+        T component = gameObject.GetComponent<T>();
+		if (component == null)
+        {
+            Debug.LogError($"{assetPath} object does not contain {typeof(T)} component.");
+            UnityEngine.Object.Destroy(gameObject);
+            return null;
+        }
+        return component;
+    }
+
+    public static T FindChildByName<T>(Transform transform, string name) where T : Component
+    {
+        foreach (Transform item in transform)
+        {
+            if (item.name == name)
+            {
+                return item.GetComponent<T>();
+            }
+            T val = FindChildByName<T>(item, name);
+			if (val != null)
+            {
+                return val;
+            }
+        }
+        return null;
+    }
+
+    public static void PlayCardEffectDefSounds(CardEffectDef cardEffectDef)
+    {
+        if (cardEffectDef == null)
+        {
+            return;
+        }
+        foreach (string soundSpellPath in cardEffectDef.m_SoundSpellPaths)
+        {
+            AssetLoader.Get().InstantiatePrefab(soundSpellPath, delegate (AssetReference name, GameObject go, object data)
+            {
+                if (go == null)
+                {
+                    Debug.LogError($"Unable to load spell object: {name}");
+                }
+                else
+                {
+                    GameObject destroyObj = go;
+                    CardSoundSpell component = go.GetComponent<CardSoundSpell>();
+                    if (component == null)
+                    {
+                        Debug.LogError($"Card sound spell component not found: {name}");
+                        UnityEngine.Object.Destroy(destroyObj);
+                    }
+                    else
+                    {
+                        component.AddStateFinishedCallback(delegate (Spell spell, SpellStateType prevStateType, object userData)
+                        {
+                            if (spell.GetActiveState() == SpellStateType.NONE)
+                            {
+                                UnityEngine.Object.Destroy(destroyObj);
+                            }
+                        });
+                        component.ForceDefaultAudioSource();
+                        component.Activate();
+                    }
+                }
+            });
+        }
+    }
+
+    public static bool LoadCardDefEmoteSound(List<EmoteEntryDef> emoteDefs, EmoteType type, EmoteSoundLoaded callback)
+    {
+        if (callback == null)
+        {
+            Debug.LogError("No callback provided for LoadEmote!");
+            return false;
+        }
+        if (emoteDefs == null)
+        {
+            return false;
+        }
+        EmoteEntryDef emoteEntryDef = emoteDefs.Find((EmoteEntryDef e) => e.m_emoteType == type);
+        if (emoteEntryDef == null)
+        {
+            return false;
+        }
+        AssetLoader.Get().InstantiatePrefab(emoteEntryDef.m_emoteSoundSpellPath, delegate (AssetReference assetRef, GameObject go, object callbackData)
+        {
+            if (go == null)
+            {
+                callback(null);
+            }
+            else
+            {
+                callback(go.GetComponent<CardSoundSpell>());
+            }
+        });
+        return true;
+    }
+
+    public static string GetCardIdFromMercenaryId(int mercenaryId)
+    {
+        MercenaryArtVariationDbfRecord defaultArtVariationRecord = LettuceMercenary.GetDefaultArtVariationRecord(mercenaryId);
+        if (defaultArtVariationRecord == null)
+        {
+            Debug.LogErrorFormat("GetCardIdFromMercenaryId() - No record found for merc: {0}", mercenaryId);
+            return null;
+        }
+        return TranslateDbIdToCardId(defaultArtVariationRecord.CardId);
+    }
+
+    public static int GetMercenaryIdFromCardId(int cardId)
+    {
+        foreach (LettuceMercenaryDbfRecord record in GameDbf.LettuceMercenary.GetRecords())
+        {
+            foreach (MercenaryArtVariationDbfRecord mercenaryArtVariation in record.MercenaryArtVariations)
+            {
+                if (mercenaryArtVariation.CardId == cardId)
+                {
+                    return record.ID;
+                }
+            }
+        }
+        return 0;
+    }
+
+    public static int GetMaxMercenaryLevel()
+    {
+        return GameDbf.GetIndex().GetMercenaryMaxLevel();
+    }
+
+    public static int GetMercenaryLevelFromExperience(int experience)
+    {
+        int maxMercenaryLevel = GetMaxMercenaryLevel();
+        List<LettuceMercenaryLevelDbfRecord> records = GameDbf.LettuceMercenaryLevel.GetRecords();
+        for (int i = 1; i <= maxMercenaryLevel; i++)
+        {
+            LettuceMercenaryLevelDbfRecord lettuceMercenaryLevelDbfRecord = null;
+            int j = 0;
+            for (int count = records.Count; j < count; j++)
+            {
+                if (records[j].Level == i)
+                {
+                    lettuceMercenaryLevelDbfRecord = records[j];
+                    break;
+                }
+            }
+            if (lettuceMercenaryLevelDbfRecord == null)
+            {
+                Log.Lettuce.PrintError("GetMercenaryLevelFromExperience - Missing mercenary level data!");
+                break;
+            }
+            if (experience < lettuceMercenaryLevelDbfRecord.TotalXpRequired)
+            {
+                return i - 1;
+            }
+        }
+        return maxMercenaryLevel;
+    }
+
+    public static float GetExperiencePercentageFromExperienceValue(int experience)
+    {
+        int currentLevel = GetMercenaryLevelFromExperience(experience);
+        if (currentLevel < GetMaxMercenaryLevel())
+        {
+            LettuceMercenaryLevelDbfRecord record = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == currentLevel);
+            return Mathf.InverseLerp(b: GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == currentLevel + 1).TotalXpRequired, a: record.TotalXpRequired, value: experience);
+        }
+        return 1f;
+    }
+
+	public static bool IsActorInMiniHand(Actor actor)
 	{
-		if (tagsToCheck == null)
+		Entity entity = actor.GetEntity();
+		if (entity == null)
 		{
 			return false;
 		}
-		foreach (TAG_CLASS item in tagsToCheck)
+		ZoneHand zoneHand = entity.GetCard().GetZone() as ZoneHand;
+		if (zoneHand != null && !zoneHand.HandEnlarged())
 		{
-			if (item == classTag)
-			{
-				return true;
-			}
+			return true;
 		}
 		return false;
 	}
 
+    public static float GetExperiencePercentageDelta(int startingExperience, int experienceDelta)
+    {
+        int maxMercenaryLevel = GetMaxMercenaryLevel();
+        if (experienceDelta == 0)
+        {
+            return 0f;
+        }
+        int num = startingExperience + experienceDelta;
+        int startingLevel = maxMercenaryLevel;
+        int currentLevel = maxMercenaryLevel;
+        int nextLevel = maxMercenaryLevel;
+        int level;
+        for (level = 1; level <= maxMercenaryLevel; level++)
+        {
+            LettuceMercenaryLevelDbfRecord record = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == level);
+            if (record == null)
+            {
+                Log.Lettuce.PrintError("GetMercenaryLevelFromExperience - Missing mercenary level data!");
+                break;
+            }
+            if (startingExperience < record.TotalXpRequired)
+            {
+                if (level <= startingLevel)
+                {
+                    startingLevel = level - 1;
+                }
+                if (num <= record.TotalXpRequired)
+                {
+                    currentLevel = level - 1;
+                    nextLevel = level;
+                    break;
+                }
+            }
+        }
+        LettuceMercenaryLevelDbfRecord record2 = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == startingLevel);
+        LettuceMercenaryLevelDbfRecord record3 = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == nextLevel);
+        if (startingLevel == currentLevel)
+        {
+            float num2 = Mathf.InverseLerp(record2.TotalXpRequired, record3.TotalXpRequired, startingExperience);
+            return Mathf.InverseLerp(record2.TotalXpRequired, record3.TotalXpRequired, num) - num2;
+        }
+        LettuceMercenaryLevelDbfRecord record4 = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == startingLevel + 1);
+        LettuceMercenaryLevelDbfRecord record5 = GameDbf.LettuceMercenaryLevel.GetRecord((LettuceMercenaryLevelDbfRecord r) => r.Level == currentLevel);
+        int num3 = currentLevel - startingLevel - 1;
+        float num4 = 1f - Mathf.InverseLerp(record2.TotalXpRequired, record4.TotalXpRequired, startingExperience);
+        float num5 = Mathf.InverseLerp(record5.TotalXpRequired, record3.TotalXpRequired, num);
+        return (float)num3 + num4 + num5;
+    }
+
+    public static LettuceMercenaryLevelStatsDbfRecord GetMercenaryStatsByLevel(int mercenaryId, int level, out bool isMaxLevel)
+    {
+        int maxMercenaryLevel = GetMaxMercenaryLevel();
+        int num = Mathf.Clamp(level, 1, maxMercenaryLevel);
+        isMaxLevel = num == maxMercenaryLevel;
+        LettuceMercenaryLevelDbfRecord lettuceMercenaryLevelDbfRecord = null;
+        List<LettuceMercenaryLevelDbfRecord> records = GameDbf.LettuceMercenaryLevel.GetRecords();
+        int i = 0;
+        for (int count = records.Count; i < count; i++)
+        {
+            LettuceMercenaryLevelDbfRecord lettuceMercenaryLevelDbfRecord2 = records[i];
+            if (lettuceMercenaryLevelDbfRecord2.Level == num)
+            {
+                lettuceMercenaryLevelDbfRecord = lettuceMercenaryLevelDbfRecord2;
+                break;
+            }
+        }
+        if (lettuceMercenaryLevelDbfRecord == null)
+        {
+            Log.Lettuce.PrintError("GetMercenaryStatsByLevel() - Unable to get level dbf record for level {0}", level);
+            return null;
+        }
+        LettuceMercenaryLevelStatsDbfRecord lettuceMercenaryLevelStatsDbfRecord = null;
+        List<LettuceMercenaryLevelStatsDbfRecord> records2 = GameDbf.LettuceMercenaryLevelStats.GetRecords();
+        int j = 0;
+        for (int count2 = records2.Count; j < count2; j++)
+        {
+            LettuceMercenaryLevelStatsDbfRecord lettuceMercenaryLevelStatsDbfRecord2 = records2[j];
+            if (lettuceMercenaryLevelStatsDbfRecord2.LettuceMercenaryId == mercenaryId && lettuceMercenaryLevelStatsDbfRecord2.LettuceMercenaryLevelId == lettuceMercenaryLevelDbfRecord.ID)
+            {
+                lettuceMercenaryLevelStatsDbfRecord = lettuceMercenaryLevelStatsDbfRecord2;
+                break;
+            }
+        }
+        if (lettuceMercenaryLevelStatsDbfRecord == null)
+        {
+            Log.Lettuce.PrintError("GetMercenaryStatsByLevel() - Unable to get level stats dbf record for level {0}", num);
+        }
+        return lettuceMercenaryLevelStatsDbfRecord;
+    }
+
+    public static bool IsFinalBossNodeType(int nodeTypeId)
+    {
+        LettuceMapNodeTypeDbfRecord record = GameDbf.LettuceMapNodeType.GetRecord(nodeTypeId);
+        if (record == null)
+        {
+            return false;
+        }
+        return record.BossType == LettuceMapNodeType.LettuceMapBossType.FINAL_BOSS;
+    }
+
+    public static TAG_ROLE GetMercenaryTagRoleFromProtoRole(Mercenary.Role role)
+    {
+		return role switch
+        {
+			Mercenary.Role.ROLE_NEUTRAL => TAG_ROLE.NEUTRAL, 
+			Mercenary.Role.ROLE_CASTER => TAG_ROLE.CASTER, 
+			Mercenary.Role.ROLE_STRIKER => TAG_ROLE.FIGHTER, 
+			Mercenary.Role.ROLE_PROTECTOR => TAG_ROLE.TANK, 
+			_ => TAG_ROLE.INVALID, 
+		};
+    }
+
+    public static bool LoadAndPositionCardActor(string actorName, string heroCardID, TAG_PREMIUM premium, LoadActorCallback callback)
+    {
+        if (!string.IsNullOrEmpty(heroCardID))
+        {
+            DefLoader.Get().LoadFullDef(heroCardID, delegate (string cardID, DefLoader.DisposableFullDef def, object userData)
+            {
+                LoadAndPositionCardActor_OnFullDefLoaded(actorName, cardID, def, userData, callback);
+            }, premium);
+            return true;
+        }
+        return false;
+    }
+
+    private static void LoadAndPositionCardActor_OnFullDefLoaded(string actorName, string cardID, DefLoader.DisposableFullDef def, object userData, LoadActorCallback callback)
+    {
+        TAG_PREMIUM premium = (TAG_PREMIUM)userData;
+        LoadActorCallbackInfo callbackData2 = new LoadActorCallbackInfo
+        {
+            fullDef = def,
+            premium = premium
+        };
+        AssetLoader.Get().InstantiatePrefab(actorName, delegate (AssetReference assetRef, GameObject go, object callbackData)
+        {
+            LoadAndPositionActorCard_OnActorLoaded(assetRef, go, callbackData, callback);
+        }, callbackData2, AssetLoadingOptions.IgnorePrefabPosition);
+    }
+
+    private static void LoadAndPositionActorCard_OnActorLoaded(AssetReference assetRef, GameObject go, object callbackData, LoadActorCallback callback)
+    {
+        LoadActorCallbackInfo loadActorCallbackInfo = callbackData as LoadActorCallbackInfo;
+        using (loadActorCallbackInfo.fullDef)
+        {
+            if (go == null)
+            {
+                Debug.LogWarning($"GameUtils.OnHeroActorLoaded() - FAILED to load actor \"{assetRef}\"");
+                return;
+            }
+            Actor component = go.GetComponent<Actor>();
+            if (component == null)
+            {
+                Debug.LogWarning($"GameUtils.OnActorLoaded() - ERROR actor \"{assetRef}\" has no Actor component");
+                return;
+            }
+            component.SetPremium(loadActorCallbackInfo.premium);
+            component.SetEntityDef(loadActorCallbackInfo.fullDef.EntityDef);
+            component.SetCardDef(loadActorCallbackInfo.fullDef.DisposableCardDef);
+            component.UpdateAllComponents();
+            component.gameObject.name = loadActorCallbackInfo.fullDef.CardDef.name + "_actor";
+            if ((bool)UniversalInputManager.UsePhoneUI)
+            {
+                LayerUtils.SetLayer(component.gameObject, GameLayer.IgnoreFullScreenEffects);
+            }
+            GemObject healthObject = component.GetHealthObject();
+            if (healthObject != null)
+            {
+                healthObject.Hide();
+            }
+            callback?.Invoke(component);
+        }
+    }
+
+    public static bool IsBoosterWild(BoosterDbId boosterId)
+    {
+        if (boosterId == BoosterDbId.INVALID)
+        {
+            return false;
+        }
+        return IsBoosterWild(GameDbf.Booster.GetRecord((int)boosterId));
+    }
+
+    public static bool IsBoosterWild(BoosterDbfRecord boosterRecord)
+    {
+        if (boosterRecord != null)
+        {
+			EventTimingType standardEvent = boosterRecord.StandardEvent;
+			if (standardEvent != EventTimingType.UNKNOWN && standardEvent != 0 && EventTimingManager.Get().HasEventEnded(standardEvent))
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static bool IsAdventureWild(AdventureDbId adventureId)
+    {
+        if (adventureId == AdventureDbId.INVALID)
+        {
+            return false;
+        }
+        AdventureDbfRecord record = GameDbf.Adventure.GetRecord((int)adventureId);
+        if (record != null)
+        {
+			EventTimingType standardEvent = record.StandardEvent;
+			if (standardEvent != EventTimingType.UNKNOWN && standardEvent != 0 && EventTimingManager.Get().HasEventEnded(standardEvent))
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static bool GetSeasonMonthAndYear(int seasonId, int startId, int startMonth, int startYear, out int month, out int year)
+    {
+        month = 0;
+        year = 0;
+        if (seasonId < startId)
+        {
+            Debug.LogFormat("GetSeasonMonthAndYear called with invalid seasonId {0}. Launch season is 6.", seasonId);
+            return false;
+        }
+        int num = seasonId - startId + startMonth - 1;
+        month = num % 12 + 1;
+        year = startYear + num / 12;
+        return true;
+    }
+
+    private static string GetSeasonName(int seasonId, int startId, int startMonth, int startYear)
+    {
+        if (!GetSeasonMonthAndYear(seasonId, startId, startMonth, startYear, out var month, out var year))
+        {
+            return null;
+        }
+        string key = $"GLUE_RANKED_SEASON_NAME_{seasonId}";
+        string monthFromDigits = GameStrings.GetMonthFromDigits(month);
+        if (GameStrings.HasKey(key))
+        {
+            return GameStrings.Format(key, monthFromDigits, year, seasonId);
+        }
+        return GameStrings.Format("GLUE_RANKED_SEASON_NAME_GENERIC", monthFromDigits, year, seasonId);
+    }
+
+    public static string GetRankedSeasonName(int seasonId)
+    {
+        return GetSeasonName(seasonId, 6, 4, 2014);
+    }
+
+    public static string GetMercenariesSeasonName(int seasonId)
+    {
+        return GetSeasonName(seasonId, 1, 11, 2021);
+    }
+
+    public static string GetMercenariesSeasonEndDescription(int seasonId, int highestRating)
+    {
+        if (!GetSeasonMonthAndYear(seasonId, 1, 11, 2021, out var month, out var year))
+        {
+            return null;
+        }
+        string monthFromDigits = GameStrings.GetMonthFromDigits(month);
+        return GameStrings.Format("GLUE_LETTUCE_SEASON_ROLL_DESC", monthFromDigits, year, highestRating);
+    }
+
+    public static bool IsGSDFlagSet(GameSaveKeyId saveKey, GameSaveKeySubkeyId subkey)
+    {
+        if (!GameSaveDataManager.Get().IsDataReady(saveKey))
+        {
+            return false;
+        }
+        GameSaveDataManager.Get().GetSubkeyValue(saveKey, subkey, out long value);
+        return value > 0;
+    }
+
+    public static void SetGSDFlag(GameSaveKeyId saveKey, GameSaveKeySubkeyId subkey, bool enableFlag)
+    {
+        if (IsGSDFlagSet(saveKey, subkey) != enableFlag)
+        {
+            int num = (enableFlag ? 1 : 0);
+            GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(saveKey, subkey, num));
+        }
+    }
+
+    public static bool IsGolden500HeroSkinAchievement(int achievementId)
+    {
+        foreach (KeyValuePair<TAG_CLASS, HeroSkinAchievements> hERO_SKIN_ACHIEVEMENT in HERO_SKIN_ACHIEVEMENTS)
+        {
+            if (hERO_SKIN_ACHIEVEMENT.Value.Golden500Win == achievementId)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static bool IsHonored1KHeroSkinAchievement(int achievementId)
+    {
+        foreach (KeyValuePair<TAG_CLASS, HeroSkinAchievements> hERO_SKIN_ACHIEVEMENT in HERO_SKIN_ACHIEVEMENTS)
+        {
+            if (hERO_SKIN_ACHIEVEMENT.Value.Honored1kWin == achievementId)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    #region Accessibility testing
+    private static bool s_cheatMockLevels;
+
+    private static Dictionary<TAG_CLASS, int> CHEAT_LEVELS_BY_CLASS = new Dictionary<TAG_CLASS, int>
+    {
+        {
+            TAG_CLASS.DRUID,
+            10
+        },
+        {
+            TAG_CLASS.HUNTER,
+            1
+        },
+        {
+            TAG_CLASS.MAGE,
+            7
+        },
+        {
+            TAG_CLASS.PALADIN,
+            3
+        },
+        {
+            TAG_CLASS.PRIEST,
+            1
+        },
+        {
+            TAG_CLASS.ROGUE,
+            1
+        },
+        {
+            TAG_CLASS.SHAMAN,
+            1
+        },
+        {
+            TAG_CLASS.WARLOCK,
+            1
+        },
+        {
+            TAG_CLASS.WARRIOR,
+            1
+        },
+        {
+            TAG_CLASS.DEMONHUNTER,
+            0 // Locked
+		},
+    };
+
+    private static NetCache.HeroLevel Cheat_GetHeroLevel(TAG_CLASS heroClass)
+    {
+        var ret = new NetCache.HeroLevel();
+        ret.Class = heroClass;
+
+        int level;
+        var ok = CHEAT_LEVELS_BY_CLASS.TryGetValue(heroClass, out level);
+
+        if (!ok)
+        {
+            return null;
+        }
+
+        var heroLevel = new NetCache.HeroLevel.LevelInfo();
+        heroLevel.Level = level;
+
+        ret.CurrentLevel = heroLevel;
+
+        return ret;
+    }
+
+    internal static void Cheat_SetLevelsOverride(bool val)
+    {
+        s_cheatMockLevels = val;
+    }
+
+    #endregion
+    public static bool HasClassTag(TAG_CLASS classTag, List<TAG_CLASS> tagsToCheck)
+    {
+        if (tagsToCheck == null)
+        {
+            return false;
+        }
+        foreach (TAG_CLASS item in tagsToCheck)
+        {
+            if (item == classTag)
+            {
+                return true;
+            }
+        }
+        return false;
+    }
+
 	public static bool IsZilliaxCard(EntityDef entityDef)
 	{
 		if (entityDef == null)
diff --git a/Assembly-CSharp/Gameplay.cs b/Assembly-CSharp/Gameplay.cs
index abcaff1..004703d 100644
--- a/Assembly-CSharp/Gameplay.cs
+++ b/Assembly-CSharp/Gameplay.cs
@@ -227,6 +227,7 @@ public class Gameplay : PegasusScene
 
 	private void Start()
 	{
+		Accessibility.AccessibleGameplay.Get().OnGameplayScreenStart();
 		Log.LoadingScreen.Print("Gameplay.Start()");
 		CheckBattleNetConnection();
 		Network network = Network.Get();
@@ -806,23 +807,23 @@ public class Gameplay : PegasusScene
 			int count = race2.Count;
 			if (race == 0 || race == 26 || !Enum.IsDefined(typeof(TAG_RACE), race))
 			{
-				continue;
-			}
+						continue;
+					}
 			if (count >= 0)
-			{
+				{
 				availableRacesInBattlegroundsExcludingAmalgam.Add((TAG_RACE)race);
 				continue;
 			}
-			switch (count)
-			{
-			case -1:
+					switch (count)
+					{
+					case -1:
 				missingRacesInBattlegrounds.Add((TAG_RACE)race);
-				break;
-			case -2:
+						break;
+					case -2:
 				inactiveRacesInBattlegrounds.Add((TAG_RACE)race);
-				break;
-			}
-		}
+						break;
+					}
+				}
 		availableRacesInBattlegroundsExcludingAmalgam.Sort((TAG_RACE a, TAG_RACE b) => string.Compare(GameStrings.GetRaceNameBattlegrounds(a), GameStrings.GetRaceNameBattlegrounds(b), StringComparison.Ordinal));
 		missingRacesInBattlegrounds.Sort((TAG_RACE a, TAG_RACE b) => string.Compare(GameStrings.GetRaceNameBattlegrounds(a), GameStrings.GetRaceNameBattlegrounds(b), StringComparison.Ordinal));
 		if (MulliganManager.Get().IsMulliganActive())
@@ -1188,8 +1189,8 @@ public class Gameplay : PegasusScene
 			return;
 		}
 		DoTraditionalTutorialPreload();
-		go.transform.parent = Board.Get().transform;
-	}
+			go.transform.parent = Board.Get().transform;
+		}
 
 	private void OnEndTurnButtonLoaded(AssetReference assetRef, GameObject go, object callbackData)
 	{
@@ -1446,8 +1447,8 @@ public class Gameplay : PegasusScene
 		{
 			if (!GameMgr.Get().IsBattlegrounds())
 			{
-				BnetRecentPlayerMgr.Get().AddRecentPlayer(GameState.Get().GetOpposingPlayer()?.GetBnetPlayer(), BnetRecentPlayerMgr.RecentReason.CURRENT_OPPONENT);
-			}
+			BnetRecentPlayerMgr.Get().AddRecentPlayer(GameState.Get().GetOpposingPlayer()?.GetBnetPlayer(), BnetRecentPlayerMgr.RecentReason.CURRENT_OPPONENT);
+		}
 			else
 			{
 				Map<int, SharedPlayerInfo> playerInfoMap = GameState.Get().GetPlayerInfoMap();
diff --git a/Assembly-CSharp/GameplayErrorManager.cs b/Assembly-CSharp/GameplayErrorManager.cs
index 966252d..f9b0063 100644
--- a/Assembly-CSharp/GameplayErrorManager.cs
+++ b/Assembly-CSharp/GameplayErrorManager.cs
@@ -4,6 +4,7 @@ using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class GameplayErrorManager : IService
 {
@@ -96,6 +97,7 @@ public class GameplayErrorManager : IService
 		m_uberText.gameObject.transform.localPosition = Data.m_mobileTextAdjustment;
 		s_messageInstance.ShowMessage(m_message, m_displaySecsLeft);
 		SoundManager.Get().LoadAndPlay(UI_NO_CAN_DO);
+		AccessibilityMgr.Output(AccessibleGameplay.Get(), message);
 	}
 
 	private void HideMessage()
diff --git a/Assembly-CSharp/GenericConfirmationPopup.cs b/Assembly-CSharp/GenericConfirmationPopup.cs
index 3053837..8b9f10e 100644
--- a/Assembly-CSharp/GenericConfirmationPopup.cs
+++ b/Assembly-CSharp/GenericConfirmationPopup.cs
@@ -1,7 +1,8 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
-public class GenericConfirmationPopup : DialogBase
+public class GenericConfirmationPopup : InaccessibleDialogBase
 {
 	[SerializeField]
 	private Spell m_successRingSpell;
diff --git a/Assembly-CSharp/GraphicsManager.cs b/Assembly-CSharp/GraphicsManager.cs
index 6a34c7c..9aaed65 100644
--- a/Assembly-CSharp/GraphicsManager.cs
+++ b/Assembly-CSharp/GraphicsManager.cs
@@ -540,7 +540,7 @@ public class GraphicsManager : IGraphicsManager, IHasUpdate, IService
 		}
 		if (i < 0)
 		{
-			Debug.LogError($"GraphicsManager: Quality Level not found: {qualityName}");
+			UnityEngine.Debug.LogError($"GraphicsManager: Quality Level not found: {qualityName}");
 		}
 		else
 		{
@@ -550,29 +550,29 @@ public class GraphicsManager : IGraphicsManager, IHasUpdate, IService
 
 	private void LogSystemInfo()
 	{
-		Debug.Log("System Info:");
-		Debug.Log($"SystemInfo - Device Name: {SystemInfo.deviceName}");
-		Debug.Log($"SystemInfo - Device Model: {SystemInfo.deviceModel}");
-		Debug.Log($"SystemInfo - OS: {SystemInfo.operatingSystem}");
-		Debug.Log($"SystemInfo - CPU Type: {SystemInfo.processorType}");
-		Debug.Log($"SystemInfo - CPU Cores: {SystemInfo.processorCount}");
-		Debug.Log($"SystemInfo - System Memory: {SystemInfo.systemMemorySize}");
-		Debug.Log($"SystemInfo - Screen Resolution: {Screen.currentResolution.width}x{Screen.currentResolution.height}");
-		Debug.Log($"SystemInfo - Screen DPI: {Screen.dpi}");
-		Debug.Log($"SystemInfo - GPU ID: {SystemInfo.graphicsDeviceID}");
-		Debug.Log($"SystemInfo - GPU Name: {SystemInfo.graphicsDeviceName}");
-		Debug.Log($"SystemInfo - GPU Vendor: {SystemInfo.graphicsDeviceVendor}");
-		Debug.Log($"SystemInfo - GPU Memory: {SystemInfo.graphicsMemorySize}");
-		Debug.Log($"SystemInfo - GPU Shader Level: {SystemInfo.graphicsShaderLevel}");
-		Debug.Log($"SystemInfo - GPU NPOT Support: {SystemInfo.npotSupport}");
-		Debug.Log($"SystemInfo - Graphics API (version): {SystemInfo.graphicsDeviceVersion}");
-		Debug.Log($"SystemInfo - Graphics API (type): {SystemInfo.graphicsDeviceType}");
-		Debug.Log($"SystemInfo - Graphics Supported Render Target Count: {SystemInfo.supportedRenderTargetCount}");
-		Debug.Log($"SystemInfo - Graphics Supports 3D Textures: {SystemInfo.supports3DTextures}");
-		Debug.Log($"SystemInfo - Graphics Supports Compute Shaders: {SystemInfo.supportsComputeShaders}");
-		Debug.Log($"SystemInfo - Graphics Supports Shadows: {SystemInfo.supportsShadows}");
-		Debug.Log($"SystemInfo - Graphics Supports Sparse Textures: {SystemInfo.supportsSparseTextures}");
-		Debug.Log($"SystemInfo - Graphics RenderTextureFormat.ARGBHalf: {SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf)}");
-		Debug.Log(string.Format("SystemInfo - Graphics Metal Support: {0}", SystemInfo.graphicsDeviceVersion.StartsWith("Metal")));
+		UnityEngine.Debug.Log("System Info:");
+		UnityEngine.Debug.Log($"SystemInfo - Device Name: {SystemInfo.deviceName}");
+		UnityEngine.Debug.Log($"SystemInfo - Device Model: {SystemInfo.deviceModel}");
+		UnityEngine.Debug.Log($"SystemInfo - OS: {SystemInfo.operatingSystem}");
+		UnityEngine.Debug.Log($"SystemInfo - CPU Type: {SystemInfo.processorType}");
+		UnityEngine.Debug.Log($"SystemInfo - CPU Cores: {SystemInfo.processorCount}");
+		UnityEngine.Debug.Log($"SystemInfo - System Memory: {SystemInfo.systemMemorySize}");
+		UnityEngine.Debug.Log($"SystemInfo - Screen Resolution: {Screen.currentResolution.width}x{Screen.currentResolution.height}");
+		UnityEngine.Debug.Log($"SystemInfo - Screen DPI: {Screen.dpi}");
+		UnityEngine.Debug.Log($"SystemInfo - GPU ID: {SystemInfo.graphicsDeviceID}");
+		UnityEngine.Debug.Log($"SystemInfo - GPU Name: {SystemInfo.graphicsDeviceName}");
+		UnityEngine.Debug.Log($"SystemInfo - GPU Vendor: {SystemInfo.graphicsDeviceVendor}");
+		UnityEngine.Debug.Log($"SystemInfo - GPU Memory: {SystemInfo.graphicsMemorySize}");
+		UnityEngine.Debug.Log($"SystemInfo - GPU Shader Level: {SystemInfo.graphicsShaderLevel}");
+		UnityEngine.Debug.Log($"SystemInfo - GPU NPOT Support: {SystemInfo.npotSupport}");
+		UnityEngine.Debug.Log($"SystemInfo - Graphics API (version): {SystemInfo.graphicsDeviceVersion}");
+		UnityEngine.Debug.Log($"SystemInfo - Graphics API (type): {SystemInfo.graphicsDeviceType}");
+		UnityEngine.Debug.Log($"SystemInfo - Graphics Supported Render Target Count: {SystemInfo.supportedRenderTargetCount}");
+		UnityEngine.Debug.Log($"SystemInfo - Graphics Supports 3D Textures: {SystemInfo.supports3DTextures}");
+		UnityEngine.Debug.Log($"SystemInfo - Graphics Supports Compute Shaders: {SystemInfo.supportsComputeShaders}");
+		UnityEngine.Debug.Log($"SystemInfo - Graphics Supports Shadows: {SystemInfo.supportsShadows}");
+		UnityEngine.Debug.Log($"SystemInfo - Graphics Supports Sparse Textures: {SystemInfo.supportsSparseTextures}");
+		UnityEngine.Debug.Log($"SystemInfo - Graphics RenderTextureFormat.ARGBHalf: {SystemInfo.SupportsRenderTextureFormat(RenderTextureFormat.ARGBHalf)}");
+		UnityEngine.Debug.Log(string.Format("SystemInfo - Graphics Metal Support: {0}", SystemInfo.graphicsDeviceVersion.StartsWith("Metal")));
 	}
 }
diff --git a/Assembly-CSharp/GuestHeroPickerTrayDisplay.cs b/Assembly-CSharp/GuestHeroPickerTrayDisplay.cs
index 777e5dc..1fc1c96 100644
--- a/Assembly-CSharp/GuestHeroPickerTrayDisplay.cs
+++ b/Assembly-CSharp/GuestHeroPickerTrayDisplay.cs
@@ -5,9 +5,10 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class GuestHeroPickerTrayDisplay : AbsDeckPickerTrayDisplay
+public class GuestHeroPickerTrayDisplay : AbsDeckPickerTrayDisplay, AccessibleScreen
 {
 	public delegate void GuestHeroSelectedCallback(TAG_CLASS classId, GuestHeroDbfRecord record);
 
@@ -101,6 +102,8 @@ public class GuestHeroPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			SetBackButtonEnabled(enable: false);
 		}
 		ShowFirstPage();
+
+		ReadPickerTrayDisplay();
 	}
 
 	protected override void InitForMode(SceneMgr.Mode mode)
@@ -283,20 +286,20 @@ public class GuestHeroPickerTrayDisplay : AbsDeckPickerTrayDisplay
 	protected override void UpdateHeroInfo(HeroPickerButton button)
 	{
 		using DefLoader.DisposableFullDef disposableFullDef = button.ShareFullDef();
-		string heroName = disposableFullDef.EntityDef.GetName();
-		string heroDescription = string.Empty;
-		GuestHeroDbfRecord guestHero = button.GetGuestHero();
-		if (guestHero != null)
-		{
-			heroDescription = guestHero.FlavorText;
-		}
-		TAG_PREMIUM premium = TAG_PREMIUM.NORMAL;
-		if (SceneMgr.Get().GetMode() == SceneMgr.Mode.ADVENTURE)
-		{
-			premium = TAG_PREMIUM.GOLDEN;
+			string heroName = disposableFullDef.EntityDef.GetName();
+			string heroDescription = string.Empty;
+			GuestHeroDbfRecord guestHero = button.GetGuestHero();
+			if (guestHero != null)
+			{
+				heroDescription = guestHero.FlavorText;
+			}
+			TAG_PREMIUM premium = TAG_PREMIUM.NORMAL;
+			if (SceneMgr.Get().GetMode() == SceneMgr.Mode.ADVENTURE)
+			{
+				premium = TAG_PREMIUM.GOLDEN;
+			}
+			UpdateHeroInfo(disposableFullDef, heroName, heroDescription, premium);
 		}
-		UpdateHeroInfo(disposableFullDef, heroName, heroDescription, premium);
-	}
 
 	protected override void PlayGame()
 	{
@@ -649,16 +652,122 @@ public class GuestHeroPickerTrayDisplay : AbsDeckPickerTrayDisplay
 			return;
 		}
 		HeroClassIconsDataModel heroClassIconsDataModel = new HeroClassIconsDataModel();
-		using DefLoader.DisposableFullDef disposableFullDef = button.ShareFullDef();
-		EntityDef entityDef = disposableFullDef?.EntityDef;
-		if (entityDef == null)
+		using (DefLoader.DisposableFullDef disposableFullDef = button.ShareFullDef())
 		{
-			Debug.LogWarning("GuestHeroPickerTrayDisplay.UpdateSelectedHeroClasses - button did not contain an entity def!");
+			EntityDef entityDef = disposableFullDef?.EntityDef;
+			if (entityDef == null)
+			{
+				Debug.LogWarning("GuestHeroPickerTrayDisplay.UpdateSelectedHeroClasses - button did not contain an entity def!");
+				return;
+			}
+			heroClassIconsDataModel.Classes.Clear();
+			entityDef.GetClasses(heroClassIconsDataModel.Classes);
+			heroClassIconsDataModel.Classes.Sort((TAG_CLASS a, TAG_CLASS b) => (a == TAG_CLASS.NEUTRAL) ? 1 : (-1));
+			component.Owner.BindDataModel(heroClassIconsDataModel);
+		}
+	}
+
+	#region Accessibility
+	private enum AccessibleState {
+		LOADING,
+		ADVENTURE_CHOOSING_HERO,
+		ADVENTURE_HERO_CHOSEN,
+	};
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleHorizontalMenu<AccessibleHeroPickerButton> m_accessibleHeroPickerButtons;
+
+	private void ReadPickerTrayDisplay()
+	{
+		if (!SupportedAdventure() && !SceneMgr.Get().IsInDuelsMode() && !SceneMgr.Get().IsInTavernBrawlMode())
+        {
 			return;
+        }
+
+		AccessibilityMgr.SetScreen(this);
+
+		var menuTitle = LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_CHOOSE_ADVENTURER_TITLE);
+		var accessibleHeroPickerButtons = new AccessibleHorizontalMenu<AccessibleHeroPickerButton>(this, menuTitle, PressBackButton);
+
+		var numSupportedBoHHeroes = 11; // Jaina, Rexxar, Garrosh, Uther, Anduin, Valeera, Thrall
+				var numSupportedBoMHeroes = 10; // Jaina, Rexxar, Garrosh, Uther, Anduin, Valeera, Thrall
+				var numSupportedDuelsHeroes = 6;
+		var selectedAdventure = AdventureConfig.Get().SelectedAdventure;
+		var numSupported=0;
+		if(selectedAdventure==AdventureDbId.BOH) numSupported=numSupportedBoHHeroes;
+		if(selectedAdventure==AdventureDbId.BOM) numSupported=numSupportedBoMHeroes;
+		if (SceneMgr.Get().IsInDuelsMode())
+		{
+			numSupported = numSupportedDuelsHeroes;
 		}
-		heroClassIconsDataModel.Classes.Clear();
-		entityDef.GetClasses(heroClassIconsDataModel.Classes);
-		heroClassIconsDataModel.Classes.Sort((TAG_CLASS a, TAG_CLASS b) => (a == TAG_CLASS.NEUTRAL) ? 1 : (-1));
-		component.Owner.BindDataModel(heroClassIconsDataModel);
+		foreach (var hb in m_heroButtons)
+        {
+			accessibleHeroPickerButtons.AddOption(new AccessibleHeroPickerButton(this, hb), () => ChooseHero(hb));
+        }
+
+		m_accessibleHeroPickerButtons = accessibleHeroPickerButtons;
+		m_accessibleHeroPickerButtons.StartReading();
+
+		m_curAccessibleState = AccessibleState.ADVENTURE_CHOOSING_HERO;
 	}
+
+    private void ChooseHero(HeroPickerButton hb)
+    {
+		hb.TriggerRelease();
+    }
+
+    protected override void OnChosenHero()
+    {
+		if (!SupportedAdventure() && !SceneMgr.Get().IsInDuelsMode())
+        {
+			return;
+        }
+
+        m_curAccessibleState = AccessibleState.ADVENTURE_HERO_CHOSEN;
+        AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_START);
+    }
+
+	public void HandleInput()
+	{
+		if (m_curAccessibleState == AccessibleState.LOADING)
+		{
+			return;
+		}
+		else if (m_curAccessibleState == AccessibleState.ADVENTURE_CHOOSING_HERO)
+        {
+            m_accessibleHeroPickerButtons?.HandleAccessibleInput();
+        }
+        else if (m_curAccessibleState == AccessibleState.ADVENTURE_HERO_CHOSEN)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_playButton.TriggerRelease();
+            }
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				PressBackButton();
+            }
+        }
+	}
+
+	public string GetHelp()
+	{
+		if (m_curAccessibleState == AccessibleState.ADVENTURE_CHOOSING_HERO)
+        {
+			return m_accessibleHeroPickerButtons?.GetHelp();
+        }
+        else if (m_curAccessibleState == AccessibleState.ADVENTURE_HERO_CHOSEN)
+        {
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_CHOOSE_ADVENTURER_SCREEN_HERO_CHOSEN_HELP, AccessibleKey.CONFIRM, AccessibleKey.BACK);
+        }
+
+		return "";
+	}
+
+	public void OnGainedFocus()
+	{
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.SCREEN_CHOOSE_ADVENTURER_SCREEN_TITLE));
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/Hearthstone/APIGateway/OptInApi.cs b/Assembly-CSharp/Hearthstone/APIGateway/OptInApi.cs
index e83833d..db19370 100644
--- a/Assembly-CSharp/Hearthstone/APIGateway/OptInApi.cs
+++ b/Assembly-CSharp/Hearthstone/APIGateway/OptInApi.cs
@@ -131,7 +131,7 @@ namespace Hearthstone.APIGateway
 		{
 			UpdateAccountOptInByAccountId((OptInType)type, value).ContinueWith(delegate(Task<bool> task)
 			{
-				callback?.Invoke(task.IsCompletedSuccessfully && task.Result);
+				callback?.Invoke(task.Status == TaskStatus.RanToCompletion && task.Result);
 			});
 		}
 
@@ -273,15 +273,15 @@ namespace Hearthstone.APIGateway
 			{
 				InitializeScopesIfNeeded(APIGatewayService);
 				using StringContent content = new StringContent(ConstructGetAccountOptInsByAccountIdRequest());
-				content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
-				string text = await APIGatewayService.PostRequestAsStringAsync("OptInService/v1/GetAccountOptIns", content).ConfigureAwait(continueOnCapturedContext: false);
-				if (string.IsNullOrEmpty(text))
-				{
-					Logger?.Log(Blizzard.T5.Core.LogLevel.Warning, "Unable to get messages from Gateway. Null or empty response");
-					return false;
+					content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
+					string text = await APIGatewayService.PostRequestAsStringAsync("OptInService/v1/GetAccountOptIns", content).ConfigureAwait(continueOnCapturedContext: false);
+					if (string.IsNullOrEmpty(text))
+					{
+						Logger?.Log(Blizzard.T5.Core.LogLevel.Warning, "Unable to get messages from Gateway. Null or empty response");
+						return false;
+					}
+					return TryExtractOptInsFromResponseJSON(text);
 				}
-				return TryExtractOptInsFromResponseJSON(text);
-			}
 			catch (Exception ex)
 			{
 				Logger?.Log(Blizzard.T5.Core.LogLevel.Error, "Exception retrieving messages from gateway: " + ex.Message);
@@ -296,15 +296,15 @@ namespace Hearthstone.APIGateway
 			{
 				InitializeScopesIfNeeded(APIGatewayService);
 				using StringContent content = new StringContent(ConstructUpdateAccountOptInRequest(optInType, value));
-				content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
-				string value2 = await APIGatewayService.PostRequestAsStringAsync("OptInService/v1/UpdateAccountOptIn", content).ConfigureAwait(continueOnCapturedContext: false);
-				Logger?.Log(Blizzard.T5.Core.LogLevel.Information, $"{optInType} opt-in updated to {value}.");
-				if (string.IsNullOrEmpty(value2))
-				{
-					Logger?.Log(Blizzard.T5.Core.LogLevel.Error, "Unable to get messages from Gateway. Null or empty response");
-					return false;
+					content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
+					string value2 = await APIGatewayService.PostRequestAsStringAsync("OptInService/v1/UpdateAccountOptIn", content).ConfigureAwait(continueOnCapturedContext: false);
+					Logger?.Log(Blizzard.T5.Core.LogLevel.Information, $"{optInType} opt-in updated to {value}.");
+					if (string.IsNullOrEmpty(value2))
+					{
+						Logger?.Log(Blizzard.T5.Core.LogLevel.Error, "Unable to get messages from Gateway. Null or empty response");
+						return false;
+					}
 				}
-			}
 			catch (Exception ex)
 			{
 				Logger?.Log(Blizzard.T5.Core.LogLevel.Error, "Exception retrieving messages from gateway: " + ex.Message);
diff --git a/Assembly-CSharp/Hearthstone/BattlegroundsBoardSkinId.cs b/Assembly-CSharp/Hearthstone/BattlegroundsBoardSkinId.cs
index 201d1c8..26fe061 100644
--- a/Assembly-CSharp/Hearthstone/BattlegroundsBoardSkinId.cs
+++ b/Assembly-CSharp/Hearthstone/BattlegroundsBoardSkinId.cs
@@ -66,5 +66,15 @@ namespace Hearthstone
 			int value = m_value;
 			return value.ToString();
 		}
+
+		public static bool operator ==(BattlegroundsBoardSkinId left, BattlegroundsBoardSkinId right)
+		{
+			return left.Equals(right);
+		}
+
+		public static bool operator !=(BattlegroundsBoardSkinId left, BattlegroundsBoardSkinId right)
+		{
+			return !left.Equals(right);
+		}
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/BattlegroundsEmoteId.cs b/Assembly-CSharp/Hearthstone/BattlegroundsEmoteId.cs
index b55e201..7dad0a5 100644
--- a/Assembly-CSharp/Hearthstone/BattlegroundsEmoteId.cs
+++ b/Assembly-CSharp/Hearthstone/BattlegroundsEmoteId.cs
@@ -76,5 +76,10 @@ namespace Hearthstone
 		{
 			return !left.Equals(right);
 		}
+
+		public static bool operator ==(BattlegroundsEmoteId left, BattlegroundsEmoteId right)
+		{
+			return left.Equals(right);
+		}
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/BattlegroundsFinisherId.cs b/Assembly-CSharp/Hearthstone/BattlegroundsFinisherId.cs
index a969c9b..e6725fc 100644
--- a/Assembly-CSharp/Hearthstone/BattlegroundsFinisherId.cs
+++ b/Assembly-CSharp/Hearthstone/BattlegroundsFinisherId.cs
@@ -66,5 +66,15 @@ namespace Hearthstone
 			int value = m_value;
 			return value.ToString();
 		}
+
+		public static bool operator ==(BattlegroundsFinisherId left, BattlegroundsFinisherId right)
+		{
+			return left.Equals(right);
+		}
+
+		public static bool operator !=(BattlegroundsFinisherId left, BattlegroundsFinisherId right)
+		{
+			return !left.Equals(right);
+		}
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/Core/Streaming/EditorAssetDownloader.cs b/Assembly-CSharp/Hearthstone/Core/Streaming/EditorAssetDownloader.cs
index 79feb04..67f5ae4 100644
--- a/Assembly-CSharp/Hearthstone/Core/Streaming/EditorAssetDownloader.cs
+++ b/Assembly-CSharp/Hearthstone/Core/Streaming/EditorAssetDownloader.cs
@@ -98,31 +98,31 @@ namespace Hearthstone.Core.Streaming
 					if (File.Exists(m_dstPath))
 					{
 						if (!m_overwriteIfExists && m_totalBytes == new FileInfo(m_dstPath).Length)
-						{
-							m_downloadedBytes = m_totalBytes;
-							m_state = State.COMPLETED;
-							m_onProgressUpdated?.Invoke(this);
+					{
+					m_downloadedBytes = m_totalBytes;
+					m_state = State.COMPLETED;
+					m_onProgressUpdated?.Invoke(this);
 							return;
 						}
 						File.Delete(m_dstPath);
 					}
 					using FileStream fileStream = new FileStream(m_srcPath, FileMode.Open, FileAccess.Read);
 					using FileStream fileStream2 = new FileStream(m_dstPath, FileMode.OpenOrCreate, FileAccess.Write);
-					int num;
-					do
-					{
-						num = fileStream.Read(m_buffer, 0, m_buffer.Length);
-						if (num > 0)
-						{
-							fileStream2.Write(m_buffer, 0, num);
-							m_downloadedBytes += num;
+							int num;
+							do
+							{
+								num = fileStream.Read(m_buffer, 0, m_buffer.Length);
+								if (num > 0)
+								{
+									fileStream2.Write(m_buffer, 0, num);
+									m_downloadedBytes += num;
+									m_onProgressUpdated?.Invoke(this);
+								}
+							}
+							while (num > 0);
+							m_state = State.COMPLETED;
 							m_onProgressUpdated?.Invoke(this);
 						}
-					}
-					while (num > 0);
-					m_state = State.COMPLETED;
-					m_onProgressUpdated?.Invoke(this);
-				}
 				catch (Exception ex)
 				{
 					Log.Downloader.PrintError("EditorAssetDownloader: Failed to download file from path = " + m_srcPath + " : Error = " + ex.Message);
@@ -335,8 +335,8 @@ namespace Hearthstone.Core.Streaming
 					if (File.Exists(assetBundlePath) && !isFreshDownload && item.Length == new FileInfo(assetBundlePath).Length)
 					{
 						Log.Downloader.PrintInfo("Skipping " + item.Name + " already present on disk");
-						continue;
-					}
+							continue;
+						}
 					item.CopyTo(assetBundlePath, overwrite: true);
 					Log.Downloader.PrintInfo("Copied essential bundle: " + item.Name);
 					num++;
@@ -589,9 +589,9 @@ namespace Hearthstone.Core.Streaming
 					if (Mode == DownloadMode.Local)
 					{
 						if (text.StartsWith("local"))
-						{
-							assetBundleDownloadProgress.BytesDownloaded = assetBundleDownloadProgress.BytesTotal;
-						}
+					{
+						assetBundleDownloadProgress.BytesDownloaded = assetBundleDownloadProgress.BytesTotal;
+					}
 					}
 					else if (assetBundleDownloadProgress.BytesDownloaded > 0 && !File.Exists(assetBundleDownloadProgress.Path))
 					{
@@ -603,7 +603,7 @@ namespace Hearthstone.Core.Streaming
 						if (num2 <= 0 && File.Exists(assetBundleDownloadProgress.Path))
 						{
 							num2 = new FileInfo(assetBundleDownloadProgress.Path).Length;
-						}
+					}
 						assetBundleDownloadProgress.BytesDownloaded = Math.Min(num2, assetBundleDownloadProgress.BytesTotal);
 					}
 					num++;
@@ -763,7 +763,7 @@ namespace Hearthstone.Core.Streaming
 				}
 			}
 			TrySerializeDownloadProgress();
-			Log.Downloader.PrintInfo($"EditorAssetDownloader.DeleteDownloadedData complete. tags deleted = {string.Join(',', tags)} : deletedDataSize = {num}");
+			Log.Downloader.PrintInfo($"EditorAssetDownloader.DeleteDownloadedData complete. tags deleted = {string.Join(",", tags)} : deletedDataSize = {num}");
 			return num;
 		}
 
diff --git a/Assembly-CSharp/Hearthstone/Core/Streaming/InternetReachableController.cs b/Assembly-CSharp/Hearthstone/Core/Streaming/InternetReachableController.cs
index a168aca..f865d23 100644
--- a/Assembly-CSharp/Hearthstone/Core/Streaming/InternetReachableController.cs
+++ b/Assembly-CSharp/Hearthstone/Core/Streaming/InternetReachableController.cs
@@ -32,15 +32,6 @@ namespace Hearthstone.Core.Streaming
 
 		private string m_optionOverride;
 
-		[CompilerGenerated]
-		private DownloadModeForInternetUnreachable <Mode>k__BackingField = DownloadModeForInternetUnreachable.NONE;
-
-		[CompilerGenerated]
-		private float <Duration>k__BackingField;
-
-		[CompilerGenerated]
-		private long <Bytes>k__BackingField;
-
 		private NetworkReachabilityManager m_networkReachabilityManager;
 
 		protected string OptionStorage
@@ -57,32 +48,11 @@ namespace Hearthstone.Core.Streaming
 
 		public bool InternetAvailable => m_networkReachabilityManager?.InternetAvailable_Cached ?? NetworkReachabilityManager.InternetAvailable;
 
-		protected DownloadModeForInternetUnreachable Mode
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Mode>k__BackingField = value;
-			}
-		}
+		protected DownloadModeForInternetUnreachable Mode { get; set; }
 
-		protected float Duration
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Duration>k__BackingField = value;
-			}
-		}
+		protected float Duration { get; set; }
 
-		protected long Bytes
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Bytes>k__BackingField = value;
-			}
-		}
+		protected long Bytes { get; set; }
 
 		public bool Initialize()
 		{
@@ -139,5 +109,10 @@ namespace Hearthstone.Core.Streaming
 			Bytes = ConvertBytesFromMB(result2);
 			return true;
 		}
+
+		public InternetReachableController()
+		{
+			Mode = DownloadModeForInternetUnreachable.NONE;
+		}
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/Core/Streaming/RuntimeAssetDownloader.cs b/Assembly-CSharp/Hearthstone/Core/Streaming/RuntimeAssetDownloader.cs
index a72b12a..430ea84 100644
--- a/Assembly-CSharp/Hearthstone/Core/Streaming/RuntimeAssetDownloader.cs
+++ b/Assembly-CSharp/Hearthstone/Core/Streaming/RuntimeAssetDownloader.cs
@@ -160,9 +160,9 @@ namespace Hearthstone.Core.Streaming
 			{
 				using MD5 mD = MD5.Create();
 				using FileStream inputStream = File.OpenRead(filename);
-				return BitConverter.ToString(mD.ComputeHash(inputStream)).Replace("-", "").ToLowerInvariant();
-			}
-		}
+						return BitConverter.ToString(mD.ComputeHash(inputStream)).Replace("-", "").ToLowerInvariant();
+					}
+				}
 
 		private static readonly string[] s_dbfTags = new string[2]
 		{
@@ -1069,11 +1069,11 @@ namespace Hearthstone.Core.Streaming
 				try
 				{
 					DirectoryInfo directoryInfo = new DirectoryInfo(text);
-					if (directoryInfo.Exists)
-					{
-						directoryInfo.Delete(recursive: true);
-					}
+				if (directoryInfo.Exists)
+				{
+					directoryInfo.Delete(recursive: true);
 				}
+			}
 				catch (Exception ex)
 				{
 					Error.AddDevFatal("Failed to delete a folder({0}): {1}", text, ex.Message);
@@ -1109,7 +1109,7 @@ namespace Hearthstone.Core.Streaming
 			}
 			m_tagIndicatorManager.DeleteIndicatorsForTags(tags);
 			ResetTagDownloadStatus(tags);
-			Log.Downloader.PrintInfo($"RuntimeAssetDownloader.DeleteDownloadedData complete. Deleted data for tags : {string.Join(',', tags)} : deletedDataSize = {num}");
+			Log.Downloader.PrintInfo($"RuntimeAssetDownloader.DeleteDownloadedData complete. Deleted data for tags : {string.Join(",", tags)} : deletedDataSize = {num}");
 			return num;
 		}
 
@@ -1125,7 +1125,7 @@ namespace Hearthstone.Core.Streaming
 			{
 				if (item.Tags.Intersect(array).Any() && item.Tags.Intersect(array2).Any())
 				{
-					Log.Downloader.PrintInfo("Resetting progress for tag download status because one of it's content-quality combination was deleted : tagDownloadStatus.Tags = " + string.Join(',', item.Tags) + " : deleted tags : " + string.Join(',', deletedTags));
+					Log.Downloader.PrintInfo("Resetting progress for tag download status because one of it's content-quality combination was deleted : tagDownloadStatus.Tags = " + string.Join(",", item.Tags) + " : deleted tags : " + string.Join(",", deletedTags));
 					item.ResetProgress();
 				}
 			}
@@ -1992,10 +1992,10 @@ namespace Hearthstone.Core.Streaming
 				{
 					if (m_curDownloadStatus.Tags.Contains(DownloadTags.GetTagString(DownloadTags.Quality.Initial)))
 					{
-						Log.Downloader.PrintInfo("UPDATE_GLOBAL Done!!!");
-						UpdateState = "Updated";
-						GoToIdleState();
-					}
+					Log.Downloader.PrintInfo("UPDATE_GLOBAL Done!!!");
+					UpdateState = "Updated";
+					GoToIdleState();
+				}
 					else
 					{
 						m_agentState = AgentState.NONE;
@@ -2408,7 +2408,7 @@ namespace Hearthstone.Core.Streaming
 					Log.Downloader.PrintDebug($"Debug.Redownload set with '{@int}");
 					if (@int >= 3)
 					{
-						DeleteDownloadedData();
+					DeleteDownloadedData();
 						Log.Downloader.PrintDebug("Deleted Data folder");
 					}
 					if (@int >= 2)
@@ -2420,8 +2420,8 @@ namespace Hearthstone.Core.Streaming
 				}
 				else
 				{
-					CleanupUnusedLanguages();
-				}
+				CleanupUnusedLanguages();
+			}
 			}
 			catch (Exception ex)
 			{
@@ -2972,9 +2972,9 @@ namespace Hearthstone.Core.Streaming
 				}
 				Log.Downloader.PrintInfo("Setting version override to token for " + EnumUtils.GetString(Pipeline) + ":" + VersionToken);
 				AgentEmbeddedAPI.SetVersionServiceUrlOverride(ProductName, url, VersionToken);
-			}
+				}
 			VersionOverrideUrl = EnumUtils.GetString(Pipeline);
-		}
+			}
 
 		private string GetNGDPRegion()
 		{
diff --git a/Assembly-CSharp/Hearthstone/Core/Streaming/TagIndicatorManager.cs b/Assembly-CSharp/Hearthstone/Core/Streaming/TagIndicatorManager.cs
index 4770da7..5843889 100644
--- a/Assembly-CSharp/Hearthstone/Core/Streaming/TagIndicatorManager.cs
+++ b/Assembly-CSharp/Hearthstone/Core/Streaming/TagIndicatorManager.cs
@@ -167,7 +167,7 @@ namespace Hearthstone.Core.Streaming
 					m_lastQualityTags[text2] = -1;
 				}
 			}
-			Log.Downloader.PrintInfo("DeleteIndicatorsForTags complete. Deleted tag indicators for tags : " + string.Join(',', tags));
+			Log.Downloader.PrintInfo("DeleteIndicatorsForTags complete. Deleted tag indicators for tags : " + string.Join(",", tags));
 			Check();
 		}
 
diff --git a/Assembly-CSharp/Hearthstone/Core/Streaming/VersionConfigurationService.cs b/Assembly-CSharp/Hearthstone/Core/Streaming/VersionConfigurationService.cs
index be2b52c..1e2f333 100644
--- a/Assembly-CSharp/Hearthstone/Core/Streaming/VersionConfigurationService.cs
+++ b/Assembly-CSharp/Hearthstone/Core/Streaming/VersionConfigurationService.cs
@@ -13,6 +13,7 @@ namespace Hearthstone.Core.Streaming
 {
 	public class VersionConfigurationService : IService
 	{
+
 		private string m_tokenFromFile = string.Empty;
 
 		private VersionPipeline m_pipelineFromFile;
@@ -46,29 +47,29 @@ namespace Hearthstone.Core.Streaming
 				{
 					string text2 = map["pipeline"];
 					if (EnumUtils.TryGetEnum<VersionPipeline>(text2, out var outVal))
-					{
+				{
 						Log.Downloader.PrintInfo("Setting pipeline override from deeplink args {0}", text2);
-						PipelineOverride = outVal;
-					}
-					else
-					{
+					PipelineOverride = outVal;
+				}
+				else
+				{
 						Log.Downloader.PrintInfo("Pipeline override deeplink arg was found but it was invalid: {0}", text2);
-					}
 				}
+			}
 				if (map.ContainsKey("version_token"))
-				{
+			{
 					string text3 = map["version_token"];
 					if (text3.Length == 36)
-					{
+				{
 						Log.Downloader.PrintInfo("Setting token override from deeplink args {0}", text3);
 						TokenOverride = text3;
-					}
-					else
-					{
+				}
+				else
+				{
 						Log.Downloader.PrintInfo("Token override deeplink arg was found but it was invalid: {0}", text3);
-					}
 				}
 			}
+			}
 			yield return new JobDefinition("VersionConfigurationService.LoadTokenConfigFile", Job_LoadConfigFiles());
 		}
 
diff --git a/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs b/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
index 5c7eb22..a368b05 100644
--- a/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
+++ b/Assembly-CSharp/Hearthstone/ExceptionReporterControl.cs
@@ -1,5 +1,6 @@
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using System.IO;
 using System.Text;
 using Blizzard.BlizzardErrorMobile;
@@ -107,6 +108,37 @@ namespace Hearthstone
 			HearthstoneApplication.Get().Resetting += ExceptionReporter.Get().ClearExceptionHashes;
 		}
 
+		public void ExceptionReportInitializeDebug()
+		{
+			ExceptionReporter.Get().Initialize(PlatformFilePaths.PersistentDataPath, m_logger, HearthstoneApplication.Get());
+			ExceptionReporter.Get().IsInDebugMode = true;
+			ExceptionReporter.Get().SendExceptions = false;
+			ExceptionReporter.Get().SendAsserts = false;
+			ExceptionReporter.Get().SendErrors = false;
+			ExceptionSettings exceptionSettings = new ExceptionSettings();
+			exceptionSettings.m_projectID = 70;
+			exceptionSettings.m_moduleName = "Hearthstone Client";
+			exceptionSettings.m_version = "20.8";
+			exceptionSettings.m_branchName = Network.BranchName;
+			exceptionSettings.m_buildNumber = 86601;
+			exceptionSettings.m_locale = Localization.GetLocaleName();
+			exceptionSettings.m_jiraProjectName = "HSTN";
+			exceptionSettings.m_jiraComponent = "T5QA Confirmation";
+			exceptionSettings.m_jiraVersion = "20.8 Patch";
+			exceptionSettings.m_logLineLimits[ExceptionSettings.ReportType.BUG] = -1;
+			if (HearthstoneApplication.IsInternal())
+			{
+				exceptionSettings.m_logLineLimits[ExceptionSettings.ReportType.EXCEPTION] = 0;
+			}
+			exceptionSettings.m_logPathsCallback = GetLogPaths;
+			exceptionSettings.m_attachableFilesCallback = GetAttachableFiles;
+			exceptionSettings.m_additionalInfoCallback = GetAdditionalInfo;
+			exceptionSettings.m_readFileMethodCallback = ReadLogFileSharing;
+			ExceptionReporter.Get().BeforeZipping += FlushAllLogs;
+			ExceptionReporter.Get().SetSettings(exceptionSettings);
+			HearthstoneApplication.Get().Resetting += ExceptionReporter.Get().ClearExceptionHashes;
+		}
+
 		public void ControlANRMonitor(bool on)
 		{
 			if (PlatformSettings.IsMobileRuntimeOS && (on ^ m_ANRMonitorOn))
@@ -199,7 +231,7 @@ namespace Hearthstone
 					string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(new FileInfo(filepath).Name);
 					Logger fullLogger = LogSystem.Get().GetFullLogger(fileNameWithoutExtension);
 					result = ((fullLogger == null || !Path.GetFullPath(fullLogger.FilePath).Equals(Path.GetFullPath(filepath))) ? File.ReadAllBytes(filepath) : Encoding.ASCII.GetBytes(fullLogger.GetContent()));
-				}
+					}
 			}
 			catch (Exception ex)
 			{
diff --git a/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs b/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
index eca3a5c..db4b217 100644
--- a/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
+++ b/Assembly-CSharp/Hearthstone/HearthstoneApplication.cs
@@ -5,6 +5,7 @@ using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Threading;
+using Accessibility;
 using Blizzard.BlizzardErrorMobile;
 using Blizzard.T5.AssetManager;
 using Blizzard.T5.Configuration;
@@ -70,6 +71,10 @@ namespace Hearthstone
 		};
 
 		private static bool s_initializedMode = false;
+		//private static bool s_initializedMode = true; // Dev mode
+
+		private static ApplicationMode s_mode = ApplicationMode.PUBLIC;
+		//private static ApplicationMode s_mode = ApplicationMode.INTERNAL; // Dev mode
 
 		private static string[] s_cachedCmdLineArgs = null;
 
@@ -97,8 +102,6 @@ namespace Hearthstone
 
 		private float m_unloadUnusedAssetsDelay;
 
-		private static ApplicationMode s_mode = ApplicationMode.INVALID;
-
 		private static HearthstoneApplication s_instance = null;
 
 		private static int s_mainThreadId = -1;
@@ -191,15 +194,16 @@ namespace Hearthstone
 			UpdateWorkingDirectory();
 			LocalOptions.Get().Initialize();
 			HearthstoneLocalization.Initialize();
+			AccessibilityMgr.Initialize(gameObject);
 			DeeplinkService.Get().Initialize();
 			LaunchArguments.ReadLaunchArgumentsFromDeeplink();
-			Processor.SetLogger(Log.Jobs);
+			Processor.SetLogger((Blizzard.T5.Core.ILogger)Log.Jobs);
 			ApplyInitializationSettingsFromConfig();
 			Processor.UseJobQueueAlerts = !IsPublic();
 			PreviousInstanceStatus.ReportAppStatus();
 			new JobQueueTelemetry(Processor.JobQueue, Processor.JobQueueAlerts, TestType);
 			Application.runInBackground = true;
-			Application.backgroundLoadingPriority = ThreadPriority.Normal;
+			Application.backgroundLoadingPriority = UnityEngine.ThreadPriority.Normal;
 			GameStrings.LoadNative();
 			if (IsPublic())
 			{
@@ -225,7 +229,8 @@ namespace Hearthstone
 			BlizzardAttributionManager.Get().Initialize();
 			TelemetryManager.Initialize();
 			TracertReporter.SendTelemetry();
-			ExceptionReporterControl.Get().ExceptionReportInitialize();
+			// ExceptionReporterControl.Get().ExceptionReportInitialize(); // Remove so we don't send Blizzard exceptions that may be caused by us
+			ExceptionReporterControl.Get().ExceptionReportInitializeDebug();
 			TelemetryManager.Client().SendSystemDetail(TelemetryUtil.GetUnitySystemInfo());
 			HearthstonePerformance.Initialize(TestType, 3758606.ToString(), 198037);
 			HearthstonePerformance.Get()?.CaptureAppStartTime();
@@ -279,6 +284,8 @@ namespace Hearthstone
 
 		private void OnApplicationQuit()
 		{
+			AccessibleHearthstoneApplication.OnClosing();
+			AccessibilityMgr.Shutdown();
 			IsHearthstoneClosing = true;
 			UberText.StoreCachedData(UberTextCacheFolderPath, UberTextCacheFilePath, 198037, Log.UberText);
 			if (this.OnShutdown != null)
@@ -514,7 +521,7 @@ namespace Hearthstone
 
 		private ServiceLocator RegisterRuntimeServices()
 		{
-			ServiceLocator runtimeServices = new ServiceLocator("Hearthstone Services", Processor.JobQueue, Log.Services, delegate(Exception exception)
+			ServiceLocator runtimeServices = new ServiceLocator("Hearthstone Services", Processor.JobQueue, (Blizzard.T5.Core.ILogger)Log.Services, delegate(Exception exception)
 			{
 				ExceptionReporter.Get()?.ReportCaughtException(exception);
 			});
@@ -583,7 +590,7 @@ namespace Hearthstone
 			runtimeServices.RegisterService<HearthstoneCheckout>();
 			runtimeServices.RegisterService<NetworkReachabilityManager>();
 			runtimeServices.RegisterService<VersionConfigurationService>();
-			runtimeServices.RegisterService<ILoginService>(new LoginService(Log.Login));
+			runtimeServices.RegisterService<ILoginService>(new LoginService((Blizzard.T5.Core.ILogger)Log.Login));
 			runtimeServices.RegisterService<PartyManager>();
 			runtimeServices.RegisterService<PlayerMigrationManager>();
 			runtimeServices.RegisterService<CosmeticCoinManager>();
@@ -597,8 +604,8 @@ namespace Hearthstone
 			runtimeServices.RegisterService<DiamondRenderToTextureService>();
 			runtimeServices.RegisterService<MessagePopupDisplay>();
 			runtimeServices.RegisterService<PrivacyGate>();
-			runtimeServices.RegisterService<APIGatewayService>(new APIGatewayService(Log.Net));
-			runtimeServices.RegisterService<Hearthstone.BreakingNews.BreakingNews>(new Hearthstone.BreakingNews.BreakingNews(Log.BreakingNews, HttpRequestFactory.Get()));
+			runtimeServices.RegisterService<APIGatewayService>(new APIGatewayService((Blizzard.T5.Core.ILogger)Log.Net));
+			runtimeServices.RegisterService<Hearthstone.BreakingNews.BreakingNews>(new Hearthstone.BreakingNews.BreakingNews((Blizzard.T5.Core.ILogger)Log.BreakingNews, HttpRequestFactory.Get()));
 			runtimeServices.RegisterService<IGameStringsService>(new GameStringsService());
 			runtimeServices.RegisterService<LuckyDrawManager>();
 			runtimeServices.RegisterService<CameraManager>();
@@ -653,7 +660,8 @@ namespace Hearthstone
 			WaitForGameDownloadManagerAvailable waitForGameDownloadManagerAvailable = new WaitForGameDownloadManagerAvailable();
 			WaitForGameDownloadManagerState waitForGameDownloadManagerState = new WaitForGameDownloadManagerState();
 			JobDefinition jobDefinition = new JobDefinition("GameStrings.LoadAll", GameStrings.Job_LoadAll(), waitForGameDownloadManagerState);
-			Processor.QueueJob("HearthstoneApplication.InitializeMode", Job_InitializeMode());
+			jobDefinition.AddJobFinishedEventListener(OnGameStringsLoaded);
+			Processor.QueueJob("HearthstoneApplication.InitializeMode", Job_InitializeMode(), Array.Empty<IJobDependency>());
 			Processor.QueueJob(jobDefinition);
 			Processor.QueueJob("UberText.LoadCachedData", UberText.Job_LoadCachedData(UberTextCacheFolderPath, UberTextCacheFilePath, PlatformFilePaths.PersistentDataPath, 198037, Log.UberText));
 			Processor.QueueJob(HearthstoneJobs.CreateJobFromAction("HearthstoneApplication.SetWindowText", SetWindowText, jobDefinition.CreateDependency()));
@@ -701,7 +709,12 @@ namespace Hearthstone
 			}
 		}
 
-		private void InitializeGlobalDataContext()
+        private void OnGameStringsLoaded(JobDefinition job, bool success)
+        {
+			AccessibleHearthstoneApplication.OnLoading();
+        }
+
+        private void InitializeGlobalDataContext()
 		{
 			DataContext dataContext = GlobalDataContext.Get();
 			dataContext.BindDataModel(new DeviceDataModel
@@ -736,7 +749,7 @@ namespace Hearthstone
 
 		private void ResetImmediately(bool forceLogin)
 		{
-			Log.Reset.Print("HearthstoneApplication.ResetImmediately - forceLogin? " + forceLogin + "  Stack trace: " + Environment.StackTrace);
+			Log.Reset.Print("HearthstoneApplication.ResetImmediately - forceLogin? " + forceLogin + "  Stack trace: " + Environment.StackTrace, Array.Empty<object>());
 			TelemetryManager.Client().SendClientReset(forceLogin, forceNoAccountTutorial: false);
 			Processor.JobQueue?.ClearJobs();
 			UnityEngine.Object.Instantiate(Resources.Load<GameObject>("Splash/PreloadScreen"));
@@ -770,9 +783,10 @@ namespace Hearthstone
 			TelemetryManager.Reset();
 			TelemetryManager.SetAppUserContext(TelemetryManager.ProgramId, TelemetryManager.ProgramName, TelemetryManager.ProgramVersion, TelemetryManager.SessionId);
 			Navigation.Clear();
+
 			Processor.QueueJob("HearthstoneApplication.OnResetDownloadComplete", Job_OnResetDownloadComplete(), new WaitForGameDownloadManagerAvailable());
 			m_resetting = false;
-			Log.Reset.Print("\tHearthstoneApplication.ResetImmediately completed");
+			Log.Reset.Print("\tHearthstoneApplication.ResetImmediately completed", Array.Empty<object>());
 		}
 
 		public IEnumerator<IAsyncJobResult> Job_OnResetDownloadComplete()
@@ -921,7 +935,7 @@ namespace Hearthstone
 				}
 				else if (!string.IsNullOrEmpty(str))
 				{
-					Log.ConfigFile.PrintWarning("Unable to evaluate Minimum  Job Delay value {0}, defaulting to {1}" + str, Processor.JobQueue.Debug.JobDelayMin);
+					Log.ConfigFile.PrintWarning("Unable to evaluate Minimum  Job Delay value {0}, defaulting to {1}" + str, new object[1] { Processor.JobQueue.Debug.JobDelayMin });
 				}
 				if (float.TryParse(str2, out result))
 				{
@@ -929,7 +943,7 @@ namespace Hearthstone
 				}
 				else if (!string.IsNullOrEmpty(str2))
 				{
-					Log.ConfigFile.PrintWarning("Unable to evaluate Maximum Job Delay value {0}, defaulting to {1}" + str2, Processor.JobQueue.Debug.JobDelayMax);
+					Log.ConfigFile.PrintWarning("Unable to evaluate Maximum Job Delay value {0}, defaulting to {1}" + str2, new object[1] { Processor.JobQueue.Debug.JobDelayMax });
 				}
 			}
 			else
diff --git a/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs b/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
index fed28d0..672929a 100644
--- a/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
+++ b/Assembly-CSharp/Hearthstone/InGameMessage/UI/MessagePopupDisplay.cs
@@ -7,10 +7,11 @@ using Blizzard.T5.Services;
 using Hearthstone.Core;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.InGameMessage.UI
 {
-	public class MessagePopupDisplay : IService
+	public class MessagePopupDisplay : IService, AccessibleUI
 	{
 		private MessageUIData m_currentlyDisplayedMessage;
 
@@ -341,6 +342,7 @@ namespace Hearthstone.InGameMessage.UI
 				m_messageModal.SetMessageList(messagesToDisplay, OnSetCurrentMessage);
 				m_modalWidget.Show();
 				UIContext.GetRoot().ShowPopup(m_modalWidget.gameObject);
+				ReadMessages(messagesToDisplay);
 			}
 			catch (Exception ex)
 			{
@@ -390,6 +392,7 @@ namespace Hearthstone.InGameMessage.UI
 
 		private void OnMessageClosed()
 		{
+			AccessibilityMgr.HideUI(this);
 			m_messageDisplayList.Clear();
 			m_currentlyDisplayedMessage = null;
 			m_onClosed?.Invoke();
@@ -466,5 +469,82 @@ namespace Hearthstone.InGameMessage.UI
 				m_messageModal.ForceClose();
 			}
 		}
+
+		#region Accessibility
+
+		private Queue<MessageUIData> s_messagesToRead;
+
+		private void ReadMessages(List<MessageUIData> messages)
+		{
+			s_messagesToRead = new Queue<MessageUIData>(messages);
+
+			AccessibilityMgr.ShowUI(this);
+
+			ReadNextMessage();
+		}
+
+		private void ReadNextMessage()
+		{
+			if (s_messagesToRead.Count == 0)
+			{
+				m_messageModal.OnClosePressed();
+			}
+			else
+			{
+				var nextMessage = s_messagesToRead.Dequeue();
+				ReadMessage(nextMessage);
+			}
+		}
+
+		private void ReadMessage(MessageUIData data)
+		{
+			List<IDataModel> list = MessageDataModelFactory.CreateDataModel(data);
+
+			if (list == null)
+			{
+				ReadNextMessage();
+				return;
+			}
+
+			foreach (var item in list)
+			{
+				switch (item)
+				{
+					case TextMessageContent i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+						AccessibilityMgr.Output(this, i.TextBody);
+						break;
+					case ShopMessageContent i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+						AccessibilityMgr.Output(this, i.TextBody);
+						break;
+					case TestDebugMessageUIData i:
+						AccessibilityMgr.ShowUI(this);
+						AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+						AccessibilityMgr.Output(this, i.TestString);
+						break;
+					default:
+						ReadNextMessage();
+						return;
+				}
+			}
+		}
+
+		public void HandleAccessibleInput()
+		{
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				ReadNextMessage();
+			}
+		}
+
+		public string GetAccessibleHelp()
+		{
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+		}
+
+		#endregion
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/LettuceVillage.cs b/Assembly-CSharp/Hearthstone/LettuceVillage.cs
index 58e7f78..2b33012 100644
--- a/Assembly-CSharp/Hearthstone/LettuceVillage.cs
+++ b/Assembly-CSharp/Hearthstone/LettuceVillage.cs
@@ -220,7 +220,7 @@ namespace Hearthstone
 				break;
 			case "BUILDING_UPGRADE_ANIM_START_EVENT_CODE":
 				if (m_widget.GetDataModel<EventDataModel>()?.Payload is MercenaryVillageBuildingDataModel mercenaryVillageBuildingDataModel2)
-				{
+			{
 					mercenaryVillageBuildingDataModel2.IsConstructionAnimationPlaying = true;
 					m_isBuildingAnimating = true;
 				}
@@ -317,14 +317,14 @@ namespace Hearthstone
 			NetCache.ProfileNoticeMercenariesRewards nextBonusMercenariesRewardToShow = PopupDisplayManager.Get().RewardPopups.GetNextBonusMercenariesRewardToShow();
 			if (nextNonAutoRetireRewardMercenariesRewardToShow == null || !popupDisplayManager.RewardPopups.ShowMercenariesRewards(autoOpenChest: false, nextNonAutoRetireRewardMercenariesRewardToShow, nextBonusMercenariesRewardToShow, OnVillageEntered))
 			{
-				LettuceVillageDataUtil.ZoneWasRecentlyUnlocked = popupDisplayManager.RewardPopups.ShowMercenariesZoneUnlockPopup(OnVillageEntered);
-				if (!LettuceVillageDataUtil.ZoneWasRecentlyUnlocked && !popupDisplayManager.RewardPopups.ShowMercenariesFullyUpgraded(OnVillageEntered) && !popupDisplayManager.RewardPopups.ShowNextMercenariesSeasonRewards(OnVillageEntered))
-				{
-					SendEventUpwardStateAction.SendEventUpward(base.gameObject, "UNBLOCK_INPUT");
-					OnVillageEnteredRewardsFinished();
-				}
+			LettuceVillageDataUtil.ZoneWasRecentlyUnlocked = popupDisplayManager.RewardPopups.ShowMercenariesZoneUnlockPopup(OnVillageEntered);
+			if (!LettuceVillageDataUtil.ZoneWasRecentlyUnlocked && !popupDisplayManager.RewardPopups.ShowMercenariesFullyUpgraded(OnVillageEntered) && !popupDisplayManager.RewardPopups.ShowNextMercenariesSeasonRewards(OnVillageEntered))
+			{
+				SendEventUpwardStateAction.SendEventUpward(base.gameObject, "UNBLOCK_INPUT");
+				OnVillageEnteredRewardsFinished();
 			}
 		}
+		}
 
 		private IEnumerator WaitForPopupManager()
 		{
@@ -439,7 +439,7 @@ namespace Hearthstone
 					break;
 				}
 			}
-			if (lettuceVillageTutorialBone != null && UserAttentionManager.CanShowAttentionGrabber("VillageDisplay.HandleTutorialAttentionEvent:" + tutEvent))
+			if (lettuceVillageTutorialBone != null && UserAttentionManager.CanShowAttentionGrabber(false, "VillageDisplay.HandleTutorialAttentionEvent:" + tutEvent))
 			{
 				Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, lettuceVillageTutorialBone.transform.localPosition, lettuceVillageTutorialBone.transform.localScale, GameStrings.Get(lettuceVillageTutorialBone.LocalizationKey));
 				notification.ShowPopUpArrow(lettuceVillageTutorialBone.ArrowDirection);
@@ -913,10 +913,10 @@ namespace Hearthstone
 			if (!(NetCache.Get().GetNetObject<NetCache.NetCacheLettuceMap>()?.Map?.Active).GetValueOrDefault())
 			{
 				if (netObject.UnlockedBountyDifficultyLevel >= 2)
-				{
-					GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.MERCENARIES, GameSaveKeySubkeyId.MERCENARIES_HAS_SEEN_HEROIC_PVE_ZONE_FANFARE, out long value3);
-					alternateCondition = value3 == 0;
-				}
+			{
+				GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.MERCENARIES, GameSaveKeySubkeyId.MERCENARIES_HAS_SEEN_HEROIC_PVE_ZONE_FANFARE, out long value3);
+				alternateCondition = value3 == 0;
+			}
 				if (netObject.UnlockedBountyDifficultyLevel >= 3)
 				{
 					GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.MERCENARIES, GameSaveKeySubkeyId.MERCENARIES_HAS_SEEN_MYTHIC_PVE_ZONE_FANFARE, out long value4);
diff --git a/Assembly-CSharp/Hearthstone/Login/AccountRepairer.cs b/Assembly-CSharp/Hearthstone/Login/AccountRepairer.cs
index d1c9d9e..677a4ef 100644
--- a/Assembly-CSharp/Hearthstone/Login/AccountRepairer.cs
+++ b/Assembly-CSharp/Hearthstone/Login/AccountRepairer.cs
@@ -10,12 +10,11 @@ namespace Hearthstone.Login
 	{
 		private class RemoveAccountCallbackWrapper : IOnAccountRemovedCallback
 		{
-			[CompilerGenerated]
-			private readonly Action<bool> <Callback>k__BackingField;
+			public Action<bool> Callback { get; set; }
 
 			public RemoveAccountCallbackWrapper(Action<bool> callback)
 			{
-				<Callback>k__BackingField = callback;
+				Callback = callback;
 			}
 		}
 
diff --git a/Assembly-CSharp/Hearthstone/Login/LoginService.cs b/Assembly-CSharp/Hearthstone/Login/LoginService.cs
index f967357..d94f369 100644
--- a/Assembly-CSharp/Hearthstone/Login/LoginService.cs
+++ b/Assembly-CSharp/Hearthstone/Login/LoginService.cs
@@ -18,29 +18,9 @@ namespace Hearthstone.Login
 	{
 		private class AccountRemoveLogger : IOnAccountRemovedCallback
 		{
-			[CompilerGenerated]
-			private string <AccountId>k__BackingField;
+			private string AccountId { get; set; }
 
-			[CompilerGenerated]
-			private ILogger <Logger>k__BackingField;
-
-			private string AccountId
-			{
-				[CompilerGenerated]
-				set
-				{
-					<AccountId>k__BackingField = value;
-				}
-			}
-
-			private ILogger Logger
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Logger>k__BackingField = value;
-				}
-			}
+			private ILogger Logger { get; set; }
 
 			public AccountRemoveLogger(string accountId, ILogger logger)
 			{
diff --git a/Assembly-CSharp/Hearthstone/Login/OfflineAuthTokenCache.cs b/Assembly-CSharp/Hearthstone/Login/OfflineAuthTokenCache.cs
index b75e967..1fa2d94 100644
--- a/Assembly-CSharp/Hearthstone/Login/OfflineAuthTokenCache.cs
+++ b/Assembly-CSharp/Hearthstone/Login/OfflineAuthTokenCache.cs
@@ -9,23 +9,13 @@ namespace Hearthstone.Login
 {
 	public class OfflineAuthTokenCache
 	{
-		[CompilerGenerated]
-		private bool <FailedToGenerateLoginWebToken>k__BackingField;
-
 		protected DateTime? m_lastRequestedLoginTokenTime;
 
 		private readonly ILogger m_logger;
 
 		protected string m_webToken;
 
-		private bool FailedToGenerateLoginWebToken
-		{
-			[CompilerGenerated]
-			set
-			{
-				<FailedToGenerateLoginWebToken>k__BackingField = value;
-			}
-		}
+		private bool FailedToGenerateLoginWebToken { get; set; }
 
 		protected TimeSpan? LoginTokenAge { get; set; }
 
diff --git a/Assembly-CSharp/Hearthstone/MarketingImages/MarketingImageContent.cs b/Assembly-CSharp/Hearthstone/MarketingImages/MarketingImageContent.cs
index 52e977e..a8987a2 100644
--- a/Assembly-CSharp/Hearthstone/MarketingImages/MarketingImageContent.cs
+++ b/Assembly-CSharp/Hearthstone/MarketingImages/MarketingImageContent.cs
@@ -6,49 +6,13 @@ namespace Hearthstone.MarketingImages
 {
 	public class MarketingImageContent
 	{
-		[CompilerGenerated]
-		private string <EntryTitle>k__BackingField;
-
-		[CompilerGenerated]
-		private string <Title>k__BackingField;
-
-		[CompilerGenerated]
-		private DateTime <PublishDate>k__BackingField;
-
-		[CompilerGenerated]
-		private DateTime <BeginningDate>k__BackingField;
-
-		[CompilerGenerated]
-		private DateTime <ExpiryDate>k__BackingField;
-
-		[CompilerGenerated]
-		private int <MinGameVersion>k__BackingField;
-
-		[CompilerGenerated]
-		private int <MaxGameVersion>k__BackingField;
-
 		public string UID { get; set; }
 
-		public string EntryTitle
-		{
-			[CompilerGenerated]
-			set
-			{
-				<EntryTitle>k__BackingField = value;
-			}
-		}
+		public string EntryTitle {get; set;}
 
 		public HashSet<string> Tags { get; } = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
-
-		public string Title
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Title>k__BackingField = value;
-			}
-		}
+		public string Title {get; set;}
 
 		public string TextureAssetUrl { get; set; }
 
@@ -56,50 +20,15 @@ namespace Hearthstone.MarketingImages
 
 		public float TextureOffsetY { get; set; }
 
-		public DateTime PublishDate
-		{
-			[CompilerGenerated]
-			set
-			{
-				<PublishDate>k__BackingField = value;
-			}
-		}
-
-		public DateTime BeginningDate
-		{
-			[CompilerGenerated]
-			set
-			{
-				<BeginningDate>k__BackingField = value;
-			}
-		}
-
-		public DateTime ExpiryDate
-		{
-			[CompilerGenerated]
-			set
-			{
-				<ExpiryDate>k__BackingField = value;
-			}
-		}
-
-		public int MinGameVersion
-		{
-			[CompilerGenerated]
-			set
-			{
-				<MinGameVersion>k__BackingField = value;
-			}
-		}
-
-		public int MaxGameVersion
-		{
-			[CompilerGenerated]
-			set
-			{
-				<MaxGameVersion>k__BackingField = value;
-			}
-		}
+		public DateTime PublishDate {get; set;}
+
+		public DateTime BeginningDate {get; set;}
+
+		public DateTime ExpiryDate {get; set;}
+
+		public int MinGameVersion {get; set;}
+
+		public int MaxGameVersion {get; set;}
 
 		public long ProductId { get; set; }
 
diff --git a/Assembly-CSharp/Hearthstone/Networking/BattleNet/BattleNetLogger.cs b/Assembly-CSharp/Hearthstone/Networking/BattleNet/BattleNetLogger.cs
index 4b24492..9d2b926 100644
--- a/Assembly-CSharp/Hearthstone/Networking/BattleNet/BattleNetLogger.cs
+++ b/Assembly-CSharp/Hearthstone/Networking/BattleNet/BattleNetLogger.cs
@@ -40,11 +40,11 @@ namespace Hearthstone.Networking.BattleNet
 				string message = "[BattleNet] " + str;
 				if (logLevel2 == Blizzard.T5.Core.LogLevel.Warning)
 				{
-					Debug.LogWarning(message);
+					UnityEngine.Debug.LogWarning(message);
 				}
 				else
 				{
-					Debug.LogError(message);
+					UnityEngine.Debug.LogError(message);
 				}
 			}
 		}
diff --git a/Assembly-CSharp/Hearthstone/Progression/AchievementCell.cs b/Assembly-CSharp/Hearthstone/Progression/AchievementCell.cs
index 37a9c5f..df43761 100644
--- a/Assembly-CSharp/Hearthstone/Progression/AchievementCell.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/AchievementCell.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -97,6 +98,7 @@ namespace Hearthstone.Progression
 			else
 			{
 				StartClaimSequence(dataModel.ID);
+																		AccessibleJournal.Get().OnAchievementClaimed();
 			}
 		}
 
@@ -153,6 +155,7 @@ namespace Hearthstone.Progression
 			else
 			{
 				m_achievementTile.BindDataModel(dataModel);
+
 			}
 		}
 
diff --git a/Assembly-CSharp/Hearthstone/Progression/AchievementToast.cs b/Assembly-CSharp/Hearthstone/Progression/AchievementToast.cs
index ffefa70..6002266 100644
--- a/Assembly-CSharp/Hearthstone/Progression/AchievementToast.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/AchievementToast.cs
@@ -1,6 +1,7 @@
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -81,6 +82,7 @@ namespace Hearthstone.Progression
 				}
 				m_toast.Show();
 			}
+			ReadToast();
 		}
 
 		public void Hide()
@@ -116,5 +118,10 @@ namespace Hearthstone.Progression
 				componentInChildren.Show();
 			});
 		}
+	#region accessibility
+		private void ReadToast() {
+			AccessibilityMgr.Output(null, m_text.Text);
+		}
+	#endregion
 	}
-}
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Hearthstone/Progression/CoinPreview.cs b/Assembly-CSharp/Hearthstone/Progression/CoinPreview.cs
index cf38565..2b01050 100644
--- a/Assembly-CSharp/Hearthstone/Progression/CoinPreview.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/CoinPreview.cs
@@ -2,73 +2,75 @@ using System.Collections;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
-	[RequireComponent(typeof(WidgetTemplate))]
-	public class CoinPreview : MonoBehaviour
-	{
-		public UIBButton m_favoriteButton;
+    [RequireComponent(typeof(WidgetTemplate))]
+    public class CoinPreview : MonoBehaviour, AccessibleUI
+    {
+        public UIBButton m_favoriteButton;
 
-		public GameObject m_cardTargetTransformMarker;
+        public GameObject m_cardTargetTransformMarker;
 
-		public GameObject m_cardDisplay;
+        public GameObject m_cardDisplay;
 
-		public Clickable m_clickable;
+        public Clickable m_clickable;
 
-		private WidgetTemplate m_widget;
+        private WidgetTemplate m_widget;
 
-		private ScreenEffectsHandle m_screenEffectsHandle;
+        private ScreenEffectsHandle m_screenEffectsHandle;
 
-		private Transform m_startTransform;
+        private Transform m_startTransform;
 
-		private bool m_hidingAnimTriggered;
+        private bool m_hidingAnimTriggered;
 
 		private int? m_currentCoinId = -1;
 
 		private CardDataModel m_coinCardDatamodel;
 
-		private const string CODE_HIDE = "CODE_HIDE_COIN_PREVIEW";
+        private const string CODE_HIDE = "CODE_HIDE_COIN_PREVIEW";
 
-		private const string START_HIDE = "START_HIDE_COIN_PREVIEW";
+        private const string START_HIDE = "START_HIDE_COIN_PREVIEW";
 
-		private const string START_SHOW = "START_SHOW_COIN_PREVIEW";
+        private const string START_SHOW = "START_SHOW_COIN_PREVIEW";
 
-		private void Awake()
-		{
-			m_screenEffectsHandle = new ScreenEffectsHandle(this);
-			m_widget = GetComponent<WidgetTemplate>();
-			m_widget.RegisterEventListener(HandleEvent);
-		}
+        private void Awake()
+        {
+            m_screenEffectsHandle = new ScreenEffectsHandle(this);
+            m_widget = GetComponent<WidgetTemplate>();
+            m_widget.RegisterEventListener(HandleEvent);
+        }
 
 		public void EnterPreviewWhenReady(CardDataModel cardDataModel, int coinId, Transform startTransform)
-		{
-			m_startTransform = startTransform;
+        {
+            m_startTransform = startTransform;
 			m_currentCoinId = coinId;
 			m_coinCardDatamodel = cardDataModel;
 			UpdateView();
 			CosmeticCoinManager.Get().OnFavoriteCoinsChanged += OnFavoriteCoinsChanged;
-			m_widget.Hide();
-			m_hidingAnimTriggered = false;
-			StartCoroutine(ShowWhenReady());
-		}
-
-		private IEnumerator ShowWhenReady()
-		{
-			while (!m_widget.IsReady || m_widget.IsChangingStates)
-			{
-				yield return null;
-			}
-			if (m_startTransform != null)
-			{
-				m_cardTargetTransformMarker.transform.position = m_cardDisplay.transform.position;
-				TransformUtil.SetWorldScale(m_cardTargetTransformMarker, m_cardDisplay.transform.lossyScale);
-				m_cardDisplay.transform.position = m_startTransform.position;
-				TransformUtil.SetWorldScale(m_cardDisplay, m_startTransform.lossyScale);
-			}
-			m_widget.TriggerEvent("START_SHOW_COIN_PREVIEW");
-			m_widget.Show();
-		}
+            m_widget.Hide();
+            m_hidingAnimTriggered = false;
+            StartCoroutine(ShowWhenReady());
+            ReadCoinPreview(cardDataModel);
+        }
+
+        private IEnumerator ShowWhenReady()
+        {
+            while (!m_widget.IsReady || m_widget.IsChangingStates)
+            {
+                yield return null;
+            }
+            if (m_startTransform != null)
+            {
+                m_cardTargetTransformMarker.transform.position = m_cardDisplay.transform.position;
+                TransformUtil.SetWorldScale(m_cardTargetTransformMarker, m_cardDisplay.transform.lossyScale);
+                m_cardDisplay.transform.position = m_startTransform.position;
+                TransformUtil.SetWorldScale(m_cardDisplay, m_startTransform.lossyScale);
+            }
+            m_widget.TriggerEvent("START_SHOW_COIN_PREVIEW");
+            m_widget.Show();
+        }
 
 		private void UpdateView()
 		{
@@ -93,29 +95,30 @@ namespace Hearthstone.Progression
 			UpdateView();
 		}
 
-		public void OnFinishHideAnim()
-		{
+        public void OnFinishHideAnim()
+        {
 			CosmeticCoinManager.Get().OnFavoriteCoinsChanged -= OnFavoriteCoinsChanged;
-			UIContext.GetRoot().DismissPopup(base.gameObject);
+            UIContext.GetRoot().DismissPopup(base.gameObject);
 			if (m_widget != null)
-			{
-				m_widget.Hide();
-			}
+            {
+                m_widget.Hide();
+            }
+            AccessibilityMgr.HideUI(this);
 			Object.Destroy(base.transform.parent.gameObject);
-		}
+        }
 
-		private void UpdateCoinCard(CardDataModel cardDataModel)
-		{
-			m_widget.BindDataModel(cardDataModel);
-		}
+        private void UpdateCoinCard(CardDataModel cardDataModel)
+        {
+            m_widget.BindDataModel(cardDataModel);
+        }
 
-		private void HandleEvent(string eventName)
-		{
-			if (eventName == "CODE_HIDE_COIN_PREVIEW")
-			{
-				BeginHideAnim();
-			}
-		}
+        private void HandleEvent(string eventName)
+        {
+            if (eventName == "CODE_HIDE_COIN_PREVIEW")
+            {
+                BeginHideAnim();
+            }
+        }
 
 		private void OnFavoriteButtonClicked(object e)
 		{
@@ -124,13 +127,44 @@ namespace Hearthstone.Progression
 			BeginHideAnim();
 		}
 
-		private void BeginHideAnim()
-		{
-			if (!m_hidingAnimTriggered)
-			{
-				m_widget?.TriggerEvent("START_HIDE_COIN_PREVIEW");
-				m_hidingAnimTriggered = true;
-			}
-		}
-	}
-}
+        private void BeginHideAnim()
+        {
+            if (!m_hidingAnimTriggered)
+            {
+                m_widget?.TriggerEvent("START_HIDE_COIN_PREVIEW");
+                m_hidingAnimTriggered = true;
+            }
+        }
+
+        #region Accessibility
+
+        private AccessibleMenu m_accessibleMenu;
+
+        private void ReadCoinPreview(CardDataModel cardDataModel)
+        {
+            AccessibilityMgr.ShowUI(this);
+
+            m_accessibleMenu = new AccessibleMenu(this, cardDataModel.Name, BeginHideAnim);
+            m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_READ_FLAVOR), () => AccessibilityMgr.Output(this, cardDataModel.FlavorText));
+
+            if (m_favoriteButton.IsEnabled())
+            {
+                m_accessibleMenu.AddOption(m_favoriteButton.GetText(), m_favoriteButton.TriggerRelease);
+            }
+
+            m_accessibleMenu.StartReading();
+        }
+
+        public void HandleAccessibleInput()
+        {
+            m_accessibleMenu?.HandleAccessibleInput();
+        }
+
+        public string GetAccessibleHelp()
+        {
+            return m_accessibleMenu?.GetHelp();
+        }
+
+        #endregion
+    }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/Hearthstone/Progression/JournalPopup.cs b/Assembly-CSharp/Hearthstone/Progression/JournalPopup.cs
index 19a27b1..e0d9116 100644
--- a/Assembly-CSharp/Hearthstone/Progression/JournalPopup.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/JournalPopup.cs
@@ -7,6 +7,7 @@ using Hearthstone.DataModels;
 using Hearthstone.Store;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -183,7 +184,9 @@ namespace Hearthstone.Progression
 			{
 				FatalErrorMgr.Get().RemoveErrorListener(OnFatalError);
 			}
-		}
+
+            AccessibleJournal.Get().OnJournalClosed();
+        }
 
 		public virtual void Show()
 		{
@@ -205,6 +208,8 @@ namespace Hearthstone.Progression
 				{
 					m_journalMetaDatamodel.DoneChangingTabs = true;
 				}
+
+				AccessibleJournal.Get().OnJournalOpened(m_widget, (!m_journalMetaDatamodel.IsApprenticeTrackActive && !m_journalMetaDatamodel.IsTavernGuideActive) ? m_rewardTrackType : Global.RewardTrackType.APPRENTICE);
 			}, null, callImmediatelyIfSet: true, doOnce: true);
 		}
 
@@ -215,7 +220,7 @@ namespace Hearthstone.Progression
 				MusicManager.Get()?.StartPlaylist(MusicPlaylistType.UI_Battlegrounds);
 			}
 			else
-			{
+		{
 				Box box = Box.Get();
 				if (box != null)
 				{
@@ -316,7 +321,10 @@ namespace Hearthstone.Progression
 			GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.FTUE_HAS_SEEN_TAVERN_GUIDE_INTRODUCTION, out long value);
 			if (value != 1)
 			{
-				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, NotificationManager.DEFAULT_CHARACTER_POS, GameStrings.Get("GLUE_PROGRESSION_APPRENTICE_TUTORIALS_INNKEEEPER_LEARN_ROPES"), "");
+				if (!AccessibilityMgr.IsAccessibilityEnabled())
+				{
+					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, NotificationManager.DEFAULT_CHARACTER_POS, GameStrings.Get("GLUE_PROGRESSION_APPRENTICE_TUTORIALS_INNKEEEPER_LEARN_ROPES"), "");
+				}
 				GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.FTUE_HAS_SEEN_TAVERN_GUIDE_INTRODUCTION, 1L));
 				if (m_journalMetaDatamodel == null)
 				{
diff --git a/Assembly-CSharp/Hearthstone/Progression/JournalTrayDisplay.cs b/Assembly-CSharp/Hearthstone/Progression/JournalTrayDisplay.cs
index 8fd7bdd..1095ea2 100644
--- a/Assembly-CSharp/Hearthstone/Progression/JournalTrayDisplay.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/JournalTrayDisplay.cs
@@ -4,6 +4,7 @@ using Assets;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -99,7 +100,9 @@ namespace Hearthstone.Progression
 			{
 				if (m_rewardTrackType == Global.RewardTrackType.GLOBAL && m_journalMetaDatamodel.EventActive && m_journalMetaDatamodel.EventIsNew)
 				{
-					s_activeTabIndexByType[m_rewardTrackType] = 0;
+					// The event tab is not accessible and spawns a popup that breaks the mod.
+					//TODO: Implement accessibility for the event tab and reinstate this.
+					s_activeTabIndexByType[m_rewardTrackType] = m_initialTabIndexPerSession; // was 0
 				}
 				else if (m_rewardTrackType == Global.RewardTrackType.GLOBAL && !m_journalMetaDatamodel.IsApprenticeTrackActive && m_journalMetaDatamodel.IsTavernGuideActive)
 				{
@@ -159,6 +162,7 @@ namespace Hearthstone.Progression
 						}
 						m_journalMetaDatamodel.DoneChangingTabs = true;
 					}, null, callImmediatelyIfSet: true, doOnce: true);
+          StartCoroutine(AccessibleJournal.Get().OnTabChanged(m_journalMetaDatamodel));
 					return;
 				}
 				m_simulateFirstTransition = false;
@@ -172,22 +176,26 @@ namespace Hearthstone.Progression
 				m_widget.TriggerEvent($"CODE_{e.SourceName}_FINISHED", new TriggerEventParameters(e.SourceName, previousIndex, noDownwardPropagation: true, ignorePlaymaker: true));
 				if (e.SourceName.Equals("REWARD_TAB"))
 				{
-					RewardTrack rewardTrack = RewardTrackManager.Get().GetRewardTrack(m_rewardTrackType);
-					if (rewardTrack == null || !rewardTrack.IsValid)
-					{
-						Debug.LogError(string.Format("{0}: no reward track found of type {1}.", "JournalTrayDisplay", m_rewardTrackType));
-					}
+				RewardTrack rewardTrack = RewardTrackManager.Get().GetRewardTrack(m_rewardTrackType);
+				if (rewardTrack == null || !rewardTrack.IsValid)
+				{
+					Debug.LogError(string.Format("{0}: no reward track found of type {1}.", "JournalTrayDisplay", m_rewardTrackType));
+				}
 					else if (rewardTrack.TrackDataModel.Season > rewardTrack.TrackDataModel.SeasonLastSeen)
-					{
-						rewardTrack.SetRewardTrackSeasonLastSeen(rewardTrack.TrackDataModel.Season);
-					}
+				{
+					rewardTrack.SetRewardTrackSeasonLastSeen(rewardTrack.TrackDataModel.Season);
+				}
 				}
 				if (m_shouldHideTrayOnTabChanged)
 				{
 					m_widget.Show();
 				}
 				m_journalMetaDatamodel.DoneChangingTabs = true;
+          StartCoroutine(AccessibleJournal.Get().OnTabChanged(m_journalMetaDatamodel));
 			}, null, callImmediatelyIfSet: true, doOnce: true);
 		}
 	}
+
+	#region accessibility
+	#endregion
 }
diff --git a/Assembly-CSharp/Hearthstone/Progression/PlayerState.cs b/Assembly-CSharp/Hearthstone/Progression/PlayerState.cs
index 3e6a863..ea251b6 100644
--- a/Assembly-CSharp/Hearthstone/Progression/PlayerState.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/PlayerState.cs
@@ -11,6 +11,8 @@ namespace Hearthstone.Progression
 
 		private readonly Func<int, T> m_defaultProvider;
 
+		private Map<int, T> m_cheatState;
+
 		public event Action<T, T> OnStateChanged = delegate
 		{
 		};
@@ -22,6 +24,11 @@ namespace Hearthstone.Progression
 
 		public T GetState(int id)
 		{
+			if (m_cheatState != null)
+			{
+				return m_cheatState[id];
+			}
+
 			if (!m_playerState.TryGetValue(id, out var value))
 			{
 				Func<int, T> defaultProvider = m_defaultProvider;
@@ -37,23 +44,53 @@ namespace Hearthstone.Progression
 		public void UpdateState(int id, T newState)
 		{
 			T state = GetState(id);
-			m_playerState[id] = newState;
+
+			if (m_cheatState != null)
+			{
+				m_cheatState[id] = newState;
+			}
+			else
+			{
+				m_playerState[id] = newState;
+			}
 			this.OnStateChanged(state, newState);
 		}
 
 		public void Reset()
 		{
-			m_playerState.Clear();
+			if (m_cheatState != null)
+			{
+				m_cheatState.Clear();
+			}
+			else
+			{
+				m_playerState.Clear();
+			}
 		}
 
 		IEnumerator<T> IEnumerable<T>.GetEnumerator()
 		{
+			if (m_cheatState != null)
+			{
+				return m_cheatState.Values.GetEnumerator();
+			}
 			return m_playerState.Values.GetEnumerator();
 		}
 
 		public IEnumerator GetEnumerator()
 		{
+			if (m_cheatState != null)
+			{
+				return m_cheatState.Values.GetEnumerator();
+			}
 			return m_playerState.Values.GetEnumerator();
 		}
+
+		#region Accessibility Testing
+		public void Cheat_SetCheatState(Map<int, T> cheatState)
+		{
+			m_cheatState = cheatState;
+		}
+		#endregion
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/Progression/QuestManager.cs b/Assembly-CSharp/Hearthstone/Progression/QuestManager.cs
index a9174e1..fa20007 100644
--- a/Assembly-CSharp/Hearthstone/Progression/QuestManager.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/QuestManager.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
+using Accessibility;
 using Assets;
 using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
@@ -182,6 +183,11 @@ namespace Hearthstone.Progression
 
 		public QuestListDataModel CreateActiveQuestsDataModel(QuestPool.QuestPoolType questPoolType, QuestPool.RewardTrackType rewardTrackType, bool appendTimeUntilNextQuest)
 		{
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				return AccessibleQuestsTestingUtils.GetQuestsForPoolType(questPoolType);
+			}
+
 			QuestListDataModel questListDataModel = new QuestListDataModel();
 			List<int> list = null;
 			if (questPoolType == QuestPool.QuestPoolType.NONE)
@@ -350,6 +356,36 @@ namespace Hearthstone.Progression
 			return true;
 		}
 
+		private void DebugQuestListDataModel(QuestListDataModel questListDataModel)
+		{
+			if (!HearthstoneAccessConstants.DEV_MODE)
+			{
+				return;
+			}
+			AccessibilityUtils.LogDebug("Debugging QuestListDataModel");
+			foreach (var quest in questListDataModel.Quests)
+			{
+				AccessibilityUtils.LogDebug("-");
+				AccessibilityUtils.LogDebug($"--- QuestId: {quest.QuestId}");
+				AccessibilityUtils.LogDebug($"--- PoolId: {quest.PoolId}");
+				AccessibilityUtils.LogDebug($"--- PoolType: {quest.PoolType}");
+				AccessibilityUtils.LogDebug($"--- DisplayMode: {quest.DisplayMode}");
+				AccessibilityUtils.LogDebug($"--- Name: {quest.Name}");
+				AccessibilityUtils.LogDebug($"--- Description: {quest.Description}");
+				AccessibilityUtils.LogDebug($"--- Icon: {quest.Icon}");
+				AccessibilityUtils.LogDebug($"--- Progress: {quest.Progress}");
+				AccessibilityUtils.LogDebug($"--- Quota: {quest.Quota}");
+				AccessibilityUtils.LogDebug($"--- RerollCount: {quest.RerollCount}");
+				AccessibilityUtils.LogDebug($"--- Rewards: {quest.Rewards}");
+				AccessibilityUtils.LogDebug($"--- RewardTrackXp: {quest.RewardTrackXp}");
+				AccessibilityUtils.LogDebug($"--- ProgressMessage: {quest.ProgressMessage}");
+				AccessibilityUtils.LogDebug($"--- Status: {quest.Status}");
+				AccessibilityUtils.LogDebug($"--- Abandonable: {quest.Abandonable}");
+				AccessibilityUtils.LogDebug($"--- NextInChain: {quest.NextInChain}");
+				AccessibilityUtils.LogDebug("-");
+			}
+		}
+
 		public bool AckQuest(int questId)
 		{
 			if (!m_questState.TryGetValue(questId, out var value))
@@ -369,12 +405,21 @@ namespace Hearthstone.Progression
 				value.Status = 5;
 				break;
 			}
-			Network.Get().AckQuest(questId);
+
+			if (!AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				Network.Get().AckQuest(questId);
+			}
 			return false;
 		}
 
 		public bool RerollQuest(int questId)
 		{
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				return AccessibleQuestsTestingUtils.RerollQuest(questId);
+			}
+
 			if (!m_questState.TryGetValue(questId, out var value))
 			{
 				return false;
@@ -398,6 +443,10 @@ namespace Hearthstone.Progression
 
 		public bool AbandonQuest(int questId)
 		{
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				return AccessibleQuestsTestingUtils.AbandonQuest(questId);
+			}
 			if (!m_questState.TryGetValue(questId, out var value))
 			{
 				return false;
@@ -422,6 +471,11 @@ namespace Hearthstone.Progression
 
 		public bool CanBeGrantedPoolQuests()
 		{
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				return AccessibleQuestsTestingUtils.CanBeGrantedPoolQuests();
+			}
+
 			return !TavernGuideManager.Get().IsTavernGuideActive();
 		}
 
@@ -474,7 +528,7 @@ namespace Hearthstone.Progression
 			return value;
 		}
 
-		private QuestDataModel CreateQuestDataModel(PlayerQuestState questState)
+		internal QuestDataModel CreateQuestDataModel(PlayerQuestState questState)
 		{
 			if (questState == null || RewardTrackManager.Get() == null)
 			{
@@ -531,7 +585,13 @@ namespace Hearthstone.Progression
 			};
 		}
 
-		private QuestDataModel CreateNextQuestTimeDataModel(QuestPoolDbfRecord questPoolRecord)
+		internal QuestDataModel CreateNextQuestTimeDataModel(QuestPoolDbfRecord questPoolRecord)
+		{
+			var timeUntilNextQuestString = GetTimeUntilNextQuestString(questPoolRecord.ID);
+			return CreateNextQuestTimeDataModel(questPoolRecord, timeUntilNextQuestString);
+		}
+
+		internal QuestDataModel CreateNextQuestTimeDataModel(QuestPoolDbfRecord questPoolRecord, string timeUntilNextQuestString)
 		{
 			string key = "GLOBAL_PROGRESSION_QUEST_TIME_UNTIL_NEXT";
 			if (questPoolRecord.RewardTrackType == QuestPool.RewardTrackType.BATTLEGROUNDS)
@@ -541,7 +601,7 @@ namespace Hearthstone.Progression
 			QuestDataModel questDataModel = new QuestDataModel();
 			questDataModel.DisplayMode = QuestDisplayMode.NextQuestTime;
 			questDataModel.PoolType = questPoolRecord.QuestPoolType;
-			questDataModel.TimeUntilNextQuest = GameStrings.Format(key, GetTimeUntilNextQuestString(questPoolRecord.ID));
+			questDataModel.TimeUntilNextQuest = GameStrings.Format(key, timeUntilNextQuestString);
 			return questDataModel;
 		}
 
@@ -601,9 +661,19 @@ namespace Hearthstone.Progression
 			HandleExpiredQuests();
 		}
 
-		private void ReceivePlayerQuestStateUpdateMessage()
+		internal void ReceivePlayerQuestStateUpdateMessage()
 		{
-			PlayerQuestStateUpdate playerQuestStateUpdate = Network.Get().GetPlayerQuestStateUpdate();
+			PlayerQuestStateUpdate playerQuestStateUpdate;
+
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				playerQuestStateUpdate = AccessibleQuestsTestingUtils.GetPlayerQuestStateUpdate();
+			}
+			else
+			{
+				playerQuestStateUpdate = Network.Get().GetPlayerQuestStateUpdate();
+			}
+
 			if (playerQuestStateUpdate == null)
 			{
 				return;
@@ -693,9 +763,19 @@ namespace Hearthstone.Progression
 			}
 		}
 
-		private void ReceivePlayerQuestPoolStateUpdateMessage()
+		internal void ReceivePlayerQuestPoolStateUpdateMessage()
 		{
-			PlayerQuestPoolStateUpdate playerQuestPoolStateUpdate = Network.Get().GetPlayerQuestPoolStateUpdate();
+			PlayerQuestPoolStateUpdate playerQuestPoolStateUpdate;
+
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				playerQuestPoolStateUpdate = AccessibleQuestsTestingUtils.GetPlayerQuestPoolStateUpdate();
+			}
+			else
+			{
+				playerQuestPoolStateUpdate = Network.Get().GetPlayerQuestPoolStateUpdate();
+			}
+
 			if (playerQuestPoolStateUpdate == null)
 			{
 				return;
@@ -711,9 +791,19 @@ namespace Hearthstone.Progression
 			ScheduleCheckForNewQuests();
 		}
 
-		private void ReceiveRerollQuestResponseMessage()
+		internal void ReceiveRerollQuestResponseMessage()
 		{
-			RerollQuestResponse rerollQuestResponse = Network.Get().GetRerollQuestResponse();
+			RerollQuestResponse rerollQuestResponse;
+
+			if (AccessibleQuestsTestingUtils.IsMockingQuests())
+			{
+				rerollQuestResponse = AccessibleQuestsTestingUtils.GetRerollQuestResponse();
+			}
+			else
+			{
+				rerollQuestResponse = Network.Get().GetRerollQuestResponse();
+			}
+
 			if (rerollQuestResponse != null)
 			{
 				this.OnQuestRerolled?.Invoke(rerollQuestResponse.RerolledQuestId, rerollQuestResponse.GrantedQuestId, rerollQuestResponse.Success);
@@ -765,6 +855,12 @@ namespace Hearthstone.Progression
 			{
 				return "";
 			}
+
+			return GetElapsedTimeString(timeUntilNextQuest);
+		}
+
+		internal string GetElapsedTimeString(TimeSpan timeUntilNextQuest)
+		{
 			return TimeUtils.GetElapsedTimeString((long)timeUntilNextQuest.TotalSeconds, TimeUtils.SPLASHSCREEN_DATETIME_STRINGSET, roundUp: true);
 		}
 
@@ -818,7 +914,10 @@ namespace Hearthstone.Progression
 			{
 				if (!GameMgr.Get().IsFindingGame())
 				{
-					Network.Get().CheckForNewQuests();
+					if (!AccessibleQuestsTestingUtils.IsMockingQuests())
+					{
+						Network.Get().CheckForNewQuests();
+					}
 				}
 				ScheduleCheckForNewQuests();
 			}
diff --git a/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs b/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
index 54484b7..5e79ee9 100644
--- a/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/QuestNotificationPopup.cs
@@ -3,11 +3,13 @@ using Assets;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class QuestNotificationPopup : MonoBehaviour
+	public class QuestNotificationPopup : MonoBehaviour, AccessibleUI
 	{
 		public Widget m_questList;
 
@@ -25,12 +27,18 @@ namespace Hearthstone.Progression
 
 		private const string CODE_HIDE = "CODE_HIDE";
 
+		#region Accessibility
+		private QuestListDataModel m_questListDataModel;
+
+		private AccessibleListOfItems<AccessibleQuest> m_accessibleQuests;
+		#endregion
+
 		private void Awake()
 		{
 			m_widget = GetComponent<WidgetTemplate>();
 			m_widget.RegisterEventListener(delegate(string eventName)
 			{
-				if (eventName == "CODE_HIDE")
+				if (eventName == CODE_HIDE)
 				{
 					Hide();
 				}
@@ -40,6 +48,8 @@ namespace Hearthstone.Progression
 
 		private void OnDestroy()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			m_callback?.Invoke();
 			InnKeepersSpecial.UnregisterClickCallback(Hide);
 			if (m_IKSShown)
@@ -50,10 +60,26 @@ namespace Hearthstone.Progression
 
 		public void Initialize(QuestListDataModel questListDataModel, Action callback, bool showIKS)
 		{
+			questListDataModel = OverrideQuestsIfNecessary(questListDataModel);
+
+			m_questListDataModel = questListDataModel;
 			m_callback = callback;
 			m_shouldShowIKS = showIKS;
 			if (questListDataModel != null)
 			{
+				// Accessiblity getting the pool type
+				for (int i = 0; i < questListDataModel.Quests.Count; i++)
+				{
+					var quest = questListDataModel.Quests[i];
+
+					if (i > 0 && m_questPoolType != quest.PoolType)
+					{
+						m_questPoolType = QuestPool.QuestPoolType.NONE;
+						break;
+					}
+					m_questPoolType = quest.PoolType;
+				}
+
 				bool flag = false;
 				if (questListDataModel.Quests.Count > m_maxQuestsPerRow)
 				{
@@ -91,17 +117,21 @@ namespace Hearthstone.Progression
 				}
 				m_widget.TriggerEvent("SHOW");
 			}, null, callImmediatelyIfSet: true, doOnce: true);
+
+			ReadPopup();
 		}
 
 		public void Hide()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			AckQuests();
 			SceneMgr.Get()?.UnregisterScenePreLoadEvent(OnPreLoadNextScene);
 			FatalErrorMgr.Get()?.RemoveErrorListener(OnFatalError);
 			if (base.transform != null && base.transform.parent != null && base.transform.parent.gameObject != null)
 			{
-				UnityEngine.Object.Destroy(base.transform.parent.gameObject);
-			}
+			UnityEngine.Object.Destroy(base.transform.parent.gameObject);
+		}
 		}
 
 		private void HandleDoneChangingStates(object unused)
@@ -157,5 +187,69 @@ namespace Hearthstone.Progression
 		{
 			Hide();
 		}
+
+        #region Accessibility
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_widget.TriggerEvent(CODE_HIDE);
+            }
+			else
+            {
+				m_accessibleQuests.HandleAccessibleInput();
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+			var helpText = LocalizationUtils.Get(LocalizationKey.UI_QUEST_NOTIFICATION_POPUP_HELP);
+			var continueHelp = AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+
+			return AccessibleSpeechUtils.CombineSentences(helpText, continueHelp);
+        }
+
+        private void ReadPopup()
+        {
+			AccessibilityMgr.ShowUI(this);
+			AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+
+			var accessibleQuests = new List<AccessibleQuest>();
+			foreach(var quest in m_questListDataModel.Quests)
+            {
+				accessibleQuests.Add(new AccessibleQuest(this, quest));
+            }
+
+			m_accessibleQuests = new AccessibleListOfItems<AccessibleQuest>(this, accessibleQuests);
+
+			if (m_questPoolType == QuestPool.QuestPoolType.WEEKLY)
+			{
+				AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_PROGRESSION_WEEKLY_QUESTS_POPUP_TITLE"));
+			}
+			else
+			{
+				AccessibilityMgr.Output(this, GameStrings.Get("GLOBAL_PROGRESSION_DAILY_QUESTS_POPUP_TITLE"));
+			}
+
+			m_accessibleQuests.StartReading();
+        }
+
+		#region Accessibility Testing
+		private QuestListDataModel OverrideQuestsIfNecessary(QuestListDataModel original)
+		{
+			var testingModel = AccessibleQuestsTestingUtils.GetQuests();
+
+			if (testingModel == null)
+			{
+				return original;
+			}
+
+			return testingModel;
+		}
+
+		#endregion
+
+		#endregion
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs b/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
index 55cf1f5..39e78bb 100644
--- a/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/QuestProgressToast.cs
@@ -1,6 +1,7 @@
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -17,6 +18,10 @@ namespace Hearthstone.Progression
 
 		private const string CODE_HIDE = "CODE_HIDE";
 
+		#region Accessibility
+		private QuestDataModel m_questDataModel;
+		#endregion
+
 		private void Awake()
 		{
 			m_toast = GetComponent<WidgetTemplate>();
@@ -31,6 +36,7 @@ namespace Hearthstone.Progression
 
 		public void Initialize(QuestDataModel questDataModel)
 		{
+			m_questDataModel = questDataModel;
 			m_toast.BindDataModel(questDataModel);
 		}
 
@@ -38,12 +44,13 @@ namespace Hearthstone.Progression
 		{
 			if (!(m_toast == null))
 			{
+				ReadToast();
 				OverlayUI.Get().AddGameObject(base.gameObject.transform.parent.gameObject, CanvasAnchor.BOTTOM);
 				m_toast.Show();
 			}
 		}
 
-		public void Hide()
+        public void Hide()
 		{
 			if (!(m_toast == null))
 			{
@@ -68,5 +75,22 @@ namespace Hearthstone.Progression
 				componentInChildren.Show();
 			});
 		}
+
+        #region Accessibility
+
+        private void ReadToast()
+        {
+			var quota = m_questDataModel.Quota;
+			var progress = m_questDataModel.Progress;
+
+			if (quota > 0)
+            {
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_TITLE));
+				AccessibilityMgr.OutputNotification(m_questDataModel.Description);
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, progress, quota));
+            }
+        }
+
+		#endregion
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/Progression/QuestTile.cs b/Assembly-CSharp/Hearthstone/Progression/QuestTile.cs
index 9d81c71..2f1b698 100644
--- a/Assembly-CSharp/Hearthstone/Progression/QuestTile.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/QuestTile.cs
@@ -2,6 +2,7 @@ using Blizzard.Telemetry.WTCG.Client;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -57,7 +58,7 @@ namespace Hearthstone.Progression
 			{
 				m_widget.TriggerEvent("DEBUG_SHOW_ID");
 			}
-		}
+				}
 
 		private void OnDoneChangingStates(object unused)
 		{
@@ -98,7 +99,7 @@ namespace Hearthstone.Progression
 
 		private void RerollQuest()
 		{
-			QuestDataModel dataModel = m_widget.GetDataModel<QuestDataModel>();
+			QuestDataModel dataModel = GetQuestDataModel();
 			if (dataModel != null && !m_isRerollPending)
 			{
 				if (!Network.IsLoggedIn())
@@ -116,7 +117,7 @@ namespace Hearthstone.Progression
 
 		private void AbandonQuest()
 		{
-			QuestDataModel dataModel = m_widget.GetDataModel<QuestDataModel>();
+			QuestDataModel dataModel = GetQuestDataModel();
 			if (dataModel != null)
 			{
 				if (!Network.IsLoggedIn())
@@ -169,15 +170,20 @@ namespace Hearthstone.Progression
 					TelemetryManager.Client().SendQuestTileClick(questDataModel.QuestId, GetQuestTileDisplayContext(questDataModel), QuestTileClickType.QTCT_ABANDON, string.Empty);
 					m_widget.TriggerEvent("CODE_REROLLED");
 					m_isRerollAnimPlaying = true;
+					AccessibleJournal.Get().OnQuestAbandoned(this);
 				}
 			}
+			else
+			{
+				AccessibleJournal.Get().OnQuestAbandonCancel();
+			}
 		}
 
 		private void OnQuestRerolled(int rerolledQuestId, int grantedQuestId, bool success)
 		{
 			if (m_isRerollPending)
 			{
-				QuestDataModel dataModel = m_widget.GetDataModel<QuestDataModel>();
+				QuestDataModel dataModel = GetQuestDataModel();
 				if (dataModel != null && dataModel.QuestId == rerolledQuestId)
 				{
 					TelemetryManager.Client().SendQuestTileClick(dataModel.QuestId, GetQuestTileDisplayContext(dataModel), QuestTileClickType.QTCT_REROLL, string.Empty);
@@ -191,7 +197,7 @@ namespace Hearthstone.Progression
 
 		private void OnQuestRerollCountChanged(int questPoolId, int rerollCount)
 		{
-			QuestDataModel dataModel = m_widget.GetDataModel<QuestDataModel>();
+			QuestDataModel dataModel = GetQuestDataModel();
 			if (dataModel != null && dataModel.PoolId == questPoolId)
 			{
 				dataModel.RerollCount = rerollCount;
@@ -217,6 +223,7 @@ namespace Hearthstone.Progression
 				{
 					m_widget.TriggerEvent("CODE_GRANTED_BY_REROLL");
 				}, null, callImmediatelyIfSet: true, doOnce: true);
+				AccessibleJournal.Get().OnQuestRerolled(this);
 			}
 			else
 			{
@@ -268,5 +275,16 @@ namespace Hearthstone.Progression
 				_ => DisplayContext.DC_CONTEXT_UNKNOWN, 
 			};
 		}
+
+
+		#region Accessibility
+
+		internal QuestDataModel GetQuestDataModel()
+        {
+			return m_widget.GetDataModel<QuestDataModel>();
+
+        }
+
+		#endregion
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/Progression/QuestXpReward.cs b/Assembly-CSharp/Hearthstone/Progression/QuestXpReward.cs
index c4a8c34..a29a3c9 100644
--- a/Assembly-CSharp/Hearthstone/Progression/QuestXpReward.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/QuestXpReward.cs
@@ -9,6 +9,7 @@ using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 namespace Hearthstone.Progression
 {
@@ -71,6 +72,12 @@ namespace Hearthstone.Progression
 
 		private const string SETUP_MODE_MERCENARIES = "MERCENARIES";
 
+		#region Accessibility
+		private int m_curLevel;
+
+		private int m_introXpGained;
+		#endregion
+
 		private static Comparison<RewardTrackXpChange> SortXPChanges = delegate(RewardTrackXpChange a, RewardTrackXpChange b)
 		{
 			int num = a.CurrLevel.CompareTo(b.CurrLevel);
@@ -136,6 +143,10 @@ namespace Hearthstone.Progression
 			{
 				return;
 			}
+
+			// A11y
+			m_curLevel = list[0].PrevLevel;
+
 			m_pauseOnNext = false;
 			m_isShowing = true;
 			m_gameXpCausedLevel = false;
@@ -306,7 +317,7 @@ namespace Hearthstone.Progression
 					questDataModel.RerollCount = 0;
 					questDataModel.DisplayMode = QuestManager.QuestDisplayMode.Inspection;
 					m_questTileWidget.BindDataModel(questDataModel);
-					AnimateQuestTile();
+					AnimateQuestTile(questDataModel);
 				}
 			}
 			else if (flag)
@@ -487,8 +498,10 @@ namespace Hearthstone.Progression
 			}
 		}
 
-		private void AnimateQuestTile()
+		private void AnimateQuestTile(QuestDataModel questDataModel)
 		{
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_TRACK_REWARD_XP_GAIN_FROM_QUEST, questDataModel.RewardTrackXp));
+			AccessibilityMgr.OutputNotification(questDataModel.Description);
 			m_fsm.SendEvent("AnimateQuestTile");
 		}
 
@@ -509,13 +522,28 @@ namespace Hearthstone.Progression
 
 		private void ShowIntroXp()
 		{
-			UpdateIntroXpVar(CalculateIntroXpGained());
+			m_introXpGained = CalculateIntroXpGained();
+
+			UpdateIntroXpVar(m_introXpGained);
 			AnimateIntroXp();
 			m_introShown = true;
 		}
 
 		private void OnPlayMakerFinished()
 		{
+			if (m_curLevel < m_dataModel.Level)
+			{
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_TRACK_REWARD_LEVEL_UP, m_dataModel.Level));
+			}
+
+			if (m_introXpGained > 0)
+			{
+				AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.UI_TRACK_REWARD_XP_GAIN, m_introXpGained));
+				m_introXpGained = 0;
+			}
+
+			m_curLevel = m_dataModel.Level;
+
 			if (m_isIntro)
 			{
 				m_isIntro = false;
diff --git a/Assembly-CSharp/Hearthstone/Progression/RewardPresenter.cs b/Assembly-CSharp/Hearthstone/Progression/RewardPresenter.cs
index b6a3047..89340e3 100644
--- a/Assembly-CSharp/Hearthstone/Progression/RewardPresenter.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/RewardPresenter.cs
@@ -112,7 +112,7 @@ namespace Hearthstone.Progression
 			rewardWidget.RegisterDoneChangingStatesListener(delegate
 			{
 				RewardScroll componentInChildren = rewardWidget.GetComponentInChildren<RewardScroll>();
-				componentInChildren.Initialize(delegate
+				componentInChildren.Initialize(rewardScrollDataModel, delegate
 				{
 					onHiddenCallback?.Invoke();
 				});
diff --git a/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs b/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
index 7cfe41f..48d0709 100644
--- a/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/RewardScroll.cs
@@ -2,11 +2,13 @@ using System;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class RewardScroll : MonoBehaviour
+	public class RewardScroll : MonoBehaviour, AccessibleUI
 	{
 		private const string HIDE = "CODE_HIDE";
 
@@ -22,12 +24,16 @@ namespace Hearthstone.Progression
 
 		private event Action OnRewardScrollShown;
 
+        #region Accessibility
+        private RewardScrollDataModel m_dataModel;
+		#endregion
+
 		private void Awake()
 		{
 			m_widget = GetComponent<WidgetTemplate>();
 			m_widget.RegisterEventListener(delegate(string eventName)
 			{
-				if (eventName == "CODE_HIDE")
+				if (eventName == HIDE)
 				{
 					if (m_isSignatureCard)
 					{
@@ -58,20 +64,25 @@ namespace Hearthstone.Progression
 
 		private void OnDestroy()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			if (FatalErrorMgr.IsInitialized())
 			{
 				FatalErrorMgr.Get().RemoveErrorListener(OnFatalError);
 			}
 		}
 
-		public void Initialize(Action onHiddenCallback, Action onShownCallback = null)
+		public void Initialize(RewardScrollDataModel dataModel, Action onHiddenCallback, Action onShownCallback = null)
 		{
+			m_dataModel = dataModel;
 			this.OnRewardScrollHidden = onHiddenCallback;
 			this.OnRewardScrollShown = onShownCallback;
 		}
 
 		public void Show()
 		{
+			ReadScroll();
+
 			OverlayUI.Get().AddGameObject(m_owner);
 			if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
 			{
@@ -81,8 +92,10 @@ namespace Hearthstone.Progression
 			this.OnRewardScrollShown?.Invoke();
 		}
 
-		private void Hide()
+        private void Hide()
 		{
+			AccessibilityMgr.HideUI(this);
+
 			if (SceneMgr.Get().GetMode() != SceneMgr.Mode.GAMEPLAY)
 			{
 				UIContext.GetRoot().DismissPopup(base.gameObject);
@@ -92,13 +105,15 @@ namespace Hearthstone.Progression
 			UnityEngine.Object.Destroy(m_owner);
 		}
 
-		public static Widget ShowFakeRewardWidget(RewardScrollDataModel dataModel)
+		public static Widget ShowFakeRewardWidget(RewardScrollDataModel dataModel, Action finishedCallback = null)
 		{
 			Widget widget = WidgetInstance.Create(RewardPresenter.REWARD_PREFAB);
 			widget.BindDataModel(dataModel);
 			widget.RegisterDoneChangingStatesListener(delegate
 			{
-				widget.GetComponentInChildren<RewardScroll>().Show();
+				RewardScroll componentInChildren = widget.GetComponentInChildren<RewardScroll>();
+				componentInChildren.Initialize(dataModel, finishedCallback);
+				componentInChildren.Show();
 			}, null, callImmediatelyIfSet: true, doOnce: true);
 			return widget;
 		}
@@ -112,5 +127,89 @@ namespace Hearthstone.Progression
 		{
 			ShowFakeRewardWidget(dataModel);
 		}
+
+        #region Accessibility
+
+		private void ReadScroll()
+        {
+			if (m_dataModel == null)
+			{
+				// Mercenaries scroll probably - this is not accessible
+				return;
+			}
+
+			AccessibilityMgr.ShowUI(this);
+
+            AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+
+            AccessibilityMgr.Output(this, m_dataModel.DisplayName);
+			AccessibilityMgr.Output(this, m_dataModel.Description);
+
+			ReadRewards();
+        }
+
+		private AccessibleListOfItems<AccessibleRewardItemDataModel> m_accessibleRewards;
+
+		private AccessibleRewardItemDataModel m_accessibleReward;
+
+        private void ReadRewards()
+        {
+            AccessibilityMgr.Output(this, LocalizedText.UI_REWARDS_TITLE);
+
+			m_accessibleRewards = null; // Reset in case of reuse
+			m_accessibleReward = null; // Reset in case of reuse
+
+			var rewards = m_dataModel.RewardList.Items;
+			var accessibleRewards = new List<AccessibleRewardItemDataModel>();
+
+			foreach (var reward in rewards)
+            {
+				accessibleRewards.Add(new AccessibleRewardItemDataModel(this, reward));
+            }
+			if (accessibleRewards.Count == 0) {
+								m_widget.TriggerEvent(HIDE);
+								return;
+			}
+			m_accessibleRewards = new AccessibleListOfItems<AccessibleRewardItemDataModel>(this, accessibleRewards);
+
+			if (m_accessibleRewards.Count == 1)
+            {
+				m_accessibleReward = m_accessibleRewards.Items[0];
+				m_accessibleReward.ReadAllLines();
+            }
+			else
+            {
+                m_accessibleRewards.StartReading();
+            }
+        }
+
+        public void HandleAccessibleInput()
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				m_widget.TriggerEvent(HIDE);
+            }
+			else
+            {
+				if (m_accessibleReward != null)
+                {
+					m_accessibleReward.HandleAccessibleInput();
+                }
+				else
+                {
+                    m_accessibleRewards.HandleAccessibleInput();
+                }
+            }
+        }
+
+        public string GetAccessibleHelp()
+        {
+			var helpText = LocalizationUtils.Get(LocalizationKey.UI_REWARD_SCROLL_HELP);
+			var continueHelp = AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+
+			return AccessibleSpeechUtils.CombineSentences(helpText, continueHelp);
+        }
+
+		#endregion
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/Progression/RewardTrack.cs b/Assembly-CSharp/Hearthstone/Progression/RewardTrack.cs
index 399aaf1..3bdd6c6 100644
--- a/Assembly-CSharp/Hearthstone/Progression/RewardTrack.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/RewardTrack.cs
@@ -2,11 +2,13 @@ using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
+using Accessibility;
 using Assets;
 using Hearthstone.Attribution;
 using Hearthstone.DataModels;
 using PegasusUtil;
 using UnityEngine;
+using Blizzard.T5.Core;
 
 namespace Hearthstone.Progression
 {
@@ -93,6 +95,12 @@ namespace Hearthstone.Progression
 
 		public bool AckReward(int rewardTrackId, int level, bool forPaidTrack)
 		{
+			if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+			{
+				AccessibleJournal.Get().OnTrackRewardAckd(rewardTrackId, level, forPaidTrack);
+				return true;
+			}
+
 			if (RewardTrackId == rewardTrackId)
 			{
 				if (!RewardExistsAtLevel(level, forPaidTrack))
@@ -118,11 +126,18 @@ namespace Hearthstone.Progression
 				}
 			}
 			Network.Get().AckRewardTrackReward(rewardTrackId, level, forPaidTrack);
+			AccessibleJournal.Get().OnTrackRewardAckd(rewardTrackId, level, forPaidTrack);
 			return true;
 		}
 
 		public bool ClaimReward(int rewardTrackId, int level, bool forPaidTrack, int chooseOneRewardItemId = 0)
 		{
+			if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+			{
+				m_pendingRewardClaimRequests[(rewardTrackId, level, forPaidTrack)] = chooseOneRewardItemId;
+				return AccessibleRewardsTrackTestingUtils.ClaimRewardTrackReward(rewardTrackId, level, forPaidTrack, chooseOneRewardItemId);
+			}
+
 			if (rewardTrackId == RewardTrackId)
 			{
 				if (!RewardExistsAtLevel(level, forPaidTrack))
@@ -515,22 +530,22 @@ namespace Hearthstone.Progression
 			{
 				return;
 			}
-			int rewardListId = (forPaidTrack ? rewardTrackLevelDbfRecord.PaidRewardList : rewardTrackLevelDbfRecord.FreeRewardList);
-			(int, int, bool) key = (rewardTrackLevelDbfRecord.RewardTrackId, level, forPaidTrack);
-			if (m_pendingRewardClaimRequests.TryGetValue(key, out var value))
-			{
-				m_pendingRewardClaimRequests.Remove(key);
-			}
-			string displayName;
-			if (ProgressUtils.IsEventRewardTrackType((Global.RewardTrackType)record.RewardTrackType))
-			{
-				int num = RewardTrackFactory.CalculateCumulativeXpForLevel(record, level);
-				displayName = GameStrings.Format("GLUE_PROGRESSION_EVENT_TAB_REWARD_SCROLL_TITLE", num);
-			}
-			else
-			{
-				displayName = GameStrings.Format("GLUE_PROGRESSION_REWARD_TRACK_REWARD_SCROLL_TITLE", level);
-			}
+				int rewardListId = (forPaidTrack ? rewardTrackLevelDbfRecord.PaidRewardList : rewardTrackLevelDbfRecord.FreeRewardList);
+				(int, int, bool) key = (rewardTrackLevelDbfRecord.RewardTrackId, level, forPaidTrack);
+				if (m_pendingRewardClaimRequests.TryGetValue(key, out var value))
+				{
+					m_pendingRewardClaimRequests.Remove(key);
+				}
+				string displayName;
+				if (ProgressUtils.IsEventRewardTrackType((Global.RewardTrackType)record.RewardTrackType))
+				{
+					int num = RewardTrackFactory.CalculateCumulativeXpForLevel(record, level);
+					displayName = GameStrings.Format("GLUE_PROGRESSION_EVENT_TAB_REWARD_SCROLL_TITLE", num);
+				}
+				else
+				{
+					displayName = GameStrings.Format("GLUE_PROGRESSION_REWARD_TRACK_REWARD_SCROLL_TITLE", level);
+				}
 			RewardScrollDataModel rewardScrollDataModel = RewardTrackFactory.CreateAdditionalRewardScrollDataModel(rewardListId, level, displayName, value, rewardItemOutput);
 			if (rewardScrollDataModel != null)
 			{
@@ -544,11 +559,11 @@ namespace Hearthstone.Progression
 					AckReward(rewardTrackId, level, forPaidTrack);
 				});
 			}
-			if (rewardTrackId == TrackDataModel.RewardTrackId)
-			{
-				SetChooseOneRewardItemAsOwned(level, forPaidTrack, value);
+				if (rewardTrackId == TrackDataModel.RewardTrackId)
+				{
+					SetChooseOneRewardItemAsOwned(level, forPaidTrack, value);
+				}
 			}
-		}
 
 		private RewardStatus GetRewardStatus(int level, bool forPaidTrack)
 		{
@@ -590,21 +605,21 @@ namespace Hearthstone.Progression
 					{
 						continue;
 					}
-					foreach (RewardItemDbfRecord rewardItem in item.PaidRewardListRecord.RewardItems)
-					{
-						if (rewardItem.RewardType == RewardItem.RewardType.REWARD_TRACK_XP_BOOST)
+						foreach (RewardItemDbfRecord rewardItem in item.PaidRewardListRecord.RewardItems)
 						{
-							float num2 = 1f + (float)rewardItem.Quantity / 100f;
-							if (num2 > num)
+							if (rewardItem.RewardType == RewardItem.RewardType.REWARD_TRACK_XP_BOOST)
 							{
-								num = num2;
+								float num2 = 1f + (float)rewardItem.Quantity / 100f;
+								if (num2 > num)
+								{
+									num = num2;
+								}
 							}
 						}
 					}
 				}
+				return num;
 			}
-			return num;
-		}
 
 		public string GetRewardTrackDebugHudString()
 		{
@@ -637,5 +652,27 @@ namespace Hearthstone.Progression
 			}
 			return "n/a";
 		}
+
+		#region Accessibility
+		public PlayerRewardTrackLevelState GetPlayerRewardTrackLevelState(int level)
+		{
+			return m_rewardTrackLevelState.GetState(level);
+		}
+
+		public bool ArePremiumRewardsUnlocked()
+		{
+			if (AccessibleRewardsTrackTestingUtils.IsMockingRewardsTrack())
+			{
+				return AccessibleRewardsTrackTestingUtils.ArePremiumRewardsUnlocked();
+			}
+			return TrackDataModel.PremiumRewardsUnlocked;
+		}
+
+		internal void Cheat_SetPlayerRewardTrackLevelState(Map<int, PlayerRewardTrackLevelState> state)
+		{
+			m_rewardTrackLevelState.Cheat_SetCheatState(state);
+		}
+
+		#endregion
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/Progression/RewardTrackChooseOneItemPopup.cs b/Assembly-CSharp/Hearthstone/Progression/RewardTrackChooseOneItemPopup.cs
index cd4e951..9abb546 100644
--- a/Assembly-CSharp/Hearthstone/Progression/RewardTrackChooseOneItemPopup.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/RewardTrackChooseOneItemPopup.cs
@@ -2,11 +2,14 @@ using System.Linq;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
+using System;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class RewardTrackChooseOneItemPopup : MonoBehaviour
+	public class RewardTrackChooseOneItemPopup : MonoBehaviour, AccessibleUI
 	{
 		public const string TURN_PAGE_LEFT = "CODE_TURN_PAGE_LEFT";
 
@@ -50,6 +53,9 @@ namespace Hearthstone.Progression
 				m_rewardListDataModel = m_widget.GetDataModel<RewardTrackNodeRewardsDataModel>().Items.CloneDataModel();
 				SetPageData(1);
 				break;
+                case "SHOW_POPUP_AFTER_CONFIRM": // A11y
+						ChooseHeroSkin();
+						break;
 			}
 		}
 
@@ -100,5 +106,139 @@ namespace Hearthstone.Progression
 				m_rewardListDataModel.Items = rewardListDataModel.Items.OrderBy((RewardItemDataModel item) => item, new RewardUtils.RewardOwnedItemComparer()).ToDataModelList();
 			}
 		}
-	}
+
+        #region Accessibility
+
+		private enum State { LOADING, CHOOSING_SKIN, CONFIRMING };
+
+		private State m_curState;
+
+        private AccessibleListOfItems<AccessibleRewardItemDataModel> m_accessibleRewards;
+
+        public void ReadPopup()
+        {
+			m_curState = State.LOADING;
+
+            AccessibilityMgr.ShowUI(this);
+            AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_POPUP), true);
+
+			var text = AccessibleWidgetUtils.GetUberText(gameObject, "Root/ItemTitle_Text");
+
+            if (text.gameObject.activeInHierarchy)
+            {
+                AccessibilityMgr.Output(this, GameStrings.Get(text.Text));
+            }
+
+			var accessibleRewards = new List<AccessibleRewardItemDataModel>();
+
+			foreach (var item in m_rewardListDataModel.Items)
+            {
+				accessibleRewards.Add(new AccessibleRewardItemDataModel(this, item, false));
+            }
+
+			m_accessibleRewards = new AccessibleListOfItems<AccessibleRewardItemDataModel>(this, accessibleRewards);
+
+			ChooseHeroSkin();
+        }
+
+        private void ChooseHeroSkin()
+        {
+            AccessibilityMgr.ShowUI(this);
+
+			m_accessibleRewards.StartReading();
+
+			m_curState = State.CHOOSING_SKIN;
+        }
+
+        public void HandleAccessibleInput()
+        {
+			if (m_curState == State.LOADING)
+            {
+				return;
+            }
+
+			if (m_curState == State.CHOOSING_SKIN)
+            {
+                if (m_accessibleRewards?.HandleAccessibleInput() ?? false)
+                {
+                    var itemBeingReadIndex = m_accessibleRewards.GetItemBeingReadIndex();
+
+                    TurnPageIfNeeded(itemBeingReadIndex);
+                }
+                else if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    ChooseReward(m_accessibleRewards.GetItemBeingReadIndex());
+                }
+            }
+			else if (m_curState == State.CONFIRMING)
+            {
+				if (AccessibleKey.CONFIRM.IsPressed())
+                {
+                    ClickClaimButton();
+                }
+				else if (AccessibleKey.BACK.IsPressed())
+                {
+					m_curState = State.CHOOSING_SKIN;
+					m_accessibleRewards.StartReading();
+                }
+            }
+        }
+
+        private void ChooseReward(int rewardIndex)
+        {
+			var rewardLayout = AccessibleUnityUtils.GetChildObject(gameObject, "Root/PageContainer/RewardLayout/");
+
+			if (rewardLayout == null)
+            {
+				return;
+            }
+
+			var rewardElements = new List<PegUIElement>();
+			foreach (var child in AccessibleUnityUtils.GetChildren(rewardLayout))
+            {
+				rewardElements.Add(AccessibleWidgetUtils.GetPegUIElement(child, "RewardTrackSkinChoiceItem/Root/Clickables/RegularHover_Clickable"));
+            }
+
+			var rewardInPageIndex = rewardIndex % m_numberOfItemsPerPage;
+			AccessibleWidgetUtils.ClickButton(rewardElements[rewardInPageIndex]);
+
+			m_curState = State.CONFIRMING;
+			AccessibilityMgr.Output(this, GetAccessibleHelp());
+        }
+
+        private void ClickClaimButton()
+        {
+			var bottomContent = AccessibleUnityUtils.GetChildObject(gameObject, "Root/BottomContent");
+
+			if (bottomContent != null)
+            {
+				var button = bottomContent.GetComponentInChildren<PegUIElement>();
+
+				AccessibleWidgetUtils.ClickButton(button);
+            }
+        }
+
+        private void TurnPageIfNeeded(int curItemIndex)
+        {
+			var pageIndex = Mathf.CeilToInt(curItemIndex / m_numberOfItemsPerPage);
+            var page = Mathf.Clamp(pageIndex + 1, 1, m_pageInfo.TotalPages);
+            SetPageData(page);
+        }
+
+        public string GetAccessibleHelp()
+        {
+			if (m_curState == State.CHOOSING_SKIN)
+            {
+                return m_accessibleRewards?.GetHelp(false);
+            }
+			else if (m_curState == State.CONFIRMING)
+            {
+				return LocalizedText.GLOBAL_PRESS_ENTER_TO_CONFIRM_OR_BACKSPACE_TO_CANCEL;
+            }
+
+			return "";
+        }
+
+        #endregion
+    }
 }
diff --git a/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs b/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
index a76fbd3..02eb7f2 100644
--- a/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/RewardTrackFactory.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Text;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusUtil;
diff --git a/Assembly-CSharp/Hearthstone/Progression/RewardTrackManager.cs b/Assembly-CSharp/Hearthstone/Progression/RewardTrackManager.cs
index 4772228..fe700dd 100644
--- a/Assembly-CSharp/Hearthstone/Progression/RewardTrackManager.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/RewardTrackManager.cs
@@ -333,7 +333,7 @@ namespace Hearthstone.Progression
 
 		public void OnSeasonRollDuringClientSession(RewardTrackDataModel rewardTrackDataModel, bool shouldActivate)
 		{
-			m_trackSeasonRollChecker.Stop();
+				m_trackSeasonRollChecker.Stop();
 			if (!shouldActivate)
 			{
 				rewardTrackDataModel.Expired = true;
@@ -341,7 +341,7 @@ namespace Hearthstone.Progression
 		}
 
 		public bool SetActiveEventRewardTrack(int rewardTrackId)
-		{
+			{
 			if (!Network.IsLoggedIn())
 			{
 				return false;
@@ -434,7 +434,7 @@ namespace Hearthstone.Progression
 			ScheduleCheckForSeasonRoll();
 		}
 
-		private RewardTrack GetCurrentRewardTrack(PlayerRewardTrackStateUpdate playerRewardTrackStateUpdate)
+		internal RewardTrack GetCurrentRewardTrack(PlayerRewardTrackStateUpdate playerRewardTrackStateUpdate)
 		{
 			if (playerRewardTrackStateUpdate == null)
 			{
@@ -660,18 +660,18 @@ namespace Hearthstone.Progression
 				}
 			}
 			else if (!m_isApprenticeComplete && flag)
-			{
-				m_isApprenticeComplete = true;
-				m_justCompletedApprentice = true;
-				Box box = Box.Get();
+				{
+					m_isApprenticeComplete = true;
+					m_justCompletedApprentice = true;
+					Box box = Box.Get();
 				if (!RankMgr.Get().DidSkipApprenticeThisSession && box != null)
 				{
 					box.GetRailroadManager().ToggleBoxTutorials(setEnabled: false);
 					box.GetRailroadManager().UpdateRailroadingOnBox();
 					box.UpdateUI();
 				}
-				BnetBar.Get()?.RefreshCurrency();
-				AchievementManager.Get().UnpauseToastNotifications();
+					BnetBar.Get()?.RefreshCurrency();
+					AchievementManager.Get().UnpauseToastNotifications();
 				GameSaveDataManager.Get().OnGameSaveDataUpdate -= OnGameSaveDataUpdate;
 			}
 		}
diff --git a/Assembly-CSharp/Hearthstone/Progression/TavernGuideTabDisplay.cs b/Assembly-CSharp/Hearthstone/Progression/TavernGuideTabDisplay.cs
index fcd8d9c..3aa01ae 100644
--- a/Assembly-CSharp/Hearthstone/Progression/TavernGuideTabDisplay.cs
+++ b/Assembly-CSharp/Hearthstone/Progression/TavernGuideTabDisplay.cs
@@ -4,11 +4,13 @@ using System.Linq;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System.Text;
 
 namespace Hearthstone.Progression
 {
 	[RequireComponent(typeof(WidgetTemplate))]
-	public class TavernGuideTabDisplay : MonoBehaviour
+	public class TavernGuideTabDisplay : MonoBehaviour, AccessibleUI
 	{
 		private enum PagePriority
 		{
@@ -51,6 +53,11 @@ namespace Hearthstone.Progression
 			TavernGuideManager.Get().OnInnerQuestStatusChanged += UpdateTavernGuideInnerQuest;
 		}
 
+		private void OnDestroy()
+		{
+			AccessibilityMgr.HideUI(this);
+		}
+
 		private void UpdateTavernGuide()
 		{
 			if (!(m_widget == null))
@@ -106,7 +113,7 @@ namespace Hearthstone.Progression
 			{
 			case "CODE_CATEGORY_PRESSED":
 				if (m_widget.GetDataModel<EventDataModel>().Payload is double num)
-				{
+			{
 					int num2 = Mathf.Clamp((int)num, 0, m_tavernGuideDatamodel.TavernGuideQuestSetCategories.Count - 1);
 					if ((double)num2 != num)
 					{
@@ -193,7 +200,8 @@ namespace Hearthstone.Progression
 			PagePriority pagePriority = PagePriority.DEFAULT;
 			foreach (KeyValuePair<int, Tuple<int, PagePriority>> item3 in m_categoryPagePriority)
 			{
-				item3.Deconstruct(out var key, out var value);
+				var key = item3.Key;
+				var value = item3.Value;
 				int num3 = key;
 				Tuple<int, PagePriority> tuple = value;
 				int item = tuple.Item1;
@@ -320,5 +328,179 @@ namespace Hearthstone.Progression
 				GoToNextQuestSet();
 			}
 		}
+
+		#region Accessibility
+		private enum State
+		{
+			INTRO,
+			BROWSING_CATEGORIES,
+			BROWSING_QUEST_SETS,
+			BROWSING_QUESTS
+		}
+
+		private State m_curState;
+		private AccessibleMenu m_categoryMenu;
+		private AccessibleMenu m_questSetMenu;
+		private AccessibleListOfItems<AccessibleTavernGuideQuest> m_quests;
+
+		internal void ReadTavernGuide()
+		{
+			AccessibilityMgr.ShowUI(this);
+			if (TavernGuideManager.Get().CanShowAllQuestSets())
+			{
+				ReadCategories();
+			}
+			else if (RewardTrackManager.Get().GetApprenticeTrackLevel() == 1)
+			{
+				ReadIntro();
+			}
+			else
+			{
+				AccessibilityUtils.LogFatalError("Tavern guide has reached an invalid state!");
+				AccessibilityMgr.HideUI(this);
+			}
+		}
+
+		private void ReadCategories()
+		{
+			m_categoryMenu = new AccessibleMenu(this, "", OnBackFromCategories);
+			for (int i = 0; i < m_tavernGuideDatamodel.TavernGuideQuestSetCategories.Count; i++)
+			{
+				var idx = i;
+				m_categoryMenu.AddOption(m_tavernGuideDatamodel.TavernGuideQuestSetCategories[idx].Title, () => ReadCategory(idx));
+			}
+			m_curState = State.BROWSING_CATEGORIES;
+			m_categoryMenu.StartReading();
+		}
+
+		private void OnBackFromCategories()
+		{
+			AccessibilityMgr.HideUI(this);
+			AccessibleJournal.Get().ReadJournal();
+		}
+
+		private void ReadCategory(int idx)
+		{
+			m_tavernGuideDatamodel.SelectedCategoryIndex = idx;
+			m_tavernGuideDatamodel.IsOpening = false;
+			var category = m_tavernGuideDatamodel.TavernGuideQuestSetCategories[idx];
+			m_questSetMenu = new AccessibleMenu(this, "", ReadCategories);
+			for (int i = 0; i < category.TavernGuideQuestSets.Count; i++)
+			{
+				if (idx == 0 && i == 0)
+				{
+					continue;
+				}
+				var idx2 = i;
+				var questSet = category.TavernGuideQuestSets[idx2];
+				m_questSetMenu.AddOption(() => GetQuestSetTitle(questSet), () => ReadQuestSet(idx2));
+			}
+			m_curState = State.BROWSING_QUEST_SETS;
+			m_questSetMenu.StartReading();
+		}
+
+		private string GetQuestSetTitle(TavernGuideQuestSetDataModel questSet)
+		{
+			var sb = new StringBuilder();
+			if (CanClaimQuestSetReward(questSet))
+			{
+				sb.Append(LocalizationUtils.Get(LocalizationKey.TAVERN_GUIDE_CLAIM_REWARD) + " ");
+			}
+			sb.Append(LocalizationUtils.Format(LocalizationKey.TAVERN_GUIDE_QUEST_SET_LABEL, questSet.Title, questSet.Description));
+			return sb.ToString();
+		}
+
+		private void ReadQuestSet(int idx)
+        {
+            m_tavernGuideDatamodel.SelectedQuestSetIndex = idx;
+            m_tavernGuideDatamodel.IsOpening = false;
+            var questSet = GetCurrentQuestSet();
+            if (CanClaimQuestSetReward(questSet))
+            {
+                ClaimQuestSetReward(questSet.CompletionAchievement.ID);
+                return;
+            }
+            var accessibleQuests = questSet.Quests.Select((q) => new AccessibleTavernGuideQuest(this, q)).ToList();
+            m_quests = new AccessibleListOfItems<AccessibleTavernGuideQuest>(this, accessibleQuests);
+            m_curState = State.BROWSING_QUESTS;
+            m_quests.StartReading();
+        }
+
+        private static bool CanClaimQuestSetReward(TavernGuideQuestSetDataModel questSet)
+        {
+            return questSet.CompletionAchievement != null && questSet.CompletionAchievement.Status == AchievementManager.AchievementStatus.COMPLETED;
+        }
+
+        internal static void ClaimQuestSetReward(int achievementId)
+	{
+		if (achievementId != 0)
+		{
+			AchievementManager.Get().ClaimAchievementReward(achievementId);
+		}
+	}
+
+	internal static void ExecuteDeeplink(TavernGuideQuestDataModel tavernGuideQuestDataModel)
+	{
+		string deepLink = tavernGuideQuestDataModel.Quest.DeepLink;
+		if (!string.IsNullOrEmpty(deepLink))
+		{
+			DeepLinkManager.ExecuteDeepLink(deepLink.Substring("hearthstone://".Length).Split('/').ToList()
+				.ToArray(), DeepLinkManager.DeepLinkSource.TAVERN_GUIDE, tavernGuideQuestDataModel.ID);
+		}
+	}
+
+	private void ReadIntro()
+	{
+		AccessibilityMgr.Output(this, GameStrings.Get("GLUE_PROGRESSION_APPRENTICE_TUTORIALS_INNKEEEPER_LEARN_ROPES"));
+		AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_START, AccessibleKey.CONFIRM));
+		m_curState = State.INTRO;
+	}
+
+
+		public void HandleAccessibleInput()
+		{
+			switch (m_curState)
+			{
+				case State.BROWSING_CATEGORIES:
+				m_categoryMenu?.HandleAccessibleInput();
+				break;
+				case State.BROWSING_QUEST_SETS:
+				m_questSetMenu?.HandleAccessibleInput();
+				break;
+				case State.BROWSING_QUESTS:
+				if (AccessibleKey.BACK.IsPressed())
+				{
+					ReadCategory(m_tavernGuideDatamodel.SelectedCategoryIndex);
+				}
+				else
+				{
+					m_quests?.HandleAccessibleInput();
+				}
+				break;
+				case State.INTRO:
+				if (AccessibleKey.CONFIRM.IsPressed())
+				{
+					var introQuest = m_tavernGuideDatamodel.TavernGuideQuestSetCategories[0].TavernGuideQuestSets[0].Quests[0];
+					ExecuteDeeplink(introQuest);
+				}
+				break;
+			}
+		}
+
+		public string GetAccessibleHelp()
+		{
+			switch (m_curState)
+			{
+				case State.BROWSING_QUEST_SETS:
+				case State.BROWSING_CATEGORIES:
+					return m_categoryMenu?.GetHelp();
+					case State.BROWSING_QUESTS:
+					return m_quests?.GetHelp(true);
+					case State.INTRO:
+					return LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_START, AccessibleKey.CONFIRM);
+			}
+			return "";
+		}
 	}
+	#endregion
 }
diff --git a/Assembly-CSharp/Hearthstone/Store/ProductDataService.cs b/Assembly-CSharp/Hearthstone/Store/ProductDataService.cs
index 137efc7..4ceccff 100644
--- a/Assembly-CSharp/Hearthstone/Store/ProductDataService.cs
+++ b/Assembly-CSharp/Hearthstone/Store/ProductDataService.cs
@@ -740,7 +740,7 @@ namespace Hearthstone.Store
 			{
 				hashSet.Add(item);
 			}
-			string val = string.Join(':', hashSet);
+			string val = string.Join("\"", hashSet);
 			Options.Get().SetString(Option.LATEST_DISPLAYED_SHOP_PRODUCT_LIST, val);
 			UpdateTabNotificationStates();
 		}
diff --git a/Assembly-CSharp/Hearthstone/Store/ProductInfo.cs b/Assembly-CSharp/Hearthstone/Store/ProductInfo.cs
index d38dbf5..9c71ff1 100644
--- a/Assembly-CSharp/Hearthstone/Store/ProductInfo.cs
+++ b/Assembly-CSharp/Hearthstone/Store/ProductInfo.cs
@@ -17,9 +17,6 @@ namespace Hearthstone.Store
 
 		public const int NO_PRODUCT_DATA_REQUIREMENT = 0;
 
-		[CompilerGenerated]
-		private DateTime? <StartTime>k__BackingField;
-
 		private RealPriceInfo? m_realMoneyPrice;
 
 		private IDictionary<CurrencyType, PriceInfo> m_vcPrices = new Dictionary<CurrencyType, PriceInfo>();
@@ -32,14 +29,7 @@ namespace Hearthstone.Store
 
 		public string Title { get; private set; }
 
-		private DateTime? StartTime
-		{
-			[CompilerGenerated]
-			set
-			{
-				<StartTime>k__BackingField = value;
-			}
-		}
+		private DateTime? StartTime {get; set;}
 
 		public DateTime? EndTime { get; private set; }
 
@@ -121,36 +111,36 @@ namespace Hearthstone.Store
 		{
 			if (!(bundle == null))
 			{
-				m_needsSetBundle = false;
-				Items = bundle.Items;
-				if (bundle.DisplayName != null && string.IsNullOrEmpty(Title))
-				{
-					Title = bundle.DisplayName.GetString();
-				}
-				if (bundle.DisplayDescription != null && string.IsNullOrEmpty(Description))
-				{
-					Description = bundle.DisplayDescription.GetString();
-				}
-				if (bundle.PMTProductID.HasValue)
-				{
-					Id = ProductId.CreateFrom(bundle.PMTProductID.Value);
-				}
-				else
-				{
-					Id = ProductId.InvalidProduct;
-				}
-				ProductEvent = bundle.ProductEvent;
-				VisibleOnSalePeriodOnly = bundle.VisibleOnSalePeriodOnly;
-				SaleIds = bundle.SaleIds;
-				IsPrePurchase = bundle.IsPrePurchase;
-				Attributes = bundle.Attributes;
-				UpdatePrices(bundle);
-				if ((!bundle.Cost.HasValue || bundle.Cost.Value.CurrentCost == 0L) && !HasNonGoldPrice() && m_vcPrices.Count > 0)
-				{
-					m_needsSetProduct = false;
-				}
-				DisableRealMoneyShopFlags = bundle.DisableRealMoneyShopFlags;
+			m_needsSetBundle = false;
+			Items = bundle.Items;
+			if (bundle.DisplayName != null && string.IsNullOrEmpty(Title))
+			{
+				Title = bundle.DisplayName.GetString();
+			}
+			if (bundle.DisplayDescription != null && string.IsNullOrEmpty(Description))
+			{
+				Description = bundle.DisplayDescription.GetString();
+			}
+			if (bundle.PMTProductID.HasValue)
+			{
+				Id = ProductId.CreateFrom(bundle.PMTProductID.Value);
 			}
+			else
+			{
+				Id = ProductId.InvalidProduct;
+			}
+			ProductEvent = bundle.ProductEvent;
+			VisibleOnSalePeriodOnly = bundle.VisibleOnSalePeriodOnly;
+			SaleIds = bundle.SaleIds;
+			IsPrePurchase = bundle.IsPrePurchase;
+			Attributes = bundle.Attributes;
+			UpdatePrices(bundle);
+			if ((!bundle.Cost.HasValue || bundle.Cost.Value.CurrentCost == 0L) && !HasNonGoldPrice() && m_vcPrices.Count > 0)
+			{
+				m_needsSetProduct = false;
+			}
+			DisableRealMoneyShopFlags = bundle.DisableRealMoneyShopFlags;
+		}
 		}
 
 		public bool TryGetBundlePrice(CurrencyType currencyType, out double value)
@@ -517,8 +507,8 @@ namespace Hearthstone.Store
 				}
 				else
 				{
-					product.externalPlatformSetting.prices.TryGetRealMoneyPrice(out price);
-				}
+				product.externalPlatformSetting.prices.TryGetRealMoneyPrice(out price);
+			}
 			}
 			if (product.prices != null)
 			{
@@ -528,8 +518,8 @@ namespace Hearthstone.Store
 				}
 				else
 				{
-					product.prices.TryGetRealMoneyPrice(out price2);
-				}
+				product.prices.TryGetRealMoneyPrice(out price2);
+			}
 			}
 			if (price2 != null)
 			{
@@ -546,14 +536,14 @@ namespace Hearthstone.Store
 					m_realMoneyPrice = new RealPriceInfo
 					{
 						CurrentPrice = new RealPriceInfo.Price
-						{
-							RealPrice = result,
-							DisplayPrice = text
+					{
+						RealPrice = result,
+						DisplayPrice = text
 						},
 						OriginalPrice = new RealPriceInfo.Price
-						{
-							RealPrice = result2,
-							DisplayPrice = displayPrice
+					{
+						RealPrice = result2,
+						DisplayPrice = displayPrice
 						},
 						CurrencyCode = currencyCode
 					};
@@ -563,14 +553,14 @@ namespace Hearthstone.Store
 					m_realMoneyPrice = new RealPriceInfo
 					{
 						CurrentPrice = new RealPriceInfo.Price
-						{
-							RealPrice = 0.0,
-							DisplayPrice = (price?.localizedCurrentPrice ?? price2.localizedCurrentPrice)
+					{
+						RealPrice = 0.0,
+						DisplayPrice = (price?.localizedCurrentPrice ?? price2.localizedCurrentPrice)
 						},
 						OriginalPrice = new RealPriceInfo.Price
-						{
-							RealPrice = 0.0,
-							DisplayPrice = (price?.localizedOriginalPrice ?? price2.localizedOriginalPrice)
+					{
+						RealPrice = 0.0,
+						DisplayPrice = (price?.localizedOriginalPrice ?? price2.localizedOriginalPrice)
 						},
 						CurrencyCode = (price?.currencyCode ?? price2.currencyCode)
 					};
@@ -588,14 +578,14 @@ namespace Hearthstone.Store
 					m_vcPrices[CurrencyType.GOLD] = new PriceInfo
 					{
 						CurrentPrice = new PriceInfo.Price
-						{
-							RealPrice = result3,
-							DisplayPrice = result3.ToString()
+					{
+						RealPrice = result3,
+						DisplayPrice = result3.ToString()
 						},
 						OriginalPrice = new PriceInfo.Price
-						{
-							RealPrice = result4,
-							DisplayPrice = result4.ToString()
+					{
+						RealPrice = result4,
+						DisplayPrice = result4.ToString()
 						}
 					};
 				}
@@ -622,14 +612,14 @@ namespace Hearthstone.Store
 				m_vcPrices[currencyTypeFromCode] = new PriceInfo
 				{
 					CurrentPrice = new PriceInfo.Price
-					{
-						RealPrice = result5,
-						DisplayPrice = result5.ToString()
+				{
+					RealPrice = result5,
+					DisplayPrice = result5.ToString()
 					},
 					OriginalPrice = new PriceInfo.Price
-					{
-						RealPrice = result6,
-						DisplayPrice = result6.ToString()
+				{
+					RealPrice = result6,
+					DisplayPrice = result6.ToString()
 					}
 				};
 			}
@@ -650,14 +640,14 @@ namespace Hearthstone.Store
 				m_vcPrices[CurrencyType.GOLD] = new PriceInfo
 				{
 					CurrentPrice = new PriceInfo.Price
-					{
-						RealPrice = bundle.GtappGoldCost.Value.CurrentCost,
-						DisplayPrice = bundle.GtappGoldCost.Value.CurrentCost.ToString()
+				{
+					RealPrice = bundle.GtappGoldCost.Value.CurrentCost,
+					DisplayPrice = bundle.GtappGoldCost.Value.CurrentCost.ToString()
 					},
 					OriginalPrice = new PriceInfo.Price
-					{
-						RealPrice = bundle.GtappGoldCost.Value.OriginalCost,
-						DisplayPrice = bundle.GtappGoldCost.Value.OriginalCost.ToString()
+				{
+					RealPrice = bundle.GtappGoldCost.Value.OriginalCost,
+					DisplayPrice = bundle.GtappGoldCost.Value.OriginalCost.ToString()
 					}
 				};
 			}
@@ -669,14 +659,14 @@ namespace Hearthstone.Store
 					m_vcPrices[currencyTypeFromCode] = new PriceInfo
 					{
 						CurrentPrice = new PriceInfo.Price
-						{
-							RealPrice = bundle.VirtualCurrencyCost.Value.CurrentCost,
-							DisplayPrice = bundle.VirtualCurrencyCost.Value.CurrentCost.ToString()
+					{
+						RealPrice = bundle.VirtualCurrencyCost.Value.CurrentCost,
+						DisplayPrice = bundle.VirtualCurrencyCost.Value.CurrentCost.ToString()
 						},
 						OriginalPrice = new PriceInfo.Price
-						{
-							RealPrice = bundle.VirtualCurrencyCost.Value.OriginalCost,
-							DisplayPrice = bundle.VirtualCurrencyCost.Value.OriginalCost.ToString()
+					{
+						RealPrice = bundle.VirtualCurrencyCost.Value.OriginalCost,
+						DisplayPrice = bundle.VirtualCurrencyCost.Value.OriginalCost.ToString()
 						}
 					};
 				}
diff --git a/Assembly-CSharp/Hearthstone/Streaming/GameDownloadManager.cs b/Assembly-CSharp/Hearthstone/Streaming/GameDownloadManager.cs
index 2fb7ba1..f9e6e34 100644
--- a/Assembly-CSharp/Hearthstone/Streaming/GameDownloadManager.cs
+++ b/Assembly-CSharp/Hearthstone/Streaming/GameDownloadManager.cs
@@ -401,7 +401,7 @@ namespace Hearthstone.Streaming
 					}
 					else
 					{
-						m_cachedReadyToPlay = IsCompletedInitialBaseDownload() && !UserAttentionManager.IsBlockedBy(UserAttentionBlocker.INITIAL_DOWNLOAD);
+						m_cachedReadyToPlay = IsCompletedInitialBaseDownload() && !UserAttentionManager.IsBlockedBy(false, UserAttentionBlocker.INITIAL_DOWNLOAD);
 					}
 					m_refreshedTime = GetRealtimeSinceStartup();
 				}
@@ -685,7 +685,7 @@ namespace Hearthstone.Streaming
 				{
 					break;
 				}
-				UserAttentionManager.StopBlocking(UserAttentionBlocker.INITIAL_DOWNLOAD);
+				UserAttentionManager.StopBlocking(false, UserAttentionBlocker.INITIAL_DOWNLOAD);
 				if (m_requestedInitialAssets)
 				{
 					HandleInitialDownloadComplete();
@@ -728,7 +728,7 @@ namespace Hearthstone.Streaming
 				{
 					break;
 				}
-				UserAttentionManager.StopBlocking(UserAttentionBlocker.INITIAL_DOWNLOAD);
+				UserAttentionManager.StopBlocking(false, UserAttentionBlocker.INITIAL_DOWNLOAD);
 				SceneMgr sceneManager = GetSceneManager();
 				if (!m_bRegisterSceneLoadCallback && sceneManager != null)
 				{
@@ -762,7 +762,8 @@ namespace Hearthstone.Streaming
 				}
 				return false;
 			}
-			}
+
+				}
 			return false;
 		}
 
@@ -795,11 +796,11 @@ namespace Hearthstone.Streaming
 		{
 			Log.Downloader.PrintInfo("Initial Download Finished!");
 			m_assetDownloader.DoPostTasksAfterDownload();
-			if (!ReportInitialDataDownloadFinished)
-			{
+				if (!ReportInitialDataDownloadFinished)
+				{
 				m_assetDownloader.SendDownloadFinishedTelemetryMessage(DownloadType.INITIAL_DOWNLOAD, IsInLocaleChange);
-				ReportInitialDataDownloadFinished = true;
-			}
+					ReportInitialDataDownloadFinished = true;
+				}
 		}
 
 		private void StartModuleDownload()
@@ -831,7 +832,7 @@ namespace Hearthstone.Streaming
 			int indexToRemove = Array.IndexOf(RequestedModulesForToast, DownloadTags.GetTagString(moduleTag));
 			if (indexToRemove != -1)
 			{
-				SocialToastMgr.Get()?.AddToast(UserAttentionBlocker.NONE, GameStrings.Format("GLUE_GAME_MODE_MODULE_DOWNLOADED", DownloadUtils.GetGameModeName(moduleTag)));
+			SocialToastMgr.Get()?.AddToast(UserAttentionBlocker.NONE, GameStrings.Format("GLUE_GAME_MODE_MODULE_DOWNLOADED", DownloadUtils.GetGameModeName(moduleTag)));
 				RequestedModulesForToast = RequestedModulesForToast.Where((string source, int index) => index != indexToRemove).ToArray();
 			}
 			m_assetDownloader.SendDownloadFinishedTelemetryMessage(DownloadType.MODULE_DOWNLOAD, IsInLocaleChange, moduleTag);
@@ -844,35 +845,35 @@ namespace Hearthstone.Streaming
 			{
 				return;
 			}
-			LastInprogressTag = GetNextTag(DownloadTags.Quality.Initial);
-			if (!Vars.Key("Mobile.StopDownloadAfter").HasValue)
-			{
-				MaximumQualityTag = DownloadTags.GetLastEnum<DownloadTags.Quality>();
-			}
-			else
-			{
-				string str = Vars.Key("Mobile.StopDownloadAfter").GetStr(string.Empty);
-				DownloadTags.Quality qualityTag = DownloadTags.GetQualityTag(str);
-				if (qualityTag != 0)
+				LastInprogressTag = GetNextTag(DownloadTags.Quality.Initial);
+				if (!Vars.Key("Mobile.StopDownloadAfter").HasValue)
 				{
-					Log.Downloader.PrintInfo("Optional data will be stopped after downloading '{0}'", str);
-					MaximumQualityTag = qualityTag;
+					MaximumQualityTag = DownloadTags.GetLastEnum<DownloadTags.Quality>();
 				}
 				else
 				{
-					Log.Downloader.PrintError("Unknown quality tag name has been used from deeplink: {0}", str);
-					MaximumQualityTag = DownloadTags.GetLastEnum<DownloadTags.Quality>();
+					string str = Vars.Key("Mobile.StopDownloadAfter").GetStr(string.Empty);
+					DownloadTags.Quality qualityTag = DownloadTags.GetQualityTag(str);
+					if (qualityTag != 0)
+					{
+						Log.Downloader.PrintInfo("Optional data will be stopped after downloading '{0}'", str);
+						MaximumQualityTag = qualityTag;
+					}
+					else
+					{
+						Log.Downloader.PrintError("Unknown quality tag name has been used from deeplink: {0}", str);
+						MaximumQualityTag = DownloadTags.GetLastEnum<DownloadTags.Quality>();
+					}
 				}
-			}
 			List<string> list = InitialContentTags.ToList();
 			list.AddRange(RequestedModules);
 			StartContentDownload(list.ToArray());
 			ProcessPostDownloadStart();
-			m_requestedStreamingAssets = true;
-		}
+				m_requestedStreamingAssets = true;
+			}
 
 		private void ProcessPostDownloadStart()
-		{
+			{
 			MobileCallbackManager.SetUpdateCompleted(finished: false);
 			ShouldRunPostTask = true;
 		}
@@ -1126,9 +1127,9 @@ namespace Hearthstone.Streaming
 					if (PlatformSettings.IsEmulating)
 					{
 						return EditorAssetDownloader.Mode != EditorAssetDownloader.DownloadMode.None;
-					}
-					return false;
-				}
+			}
+			return false;
+		}
 				return PlatformSettings.IsMobileRuntimeOS;
 			}
 		}
@@ -1156,13 +1157,13 @@ namespace Hearthstone.Streaming
 			{
 				if (!flag || content == DownloadTags.Content.Bgs)
 				{
-					string tagString = DownloadTags.GetTagString(content);
-					if (!list.Contains(tagString))
-					{
-						DownloadModule(content);
-					}
+				string tagString = DownloadTags.GetTagString(content);
+				if (!list.Contains(tagString))
+				{
+					DownloadModule(content);
 				}
 			}
+			}
 			Log.Downloader.PrintDebug("Will auto download modules = " + string.Join(", ", RequestedModules.Select((string t) => t ?? "").ToArray()));
 		}
 
@@ -1218,7 +1219,7 @@ namespace Hearthstone.Streaming
 				if (m_currentDownloadType == DownloadType.OPTIONAL_DOWNLOAD)
 				{
 					StopOptionalDownloads();
-				}
+			}
 				StartUpdateProcess(localeChange: false, resetDownloadFinishReport: true);
 			}
 		}
@@ -1824,10 +1825,10 @@ namespace Hearthstone.Streaming
 			Log.Downloader.PrintDebug($"StartUpdateProcessForOptional :  m_currentDownloadType = {m_currentDownloadType} : ShouldDownloadOptional = {ShouldDownloadOptional} : ShouldNotDownloadOptionalData = {ShouldNotDownloadOptionalData} : PlayerPausedDownload = {PlayerPausedDownload}");
 			if (m_currentDownloadType != 0 && m_currentDownloadType != DownloadType.MODULE_DOWNLOAD && ShouldDownloadOptional && !PlayerPausedDownload)
 			{
-				MaximumQualityTag = DownloadTags.GetLastEnum<DownloadTags.Quality>();
+			MaximumQualityTag = DownloadTags.GetLastEnum<DownloadTags.Quality>();
 				StartOptionalDownload();
-				StartUpdateJobIfNotRunning();
-			}
+			StartUpdateJobIfNotRunning();
+		}
 		}
 
 		protected void SetPlayerPausedDownload()
diff --git a/Assembly-CSharp/Hearthstone/Timeline/TimelineEffectBehaviour.cs b/Assembly-CSharp/Hearthstone/Timeline/TimelineEffectBehaviour.cs
index f0eb980..3152384 100644
--- a/Assembly-CSharp/Hearthstone/Timeline/TimelineEffectBehaviour.cs
+++ b/Assembly-CSharp/Hearthstone/Timeline/TimelineEffectBehaviour.cs
@@ -12,14 +12,7 @@ namespace Hearthstone.Timeline
 
 		private PlayableDirector m_playableDirector;
 
-		public PlayableAsset PlayableAsset
-		{
-			[CompilerGenerated]
-			set
-			{
-				<PlayableAsset>k__BackingField = value;
-			}
-		}
+		public PlayableAsset PlayableAsset { get; set; }
 
 		protected T Helper { get; private set; }
 
diff --git a/Assembly-CSharp/Hearthstone/TrailMaker/TrailSplineInterpolator.cs b/Assembly-CSharp/Hearthstone/TrailMaker/TrailSplineInterpolator.cs
index c070437..f918d5c 100644
--- a/Assembly-CSharp/Hearthstone/TrailMaker/TrailSplineInterpolator.cs
+++ b/Assembly-CSharp/Hearthstone/TrailMaker/TrailSplineInterpolator.cs
@@ -107,7 +107,7 @@ namespace Hearthstone.TrailMaker
 				double num = xOrig[j + 1] - xOrig[j];
 				double num2 = (xInterp[i] - xOrig[j]) / num;
 				double num3 = (1.0 - num2) * yOrig[j] + num2 * yOrig[j + 1] + num2 * (1.0 - num2) * (doubleArray.a[j] * (1.0 - num2) + doubleArray.b[j] * num2);
-				if (!double.IsFinite(num3))
+				if (double.IsInfinity(num3))
 				{
 					num3 = 0.0;
 				}
diff --git a/Assembly-CSharp/Hearthstone/UI/Clickable.cs b/Assembly-CSharp/Hearthstone/UI/Clickable.cs
index eef5b46..29be0ed 100644
--- a/Assembly-CSharp/Hearthstone/UI/Clickable.cs
+++ b/Assembly-CSharp/Hearthstone/UI/Clickable.cs
@@ -580,5 +580,14 @@ namespace Hearthstone.UI
 		{
 			Hearthstone.UI.Logging.Log.Get().AddMessage(message, this, LogLevel.Info, type);
 		}
+
+        #region Accessibility
+
+        internal PegUIElement GetPegUIElement()
+        {
+			return m_pegUiElement;
+        }
+
+		#endregion
 	}
 }
diff --git a/Assembly-CSharp/Hearthstone/UI/Override.cs b/Assembly-CSharp/Hearthstone/UI/Override.cs
index 293f122..ebd74e8 100644
--- a/Assembly-CSharp/Hearthstone/UI/Override.cs
+++ b/Assembly-CSharp/Hearthstone/UI/Override.cs
@@ -107,7 +107,7 @@ namespace Hearthstone.UI
 			}
 			catch (Exception ex)
 			{
-				Debug.LogErrorFormat("Error when applying override '{0}' to '{1}': {2}", @object, m_valueString, ex);
+				UnityEngine.Debug.LogErrorFormat("Error when applying override '{0}' to '{1}': {2}", @object, m_valueString, ex);
 			}
 		}
 
@@ -131,7 +131,7 @@ namespace Hearthstone.UI
 			}
 			catch (Exception ex)
 			{
-				Debug.LogErrorFormat("Error when applying override '{0}' to '{1}': {2}", @object, value, ex);
+				UnityEngine.Debug.LogErrorFormat("Error when applying override '{0}' to '{1}': {2}", @object, value, ex);
 			}
 		}
 
@@ -262,16 +262,16 @@ namespace Hearthstone.UI
 				else if ((dynamicPropertyResolver = DynamicPropertyResolvers.TryGetResolver(targetInfo.Target)) != null)
 				{
 					if (implicitConversion && value is IConvertible convertible2)
-					{
-						foreach (DynamicPropertyInfo dynamicProperty in dynamicPropertyResolver.DynamicProperties)
 						{
-							if (dynamicProperty.Id == targetInfo.Path)
+							foreach (DynamicPropertyInfo dynamicProperty in dynamicPropertyResolver.DynamicProperties)
 							{
-								value = convertible2.ToType(dynamicProperty.Type, null);
-								break;
+								if (dynamicProperty.Id == targetInfo.Path)
+								{
+									value = convertible2.ToType(dynamicProperty.Type, null);
+									break;
+								}
 							}
 						}
-					}
 					if (dynamicPropertyResolver.SetDynamicPropertyValue(targetInfo.Path, value))
 					{
 						result = AsyncOperationResult.Success;
diff --git a/Assembly-CSharp/Hearthstone/UI/Spawnable.cs b/Assembly-CSharp/Hearthstone/UI/Spawnable.cs
index 27cc2cc..e1fc038 100644
--- a/Assembly-CSharp/Hearthstone/UI/Spawnable.cs
+++ b/Assembly-CSharp/Hearthstone/UI/Spawnable.cs
@@ -360,13 +360,13 @@ namespace Hearthstone.UI
 		{
 			if (m_sprite != null && m_renderer is SpriteRenderer spriteRenderer)
 			{
-				bool flag = spriteRenderer.size != Vector2.one;
-				Vector2 size = spriteRenderer.size;
+					bool flag = spriteRenderer.size != Vector2.one;
+					Vector2 size = spriteRenderer.size;
 				spriteRenderer.sprite = m_sprite;
-				if (flag)
-				{
-					spriteRenderer.size = size;
-				}
+					if (flag)
+					{
+						spriteRenderer.size = size;
+					}
 			}
 			m_renderer.SetMaterial(m_material);
 			m_renderer.enabled = true;
@@ -421,7 +421,7 @@ namespace Hearthstone.UI
 			{
 				m_isLoading = false;
 				m_readyState.SetAndDispatch();
-				Debug.LogErrorFormat("Failed to load texture icon for {0} in {1}!", base.name, base.Owner.name);
+				UnityEngine.Debug.LogErrorFormat("Failed to load texture icon for {0} in {1}!", base.name, base.Owner.name);
 				HandleTextureItemCleanUp();
 				HandleDoneChangingStates();
 			}
@@ -540,25 +540,25 @@ namespace Hearthstone.UI
 		}
 
 		private void HandleTextureLoaded(AssetReference assetRef, AssetHandle<Texture2D> assetHandle, object asyncOperationId)
-		{
-			if (assetHandle == null)
 			{
-				HandleAssetItemError(assetHandle);
+				if (assetHandle == null)
+				{
+					HandleAssetItemError(assetHandle);
 				return;
-			}
+				}
 			if (m_textureAsyncOperationId != (int)asyncOperationId)
-			{
-				AssetHandle.SafeDispose(ref assetHandle);
+				{
+					AssetHandle.SafeDispose(ref assetHandle);
 				return;
-			}
-			m_texture = assetHandle.Asset;
-			m_textureHandle = assetHandle;
-			if (m_material != null)
-			{
-				m_material.mainTexture = m_texture;
-				SetupRenderer();
-			}
-		}
+				}
+					m_texture = assetHandle.Asset;
+					m_textureHandle = assetHandle;
+					if (m_material != null)
+					{
+						m_material.mainTexture = m_texture;
+						SetupRenderer();
+					}
+				}
 
 		private void CreateSpriteItem(SpawnableLibrary.ItemData itemData)
 		{
@@ -579,8 +579,8 @@ namespace Hearthstone.UI
 			}
 			else
 			{
-				LoadAsset<Material>(m_spawnableLibrary.BaseMaterial, ++m_materialAsyncOperationId, HandleMaterialLoaded);
-			}
+			LoadAsset<Material>(m_spawnableLibrary.BaseMaterial, ++m_materialAsyncOperationId, HandleMaterialLoaded);
+		}
 		}
 
 		private void HandleSpriteLoaded(AssetReference assetRef, AssetHandle<Sprite> assetHandle, object asyncOperationId)
@@ -619,21 +619,21 @@ namespace Hearthstone.UI
 		}
 
 		private void HandleMaterialLoaded(AssetReference assetRef, AssetHandle<Material> assetHandle, object asyncOperationId)
-		{
-			if (assetHandle == null)
 			{
-				HandleAssetItemError(assetHandle);
+				if (assetHandle == null)
+				{
+					HandleAssetItemError(assetHandle);
 				return;
-			}
+				}
 			if (m_materialAsyncOperationId != (int)asyncOperationId)
-			{
-				AssetHandle.SafeDispose(ref assetHandle);
+				{
+					AssetHandle.SafeDispose(ref assetHandle);
 				return;
-			}
-			m_material = assetHandle.Asset;
-			m_materialHandle = assetHandle;
-			SetupRenderer();
-		}
+				}
+					m_material = assetHandle.Asset;
+					m_materialHandle = assetHandle;
+					SetupRenderer();
+				}
 
 		private void HandleMaterialLoadedForInstancing(AssetReference assetRef, AssetHandle<Material> assetHandle, object asyncOperationId)
 		{
@@ -694,13 +694,13 @@ namespace Hearthstone.UI
 				return gameObject;
 			}
 			managedSprite.UsesSpriteAtlas = true;
-			assetReference = AssetReference.CreateFromAssetString(spriteItemParameters.SpriteAtlasReference.AssetString);
-			if (assetReference == null)
-			{
+				assetReference = AssetReference.CreateFromAssetString(spriteItemParameters.SpriteAtlasReference.AssetString);
+				if (assetReference == null)
+				{
 				global::Log.UIFramework.PrintWarning("[Spawnable] Sprite {0} for renderer {1} (instance {2}) doesn't have a clear atlas associated with it. If there is an atlas for it, this could lead to missing assets in-game or the inability to track assets' lifetime!", itemData.Reference, base.name, base.gameObject.GetInstanceID());
 				managedSprite.UsesSpriteAtlas = false;
-			}
-			managedSprite.SpriteAtlas = assetReference;
+				}
+				managedSprite.SpriteAtlas = assetReference;
 			managedSprite.SpriteRenderer.color = spriteItemParameters.Color;
 			managedSprite.SpriteRenderer.flipX = spriteItemParameters.FlipX;
 			managedSprite.SpriteRenderer.flipY = spriteItemParameters.FlipY;
diff --git a/Assembly-CSharp/Hearthstone/UI/WidgetInstance.cs b/Assembly-CSharp/Hearthstone/UI/WidgetInstance.cs
index 334f983..8e7a1fb 100644
--- a/Assembly-CSharp/Hearthstone/UI/WidgetInstance.cs
+++ b/Assembly-CSharp/Hearthstone/UI/WidgetInstance.cs
@@ -35,7 +35,7 @@ namespace Hearthstone.UI
 		[HideInInspector]
 		private LoadingPolicy m_loadingPolicy;
 
-		private PrefabInstance m_prefabInstance;
+		internal PrefabInstance m_prefabInstance;
 
 		private bool m_startedInitialization;
 
@@ -43,7 +43,7 @@ namespace Hearthstone.UI
 
 		private List<Action> m_pendingPreInitializeActions;
 
-		private DataContext m_pendingDataContext = new DataContext();
+		public DataContext m_pendingDataContext = new DataContext();
 
 		private WidgetTemplate m_parentWidgetTemplate;
 
diff --git a/Assembly-CSharp/HearthstoneCheckout.cs b/Assembly-CSharp/HearthstoneCheckout.cs
index 0b641c9..03c5876 100644
--- a/Assembly-CSharp/HearthstoneCheckout.cs
+++ b/Assembly-CSharp/HearthstoneCheckout.cs
@@ -191,9 +191,6 @@ public class HearthstoneCheckout : blz_commerce_log_hook, ISceneEventObserver, I
 
 	internal bool m_isPendingBlocked;
 
-	[CompilerGenerated]
-	private bool <IsSystemEnabled>k__BackingField;
-
 	public bool ReceivedSdkProducts
 	{
 		get
@@ -227,14 +224,7 @@ public class HearthstoneCheckout : blz_commerce_log_hook, ISceneEventObserver, I
 		}
 	}
 
-	private bool IsSystemEnabled
-	{
-		[CompilerGenerated]
-		set
-		{
-			<IsSystemEnabled>k__BackingField = value;
-		}
-	}
+	private bool IsSystemEnabled {get; set;}
 
 	public bool HasProductCatalog
 	{
@@ -411,9 +401,9 @@ public class HearthstoneCheckout : blz_commerce_log_hook, ISceneEventObserver, I
 			hearthstoneApplication.WillReset += OnReset;
 		}
 		if (!(DeeplinkService.Get()?.RegisterDeeplinkHandler("blizzard", this) ?? false))
-		{
-			Log.Store.PrintError("Unable register with deeplink service");
-		}
+			{
+				Log.Store.PrintError("Unable register with deeplink service");
+			}
 		JobDefinition jobDefinition = new JobDefinition("HearthstoneCheckout.LoadCheckoutUI", Job_CreateCSDK(), JobFlags.StartImmediately);
 		Processor.QueueJob(jobDefinition);
 		Processor.QueueJob(new JobDefinition("HearthstoneCheckout.InitializeCheckoutClient", Job_InitializeCheckoutClient(), jobDefinition.CreateDependency(), new WaitForCheckoutConfiguration()));
@@ -424,13 +414,13 @@ public class HearthstoneCheckout : blz_commerce_log_hook, ISceneEventObserver, I
 		if (m_dependencies == null)
 		{
 			m_dependencies = new Type[4]
-			{
-				typeof(Network),
-				typeof(LoginManager),
-				typeof(IAssetLoader),
-				typeof(ILoginService)
-			};
-		}
+		{
+			typeof(Network),
+			typeof(LoginManager),
+			typeof(IAssetLoader),
+			typeof(ILoginService)
+		};
+	}
 		return m_dependencies;
 	}
 
@@ -972,7 +962,7 @@ public class HearthstoneCheckout : blz_commerce_log_hook, ISceneEventObserver, I
 		TransactionData transactionData = ((m_currentTransaction != null) ? m_currentTransaction : new TransactionData(ProductId.InvalidProduct, currencyCode, 1u, isVCPurchase: false));
 		if (!string.IsNullOrEmpty(transactionId))
 		{
-			transactionData.TransactionID = transactionId;
+		transactionData.TransactionID = transactionId;
 		}
 		transactionData.ErrorCodes = errorCode;
 		return transactionData;
@@ -1149,8 +1139,8 @@ public class HearthstoneCheckout : blz_commerce_log_hook, ISceneEventObserver, I
 		m_closeRequested = false;
 		m_currentTransaction = null;
 		m_TransactionState = State.Ready;
-		_shouldCallCSDKUpdate = true;
-	}
+			_shouldCallCSDKUpdate = true;
+		}
 
 	private void DestroyCheckoutUI()
 	{
diff --git a/Assembly-CSharp/HeroDbId.cs b/Assembly-CSharp/HeroDbId.cs
index 79c6983..1bb1e15 100644
--- a/Assembly-CSharp/HeroDbId.cs
+++ b/Assembly-CSharp/HeroDbId.cs
@@ -14,5 +14,6 @@ public enum HeroDbId
 	ALLERIA,
 	MEDIVH,
 	LIADRIN,
-	KHADGAR
+	KHADGAR,
+	EOE
 }
diff --git a/Assembly-CSharp/HeroPickerDisplay.cs b/Assembly-CSharp/HeroPickerDisplay.cs
index 7581fad..ff4a490 100644
--- a/Assembly-CSharp/HeroPickerDisplay.cs
+++ b/Assembly-CSharp/HeroPickerDisplay.cs
@@ -1,4 +1,5 @@
 using UnityEngine;
+using Accessibility;
 
 public class HeroPickerDisplay : MonoBehaviour
 {
diff --git a/Assembly-CSharp/HeroSkinInfoManager.cs b/Assembly-CSharp/HeroSkinInfoManager.cs
index 96905db..0df4c5c 100644
--- a/Assembly-CSharp/HeroSkinInfoManager.cs
+++ b/Assembly-CSharp/HeroSkinInfoManager.cs
@@ -1,9 +1,11 @@
 using Blizzard.T5.AssetManager;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
+using System;
 
 [CustomEditClass]
-public class HeroSkinInfoManager : BaseHeroSkinInfoManager
+public class HeroSkinInfoManager : BaseHeroSkinInfoManager, AccessibleUI
 {
 	private static HeroSkinInfoManager s_instance;
 
@@ -107,6 +109,10 @@ public class HeroSkinInfoManager : BaseHeroSkinInfoManager
 		{
 			CollectionManager.Get().UpdateFavoriteHero(@class, cardId, m_currentPremium, flag);
 		}
+		else
+		{
+			AccessibleCollectionManager.Get().WaitingForServerResponse();
+		}
 	}
 
 	protected override bool CanToggleFavorite()
@@ -136,4 +142,5 @@ public class HeroSkinInfoManager : BaseHeroSkinInfoManager
 			BnetBar.Get()?.RefreshCurrency();
 		}
 	}
+
 }
diff --git a/Assembly-CSharp/HeroXPBar.cs b/Assembly-CSharp/HeroXPBar.cs
index f2bdc55..143e9fa 100644
--- a/Assembly-CSharp/HeroXPBar.cs
+++ b/Assembly-CSharp/HeroXPBar.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using UnityEngine;
+using Accessibility;
 
 public class HeroXPBar : PegUIElement
 {
@@ -33,6 +34,12 @@ public class HeroXPBar : PegUIElement
 
 	private string m_rewardDesc;
 
+	#region Accessibility
+	private bool m_fromEndGameScreen;
+
+	private AccessibleComponent m_parent;
+	#endregion
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -40,12 +47,16 @@ public class HeroXPBar : PegUIElement
 		AddEventListener(UIEventType.ROLLOUT, OnProgressBarOut);
 	}
 
-	public void UpdateDisplay(NetCache.HeroLevel heroLevel, int totalLevel)
+	public void UpdateDisplay(AccessibleComponent parent, NetCache.HeroLevel heroLevel, int totalLevel, bool fromEndGameScreen) // fromEndGameScreen is used for A11y
 	{
+		m_fromEndGameScreen = fromEndGameScreen;
+		m_parent = parent;
+
 		if (heroLevel == null)
 		{
 			base.gameObject.SetActive(value: false);
-			return;
+            SignalEnterToContinue();
+            return;
 		}
 		m_heroLevel = heroLevel;
 		m_totalLevel = totalLevel;
@@ -68,6 +79,7 @@ public class HeroXPBar : PegUIElement
 			if (m_heroLevel.PrevLevel.IsMaxLevel())
 			{
 				SetBarValue(1f);
+				SignalEnterToContinue();
 				return;
 			}
 			SetBarValue((float)m_heroLevel.PrevLevel.XP / (float)m_heroLevel.PrevLevel.MaxXP);
@@ -79,12 +91,14 @@ public class HeroXPBar : PegUIElement
 			if (m_heroLevel.CurrentLevel.IsMaxLevel())
 			{
 				SetBarValue(1f);
-			}
-			else
+                SignalEnterToContinue();
+            }
+            else
 			{
 				SetBarValue((float)m_heroLevel.CurrentLevel.XP / (float)m_heroLevel.CurrentLevel.MaxXP);
-			}
-		}
+                SignalEnterToContinue();
+            }
+        }
 	}
 
 	public void AnimateBar(NetCache.HeroLevel.LevelInfo previousLevelInfo, NetCache.HeroLevel.LevelInfo currentLevelInfo)
@@ -106,9 +120,10 @@ public class HeroXPBar : PegUIElement
 			currVal2 = 1f;
 		}
 		m_progressBar.AnimateProgress(prevVal2, currVal2);
-	}
+        SignalEnterToContinue();
+    }
 
-	public void SetBarValue(float barValue)
+    public void SetBarValue(float barValue)
 	{
 		m_progressBar.SetProgressBar(barValue);
 	}
@@ -131,6 +146,8 @@ public class HeroXPBar : PegUIElement
 		{
 			m_levelUpCallback();
 		}
+		AccessibilityMgr.Output(m_parent, LocalizationUtils.Format(LocalizationKey.SCREEN_END_GAME_SCREEN_HERO_LEVEL_UP, currentLevelInfo.Level));
+		SignalEnterToContinue();
 	}
 
 	private IEnumerator DelayBarAnimation(NetCache.HeroLevel.LevelInfo prevInfo, NetCache.HeroLevel.LevelInfo currInfo)
@@ -162,4 +179,16 @@ public class HeroXPBar : PegUIElement
 	{
 		base.gameObject.GetComponent<TooltipZone>().HideTooltip();
 	}
+
+	#region Accessibility
+
+	private void SignalEnterToContinue()
+    {
+		if (m_fromEndGameScreen)
+        {
+            AccessibilityMgr.Output(m_parent, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+        }
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/Hero_06ah_EyeScalar.cs b/Assembly-CSharp/Hero_06ah_EyeScalar.cs
index 3a09dc0..2dda20b 100644
--- a/Assembly-CSharp/Hero_06ah_EyeScalar.cs
+++ b/Assembly-CSharp/Hero_06ah_EyeScalar.cs
@@ -95,8 +95,8 @@ public class Hero_06ah_EyeScalar : MonoBehaviour
 	{
 		if (m_heroEntity == null)
 		{
-			return false;
-		}
+		return false;
+	}
 		if (!m_heroEntity.IsFrozen() && !m_heroEntity.IsImmune() && !m_heroEntity.HasDivineShield() && !m_heroEntity.IsStealthed() && !m_heroEntity.IsEnraged() && m_heroEntity.CanBeTargetedBySpells() && m_heroEntity.CanBeTargetedByHeroPowers() && !m_heroEntity.HasTag(GAME_TAG.HEAVILY_ARMORED))
 		{
 			return m_heroEntity.HasTag(GAME_TAG.UNTOUCHABLE);
diff --git a/Assembly-CSharp/HistoryCard.cs b/Assembly-CSharp/HistoryCard.cs
index 45c78a0..1e430ff 100644
--- a/Assembly-CSharp/HistoryCard.cs
+++ b/Assembly-CSharp/HistoryCard.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using Blizzard.T5.MaterialService.Extensions;
@@ -96,7 +97,9 @@ public class HistoryCard : HistoryItem
 
 	private int m_displayTimeMS;
 
-	private HistoryInfoType m_historyInfoType;
+	internal HistoryInfoType m_historyInfoType;
+
+	internal PowerTaskList OriginTaskList { get; private set; }
 
 	public void LoadMainCardActor()
 	{
@@ -255,13 +258,13 @@ public class HistoryCard : HistoryItem
 		{
 			return;
 		}
-		LoadChildCardsFromInfos();
-		LoadOwnerFromInfo();
-		m_mousedOver = true;
-		SoundManager.Get().LoadAndPlay("history_event_mouseover.prefab:0bc4f1638257a264a9b02e811c0a61b5", m_tileActor.gameObject);
-		if (!m_mainCardActor)
-		{
-			LoadMainCardActor();
+			LoadChildCardsFromInfos();
+			LoadOwnerFromInfo();
+			m_mousedOver = true;
+			SoundManager.Get().LoadAndPlay("history_event_mouseover.prefab:0bc4f1638257a264a9b02e811c0a61b5", m_tileActor.gameObject);
+			if (!m_mainCardActor)
+			{
+				LoadMainCardActor();
 			if (m_mainCardActor != null)
 			{
 				LayerUtils.SetLayer(m_mainCardActor, GameLayer.Tooltip);
@@ -527,23 +530,23 @@ public class HistoryCard : HistoryItem
 			return null;
 		}
 		using DefLoader.DisposableCardDef disposableCardDef = duplicatedEntity.ShareDisposableCardDef();
-		if (disposableCardDef?.CardDef == null)
-		{
-			return null;
-		}
-		component.SetCardInfo(duplicatedEntity, disposableCardDef, info.GetSplatAmount(), info.HasDied(), info.m_isBurnedCard, info.m_isPoisonous, info.m_isCriticalHit);
-		component.transform.parent = base.transform;
-		component.LoadMainCardActor();
-		Actor componentInChildren = gameObject.GetComponentInChildren<Actor>();
-		if (componentInChildren == null)
-		{
-			return null;
+			if (disposableCardDef?.CardDef == null)
+			{
+				return null;
+			}
+			component.SetCardInfo(duplicatedEntity, disposableCardDef, info.GetSplatAmount(), info.HasDied(), info.m_isBurnedCard, info.m_isPoisonous, info.m_isCriticalHit);
+			component.transform.parent = base.transform;
+			component.LoadMainCardActor();
+			Actor componentInChildren = gameObject.GetComponentInChildren<Actor>();
+			if (componentInChildren == null)
+			{
+				return null;
+			}
+			componentInChildren.SetEntity(duplicatedEntity);
+			componentInChildren.SetCardDef(disposableCardDef);
+			componentInChildren.UpdateAllComponents();
+			return component;
 		}
-		componentInChildren.SetEntity(duplicatedEntity);
-		componentInChildren.SetCardDef(disposableCardDef);
-		componentInChildren.UpdateAllComponents();
-		return component;
-	}
 
 	private void ShowTile()
 	{
@@ -701,8 +704,10 @@ public class HistoryCard : HistoryItem
 		return -1.404475f + num2 * (float)num3;
 	}
 
-	public void LoadBigCard(HistoryBigCardInitInfo info)
+	public void LoadBigCard(PowerTaskList origin, HistoryBigCardInitInfo info)
 	{
+		OriginTaskList = origin;
+
 		m_entity = info.m_entity;
 		m_historyInfoType = info.m_historyInfoType;
 		m_portraitTexture = info.m_portraitTexture;
@@ -821,10 +826,11 @@ public class HistoryCard : HistoryItem
 			{
 				ShowDisplayedCreator();
 			}
-		}
-	}
+            AccessibleGameplay.Get().OnShowBigCard(this);
+        }
+    }
 
-	private void OnBigCardPathComplete()
+    private void OnBigCardPathComplete()
 	{
 		ShowDisplayedCreator();
 	}
diff --git a/Assembly-CSharp/HistoryInfoType.cs b/Assembly-CSharp/HistoryInfoType.cs
index 23926a8..8ba672c 100644
--- a/Assembly-CSharp/HistoryInfoType.cs
+++ b/Assembly-CSharp/HistoryInfoType.cs
@@ -7,5 +7,6 @@ public enum HistoryInfoType
 	TRIGGER,
 	WEAPON_BREAK,
 	FATIGUE,
-	BURNED_CARDS
+	BURNED_CARDS,
+	EOE
 }
diff --git a/Assembly-CSharp/HistoryManager.cs b/Assembly-CSharp/HistoryManager.cs
index 1bfb11f..61b0cbb 100644
--- a/Assembly-CSharp/HistoryManager.cs
+++ b/Assembly-CSharp/HistoryManager.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Blizzard.T5.Game.Spells;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class HistoryManager : CardTileListDisplay
 {
@@ -26,6 +27,14 @@ public class HistoryManager : CardTileListDisplay
 		public bool m_waitForSecretSpell;
 
 		public int m_displayTimeMS;
+
+		public PowerTaskList m_origin;
+
+		public BigCardEntry(PowerTaskList origin)
+        {
+			// Required to arbitrate TTS between big cards and power list parsing
+			m_origin = origin;
+        }
 	}
 
 	private enum BigCardTransformState
@@ -1296,7 +1305,7 @@ public class HistoryManager : CardTileListDisplay
 				};
 				tileLoadedCallbackData.m_childInfos.Add(historyInfo2);
 				AssetLoader.Get().InstantiatePrefab("HistoryCard.prefab:f8193c3e146b62342b8fb2c0494ec447", TileLoadedCallback, tileLoadedCallbackData, AssetLoadingOptions.IgnorePrefabPosition);
-			}
+		}
 		}
 	}
 
@@ -1489,9 +1498,9 @@ public class HistoryManager : CardTileListDisplay
 			historyTileInitInfo.m_portraitTexture = DeterminePortraitTextureForTiles(duplicatedEntity, historyTileInitInfo.m_cardDef.CardDef);
 			if (historyTileInitInfo.m_cardDef != null && historyTileInitInfo.m_cardDef.CardDef != null)
 			{
-				historyTileInitInfo.m_portraitGoldenMaterial = historyTileInitInfo.m_cardDef.CardDef.GetPremiumPortraitMaterial();
-				historyTileInitInfo.m_cardDef.CardDef.TryGetHistoryTileFullPortrait(duplicatedEntity.GetPremiumType(), out historyTileInitInfo.m_fullTileMaterial);
-				historyTileInitInfo.m_cardDef.CardDef.TryGetHistoryTileHalfPortrait(duplicatedEntity.GetPremiumType(), out historyTileInitInfo.m_halfTileMaterial);
+			historyTileInitInfo.m_portraitGoldenMaterial = historyTileInitInfo.m_cardDef.CardDef.GetPremiumPortraitMaterial();
+			historyTileInitInfo.m_cardDef.CardDef.TryGetHistoryTileFullPortrait(duplicatedEntity.GetPremiumType(), out historyTileInitInfo.m_fullTileMaterial);
+			historyTileInitInfo.m_cardDef.CardDef.TryGetHistoryTileHalfPortrait(duplicatedEntity.GetPremiumType(), out historyTileInitInfo.m_halfTileMaterial);
 			}
 			historyTileInitInfo.m_splatAmount = sourceInfo.GetSplatAmount();
 			historyTileInitInfo.m_dead = sourceInfo.HasDied();
@@ -1710,26 +1719,27 @@ public class HistoryManager : CardTileListDisplay
 		return m_pendingBigCardEntry.m_info.GetOriginalEntity();
 	}
 
-	public void CreateFastBigCardFromMetaData(Entity entity)
+	public void CreateFastBigCardFromMetaData(PowerTaskList origin, Entity entity)
 	{
 		int displayTimeMS = 1000;
-		CreatePlayedBigCard(entity, delegate
+		CreatePlayedBigCard(origin, entity, delegate
 		{
 		}, delegate
 		{
 		}, fromMetaData: true, countered: false, displayTimeMS);
 	}
 
-	public void CreatePlayedBigCard(Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool countered, int displayTimeMS)
+	public void CreatePlayedBigCard(PowerTaskList origin, Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool countered, int displayTimeMS)
 	{
-		if (!GameState.Get().GetGameEntity().ShouldShowBigCard())
-		{
-			finishedCallback();
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && !GameState.Get().GetGameEntity().ShouldShowBigCard())
+        {
+            // Some tutorials don't show big cards but we depend on it for accessibility atm
+            finishedCallback();
 			return;
-		}
+        }
 		m_showingBigCard = true;
 		StopCoroutine("WaitForCardLoadedAndCreateBigCard");
-		BigCardEntry bigCardEntry = new BigCardEntry();
+		BigCardEntry bigCardEntry = new BigCardEntry(origin);
 		bigCardEntry.m_info = new HistoryInfo();
 		bigCardEntry.m_info.SetOriginalEntity(entity);
 		if (entity.IsWeapon())
@@ -1748,16 +1758,17 @@ public class HistoryManager : CardTileListDisplay
 		StartCoroutine("WaitForCardLoadedAndCreateBigCard", bigCardEntry);
 	}
 
-	public void CreateTriggeredBigCard(Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool isSecret)
+	public void CreateTriggeredBigCard(PowerTaskList origin, Entity entity, BigCardStartedCallback startedCallback, BigCardFinishedCallback finishedCallback, bool fromMetaData, bool isSecret)
 	{
-		if (!GameState.Get().GetGameEntity().ShouldShowBigCard() || entity.IsBobQuest())
+		if ((!AccessibilityMgr.IsAccessibilityEnabled() && !GameState.Get().GetGameEntity().ShouldShowBigCard()) || entity.IsBobQuest())
 		{
+      // Some tutorials don't show big cards but we depend on it for accessibility atm
 			finishedCallback();
 			return;
-		}
+        }
 		m_showingBigCard = true;
 		StopCoroutine("WaitForCardLoadedAndCreateBigCard");
-		BigCardEntry bigCardEntry = new BigCardEntry();
+		BigCardEntry bigCardEntry = new BigCardEntry(origin);
 		bigCardEntry.m_info = new HistoryInfo();
 		bigCardEntry.m_info.SetOriginalEntity(entity);
 		bigCardEntry.m_info.m_infoType = HistoryInfoType.TRIGGER;
@@ -1906,7 +1917,7 @@ public class HistoryManager : CardTileListDisplay
 			historyBigCardInitInfo.m_postTransformedEntity = postTransformedEntity;
 			historyBigCardInitInfo.m_displayTimeMS = bigCardEntry.m_displayTimeMS;
 			HistoryCard component = go.GetComponent<HistoryCard>();
-			component.LoadBigCard(historyBigCardInitInfo);
+			component.LoadBigCard(bigCardEntry.m_origin, historyBigCardInitInfo);
 			if ((bool)m_currentBigCard)
 			{
 				InterruptCurrentBigCard();
@@ -1977,11 +1988,11 @@ public class HistoryManager : CardTileListDisplay
 				Card card = entity.GetCard();
 				if (!entity.IsTitan() || entity.IsControlledByFriendlySidePlayer())
 				{
-					ChoiceCardMgr.Get().ShowSubOptions(card);
-					StartCoroutine(FinishSpectatorSubOption(entity, histBlockStart.SubOption));
-				}
+				ChoiceCardMgr.Get().ShowSubOptions(card);
+				StartCoroutine(FinishSpectatorSubOption(entity, histBlockStart.SubOption));
 			}
 		}
+		}
 		if (!GameState.Get().GetBooleanGameOption(GameEntityOption.DISABLE_DELAY_BETWEEN_BIG_CARD_DISPLAY_AND_POWER_PROCESSING))
 		{
 			yield return new WaitForSeconds(1f);
@@ -2030,8 +2041,8 @@ public class HistoryManager : CardTileListDisplay
 			}
 			yield break;
 		}
-		InputManager.Get().HandleClickOnSubOption(subEntity, isSimulated: true);
-	}
+			InputManager.Get().HandleClickOnSubOption(subEntity, isSimulated: true);
+		}
 
 	private IEnumerator WaitThenDestroyBigCard()
 	{
diff --git a/Assembly-CSharp/HttpCheater.cs b/Assembly-CSharp/HttpCheater.cs
index 086e355..321d621 100644
--- a/Assembly-CSharp/HttpCheater.cs
+++ b/Assembly-CSharp/HttpCheater.cs
@@ -598,7 +598,7 @@ public class HttpCheater
 		if (!HearthstoneApplication.IsPublic())
 		{
 			UIStatus.Get().AddError(message);
-			Debug.LogError(message);
+			UnityEngine.Debug.LogError(message);
 		}
 	}
 }
diff --git a/Assembly-CSharp/Hub.cs b/Assembly-CSharp/Hub.cs
index 3d0cbac..6f27a6c 100644
--- a/Assembly-CSharp/Hub.cs
+++ b/Assembly-CSharp/Hub.cs
@@ -10,6 +10,7 @@ using Hearthstone.Store;
 using Hearthstone.Streaming;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class Hub : PegasusScene
 {
@@ -63,12 +64,16 @@ public class Hub : PegasusScene
 			if (SceneMgr.Get() != null && SceneMgr.Get().GetPrevMode() != SceneMgr.Mode.LOGIN)
 			{
 				box.PlayBoxMusic();
-			}
-			if (!Network.ShouldBeConnectedToAurora())
-			{
+		}
+		if (!Network.ShouldBeConnectedToAurora())
+		{
 				box.DisableAllButtons();
-			}
 		}
+		else
+		{
+			AccessibleHub.Get().OnHubOpened();
+		}
+	}
 		SceneMgr.Get()?.NotifySceneLoaded();
 	}
 
@@ -128,10 +133,10 @@ public class Hub : PegasusScene
 		}
 		if (!(this == null))
 		{
-			PreloadShopUI();
-			Log.Box.PrintInfo("Box transition finished and ready to play. Showing notifications.");
-			ShowHubStartNotifications();
-		}
+		PreloadShopUI();
+		Log.Box.PrintInfo("Box transition finished and ready to play. Showing notifications.");
+		ShowHubStartNotifications();
+	}
 	}
 
 	private void ShowHubStartNotificationsWhenReadyToPlay()
@@ -326,7 +331,7 @@ public class Hub : PegasusScene
 		MessageModal.ShopButtonPressed -= OnMessageModalShopButtonPressed;
 		if (HearthstoneApplication.Get() != null)
 		{
-			HearthstoneApplication.Get().Resetting -= ShowHubStartNotificationsWhenReadyToPlay;
+		HearthstoneApplication.Get().Resetting -= ShowHubStartNotificationsWhenReadyToPlay;
 		}
 		Box box = Box.Get();
 		if (!(box != null))
@@ -422,28 +427,29 @@ public class Hub : PegasusScene
 		PopupDisplayManager.Get().ReadyToShowPopups();
 		if (Network.ShouldBeConnectedToAurora())
 		{
-			if (!Options.Get().GetBool(Option.HAS_SEEN_HUB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_HUB))
-			{
-				StartCoroutine(DoFirstTimeHubWelcome());
-			}
-			else if (CollectionManager.Get().ShouldSeeTwistModeNotification() && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + GameSaveKeySubkeyId.HAS_SEEN_TWIST_MODE_NOTIFICATION))
+			if (!Options.Get().GetBool(Option.HAS_SEEN_HUB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "Hub.Start:" + Option.HAS_SEEN_HUB))
+		{
+			StartCoroutine(DoFirstTimeHubWelcome());
+		}
+			else if (CollectionManager.Get().ShouldSeeTwistModeNotification() && UserAttentionManager.CanShowAttentionGrabber(false, "Hub.Start:" + GameSaveKeySubkeyId.HAS_SEEN_TWIST_MODE_NOTIFICATION) && !AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// This is visual and doesn't really help. Need to ask for translations to do this properly
+			ShowNewTwistHearthstoneNotification("GLUE_NEW_TWIST_MODE_HINT");
+		}
+		else if (!Options.Get().GetBool(Option.HAS_SEEN_100g_REMINDER, defaultVal: false))
+		{
+			NetCache.NetCacheGoldBalance netObject = NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>();
+			if (netObject == null)
 			{
-				ShowNewTwistHearthstoneNotification("GLUE_NEW_TWIST_MODE_HINT");
+				Debug.LogError("Hub.Start Error - NetCache.NetCacheGoldBalance is null");
 			}
-			else if (!Options.Get().GetBool(Option.HAS_SEEN_100g_REMINDER, defaultVal: false))
+			if (netObject.GetTotal() >= 100 && UserAttentionManager.CanShowAttentionGrabber(true, "Hub.Start:" + Option.HAS_SEEN_100g_REMINDER))
 			{
-				NetCache.NetCacheGoldBalance netObject = NetCache.Get().GetNetObject<NetCache.NetCacheGoldBalance>();
-				if (netObject == null)
-				{
-					Debug.LogError("Hub.Start Error - NetCache.NetCacheGoldBalance is null");
-				}
-				if (netObject.GetTotal() >= 100 && UserAttentionManager.CanShowAttentionGrabber("Hub.Start:" + Option.HAS_SEEN_100g_REMINDER))
-				{
-					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FIRST_100_GOLD"), "VO_INNKEEPER_FIRST_100_GOLD.prefab:c6a50337099a454488acd96d2f37320f");
-					Options.Get().SetBool(Option.HAS_SEEN_100g_REMINDER, val: true);
-				}
+				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, GameStrings.Get("VO_INNKEEPER_FIRST_100_GOLD"), "VO_INNKEEPER_FIRST_100_GOLD.prefab:c6a50337099a454488acd96d2f37320f");
+				Options.Get().SetBool(Option.HAS_SEEN_100g_REMINDER, val: true);
 			}
 		}
+	}
 		RewardData.LoadPendingRewards();
 	}
 
diff --git a/Assembly-CSharp/HutongGames/PlayMaker/Actions/AnimationPlayAction.cs b/Assembly-CSharp/HutongGames/PlayMaker/Actions/AnimationPlayAction.cs
index 6a3060f..f19ef70 100644
--- a/Assembly-CSharp/HutongGames/PlayMaker/Actions/AnimationPlayAction.cs
+++ b/Assembly-CSharp/HutongGames/PlayMaker/Actions/AnimationPlayAction.cs
@@ -75,18 +75,19 @@ namespace HutongGames.PlayMaker.Actions
 			}
 			if (ownerDefaultTarget.GetComponent<Animation>() == null)
 			{
-				Debug.LogError($"AnimationPlayAction.OnUpdate() - animation component is missing. GameObject: {ownerDefaultTarget}, full path: {ownerDefaultTarget.GetFullPath()}");
+				UnityEngine.Debug.LogError($"AnimationPlayAction.OnUpdate() - animation component is missing. GameObject: {ownerDefaultTarget}, full path: {ownerDefaultTarget.GetFullPath()}");
 				ExceptionReporter.Get().ReportCaughtException(new Exception($"AnimationPlayAction.OnUpdate() - animation component is missing. GameObject: {ownerDefaultTarget}, full path: {ownerDefaultTarget.GetFullPath()}"));
 				Finish();
 				return;
 			}
 			if (m_animState == null)
 			{
-				Debug.LogError($"m_animState is null. GameObject: {ownerDefaultTarget}, full path: {ownerDefaultTarget.GetFullPath()}");
+				UnityEngine.Debug.LogError($"m_animState is null. GameObject: {ownerDefaultTarget}, full path: {ownerDefaultTarget.GetFullPath()}");
 				ExceptionReporter.Get().ReportCaughtException(new Exception($"m_animState is null. GameObject: {ownerDefaultTarget}, full path: {ownerDefaultTarget.GetFullPath()}"));
 				Finish();
 				return;
 			}
+
 			if (!m_animState.enabled || (m_animState.wrapMode == WrapMode.ClampForever && m_animState.time > m_animState.length))
 			{
 				base.Fsm.Event(m_FinishEvent);
diff --git a/Assembly-CSharp/ICCPrologueFakeDeath.cs b/Assembly-CSharp/ICCPrologueFakeDeath.cs
index 1b9915a..bcab668 100644
--- a/Assembly-CSharp/ICCPrologueFakeDeath.cs
+++ b/Assembly-CSharp/ICCPrologueFakeDeath.cs
@@ -4,295 +4,296 @@ using UnityEngine;
 
 public class ICCPrologueFakeDeath : Spell
 {
-	private enum FakeDeathState
-	{
-		EXPLODING_JAINA,
-		FROST_LICH_JAINA_ENTER,
-		LICH_KING_EXIT,
-		TIRION_ENTER,
-		COMPLETE
-	}
+    private enum FakeDeathState
+    {
+        EXPLODING_JAINA,
+        FROST_LICH_JAINA_ENTER,
+        LICH_KING_EXIT,
+        TIRION_ENTER,
+        COMPLETE
+    }
 
-	public Spell m_ExplodeReformSpell;
+    public Spell m_ExplodeReformSpell;
 
-	public Spell m_LichKingExitSpell;
+    public Spell m_LichKingExitSpell;
 
-	public Spell m_TirionEnterSpell;
+    public Spell m_TirionEnterSpell;
 
-	public GameObject m_FakeDefeatScreen;
+    public GameObject m_FakeDefeatScreen;
 
-	public float m_FakeDefeatScreenShowTime = 5f;
+    public float m_FakeDefeatScreenShowTime = 5f;
 
-	public float m_TirionEnterDelay = 2f;
+    public float m_TirionEnterDelay = 2f;
 
-	private Card m_lichKingCard;
+    private Card m_lichKingCard;
 
-	private Card m_tirionCard;
+    private Card m_tirionCard;
 
-	private Card m_frostLichJainaCard;
+    private Card m_frostLichJainaCard;
 
-	private int m_tirionEnterTaskIndex;
+    private int m_tirionEnterTaskIndex;
 
-	private int m_frostLichJainaEnterTaskIndex;
+    private int m_frostLichJainaEnterTaskIndex;
 
-	private Spell m_explodeReformSpellInstance;
+    private Spell m_explodeReformSpellInstance;
 
-	private ICC_01_LICHKING m_missionEntity;
+    private ICC_01_LICHKING m_missionEntity;
 
-	private FakeDeathState m_fakeDeathState;
+    private FakeDeathState m_fakeDeathState;
 
-	private ScreenEffectsHandle m_screenEffectsHandle;
+    private ScreenEffectsHandle m_screenEffectsHandle;
 
-	public override bool AddPowerTargets()
-	{
-		base.AddPowerTargets();
-		if (m_missionEntity == null)
-		{
-			m_missionEntity = GameState.Get().GetGameEntity() as ICC_01_LICHKING;
-			if (m_missionEntity == null)
-			{
-				Log.Spells.PrintError("ICCPrologueFakeDeath.AddPowerTargets(): GameEntity is not an instance of ICC_01_LICHKING!");
-			}
-		}
-		FindHeroCards();
-		return true;
-	}
+    public override bool AddPowerTargets()
+    {
+        base.AddPowerTargets();
+        if (m_missionEntity == null)
+        {
+            m_missionEntity = GameState.Get().GetGameEntity() as ICC_01_LICHKING;
+            if (m_missionEntity == null)
+            {
+                Log.Spells.PrintError("ICCPrologueFakeDeath.AddPowerTargets(): GameEntity is not an instance of ICC_01_LICHKING!");
+            }
+        }
+        FindHeroCards();
+        return true;
+    }
 
-	private void FindHeroCards()
-	{
-		if (m_lichKingCard == null)
-		{
-			m_lichKingCard = GameState.Get().GetOpposingSidePlayer().GetHeroCard();
-		}
-		if (m_frostLichJainaCard == null)
-		{
-			List<PowerTask> taskList = m_taskList.GetTaskList();
-			for (int i = 0; i < taskList.Count; i++)
-			{
+    private void FindHeroCards()
+    {
+        if (m_lichKingCard == null)
+        {
+            m_lichKingCard = GameState.Get().GetOpposingSidePlayer().GetHeroCard();
+        }
+        if (m_frostLichJainaCard == null)
+        {
+            List<PowerTask> taskList = m_taskList.GetTaskList();
+            for (int i = 0; i < taskList.Count; i++)
+            {
 				if (taskList[i].GetPower() is Network.HistFullEntity histFullEntity)
-				{
-					Entity entity = GameState.Get().GetEntity(histFullEntity.Entity.ID);
-					if (entity.GetControllerSide() == Player.Side.FRIENDLY && entity.IsHero())
-					{
-						m_frostLichJainaCard = entity.GetCard();
-						m_frostLichJainaEnterTaskIndex = i;
-						break;
-					}
-				}
-			}
-		}
-		if (!(m_tirionCard == null))
-		{
-			return;
-		}
-		List<PowerTask> taskList2 = m_taskList.GetTaskList();
-		for (int j = 0; j < taskList2.Count; j++)
-		{
+                {
+                    Entity entity = GameState.Get().GetEntity(histFullEntity.Entity.ID);
+                    if (entity.GetControllerSide() == Player.Side.FRIENDLY && entity.IsHero())
+                    {
+                        m_frostLichJainaCard = entity.GetCard();
+                        m_frostLichJainaEnterTaskIndex = i;
+                        break;
+                    }
+                }
+            }
+        }
+        if (!(m_tirionCard == null))
+        {
+            return;
+        }
+        List<PowerTask> taskList2 = m_taskList.GetTaskList();
+        for (int j = 0; j < taskList2.Count; j++)
+        {
 			if (taskList2[j].GetPower() is Network.HistTagChange histTagChange)
-			{
-				Entity entity2 = GameState.Get().GetEntity(histTagChange.Entity);
-				if (entity2.GetControllerSide() == Player.Side.OPPOSING && entity2.IsHero() && histTagChange.Tag == 262)
-				{
-					m_tirionCard = entity2.GetCard();
-					m_tirionEnterTaskIndex = j;
-					break;
-				}
-			}
-		}
-	}
+            {
+                Entity entity2 = GameState.Get().GetEntity(histTagChange.Entity);
+                if (entity2.GetControllerSide() == Player.Side.OPPOSING && entity2.IsHero() && histTagChange.Tag == 262)
+                {
+                    m_tirionCard = entity2.GetCard();
+                    m_tirionEnterTaskIndex = j;
+                    break;
+                }
+            }
+        }
+    }
 
-	public override bool CanPurge()
-	{
-		if (m_fakeDeathState != FakeDeathState.COMPLETE)
-		{
-			return false;
-		}
-		return base.CanPurge();
-	}
+    public override bool CanPurge()
+    {
+        if (m_fakeDeathState != FakeDeathState.COMPLETE)
+        {
+            return false;
+        }
+        return base.CanPurge();
+    }
 
-	public override bool ShouldReconnectIfStuck()
-	{
-		return false;
-	}
+    public override bool ShouldReconnectIfStuck()
+    {
+        return false;
+    }
 
-	protected override void OnAction(SpellStateType prevStateType)
-	{
-		base.OnAction(prevStateType);
-		StartCoroutine(DoEffects());
-	}
+    protected override void OnAction(SpellStateType prevStateType)
+    {
+        base.OnAction(prevStateType);
+        StartCoroutine(DoEffects());
+    }
 
-	private IEnumerator DoEffects()
-	{
-		if (m_fakeDeathState == FakeDeathState.EXPLODING_JAINA)
-		{
-			yield return StartCoroutine(ExplodeJaina());
-		}
-		if (m_fakeDeathState == FakeDeathState.FROST_LICH_JAINA_ENTER)
-		{
-			yield return StartCoroutine(FrostJainaEnter());
-		}
-		if (m_fakeDeathState == FakeDeathState.LICH_KING_EXIT)
-		{
-			yield return StartCoroutine(LichKingExit());
-		}
-		if (m_fakeDeathState == FakeDeathState.TIRION_ENTER)
-		{
-			yield return StartCoroutine(TirionEnter());
-		}
-		OnSpellFinished();
-		OnStateFinished();
-	}
+    private IEnumerator DoEffects()
+    {
+        if (m_fakeDeathState == FakeDeathState.EXPLODING_JAINA)
+        {
+            yield return StartCoroutine(ExplodeJaina());
+        }
+        if (m_fakeDeathState == FakeDeathState.FROST_LICH_JAINA_ENTER)
+        {
+            yield return StartCoroutine(FrostJainaEnter());
+        }
+        if (m_fakeDeathState == FakeDeathState.LICH_KING_EXIT)
+        {
+            yield return StartCoroutine(LichKingExit());
+        }
+        if (m_fakeDeathState == FakeDeathState.TIRION_ENTER)
+        {
+            yield return StartCoroutine(TirionEnter());
+        }
+        OnSpellFinished();
+        OnStateFinished();
+    }
 
-	private IEnumerator ExplodeJaina()
-	{
-		EndTurnButton.Get().AddInputBlocker();
-		PegCursor.Get().SetMode(PegCursor.Mode.STOPWAITING);
-		MusicManager.Get().StartPlaylist(MusicPlaylistType.UI_EndGameScreen);
-		SoundManager.Get().LoadAndPlay("defeat_jingle.prefab:0744a10f38e92f1438a02349c29a7b76");
-		StartCoroutine(HideBoardElements());
-		Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
-		heroCard.ActivateCharacterDeathEffects();
-		m_explodeReformSpellInstance = SpellManager.Get().GetSpell(m_ExplodeReformSpell);
-		SpellUtils.SetCustomSpellParent(m_explodeReformSpellInstance, heroCard.GetActor());
-		m_explodeReformSpellInstance.ActivateState(SpellStateType.ACTION);
-		while (m_explodeReformSpellInstance.GetActiveState() != 0)
-		{
-			yield return null;
-		}
-		m_fakeDeathState = FakeDeathState.FROST_LICH_JAINA_ENTER;
-	}
+    private IEnumerator ExplodeJaina()
+    {
+        EndTurnButton.Get().AddInputBlocker();
+        PegCursor.Get().SetMode(PegCursor.Mode.STOPWAITING);
+        MusicManager.Get().StartPlaylist(MusicPlaylistType.UI_EndGameScreen);
+        SoundManager.Get().LoadAndPlay("defeat_jingle.prefab:0744a10f38e92f1438a02349c29a7b76");
+        StartCoroutine(HideBoardElements());
+        Card heroCard = GameState.Get().GetFriendlySidePlayer().GetHeroCard();
+        heroCard.ActivateCharacterDeathEffects();
+        m_explodeReformSpellInstance = SpellManager.Get().GetSpell(m_ExplodeReformSpell);
+        SpellUtils.SetCustomSpellParent(m_explodeReformSpellInstance, heroCard.GetActor());
+        m_explodeReformSpellInstance.ActivateState(SpellStateType.ACTION);
+        while (m_explodeReformSpellInstance.GetActiveState() != 0)
+        {
+            yield return null;
+        }
+        m_fakeDeathState = FakeDeathState.FROST_LICH_JAINA_ENTER;
+    }
 
-	private IEnumerator FrostJainaEnter()
-	{
-		if (!(m_frostLichJainaCard == null))
-		{
-			m_taskList.DoTasks(0, m_frostLichJainaEnterTaskIndex);
-			GameObject fakeDefeatScreenInstance = Object.Instantiate(m_FakeDefeatScreen);
-			DefeatTwoScoop defeatTwoScoop = fakeDefeatScreenInstance.GetComponentInChildren<DefeatTwoScoop>(includeInactive: true);
-			while (!defeatTwoScoop.IsLoaded())
-			{
-				yield return null;
-			}
-			m_screenEffectsHandle = new ScreenEffectsHandle(this);
-			ScreenEffectParameters blurVignetteDesaturatePerspective = ScreenEffectParameters.BlurVignetteDesaturatePerspective;
-			m_screenEffectsHandle.StartEffect(blurVignetteDesaturatePerspective);
-			defeatTwoScoop.Show(showXPBar: false);
-			yield return new WaitForSeconds(m_FakeDefeatScreenShowTime);
-			m_screenEffectsHandle.StopEffect();
-			defeatTwoScoop.Hide();
-			m_taskList.DoTasks(0, m_frostLichJainaEnterTaskIndex + 1);
-			while (m_frostLichJainaCard.GetActor() == null || m_frostLichJainaCard.IsActorLoading())
-			{
-				yield return null;
-			}
-			m_frostLichJainaCard.HideCard();
-			m_explodeReformSpellInstance.ActivateState(SpellStateType.DEATH);
-			if (m_missionEntity != null)
-			{
-				StartCoroutine(m_missionEntity.PlayLichKingRezLines());
-			}
-			while (!m_explodeReformSpellInstance.IsFinished())
-			{
-				yield return null;
-			}
-			m_frostLichJainaCard.ShowCard();
-			m_frostLichJainaCard.GetActor().GetAttackObject().Hide();
-			while (m_explodeReformSpellInstance.GetActiveState() != 0)
-			{
-				yield return null;
-			}
-			while (GameState.Get().IsBusy())
-			{
-				yield return null;
-			}
-			Object.Destroy(fakeDefeatScreenInstance);
-			m_fakeDeathState = FakeDeathState.LICH_KING_EXIT;
-		}
-	}
+    private IEnumerator FrostJainaEnter()
+    {
+        if (!(m_frostLichJainaCard == null))
+        {
+            m_taskList.DoTasks(0, m_frostLichJainaEnterTaskIndex);
+            GameObject fakeDefeatScreenInstance = Object.Instantiate(m_FakeDefeatScreen);
+            DefeatTwoScoop defeatTwoScoop = fakeDefeatScreenInstance.GetComponentInChildren<DefeatTwoScoop>(includeInactive: true);
+            while (!defeatTwoScoop.IsLoaded())
+            {
+                yield return null;
+            }
 
-	private IEnumerator LichKingExit()
-	{
-		Spell lichKingExitSpellInstance = SpellManager.Get().GetSpell(m_LichKingExitSpell);
-		SpellUtils.SetCustomSpellParent(lichKingExitSpellInstance, m_lichKingCard.GetActor());
-		lichKingExitSpellInstance.Activate();
-		while (lichKingExitSpellInstance.GetActiveState() != 0)
-		{
-			yield return null;
-		}
-		yield return new WaitForSeconds(m_TirionEnterDelay);
-		m_fakeDeathState = FakeDeathState.TIRION_ENTER;
-	}
+            m_screenEffectsHandle = new ScreenEffectsHandle(this);
+            ScreenEffectParameters blurVignetteDesaturatePerspective = ScreenEffectParameters.BlurVignetteDesaturatePerspective;
+            m_screenEffectsHandle.StartEffect(blurVignetteDesaturatePerspective);
+            defeatTwoScoop.Show(null, showXPBar: false);
+            yield return new WaitForSeconds(m_FakeDefeatScreenShowTime);
+            m_screenEffectsHandle.StopEffect();
+            defeatTwoScoop.Hide();
+            m_taskList.DoTasks(0, m_frostLichJainaEnterTaskIndex + 1);
+            while (m_frostLichJainaCard.GetActor() == null || m_frostLichJainaCard.IsActorLoading())
+            {
+                yield return null;
+            }
+            m_frostLichJainaCard.HideCard();
+            m_explodeReformSpellInstance.ActivateState(SpellStateType.DEATH);
+            if (m_missionEntity != null)
+            {
+                StartCoroutine(m_missionEntity.PlayLichKingRezLines());
+            }
+            while (!m_explodeReformSpellInstance.IsFinished())
+            {
+                yield return null;
+            }
+            m_frostLichJainaCard.ShowCard();
+            m_frostLichJainaCard.GetActor().GetAttackObject().Hide();
+            while (m_explodeReformSpellInstance.GetActiveState() != 0)
+            {
+                yield return null;
+            }
+            while (GameState.Get().IsBusy())
+            {
+                yield return null;
+            }
+            Object.Destroy(fakeDefeatScreenInstance);
+            m_fakeDeathState = FakeDeathState.LICH_KING_EXIT;
+        }
+    }
 
-	private IEnumerator TirionEnter()
-	{
-		if (!(m_tirionCard == null))
-		{
-			m_taskList.DoTasks(0, m_tirionEnterTaskIndex + 1);
-			m_tirionCard.SetDoNotSort(on: true);
-			m_tirionCard.SetDoNotWarpToNewZone(on: true);
-			while (m_tirionCard.GetActor() == null || m_tirionCard.IsActorLoading())
-			{
-				yield return null;
-			}
-			TransformUtil.CopyWorld(m_tirionCard, m_tirionCard.GetZone().transform);
-			m_tirionCard.GetActor().Hide();
-			Spell tirionEnterSpellInstance = SpellManager.Get().GetSpell(m_TirionEnterSpell);
-			SpellUtils.SetCustomSpellParent(tirionEnterSpellInstance, m_tirionCard.GetActor());
-			tirionEnterSpellInstance.Activate();
-			while (tirionEnterSpellInstance.GetActiveState() != 0)
-			{
-				yield return null;
-			}
-			m_tirionCard.SetDoNotSort(on: false);
-			m_tirionCard.SetDoNotWarpToNewZone(on: false);
-			NameBanner nameBannerForSide = Gameplay.Get().GetNameBannerForSide(Player.Side.OPPOSING);
-			nameBannerForSide.UpdateHeroNameBanner();
-			nameBannerForSide.UpdateSubtext();
-			m_missionEntity.StartGameplaySoundtracks();
-			EndTurnButton.Get().RemoveInputBlocker();
-			m_fakeDeathState = FakeDeathState.COMPLETE;
-		}
-	}
+    private IEnumerator LichKingExit()
+    {
+        Spell lichKingExitSpellInstance = SpellManager.Get().GetSpell(m_LichKingExitSpell);
+        SpellUtils.SetCustomSpellParent(lichKingExitSpellInstance, m_lichKingCard.GetActor());
+        lichKingExitSpellInstance.Activate();
+        while (lichKingExitSpellInstance.GetActiveState() != 0)
+        {
+            yield return null;
+        }
+        yield return new WaitForSeconds(m_TirionEnterDelay);
+        m_fakeDeathState = FakeDeathState.TIRION_ENTER;
+    }
 
-	private IEnumerator HideBoardElements()
-	{
-		yield return new WaitForSeconds(0.5f);
-		Player controller = GameState.Get().GetFriendlySidePlayer();
-		if (controller.GetHeroPowerCard() != null)
-		{
-			controller.GetHeroPowerCard().HideCard();
-			controller.GetHeroPowerCard().GetActor().ToggleForceIdle(bOn: true);
-			controller.GetHeroPowerCard().GetActor().SetActorState(ActorStateType.CARD_IDLE);
-			controller.GetHeroPowerCard().GetActor().DoCardDeathVisuals();
-		}
-		if (controller.GetWeaponCard() != null)
-		{
-			controller.GetWeaponCard().HideCard();
-			controller.GetWeaponCard().GetActor().ToggleForceIdle(bOn: true);
-			controller.GetWeaponCard().GetActor().SetActorState(ActorStateType.CARD_IDLE);
-			controller.GetWeaponCard().GetActor().DoCardDeathVisuals();
-		}
-		Actor actor = controller.GetHeroCard().GetActor();
-		actor.HideArmorSpell();
-		actor.GetHealthObject().Hide();
-		actor.GetAttackObject().Hide();
-		actor.ToggleForceIdle(bOn: true);
-		actor.SetActorState(ActorStateType.CARD_IDLE);
-		yield return new WaitForSeconds(3f);
-		Player firstOpponentPlayer = GameState.Get().GetFirstOpponentPlayer(controller);
-		if (firstOpponentPlayer.GetHeroPowerCard() != null)
-		{
-			firstOpponentPlayer.GetHeroPowerCard().HideCard();
-			firstOpponentPlayer.GetHeroPowerCard().GetActor().ToggleForceIdle(bOn: true);
-			firstOpponentPlayer.GetHeroPowerCard().GetActor().SetActorState(ActorStateType.CARD_IDLE);
-			firstOpponentPlayer.GetHeroPowerCard().GetActor().DoCardDeathVisuals();
-		}
-		if (firstOpponentPlayer.GetWeaponCard() != null)
-		{
-			firstOpponentPlayer.GetWeaponCard().HideCard();
-			firstOpponentPlayer.GetWeaponCard().GetActor().ToggleForceIdle(bOn: true);
-			firstOpponentPlayer.GetWeaponCard().GetActor().SetActorState(ActorStateType.CARD_IDLE);
-			firstOpponentPlayer.GetWeaponCard().GetActor().DoCardDeathVisuals();
-		}
-	}
+    private IEnumerator TirionEnter()
+    {
+        if (!(m_tirionCard == null))
+        {
+            m_taskList.DoTasks(0, m_tirionEnterTaskIndex + 1);
+            m_tirionCard.SetDoNotSort(on: true);
+            m_tirionCard.SetDoNotWarpToNewZone(on: true);
+            while (m_tirionCard.GetActor() == null || m_tirionCard.IsActorLoading())
+            {
+                yield return null;
+            }
+            TransformUtil.CopyWorld(m_tirionCard, m_tirionCard.GetZone().transform);
+            m_tirionCard.GetActor().Hide();
+            Spell tirionEnterSpellInstance = SpellManager.Get().GetSpell(m_TirionEnterSpell);
+            SpellUtils.SetCustomSpellParent(tirionEnterSpellInstance, m_tirionCard.GetActor());
+            tirionEnterSpellInstance.Activate();
+            while (tirionEnterSpellInstance.GetActiveState() != 0)
+            {
+                yield return null;
+            }
+            m_tirionCard.SetDoNotSort(on: false);
+            m_tirionCard.SetDoNotWarpToNewZone(on: false);
+            NameBanner nameBannerForSide = Gameplay.Get().GetNameBannerForSide(Player.Side.OPPOSING);
+            nameBannerForSide.UpdateHeroNameBanner();
+            nameBannerForSide.UpdateSubtext();
+            m_missionEntity.StartGameplaySoundtracks();
+            EndTurnButton.Get().RemoveInputBlocker();
+            m_fakeDeathState = FakeDeathState.COMPLETE;
+        }
+    }
+
+    private IEnumerator HideBoardElements()
+    {
+        yield return new WaitForSeconds(0.5f);
+        Player controller = GameState.Get().GetFriendlySidePlayer();
+        if (controller.GetHeroPowerCard() != null)
+        {
+            controller.GetHeroPowerCard().HideCard();
+            controller.GetHeroPowerCard().GetActor().ToggleForceIdle(bOn: true);
+            controller.GetHeroPowerCard().GetActor().SetActorState(ActorStateType.CARD_IDLE);
+            controller.GetHeroPowerCard().GetActor().DoCardDeathVisuals();
+        }
+        if (controller.GetWeaponCard() != null)
+        {
+            controller.GetWeaponCard().HideCard();
+            controller.GetWeaponCard().GetActor().ToggleForceIdle(bOn: true);
+            controller.GetWeaponCard().GetActor().SetActorState(ActorStateType.CARD_IDLE);
+            controller.GetWeaponCard().GetActor().DoCardDeathVisuals();
+        }
+        Actor actor = controller.GetHeroCard().GetActor();
+        actor.HideArmorSpell();
+        actor.GetHealthObject().Hide();
+        actor.GetAttackObject().Hide();
+        actor.ToggleForceIdle(bOn: true);
+        actor.SetActorState(ActorStateType.CARD_IDLE);
+        yield return new WaitForSeconds(3f);
+        Player firstOpponentPlayer = GameState.Get().GetFirstOpponentPlayer(controller);
+        if (firstOpponentPlayer.GetHeroPowerCard() != null)
+        {
+            firstOpponentPlayer.GetHeroPowerCard().HideCard();
+            firstOpponentPlayer.GetHeroPowerCard().GetActor().ToggleForceIdle(bOn: true);
+            firstOpponentPlayer.GetHeroPowerCard().GetActor().SetActorState(ActorStateType.CARD_IDLE);
+            firstOpponentPlayer.GetHeroPowerCard().GetActor().DoCardDeathVisuals();
+        }
+        if (firstOpponentPlayer.GetWeaponCard() != null)
+        {
+            firstOpponentPlayer.GetWeaponCard().HideCard();
+            firstOpponentPlayer.GetWeaponCard().GetActor().ToggleForceIdle(bOn: true);
+            firstOpponentPlayer.GetWeaponCard().GetActor().SetActorState(ActorStateType.CARD_IDLE);
+            firstOpponentPlayer.GetWeaponCard().GetActor().DoCardDeathVisuals();
+        }
+    }
 }
diff --git a/Assembly-CSharp/ICollectible.cs b/Assembly-CSharp/ICollectible.cs
index 9279439..479df90 100644
--- a/Assembly-CSharp/ICollectible.cs
+++ b/Assembly-CSharp/ICollectible.cs
@@ -10,4 +10,8 @@ public interface ICollectible : IComparable
 	HashSet<string> GetSearchableTokens();
 
 	SearchableString GetSearchableString();
+
+	#region Accessibility
+	bool IsAccessible();
+	#endregion
 }
diff --git a/Assembly-CSharp/InactivePlayerKicker.cs b/Assembly-CSharp/InactivePlayerKicker.cs
index 78730a1..df77715 100644
--- a/Assembly-CSharp/InactivePlayerKicker.cs
+++ b/Assembly-CSharp/InactivePlayerKicker.cs
@@ -21,7 +21,7 @@ public class InactivePlayerKicker : IService, IHasUpdate
 
 	private GameMgr m_gameMgr;
 
-	public bool WasKickedForInactivity { get; private set; }
+	public bool WasKickedForInactivity { get; set; }
 
 	public IEnumerator<IAsyncJobResult> Initialize(ServiceLocator serviceLocator)
 	{
diff --git a/Assembly-CSharp/InitialDownloadDialog.cs b/Assembly-CSharp/InitialDownloadDialog.cs
index 1d18bb4..16f3d5b 100644
--- a/Assembly-CSharp/InitialDownloadDialog.cs
+++ b/Assembly-CSharp/InitialDownloadDialog.cs
@@ -1,12 +1,14 @@
 using System;
 using System.Collections;
+using System.Collections.Generic;
+using Accessibility;
 using Blizzard.T5.Core;
 using Blizzard.T5.Jobs;
 using Hearthstone.Core.Streaming;
 using Hearthstone.Streaming;
 using UnityEngine;
 
-public class InitialDownloadDialog : DialogBase
+public class InitialDownloadDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
@@ -142,9 +144,9 @@ public class InitialDownloadDialog : DialogBase
 			Log.Downloader.Log(LogLevel.Information, "Initial download is done.");
 			m_progressBar.SetProgressBar(1f);
 			m_downloadProgressText.Text = $"{megabytes} / {megabytes} {arg}";
-			SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
-			Hide();
-		}
+		SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
+		Hide();
+	}
 	}
 
 	private void StartFlavorTextAnimation()
diff --git a/Assembly-CSharp/InputCollection.cs b/Assembly-CSharp/InputCollection.cs
index 755b8a0..33d1804 100644
--- a/Assembly-CSharp/InputCollection.cs
+++ b/Assembly-CSharp/InputCollection.cs
@@ -8,6 +8,7 @@ public static class InputCollection
 	static InputCollection()
 	{
 		m_Inputs = new List<IInput>();
+		m_Inputs.Add(AccessibleUnityInput.Get());
 		m_Inputs.Add(new UnityInput());
 	}
 
diff --git a/Assembly-CSharp/InputManager.cs b/Assembly-CSharp/InputManager.cs
index e352c3e..91c98ad 100644
--- a/Assembly-CSharp/InputManager.cs
+++ b/Assembly-CSharp/InputManager.cs
@@ -7,6 +7,7 @@ using Blizzard.T5.Game.Spells;
 using Blizzard.T5.Services;
 using Hearthstone;
 using UnityEngine;
+using Accessibility;
 
 public class InputManager : MonoBehaviour
 {
@@ -267,6 +268,10 @@ public class InputManager : MonoBehaviour
 
 	public Vector3 LastMouseDownPosition => m_lastMouseDownPosition;
 
+	#region Accessibility
+	internal Card m_mousedOverCardRegardlessOfInput; // Used in Battlegrounds only due to the tutorial messing things up
+	#endregion
+
 	private void Awake()
 	{
 		s_instance = this;
@@ -638,6 +643,8 @@ public class InputManager : MonoBehaviour
 
 	public void SetMousedOverCard(Card card)
 	{
+		m_mousedOverCardRegardlessOfInput = card;
+
 		if (!(m_mousedOverCard == card))
 		{
 			if (m_mousedOverCard != null && !(m_mousedOverCard.GetZone() is ZoneHand))
@@ -646,7 +653,7 @@ public class InputManager : MonoBehaviour
 			}
 			if (card.IsInputEnabled())
 			{
-				m_mousedOverCard = card;
+				SetMousedOverCardVariable(card);
 				card.NotifyMousedOver();
 			}
 		}
@@ -805,40 +812,40 @@ public class InputManager : MonoBehaviour
 						TeammateBoardViewer.Get().ClickedTeammatesCardInHand();
 						return;
 					}
-					Card linkedCard = cardStandIn.linkedCard;
-					if (IsCancelingBattlecryCard(linkedCard))
-					{
-						return;
-					}
-					if (m_myHandZone == null)
-					{
-						Debug.LogWarning("HandZone not set for CardStandIn " + (cardStandIn.name ?? "Unknown"));
-						return;
-					}
-					if (m_useHandEnlarge && !m_myHandZone.HandEnlarged())
-					{
-						m_leftMouseButtonIsDown = true;
-						m_touchedDownOnSmallHand = true;
-						if (!HasPlayFromMiniHandEnabled())
-						{
-							return;
-						}
-						m_touchedDownOnSmallHandStartTime = Time.realtimeSinceStartup;
-					}
-					m_lastObjectMousedDown = cardStandIn.gameObject;
-					m_lastMouseDownPosition = InputCollection.GetMousePosition();
+				Card linkedCard = cardStandIn.linkedCard;
+				if (IsCancelingBattlecryCard(linkedCard))
+				{
+					return;
+				}
+				if (m_myHandZone == null)
+				{
+					Debug.LogWarning("HandZone not set for CardStandIn " + (cardStandIn.name ?? "Unknown"));
+					return;
+				}
+				if (m_useHandEnlarge && !m_myHandZone.HandEnlarged())
+				{
 					m_leftMouseButtonIsDown = true;
-					if (m_universalInputManager.IsTouchMode())
+					m_touchedDownOnSmallHand = true;
+					if (!HasPlayFromMiniHandEnabled())
 					{
-						m_touchDraggingCard = m_myHandZone.TouchReceived();
-						m_lastPreviewedCard = cardStandIn.linkedCard;
-					}
-					if (m_heldCard == null)
-					{
-						m_myHandZone.HandleInput();
+						return;
 					}
-					return;
+					m_touchedDownOnSmallHandStartTime = Time.realtimeSinceStartup;
 				}
+				m_lastObjectMousedDown = cardStandIn.gameObject;
+				m_lastMouseDownPosition = InputCollection.GetMousePosition();
+				m_leftMouseButtonIsDown = true;
+				if (m_universalInputManager.IsTouchMode())
+				{
+					m_touchDraggingCard = m_myHandZone.TouchReceived();
+					m_lastPreviewedCard = cardStandIn.linkedCard;
+				}
+				if (m_heldCard == null)
+				{
+					m_myHandZone.HandleInput();
+				}
+				return;
+			}
 			}
 			if (gameObject.GetComponent<EndTurnButton>() != null && PermitDecisionMakingInput() && !EndTurnButton.Get().IsInputBlocked())
 			{
@@ -1085,11 +1092,11 @@ public class InputManager : MonoBehaviour
 					if (cardStandIn != null)
 					{
 						if (HasPlayFromMiniHandEnabled() && m_useHandEnlarge && m_touchedDownOnSmallHand)
-						{
-							ShowPhoneHand();
-						}
-						TryHandleClickOnCard(lastObjectMousedDown, cardStandIn);
-					}
+								{
+									ShowPhoneHand();
+								}
+									TryHandleClickOnCard(lastObjectMousedDown, cardStandIn);
+								}
 					if (m_universalInputManager.IsTouchMode() && actor != null && choiceCardMgr.GetSubOptionParentCard() != null)
 					{
 						Card card2 = actor.GetCard();
@@ -1167,20 +1174,20 @@ public class InputManager : MonoBehaviour
 				return;
 			}
 		}
-		Card card = actor.GetCard();
-		if (card != null)
-		{
-			m_lastObjectRightMousedDown = card.gameObject;
-		}
-		else if (actor.GetHistoryCard() != null)
-		{
-			m_lastObjectRightMousedDown = actor.transform.parent.gameObject;
-		}
-		else
-		{
-			Debug.LogWarning("You clicked on something that is not being handled by InputManager.  Alert The Brode!");
+			Card card = actor.GetCard();
+			if (card != null)
+			{
+				m_lastObjectRightMousedDown = card.gameObject;
+			}
+			else if (actor.GetHistoryCard() != null)
+			{
+				m_lastObjectRightMousedDown = actor.transform.parent.gameObject;
+			}
+			else
+			{
+				Debug.LogWarning("You clicked on something that is not being handled by InputManager.  Alert The Brode!");
+			}
 		}
-	}
 
 	private void HandleRightMouseUp()
 	{
@@ -1198,9 +1205,9 @@ public class InputManager : MonoBehaviour
 				CardStandIn cardStandIn = GameObjectUtils.FindComponentInParents<CardStandIn>(hitInfo.transform);
 				if (cardStandIn == null || cardStandIn.linkedCard == null)
 				{
-					HandleRightClick();
+				HandleRightClick();
 					return;
-				}
+			}
 				actor = cardStandIn.linkedCard.GetActor();
 				if (actor == null || actor.GetCard() == null)
 				{
@@ -2303,7 +2310,7 @@ public class InputManager : MonoBehaviour
 					DropCanceledHeldCard(heldCard);
 					return true;
 				}
-			}
+					}
 			else if (flag2)
 			{
 				bool cancelDrop2 = false;
@@ -2377,9 +2384,9 @@ public class InputManager : MonoBehaviour
 		{
 			GameState gameState = m_gameState;
 			if (gameState == null || gameState.GetResponseMode() != GameState.ResponseMode.SUB_OPTION)
-			{
-				RemoteActionHandler.Get().NotifyOpponentOfCardDropped();
-			}
+		{
+			RemoteActionHandler.Get().NotifyOpponentOfCardDropped();
+		}
 		}
 		return true;
 	}
@@ -2803,9 +2810,9 @@ public class InputManager : MonoBehaviour
 		if (clickedEntity.IsGameModeButton())
 		{
 			if (card != null && card.GetPlaySpell(0) != null && card.GetPlaySpell(0).GetActiveState() != 0)
-			{
-				return;
-			}
+		{
+			return;
+		}
 			if (card.GetActor() != null)
 			{
 				card.GetActor().RemovePingAndNotifyTeammate();
@@ -2965,10 +2972,10 @@ public class InputManager : MonoBehaviour
 	public void CancelSelectedLettuceAbilityForEntity(Entity mercenaryEntity)
 	{
 		if (!m_gameState.IsResponsePacketBlocked() && m_gameState.GetGameEntity() is LettuceMissionEntity lettuceMissionEntity && DoNetworkOptions(mercenaryEntity))
-		{
-			lettuceMissionEntity.SetEntityThatJustCancelledAbilitySelection(mercenaryEntity);
+			{
+				lettuceMissionEntity.SetEntityThatJustCancelledAbilitySelection(mercenaryEntity);
+			}
 		}
-	}
 
 	private void ManuallyDismissMercenariesAbilityTray()
 	{
@@ -3452,7 +3459,7 @@ public class InputManager : MonoBehaviour
 			}
 			if (!entity.IsTitan())
 			{
-				RollbackSpentMana(entity);
+			RollbackSpentMana(entity);
 			}
 			DropSubOptionParentCard();
 		}
@@ -3502,6 +3509,8 @@ public class InputManager : MonoBehaviour
 				m_targetReticleManager.CreateFriendlyTargetArrow(entity, showDamageIndicatorText: true);
 			}
 		}
+
+		AccessibleGameplay.Get().ForceAnnounceChooseTarget();
 	}
 
 	public void FinishPendingChoiceTarget()
@@ -3834,47 +3843,47 @@ public class InputManager : MonoBehaviour
 		{
 			return;
 		}
-		m_mousedOverCard = card;
-		bool flag = m_gameState.IsFriendlySidePlayerTurn() && (bool)m_targetReticleManager && m_targetReticleManager.ShouldPreventMouseOverBigCard();
-		if (!PermitDecisionMakingInput())
-		{
-			flag = false;
-		}
-		if (m_gameState.IsMainPhase() && m_heldCard == null && !ChoiceCardMgr.Get().HasSubOption() && !flag && (!m_universalInputManager.IsTouchMode() || card.gameObject == m_lastObjectMousedDown))
-		{
-			SetShouldShowTooltip();
-		}
-		if (!m_gameState.IsMulliganManagerActive() || !card.GetEntity().IsHeroPower())
-		{
+			SetMousedOverCardVariable(card);
+			bool flag = m_gameState.IsFriendlySidePlayerTurn() && (bool)m_targetReticleManager && m_targetReticleManager.ShouldPreventMouseOverBigCard();
+			if (!PermitDecisionMakingInput())
+			{
+				flag = false;
+			}
+			if (m_gameState.IsMainPhase() && m_heldCard == null && !ChoiceCardMgr.Get().HasSubOption() && !flag && (!m_universalInputManager.IsTouchMode() || card.gameObject == m_lastObjectMousedDown))
+			{
+				SetShouldShowTooltip();
+			}
+			if (!m_gameState.IsMulliganManagerActive() || !card.GetEntity().IsHeroPower())
+			{
 			card.NotifyMousedOver();
-		}
+			}
 		if (m_gameState.IsMulliganManagerActive())
-		{
+			{
 			if (card.GetEntity().IsControlledByFriendlySidePlayer() && card.GetZone() is ZoneHand && !GameMgr.Get().IsBattlegroundsMatchOrTutorial())
 			{
 				TooltipPanelManager.Get().UpdateKeywordHelpForMulliganCard(card.GetEntity(), card.GetActor());
 			}
-		}
+			}
 		else
 		{
 			Zone zone = m_mousedOverCard.GetZone();
 			if (!(zone is ZoneHero) && !(zone is ZoneHeroPower) && !(zone is ZoneBattlegroundAnomaly) && !(zone is ZoneBattlegroundHeroBuddy) && !(zone is ZoneWeapon))
 			{
 				if (m_gameState.GetResponseMode() == GameState.ResponseMode.CHOICE)
-				{
-					TooltipPanelManager.TooltipBoneSource boneSource = ((ChoiceCardMgr.Get() != null && ChoiceCardMgr.Get().CardIsFirstChoice(m_mousedOverCard)) ? TooltipPanelManager.TooltipBoneSource.TOP_RIGHT : TooltipPanelManager.TooltipBoneSource.TOP_LEFT);
-					TooltipPanelManager.Get().UpdateKeywordHelpForDiscover(m_mousedOverCard.GetEntity(), m_mousedOverCard.GetActor(), boneSource);
-				}
-				else if (m_gameState.GetResponseMode() == GameState.ResponseMode.SUB_OPTION)
-				{
-					TooltipPanelManager.TooltipBoneSource boneSource2 = ((ChoiceCardMgr.Get() != null && ChoiceCardMgr.Get().CardIsFirstChoice(m_mousedOverCard)) ? TooltipPanelManager.TooltipBoneSource.TOP_RIGHT : TooltipPanelManager.TooltipBoneSource.TOP_LEFT);
-					TooltipPanelManager.Get().UpdateKeywordHelpForSubOptions(m_mousedOverCard.GetEntity(), m_mousedOverCard.GetActor(), boneSource2);
-				}
+		{
+			TooltipPanelManager.TooltipBoneSource boneSource = ((ChoiceCardMgr.Get() != null && ChoiceCardMgr.Get().CardIsFirstChoice(m_mousedOverCard)) ? TooltipPanelManager.TooltipBoneSource.TOP_RIGHT : TooltipPanelManager.TooltipBoneSource.TOP_LEFT);
+			TooltipPanelManager.Get().UpdateKeywordHelpForDiscover(m_mousedOverCard.GetEntity(), m_mousedOverCard.GetActor(), boneSource);
 			}
+		else if (m_gameState.GetResponseMode() == GameState.ResponseMode.SUB_OPTION)
+		{
+			TooltipPanelManager.TooltipBoneSource boneSource2 = ((ChoiceCardMgr.Get() != null && ChoiceCardMgr.Get().CardIsFirstChoice(m_mousedOverCard)) ? TooltipPanelManager.TooltipBoneSource.TOP_RIGHT : TooltipPanelManager.TooltipBoneSource.TOP_LEFT);
+			TooltipPanelManager.Get().UpdateKeywordHelpForSubOptions(m_mousedOverCard.GetEntity(), m_mousedOverCard.GetActor(), boneSource2);
+		}
+			}
+		}
+			ShowBullseyeIfNeeded();
+			ShowSkullIfNeeded();
 		}
-		ShowBullseyeIfNeeded();
-		ShowSkullIfNeeded();
-	}
 
 	public void NotifyCardDestroyed(Card destroyedCard)
 	{
@@ -3890,7 +3899,7 @@ public class InputManager : MonoBehaviour
 		{
 			PegCursor.Get().SetMode(PegCursor.Mode.UP);
 			Card mousedOverCard = m_mousedOverCard;
-			m_mousedOverCard = null;
+			SetMousedOverCardVariable(null);
 			mousedOverCard.HideTooltip();
 			mousedOverCard.NotifyMousedOut();
 			ShowBullseyeIfNeeded();
@@ -4116,11 +4125,11 @@ public class InputManager : MonoBehaviour
 			for (int i = 1; i < zoneTooltipSettings.FriendlyDeck.GetTooltipCount(); i++)
 			{
 				if (zoneTooltipSettings.FriendlyDeck.GetTooltipOverrideContent(ref headline2, ref description2, i))
-				{
-					AddTooltipInZone(tooltip, headline2, description2);
-				}
+			{
+				AddTooltipInZone(tooltip, headline2, description2);
 			}
 		}
+		}
 		ShowFriendlyHandSizeTooltipWhenHoveringDeck(zoneTooltipSettings);
 	}
 
@@ -4159,9 +4168,9 @@ public class InputManager : MonoBehaviour
 			for (int i = 1; i < zoneTooltipSettings.EnemyDeck.GetTooltipCount(); i++)
 			{
 				if (zoneTooltipSettings.EnemyDeck.GetTooltipOverrideContent(ref headline2, ref description2, i))
-				{
-					AddTooltipInZone(tooltip, headline2, description2);
-				}
+			{
+				AddTooltipInZone(tooltip, headline2, description2);
+			}
 			}
 		}
 		if (zoneTooltipSettings.ShowFriendlyHandWhenHoveringOpponentDeck)
@@ -4544,4 +4553,12 @@ public class InputManager : MonoBehaviour
 	{
 		return NetCache.Get().GetNetObject<NetCache.NetCacheFeatures>().EnablePlayingFromMiniHand;
 	}
+
+	#region Accessibility
+	private void SetMousedOverCardVariable(Card card)
+	{
+		m_mousedOverCard = card;
+		m_mousedOverCardRegardlessOfInput = card;
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/JoustSpellController.cs b/Assembly-CSharp/JoustSpellController.cs
index 1aa4659..b88e7d2 100644
--- a/Assembly-CSharp/JoustSpellController.cs
+++ b/Assembly-CSharp/JoustSpellController.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Blizzard.T5.Core.Utils;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class JoustSpellController : SpellController
@@ -266,6 +267,7 @@ public class JoustSpellController : SpellController
 		{
 			PlayNoJousterSpell(GameState.Get().GetOpposingSidePlayer());
 		}
+
 		while (IsJousterBusy(m_friendlyJouster) || IsJousterBusy(m_opponentJouster))
 		{
 			yield return null;
@@ -310,9 +312,26 @@ public class JoustSpellController : SpellController
 			DriftJouster(jouster);
 		};
 		iTween.Timer(card.gameObject, iTween.Hash("delay", delaySec, "time", showSec, "oncomplete", action));
+
+		var jousterName = card.GetEntity().GetName();
+		var jousterCost = card.GetEntity().GetDefCost();
+
+		if (card.GetEntity().IsControlledByFriendlySidePlayer())
+        {
+			OutputSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_JOUST_PLAYER_REVEALED_CARD, jousterCost, jousterName));
+        }
+		else
+        {
+			if (card.GetEntity().GetCardType() != TAG_CARDTYPE.INVALID)
+			{
+				// Some cards reuse the Joust mechanic even though they're not really Jousts
+				// e.g. Guess the weight when used by the opponent (only the opponent sees the card)
+				OutputSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_JOUST_OPPONENT_REVEALED_CARD, jousterCost, jousterName));
+			}
+		}
 	}
 
-	private void PlayNoJousterSpell(Player player)
+    private void PlayNoJousterSpell(Player player)
 	{
 		ZoneDeck deckZone = player.GetDeckZone();
 		Spell spell2 = SpellManager.Get().GetSpell(m_NoJousterSpellPrefab);
@@ -325,6 +344,15 @@ public class JoustSpellController : SpellController
 			}
 		});
 		spell2.Activate();
+
+		if (player.IsFriendlySide())
+        {
+			OutputSpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_JOUST_PLAYER_NO_VALID_CARDS));
+        }
+		else
+        {
+			OutputSpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_JOUST_OPPONENT_NO_VALID_CARDS));
+        }
 	}
 
 	private void DriftJouster(Jouster jouster)
@@ -537,4 +565,14 @@ public class JoustSpellController : SpellController
 		}
 		return jouster.m_effectsPendingFinish > 0;
 	}
+
+    #region Accessibility
+
+    private void OutputSpeech(string speech)
+    {
+        AccessibilityMgr.Output(AccessibleGameplay.Get(), speech);
+        AccessibleHistoryMgr.Get().AddEntry(speech);
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/KeyValuePairUtils.cs b/Assembly-CSharp/KeyValuePairUtils.cs
new file mode 100644
index 0000000..31ea32f
--- /dev/null
+++ b/Assembly-CSharp/KeyValuePairUtils.cs
@@ -0,0 +1,12 @@
+using System;
+using System.Collections.Generic;
+
+public static class KeyValuePairUtils
+{
+
+public static void Deconstruct<k, v>(this KeyValuePair<k, v> pair, out k key, out v value)
+{
+    key = pair.Key;
+    value = pair.Value;
+}
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/KeyboardAnimationSettings.cs b/Assembly-CSharp/KeyboardAnimationSettings.cs
index 6e848f2..4daa287 100644
--- a/Assembly-CSharp/KeyboardAnimationSettings.cs
+++ b/Assembly-CSharp/KeyboardAnimationSettings.cs
@@ -2,7 +2,7 @@ using System;
 using System.Collections.Generic;
 using UnityEngine;
 
-[CreateAssetMenu(menuName = "Prototyping/Keyboard Animation Settings")]
+// [CreateAssetMenu(menuName = "Prototyping/Keyboard Animation Settings")]
 public class KeyboardAnimationSettings : ScriptableObject
 {
 	[Serializable]
diff --git a/Assembly-CSharp/KeyboardFSMSettings.cs b/Assembly-CSharp/KeyboardFSMSettings.cs
index c6ff038..36977c3 100644
--- a/Assembly-CSharp/KeyboardFSMSettings.cs
+++ b/Assembly-CSharp/KeyboardFSMSettings.cs
@@ -2,7 +2,7 @@ using System;
 using System.Collections.Generic;
 using UnityEngine;
 
-[CreateAssetMenu(menuName = "Prototyping/Keyboard FSM Settings")]
+// [CreateAssetMenu(menuName = "Prototyping/Keyboard FSM Settings")]
 public class KeyboardFSMSettings : ScriptableObject
 {
 	[Serializable]
diff --git a/Assembly-CSharp/KeyboardFinisherSettings.cs b/Assembly-CSharp/KeyboardFinisherSettings.cs
index 2e93d2d..b6f9553 100644
--- a/Assembly-CSharp/KeyboardFinisherSettings.cs
+++ b/Assembly-CSharp/KeyboardFinisherSettings.cs
@@ -2,7 +2,7 @@ using System;
 using System.Collections.Generic;
 using UnityEngine;
 
-[CreateAssetMenu(menuName = "Prototyping/Keyboard Finisher Settings")]
+// [CreateAssetMenu(menuName = "Prototyping/Keyboard Finisher Settings")]
 public class KeyboardFinisherSettings : ScriptableObject
 {
 	public enum DamageLevel
diff --git a/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs b/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
index 57a62b6..c291806 100644
--- a/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
+++ b/Assembly-CSharp/LeaguePromoteSelfManuallyDialog.cs
@@ -1,6 +1,7 @@
+using Accessibility;
 using Hearthstone.UI;
 
-public class LeaguePromoteSelfManuallyDialog : DialogBase
+public class LeaguePromoteSelfManuallyDialog : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback();
 
diff --git a/Assembly-CSharp/LegalChallengeUIController.cs b/Assembly-CSharp/LegalChallengeUIController.cs
index 1b02885..c9b99c8 100644
--- a/Assembly-CSharp/LegalChallengeUIController.cs
+++ b/Assembly-CSharp/LegalChallengeUIController.cs
@@ -80,7 +80,7 @@ public class LegalChallengeUIController : BasicPopup
 		for (int i = 0; i < componentsInChildren.Length; i++)
 		{
 			componentsInChildren[i].SetText(data.legalAgreements[i].title);
-			string url = new string(data.legalAgreements[i].externalURL);
+			string url = string.Copy(data.legalAgreements[i].externalURL);
 			componentsInChildren[i].AddEventListener(UIEventType.RELEASE, delegate
 			{
 				OnDocButtonPressed(url);
diff --git a/Assembly-CSharp/LettuceCollectionDisplay.cs b/Assembly-CSharp/LettuceCollectionDisplay.cs
index 3dbbc95..1b47d79 100644
--- a/Assembly-CSharp/LettuceCollectionDisplay.cs
+++ b/Assembly-CSharp/LettuceCollectionDisplay.cs
@@ -484,7 +484,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 		DoEnterCollectionManagerEvents();
 		if (CollectionManager.Get().ShouldShowWildToStandardTutorial())
 		{
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		}
 		CollectionManager.Get().RequestDeckContentsForDecksWithoutContentsLoaded();
 		StartCoroutine(WaitUntilReady());
@@ -504,7 +504,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 
 	protected override void OnDestroy()
 	{
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_CM_TUTORIALS);
 		base.OnDestroy();
 	}
 
@@ -579,16 +579,20 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 
 	public override void CollectionPageContentsChanged<TCollectible>(ICollection<TCollectible> collectiblesToDisplay, CollectionActorsReadyCallback callback, object callbackData)
 	{
-		Log.CollectionManager.Print("transitionPageId={0} pagesTurning={1}", m_pageManager.GetTransitionPageId(), m_pageManager.ArePagesTurning());
+		Log.CollectionManager.Print("transitionPageId={0} pagesTurning={1}", new object[2]
+		{
+			m_pageManager.GetTransitionPageId(),
+			m_pageManager.ArePagesTurning()
+		});
 		bool flag = false;
 		if (collectiblesToDisplay == null)
 		{
-			Log.CollectionManager.Print("collectiblesToDisplay is null!");
+			Log.CollectionManager.Print("collectiblesToDisplay is null!", Array.Empty<object>());
 			flag = true;
 		}
 		else if (collectiblesToDisplay.Count == 0)
 		{
-			Log.CollectionManager.Print("collectiblesToDisplay has a count of 0!");
+			Log.CollectionManager.Print("collectiblesToDisplay has a count of 0!", Array.Empty<object>());
 			flag = true;
 		}
 		if (flag)
@@ -610,7 +614,13 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 
 	public override void SetViewMode(CollectionUtils.ViewMode mode, bool triggerResponse, CollectionUtils.ViewModeData userdata = null)
 	{
-		Log.CollectionManager.Print("mode={0}-->{1} triggerResponse={2} isUpdatingTrayMode={3}", m_currentViewMode, mode, triggerResponse, CollectionDeckTray.Get().IsUpdatingTrayMode());
+		Log.CollectionManager.Print("mode={0}-->{1} triggerResponse={2} isUpdatingTrayMode={3}", new object[4]
+		{
+			m_currentViewMode,
+			mode,
+			triggerResponse,
+			CollectionDeckTray.Get().IsUpdatingTrayMode()
+		});
 		if (m_currentViewMode != mode && ((mode != CollectionUtils.ViewMode.HERO_SKINS && mode != CollectionUtils.ViewMode.CARD_BACKS) || !CollectionDeckTray.Get().IsUpdatingTrayMode()))
 		{
 			CollectionUtils.ViewMode currentViewMode = m_currentViewMode;
@@ -686,7 +696,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 	{
 		if (formatType != FormatType.FT_STANDARD)
 		{
-			Log.CollectionManager.PrintWarning("LettuceCollectionDisplay only supports the Standard format, please add support to the class for other formats if needed.");
+			Log.CollectionManager.PrintWarning("LettuceCollectionDisplay only supports the Standard format, please add support to the class for other formats if needed.", Array.Empty<object>());
 		}
 		m_search.SetWildModeActive(active: false);
 		ShowSetFilterCards(cardSets, specificCards, transitionPage);
@@ -863,7 +873,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 	{
 		if (m_mercCraftingPopup == null)
 		{
-			Log.Lettuce.PrintError("LettuceCollectionDisplay.ShowMercCraftingPopup - merc crafting popup is null!");
+			Log.Lettuce.PrintError("LettuceCollectionDisplay.ShowMercCraftingPopup - merc crafting popup is null!", Array.Empty<object>());
 			return;
 		}
 		CollectionDeckTray.Get()?.GetTeamsContent()?.CancelRenameEditingTeam();
@@ -996,7 +1006,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 	{
 		if (m_pageManager == null)
 		{
-			Log.CollectionManager.PrintError("LettuceCollectionDisplay.InitCollectionWhenReady - m_pageManager null!");
+			Log.CollectionManager.PrintError("LettuceCollectionDisplay.InitCollectionWhenReady - m_pageManager null!", Array.Empty<object>());
 			yield break;
 		}
 		while (!m_pageManager.IsFullyLoaded())
@@ -1408,13 +1418,13 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 	{
 		if (!IsCollectionTipsBlocked)
 		{
-			if (m_ShowCollectionTipsCoroutine != null)
-			{
-				StopCoroutine(m_ShowCollectionTipsCoroutine);
-				m_ShowCollectionTipsCoroutine = null;
-			}
-			m_ShowCollectionTipsCoroutine = StartCoroutine(ShowCollectionTipsIfNeeded());
+		if (m_ShowCollectionTipsCoroutine != null)
+		{
+			StopCoroutine(m_ShowCollectionTipsCoroutine);
+			m_ShowCollectionTipsCoroutine = null;
 		}
+		m_ShowCollectionTipsCoroutine = StartCoroutine(ShowCollectionTipsIfNeeded());
+	}
 	}
 
 	public void BlockCollectionTips(bool isBlocked, string blockId)
@@ -1464,7 +1474,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 		{
 			yield return null;
 		}
-		if (TutorialShouldShowAbilityUpgrade() && UserAttentionManager.CanShowAttentionGrabber("LettuceCollectionDisplay.ShowCollectionTipsIfNeeded:HAS_SEEN_SHOW_MERC_DETAILS_TUTORIAL"))
+		if (TutorialShouldShowAbilityUpgrade() && UserAttentionManager.CanShowAttentionGrabber(false, "LettuceCollectionDisplay.ShowCollectionTipsIfNeeded:HAS_SEEN_SHOW_MERC_DETAILS_TUTORIAL"))
 		{
 			m_helpPopup = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, m_showMercDetailsTutorialBone.position, m_showMercDetailsTutorialBone.localScale, GameStrings.Get("GLUE_LETTUCE_COLLECTION_TUTORIAL01"));
 			m_helpPopup.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
@@ -1523,7 +1533,7 @@ public class LettuceCollectionDisplay : CollectibleDisplay
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber("LettuceCollectionDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL))
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "LettuceCollectionDisplay.ShowCollectionTipsIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL))
 		{
 			return false;
 		}
diff --git a/Assembly-CSharp/LettuceMapDisplay.cs b/Assembly-CSharp/LettuceMapDisplay.cs
index 627a4ad..6c79981 100644
--- a/Assembly-CSharp/LettuceMapDisplay.cs
+++ b/Assembly-CSharp/LettuceMapDisplay.cs
@@ -1113,43 +1113,43 @@ public class LettuceMapDisplay : AbsSceneDisplay
 			foreach (LettuceMapTreasure treasureOption in item.TreasureOptions)
 			{
 				lettuceTreasureSelectionDataModel.TreasureOptions.Add(CollectionUtils.CreateTreasureCardDataModel(treasureOption, m_isMythicMode));
-			}
+		}
 			lettuceTreasureSelectionDataModel.MercenaryTreasure = new DataModelList<CardDataModel>();
-			LettuceMapPlayerData currentPlayerData = GetCurrentPlayerData();
-			if (currentPlayerData == null || !currentPlayerData.HasTeamId)
+		LettuceMapPlayerData currentPlayerData = GetCurrentPlayerData();
+		if (currentPlayerData == null || !currentPlayerData.HasTeamId)
+		{
+			Log.Lettuce.PrintError("InitializeTreasureSelectionData - no player data or teamId!");
+			return;
+		}
+		PegasusLettuce.LettuceTeam teamForPlayer = GetTeamForPlayer(currentPlayerData);
+		if (teamForPlayer == null)
+		{
+			Log.Lettuce.PrintError("InitializeTreasureSelectionData - no team found for player!");
+			return;
+		}
+		foreach (LettuceTeamMercenary teamMercenary in teamForPlayer.MercenaryList.Mercenaries)
+		{
+			LettuceMercenary mercenary = CollectionManager.Get().GetMercenary(teamMercenary.MercenaryId);
+			MercenaryArtVariationPremiumDbfRecord record = GameDbf.MercenaryArtVariationPremium.GetRecord(teamMercenary.SelectedPortraitId);
+			int artVariationId = 0;
+			TAG_PREMIUM premium = TAG_PREMIUM.NORMAL;
+			if (record != null)
 			{
-				Log.Lettuce.PrintError("InitializeTreasureSelectionData - no player data or teamId!");
-				return;
+				artVariationId = record.MercenaryArtVariationId;
+				premium = (TAG_PREMIUM)record.Premium;
 			}
-			PegasusLettuce.LettuceTeam teamForPlayer = GetTeamForPlayer(currentPlayerData);
-			if (teamForPlayer == null)
+				lettuceTreasureSelectionDataModel.Mercenaries.Add(MercenaryFactory.CreateMercenaryDataModel(mercenary.ID, artVariationId, premium, mercenary, m_isMythicMode ? CollectionUtils.MercenaryDataPopluateExtra.MythicStats : CollectionUtils.MercenaryDataPopluateExtra.None));
+			LettuceMapTreasureAssignment lettuceMapTreasureAssignment = null;
+			if (map.TreasureAssignmentList?.TreasureAssignments != null)
 			{
-				Log.Lettuce.PrintError("InitializeTreasureSelectionData - no team found for player!");
-				return;
+				lettuceMapTreasureAssignment = map.TreasureAssignmentList.TreasureAssignments.FirstOrDefault((LettuceMapTreasureAssignment e) => e.AssignedMercenary == teamMercenary.MercenaryId);
 			}
-			foreach (LettuceTeamMercenary teamMercenary in teamForPlayer.MercenaryList.Mercenaries)
+			if (lettuceMapTreasureAssignment != null)
 			{
-				LettuceMercenary mercenary = CollectionManager.Get().GetMercenary(teamMercenary.MercenaryId);
-				MercenaryArtVariationPremiumDbfRecord record = GameDbf.MercenaryArtVariationPremium.GetRecord(teamMercenary.SelectedPortraitId);
-				int artVariationId = 0;
-				TAG_PREMIUM premium = TAG_PREMIUM.NORMAL;
-				if (record != null)
-				{
-					artVariationId = record.MercenaryArtVariationId;
-					premium = (TAG_PREMIUM)record.Premium;
-				}
-				lettuceTreasureSelectionDataModel.Mercenaries.Add(MercenaryFactory.CreateMercenaryDataModel(mercenary.ID, artVariationId, premium, mercenary, m_isMythicMode ? CollectionUtils.MercenaryDataPopluateExtra.MythicStats : CollectionUtils.MercenaryDataPopluateExtra.None));
-				LettuceMapTreasureAssignment lettuceMapTreasureAssignment = null;
-				if (map.TreasureAssignmentList?.TreasureAssignments != null)
-				{
-					lettuceMapTreasureAssignment = map.TreasureAssignmentList.TreasureAssignments.FirstOrDefault((LettuceMapTreasureAssignment e) => e.AssignedMercenary == teamMercenary.MercenaryId);
-				}
-				if (lettuceMapTreasureAssignment != null)
-				{
 					lettuceTreasureSelectionDataModel.MercenaryTreasure.Add(CollectionUtils.CreateTreasureCardDataModel(lettuceMapTreasureAssignment.Treasure, m_isMythicMode));
-				}
-				else
-				{
+			}
+			else
+			{
 					lettuceTreasureSelectionDataModel.MercenaryTreasure.Add(new CardDataModel());
 				}
 			}
@@ -1168,36 +1168,36 @@ public class LettuceMapDisplay : AbsSceneDisplay
 			}
 			LettuceTreasureSelectionDataModel lettuceTreasureSelectionDataModel = dataModel.TreasureSelectionData[i];
 			int mercenaryId = map.PendingTreasureSelection[i].MercenaryId;
-			LettuceMercenaryDataModel lettuceMercenaryDataModel = null;
-			MercenaryDetailed mercenaryDetailed = map.RecruitedMercenaries.FirstOrDefault((MercenaryDetailed m) => m.Mercenary.AssetId == mercenaryId);
-			if (mercenaryDetailed != null)
-			{
-				lettuceMercenaryDataModel = MercenaryFactory.CreateEmptyMercenaryDataModel();
-				CollectionUtils.PopulateMercenaryCardDataModel(lettuceMercenaryDataModel, LettuceMercenary.CreateDefaultArtVariation(mercenaryId));
-				lettuceMercenaryDataModel.MercenaryId = mercenaryDetailed.Mercenary.AssetId;
-				lettuceMercenaryDataModel.MercenaryLevel = GameUtils.GetMercenaryLevelFromExperience((int)mercenaryDetailed.Mercenary.Exp);
-				lettuceMercenaryDataModel.ExperienceInitial = (int)mercenaryDetailed.Mercenary.Exp;
-				lettuceMercenaryDataModel.FullyUpgradedInitial = mercenaryDetailed.IsFullyUpgraded;
-				lettuceMercenaryDataModel.Owned = true;
-				CollectionUtils.SetMercenaryStatsByLevel(lettuceMercenaryDataModel, mercenaryId, lettuceMercenaryDataModel.MercenaryLevel, mercenaryDetailed.IsFullyUpgraded);
-			}
-			else
-			{
+		LettuceMercenaryDataModel lettuceMercenaryDataModel = null;
+		MercenaryDetailed mercenaryDetailed = map.RecruitedMercenaries.FirstOrDefault((MercenaryDetailed m) => m.Mercenary.AssetId == mercenaryId);
+		if (mercenaryDetailed != null)
+		{
+			lettuceMercenaryDataModel = MercenaryFactory.CreateEmptyMercenaryDataModel();
+			CollectionUtils.PopulateMercenaryCardDataModel(lettuceMercenaryDataModel, LettuceMercenary.CreateDefaultArtVariation(mercenaryId));
+			lettuceMercenaryDataModel.MercenaryId = mercenaryDetailed.Mercenary.AssetId;
+			lettuceMercenaryDataModel.MercenaryLevel = GameUtils.GetMercenaryLevelFromExperience((int)mercenaryDetailed.Mercenary.Exp);
+			lettuceMercenaryDataModel.ExperienceInitial = (int)mercenaryDetailed.Mercenary.Exp;
+			lettuceMercenaryDataModel.FullyUpgradedInitial = mercenaryDetailed.IsFullyUpgraded;
+			lettuceMercenaryDataModel.Owned = true;
+			CollectionUtils.SetMercenaryStatsByLevel(lettuceMercenaryDataModel, mercenaryId, lettuceMercenaryDataModel.MercenaryLevel, mercenaryDetailed.IsFullyUpgraded);
+		}
+		else
+		{
 				lettuceMercenaryDataModel = lettuceTreasureSelectionDataModel.Mercenaries.Where((LettuceMercenaryDataModel m) => m.MercenaryId == mercenaryId).FirstOrDefault();
-			}
-			if (lettuceMercenaryDataModel == null)
-			{
-				Log.Lettuce.PrintError($"PopulateChoiceMercenaryData - no mercenary {mercenaryId} found in team or recruit list!");
+		}
+		if (lettuceMercenaryDataModel == null)
+		{
+			Log.Lettuce.PrintError($"PopulateChoiceMercenaryData - no mercenary {mercenaryId} found in team or recruit list!");
 				break;
-			}
+		}
 			lettuceTreasureSelectionDataModel.ChoiceMercenary = lettuceMercenaryDataModel;
-			LettuceMapTreasureAssignment lettuceMapTreasureAssignment = null;
-			if (map.TreasureAssignmentList?.TreasureAssignments != null)
-			{
-				lettuceMapTreasureAssignment = map.TreasureAssignmentList.TreasureAssignments.Where((LettuceMapTreasureAssignment e) => e.AssignedMercenary == mercenaryId).FirstOrDefault();
-			}
-			if (lettuceMapTreasureAssignment != null)
-			{
+		LettuceMapTreasureAssignment lettuceMapTreasureAssignment = null;
+		if (map.TreasureAssignmentList?.TreasureAssignments != null)
+		{
+			lettuceMapTreasureAssignment = map.TreasureAssignmentList.TreasureAssignments.Where((LettuceMapTreasureAssignment e) => e.AssignedMercenary == mercenaryId).FirstOrDefault();
+		}
+		if (lettuceMapTreasureAssignment != null)
+		{
 				lettuceTreasureSelectionDataModel.ChoiceMercenaryTreasure = CollectionUtils.CreateTreasureCardDataModel(lettuceMapTreasureAssignment.Treasure, m_isMythicMode);
 			}
 			lettuceTreasureSelectionDataModel.ChoiceMercenaryHasTreasure = lettuceMapTreasureAssignment != null;
@@ -1439,7 +1439,7 @@ public class LettuceMapDisplay : AbsSceneDisplay
 			rewardWidget.RegisterDoneChangingStatesListener(delegate
 			{
 				RewardScroll componentInChildren = rewardWidget.GetComponentInChildren<RewardScroll>();
-				componentInChildren.Initialize(delegate
+				componentInChildren.Initialize(null, delegate
 				{
 					m_waitingForVisitorSelectionServerResponse = false;
 					m_screenEffectsHandle.StopEffect();
@@ -1507,7 +1507,7 @@ public class LettuceMapDisplay : AbsSceneDisplay
 		rewardWidget.RegisterDoneChangingStatesListener(delegate
 		{
 			RewardScroll componentInChildren = rewardWidget.GetComponentInChildren<RewardScroll>();
-			componentInChildren.Initialize(delegate
+			componentInChildren.Initialize(null, delegate
 			{
 				m_waitingForVisitorSelectionServerResponse = false;
 				m_screenEffectsHandle.StopEffect();
@@ -2258,18 +2258,18 @@ public class LettuceMapDisplay : AbsSceneDisplay
 			long deckId = 0L;
 			int? lettuceMapNodeId = m_selectedMapCoin.Id;
 			gameMgr.FindGame(GameType.GT_MERCENARIES_PVE, FormatType.FT_WILD, missionId, 0, deckId, null, null, restoreSavedGameState: false, null, lettuceMapNodeId, 0L);
-		}
+			}
 		else if (record.VisitLogic == LettuceMapNodeType.Visitlogictype.VIEW_TASK_LIST)
-		{
-			LettuceVillagePopupManager lettuceVillagePopupManager = LettuceVillagePopupManager.Get();
-			lettuceVillagePopupManager.OnPopupClosed = (Action<LettuceVillagePopupManager.PopupType>)Delegate.Combine(lettuceVillagePopupManager.OnPopupClosed, new Action<LettuceVillagePopupManager.PopupType>(OnTaskboardClosed));
-			lettuceVillagePopupManager.Show(LettuceVillagePopupManager.PopupType.TASKBOARD);
-		}
-		else
-		{
-			m_playButton.Disable();
-			Network.Get().ChooseLettuceMapNode((uint)m_selectedMapCoin.Id);
-			m_clickBlocker.SetActive(value: true);
+			{
+				LettuceVillagePopupManager lettuceVillagePopupManager = LettuceVillagePopupManager.Get();
+				lettuceVillagePopupManager.OnPopupClosed = (Action<LettuceVillagePopupManager.PopupType>)Delegate.Combine(lettuceVillagePopupManager.OnPopupClosed, new Action<LettuceVillagePopupManager.PopupType>(OnTaskboardClosed));
+				lettuceVillagePopupManager.Show(LettuceVillagePopupManager.PopupType.TASKBOARD);
+			}
+			else
+			{
+				m_playButton.Disable();
+				Network.Get().ChooseLettuceMapNode((uint)m_selectedMapCoin.Id);
+				m_clickBlocker.SetActive(value: true);
+			}
 		}
 	}
-}
diff --git a/Assembly-CSharp/LoadingPopupDisplay.cs b/Assembly-CSharp/LoadingPopupDisplay.cs
index 974ebe1..a893789 100644
--- a/Assembly-CSharp/LoadingPopupDisplay.cs
+++ b/Assembly-CSharp/LoadingPopupDisplay.cs
@@ -3,8 +3,9 @@ using System.Collections;
 using System.Collections.Generic;
 using Blizzard.T5.Core;
 using UnityEngine;
+using Accessibility;
 
-public class LoadingPopupDisplay : TransitionPopup
+public class LoadingPopupDisplay : TransitionPopup, AccessibleUI
 {
 	[Serializable]
 	public class LoadingbarTexture
@@ -96,12 +97,23 @@ public class LoadingPopupDisplay : TransitionPopup
 		}
 	}
 
+	public override void Show()
+    {
+		base.Show();
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, m_title.Text, true);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+    }
+
 	public override void Hide()
 	{
 		if (m_shown)
 		{
 			Navigation.RemoveHandler(OnNavigateBack);
 			base.Hide();
+
+			AccessibilityMgr.HideUI(this);
 		}
 	}
 
@@ -461,4 +473,18 @@ public class LoadingPopupDisplay : TransitionPopup
 		}
 		m_progressBar.SetBarTexture(texture);
 	}
+
+	#region Accessibility
+
+	public void HandleAccessibleInput()
+    {
+		HandleCancelButtonInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return HandleCancelButtonHelp();
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/LoanerDeckDisplay.cs b/Assembly-CSharp/LoanerDeckDisplay.cs
index 5ae81b1..f6da636 100644
--- a/Assembly-CSharp/LoanerDeckDisplay.cs
+++ b/Assembly-CSharp/LoanerDeckDisplay.cs
@@ -5,8 +5,9 @@ using Assets;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
-public class LoanerDeckDisplay : MonoBehaviour
+public class LoanerDeckDisplay : MonoBehaviour, AccessibleScreen
 {
 	private const string CLOSE_DECK_DETAILS = "CloseDetails";
 
@@ -128,6 +129,8 @@ public class LoanerDeckDisplay : MonoBehaviour
 		if (m_loanerDeckDetails != null)
 		{
 			m_loanerDeckDetails.TriggerEvent("SHOW_EXPIRED_NOTIFICATION");
+						ReadLoanerDeckDisplay();
+
 			LoanerDeckDisplay.LoanerDeckExpiredDisplayed?.Invoke();
 		}
 	}
@@ -220,9 +223,9 @@ public class LoanerDeckDisplay : MonoBehaviour
 					gameMgr.CancelFindGame();
 				}
 			}
-			LoanerDeckInfoDataModel.IsLoanerDeckAvailable = true;
-			if (CanShowTimerExpiredState())
-			{
+				LoanerDeckInfoDataModel.IsLoanerDeckAvailable = true;
+				if (CanShowTimerExpiredState())
+				{
 				ShowTrialTimerExpiredState();
 				StopCoroutine(TickDownEligibilityTimer());
 				break;
@@ -304,6 +307,8 @@ public class LoanerDeckDisplay : MonoBehaviour
 						defaultDeckSelectButton = componentInChildren;
 						defaultDeckSelectButton.OnDeckChoiceButtonClicked("Selected");
 					}
+					m_decks.Items.Add(new AccessibleLoanerDeck(componentInChildren, collectionDeckMap[record.Key], record.Value.DeckRecord.Description));
+					m_numButtonsReady++;
 				}
 			});
 			num++;
@@ -360,4 +365,136 @@ public class LoanerDeckDisplay : MonoBehaviour
 		}
 		return false;
 	}
+
+	#region Accessibility
+	private enum AccessibleState
+	{
+		INTRO,
+		LOADING,
+		BROWSING_DECKS,
+		VIEW_DECK_MENU,
+		VIEW_DECK_CARDS
+	};
+
+	private AccessibleMenu m_deckMenu;
+
+	private AccessibleListOfItems<AccessibleLoanerDeck> m_decks = new AccessibleListOfItems<AccessibleLoanerDeck>(null, new List<AccessibleLoanerDeck>());
+	private AccessibleLoanerDeck m_currDeck;
+	private AccessibleListOfItems<AccessibleEditingDeckCard> m_currDeckCards  = new AccessibleListOfItems<AccessibleEditingDeckCard>(null, new List<AccessibleEditingDeckCard>());
+	private AccessibleState m_currAccessibleState;
+	private int m_numButtonsReady = 0;
+
+	private void ReadLoanerDeckDisplay()
+	{
+		if (AccessibilityMgr.IsCurrentlyFocused(this))
+		{
+			return;
+		}
+		SetupDeckMenu();
+		m_currAccessibleState = AccessibleState.INTRO;
+		AccessibilityMgr.SetScreen(this);
+		AccessibilityMgr.Output(this, GameStrings.Get("GLUE_LOANER_DECK_TIME_REACHED"));
+		AccessibilityMgr.Output(this, GameStrings.Get("GLUE_LOANER_DECK_CHOOSE_DECK"));
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+	}
+
+	private void SetupDeckMenu()
+	{
+		m_deckMenu = new AccessibleMenu(null, null, OnGoBackFromDeckMenu);
+		m_deckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_ADVENTURE_SCREEN_ADVENTURE_MENU_READ_DECK_OPTION), OnReadCurrDeck);
+		m_deckMenu.AddOption(GameStrings.Get("GLUE_LOANER_DECK_CLAIM"), OnClaimDeck);
+		m_deckMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_GO_BACK), OnGoBackFromDeckMenu);
+	}
+
+	private void OnReadCurrDeck()
+	{
+		m_currDeckCards.Items.Clear();
+		foreach (var slot in m_currDeck.Deck.GetSlots())
+		{
+			m_currDeckCards.Items.Add(new AccessibleEditingDeckCard(null, slot));
+		}
+		m_currAccessibleState = AccessibleState.VIEW_DECK_CARDS;
+		m_currDeckCards.StartReadingFromIndex(0);
+	}
+
+	private void OnClaimDeck()
+	{
+		ConfirmDeckSelection("ConfirmDeckChoice");
+	}
+
+	private void OnGoBackFromDeckMenu()
+	{
+		m_currAccessibleState = AccessibleState.BROWSING_DECKS;
+		m_decks.StartReading();
+	}
+
+	public void HandleInput()
+	{
+		switch (m_currAccessibleState)
+		{
+			case AccessibleState.INTRO:
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				AccessibilityUtils.LogDebug(m_loanerDeckDetails.transform.gameObject.name);
+				var button = m_loanerDeckDetails.transform.Find("LoanerDeckDetailsPopup/TimerExpiredNotification Popup Bone/TimerExpiredNotification/Button_Framed_Fast_Paging/ButtonFramed").GetComponent<UIBButton>();
+				button.TriggerPress();
+				button.TriggerRelease();
+				m_currAccessibleState = AccessibleState.LOADING;
+			}
+			break;
+			case AccessibleState.LOADING:
+			if (m_numButtonsReady >= FreeDeckMgr.Get().GetLoanerDecksAsMap().Count)
+			{
+				m_currAccessibleState = AccessibleState.BROWSING_DECKS;
+				m_decks.StartReading();
+			}
+			break;
+			case AccessibleState.BROWSING_DECKS:
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				m_currDeck = m_decks.GetItemBeingRead();
+				m_currDeck.Button.OnDeckChoiceButtonClicked("Selected");
+				m_currAccessibleState = AccessibleState.VIEW_DECK_MENU;
+				m_deckMenu.SetIndex(0);
+				m_deckMenu.StartReading();
+				return;
+			}
+			m_decks.HandleAccessibleInput();
+			break;
+			case AccessibleState.VIEW_DECK_MENU:
+			m_deckMenu.HandleAccessibleInput();
+			break;
+			case AccessibleState.VIEW_DECK_CARDS:
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				m_currAccessibleState = AccessibleState.VIEW_DECK_MENU;
+				m_deckMenu.StartReading();
+				return;
+			}
+			m_currDeckCards.HandleAccessibleInput();
+			break;
+		}
+	}
+
+	public string GetHelp()
+	{
+		switch (m_currAccessibleState)
+		{
+			case AccessibleState.INTRO:
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+			case AccessibleState.BROWSING_DECKS:
+			return m_decks.GetHelp(false);
+			case AccessibleState.VIEW_DECK_MENU:
+			return m_deckMenu.GetHelp();
+			case AccessibleState.VIEW_DECK_CARDS:
+			return m_currDeckCards.GetHelp(true);
+		}
+		return null;
+	}
+
+	public void OnGainedFocus()
+	{
+	}
+	#endregion
+
 }
diff --git a/Assembly-CSharp/Log.cs b/Assembly-CSharp/Log.cs
index db3e804..8d31e88 100644
--- a/Assembly-CSharp/Log.cs
+++ b/Assembly-CSharp/Log.cs
@@ -11,9 +11,12 @@ using UnityEngine;
 
 public static class Log
 {
+	private const string ACCESSIBILITY_LOG_NAME = "Accessibility";
+	private const string ACCESSIBILITY_TEXT_LOG_NAME = "Accessibility_text";
+
 	private static readonly List<string> s_legacyHearthstoneLoggers = new List<string>
 	{
-		"All", "AchievementManager", "Achievements", "AdTracking", "Adventures", "Arena", "Asset", "AsyncLoading", "BattlegroundsAuthoring", "BattleNet",
+		ACCESSIBILITY_LOG_NAME, "All", "AchievementManager", "Achievements", ACCESSIBILITY_TEXT_LOG_NAME, "AdTracking", "Adventures", "Arena", "Asset", "AsyncLoading", "BattlegroundsAuthoring", "BattleNet",
 		"BIReport", "Box", "BreakingNews", "BugReporter", "CardbackMgr", "ChangedCards", "ClientRequestManager", "CloudStorage", "CollectionDeckBox", "CollectionManager",
 		"CoinManager", "ConfigFile", "ContentConnect", "Crafting", "CRM", "Dbf", "DeckHelper", "DeckRuleset", "Decks", "DeckTray",
 		"DeepLink", "DelayedReporter", "DeviceEmulation", "Downloader", "EndOfGame", "ErrorReporter", "EventTable", "EventTiming", "ExceptionReporter", "FaceDownCard",
@@ -25,7 +28,7 @@ public static class Log
 		"UIStatus", "UserAttention", "W8Touch", "Zone"
 	};
 
-	private static readonly LogInfo[] DEFAULT_LOG_INFOS = new LogInfo[5]
+	private static readonly LogInfo[] DEFAULT_LOG_INFOS = new LogInfo[7]
 	{
 		new LogInfo
 		{
@@ -41,6 +44,22 @@ public static class Log
 			m_minLevel = LogLevel.Info
 		},
 		new LogInfo
+		{
+			m_name = ACCESSIBILITY_LOG_NAME,
+			m_filePrinting = true,
+			m_consolePrinting = false,
+			m_minLevel = LogLevel.Info,
+			m_defaultLevel = LogLevel.Info
+		},
+		new LogInfo
+		{
+			m_name = ACCESSIBILITY_TEXT_LOG_NAME,
+			m_filePrinting = true,
+			m_consolePrinting = false,
+			m_minLevel = LogLevel.Info,
+			m_defaultLevel = LogLevel.Info
+		},
+				new LogInfo
 		{
 			m_name = "Login",
 			m_filePrinting = true,
@@ -64,6 +83,8 @@ public static class Log
 
 	public static Logger All => GetLoggerFromSystem("All");
 
+	public static Logger Accessibility => GetLoggerFromSystem(ACCESSIBILITY_LOG_NAME);
+	public static Logger Accessibility_text => GetLoggerFromSystem(ACCESSIBILITY_TEXT_LOG_NAME);
 	public static Logger Achievements => GetLoggerFromSystem("Achievements");
 
 	public static Logger AdTracking => GetLoggerFromSystem("AdTracking");
@@ -337,14 +358,14 @@ public static class Log
 			Printers = new List<ILogPrinter>
 			{
 				new StandardFileLogPrinter(logSessionConfig, delegate(Action onMainThreadFunc)
+			{
+				Processor.ScheduleCallback(0f, realTime: false, delegate
 				{
-					Processor.ScheduleCallback(0f, realTime: false, delegate
-					{
 						onMainThreadFunc();
-					});
-				}, () => HearthstoneApplication.IsMainThread),
-				new UnityConsoleLogPrinter(),
-				new ScreenLogPrinter()
+				});
+			}, () => HearthstoneApplication.IsMainThread),
+			new UnityConsoleLogPrinter(),
+			new ScreenLogPrinter()
 			},
 			IsMainThreadFunc = () => HearthstoneApplication.IsMainThread,
 			LogInfoConfigDirectory = ConfigPath,
@@ -363,6 +384,7 @@ public static class Log
 				LogSystem.Get().SetLogInfo(logInfo.m_name, logInfo);
 			}
 		}
+
 		foreach (string s_legacyHearthstoneLogger in s_legacyHearthstoneLoggers)
 		{
 			LogSystem.Get().CreateFullLogger(s_legacyHearthstoneLogger);
diff --git a/Assembly-CSharp/Login.cs b/Assembly-CSharp/Login.cs
index 2084c69..e3549ff 100644
--- a/Assembly-CSharp/Login.cs
+++ b/Assembly-CSharp/Login.cs
@@ -1,4 +1,5 @@
 using System.Collections.Generic;
+using Accessibility;
 using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
 using Hearthstone;
@@ -97,11 +98,16 @@ public class Login : PegasusScene
 
 	private void ChangeMode()
 	{
+		HSADevTools.Init();
+
 		m_nextMissionId = GameUtils.GetNextTutorial();
 		bool flag = m_nextMissionId > 5287;
 		if (!GameUtils.IsTraditionalTutorialComplete() || flag)
 		{
-			ChangeMode_Tutorial();
+
+			AccessibilityMgr.Output(null, LocalizedText.GLOBAL_GAME_LOADED);
+			AccessibilityMgr.Output(null, AccessibleSpeech.PRESS_ENTER_TO_START);
+			AccessibilityMgr.WaitForForcedKey(AccessibleKey.CONFIRM, ChangeMode_Tutorial);
 			return;
 		}
 		if (RewardTrackManager.Get().HasReceivedRewardTracksFromServer)
@@ -117,21 +123,20 @@ public class Login : PegasusScene
 			if (!CreateSkipHelper.ShouldShowCreateSkip() || !CreateSkipHelper.ShowCreateSkipDialog(ChangeToAppropriateHubMode))
 			{
 				ChangeToAppropriateHubMode();
-				ChangeMode_SetRotation();
+				ChangeMode_SetRotation(false);
 			}
+			return;
 		}
-		else
-		{
-			ChangeMode_Hub();
-		}
+		ChangeMode_Hub();
 	}
 
 	private void ChangeToAppropriateHubMode()
 	{
 		Log.Login.PrintInfo("Changing mode");
-		if (SetRotationManager.Get().ShouldShowSetRotationIntro())
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && SetRotationManager.Get().ShouldShowSetRotationIntro())
 		{
-			ChangeMode_SetRotation();
+			// None of this is implemented yet (nor needed until ranked etc)
+			ChangeMode_SetRotation(false);
 		}
 		else
 		{
@@ -227,10 +232,17 @@ public class Login : PegasusScene
 	{
 		if (m_nextMissionId == 5287)
 		{
-			StartTutorial();
+			AccessibilityMgr.Output(null, LocalizationUtils.Get(LocalizationKey.WELCOME_TO_HEARTHSTONE));
+			AccessibilityMgr.Output(null, LocalizationUtils.Get(LocalizationKey.NEW_TUTORIAL_NARRATOR_INTRO));
+			AccessibilityMgr.Output(null, LocalizationUtils.Format(LocalizationKey.TUTORIAL_NARRATOR_HELP_KEYS, AccessibleKey.HELP));
+			AccessibilityMgr.Output(null, LocalizationUtils.Get(LocalizationKey.NEW_TUTORIAL_REXXAR_START));
+			AccessibilityMgr.Output(null, LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_START, AccessibleKey.CONFIRM));
+			AccessibilityMgr.WaitForForcedKey(AccessibleKey.CONFIRM, StartTutorial);
 		}
 		else
 		{
+			AccessibilityMgr.Output(null, LocalizationUtils.Get(LocalizationKey.TUTORIAL_WELCOME_BACK));
+
 			ShowTutorialProgressScreen();
 		}
 	}
@@ -255,6 +267,7 @@ public class Login : PegasusScene
 
 	private void StartTutorial()
 	{
+		AccessibleTutorialProgressScreen.Get().OnStartTutorial();
 		MusicManager.Get().StopPlaylist();
 		Box.Get().ChangeState(Box.State.CLOSED);
 		GameMgr.Get().RegisterFindGameEvent(OnFindGameEvent);
@@ -268,9 +281,9 @@ public class Login : PegasusScene
 		return true;
 	}
 
-	private void ChangeMode_SetRotation()
+	private void ChangeMode_SetRotation(bool accessible)
 	{
-		UserAttentionManager.StartBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StartBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 		Spell eventSpell = Box.Get().GetEventSpell(BoxEventType.STARTUP_SET_ROTATION);
 		Box.Get().m_StoreButton.gameObject.SetActive(value: false);
 		Box.Get().m_QuestLogButton.gameObject.SetActive(value: false);
diff --git a/Assembly-CSharp/LoginManager.cs b/Assembly-CSharp/LoginManager.cs
index efd2a95..a11f372 100644
--- a/Assembly-CSharp/LoginManager.cs
+++ b/Assembly-CSharp/LoginManager.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Globalization;
+using Accessibility;
 using Assets;
 using Blizzard.GameService.SDK.Client.Integration;
 using Blizzard.T5.Configuration;
@@ -240,15 +241,15 @@ public class LoginManager : IService
 	{
 		HearthstoneApplication.SendStartupTimeTelemetry("LoginManager.OnProfileProgressResponse");
 		Cinematic service2;
-		if (!Options.Get().GetBool(Option.HAS_SEEN_NEW_CINEMATIC, defaultVal: false) && PlatformSettings.OS == OSCategory.PC)
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && !Options.Get().GetBool(Option.HAS_SEEN_NEW_CINEMATIC, defaultVal: false) && PlatformSettings.OS == OSCategory.PC)
 		{
 			if (ServiceManager.TryGet<Cinematic>(out var service))
 			{
 				service.Play(delegate
-				{
-					ReadyToReconnectOrChangeModeDependency.Callback();
-				});
-			}
+			{
+				ReadyToReconnectOrChangeModeDependency.Callback();
+			});
+		}
 		}
 		else if (!ServiceManager.TryGet<Cinematic>(out service2) || !service2.IsPlaying)
 		{
@@ -408,15 +409,15 @@ public class LoginManager : IService
 		if (GameDownloadManagerProvider.Get().IsReadyToPlay)
 		{
 			Log.Login.PrintInfo("Initial download done, Waiting Intro popup...");
-			yield return new JobDefinition("DialogManager.WaitForSeasonEndPopup", DialogManager.Get().Job_WaitForSeasonEndPopup());
-			yield return new JobDefinition("PopupDisplayManager.WaitForAllPopups", PopupDisplayManager.Get().Job_WaitForAllPopups());
-			yield return new JobDefinition("NarrativeManager.WaitForOutstandingCharacterDialog", NarrativeManager.Get().Job_WaitForOutstandingCharacterDialog());
-			yield return new JobDefinition("LoginManager.ShowBreakingNews", Job_ShowBreakingNews());
-		}
+		yield return new JobDefinition("DialogManager.WaitForSeasonEndPopup", DialogManager.Get().Job_WaitForSeasonEndPopup());
+		yield return new JobDefinition("PopupDisplayManager.WaitForAllPopups", PopupDisplayManager.Get().Job_WaitForAllPopups());
+		yield return new JobDefinition("NarrativeManager.WaitForOutstandingCharacterDialog", NarrativeManager.Get().Job_WaitForOutstandingCharacterDialog());
+		yield return new JobDefinition("LoginManager.ShowBreakingNews", Job_ShowBreakingNews());
+	}
 		else
 		{
 			Log.Login.PrintInfo("Initial download not done, skipping Intro Popups...");
-			UserAttentionManager.StartBlocking(UserAttentionBlocker.INITIAL_DOWNLOAD);
+			UserAttentionManager.StartBlocking(false, UserAttentionBlocker.INITIAL_DOWNLOAD);
 		}
 	}
 
diff --git a/Assembly-CSharp/LoginPopupSequencePopup.cs b/Assembly-CSharp/LoginPopupSequencePopup.cs
index b04436a..4d49b8e 100644
--- a/Assembly-CSharp/LoginPopupSequencePopup.cs
+++ b/Assembly-CSharp/LoginPopupSequencePopup.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using Blizzard.T5.MaterialService.Extensions;
 using UnityEngine;
+using Accessibility;
 
 public class LoginPopupSequencePopup : BasicPopup
 {
@@ -19,6 +20,8 @@ public class LoginPopupSequencePopup : BasicPopup
 		public AssetReference m_backgroundMaterialReference;
 
 		public HideCallback m_callbackOnHide;
+
+		public Info(bool markedForAccessibility) { } // If something new shows up we must ensure login popup sequence is still hidden
 	}
 
 	private struct CardActorLoadedData
@@ -130,14 +133,17 @@ public class LoginPopupSequencePopup : BasicPopup
 		if (m_headerText != null)
 		{
 			m_headerText.Text = info.m_headerText;
+			AccessibilityMgr.Output(this, info.m_headerText);
 		}
 		if (m_bodyText != null)
 		{
 			m_bodyText.Text = info.m_bodyText;
+			AccessibilityMgr.Output(this, info.m_bodyText);
 		}
 		if (m_cancelButton != null)
 		{
 			m_cancelButton.SetText(info.m_buttonText);
+			AccessibilityMgr.Output(this, info.m_buttonText);
 		}
 		if (m_backgroundMaterial != null)
 		{
diff --git a/Assembly-CSharp/LoginPopups.cs b/Assembly-CSharp/LoginPopups.cs
index 3f8a87e..83d6b1c 100644
--- a/Assembly-CSharp/LoginPopups.cs
+++ b/Assembly-CSharp/LoginPopups.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using Assets;
+using Accessibility;
 
 public class LoginPopups : IDisposable
 {
@@ -23,7 +24,14 @@ public class LoginPopups : IDisposable
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber("ShowLoginPopupSequence"))
+		/*if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Not implemented yet as there's a few tricky ones
+		// TODO: Check all of this as I had to disable it due to the choose faction poup
+			return false;
+		}
+		*/
+		if (!UserAttentionManager.CanShowAttentionGrabber(false, "ShowLoginPopupSequence"))
 		{
 			return false;
 		}
@@ -113,7 +121,7 @@ public class LoginPopups : IDisposable
 					}
 					continue;
 				}
-				LoginPopupSequencePopup.Info info = new LoginPopupSequencePopup.Info
+				LoginPopupSequencePopup.Info info = new LoginPopupSequencePopup.Info(false)
 				{
 					m_headerText = loginPopupSequencePopupDbfRecord2.HeaderText,
 					m_bodyText = loginPopupSequencePopupDbfRecord2.BodyText,
diff --git a/Assembly-CSharp/ManaFilterTab.cs b/Assembly-CSharp/ManaFilterTab.cs
index a60ff96..73a8e4e 100644
--- a/Assembly-CSharp/ManaFilterTab.cs
+++ b/Assembly-CSharp/ManaFilterTab.cs
@@ -29,6 +29,10 @@ public class ManaFilterTab : PegUIElement
 
 	private AudioSource m_mouseOverSound;
 
+	#region Accessibility
+	internal string m_manaCostText;
+	#endregion
+
 	protected override void Awake()
 	{
 		m_crystal.MarkAsNotInGame();
@@ -125,19 +129,25 @@ public class ManaFilterTab : PegUIElement
 		if (m_manaID == -1)
 		{
 			text2 = GameStrings.Get("GLUE_COLLECTION_ALL");
+			m_manaCostText = text2;
 		}
 		else
 		{
 			text = m_manaID.ToString();
+			m_manaCostText = text;
+
 			if (m_manaID == 7)
 			{
+				var plus = GameStrings.Get("GLUE_COLLECTION_PLUS");
 				if ((bool)UniversalInputManager.UsePhoneUI)
 				{
-					text += GameStrings.Get("GLUE_COLLECTION_PLUS");
+					text += plus;
+					m_manaCostText = text;
 				}
 				else
 				{
-					text2 = GameStrings.Get("GLUE_COLLECTION_PLUS");
+					text2 = plus;
+					m_manaCostText += plus; // This is the one we'll actually end up using
 				}
 			}
 		}
diff --git a/Assembly-CSharp/ManaFilterTabManager.cs b/Assembly-CSharp/ManaFilterTabManager.cs
index af7dc30..e05e0e4 100644
--- a/Assembly-CSharp/ManaFilterTabManager.cs
+++ b/Assembly-CSharp/ManaFilterTabManager.cs
@@ -4,6 +4,8 @@ using UnityEngine;
 
 public class ManaFilterTabManager : MonoBehaviour
 {
+	internal static int NUM_MANA_FILTERS = 7;
+
 	public ManaFilterTab m_singleManaFilterPrefab;
 
 	public ManaFilterTab m_dynamicManaFilterPrefab;
@@ -12,7 +14,7 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	private bool m_tabsActive;
 
-	private List<ManaFilterTab> m_tabs = new List<ManaFilterTab>();
+	internal List<ManaFilterTab> m_tabs = new List<ManaFilterTab>();
 
 	private HashSet<int> m_currentFilterExactValues = new HashSet<int>();
 
@@ -165,11 +167,11 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	public void SetUpTabs()
 	{
-		for (int i = 0; i <= 6; i++)
+		for (int i = 0; i <= NUM_MANA_FILTERS - 1; i++)
 		{
 			CreateNewTab(m_singleManaFilterPrefab, i);
 		}
-		CreateNewTab(m_dynamicManaFilterPrefab, 7);
+		CreateNewTab(m_dynamicManaFilterPrefab, NUM_MANA_FILTERS);
 		m_manaCrystalContainer.UpdateSlices();
 	}
 
@@ -204,7 +206,7 @@ public class ManaFilterTabManager : MonoBehaviour
 		if (m_tabsActive)
 		{
 			ManaFilterTab manaFilterTab = (ManaFilterTab)e.GetElement();
-			if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_CLICKED_MANA_TAB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("ManaFilterTabManager.OnTabPressed:" + Option.HAS_CLICKED_MANA_TAB))
+			if (!UniversalInputManager.UsePhoneUI && !Options.Get().GetBool(Option.HAS_CLICKED_MANA_TAB, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "ManaFilterTabManager.OnTabPressed:" + Option.HAS_CLICKED_MANA_TAB))
 			{
 				Options.Get().SetBool(Option.HAS_CLICKED_MANA_TAB, val: true);
 				ShowManaTabHint(manaFilterTab);
@@ -255,7 +257,7 @@ public class ManaFilterTabManager : MonoBehaviour
 			if (num == 0)
 			{
 				goto IL_0047;
-			}
+		}
 		}
 		else
 		{
@@ -305,6 +307,9 @@ public class ManaFilterTabManager : MonoBehaviour
 
 	private void ShowManaTabHint(ManaFilterTab tabButton)
 	{
+		// Visual notif
+		return;
+
 		Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, tabButton.transform.position + new Vector3(0f, 0f, 7f), TutorialEntity.GetTextScale(), GameStrings.Get("GLUE_COLLECTION_MANAGER_MANA_TAB_FIRST_CLICK"));
 		if (!(notification == null))
 		{
diff --git a/Assembly-CSharp/MassDisenchant.cs b/Assembly-CSharp/MassDisenchant.cs
index 296215a..98b1807 100644
--- a/Assembly-CSharp/MassDisenchant.cs
+++ b/Assembly-CSharp/MassDisenchant.cs
@@ -4,8 +4,9 @@ using System.Collections.Generic;
 using Blizzard.T5.MaterialService.Extensions;
 using Blizzard.T5.Services;
 using UnityEngine;
+using Accessibility;
 
-public class MassDisenchant : MonoBehaviour
+public class MassDisenchant : MonoBehaviour, AccessibleUI
 {
 	public GameObject m_root;
 
@@ -120,10 +121,12 @@ public class MassDisenchant : MonoBehaviour
 	public void Show()
 	{
 		m_root.SetActive(value: true);
+		ReadScreen();
 	}
 
 	public void Hide()
 	{
+		HideThis();
 		m_root.SetActive(value: false);
 		BlockCurrencyFrame(block: false);
 	}
@@ -135,6 +138,7 @@ public class MassDisenchant : MonoBehaviour
 
 	private void OnDestroy()
 	{
+		HideThis();
 		foreach (GameObject cleanupObject in m_cleanupObjects)
 		{
 			if (cleanupObject != null)
@@ -337,6 +341,9 @@ public class MassDisenchant : MonoBehaviour
 
 	private IEnumerator DoDisenchantAnims(int maxGlowBalls, int disenchantTotal)
 	{
+		AccessibleCollectionManager.Get().OnMassDisenchantAnimStarted();
+		m_isPlayingAnim = true;
+
 		if (disenchantTotal == 0)
 		{
 			yield return null;
@@ -510,6 +517,9 @@ public class MassDisenchant : MonoBehaviour
 			material2.SetFloat("_XSpeed", origXSpeed);
 			item5.m_amountBar.GetComponent<Renderer>().GetMaterial().SetFloat("_Intensity", origInten);
 		}
+
+		m_isPlayingAnim = false;
+		AccessibleCollectionManager.Get().OnMassDisenchantAnimDone();
 	}
 
 	private void SetDustBalanceVisual(float bal)
@@ -762,4 +772,64 @@ public class MassDisenchant : MonoBehaviour
 		}
 		return raritySound;
 	}
+
+	#region Accessibility
+
+	private bool m_isPlayingAnim;
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadScreen()
+	{
+		if (AccessibilityMgr.IsCurrentlyFocused(this))
+		{
+			// Show triggers again after disenchanting for some reason
+			return;
+		}
+
+		m_isPlayingAnim = false;
+
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleMenu = new AccessibleMenu(this, m_headlineText.Text, CancelMassDisenchant);
+		m_accessibleMenu.AddOption(LocalizationUtils.Format(LocalizationKey.SCREEN_COLLECTION_MANAGER_CRAFTING_MASS_DISENCHANT_FOR_N_DUST, m_totalCardsToDisenchant, m_totalAmount), ConfirmMassDisenchant);
+		m_accessibleMenu.AddOption(GameStrings.Get("GLOBAL_CANCEL"), CancelMassDisenchant);
+
+		m_accessibleMenu.StartReading();
+	}
+
+	private void ConfirmMassDisenchant()
+	{
+		m_disenchantButton.TriggerRelease();
+	}
+
+	private void CancelMassDisenchant()
+	{
+		CraftingTray.Get().m_massDisenchantButton.TriggerRelease();
+	}
+
+	internal void HideThis()
+	{
+		AccessibilityMgr.HideUI(this);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (!m_isPlayingAnim)
+		{
+			m_accessibleMenu?.HandleAccessibleInput();
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_isPlayingAnim)
+		{
+			return "";
+		}
+
+		return m_accessibleMenu?.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/MassPackOpeningHighlights.cs b/Assembly-CSharp/MassPackOpeningHighlights.cs
index 3f18192..3958573 100644
--- a/Assembly-CSharp/MassPackOpeningHighlights.cs
+++ b/Assembly-CSharp/MassPackOpeningHighlights.cs
@@ -53,7 +53,7 @@ public class MassPackOpeningHighlights : MonoBehaviour
 	private GameObject m_banner;
 
 	[SerializeField]
-	private UberText m_numPacksOpened;
+	internal UberText m_numPacksOpened;
 
 	[SerializeField]
 	private PlayMakerFSM m_explosionAnimationPlayMakerOver25;
diff --git a/Assembly-CSharp/MassPackOpeningSummary.cs b/Assembly-CSharp/MassPackOpeningSummary.cs
index 03c4fda..4ced0b1 100644
--- a/Assembly-CSharp/MassPackOpeningSummary.cs
+++ b/Assembly-CSharp/MassPackOpeningSummary.cs
@@ -1,11 +1,12 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
 
-public class MassPackOpeningSummary : MonoBehaviour
+public class MassPackOpeningSummary : MonoBehaviour, AccessibleUI
 {
 	private enum CLASS
 	{
@@ -421,4 +422,61 @@ public class MassPackOpeningSummary : MonoBehaviour
 			_ => "INVALID", 
 		};
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleMultilineText> m_accessibleEntries;
+
+	public void ReadSummary()
+	{
+		AccessibilityMgr.ShowUI(this);
+		m_accessibleEntries = new AccessibleListOfItems<AccessibleMultilineText>(this, new List<AccessibleMultilineText>(4));
+
+		if (m_dataModel.NumLegendariesOpened > 0 && m_dataModel.NumLegendariesOpened <= LEGENDARY_FALLBACK_THRESHOLD)
+		{
+			m_accessibleEntries.Items.Add(new AccessibleMultilineText(this, LocalizationUtils.Format(LocalizationKey.MASS_PACK_OPENING_SUMMARY_LEGENDARY_COUNT, m_dataModel.LegendariesOpened.Count), AccessibleSpeechUtils.HumanizeList(m_dataModel.LegendariesOpened.Select((card) => card.Name).ToList())));
+		}
+		else
+		{
+			AddEntryIfNeeded(m_dataModel.LegendariesOpenedFallback, LocalizationKey.MASS_PACK_OPENING_SUMMARY_LEGENDARY_COUNT);
+	}
+
+	AddEntryIfNeeded(m_dataModel.EpicsOpened, LocalizationKey.MASS_PACK_OPENING_SUMMARY_EPIC_COUNT);
+	AddEntryIfNeeded(m_dataModel.RaresOpened, LocalizationKey.MASS_PACK_OPENING_SUMMARY_RARE_COUNT);
+	AddEntryIfNeeded(m_dataModel.CommonsOpened, LocalizationKey.MASS_PACK_OPENING_SUMMARY_COMMON_COUNT);
+
+	AccessibilityMgr.Output(this, GameStrings.Get("GLUE_MASS_PACK_OPEN_SUMMARY"));
+	m_accessibleEntries.StartReading();
+	}
+
+	private void AddEntryIfNeeded(DataModelList<ClassCardCountDataModel> cardCounts, LocalizationKey key)
+	{
+		if (cardCounts.Count == 0)
+		{
+			return;
+		}
+
+		var totalCount = cardCounts.Select((cc) => cc.CardCount).Sum();
+
+		string header = LocalizationUtils.Format(key, totalCount);
+		var body = cardCounts.Select((cc) => LocalizationUtils.Format(LocalizationKey.MASS_PACK_OPENING_SUMMARY_CLASS_COUNT, cc.CardCount, cc.ClassName)).ToList();
+		m_accessibleEntries.Items.Add(new AccessibleMultilineText(this, header, AccessibleSpeechUtils.HumanizeList(body)));
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (AccessibleKey.CONFIRM.IsPressed())
+		{
+			PressDoneButton();
+		}
+		else
+		{
+			m_accessibleEntries.HandleAccessibleInput();
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		return LocalizationUtils.Format(LocalizationKey.MASS_PACK_OPENING_SUMMARY_HELP, AccessibleKey.CONFIRM);
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/MatchingPopupDisplay.cs b/Assembly-CSharp/MatchingPopupDisplay.cs
index aea4b6a..6815ca0 100644
--- a/Assembly-CSharp/MatchingPopupDisplay.cs
+++ b/Assembly-CSharp/MatchingPopupDisplay.cs
@@ -4,8 +4,9 @@ using Blizzard.T5.Core.Utils;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class MatchingPopupDisplay : TransitionPopup
+public class MatchingPopupDisplay : TransitionPopup, AccessibleUI
 {
 	public UberText m_tipOfTheDay;
 
@@ -44,6 +45,8 @@ public class MatchingPopupDisplay : TransitionPopup
 		{
 			Navigation.RemoveHandler(OnNavigateBack);
 			base.Hide();
+
+			AccessibilityMgr.HideUI(this);
 		}
 	}
 
@@ -53,6 +56,9 @@ public class MatchingPopupDisplay : TransitionPopup
 		UpdateTipOfTheDay();
 		GenerateRandomSpinnerTexts(IsMultiOpponentGame());
 		m_title.Text = GetTitleTextBasedOnScenario();
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, m_title.Text, true);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
 		base.Show();
 	}
 
@@ -315,4 +321,63 @@ public class MatchingPopupDisplay : TransitionPopup
 		}
 		return record.Players > 2;
 	}
+
+	#region
+
+	public void HandleAccessibleInput()
+	{
+		if (AccessibleKey.BACK.IsPressed())
+		{
+			HandleCancelButtonInput();
+		}
+		else if (AccessibleKey.SPACE.IsPressed() && m_queueTab != null && m_queueTab.isActiveAndEnabled)
+		{
+			var lines = new List<string>();
+			if (m_queueTab.m_waitTime.isActiveAndEnabled && !m_queueTab.m_waitTime.isHidden())
+			{
+				lines.Add($"{LocalizationUtils.Format(LocalizationKey.GLOBAL_GAME_QUEUE_WAIT_TIME)}: {m_queueTab.m_waitTime.Text}");
+			}
+
+			if (m_queueTab.m_waitTime.isActiveAndEnabled && !m_queueTab.m_queueTime.isHidden())
+			{
+				lines.Add($"{LocalizationUtils.Format(LocalizationKey.GLOBAL_GAME_QUEUE_TIME_IN_QUEUE)}: {m_queueTab.m_queueTime.Text}");
+			}
+
+			if (lines.Count != 0)
+			{
+				AccessibilityMgr.Output(this, AccessibleSpeechUtils.CombineLines(lines));
+			}
+
+		}
+
+	}
+
+	public string GetAccessibleHelp()
+	{
+		var lines = new List<string>();
+		lines.Add(m_title.Text);
+
+		bool shouldShowPleaseWait = true;
+
+		if (m_cancelButton != null && m_cancelButton.isActiveAndEnabled)
+		{
+			lines.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_CANCEL_HELP, AccessibleKey.BACK));
+			shouldShowPleaseWait = false;
+		}
+
+		if (m_queueTab != null && m_queueTab.isActiveAndEnabled)
+		{
+			lines.Add(LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_READ_DETAILS, AccessibleKey.SPACE));
+			shouldShowPleaseWait = false;
+		}
+
+		if (shouldShowPleaseWait)
+		{
+			lines.Add(LocalizedText.GLOBAL_PLEASE_WAIT);
+		}
+
+		return AccessibleSpeechUtils.CombineLines(lines);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/MercenariesKnockoutRewardData.cs b/Assembly-CSharp/MercenariesKnockoutRewardData.cs
index f828aa7..453ec8f 100644
--- a/Assembly-CSharp/MercenariesKnockoutRewardData.cs
+++ b/Assembly-CSharp/MercenariesKnockoutRewardData.cs
@@ -4,21 +4,11 @@ using Hearthstone.DataModels;
 
 public class MercenariesKnockoutRewardData : RewardData
 {
-	[CompilerGenerated]
-	private Action <OnDestroyReward>k__BackingField;
-
 	public RewardItemDataModel MercenaryDataModel { get; private set; }
 
 	public RewardItemDataModel KnockoutDataModel { get; private set; }
 
-	private Action OnDestroyReward
-	{
-		[CompilerGenerated]
-		set
-		{
-			<OnDestroyReward>k__BackingField = value;
-		}
-	}
+	private Action OnDestroyReward { get; set; }
 
 	public MercenariesKnockoutRewardData(RewardItemDataModel mercenaryDataModel, RewardItemDataModel knockoutDataModel, Action onDestroyReward = null)
 		: base(Reward.Type.MERCENARY_KNOCKOUT, showQuestToast: true)
diff --git a/Assembly-CSharp/MercenariesSeasonRewardsDialog.cs b/Assembly-CSharp/MercenariesSeasonRewardsDialog.cs
index e35e38c..07fea15 100644
--- a/Assembly-CSharp/MercenariesSeasonRewardsDialog.cs
+++ b/Assembly-CSharp/MercenariesSeasonRewardsDialog.cs
@@ -5,8 +5,9 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using UnityEngine;
+using Accessibility;
 
-public class MercenariesSeasonRewardsDialog : DialogBase
+public class MercenariesSeasonRewardsDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
diff --git a/Assembly-CSharp/MercenariesZoneUnlockDialog.cs b/Assembly-CSharp/MercenariesZoneUnlockDialog.cs
index 1f88fa6..3836531 100644
--- a/Assembly-CSharp/MercenariesZoneUnlockDialog.cs
+++ b/Assembly-CSharp/MercenariesZoneUnlockDialog.cs
@@ -1,10 +1,11 @@
 using System;
 using System.Collections;
+using Accessibility;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
 
-public class MercenariesZoneUnlockDialog : DialogBase
+public class MercenariesZoneUnlockDialog : InaccessibleDialogBase
 {
 	public class Info
 	{
@@ -99,4 +100,15 @@ public class MercenariesZoneUnlockDialog : DialogBase
 	{
 		Hide();
 	}
+
+	#region Accessibility
+	public override void HandleAccessibleInput()
+	{
+		// Not really sure what this dialog is yet but might help someone
+		if (AccessibleKey.CONFIRM.IsPressed())
+		{
+			m_clickCatcher.TriggerRelease();
+		}
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/MercenaryDetailDisplay.cs b/Assembly-CSharp/MercenaryDetailDisplay.cs
index b0a66d1..9fc53a0 100644
--- a/Assembly-CSharp/MercenaryDetailDisplay.cs
+++ b/Assembly-CSharp/MercenaryDetailDisplay.cs
@@ -1021,7 +1021,7 @@ public class MercenaryDetailDisplay : MonoBehaviour
 			m_tutorialCoroutine = StartCoroutine(ShowUnlockMythicWhenReady());
 			return;
 		}
-		if (!Options.Get().GetBool(Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MercenaryDetailDisplay.ShowAppearanceTutorialIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL) && currentlyDisplayedMercenary != null && (long)currentlyDisplayedMercenary.ID == 18 && currentlyDisplayedMercenary.HasUnlockedGoldenOrBetter())
+		if (!Options.Get().GetBool(Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "MercenaryDetailDisplay.ShowAppearanceTutorialIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL) && currentlyDisplayedMercenary != null && (long)currentlyDisplayedMercenary.ID == 18 && currentlyDisplayedMercenary.HasUnlockedGoldenOrBetter())
 		{
 			HideHelpPopups();
 			m_helpPopupType = Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL;
@@ -1033,12 +1033,12 @@ public class MercenaryDetailDisplay : MonoBehaviour
 		{
 			LettuceTutorialUtils.FireEvent(LettuceTutorialVo.LettuceTutorialEvent.VILLAGE_TUTORIAL_UPGRADE_ABILITY_START, base.gameObject);
 		}
-		if (TutorialShouldShowAbilityUpgrade() && flag && UserAttentionManager.CanShowAttentionGrabber("MercenaryDetailDisplay.ShowEquipmentSlotTutorialIfNeeded:HAS_SEEN_ABILITY_UPGRADE"))
+		if (TutorialShouldShowAbilityUpgrade() && flag && UserAttentionManager.CanShowAttentionGrabber(false, "MercenaryDetailDisplay.ShowEquipmentSlotTutorialIfNeeded:HAS_SEEN_ABILITY_UPGRADE"))
 		{
 			HideHelpPopups();
 			m_tutorialCoroutine = StartCoroutine(ShowUpgradeAbilityTutorialWhenReady(currentlyDisplayedMercenary));
 		}
-		else if (!Options.Get().GetBool(Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MercenaryDetailDisplay.ShowEquipmentSlotTutorialIfNeeded:" + Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL))
+		else if (!Options.Get().GetBool(Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "MercenaryDetailDisplay.ShowEquipmentSlotTutorialIfNeeded:" + Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL))
 		{
 			HideHelpPopups();
 			m_helpPopupType = Option.HAS_SEEN_LOAD_EQUIPMENT_IN_SLOT_TUTORIAL;
@@ -1048,7 +1048,7 @@ public class MercenaryDetailDisplay : MonoBehaviour
 
 	protected void ShowAppearancePart2TutorialIfNeeded()
 	{
-		if (!Options.Get().GetBool(Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MercenaryDetailDisplay.ShowAppearanceTutorialIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL) && (long)GetCurrentlyDisplayedMercenary().ID == 18 && CollectionManager.Get().GetMercenary(18L).HasUnlockedGoldenOrBetter())
+		if (!Options.Get().GetBool(Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "MercenaryDetailDisplay.ShowAppearanceTutorialIfNeeded:" + Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL) && (long)GetCurrentlyDisplayedMercenary().ID == 18 && CollectionManager.Get().GetMercenary(18L).HasUnlockedGoldenOrBetter())
 		{
 			HideHelpPopups();
 			m_helpPopupType = Option.HAS_SEEN_MERC_APPEARANCE_TUTORIAL;
diff --git a/Assembly-CSharp/MiniSetProductPage.cs b/Assembly-CSharp/MiniSetProductPage.cs
index 4f2f76e..3adf8f2 100644
--- a/Assembly-CSharp/MiniSetProductPage.cs
+++ b/Assembly-CSharp/MiniSetProductPage.cs
@@ -5,6 +5,7 @@ using Blizzard.T5.AssetManager;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class MiniSetProductPage : ProductPage
 {
@@ -14,7 +15,7 @@ public class MiniSetProductPage : ProductPage
 
 	private Maskable m_maskable;
 
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
 		m_maskable = GetComponentInChildren<Maskable>();
 		m_maskable.enabled = false;
@@ -23,7 +24,7 @@ public class MiniSetProductPage : ProductPage
 			m_container.OverrideMusic(MusicPlaylistType.Invalid);
 		}
 		m_cardList = new ShopCardList(m_widget, m_scrollbar);
-		base.Open();
+		base.Open(true);
 		base.OnOpened += InitInput;
 	}
 
@@ -44,12 +45,12 @@ public class MiniSetProductPage : ProductPage
 	{
 		bool flag = chosenProduct.Tags.Contains("golden");
 		ProductDataModel result = chosenVariant;
-		foreach (ProductDataModel variant in chosenProduct.Variants)
-		{
+			foreach (ProductDataModel variant in chosenProduct.Variants)
+			{
 			bool flag2 = variant.Tags.Contains("golden");
 			variant.VariantName = (flag2 ? GameStrings.Get("GLUE_STORE_PREMIUM_VARIATION_NAME_GOLDEN") : GameStrings.Get("GLUE_STORE_PREMIUM_VARIATION_NAME_NORMAL"));
 			if (flag2 == flag)
-			{
+				{
 				result = variant;
 			}
 		}
@@ -118,4 +119,79 @@ public class MiniSetProductPage : ProductPage
 		product.FlavorText = GameStrings.FormatPlurals("GLUE_STORE_MINI_SET_CARD_COUNT", GameStrings.MakePlurals(num), num);
 		m_cardList.SetData(list, boosterId);
 	}
+
+	#region Accessibility
+
+	private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleCards;
+
+	protected override void SetupVariantMenuOptions()
+	{
+		var variant = m_productSelection.Variant;
+
+		m_readingVariantMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_ITEM_READ_DESCRIPTION), () => ReadVariantDescription(variant));
+		m_readingVariantMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_READ_CARDS), () => ReadCards());
+		SetupPriceMenuOptions(variant);
+	}
+
+	private void ReadCards()
+	{
+		var cardTiles = m_cardList.m_dataModel.CardTiles;
+
+		var accessibleCards = new List<AccessibleCollectibleCard>(cardTiles.Count);
+
+		foreach (var card in cardTiles)
+        {
+			var cardId = card.CardId;
+			var cardQty = card.Count;
+			var entityDef = DefLoader.Get().GetEntityDef(cardId);
+			var cardRecord = GameUtils.GetCardRecord(cardId);
+			var collectibleCard = new CollectibleCard(cardRecord, entityDef, TAG_PREMIUM.NORMAL);
+			collectibleCard.OwnedCount = cardQty;
+			var accessibleCollectibleCard = new AccessibleCollectibleCard(m_container, collectibleCard, true, true);
+
+			accessibleCards.Add(accessibleCollectibleCard);
+        }
+
+		m_accessibleCards = new AccessibleListOfItems<AccessibleCollectibleCard>(m_container, accessibleCards);
+		m_accessibleCards.StartReading();
+		m_curState = State.READING_CARDS;
+	}
+
+	public override void HandleAccessibleInput()
+	{
+		if (m_curState == State.READING_CARDS)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadVariantMenu();
+			}
+			else
+			{
+				var curTile = m_scrollbar.m_scrollableItems[m_accessibleCards.GetItemBeingReadIndex()];
+				if (m_accessibleCards.HandleAccessibleInput())
+				{
+					AccessibilityUtils.CenterScrollbarAroundObject(m_scrollbar, curTile.gameObject);
+				}
+				AccessibleInputMgr.MoveMouseTo(curTile);
+			}
+		}
+		else
+		{
+			base.HandleAccessibleInput();
+		}
+	}
+
+	public override string GetAccessibleHelp()
+	{
+		if (m_curState == State.READING_CARDS)
+		{
+			return LocalizationUtils.Get(LocalizationKey.UI_SHOP_READ_CARDS_HELP);
+		}
+		else
+		{
+			return base.GetAccessibleHelp();
+		}
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/MissionEntity.cs b/Assembly-CSharp/MissionEntity.cs
index daf5669..80fbc94 100644
--- a/Assembly-CSharp/MissionEntity.cs
+++ b/Assembly-CSharp/MissionEntity.cs
@@ -3,6 +3,7 @@ using System.Collections;
 using System.Collections.Generic;
 using Blizzard.T5.Core;
 using UnityEngine;
+using Accessibility;
 
 public class MissionEntity : GameEntity
 {
@@ -1155,6 +1156,111 @@ public class MissionEntity : GameEntity
 		return null;
 	}
 
+    #region Missions with Turn Counters
+
+	protected Notification m_turnCounter;
+
+	private string m_turnCounterText = ""; // Used for reading # of remaining turns when focusing on opponent's Hero
+
+	private bool m_isTurnCounterBasedMission = false; // Used to avoid race conditions after the counter is destroyed
+
+	// the key used by a particular mission to specify what should read in the banner.
+	// Not all "turn counter"-based missions are turns. e.g. Valeera 08 is "silent shadows left to defeat" but all componentry is reused
+	private string m_turnCounterKey;
+
+	// Not all of these are the same between missions but it's easier to keep them like this to force conflicts if Blizzard refactors any of this
+	private bool m_fsmRunningManVal;
+	private bool m_fsmMineCartVal;
+	private bool m_fsmAirshipVal;
+	private bool m_fsmDestroyerVal;
+
+    protected virtual void InitTurnCounterVisuals(string turnCounterKey, bool fsmRunningManVal, bool fsmMineCartVal, bool fsmAirshipVal, bool fsmDestroyerVal)
+	{
+		m_turnCounterKey = turnCounterKey;
+		m_fsmRunningManVal = fsmRunningManVal;
+		m_fsmMineCartVal = fsmMineCartVal;
+		m_fsmAirshipVal = fsmAirshipVal;
+		m_fsmDestroyerVal = fsmDestroyerVal;
+
+		m_isTurnCounterBasedMission = true;
+		int cost = GetCost();
+		InitTurnCounter(cost);
+	}
+
+	private void InitTurnCounter(int cost)
+	{
+		GameObject gameObject = AssetLoader.Get().InstantiatePrefab("LOE_Turn_Timer.prefab:b05530aa55868554fb8f0c66632b3c22");
+		m_turnCounter = gameObject.GetComponent<Notification>();
+		PlayMakerFSM component = m_turnCounter.GetComponent<PlayMakerFSM>();
+		component.FsmVariables.GetFsmBool("RunningMan").Value = m_fsmRunningManVal;
+		component.FsmVariables.GetFsmBool("MineCart").Value = m_fsmMineCartVal;
+		component.FsmVariables.GetFsmBool("Airship").Value = m_fsmAirshipVal;
+		component.FsmVariables.GetFsmBool("Destroyer").Value = m_fsmDestroyerVal;
+		component.SendEvent("Birth");
+		Actor actor = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
+			.GetActor();
+		m_turnCounter.transform.parent = actor.gameObject.transform;
+		m_turnCounter.transform.localPosition = new Vector3(-1.4f, 0.187f, -0.11f);
+		m_turnCounter.transform.localScale = Vector3.one * 0.52f;
+		UpdateTurnCounterText(cost);
+	}
+
+	protected virtual void UpdateTurnCounterVisualsIfNeeded(TagDelta change)
+    {
+		GAME_TAG tag = (GAME_TAG)change.tag;
+		if (tag == GAME_TAG.COST && change.newValue != change.oldValue)
+		{
+			UpdateTurnCounterVisuals(change.newValue);
+		}
+    }
+
+	private void UpdateTurnCounterVisuals(int cost)
+	{
+		UpdateTurnCounter(cost);
+	}
+
+	private void UpdateTurnCounter(int cost)
+	{
+		m_turnCounter.GetComponent<PlayMakerFSM>().SendEvent("Action");
+		if (cost <= 0)
+		{
+			UnityEngine.Object.Destroy(m_turnCounter.gameObject);
+		}
+		else
+		{
+			UpdateTurnCounterText(cost);
+		}
+	}
+
+	private void UpdateTurnCounterText(int cost)
+	{
+		GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
+		{
+			new GameStrings.PluralNumber
+			{
+				m_index = 0,
+				m_number = cost
+			}
+		};
+		string headlineString = GameStrings.FormatPlurals(m_turnCounterKey, pluralNumbers);
+		string costString = cost.ToString();
+		m_turnCounter.ChangeDialogText(headlineString, costString, "", "");
+		m_turnCounterText = $"{costString} {headlineString}";
+		AccessibilityMgr.Output(AccessibleGameplay.Get(), m_turnCounterText);
+	}
+
+	public string GetTurnCounterText()
+    {
+		return m_turnCounterText;
+    }
+
+    public override bool IsTurnCounterBasedMission()
+    {
+		return m_isTurnCounterBasedMission;
+    }
+
+    #endregion
+
 	protected IEnumerator HideRuneTrayAndLoanerBanner(int linkedID)
 	{
 		yield return new WaitForEndOfFrame();
diff --git a/Assembly-CSharp/MobileChatLogMessageFrame.cs b/Assembly-CSharp/MobileChatLogMessageFrame.cs
index 7a7a7de..a48fed1 100644
--- a/Assembly-CSharp/MobileChatLogMessageFrame.cs
+++ b/Assembly-CSharp/MobileChatLogMessageFrame.cs
@@ -96,15 +96,7 @@ public class MobileChatLogMessageFrame : MonoBehaviour, ITouchListItem
 		LocalBounds = localBounds;
 	}
 
-	[SpecialName]
-	GameObject ITouchListItem.get_gameObject()
-	{
-		return base.gameObject;
-	}
 
-	[SpecialName]
-	Transform ITouchListItem.get_transform()
-	{
-		return base.transform;
-	}
+
+
 }
diff --git a/Assembly-CSharp/MobileFriendListItem.cs b/Assembly-CSharp/MobileFriendListItem.cs
index 2666419..5f83a2f 100644
--- a/Assembly-CSharp/MobileFriendListItem.cs
+++ b/Assembly-CSharp/MobileFriendListItem.cs
@@ -136,15 +136,7 @@ public class MobileFriendListItem : MonoBehaviour, ISelectableTouchListItem, ITo
 	{
 	}
 
-	[SpecialName]
-	GameObject ITouchListItem.get_gameObject()
-	{
-		return base.gameObject;
-	}
 
-	[SpecialName]
-	Transform ITouchListItem.get_transform()
-	{
-		return base.transform;
-	}
+
+
 }
diff --git a/Assembly-CSharp/MountRewardData.cs b/Assembly-CSharp/MountRewardData.cs
index 912c7bd..e068a7a 100644
--- a/Assembly-CSharp/MountRewardData.cs
+++ b/Assembly-CSharp/MountRewardData.cs
@@ -6,7 +6,8 @@ public class MountRewardData : RewardData
 		WOW_HEARTHSTEED,
 		HEROES_MAGIC_CARPET_CARD,
 		WOW_SARGE_TALE,
-		TEN_YEAR_MOUNT
+		TEN_YEAR_MOUNT,
+		EOE
 	}
 
 	public MountType Mount { get; set; }
diff --git a/Assembly-CSharp/MulliganManager.cs b/Assembly-CSharp/MulliganManager.cs
index e507d5a..689f6bb 100644
--- a/Assembly-CSharp/MulliganManager.cs
+++ b/Assembly-CSharp/MulliganManager.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Assets;
 using Blizzard.T5.Core;
 using Blizzard.T5.Core.Time;
@@ -110,7 +111,7 @@ public class MulliganManager : MonoBehaviour
 
 	private bool mulliganActive;
 
-	private MulliganTimer m_mulliganTimer;
+	internal MulliganTimer m_mulliganTimer;
 
 	private NormalButton mulliganButton;
 
@@ -1372,11 +1373,11 @@ public class MulliganManager : MonoBehaviour
 		{
 			mulliganChooseBanner = UnityEngine.Object.Instantiate(GetChooseBannerPrefab(), Board.Get().FindBone("ChoiceBanner").position, new Quaternion(0f, 0f, 0f, 0f));
 		}
-		string mulliganBannerText = GameState.Get().GetGameEntity().GetMulliganBannerText();
-		string mulliganBannerSubtitleText = GameState.Get().GetGameEntity().GetMulliganBannerSubtitleText();
-		SetMulliganBannerText(mulliganBannerText, mulliganBannerSubtitleText);
-		ShowMulliganDetail();
-	}
+			string mulliganBannerText = GameState.Get().GetGameEntity().GetMulliganBannerText();
+			string mulliganBannerSubtitleText = GameState.Get().GetGameEntity().GetMulliganBannerSubtitleText();
+			SetMulliganBannerText(mulliganBannerText, mulliganBannerSubtitleText);
+			ShowMulliganDetail();
+		}
 
 	private void CreateBannerShrinking()
 	{
@@ -1787,13 +1788,25 @@ public class MulliganManager : MonoBehaviour
 			mulliganCancelConfirmationButtonWidget.AddEventListener(UIEventType.RELEASE, OnMulliganCancelConfirmationButtonReleased);
 			m_WaitAFrameBeforeSendingEventToMulliganButton = WaitAFrameBeforeSendingEventToMulliganButton(mulliganButton);
 			StartCoroutine(m_WaitAFrameBeforeSendingEventToMulliganButton);
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
 			{
-				innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
 				Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, val: true);
 				mulliganButton.GetComponent<Collider>().enabled = false;
-			}
-		}
+
+        if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+          yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME);
+          yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B);
+          yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C);
+          yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D);
+          yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E);
+        }
+        else
+        {
+          innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
+        }
+      }
+    }
 		if (GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE))
 		{
 			while (m_refreshButton == null)
@@ -1822,6 +1835,11 @@ public class MulliganManager : MonoBehaviour
 		{
 			BeginDealNewCards();
 		}
+		else
+		{
+			GameEntity gameEntity = GameState.Get().GetGameEntity();
+			AccessibleGameplay.Get().OnEnterMultiplayerWaitingArea(m_startingCards, gameEntity.GetMulliganBannerText(), gameEntity.GetMulliganBannerSubtitleText(), mulliganButton);
+		}
 	}
 
 	private IEnumerator DealStartingCards()
@@ -1845,7 +1863,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterIntroBeforeMulligan());
 		if (GameState.Get().GetBooleanGameOption(GameEntityOption.DO_OPENING_TAUNTS) && !Cheats.Get().ShouldSkipMulligan())
 		{
-			m_PlayStartingTaunts = PlayStartingTaunts();
+            m_PlayStartingTaunts = PlayStartingTaunts();
 			StartCoroutine(m_PlayStartingTaunts);
 		}
 		Player friendlySidePlayer = GameState.Get().GetFriendlySidePlayer();
@@ -1853,11 +1871,11 @@ public class MulliganManager : MonoBehaviour
 		GetStartingLists();
 		if (m_startingCards.Count == 0)
 		{
-			SkipCardChoosing();
+            SkipCardChoosing();
 		}
 		foreach (Card startingCard in m_startingCards)
 		{
-			startingCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
+            startingCard.GetActor().SetActorState(ActorStateType.CARD_IDLE);
 			startingCard.GetActor().TurnOffCollider();
 			startingCard.GetActor().GetMeshRenderer().gameObject.layer = 8;
 			startingCard.GetActor().m_nameTextMesh.UpdateNow();
@@ -1876,15 +1894,15 @@ public class MulliganManager : MonoBehaviour
 		int numCardsToDealExcludingBonusCard = m_startingCards.Count;
 		if (!friendlyPlayerGoesFirst)
 		{
-			numCardsToDealExcludingBonusCard = m_bonusCardIndex;
+            numCardsToDealExcludingBonusCard = m_bonusCardIndex;
 			spacingToUse = spaceForEachCard;
 		}
 		else if (m_startingOppCards.Count > 0)
 		{
-			m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: true);
+            m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: true);
 			if (m_coinCardIndex >= 0)
 			{
-				m_startingOppCards[m_coinCardIndex].SetDoNotSort(on: true);
+                m_startingOppCards[m_coinCardIndex].SetDoNotSort(on: true);
 			}
 		}
 		opposingSideHandZone.SetDoNotUpdateLayout(enable: false);
@@ -1901,6 +1919,7 @@ public class MulliganManager : MonoBehaviour
 		}
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeDealingBaseMulliganCards());
 		float xOffset2 = spacingToUse / 2f;
+		AccessibleGameplay.Get().OnStartingHand(m_startingCards);
 		for (int i = 0; i < numCardsToDealExcludingBonusCard; i++)
 		{
 			GameObject topCard2 = m_startingCards[i].gameObject;
@@ -1937,11 +1956,12 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeCoinFlip());
 		if (coinObject != null)
 		{
-			Transform transform = Board.Get().FindBone("MulliganCoinPosition");
+            Transform transform = Board.Get().FindBone("MulliganCoinPosition");
 			coinObject.transform.position = transform.position;
 			coinObject.transform.localEulerAngles = transform.localEulerAngles;
 			coinObject.SetActive(value: true);
 			coinObject.GetComponent<CoinEffect>().DoAnim(friendlyPlayerGoesFirst);
+			AccessibleGameplay.Get().OnCoinResult(friendlyPlayerGoesFirst);
 			SoundManager.Get().LoadAndPlay("FX_MulliganCoin03_CoinFlip.prefab:07015cb3f02713a45aa03fc3aa798778", coinObject);
 			coinLocation = transform.position;
 			AssetLoader.Get().InstantiatePrefab("MulliganResultText.prefab:0369b435afd2e344db21e58648f8636c", CoinTossTextCallback, null, AssetLoadingOptions.IgnorePrefabPosition);
@@ -1973,7 +1993,7 @@ public class MulliganManager : MonoBehaviour
 		}
 		else if (m_startingOppCards.Count > 0)
 		{
-			m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: false);
+            m_startingOppCards[m_bonusCardIndex].SetDoNotSort(on: false);
 			opposingSideHandZone.UpdateLayout(null, forced: true, 4);
 		}
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterDealingBonusCard());
@@ -1985,7 +2005,7 @@ public class MulliganManager : MonoBehaviour
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsBeforeSpreadingMulliganCards());
 		if (friendlyPlayerGoesFirst)
 		{
-			xOffset2 = 0f;
+            xOffset2 = 0f;
 			for (int num3 = m_startingCards.Count - 1; num3 >= 0; num3--)
 			{
 				GameObject target = m_startingCards[num3].gameObject;
@@ -1999,22 +2019,23 @@ public class MulliganManager : MonoBehaviour
 			}
 		}
 		GameState.Get().GetGameEntity().OnMulliganCardsDealt(m_startingCards);
+		AccessibleGameplay.Get().OnMulliganCardsDealt(m_startingCards);
 		yield return new WaitForSeconds(0.6f);
 		yield return StartCoroutine(GameState.Get().GetGameEntity().DoActionsAfterSpreadingMulliganCards());
 		if (skipCardChoosing)
 		{
-			if (GameState.Get().IsMulliganPhase())
+            if (GameState.Get().IsMulliganPhase())
 			{
-				if (GameState.Get().IsFriendlySidePlayerTurn())
+                if (GameState.Get().IsFriendlySidePlayerTurn())
 				{
-					TurnStartManager.Get().BeginListeningForTurnEvents();
+                    TurnStartManager.Get().BeginListeningForTurnEvents();
 				}
 				m_WaitForOpponentToFinishMulligan = WaitForOpponentToFinishMulligan();
 				StartCoroutine(m_WaitForOpponentToFinishMulligan);
 			}
 			else
 			{
-				yield return new WaitForSeconds(2f);
+                yield return new WaitForSeconds(2f);
 				EndMulligan();
 			}
 			yield break;
@@ -2049,12 +2070,26 @@ public class MulliganManager : MonoBehaviour
 			mulliganCancelConfirmationButtonWidget.AddEventListener(UIEventType.RELEASE, OnMulliganCancelConfirmationButtonReleased);
 			m_WaitAFrameBeforeSendingEventToMulliganButton = WaitAFrameBeforeSendingEventToMulliganButton(mulliganButton);
 			StartCoroutine(m_WaitAFrameBeforeSendingEventToMulliganButton);
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_MULLIGAN, defaultVal: false) && !GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.DealStartingCards:" + Option.HAS_SEEN_MULLIGAN))
 			{
-				innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
 				Options.Get().SetBool(Option.HAS_SEEN_MULLIGAN, val: true);
 				mulliganButton.GetComponent<Collider>().enabled = false;
-			}
+
+				if (AccessibilityMgr.IsAccessibilityEnabled())
+				{
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_B);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_C);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_D);
+					yield return AccessibilityMgr.Narrate(AccessibleSpeech.IN_GAME_TUTORIAL_MULLIGAN_FIRST_TIME_E);
+				}
+				else
+                {
+                    innkeeperMulliganDialog = NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_MULLIGAN_13"), "VO_INNKEEPER_MULLIGAN_13.prefab:3ec6b2e741ac16d4ca519bdfd26d10e3");
+                }
+            }
+
+			AccessibleGameplay.Get().OnMulliganChoiceStart(m_startingCards, mulliganButton);
 		}
 		if (GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE))
 		{
@@ -2288,14 +2323,14 @@ public class MulliganManager : MonoBehaviour
 			}
 			if (flag != m_handCardsMarkedForReplace[startingCardsIndex])
 			{
-				if (!m_handCardsMarkedForReplace[startingCardsIndex])
-				{
-					SoundManager.Get().LoadAndPlay("GM_ChatWarning.prefab:41baa28576a71664eabd8712a198b67f");
-				}
-				else
-				{
-					SoundManager.Get().LoadAndPlay("HeroDropItem1.prefab:587232e6704b20942af1205d00cfc0f9");
-				}
+			if (!m_handCardsMarkedForReplace[startingCardsIndex])
+			{
+				SoundManager.Get().LoadAndPlay("GM_ChatWarning.prefab:41baa28576a71664eabd8712a198b67f");
+			}
+			else
+			{
+				SoundManager.Get().LoadAndPlay("HeroDropItem1.prefab:587232e6704b20942af1205d00cfc0f9");
+			}
 			}
 			if (GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_USES_ALTERNATE_ACTORS))
 			{
@@ -2597,8 +2632,8 @@ public class MulliganManager : MonoBehaviour
 		if (GameState.Get().GetBooleanGameOption(GameEntityOption.MULLIGAN_IS_CHOOSE_ONE))
 		{
 			Network.Get().SendMulliganChooseOneTentativeSelect(entityId, isConfirmation: false);
-			mulliganButtonWidget.gameObject.SetActive(value: true);
-		}
+				mulliganButtonWidget.gameObject.SetActive(value: true);
+			}
 		else
 		{
 			if (mulliganButton != null)
@@ -2618,11 +2653,11 @@ public class MulliganManager : MonoBehaviour
 		{
 			return;
 		}
-		foreach (Actor item in list)
-		{
-			GameState.Get().GetGameEntity().ToggleAlternateMulliganActorHighlight(item, false);
+			foreach (Actor item in list)
+			{
+				GameState.Get().GetGameEntity().ToggleAlternateMulliganActorHighlight(item, false);
+			}
 		}
-	}
 
 	public void ServerHasDealtReplacementCards(bool isFriendlySide)
 	{
@@ -2662,7 +2697,7 @@ public class MulliganManager : MonoBehaviour
 			}
 			if (destroyTimer)
 			{
-				DestroyMulliganTimer();
+			DestroyMulliganTimer();
 			}
 			BeginDealNewCards();
 		}
@@ -2685,7 +2720,7 @@ public class MulliganManager : MonoBehaviour
 		return result;
 	}
 
-	private void OnMulliganButtonReleased(UIEvent e)
+	internal void OnMulliganButtonReleased(UIEvent e)
 	{
 		if (!InputManager.Get().PermitDecisionMakingInput())
 		{
@@ -2700,16 +2735,16 @@ public class MulliganManager : MonoBehaviour
 				return;
 			}
 		}
-		if (mulliganButton != null)
-		{
-			mulliganButton.SetEnabled(enabled: false);
-		}
-		if (mulliganButtonWidget != null)
-		{
-			mulliganButtonWidget.SetEnabled(active: false);
+			if (mulliganButton != null)
+			{
+				mulliganButton.SetEnabled(enabled: false);
+			}
+			if (mulliganButtonWidget != null)
+			{
+				mulliganButtonWidget.SetEnabled(active: false);
+			}
+			BeginDealNewCards();
 		}
-		BeginDealNewCards();
-	}
 
 	private void OnMulliganCancelConfirmationButtonReleased(UIEvent e)
 	{
@@ -3058,10 +3093,12 @@ public class MulliganManager : MonoBehaviour
 
 	private IEnumerator WaitForOpponentToFinishMulligan()
 	{
+		AccessibleGameplay.Get().WaitingForOpponentToFinishMulligan();
+
 		if (!GameMgr.Get().IsBattlegrounds())
 		{
-			DestroyChooseBanner();
-			DestroyDetailLabel();
+		DestroyChooseBanner();
+		DestroyDetailLabel();
 		}
 		DestroyTagConditionalVFXs();
 		Vector3 position = Board.Get().FindBone("ChoiceBanner").position;
@@ -3087,9 +3124,9 @@ public class MulliganManager : MonoBehaviour
 		}
 		if (!GameMgr.Get().IsBattlegrounds())
 		{
-			mulliganChooseBanner = UnityEngine.Object.Instantiate(GetChooseBannerPrefab(), position2, new Quaternion(0f, 0f, 0f, 0f));
-			mulliganChooseBanner.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
-			iTween.ScaleTo(mulliganChooseBanner, scale, 0.4f);
+		mulliganChooseBanner = UnityEngine.Object.Instantiate(GetChooseBannerPrefab(), position2, new Quaternion(0f, 0f, 0f, 0f));
+		mulliganChooseBanner.transform.localScale = new Vector3(0.01f, 0.01f, 0.01f);
+		iTween.ScaleTo(mulliganChooseBanner, scale, 0.4f);
 		}
 		CreateTagConditionalVFXs(position2);
 		Actor yourHeroActor = null;
@@ -3419,8 +3456,8 @@ public class MulliganManager : MonoBehaviour
 			{
 				if (GameMgr.Get().IsBattlegrounds() && GetBaconAnomaly() != 0)
 				{
-					component.SetBaconAnomalyBannerText(title, subtitle, GetBaconAnomaly());
-				}
+				component.SetBaconAnomalyBannerText(title, subtitle, GetBaconAnomaly());
+			}
 				else
 				{
 					component.SetBaconBannerText(title, subtitle);
@@ -3428,14 +3465,14 @@ public class MulliganManager : MonoBehaviour
 			}
 		}
 		else if (subtitle != null)
-		{
-			mulliganChooseBanner.GetComponent<Banner>().SetText(title, subtitle);
-		}
-		else
-		{
-			mulliganChooseBanner.GetComponent<Banner>().SetText(title);
+			{
+				mulliganChooseBanner.GetComponent<Banner>().SetText(title, subtitle);
+			}
+			else
+			{
+				mulliganChooseBanner.GetComponent<Banner>().SetText(title);
+			}
 		}
-	}
 
 	private void SetMulliganDetailLabelText(string title)
 	{
@@ -3480,7 +3517,7 @@ public class MulliganManager : MonoBehaviour
 		return GetAnomalies().Count > 0;
 	}
 
-	private List<int> GetAnomalies()
+	internal static List<int> GetAnomalies()
 	{
 		List<int> list = new List<int>();
 		GameEntity gameEntity = GameState.Get().GetGameEntity();
@@ -3531,8 +3568,8 @@ public class MulliganManager : MonoBehaviour
 				GameEntity gameEntity = GameState.Get().GetGameEntity();
 				if (IsBaconAnomalyActive())
 				{
-					component.SetBaconAnomalyBannerText(gameEntity.GetMulliganBannerText(), gameEntity.GetMulliganDetailText(), GetBaconAnomaly());
-				}
+				component.SetBaconAnomalyBannerText(gameEntity.GetMulliganBannerText(), gameEntity.GetMulliganDetailText(), GetBaconAnomaly());
+			}
 				else
 				{
 					component.SetBaconBannerText(gameEntity.GetMulliganBannerText(), gameEntity.GetMulliganDetailText());
@@ -3541,8 +3578,8 @@ public class MulliganManager : MonoBehaviour
 			return;
 		}
 		string mulliganDetailText = GameState.Get().GetGameEntity().GetMulliganDetailText();
-		if (mulliganDetailText != null)
-		{
+			if (mulliganDetailText != null)
+			{
 			if (mulliganDetailLabel == null)
 			{
 				mulliganDetailLabel = UnityEngine.Object.Instantiate(mulliganDetailLabelPrefab);
@@ -3806,8 +3843,8 @@ public class MulliganManager : MonoBehaviour
 					GameState.Get().GetGameEntity().ToggleAlternateMulliganActorHighlight(card, highlighted: false);
 					GameState.Get().GetGameEntity().ToggleAlternateMulliganActorConfirmHighlight(card, highlighted: false);
 					if (actor is PlayerLeaderboardMainCardActor)
-					{
-						actor.ActivateSpellBirthState(SpellType.DEATH);
+				{
+					actor.ActivateSpellBirthState(SpellType.DEATH);
 					}
 				}
 			}
@@ -3886,6 +3923,7 @@ public class MulliganManager : MonoBehaviour
 
 	public void EndMulligan()
 	{
+		AccessibleGameplay.Get().EndMulligan();
 		m_waitingForUserInput = false;
 		if (m_replaceLabels != null)
 		{
@@ -4034,7 +4072,7 @@ public class MulliganManager : MonoBehaviour
 				coinObject.GetComponentInChildren<PlayMakerFSM>().SendEvent("Birth");
 				yield return new WaitForSeconds(0.1f);
 			}
-			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_THE_COIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("MulliganManager.HandleCoinCard:" + Option.HAS_SEEN_THE_COIN))
+			if (!GameMgr.Get().IsSpectator() && !Options.Get().GetBool(Option.HAS_SEEN_THE_COIN, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "MulliganManager.HandleCoinCard:" + Option.HAS_SEEN_THE_COIN))
 			{
 				NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, NotificationManager.DEPTH, 34.5f), GameStrings.Get("VO_INNKEEPER_COIN_INTRO"), "VO_INNKEEPER_COIN_INTRO.prefab:6fb1b3b124d474c4c84e392646caada4");
 				Options.Get().SetBool(Option.HAS_SEEN_THE_COIN, val: true);
@@ -4093,6 +4131,7 @@ public class MulliganManager : MonoBehaviour
 
 	private void CoinCardSummonFinishedCallback(Spell spell, object userData)
 	{
+		AccessibleGameplay.Get().OnCoinCard();
 		Card card = GameObjectUtils.FindComponentInParents<Card>(spell);
 		card.RefreshActor();
 		card.UpdateActorComponents();
diff --git a/Assembly-CSharp/MulliganTimer.cs b/Assembly-CSharp/MulliganTimer.cs
index e0c361b..e968c03 100644
--- a/Assembly-CSharp/MulliganTimer.cs
+++ b/Assembly-CSharp/MulliganTimer.cs
@@ -1,4 +1,5 @@
 using UnityEngine;
+using Accessibility;
 
 public class MulliganTimer : MonoBehaviour
 {
@@ -33,6 +34,7 @@ public class MulliganTimer : MonoBehaviour
 		{
 			num2 = 0;
 		}
+		UpdateAccessibleTimer(num2);
 		m_timeText.Text = $":{num2:D2}";
 		if (!(num > 0f))
 		{
@@ -77,4 +79,21 @@ public class MulliganTimer : MonoBehaviour
 	{
 		Object.Destroy(base.gameObject);
 	}
+
+	#region Accessibility
+
+	private int m_prevSeconds;
+
+	private void UpdateAccessibleTimer(int curSeconds)
+	{
+		AccessibilityUtils.OutputTimerIfNecessary(curSeconds, m_prevSeconds);
+
+		m_prevSeconds = curSeconds;
+	}
+
+	internal void OutputSecondsRemaining()
+	{
+		AccessibilityUtils.OutputSecondsRemaining(m_prevSeconds);
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/MultiPagePopup.cs b/Assembly-CSharp/MultiPagePopup.cs
index 92fa0b1..c568669 100644
--- a/Assembly-CSharp/MultiPagePopup.cs
+++ b/Assembly-CSharp/MultiPagePopup.cs
@@ -1,10 +1,11 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using Blizzard.T5.Core;
 using UnityEngine;
 
 [CustomEditClass]
-public class MultiPagePopup : DialogBase
+public class MultiPagePopup : InaccessibleDialogBase
 {
 	public enum PageType
 	{
@@ -27,6 +28,8 @@ public class MultiPagePopup : DialogBase
 		public List<int> m_cards;
 
 		public int m_dustAmount;
+
+		public PageInfo(bool markedForAccessibility) { } // This is not implemented as it was only being used in login dialog sequence, which is disabled
 	}
 
 	public class Info
@@ -36,6 +39,8 @@ public class MultiPagePopup : DialogBase
 		public bool m_blurWhenShown;
 
 		public List<PageInfo> m_pages = new List<PageInfo>();
+
+		public Info(bool markedForAccessibility) { } // This is not implemented as it was only being used in login dialog sequence, which is disabled
 	}
 
 	private readonly Map<PageType, string> m_pagePrefabRefs = new Map<PageType, string>
@@ -56,7 +61,7 @@ public class MultiPagePopup : DialogBase
 	[CustomEditField(Sections = "Sounds", T = EditType.SOUND_PREFAB)]
 	public string m_hideAnimationSound = "Shrink_Down_Quicker.prefab:2fe963b171811ca4b8d544fa53e3330c";
 
-	private Info m_info = new Info();
+	private Info m_info = new Info(true);
 
 	private int m_currentPageIdx;
 
@@ -64,6 +69,11 @@ public class MultiPagePopup : DialogBase
 
 	private int m_numPagesLoaded;
 
+	private MultiPagePopup()
+    {
+		// Protect against constructors due to accessibility and the fact that this has a dangling m_info (Info subclass)
+    }
+
 	protected override void OnDestroy()
 	{
 		base.OnDestroy();
diff --git a/Assembly-CSharp/MythicUpgradeDisplay.cs b/Assembly-CSharp/MythicUpgradeDisplay.cs
index 9f429b3..f0ce528 100644
--- a/Assembly-CSharp/MythicUpgradeDisplay.cs
+++ b/Assembly-CSharp/MythicUpgradeDisplay.cs
@@ -8,53 +8,14 @@ public class MythicUpgradeDisplay : MonoBehaviour
 {
 	protected class PendingRequest
 	{
-		[CompilerGenerated]
-		private int <UpgradeId>k__BackingField;
+		public int UpgradeId;
 
-		[CompilerGenerated]
-		private MERCENARY_MYTHIC_UPGRADE_TYPE <UpgradeType>k__BackingField;
+		public MERCENARY_MYTHIC_UPGRADE_TYPE UpgradeType;
 
-		[CompilerGenerated]
-		private long <MythicLevel>k__BackingField;
+		public long MythicLevel;
 
-		[CompilerGenerated]
-		private int <RequestedCount>k__BackingField;
+		public int RequestedCount;
 
-		public int UpgradeId
-		{
-			[CompilerGenerated]
-			set
-			{
-				<UpgradeId>k__BackingField = value;
-			}
-		}
-
-		public MERCENARY_MYTHIC_UPGRADE_TYPE UpgradeType
-		{
-			[CompilerGenerated]
-			set
-			{
-				<UpgradeType>k__BackingField = value;
-			}
-		}
-
-		public long MythicLevel
-		{
-			[CompilerGenerated]
-			set
-			{
-				<MythicLevel>k__BackingField = value;
-			}
-		}
-
-		public int RequestedCount
-		{
-			[CompilerGenerated]
-			set
-			{
-				<RequestedCount>k__BackingField = value;
-			}
-		}
 	}
 
 	[CustomEditField(Sections = "Widgets")]
diff --git a/Assembly-CSharp/NarrativeManager.cs b/Assembly-CSharp/NarrativeManager.cs
index 1000173..ab6241d 100644
--- a/Assembly-CSharp/NarrativeManager.cs
+++ b/Assembly-CSharp/NarrativeManager.cs
@@ -914,7 +914,7 @@ public class NarrativeManager : MonoBehaviour
 		{
 			return false;
 		}
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.SET_ROTATION_INTRO))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.SET_ROTATION_INTRO))
 		{
 			return false;
 		}
diff --git a/Assembly-CSharp/NetCache.cs b/Assembly-CSharp/NetCache.cs
index da08f09..ab1ab7c 100644
--- a/Assembly-CSharp/NetCache.cs
+++ b/Assembly-CSharp/NetCache.cs
@@ -19,6 +19,7 @@ using PegasusLettuce;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class NetCache : IService, IHasUpdate
 {
@@ -150,19 +151,9 @@ public class NetCache : IService, IHasUpdate
 
 		public class CacheCollection
 		{
-			[CompilerGenerated]
-			private bool <Crafting>k__BackingField;
-
 			public bool Manager { get; set; }
 
-			public bool Crafting
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Crafting>k__BackingField = value;
-				}
-			}
+			public bool Crafting { get; set; }
 
 			public bool DeckReordering { get; set; }
 
@@ -173,9 +164,6 @@ public class NetCache : IService, IHasUpdate
 
 		public class CacheStore
 		{
-			[CompilerGenerated]
-			private int <NumClassicPacksUntilDeprioritize>k__BackingField;
-
 			public bool Store { get; set; }
 
 			public bool BattlePay { get; set; }
@@ -188,14 +176,7 @@ public class NetCache : IService, IHasUpdate
 
 			public bool VirtualCurrencyEnabled { get; set; }
 
-			public int NumClassicPacksUntilDeprioritize
-			{
-				[CompilerGenerated]
-				set
-				{
-					<NumClassicPacksUntilDeprioritize>k__BackingField = value;
-				}
-			}
+			public int NumClassicPacksUntilDeprioritize;
 
 			public bool SimpleCheckoutIOS { get; set; }
 
@@ -222,101 +203,21 @@ public class NetCache : IService, IHasUpdate
 
 		public class CacheHeroes
 		{
-			[CompilerGenerated]
-			private bool <Hunter>k__BackingField;
-
-			[CompilerGenerated]
-			private bool <Mage>k__BackingField;
-
-			[CompilerGenerated]
-			private bool <Paladin>k__BackingField;
+			public bool Hunter { get; set; }
 
-			[CompilerGenerated]
-			private bool <Priest>k__BackingField;
+			public bool Mage { get; set; }
 
-			[CompilerGenerated]
-			private bool <Rogue>k__BackingField;
+			public bool Paladin { get; set; }
 
-			[CompilerGenerated]
-			private bool <Shaman>k__BackingField;
+			public bool Priest { get; set; }
 
-			[CompilerGenerated]
-			private bool <Warlock>k__BackingField;
+			public bool Rogue { get; set; }
 
-			[CompilerGenerated]
-			private bool <Warrior>k__BackingField;
+			public bool Shaman { get; set; }
 
-			public bool Hunter
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Hunter>k__BackingField = value;
-				}
-			}
-
-			public bool Mage
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Mage>k__BackingField = value;
-				}
-			}
+			public bool Warlock { get; set; }
 
-			public bool Paladin
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Paladin>k__BackingField = value;
-				}
-			}
-
-			public bool Priest
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Priest>k__BackingField = value;
-				}
-			}
-
-			public bool Rogue
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Rogue>k__BackingField = value;
-				}
-			}
-
-			public bool Shaman
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Shaman>k__BackingField = value;
-				}
-			}
-
-			public bool Warlock
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Warlock>k__BackingField = value;
-				}
-			}
-
-			public bool Warrior
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Warrior>k__BackingField = value;
-				}
-			}
+			public bool Warrior { get; set; }
 		}
 
 		public class CacheMercenaries
@@ -362,12 +263,6 @@ public class NetCache : IService, IHasUpdate
 
 		public bool SendTelemetryPresence;
 
-		[CompilerGenerated]
-		private float <SpecialEventTimingMod>k__BackingField;
-
-		[CompilerGenerated]
-		private int <BattlegroundsEarlyAccessLicense>k__BackingField;
-
 		public CacheMisc Misc { get; set; }
 
 		public CacheGames Games { get; set; }
@@ -386,14 +281,7 @@ public class NetCache : IService, IHasUpdate
 
 		public int MaxHeroLevel { get; set; }
 
-		public float SpecialEventTimingMod
-		{
-			[CompilerGenerated]
-			set
-			{
-				<SpecialEventTimingMod>k__BackingField = value;
-			}
-		}
+		public float SpecialEventTimingMod { get; set; }
 
 		public int FriendWeekConcederMaxDefense { get; set; }
 
@@ -415,14 +303,7 @@ public class NetCache : IService, IHasUpdate
 
 		public bool AllowOfflineClientDeckDeletion { get; set; }
 
-		public int BattlegroundsEarlyAccessLicense
-		{
-			[CompilerGenerated]
-			set
-			{
-				<BattlegroundsEarlyAccessLicense>k__BackingField = value;
-			}
-		}
+		public int BattlegroundsEarlyAccessLicense { get; set; }
 
 		public int BattlegroundsMaxRankedPartySize { get; set; }
 
@@ -514,9 +395,9 @@ public class NetCache : IService, IHasUpdate
 
 		public bool ShopButtonOnPackOpeningScreenEnabled { get; set; }
 
-		public bool MassPackOpeningEnabled { get; set; }
+		public bool MassPackOpeningEnabled {get; set;}
 
-		public int MassPackOpeningPackLimit { get; set; }
+		public int MassPackOpeningPackLimit {get; set;}
 
 		public int MassPackOpeningGoldenPackLimit { get; set; }
 
@@ -880,19 +761,9 @@ public class NetCache : IService, IHasUpdate
 
 	public class BoosterCard
 	{
-		[CompilerGenerated]
-		private long <Date>k__BackingField;
-
 		public CardDefinition Def { get; set; }
 
-		public long Date
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Date>k__BackingField = value;
-			}
-		}
+		public long Date { get; set; }
 
 		public BoosterCard()
 		{
@@ -936,9 +807,6 @@ public class NetCache : IService, IHasUpdate
 
 	public class PlayerRecord
 	{
-		[CompilerGenerated]
-		private int <Ties>k__BackingField;
-
 		public PegasusShared.GameType RecordType { get; set; }
 
 		public int Data { get; set; }
@@ -947,14 +815,7 @@ public class NetCache : IService, IHasUpdate
 
 		public int Losses { get; set; }
 
-		public int Ties
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Ties>k__BackingField = value;
-			}
-		}
+		public int Ties { get; set; }
 	}
 
 	public class NetCachePlayerRecords
@@ -1205,9 +1066,6 @@ public class NetCache : IService, IHasUpdate
 
 	public class NetCacheMercenariesVillageInfo
 	{
-		[CompilerGenerated]
-		private List<MercenariesBuildingState> <LastBuildingUpdate>k__BackingField;
-
 		private readonly List<int> m_emptyTierList = new List<int>();
 
 		private Dictionary<int, List<int>> m_tierTreeCache = new Dictionary<int, List<int>>();
@@ -1220,14 +1078,7 @@ public class NetCache : IService, IHasUpdate
 
 		public List<MercenariesBuildingState> BuildingStates { get; set; }
 
-		public List<MercenariesBuildingState> LastBuildingUpdate
-		{
-			[CompilerGenerated]
-			set
-			{
-				<LastBuildingUpdate>k__BackingField = value;
-			}
-		}
+		public List<MercenariesBuildingState> LastBuildingUpdate { get; set; }
 
 		public List<MercenariesRenownConvertRate> ConversionRates { get; private set; }
 
@@ -1772,6 +1623,8 @@ public class NetCache : IService, IHasUpdate
 	public class ProfileNoticeEvent : ProfileNotice
 	{
 		public int EventType { get; }
+
+		public ProfileNoticeEvent() : base(NoticeType.EVENT) { }
 	}
 
 	public class ProfileNoticeDisconnectedGame : ProfileNotice
@@ -1877,29 +1730,9 @@ public class NetCache : IService, IHasUpdate
 
 	public class ProfileNoticeTavernBrawlTicket : ProfileNotice
 	{
-		[CompilerGenerated]
-		private int <TicketType>k__BackingField;
+		public int TicketType { get; set; }
 
-		[CompilerGenerated]
-		private int <Quantity>k__BackingField;
-
-		public int TicketType
-		{
-			[CompilerGenerated]
-			set
-			{
-				<TicketType>k__BackingField = value;
-			}
-		}
-
-		public int Quantity
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Quantity>k__BackingField = value;
-			}
-		}
+		public int Quantity { get; set; }
 
 		public ProfileNoticeTavernBrawlTicket()
 			: base(NoticeType.TAVERN_BRAWL_TICKET)
@@ -2708,19 +2541,9 @@ public class NetCache : IService, IHasUpdate
 
 	public class ErrorInfo
 	{
-		[CompilerGenerated]
-		private uint <ServerError>k__BackingField;
-
 		public ErrorCode Error { get; set; }
 
-		public uint ServerError
-		{
-			[CompilerGenerated]
-			set
-			{
-				<ServerError>k__BackingField = value;
-			}
-		}
+		public uint ServerError { get; set; }
 
 		public RequestFunc RequestingFunction { get; set; }
 
@@ -3009,24 +2832,50 @@ public class NetCache : IService, IHasUpdate
 		return GetNetObject<T>() != null;
 	}
 
+	#region Accessibility
+	private NetCacheBoosters m_testNetCacheBoosters;
+
+    internal void SetTestDataNetCacheBoosters(NetCacheBoosters netCacheBoosters)
+    {
+		m_testNetCacheBoosters = netCacheBoosters;
+    }
+	#endregion
+
 	private object GetTestData(Type type)
 	{
+		if (type == typeof(NetCacheBoosters) && m_testNetCacheBoosters != null)
+        {
+			return m_testNetCacheBoosters;
+        }
+
 		if (type == typeof(NetCacheBoosters) && GameUtils.IsFakePackOpeningEnabled())
 		{
 			NetCacheBoosters netCacheBoosters = new NetCacheBoosters();
 			int fakePackCount = GameUtils.GetFakePackCount();
-			BoosterStack item = new BoosterStack
-			{
-				Id = 1,
-				Count = fakePackCount
-			};
-			netCacheBoosters.BoosterStacks.Add(item);
+			AddTestPack(netCacheBoosters.BoosterStacks, 1, 1);
+			AddTestPack(netCacheBoosters.BoosterStacks, 23, 1);
+			AddTestPack(netCacheBoosters.BoosterStacks, 468, 7);
+			AddTestPack(netCacheBoosters.BoosterStacks, 470, 2);
+			AddTestPack(netCacheBoosters.BoosterStacks, 545, 1);
+			AddTestPack(netCacheBoosters.BoosterStacks, 553, 2);
+			AddTestPack(netCacheBoosters.BoosterStacks, 616, 2);
+			AddTestPack(netCacheBoosters.BoosterStacks, 633, 1);
 			return netCacheBoosters;
 		}
 		return null;
 	}
 
-	public void UnloadNetObject<T>()
+    private void AddTestPack(List<BoosterStack> boosterStacks, int packId, int packCount)
+    {
+		BoosterStack item = new BoosterStack
+		{
+			Id = packId,
+			Count = packCount
+		};
+		boosterStacks.Add(item);
+    }
+
+    public void UnloadNetObject<T>()
 	{
 		Type typeFromHandle = typeof(T);
 		m_netCache[typeFromHandle] = null;
@@ -3044,6 +2893,11 @@ public class NetCache : IService, IHasUpdate
 
 	public long GetArcaneDustBalance()
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			return 327;
+		}
+
 		NetCacheArcaneDustBalance netObject = GetNetObject<NetCacheArcaneDustBalance>();
 		if (netObject == null)
 		{
@@ -4403,37 +4257,37 @@ public class NetCache : IService, IHasUpdate
 		}
 		if (visitorInfo.VisitorStates != null)
 		{
-			foreach (MercenariesVisitorState visitorState in visitorInfo.VisitorStates)
-			{
+		foreach (MercenariesVisitorState visitorState in visitorInfo.VisitorStates)
+		{
 				if (hashSet2.Contains(visitorState.VisitorId) || visitorState.ActiveTaskState == null)
-				{
-					continue;
-				}
-				MercenaryVisitorDbfRecord visitorRecordByID = LettuceVillageDataUtil.GetVisitorRecordByID(visitorState.VisitorId);
+			{
+				continue;
+			}
+			MercenaryVisitorDbfRecord visitorRecordByID = LettuceVillageDataUtil.GetVisitorRecordByID(visitorState.VisitorId);
 				if (visitorRecordByID == null)
 				{
 					Debug.LogError($"mercRecord {visitorState.VisitorId} not found in CollectVisitingMercenariesFromVisitorStates");
 				}
 				else
 				{
-					if (visitorRecordByID.VisitorType == MercenaryVisitor.VillageVisitorType.STANDARD)
-					{
-						continue;
-					}
-					VisitorTaskDbfRecord taskRecordByID = LettuceVillageDataUtil.GetTaskRecordByID(visitorState.ActiveTaskState.TaskId);
-					if (visitorRecordByID != null && taskRecordByID != null)
-					{
-						if (visitorRecordByID.VisitorType == MercenaryVisitor.VillageVisitorType.PROCEDURAL)
-						{
-							hashSet.Add(visitorState.ProceduralMercenaryId);
-						}
-						else
-						{
-							hashSet.Add(LettuceVillageDataUtil.GetMercenaryIdForVisitor(visitorRecordByID, taskRecordByID));
-						}
-					}
+			if (visitorRecordByID.VisitorType == MercenaryVisitor.VillageVisitorType.STANDARD)
+			{
+				continue;
+			}
+			VisitorTaskDbfRecord taskRecordByID = LettuceVillageDataUtil.GetTaskRecordByID(visitorState.ActiveTaskState.TaskId);
+			if (visitorRecordByID != null && taskRecordByID != null)
+			{
+				if (visitorRecordByID.VisitorType == MercenaryVisitor.VillageVisitorType.PROCEDURAL)
+				{
+					hashSet.Add(visitorState.ProceduralMercenaryId);
+				}
+				else
+				{
+					hashSet.Add(LettuceVillageDataUtil.GetMercenaryIdForVisitor(visitorRecordByID, taskRecordByID));
 				}
 			}
+		}
+			}
 		}
 		if (visitorInfo.ActiveRenownOffers != null)
 		{
@@ -4764,7 +4618,7 @@ public class NetCache : IService, IHasUpdate
 			netCacheRenownBalance.Balance = currencyState.RenownBalance;
 			OnNetCacheObjReceived(netCacheRenownBalance);
 			foreach (DelRenownBalanceListener renownBalanceListener in m_renownBalanceListeners)
-			{
+		{
 				renownBalanceListener(netCacheRenownBalance);
 			}
 		}
@@ -4870,15 +4724,15 @@ public class NetCache : IService, IHasUpdate
 				if (num3 > 0)
 				{
 					list.Add(new CollectionManager.CardModification
-					{
+			{
 						modificationType = CollectionManager.CardModification.ModificationType.Add,
 						cardID = cardID,
 						premium = (TAG_PREMIUM)item.Premium,
 						count = num3,
 						seenBefore = false
 					});
-				}
 			}
+		}
 			else if (item.Quantity < 0)
 			{
 				list.Add(new CollectionManager.CardModification
@@ -5264,8 +5118,8 @@ public class NetCache : IService, IHasUpdate
 			netObject.BattlegroundsFavoriteHeroSkins.Add(num, value);
 		}
 		value.Add(newBattlegroundsHeroSkinId.ToValue());
-		if (this.FavoriteBattlegroundsHeroSkinChanged != null)
-		{
+			if (this.FavoriteBattlegroundsHeroSkinChanged != null)
+			{
 			this.FavoriteBattlegroundsHeroSkinChanged(num, newBattlegroundsHeroSkinId.ToValue());
 		}
 	}
@@ -5278,10 +5132,10 @@ public class NetCache : IService, IHasUpdate
 			Debug.LogWarning($"NetCache.ProcessNewFavoriteBattlegroundsBoardSkin(): trying to access NetCacheBattlegroundsBoardSkins before it has been loaded.");
 		}
 		else if (netObject.BattlegroundsFavoriteBoardSkins.Add(newFavoriteBattlegroundsBoardSkinID) && this.FavoriteBattlegroundsBoardSkinChanged != null)
-		{
-			this.FavoriteBattlegroundsBoardSkinChanged(newFavoriteBattlegroundsBoardSkinID);
+			{
+				this.FavoriteBattlegroundsBoardSkinChanged(newFavoriteBattlegroundsBoardSkinID);
+			}
 		}
-	}
 
 	public void ProcessNewFavoriteBattlegroundsFinisher(BattlegroundsFinisherId newFavoriteBattlegroundsFinisherID)
 	{
@@ -5329,8 +5183,8 @@ public class NetCache : IService, IHasUpdate
 		{
 			netObject.FavoriteCoins.Remove(coinId);
 		}
-		if (this.FavoriteCoinChanged != null)
-		{
+			if (this.FavoriteCoinChanged != null)
+			{
 			this.FavoriteCoinChanged(coinId, isFavorite);
 		}
 	}
@@ -5433,15 +5287,15 @@ public class NetCache : IService, IHasUpdate
 			return;
 		}
 		List<int> favoriteCoins = coinsPacket.FavoriteCoins;
-		OfflineDataCache.OfflineData data = OfflineDataCache.ReadOfflineDataFromFile();
+			OfflineDataCache.OfflineData data = OfflineDataCache.ReadOfflineDataFromFile();
 		foreach (SetFavoriteCosmeticCoin item in OfflineDataCache.GenerateSetFavoriteCosmeticCoinFromDiff(data, favoriteCoins))
-		{
+			{
 			network.SetFavoriteCosmeticCoin(ref data, item.Coin, item.IsFavorite);
+			}
+			OfflineDataCache.ClearCoinDirtyFlag(ref data);
+			OfflineDataCache.CacheCoins(ref data, coinsPacket);
+			OfflineDataCache.WriteOfflineDataToFile(data);
 		}
-		OfflineDataCache.ClearCoinDirtyFlag(ref data);
-		OfflineDataCache.CacheCoins(ref data, coinsPacket);
-		OfflineDataCache.WriteOfflineDataToFile(data);
-	}
 
 	private void OnBattlegroundsHeroSkinsResponse()
 	{
@@ -5462,12 +5316,12 @@ public class NetCache : IService, IHasUpdate
 				item = record.ID;
 				string cardId = GameUtils.TranslateDbIdToCardId(record.SkinCardId);
 				if (!collectionManager.IsBattlegroundsHeroCard(cardId))
-				{
-					Log.Net.PrintError("OnBattlegroundsHeroSkinsResponse FAILED (packetOwnedSkin = {0})", ownedSkin);
-					continue;
-				}
-				if (!ownedSkin.HasSeen)
-				{
+			{
+				Log.Net.PrintError("OnBattlegroundsHeroSkinsResponse FAILED (packetOwnedSkin = {0})", ownedSkin);
+				continue;
+			}
+			if (!ownedSkin.HasSeen)
+			{
 					netCacheBattlegroundsHeroSkins.UnseenSkinIds.Add(item2);
 				}
 			}
@@ -5502,7 +5356,7 @@ public class NetCache : IService, IHasUpdate
 			{
 				value = new HashSet<int>();
 				netObject.BattlegroundsFavoriteHeroSkins.Add(baseHeroCardId, value);
-			}
+		}
 			int item = heroSkinId;
 			value.Add(item);
 			if (this.FavoriteBattlegroundsHeroSkinChanged != null)
@@ -5671,10 +5525,10 @@ public class NetCache : IService, IHasUpdate
 		}
 		NetCacheBattlegroundsBoardSkins netObject = Get().GetNetObject<NetCacheBattlegroundsBoardSkins>();
 		if (netObject != null && netObject.BattlegroundsFavoriteBoardSkins.Add(battlegroundsBoardSkinId.Value) && this.FavoriteBattlegroundsBoardSkinChanged != null)
-		{
-			this.FavoriteBattlegroundsBoardSkinChanged(battlegroundsBoardSkinId);
+			{
+				this.FavoriteBattlegroundsBoardSkinChanged(battlegroundsBoardSkinId);
+			}
 		}
-	}
 
 	private void OnClearBattlegroundsFavoriteBoardSkinResponse()
 	{
@@ -5696,10 +5550,10 @@ public class NetCache : IService, IHasUpdate
 		}
 		NetCacheBattlegroundsBoardSkins netObject = Get().GetNetObject<NetCacheBattlegroundsBoardSkins>();
 		if (netObject != null && netObject.BattlegroundsFavoriteBoardSkins.Remove(battlegroundsBoardSkinId.Value) && this.FavoriteBattlegroundsBoardSkinChanged != null)
-		{
-			this.FavoriteBattlegroundsBoardSkinChanged(null);
+			{
+				this.FavoriteBattlegroundsBoardSkinChanged(null);
+			}
 		}
-	}
 
 	private void OnBattlegroundsFinishersResponse()
 	{
@@ -5967,14 +5821,14 @@ public class NetCache : IService, IHasUpdate
 		}
 		else
 		{
-			foreach (ProfileNotice receivedNotice in receivedNotices)
+		foreach (ProfileNotice receivedNotice in receivedNotices)
+		{
+			if (netObject.Notices.Find((ProfileNotice obj) => obj.NoticeID == receivedNotice.NoticeID) == null)
 			{
-				if (netObject.Notices.Find((ProfileNotice obj) => obj.NoticeID == receivedNotice.NoticeID) == null)
-				{
-					list.Add(receivedNotice);
-				}
+				list.Add(receivedNotice);
 			}
 		}
+		}
 		return list;
 	}
 
diff --git a/Assembly-CSharp/Network.cs b/Assembly-CSharp/Network.cs
index 7528137..eb5839f 100644
--- a/Assembly-CSharp/Network.cs
+++ b/Assembly-CSharp/Network.cs
@@ -36,6 +36,7 @@ using PegasusUtil;
 using Shared.Scripts.Game.Shop.Product;
 using Shared.Scripts.Util.ValueTypes;
 using UnityEngine;
+using Accessibility;
 
 public class Network : IHasUpdate, IService
 {
@@ -301,29 +302,9 @@ public class Network : IHasUpdate, IService
 
 	public class TriggeredEvent
 	{
-		[CompilerGenerated]
-		private int <EventID>k__BackingField;
+		public int EventID { get; set; }
 
-		[CompilerGenerated]
-		private bool <Success>k__BackingField;
-
-		public int EventID
-		{
-			[CompilerGenerated]
-			set
-			{
-				<EventID>k__BackingField = value;
-			}
-		}
-
-		public bool Success
-		{
-			[CompilerGenerated]
-			set
-			{
-				<Success>k__BackingField = value;
-			}
-		}
+		public bool Success { get; set; }
 
 		public TriggeredEvent()
 		{
@@ -544,19 +525,9 @@ public class Network : IHasUpdate, IService
 			E_BP_CHALLENGE_ID_FAILED_VERIFICATION = 116
 		}
 
-		[CompilerGenerated]
-		private string <PurchaseInProgressProductID>k__BackingField;
-
 		public ErrorType Error { get; set; }
 
-		public string PurchaseInProgressProductID
-		{
-			[CompilerGenerated]
-			set
-			{
-				<PurchaseInProgressProductID>k__BackingField = value;
-			}
-		}
+		public string PurchaseInProgressProductID { get; set; }
 
 		public string ErrorCode { get; set; }
 
@@ -1376,35 +1347,15 @@ public class Network : IHasUpdate, IService
 	{
 		public class MouseInfo
 		{
-			[CompilerGenerated]
-			private int <X>k__BackingField;
-
-			[CompilerGenerated]
-			private int <Y>k__BackingField;
-
 			public int OverCardID { get; set; }
 
 			public int HeldCardID { get; set; }
 
 			public int ArrowOriginID { get; set; }
 
-			public int X
-			{
-				[CompilerGenerated]
-				set
-				{
-					<X>k__BackingField = value;
-				}
-			}
+			public int X { get; set; }
 
-			public int Y
-			{
-				[CompilerGenerated]
-				set
-				{
-					<Y>k__BackingField = value;
-				}
-			}
+			public int Y { get; set; }
 
 			public bool UseTeammatesGamestate { get; set; }
 		}
@@ -2252,15 +2203,6 @@ public class Network : IHasUpdate, IService
 
 	private const int DefaultMinimumSkinsSeenBeforeSend = 16;
 
-	[CompilerGenerated]
-	private string <GameServerIPv6>k__BackingField;
-
-	[CompilerGenerated]
-	private string <GameServerIPv4>k__BackingField;
-
-	[CompilerGenerated]
-	private bool <IsOSSupportIPv6>k__BackingField = Socket.OSSupportsIPv6;
-
 	private DispatchListener m_dispatcerListner;
 
 	private QueueInfoHandler m_queueInfoHandler;
@@ -2311,36 +2253,15 @@ public class Network : IHasUpdate, IService
 
 	private long FakeIdWaitingForResponse { get; set; }
 
+	private string GameServerIPv6 {get; set;}
+
 	public SocketProvider NetworkGameSocketProvider { get; private set; }
 
 	private static List<BattleNetErrors> GameServerDisconnectEvents { get; set; }
 
-	private string GameServerIPv6
-	{
-		[CompilerGenerated]
-		set
-		{
-			<GameServerIPv6>k__BackingField = value;
-		}
-	}
+	private string GameServerIPv4 {get; set;}
 
-	private string GameServerIPv4
-	{
-		[CompilerGenerated]
-		set
-		{
-			<GameServerIPv4>k__BackingField = value;
-		}
-	}
-
-	private bool IsOSSupportIPv6
-	{
-		[CompilerGenerated]
-		set
-		{
-			<IsOSSupportIPv6>k__BackingField = value;
-		}
-	}
+	private bool IsOSSupportIPv6 {get; set;}
 
 	public Blizzard.T5.Core.ILogger GameNetLogger
 	{
@@ -2593,10 +2514,10 @@ public class Network : IHasUpdate, IService
 		if (portraitIdFromArtVariation != 0)
 		{
 			UpdateEquippedMercenaryPortraitRequest request = new UpdateEquippedMercenaryPortraitRequest
-			{
-				MercenaryId = mercenaryId,
+		{
+			MercenaryId = mercenaryId,
 				EquippedPortraitId = portraitIdFromArtVariation
-			};
+		};
 			m_connectApi.UpdateEquippedMercenaryPortraitRequest(request);
 		}
 	}
@@ -3072,12 +2993,12 @@ public class Network : IHasUpdate, IService
 			RequestContext requestContext = m_inTransitRequests[i];
 			try
 			{
-				if (requestContext.m_timeoutHandler != null && requestContext.m_waitUntil < realtimeSinceStartup)
-				{
+			if (requestContext.m_timeoutHandler != null && requestContext.m_waitUntil < realtimeSinceStartup)
+			{
 					Log.Net.PrintWarning($"Encountered timeout waiting for {requestContext.m_pendingResponseId} {requestContext.m_requestId} {requestContext.m_requestSubId}");
-					requestContext.m_timeoutHandler(requestContext.m_pendingResponseId, requestContext.m_requestId, requestContext.m_requestSubId);
-				}
+				requestContext.m_timeoutHandler(requestContext.m_pendingResponseId, requestContext.m_requestId, requestContext.m_requestSubId);
 			}
+		}
 			catch (Exception ex)
 			{
 				Log.Net.PrintError("Exception reporting timeout: " + ex.Message);
@@ -3201,8 +3122,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnCurrencyState(packet.CurrencyState);
-			}
+			NetCache.Get().OnCurrencyState(packet.CurrencyState);
+		}
 			catch (Exception e)
 			{
 				ReportClientStateNotificationException(e);
@@ -3212,8 +3133,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnCollectionModification(packet);
-			}
+			NetCache.Get().OnCollectionModification(packet);
+		}
 			catch (Exception e2)
 			{
 				ReportClientStateNotificationException(e2);
@@ -3225,8 +3146,8 @@ public class Network : IHasUpdate, IService
 			{
 				try
 				{
-					AchieveManager.Get().OnAchievementNotifications(packet.AchievementNotifications.AchievementNotifications_);
-				}
+				AchieveManager.Get().OnAchievementNotifications(packet.AchievementNotifications.AchievementNotifications_);
+			}
 				catch (Exception e3)
 				{
 					ReportClientStateNotificationException(e3);
@@ -3236,8 +3157,8 @@ public class Network : IHasUpdate, IService
 			{
 				try
 				{
-					Get().OnNoticeNotifications(packet.NoticeNotifications);
-				}
+				Get().OnNoticeNotifications(packet.NoticeNotifications);
+			}
 				catch (Exception e4)
 				{
 					ReportClientStateNotificationException(e4);
@@ -3247,8 +3168,8 @@ public class Network : IHasUpdate, IService
 			{
 				try
 				{
-					NetCache.Get().OnBoosterModifications(packet.BoosterModifications);
-				}
+				NetCache.Get().OnBoosterModifications(packet.BoosterModifications);
+			}
 				catch (Exception e5)
 				{
 					ReportClientStateNotificationException(e5);
@@ -3259,8 +3180,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnBattlegroundsGuideSkinModifications(packet.BattlegroundsGuideSkinModifications);
-			}
+			NetCache.Get().OnBattlegroundsGuideSkinModifications(packet.BattlegroundsGuideSkinModifications);
+		}
 			catch (Exception e6)
 			{
 				ReportClientStateNotificationException(e6);
@@ -3270,8 +3191,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnBattlegroundsHeroSkinModifications(packet.BattlegroundsHeroSkinModifications);
-			}
+			NetCache.Get().OnBattlegroundsHeroSkinModifications(packet.BattlegroundsHeroSkinModifications);
+		}
 			catch (Exception e7)
 			{
 				ReportClientStateNotificationException(e7);
@@ -3281,8 +3202,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnBattlegroundsBoardSkinModifications(packet.BattlegroundsBoardSkinModifications);
-			}
+			NetCache.Get().OnBattlegroundsBoardSkinModifications(packet.BattlegroundsBoardSkinModifications);
+		}
 			catch (Exception e8)
 			{
 				ReportClientStateNotificationException(e8);
@@ -3292,8 +3213,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnBattlegroundsFinisherModifications(packet.BattlegroundsFinisherModifications);
-			}
+			NetCache.Get().OnBattlegroundsFinisherModifications(packet.BattlegroundsFinisherModifications);
+		}
 			catch (Exception e9)
 			{
 				ReportClientStateNotificationException(e9);
@@ -3303,8 +3224,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnBattlegroundsEmoteModifications(packet.BattlegroundsEmoteModifications);
-			}
+			NetCache.Get().OnBattlegroundsEmoteModifications(packet.BattlegroundsEmoteModifications);
+		}
 			catch (Exception e10)
 			{
 				ReportClientStateNotificationException(e10);
@@ -3314,8 +3235,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnHeroXP(packet.HeroXp);
-			}
+			NetCache.Get().OnHeroXP(packet.HeroXp);
+		}
 			catch (Exception e11)
 			{
 				ReportClientStateNotificationException(e11);
@@ -3325,8 +3246,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnPlayerRecordsPacket(packet.PlayerRecords);
-			}
+			NetCache.Get().OnPlayerRecordsPacket(packet.PlayerRecords);
+		}
 			catch (Exception e12)
 			{
 				ReportClientStateNotificationException(e12);
@@ -3336,8 +3257,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				DraftManager.Get().OnArenaSessionResponsePacket(packet.ArenaSessionResponse);
-			}
+			DraftManager.Get().OnArenaSessionResponsePacket(packet.ArenaSessionResponse);
+		}
 			catch (Exception e13)
 			{
 				ReportClientStateNotificationException(e13);
@@ -3347,8 +3268,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnCardBackModifications(packet.CardBackModifications);
-			}
+			NetCache.Get().OnCardBackModifications(packet.CardBackModifications);
+		}
 			catch (Exception e14)
 			{
 				ReportClientStateNotificationException(e14);
@@ -3358,8 +3279,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				NetCache.Get().OnPlayerDraftTickets(packet.PlayerDraftTickets);
-			}
+			NetCache.Get().OnPlayerDraftTickets(packet.PlayerDraftTickets);
+		}
 			catch (Exception e15)
 			{
 				ReportClientStateNotificationException(e15);
@@ -3381,8 +3302,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				ProcessClientStateNotification(item);
-			}
+			ProcessClientStateNotification(item);
+		}
 			catch (Exception e)
 			{
 				ReportClientStateNotificationException(e);
@@ -3486,7 +3407,7 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				ProcessRequestTimeouts();
+			ProcessRequestTimeouts();
 			}
 			catch (Exception ex)
 			{
@@ -3495,7 +3416,7 @@ public class Network : IHasUpdate, IService
 			}
 			try
 			{
-				ProcessNetworkReachability();
+			ProcessNetworkReachability();
 			}
 			catch (Exception ex2)
 			{
@@ -3504,7 +3425,7 @@ public class Network : IHasUpdate, IService
 			}
 			try
 			{
-				ProcessConnectApiHeartbeat();
+			ProcessConnectApiHeartbeat();
 			}
 			catch (Exception ex3)
 			{
@@ -3513,7 +3434,7 @@ public class Network : IHasUpdate, IService
 			}
 			try
 			{
-				StoreManager.Get().Heartbeat();
+			StoreManager.Get().Heartbeat();
 			}
 			catch (Exception ex4)
 			{
@@ -3624,10 +3545,10 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				PegasusPacket pegasusPacket = new PegasusPacket(utilResponse.type, utilResponse.bytes.Length, utilResponse.bytes);
-				pegasusPacket.Context = utilResponse.context;
-				m_connectApi.DecodeAndProcessPacket(pegasusPacket);
-			}
+			PegasusPacket pegasusPacket = new PegasusPacket(utilResponse.type, utilResponse.bytes.Length, utilResponse.bytes);
+			pegasusPacket.Context = utilResponse.context;
+			m_connectApi.DecodeAndProcessPacket(pegasusPacket);
+		}
 			catch (Exception ex)
 			{
 				Log.Net.PrintError("Excpetion processsing packet " + utilResponse?.ToString() + ", Error: " + ex.Message + " , " + ex.StackTrace);
@@ -3734,8 +3655,8 @@ public class Network : IHasUpdate, IService
 		{
 			try
 			{
-				array[i]();
-			}
+			array[i]();
+		}
 			catch (Exception ex)
 			{
 				Log.Net.PrintError($"Excpetion handling packet id {id}: {ex.Message}{ex.StackTrace}");
@@ -3777,6 +3698,13 @@ public class Network : IHasUpdate, IService
 			Asset = GameUtils.TranslateCardIdToDbId(transaction.CardID),
 			Premium = (int)transaction.Premium
 		};
+
+		if (AccessibleCraftingTestingUtils.IsTestingCrafting())
+		{
+			AccessibleCraftingTestingUtils.CraftingTransaction(transaction, cardDef, expectedTransactionCost, normalOwned, goldenOwned);
+			return;
+		}
+
 		m_connectApi.CraftingTransaction(transaction, cardDef, expectedTransactionCost, normalOwned, goldenOwned, signatureOwned, diamondOwned);
 	}
 
@@ -3870,7 +3798,7 @@ public class Network : IHasUpdate, IService
 		}
 		if (BattleNet.Get() == null)
 		{
-			BattleNet.SetImpl(CreateBattleNetImplementation());
+		BattleNet.SetImpl(CreateBattleNetImplementation());
 		}
 		ConnectionOptions connectionOptions = CreateConnectionOptions();
 		Log.Net.PrintDebug($"StartInitalBattleNetConnection: BattleNet.Connect with: {connectionOptions.Host}:{connectionOptions.Port} , Auth: {connectionOptions.AuthToken} ");
@@ -3938,20 +3866,20 @@ public class Network : IHasUpdate, IService
 		{
 			return;
 		}
-		QueueInfo queueInfo2 = new QueueInfo();
-		queueInfo2.position = queueInfo.position;
-		queueInfo2.secondsTilEnd = queueInfo.end;
-		queueInfo2.stdev = queueInfo.stdev;
-		try
-		{
+			QueueInfo queueInfo2 = new QueueInfo();
+			queueInfo2.position = queueInfo.position;
+			queueInfo2.secondsTilEnd = queueInfo.end;
+			queueInfo2.stdev = queueInfo.stdev;
+			try
+			{
 			m_queueInfoHandler(queueInfo2);
 		}
-		catch (Exception ex)
-		{
-			Log.Net.PrintError("Exception processing queue position: " + ex.Message);
-			ExceptionReporter.Get().ReportCaughtException(ex);
+			catch (Exception ex)
+			{
+				Log.Net.PrintError("Exception processing queue position: " + ex.Message);
+				ExceptionReporter.Get().ReportCaughtException(ex);
+			}
 		}
-	}
 
 	public void SetFriendsHandler(FriendsHandler handler)
 	{
@@ -4131,9 +4059,9 @@ public class Network : IHasUpdate, IService
 		{
 			return;
 		}
-		BattleNet.TakeWhispers(m_bnetWhispers);
-		if (m_bnetWhispers.Count > 0)
-		{
+			BattleNet.TakeWhispers(m_bnetWhispers);
+			if (m_bnetWhispers.Count > 0)
+			{
 			try
 			{
 				m_state.CurrentWhisperHandler(m_bnetWhispers.ToArray());
@@ -4151,8 +4079,8 @@ public class Network : IHasUpdate, IService
 	{
 		try
 		{
-			BnetParty.Process();
-		}
+		BnetParty.Process();
+	}
 		catch (Exception ex)
 		{
 			Log.Net.PrintError("Exception processing parties: " + ex.Message);
@@ -4167,16 +4095,16 @@ public class Network : IHasUpdate, IService
 		{
 			return;
 		}
-		try
-		{
+			try
+			{
 			m_state.CurrentShutdownHandler(shutdownMinutes);
 		}
-		catch (Exception ex)
-		{
-			Log.Net.PrintError("Exception processing broadcasts: " + ex.Message);
-			ExceptionReporter.Get().ReportCaughtException(ex);
+			catch (Exception ex)
+			{
+				Log.Net.PrintError("Exception processing broadcasts: " + ex.Message);
+				ExceptionReporter.Get().ReportCaughtException(ex);
+			}
 		}
-	}
 
 	private void ProcessNotifications()
 	{
@@ -4211,9 +4139,9 @@ public class Network : IHasUpdate, IService
 		{
 			return;
 		}
-		BattleNet.TakeFriendsUpdates(m_friendsUpdates);
-		if (m_friendsUpdates.Count > 0)
-		{
+			BattleNet.TakeFriendsUpdates(m_friendsUpdates);
+			if (m_friendsUpdates.Count > 0)
+			{
 			try
 			{
 				m_state.CurrentFriendsHandler(m_friendsUpdates.ToArray());
@@ -4233,9 +4161,9 @@ public class Network : IHasUpdate, IService
 		{
 			return;
 		}
-		BattleNet.TakePresence(m_presenceUpdates);
-		if (m_presenceUpdates.Count > 0)
-		{
+			BattleNet.TakePresence(m_presenceUpdates);
+			if (m_presenceUpdates.Count > 0)
+			{
 			try
 			{
 				m_state.CurrentPresenceHandler(m_presenceUpdates.ToArray());
@@ -4301,8 +4229,8 @@ public class Network : IHasUpdate, IService
 			{
 				try
 				{
-					flag = array[i].Fire(info) || flag;
-				}
+				flag = array[i].Fire(info) || flag;
+			}
 				catch (Exception ex)
 				{
 					Log.Net.PrintError("Exception firing error listener " + ex.Message);
@@ -4350,38 +4278,38 @@ public class Network : IHasUpdate, IService
 		{
 			return false;
 		}
-		ErrorParams errorParams = new ErrorParams();
-		errorParams.m_delayBeforeNextReset = m_state.TimeBeforeAllowReset;
-		string text = m_breakingNews.GetText();
-		if (string.IsNullOrEmpty(text))
-		{
-			if (m_breakingNews.GetError() != null && m_state.DelayedError == "GLOBAL_ERROR_NETWORK_NO_GAME_SERVER")
-			{
-				errorParams.m_message = GameStrings.Format("GLOBAL_ERROR_NETWORK_NO_CONNECTION");
-			}
-			else if (HearthstoneApplication.IsInternal() && m_state.DelayedError == "GLOBAL_ERROR_UNKNOWN_ERROR")
+			ErrorParams errorParams = new ErrorParams();
+			errorParams.m_delayBeforeNextReset = m_state.TimeBeforeAllowReset;
+			string text = m_breakingNews.GetText();
+			if (string.IsNullOrEmpty(text))
 			{
-				errorParams.m_message = "Dev Message: Could not connect to Battle.net, and there was no breaking news to display. Maybe Battle.net is down?";
+				if (m_breakingNews.GetError() != null && m_state.DelayedError == "GLOBAL_ERROR_NETWORK_NO_GAME_SERVER")
+				{
+					errorParams.m_message = GameStrings.Format("GLOBAL_ERROR_NETWORK_NO_CONNECTION");
+				}
+				else if (HearthstoneApplication.IsInternal() && m_state.DelayedError == "GLOBAL_ERROR_UNKNOWN_ERROR")
+				{
+					errorParams.m_message = "Dev Message: Could not connect to Battle.net, and there was no breaking news to display. Maybe Battle.net is down?";
+				}
+				else
+				{
+					errorParams.m_message = GameStrings.Format(m_state.DelayedError);
+					if (m_state.DelayedError == "GLOBAL_MOBILE_ERROR_GAMESERVER_CONNECT")
+					{
+						errorParams.m_reason = FatalErrorReason.MOBILE_GAME_SERVER_RPC_ERROR;
+					}
+				}
 			}
 			else
 			{
-				errorParams.m_message = GameStrings.Format(m_state.DelayedError);
-				if (m_state.DelayedError == "GLOBAL_MOBILE_ERROR_GAMESERVER_CONNECT")
-				{
-					errorParams.m_reason = FatalErrorReason.MOBILE_GAME_SERVER_RPC_ERROR;
-				}
+				errorParams.m_message = GameStrings.Format("GLOBAL_MOBILE_ERROR_BREAKING_NEWS", text);
+				errorParams.m_reason = FatalErrorReason.BREAKING_NEWS;
 			}
-		}
-		else
-		{
-			errorParams.m_message = GameStrings.Format("GLOBAL_MOBILE_ERROR_BREAKING_NEWS", text);
-			errorParams.m_reason = FatalErrorReason.BREAKING_NEWS;
-		}
 		GameNetLogger.Log(Blizzard.T5.Core.LogLevel.Debug, $"Network.ProcessDelayedError() - reason: {errorParams.m_reason}, message: {errorParams.m_message}");
 		GameNetLogger.Log(Blizzard.T5.Core.LogLevel.Error, GetNetworkGameStateStringForErrors());
-		Error.AddFatal(errorParams);
-		m_state.DelayedError = null;
-		m_state.TimeBeforeAllowReset = 0f;
+			Error.AddFatal(errorParams);
+			m_state.DelayedError = null;
+			m_state.TimeBeforeAllowReset = 0f;
 		return true;
 	}
 
@@ -4582,7 +4510,7 @@ public class Network : IHasUpdate, IService
 	public void BattlegroundsPartyLeaderChangedFindingGameState(int newGameState)
 	{
 		if (Enum.IsDefined(typeof(BnetGameType), newGameState))
-		{
+	{
 			m_state.FindingBnetGameType = (BnetGameType)newGameState;
 		}
 	}
@@ -4986,6 +4914,12 @@ public class Network : IHasUpdate, IService
 
 	public void MassDisenchant()
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			AccessibleCraftingTestingUtils.DoMassDisenchant();
+			return;
+		}
+
 		m_connectApi.MassDisenchant();
 	}
 
@@ -5291,6 +5225,11 @@ public class Network : IHasUpdate, IService
 
 	public void PurchaseViaGold(int quantity, ProductType productItemType, int data)
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			return;
+		}
+
 		if (!IsLoggedIn())
 		{
 			Log.All.PrintError("Client attempted to make a gold purchase while offline!");
@@ -5303,6 +5242,11 @@ public class Network : IHasUpdate, IService
 
 	public void GetPurchaseMethod(long? pmtProductId, int quantity, Currency currency)
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			return;
+		}
+
 		m_connectApi.RequestPurchaseMethod(pmtProductId, quantity, currency.toProto(), SystemInfo.deviceUniqueIdentifier, GetPlatformBuilder());
 	}
 
@@ -5413,7 +5357,7 @@ public class Network : IHasUpdate, IService
 
 	public void SetFavoriteCardBack(int cardBack, bool isFavorite = true)
 	{
-		m_connectApi.SetFavoriteCardBack(cardBack, isFavorite);
+			m_connectApi.SetFavoriteCardBack(cardBack, isFavorite);
 		if (!IsLoggedIn())
 		{
 			OfflineDataCache.SetFavoriteCardBack(cardBack, isFavorite);
@@ -7569,8 +7513,8 @@ public class Network : IHasUpdate, IService
 		if (IsLoggedIn())
 		{
 			m_connectApi.ClearBattlegroundsFavoriteHeroSkin(baseHeroCardDbid, battlegroundsHeroSkinId);
-			return;
-		}
+				return;
+			}
 		NetCache.NetCacheBattlegroundsHeroSkins netObject = NetCache.Get().GetNetObject<NetCache.NetCacheBattlegroundsHeroSkins>();
 		if (netObject != null)
 		{
diff --git a/Assembly-CSharp/NotificationManager.cs b/Assembly-CSharp/NotificationManager.cs
index aab4fe7..078c81c 100644
--- a/Assembly-CSharp/NotificationManager.cs
+++ b/Assembly-CSharp/NotificationManager.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -279,7 +280,7 @@ public class NotificationManager : MonoBehaviour
 
 	private Notification popUpDialog;
 
-	private Notification m_quote;
+	internal Notification m_quote;
 
 	private List<string> m_quotesThisSession;
 
@@ -364,28 +365,28 @@ public class NotificationManager : MonoBehaviour
 		return s_instance;
 	}
 
-	public Notification CreatePopupDialog(string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText)
-	{
-		return CreatePopupDialog(headlineText, bodyText, yesOrOKButtonText, noButtonText, new Vector3(0f, 0f, 0f));
-	}
-
-	public Notification CreatePopupDialog(string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText, Vector3 offset)
-	{
-		if (popUpDialog != null)
-		{
-			UnityEngine.Object.Destroy(popUpDialog.gameObject);
-		}
-		GameObject gameObject = UnityEngine.Object.Instantiate(dialogBoxPrefab);
-		Vector3 position = Camera.main.transform.position;
-		gameObject.transform.position = position + new Vector3(-0.07040818f, -16.10709f, 1.79612f) + offset;
-		popUpDialog = gameObject.GetComponent<Notification>();
-		popUpDialog.ChangeDialogText(headlineText, bodyText, yesOrOKButtonText, noButtonText);
-		popUpDialog.PlayBirth();
-		UniversalInputManager.Get().SetGameDialogActive(active: true);
-		return popUpDialog;
-	}
-
-	public Notification CreateSpeechBubble(string speechText, Actor actor)
+    public Notification CreatePopupDialog(bool accessible, string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText)
+    {
+        return CreatePopupDialog(accessible, headlineText, bodyText, yesOrOKButtonText, noButtonText, new Vector3(0f, 0f, 0f));
+    }
+
+    public Notification CreatePopupDialog(bool accessible, string headlineText, string bodyText, string yesOrOKButtonText, string noButtonText, Vector3 offset)
+    {
+        if (popUpDialog != null)
+        {
+            UnityEngine.Object.Destroy(popUpDialog.gameObject);
+        }
+        GameObject gameObject = UnityEngine.Object.Instantiate(dialogBoxPrefab);
+        Vector3 position = Camera.main.transform.position;
+        gameObject.transform.position = position + new Vector3(-0.07040818f, -16.10709f, 1.79612f) + offset;
+        popUpDialog = gameObject.GetComponent<Notification>();
+        popUpDialog.ChangeDialogText(headlineText, bodyText, yesOrOKButtonText, noButtonText);
+        popUpDialog.PlayBirth();
+        UniversalInputManager.Get().SetGameDialogActive(active: true);
+        return popUpDialog;
+    }
+
+    public Notification CreateSpeechBubble(string speechText, Actor actor)
 	{
 		return CreateSpeechBubble(speechText, Notification.SpeechBubbleDirection.BottomLeft, actor, bDestroyWhenNewCreated: false);
 	}
@@ -524,13 +525,14 @@ public class NotificationManager : MonoBehaviour
 			DestroyNotification(component, options.emoteDuration);
 		}
 		component.notificationGroup = options.speechBubbleGroup;
+		AccessibleNotificationMgr.OnCreateNotificationWithSound(component);
 		return component;
 	}
 
 	public Notification CreateBouncingArrow(UserAttentionBlocker blocker, bool addToList)
 	{
 		bool num = SceneMgr.Get().IsInGame();
-		bool flag = UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManger.CreateBouncingArrow");
+		bool flag = UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManger.CreateBouncingArrow");
 		if (!num && !flag)
 		{
 			Log.All.PrintDebug($"CreateBouncingArrow returning null because: SceneMgr.Get().IsInGame(): {SceneMgr.Get().IsInGame()} && UserAttentionManager.CanShowAttentionGrabber(blocker, \"NotificationManger.CreateBouncingArrow\"):{flag} ");
@@ -599,7 +601,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreatePopupText(UserAttentionBlocker blocker, Vector3 position, Vector3 scale, string text, bool convertLegacyPosition = true, PopupTextType popupTextType = PopupTextType.BASIC)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManager.CreatePopupText"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManager.CreatePopupText"))
 		{
 			return null;
 		}
@@ -619,6 +621,7 @@ public class NotificationManager : MonoBehaviour
 		component.PlayBirth();
 		component.OnDestroyCallback = (Action<Notification>)Delegate.Combine(component.OnDestroyCallback, new Action<Notification>(OnPopupTextDestroy));
 		popUpTexts.Add(component);
+		AccessibleNotificationMgr.OnCreateNotificationWithoutSound(component);
 		return component;
 	}
 
@@ -634,7 +637,7 @@ public class NotificationManager : MonoBehaviour
 
 	public Notification CreateInnkeeperQuote(UserAttentionBlocker blocker, Vector3 position, string text, string soundPath, float durationSeconds = 0f, Action<int> finishCallback = null, bool clickToDismiss = false, CanvasAnchor anchor = CanvasAnchor.BOTTOM_LEFT)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManager.CreateInnkeeperQuote"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(true, blocker, "NotificationManager.CreateInnkeeperQuote"))
 		{
 			finishCallback?.Invoke(0);
 			return null;
@@ -861,7 +864,8 @@ public class NotificationManager : MonoBehaviour
 			return;
 		}
 		m_quote.PlayBirthWithForcedScale(Vector3.one);
-		if (durationSeconds > 0f)
+        AccessibleNotificationMgr.OnCreateNotificationWithSound(m_quote);
+        if (durationSeconds > 0f)
 		{
 			if (persistCharacter)
 			{
@@ -891,8 +895,9 @@ public class NotificationManager : MonoBehaviour
 			quoteSoundCallbackData.m_quote = m_quote;
 			quoteSoundCallbackData.m_durationSeconds = durationSeconds;
 			SoundLoader.LoadSound(soundPath, OnQuoteSoundLoaded, quoteSoundCallbackData, SoundManager.Get().GetPlaceholderSound());
-		}
-		else
+            AccessibleNotificationMgr.OnCreateNotificationWithSound(m_quote);
+        }
+        else
 		{
 			PlayQuoteWithoutSound(durationSeconds, text);
 		}
@@ -901,6 +906,7 @@ public class NotificationManager : MonoBehaviour
 	private void PlayQuoteWithoutSound(float durationSeconds, string text = null)
 	{
 		m_quote.PlayBirthWithForcedScale(UniversalInputManager.UsePhoneUI ? NOTIFICATION_SCALE_PHONE : NOTIFICATION_SCALE);
+		AccessibleNotificationMgr.OnCreateNotificationWithoutSound(m_quote);
 		if (durationSeconds <= 0f && text != null)
 		{
 			durationSeconds = ClipLengthEstimator.StringToReadTime(text);
@@ -1276,7 +1282,7 @@ public class NotificationManager : MonoBehaviour
 
 	public bool ShowTutorialNotification(UserAttentionBlocker blocker, Vector3 position, Vector3 scale, string text, bool convertLegacyPosition = true, TutorialPopupType tooltipType = TutorialPopupType.BASIC, Notification.PopUpArrowDirection arrowDirection = Notification.PopUpArrowDirection.None)
 	{
-		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(blocker, "NotificationManager.CreateTutorialNotificationText"))
+		if (!SceneMgr.Get().IsInGame() && !UserAttentionManager.CanShowAttentionGrabber(false, blocker, "NotificationManager.CreateTutorialNotificationText"))
 		{
 			return false;
 		}
diff --git a/Assembly-CSharp/Option.cs b/Assembly-CSharp/Option.cs
index 76e5487..a1d5028 100644
--- a/Assembly-CSharp/Option.cs
+++ b/Assembly-CSharp/Option.cs
@@ -659,6 +659,7 @@ public enum Option
 	EARLY_CONCEDE_CONFIRMATION_DISABLED,
 	[Description("hasSeenMythicUnlock")]
 	HAS_SEEN_MYTHIC_UNLOCK,
+
 	[Description("optoutDataSharing")]
 	OPTOUT_DATA_SHARING,
 	[Description("optoutDataSharingCached")]
@@ -696,5 +697,18 @@ public enum Option
 	[Description("hasSeenDuosLobbyTutorialQueue")]
 	BG_DUOS_LOBBY_TUTORIAL_PLAYED_QUEUE,
 	[Description("hasSeenDuosLobbyTutorialArrangeParty")]
-	BG_DUOS_LOBBY_TUTORIAL_PLAYED_ARRANGE_PARTY
+	BG_DUOS_LOBBY_TUTORIAL_PLAYED_ARRANGE_PARTY,
+
+	#region Accessibility
+	[Description("accessibilityGameSpeed")]
+	ACCESSIBILITY_GAME_SPEED,
+	[Description("accessibilityBackgroundSpeech")]
+	ACCESSIBILITY_BACKGROUND_SPEECH,
+	[Description("accessibilityAutoAttackSpeed")]
+	ACCESSIBILITY_AUTO_ATTACK_SPEED,
+	[Description("accessibilityBattlegroundsNarrateAttacks")]
+	ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS,
+		[Description("accessibilitySaveBattleLogs")]
+	ACCESSIBILITY_SAVE_BATTLE_LOGS
+	#endregion
 }
diff --git a/Assembly-CSharp/OptionDataTables.cs b/Assembly-CSharp/OptionDataTables.cs
index 44b6f1d..63ea7bb 100644
--- a/Assembly-CSharp/OptionDataTables.cs
+++ b/Assembly-CSharp/OptionDataTables.cs
@@ -813,6 +813,28 @@ public class OptionDataTables
 			Option.FORMAT_TYPE_LAST_PLAYED,
 			typeof(int)
 		},
+		#region Accessibility
+		{
+      Option.ACCESSIBILITY_GAME_SPEED,
+			typeof(int)
+    },
+		{
+      Option.ACCESSIBILITY_BACKGROUND_SPEECH,
+			typeof(bool)
+    },
+		{
+      Option.ACCESSIBILITY_SAVE_BATTLE_LOGS,
+			typeof(bool)
+    },
+		{
+      Option.ACCESSIBILITY_AUTO_ATTACK_SPEED,
+			typeof(float)
+    },
+		{
+      Option.ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS,
+			typeof(bool)
+    },
+		#endregion
 		{
 			Option.AADC_LOCAL_SAVE_TIME_STAMP,
 			typeof(ulong)
@@ -867,7 +889,7 @@ public class OptionDataTables
 		},
 		{
 			Option.SOUND_VOLUME,
-			1f
+			0.5f // Start lower due to screen readers as it's easier for beginners
 		},
 		{
 			Option.MUSIC_VOLUME,
@@ -1357,6 +1379,28 @@ public class OptionDataTables
 			Option.HAS_SEEN_CLASSIC_MODE_VO,
 			false
 		},
+		#region Accessibility
+    {
+			Option.ACCESSIBILITY_GAME_SPEED,
+			3
+	},
+	    {
+			Option.ACCESSIBILITY_BACKGROUND_SPEECH,
+			true
+	},
+	    {
+			Option.ACCESSIBILITY_SAVE_BATTLE_LOGS,
+			false
+	},
+    {
+			Option.ACCESSIBILITY_AUTO_ATTACK_SPEED,
+			1.0f
+	},
+    {
+			Option.ACCESSIBILITY_BATTLEGROUNDS_NARRATE_ATTACKS,
+			true
+	},
+		#endregion
 		{
 			Option.DEBUG_SHOW_BATTLEGROUND_SKIN_IDS,
 			false
diff --git a/Assembly-CSharp/OptionsMenu.cs b/Assembly-CSharp/OptionsMenu.cs
index 2069ce6..0c749da 100644
--- a/Assembly-CSharp/OptionsMenu.cs
+++ b/Assembly-CSharp/OptionsMenu.cs
@@ -6,9 +6,11 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Streaming;
 using UnityEngine;
+using Accessibility;
+using Blizzard.T5.Core;
 
 [CustomEditClass]
-public class OptionsMenu : MonoBehaviour
+public class OptionsMenu : MonoBehaviour, AccessibleUI
 {
 	public delegate void hideHandler();
 
@@ -235,6 +237,12 @@ public class OptionsMenu : MonoBehaviour
 		UpdateUI();
 		m_graphicsGroup.GetComponent<MultiSliceElement>().UpdateSlices();
 		m_graphicsManager.OnResolutionChangedEvent += UpdateMenuItemValues;
+		#region accessibility
+		m_autoAttackSpeeds.Clear();
+		m_autoAttackSpeeds.Add(1.0f,LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_AUTO_ATTACK_SPEED_SLOW));
+		m_autoAttackSpeeds.Add(0.8f,LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_AUTO_ATTACK_SPEED_MEDIUM));
+		m_autoAttackSpeeds.Add(0.5f,LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_AUTO_ATTACK_SPEED_FAST));
+		#endregion
 	}
 
 	public void OnDestroy()
@@ -283,10 +291,13 @@ public class OptionsMenu : MonoBehaviour
 		UpdateOtherUI();
 		ShowOrHide(showOrHide: true);
 		AnimationUtil.ShowWithPunch(base.gameObject, HIDDEN_SCALE, 1.1f * NORMAL_SCALE, NORMAL_SCALE, null, noFade: true);
+
+		ReadMenu();
 	}
 
 	public void Hide(bool callHideHandler = true)
 	{
+		AccessibilityMgr.HideUI(this);
 		ShowOrHide(showOrHide: false);
 		if (m_hideHandler != null && callHideHandler)
 		{
@@ -382,7 +393,7 @@ public class OptionsMenu : MonoBehaviour
 
 	private bool CanShowOtherMenuOptions()
 	{
-		if (UserAttentionManager.GetAvailabilityBlockerReason(isFriendlyChallenge: false) != 0)
+		if (UserAttentionManager.GetAvailabilityBlockerReason(false, isFriendlyChallenge: false) != 0)
 		{
 			return false;
 		}
@@ -694,4 +705,151 @@ public class OptionsMenu : MonoBehaviour
 		m_soundOptionsMenu.Show();
 		m_soundOptionsMenuLoading = false;
 	}
+
+	#region Accessibility
+private Map<float, string> m_autoAttackSpeeds = new Map<float,string>();
+	private AccessibleMenu m_accessibleMenu;
+
+	private AccessibleDropdownControl m_curAccessibleDropdown;
+
+	private AccessibleDropdownControl m_accessibleGraphicsQuality;
+
+	private AccessibleDropdownControl m_accessibleGraphicsResolution;
+
+	private AccessibleDropdownControl m_accessibleFrameRate;
+
+	private AccessibleCheckBox m_speechInBackground;
+private AccessibleCheckBox m_saveBattleLogs;
+	private AccessibleCheckBox m_debugLogging;
+
+	private AccessibleCheckBox m_accessibleFullScreen;
+
+	private AccessibleCheckBox m_accessibleScreenShake;
+
+	private AccessibleMenu m_autoAttackSpeedMenu;
+
+	private AccessibleCheckBox m_accessibleAllowSpectators;
+
+	private enum AccessibleMenuState { MAIN_MENU, ADJUSTING_DROPDOWN, AUTO_ATTACK_SPEED_MENU};
+
+	private AccessibleMenuState m_curState;
+
+	private void ReadMenu()
+	{
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleGraphicsResolution = new AccessibleDropdownControl(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_GRAPHICS_RESOLUTION_OPTION), m_graphicsRes, BackToMainMenu);
+		m_accessibleGraphicsQuality = new AccessibleDropdownControl(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_GRAPHICS_QUALITY_OPTION), m_graphicsQuality, BackToMainMenu);
+		m_accessibleFrameRate = new AccessibleDropdownControl(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_FRAME_RATE_OPTION), m_graphicsFps, BackToMainMenu);
+
+		m_speechInBackground = new AccessibleCheckBox(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_SPEECH_IN_BACKGROUND_OPTION), OnToggleSpeechInBackground, GetSpeechinBackgroundState);
+				m_saveBattleLogs = new AccessibleCheckBox(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_SAVE_BATTLE_LOGS), OnToggleSaveBattleLogs, GetSaveBattleLogsState);
+		m_debugLogging = new AccessibleCheckBox(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_DEBUG_LOGGING_OPTION), AccessibilityUtils.DebugLoggingToggle, AccessibilityUtils.GetDebugLoggingState);
+		m_accessibleScreenShake = new AccessibleCheckBox(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ENABLE_SCREEN_SHAKE_OPTION), m_screenShakeCheckbox);
+		m_accessibleFullScreen = new AccessibleCheckBox(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_FULLSCREEN_OPTION), m_fullScreenCheckbox);
+		m_accessibleAllowSpectators = new AccessibleCheckBox(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ALLOW_SPECTATORS_OPTION), m_spectatorOpenJoinCheckbox);
+m_autoAttackSpeedMenu=new AccessibleMenu(this, "", BackToMainMenu);
+foreach(float k in m_autoAttackSpeeds.Keys) {
+	m_autoAttackSpeedMenu.AddOption(m_autoAttackSpeeds[k],() => SetAutoAttackSpeed(k));
+}
+		SetupMainMenu();
+	}
+
+	private void SetupMainMenu()
+	{
+		m_curState = AccessibleMenuState.MAIN_MENU;
+		m_accessibleMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_TITLE), () => Hide(), true);
+
+		m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_TITLE), m_soundOptionsButton.TriggerRelease);
+		m_accessibleMenu.AddOption(m_speechInBackground.GetText, m_speechInBackground.Toggle);
+		m_accessibleMenu.AddOption(getAutoAttackSpeedText, setAutoAttackSpeed);
+		m_accessibleMenu.AddOption(m_saveBattleLogs.GetText, m_saveBattleLogs.Toggle);
+		m_accessibleMenu.AddOption(m_accessibleGraphicsResolution.GetText, () => OnClickDropdown(m_accessibleGraphicsResolution));
+		m_accessibleMenu.AddOption(m_accessibleGraphicsQuality.GetText, () => OnClickDropdown(m_accessibleGraphicsQuality));
+		m_accessibleMenu.AddOption(m_accessibleFrameRate.GetText, () => OnClickDropdown(m_accessibleFrameRate));
+		m_accessibleMenu.AddOption(m_accessibleFullScreen.GetText, m_accessibleFullScreen.Toggle);
+		m_accessibleMenu.AddOption(m_accessibleAllowSpectators.GetText, m_accessibleAllowSpectators.Toggle);
+		m_accessibleMenu.AddOption(m_accessibleScreenShake.GetText, m_accessibleScreenShake.Toggle);
+		m_accessibleMenu.AddOption(m_debugLogging.GetText, m_debugLogging.Toggle);
+
+		m_accessibleMenu.StartReading();
+	}
+private string getAutoAttackSpeedText() {
+		string curSpeed="";
+		m_autoAttackSpeeds.TryGetValue(Options.Get().GetFloat(Option.ACCESSIBILITY_AUTO_ATTACK_SPEED),out curSpeed);
+	return LocalizationUtils.Format(LocalizationKey.OPTIONS_MENU_AUTO_ATTACK_SPEED,curSpeed);
+
+}
+	private void setAutoAttackSpeed() {
+	m_curState=AccessibleMenuState.AUTO_ATTACK_SPEED_MENU;
+	m_autoAttackSpeedMenu.StartReading();
+}
+
+private void SetAutoAttackSpeed(float speed) {
+	Options.Get().SetFloat(Option.ACCESSIBILITY_AUTO_ATTACK_SPEED, speed);
+	BackToMainMenu();
+}
+	private void BackToMainMenu()
+	{
+		m_curState = AccessibleMenuState.MAIN_MENU;
+		m_accessibleMenu.ReadCurrentOption();
+	}
+
+	private void OnClickDropdown(AccessibleDropdownControl dropdown)
+	{
+		m_curAccessibleDropdown = dropdown;
+		m_curState = AccessibleMenuState.ADJUSTING_DROPDOWN;
+		dropdown.StartReading();
+	}
+
+	private void OnToggleSpeechInBackground()
+	{
+				Options.Get().SetBool(Option.ACCESSIBILITY_BACKGROUND_SPEECH, !(Options.Get().GetBool(Option.ACCESSIBILITY_BACKGROUND_SPEECH)));
+	}
+
+
+	private bool GetSpeechinBackgroundState()
+	{
+		return Options.Get().GetBool(Option.ACCESSIBILITY_BACKGROUND_SPEECH);
+	}
+	private void OnToggleSaveBattleLogs()
+	{
+				Options.Get().SetBool(Option.ACCESSIBILITY_SAVE_BATTLE_LOGS, !(Options.Get().GetBool(Option.ACCESSIBILITY_SAVE_BATTLE_LOGS)));
+	}
+
+
+	private bool GetSaveBattleLogsState()
+	{
+		return Options.Get().GetBool(Option.ACCESSIBILITY_SAVE_BATTLE_LOGS);
+	}
+
+
+	public void HandleAccessibleInput()
+	{
+		if (m_curState == AccessibleMenuState.MAIN_MENU)
+		{
+			m_accessibleMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == AccessibleMenuState.ADJUSTING_DROPDOWN)
+		{
+			m_curAccessibleDropdown?.HandleInput();
+		}
+				else if (m_curState == AccessibleMenuState.AUTO_ATTACK_SPEED_MENU)
+		{
+			m_autoAttackSpeedMenu?.HandleAccessibleInput();
+		}
+
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_curState == AccessibleMenuState.MAIN_MENU)
+		{
+			return m_accessibleMenu?.GetHelp();
+		}
+
+		return "";
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/OutstandingDraftTicketDialog.cs b/Assembly-CSharp/OutstandingDraftTicketDialog.cs
index 6744698..9d6a981 100644
--- a/Assembly-CSharp/OutstandingDraftTicketDialog.cs
+++ b/Assembly-CSharp/OutstandingDraftTicketDialog.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using UnityEngine;
@@ -96,6 +97,7 @@ public class OutstandingDraftTicketDialog : DialogBase
 		tweenHashTable.Add("easetype", iTween.EaseType.easeOutBack);
 		iTween.ScaleTo(base.gameObject, tweenHashTable);
 		UniversalInputManager.Get().SetSystemDialogActive(active: true);
+		ReadDialog();
 	}
 
 	protected void EnableFullScreenEffects(bool enable)
@@ -139,4 +141,30 @@ public class OutstandingDraftTicketDialog : DialogBase
 			m_info?.m_callbackOnCancel?.Invoke();
 		}
 	}
+	
+	#region accessibility
+	private AccessibleMenu m_accessibleMenu;
+	private void ReadDialog()
+	{
+		AccessibilityMgr.ShowUI(this);
+		m_accessibleMenu = new AccessibleMenu(this, m_description.Text, null);
+		m_accessibleMenu.AddOption(GameStrings.Get(m_enterButton.m_ButtonText.Text), () => m_enterButton.TriggerRelease());
+		m_accessibleMenu.AddOption(GameStrings.Get(m_cancelButton.m_ButtonText.Text), () => m_cancelButton.TriggerRelease());
+		m_accessibleMenu.StartReading();
+	}
+	public override void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public void onGainedFocus() {
+
+	}
+	public override string GetAccessibleHelp()
+	{
+		return m_accessibleMenu.GetHelp();
+	}
+	#endregion
+
+
 }
diff --git a/Assembly-CSharp/PackOpening.cs b/Assembly-CSharp/PackOpening.cs
index b2f3a2c..aa0dff0 100644
--- a/Assembly-CSharp/PackOpening.cs
+++ b/Assembly-CSharp/PackOpening.cs
@@ -10,8 +10,9 @@ using Hearthstone.Progression;
 using PegasusLettuce;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
-public class PackOpening : MonoBehaviour
+public class PackOpening : MonoBehaviour, AccessibleScreen
 {
 	public PackOpeningBones m_Bones;
 
@@ -218,7 +219,7 @@ public class PackOpening : MonoBehaviour
 		if (StoreButtonOnPackOpeningScreenEnabled())
 		{
 			m_StoreButton.AddEventListener(UIEventType.RELEASE, OnStoreButtonReleased);
-			TelemetryWatcher.WatchFor(TelemetryWatcherWatchType.StoreFromPackOpening);
+		TelemetryWatcher.WatchFor(TelemetryWatcherWatchType.StoreFromPackOpening);
 		}
 		else
 		{
@@ -249,11 +250,11 @@ public class PackOpening : MonoBehaviour
 		{
 			return;
 		}
-		if (m_inSpaceBarHeldDownModeTimer >= 0f && Time.realtimeSinceStartup - m_inSpaceBarHeldDownModeTimer >= 0.5f)
-		{
-			m_isAutoOpenPackMode = true;
-			m_inSpaceBarHeldDownModeTimer = -1f;
-		}
+			if (m_inSpaceBarHeldDownModeTimer >= 0f && Time.realtimeSinceStartup - m_inSpaceBarHeldDownModeTimer >= 0.5f)
+			{
+				m_isAutoOpenPackMode = true;
+				m_inSpaceBarHeldDownModeTimer = -1f;
+			}
 		if (m_isAutoOpenPackMode)
 		{
 			if (!Application.isFocused)
@@ -338,22 +339,22 @@ public class PackOpening : MonoBehaviour
 							if (!(unopenedPack == null) && unopenedPack.GetCount() > 0)
 							{
 								value = unopenedPack;
-								break;
-							}
+							break;
 						}
 					}
 				}
-				m_autoOpenPending = true;
-				m_director.FinishPackOpen();
+				}
+			m_autoOpenPending = true;
+			m_director.FinishPackOpen();
 				m_autoOpenPackCoroutine = StartCoroutine(OpenNextPackWhenReady(value));
-			}
+		}
 		}
 		else if (PackOpeningDirector.QuickPackOpeningAllowed)
 		{
 			if (!m_director.IsMassPackOpening() && !m_director.IsCatchupPackOpening())
 			{
-				m_director.ForceRevealRandomCard();
-			}
+			m_director.ForceRevealRandomCard();
+		}
 			else
 			{
 				if (m_director.IsMassPackOpeningHighlightsContinueButtonShowing())
@@ -383,8 +384,8 @@ public class PackOpening : MonoBehaviour
 	{
 		if (HoldSpaceToOpenPacksEnabled())
 		{
-			if (InputCollection.GetKeyUp(KeyCode.Space))
-			{
+		if (InputCollection.GetKeyUp(KeyCode.Space))
+		{
 				if (m_draggedPack != null && (m_isDoingAnim || m_draggedPack.GetCount() >= m_massPackOpeningHooverChunkSize))
 				{
 					TriggerMassPackOpeningWithSpaceBar();
@@ -415,11 +416,11 @@ public class PackOpening : MonoBehaviour
 				m_isAutoOpenPackMode = false;
 				m_inSpaceBarHeldDownModeTimer = -1f;
 				return result;
-			}
-			if (InputCollection.GetKeyDown(KeyCode.Space))
-			{
+		}
+		if (InputCollection.GetKeyDown(KeyCode.Space))
+		{
 				m_inSpaceBarHeldDownModeTimer = Time.realtimeSinceStartup;
-			}
+		}
 		}
 		else if (InputCollection.GetKeyUp(KeyCode.Space))
 		{
@@ -935,9 +936,9 @@ public class PackOpening : MonoBehaviour
 			num = pack.GetBoosterId();
 			m_packOpeningStartTime = Time.realtimeSinceStartup;
 			m_packOpeningId = num;
-			m_director.SetNumPacksOpened(numPacks);
 			BoosterPackUtils.OpenBooster(num, numPacks);
 		}
+			m_director.SetNumPacksOpened(numPacks);
 		m_InputBlocker.SetActive(value: true);
 		if (m_autoOpenPackCoroutine != null)
 		{
@@ -949,36 +950,43 @@ public class PackOpening : MonoBehaviour
 		BnetBar.Get().HideCurrencyFrames();
 		if (GameUtils.IsFakePackOpeningEnabled())
 		{
-			StartCoroutine(OnFakeBoosterOpened());
+			StartCoroutine(OnFakeBoosterOpened(pack.GetBoosterId(), numPacks));
 		}
 		m_UnopenedPackScroller.Pause(pause: true);
 	}
 
-	private IEnumerator OnFakeBoosterOpened()
+	private IEnumerator OnFakeBoosterOpened(int boosterId, int numPacks)
 	{
 		float seconds = UnityEngine.Random.Range(0f, 1f);
 		yield return new WaitForSeconds(seconds);
 		List<NetCache.BoosterCard> list = new List<NetCache.BoosterCard>();
-		NetCache.BoosterCard boosterCard = new NetCache.BoosterCard();
-		boosterCard.Def.Name = "CS1_042";
-		boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
-		list.Add(boosterCard);
-		boosterCard = new NetCache.BoosterCard();
-		boosterCard.Def.Name = "CS1_129";
-		boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
-		list.Add(boosterCard);
-		boosterCard = new NetCache.BoosterCard();
-		boosterCard.Def.Name = "EX1_050";
-		boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
-		list.Add(boosterCard);
-		boosterCard = new NetCache.BoosterCard();
-		boosterCard.Def.Name = "EX1_105";
-		boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
-		list.Add(boosterCard);
-		boosterCard = new NetCache.BoosterCard();
-		boosterCard.Def.Name = "EX1_350";
-		boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
-		list.Add(boosterCard);
+		for (int i = 0; i < numPacks; ++i)
+		{
+			NetCache.BoosterCard boosterCard = new NetCache.BoosterCard();
+			boosterCard.Def.Name = "CS1_042";
+			boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
+			list.Add(boosterCard);
+			boosterCard = new NetCache.BoosterCard();
+			boosterCard.Def.Name = "CS1_129";
+			boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
+			list.Add(boosterCard);
+			boosterCard = new NetCache.BoosterCard();
+			boosterCard.Def.Name = "EX1_050";
+			boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
+			list.Add(boosterCard);
+			boosterCard = new NetCache.BoosterCard();
+			boosterCard.Def.Name = "EX1_105";
+			boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
+			list.Add(boosterCard);
+			boosterCard = new NetCache.BoosterCard();
+			boosterCard.Def.Name = "EX1_350";
+			boosterCard.Def.Premium = TAG_PREMIUM.NORMAL;
+			list.Add(boosterCard);
+		}
+
+		//
+		m_director.Play(boosterId);
+		m_autoOpenPending = false;
 		m_director.OnBoosterOpened(list, isCatchupPack: false);
 	}
 
@@ -986,11 +994,11 @@ public class PackOpening : MonoBehaviour
 	{
 		if (!(m_draggedPack == null))
 		{
-			UnopenedPack creatorPack = m_draggedPack.GetCreatorPack();
-			int count = m_draggedPack.GetCount();
-			m_draggedPack.RemoveBooster(count);
-			creatorPack.AddBoosters(count);
-		}
+		UnopenedPack creatorPack = m_draggedPack.GetCreatorPack();
+		int count = m_draggedPack.GetCount();
+		m_draggedPack.RemoveBooster(count);
+		creatorPack.AddBoosters(count);
+	}
 	}
 
 	private void UpdatePack(UnopenedPack pack, NetCache.BoosterStack boosterStack)
@@ -1025,8 +1033,8 @@ public class PackOpening : MonoBehaviour
 			component.SetDragTolerance(m_DragTolerance);
 			if ((bool)m_isOnMobile)
 			{
-				component.AddEventListener(UIEventType.PRESS, OnUnopenedPackPress);
-				component.AddEventListener(UIEventType.DRAG, OnUnopenedPackDrag);
+			component.AddEventListener(UIEventType.PRESS, OnUnopenedPackPress);
+			component.AddEventListener(UIEventType.DRAG, OnUnopenedPackDrag);
 			}
 			else
 			{
@@ -1123,10 +1131,10 @@ public class PackOpening : MonoBehaviour
 	{
 		if (!(m_draggedPack == null))
 		{
-			m_UnopenedPackScroller.Pause(pause: false);
-			m_draggedPack.GetCreatorPack().ReleaseDraggedPack();
-			m_draggedPack = null;
-		}
+		m_UnopenedPackScroller.Pause(pause: false);
+		m_draggedPack.GetCreatorPack().ReleaseDraggedPack();
+		m_draggedPack = null;
+	}
 	}
 
 	private void UpdateDraggedPack()
@@ -1155,18 +1163,18 @@ public class PackOpening : MonoBehaviour
 				StopHooverCoroutine();
 			}
 		}
-		Vector3 position = m_draggedPack.transform.position;
+			Vector3 position = m_draggedPack.transform.position;
 		if (!m_isAutoOpenPackMode && UniversalInputManager.Get().GetInputHitInfo(GameLayer.DragPlane.LayerBit(), out var hitInfo))
-		{
-			position.x = hitInfo.point.x;
-			position.z = hitInfo.point.z;
-			m_draggedPack.transform.position = position;
-		}
+			{
+				position.x = hitInfo.point.x;
+				position.z = hitInfo.point.z;
+				m_draggedPack.transform.position = position;
+			}
 		if (InputCollection.GetMouseButtonUp(0) && !m_isAutoOpenPackMode)
-		{
-			DropPack();
+			{
+				DropPack();
+			}
 		}
-	}
 
 	private void SetPackVariablesInPlayMaker(UnopenedPack sourceStack, UnopenedPack heldStack)
 	{
@@ -1293,11 +1301,17 @@ public class PackOpening : MonoBehaviour
 		CreateDirector();
 		LayoutPacks(animate: true);
 		BnetBar.Get().RefreshCurrency();
+		ReadChoosePack();
 	}
 
 	private void ShowHintOnUnopenedPack()
 	{
-		if (!m_shown || Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) || !UserAttentionManager.CanShowAttentionGrabber("PackOpening.ShowHintOnUnopenedPack"))
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// This is a visual notification
+			return;
+		}
+		if (!m_shown || Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) || !UserAttentionManager.CanShowAttentionGrabber(true, "PackOpening.ShowHintOnUnopenedPack"))
 		{
 			return;
 		}
@@ -1337,7 +1351,7 @@ public class PackOpening : MonoBehaviour
 
 	private void ShowHintOnSlot()
 	{
-		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("PackOpening.ShowHintOnSlot"))
+		if (!Options.Get().GetBool(Option.HAS_OPENED_BOOSTER, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "PackOpening.ShowHintOnSlot"))
 		{
 			if (m_hintArrow == null)
 			{
@@ -1411,9 +1425,11 @@ public class PackOpening : MonoBehaviour
 				unopenedPack.Value.SetEnabled(enabled: true);
 			}
 		}
+
+		AccessibilityOnUpdateUIEvents();
 	}
 
-	private void UnregisterUIEvents()
+    private void UnregisterUIEvents()
 	{
 		m_enableBackButton = false;
 		m_BackButton.SetEnabled(enabled: false);
@@ -1584,7 +1600,7 @@ public class PackOpening : MonoBehaviour
 		return true;
 	}
 
-	private void AutomaticallyOpenPack()
+	private void AutomaticallyOpenPack(UnopenedPack pack = null)
 	{
 		if (PopupDisplayManager.Get().IsShowing || PopupDisplayManager.Get().RedundantNDERerollPopups.IsWaitingToShow())
 		{
@@ -1592,22 +1608,27 @@ public class PackOpening : MonoBehaviour
 			return;
 		}
 		HideUnopenedPackTooltip();
-		UnopenedPack value = null;
-		if (!m_unopenedPacks.TryGetValue(m_lastOpenedBoosterId, out value) || value.GetCount() == 0)
+		UnopenedPack value = pack;
+		if (value == null)
 		{
-			foreach (int sortedPackId in m_sortedPackIds)
+			// Normal HS flow - This is not used by HSA since we specifically pass a pack in
+			if (!m_unopenedPacks.TryGetValue(m_lastOpenedBoosterId, out value) || value.GetCount() == 0)
 			{
-				if (m_unopenedPacks.ContainsKey(sortedPackId))
+				foreach (int sortedPackId in m_sortedPackIds)
 				{
-					UnopenedPack unopenedPack = m_unopenedPacks[sortedPackId];
-					if (!(unopenedPack == null) && unopenedPack.GetCount() > 0)
+					if (m_unopenedPacks.ContainsKey(sortedPackId))
 					{
-						value = unopenedPack;
-						break;
+						UnopenedPack unopenedPack = m_unopenedPacks[sortedPackId];
+						if (!(unopenedPack == null) && unopenedPack.GetCount() > 0)
+						{
+							value = unopenedPack;
+							break;
+						}
 					}
 				}
 			}
 		}
+
 		if (!(value == null) && value.CanOpenPack())
 		{
 			if (m_draggedPack != null || m_InputBlocker.activeSelf)
@@ -1623,7 +1644,7 @@ public class PackOpening : MonoBehaviour
 			UpdateUIEvents();
 			m_DragPlane.SetActive(value: false);
 		}
-	}
+		}
 
 	private void SpaceToHoover(UnopenedPack packToOpen)
 	{
@@ -1796,7 +1817,7 @@ public class PackOpening : MonoBehaviour
 		if (packToOpen.GetCount() < m_massPackOpeningHooverChunkSize)
 		{
 			AutomaticallyOpenPack();
-		}
+	}
 		else if (m_isAutoOpenPackMode)
 		{
 			SpaceToHoover(packToOpen);
@@ -2388,4 +2409,184 @@ public class PackOpening : MonoBehaviour
 	{
 		GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.PLAYER_FLAGS, GameSaveKeySubkeyId.PLAYER_FLAGS_HAS_SEEN_MASS_PACK_OPENING_TOOLTIP, 1L));
 	}
+
+    #region Accessibility
+	private enum AccessibleState { LOADING, CHOOSING_PACK };
+
+	private AccessibleState m_curAccessibleState;
+	private AccessibleListOfItems<AccessibleUnopenedPack> m_accessiblePacks;
+
+    private void AccessibilityOnUpdateUIEvents()
+    {
+		AccessibilityMgr.SetScreen(this);
+    }
+
+    private void ReadChoosePack()
+    {
+		m_curAccessibleState = AccessibleState.CHOOSING_PACK;
+
+		if (GetNumUnopenedPacks() == 0)
+        {
+			GoBack();
+			return;
+        }
+
+		if (m_accessiblePacks != null && m_accessiblePacks.Count == GetNumUnopenedPacks())
+        {
+			m_accessiblePacks.StartReading();
+			return;
+        }
+
+		var unopenedPacks = GetSortedUnopenedPacks();
+		var accessiblePacks = new List<AccessibleUnopenedPack>();
+
+        foreach (var pack in unopenedPacks)
+        {
+			if (pack.GetCount() > 0)
+            {
+                accessiblePacks.Add(new AccessibleUnopenedPack(this, pack));
+            }
+        }
+
+		m_accessiblePacks = new AccessibleListOfItems<AccessibleUnopenedPack>(this, accessiblePacks);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.GLOBAL_OPEN_PACKS));
+		m_accessiblePacks.StartReading();
+        AccessibilityUtils.CenterScrollbarAroundObject(m_UnopenedPackScroller, m_accessiblePacks.GetItemBeingRead().GetUnopenedPack().gameObject);
+    }
+
+    private List<UnopenedPack> GetSortedUnopenedPacks()
+    {
+		// Index by game object to compare
+		var gameObjectIndex = new Dictionary<GameObject, int>();
+		var spacedObjects = m_UnopenedPackContainer.m_Objects;
+		for (var i = 0; i < spacedObjects.Count; i++)
+        {
+			var spacedObject = spacedObjects[i];
+			if (spacedObject != null && spacedObject.m_Object != null)
+            {
+                gameObjectIndex.Add(spacedObject.m_Object, i);
+            }
+        }
+
+		// Use index to sort
+		var ret = new List<UnopenedPack>();
+		ret.AddRange(m_unopenedPacks.Values);
+		ret.RemoveAll(p => p.GetCount() == 0);
+		ret.Sort((a, b) => gameObjectIndex[a.gameObject] - gameObjectIndex[b.gameObject]);
+
+		return ret;
+    }
+
+    private int GetNumUnopenedPacks()
+    {
+		int ret = 0;
+
+		foreach (var entry in m_unopenedPacks)
+        {
+			if (entry.Value.GetCount() > 0)
+            {
+				ret++;
+            }
+        }
+
+		return ret;
+    }
+
+    private bool FinishedLoadingPacks()
+    {
+        foreach (var pack in m_unopenedPacksLoading)
+        {
+			if (pack.Value)
+            {
+				return false;
+            }
+        }
+
+		return true;
+    }
+
+    public void HandleInput()
+    {
+		if (m_curAccessibleState == AccessibleState.LOADING)
+        {
+			if (FinishedLoadingPacks())
+            {
+				ReadChoosePack();
+				return;
+            }
+        }
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_PACK)
+        {
+			if (AccessibleKey.CONFIRM.IsPressed())
+            {
+				// TODO: Locked, open, etc
+				TryOpenPack();
+            }
+			else if (AccessibleKey.PACK_OPENING_MASS_OPEN_PACK.IsPressed())
+			{
+				TryMassOpenPack();
+			}
+			else if (AccessibleKey.BACK.IsPressed())
+            {
+				m_BackButton.TriggerRelease();
+            }
+			else if (m_accessiblePacks.HandleAccessibleInput())
+			{
+				AccessibilityUtils.CenterScrollbarAroundObject(m_UnopenedPackScroller, m_accessiblePacks.GetItemBeingRead().GetUnopenedPack().gameObject);
+			}
+        }
+    }
+
+    private void TryOpenPack()
+    {
+		var curPack = m_accessiblePacks.GetItemBeingRead();
+
+		if (curPack.IsLocked())
+        {
+			AccessibilityMgr.Output(this, curPack.GetLockedRibbonText());
+        }
+		else
+        {
+			AutomaticallyOpenPack(curPack.GetUnopenedPack());
+        }
+    }
+
+	public void TryMassOpenPack()
+	{
+		var curPack = m_accessiblePacks.GetItemBeingRead();
+		if (curPack.IsLocked())
+		{
+			AccessibilityMgr.Output(this, curPack.GetLockedRibbonText());
+		}
+		else if (curPack.GetUnopenedPack().GetCount() == 1)
+		{
+			return;
+		}
+		else
+		{
+			var maxQty = Math.Min(MassPackOpeningPackLimit(curPack.GetUnopenedPack().GetBoosterId() ), curPack.GetUnopenedPack().GetCount());
+			AccessibleMassPackOpeningQuantityPrompt.show(maxQty, (qty) => OpenBooster(curPack.GetUnopenedPack(), qty), m_accessiblePacks.StartReading);
+		}
+	}
+
+
+    public string GetHelp()
+    {
+		if (m_curAccessibleState == AccessibleState.LOADING)
+        {
+			return LocalizedText.GLOBAL_LOADING;
+        }
+		else if (m_curAccessibleState == AccessibleState.CHOOSING_PACK)
+        {
+			return m_accessiblePacks?.GetHelp(true);
+        }
+
+		return "";
+    }
+
+    public void OnGainedFocus()
+    {
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/PackOpeningButton.cs b/Assembly-CSharp/PackOpeningButton.cs
index b9b0c5f..748eac9 100644
--- a/Assembly-CSharp/PackOpeningButton.cs
+++ b/Assembly-CSharp/PackOpeningButton.cs
@@ -6,6 +6,9 @@ public class PackOpeningButton : BoxMenuButton
 
 	public GameObject m_countFrame;
 
+	// Accessibility
+	public int m_numPacks;
+
 	public string GetGetPackCount()
 	{
 		return m_count.Text;
@@ -13,6 +16,8 @@ public class PackOpeningButton : BoxMenuButton
 
 	public void SetPackCount(int packs)
 	{
+		m_numPacks = packs;
+
 		if (!(m_countFrame == null) && !(m_count == null))
 		{
 			if (packs <= 0)
diff --git a/Assembly-CSharp/PackOpeningCard.cs b/Assembly-CSharp/PackOpeningCard.cs
index 2d173ae..e09f177 100644
--- a/Assembly-CSharp/PackOpeningCard.cs
+++ b/Assembly-CSharp/PackOpeningCard.cs
@@ -39,13 +39,13 @@ public class PackOpeningCard : MonoBehaviour
 
 	private LettucePackComponent m_mercenaryPackComponent;
 
-	private TAG_PREMIUM m_premium;
+	internal TAG_PREMIUM m_premium;
 
 	private EntityDef m_entityDef;
 
 	private Actor m_actor;
 
-	private PackOpeningCardRarityInfo m_rarityInfo;
+	internal PackOpeningCardRarityInfo m_rarityInfo;
 
 	private Spell m_spell;
 
@@ -65,7 +65,7 @@ public class PackOpeningCard : MonoBehaviour
 
 	private bool m_revealed;
 
-	private bool m_isNew;
+	internal bool m_isNew;
 
 	private List<RevealedListener> m_revealedListeners = new List<RevealedListener>();
 
@@ -240,9 +240,9 @@ public class PackOpeningCard : MonoBehaviour
 			OnPressNoSound(null);
 		}
 		else
-		{
-			OnPress(null);
-		}
+	{
+		OnPress(null);
+	}
 	}
 
 	public void ShowRarityGlow()
@@ -359,9 +359,9 @@ public class PackOpeningCard : MonoBehaviour
 			else if (m_boosterCard != null)
 			{
 				AssetLoader.Get().InstantiatePrefab(ActorNames.GetHandActor(m_entityDef, m_premium), OnActorLoaded, null, AssetLoadingOptions.IgnorePrefabPosition);
-				CollectibleCard card = CollectionManager.Get().GetCard(m_entityDef.GetCardId(), m_premium);
-				m_isNew = card.SeenCount < 1 && card.OwnedCount < 2;
-			}
+					CollectibleCard card = CollectionManager.Get().GetCard(m_entityDef.GetCardId(), m_premium);
+					m_isNew = card.SeenCount < 1 && card.OwnedCount < 2;
+				}
 			else
 			{
 				Debug.LogError($"PackOpeningCard.OnFullDefLoaded() - No card data provided \"{cardId}\"");
@@ -373,10 +373,10 @@ public class PackOpeningCard : MonoBehaviour
 	{
 		if (go == null)
 		{
-			Debug.LogError($"PackOpeningCard.OnActorLoaded() - FAILED to load actor \"{assetRef}\"");
+            Debug.LogError($"PackOpeningCard.OnActorLoaded() - FAILED to load actor \"{assetRef}\"");
 			return;
 		}
-		Actor component = go.GetComponent<Actor>();
+        Actor component = go.GetComponent<Actor>();
 		if (component == null)
 		{
 			Debug.LogError($"PackOpeningCard.OnActorLoaded() - ERROR actor \"{base.name}\" has no Actor component");
@@ -871,7 +871,7 @@ public class PackOpeningCard : MonoBehaviour
 
 	private void ShowClassName()
 	{
-		string className = GetClassName();
+		string className = GetClassName(m_entityDef);
 		UberText[] componentsInChildren = m_ClassNameSpell.GetComponentsInChildren<UberText>(includeInactive: true);
 		foreach (UberText uberText in componentsInChildren)
 		{
@@ -892,12 +892,12 @@ public class PackOpeningCard : MonoBehaviour
 		}
 	}
 
-	private string GetClassName()
+	internal static string GetClassName(EntityDef entityDef)
 	{
-		TAG_CLASS @class = m_entityDef.GetClass();
-		if (m_entityDef.IsMultiClass())
+		TAG_CLASS @class = entityDef.GetClass();
+		if (entityDef.IsMultiClass())
 		{
-			return GetFamilyClassNames();
+			return GetFamilyClassNames(entityDef);
 		}
 		if (@class == TAG_CLASS.NEUTRAL)
 		{
@@ -906,22 +906,22 @@ public class PackOpeningCard : MonoBehaviour
 		return GameStrings.GetClassName(@class);
 	}
 
-	private string GetFamilyClassNames()
+	internal static string GetFamilyClassNames(EntityDef entityDef)
 	{
-		if (m_entityDef.HasTag(GAME_TAG.GRIMY_GOONS))
+		if (entityDef.HasTag(GAME_TAG.GRIMY_GOONS))
 		{
 			return GameStrings.Get("GLUE_GOONS_CLASS_NAMES");
 		}
-		if (m_entityDef.HasTag(GAME_TAG.JADE_LOTUS))
+		if (entityDef.HasTag(GAME_TAG.JADE_LOTUS))
 		{
 			return GameStrings.Get("GLUE_LOTUS_CLASS_NAMES");
 		}
-		if (m_entityDef.HasTag(GAME_TAG.KABAL))
+		if (entityDef.HasTag(GAME_TAG.KABAL))
 		{
 			return GameStrings.Get("GLUE_KABAL_CLASS_NAMES");
 		}
 		List<TAG_CLASS> list = new List<TAG_CLASS>();
-		m_entityDef.GetClasses(list);
+		entityDef.GetClasses(list);
 		if (list.Count() == 10)
 		{
 			return GameStrings.Get("GLUE_PACK_OPENING_ALL_CLASSES");
diff --git a/Assembly-CSharp/PackOpeningDirector.cs b/Assembly-CSharp/PackOpeningDirector.cs
index 3203b40..52d489f 100644
--- a/Assembly-CSharp/PackOpeningDirector.cs
+++ b/Assembly-CSharp/PackOpeningDirector.cs
@@ -13,9 +13,10 @@ using PegasusLettuce;
 using PegasusUtil;
 using Shared.UI.Scripts.Carousel;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class PackOpeningDirector : MonoBehaviour
+public class PackOpeningDirector : MonoBehaviour, AccessibleUI
 {
 	private struct OriginalTransformValues
 	{
@@ -186,7 +187,8 @@ public class PackOpeningDirector : MonoBehaviour
 		}
 	}
 
-	public void Play(int boosterId, float timeToRegisterPackOpening, int packOpeningId)
+	// -1,-1 is because of testing (to avoid telemetry)
+	public void Play(int boosterId, float timeToRegisterPackOpening=-1, int packOpeningId=-1)
 	{
 		if (!m_playing)
 		{
@@ -213,9 +215,9 @@ public class PackOpeningDirector : MonoBehaviour
 		{
 			if (!PackOpening.Get().MassPackOpeningEnabled())
 			{
-				Debug.LogError($"PackOpeningDirector.OnBoosterOpened() - Not enough PackOpeningCards! Received {cards.Count} cards. There are only {5} hidden cards.");
-				return;
-			}
+			Debug.LogError($"PackOpeningDirector.OnBoosterOpened() - Not enough PackOpeningCards! Received {cards.Count} cards. There are only {5} hidden cards.");
+			return;
+		}
 			UseMassPackOpeningFlow();
 		}
 		if (m_useMassPackOpeningFlow)
@@ -240,8 +242,8 @@ public class PackOpeningDirector : MonoBehaviour
 		}
 		if (!m_useMassPackOpeningFlow && !m_useCatchupPackOpeningFlow)
 		{
-			StartCoroutine(m_hiddenCards.AttachBoosterCards(cards));
-		}
+		StartCoroutine(m_hiddenCards.AttachBoosterCards(cards));
+	}
 		else if (m_useCatchupPackOpeningFlow)
 		{
 			cards.Sort(delegate(NetCache.BoosterCard lhs, NetCache.BoosterCard rhs)
@@ -253,6 +255,8 @@ public class PackOpeningDirector : MonoBehaviour
 			SetupCatchupPackCardsFalling(cards);
 			SetupCatchupPackCarousel(cards);
 			SetupCatchupPackExpansionCollectionStats(cards);
+
+			m_sortedCatchupCards = cards;
 		}
 	}
 
@@ -298,11 +302,12 @@ public class PackOpeningDirector : MonoBehaviour
 			}
 			else
 			{
-				m_hiddenCards.Dissipate();
+			m_hiddenCards.Dissipate();
 			}
 			this.OnDoneOpeningPack?.Invoke();
 			HideKeywordTooltips();
 		}
+		AccessibilityMgr.HideUI(this);
 	}
 
 	public void ForceRevealRandomCard()
@@ -341,11 +346,11 @@ public class PackOpeningDirector : MonoBehaviour
 		m_spellPlayMaker = m_activePackFxSpell.GetPlayMaker();
 		if (m_useMassPackOpeningFlow)
 		{
-			PlayMakerFSM component = spell.GetComponent<PlayMakerFSM>();
-			if (component != null)
-			{
-				component.FsmVariables.GetFsmGameObject("PackOpeningDirector").Value = base.gameObject;
-			}
+		PlayMakerFSM component = spell.GetComponent<PlayMakerFSM>();
+		if (component != null)
+		{
+			component.FsmVariables.GetFsmGameObject("PackOpeningDirector").Value = base.gameObject;
+		}
 		}
 		else
 		{
@@ -363,8 +368,13 @@ public class PackOpeningDirector : MonoBehaviour
 			CreateSkipHelper.QueueSkipScreenAtBox();
 		}
 		float timeTillAnimationStart = Time.realtimeSinceStartup - m_initializePackOpeningAnimationStartTime;
+
+		if (packOpeningId != -1)
+		{
+			// We need to fake this during tests -> don't send telemetry though
 		TelemetryManager.Client().SendPackOpening(timeToRegisterPackOpening, timeTillAnimationStart, packOpeningId, m_numPacksOpened);
-		BlizzardAttributionManager.Get().SendEvent_PackOpen(packOpeningId);
+      BlizzardAttributionManager.Get().SendEvent_PackOpen(packOpeningId);
+		}
 		m_activePackFxSpell.ActivateState(SpellStateType.ACTION);
 		void Callback(AssetReference assetRef, GameObject go, object callbackData)
 		{
@@ -396,11 +406,16 @@ public class PackOpeningDirector : MonoBehaviour
 		}
 		else
 		{
-			m_hiddenCards.SetInputEnabled(enable: true);
-			m_hiddenCards.EnableReveal();
-			AttachCardsToCarousel();
+		m_hiddenCards.SetInputEnabled(enable: true);
+		m_hiddenCards.EnableReveal();
+		AttachCardsToCarousel();
+
+		if (!m_useCatchupPackOpeningFlow)
+		{
+			ReadCards();
 		}
 	}
+	}
 
 	private IEnumerator DoMassPackOpeningInitialAnimations()
 	{
@@ -412,6 +427,7 @@ public class PackOpeningDirector : MonoBehaviour
 				yield return null;
 			}
 			m_massPackOpeningHighlights.HideCardExplosionAnimation();
+
 			ShowNextSetOfMassPackOpeningHighlights();
 		}
 	}
@@ -571,6 +587,8 @@ public class PackOpeningDirector : MonoBehaviour
 	private void OnDoneButtonShown(Spell spell, object userData)
 	{
 		m_doneButton.AddEventListener(UIEventType.RELEASE, OnDoneButtonPressed);
+
+		AccessibilityMgr.Output(this, GetAccessibleHelp());
 	}
 
 	private void HideDoneButton()
@@ -581,7 +599,7 @@ public class PackOpeningDirector : MonoBehaviour
 		Spell component = m_doneButton.m_button.GetComponent<Spell>();
 		if (!m_useMassPackOpeningFlow)
 		{
-			component.AddFinishedCallback(OnDoneButtonHidden);
+		component.AddFinishedCallback(OnDoneButtonHidden);
 		}
 		component.ActivateState(SpellStateType.DEATH);
 	}
@@ -597,8 +615,8 @@ public class PackOpeningDirector : MonoBehaviour
 		HideKeywordTooltips();
 		if (!m_useMassPackOpeningFlow)
 		{
-			FinishPackOpen();
-		}
+		FinishPackOpen();
+	}
 	}
 
 	private void HideKeywordTooltips()
@@ -622,7 +640,7 @@ public class PackOpeningDirector : MonoBehaviour
 		}
 		else
 		{
-			m_hiddenCards.RemoveOnOverWhileFlippedListeners();
+		m_hiddenCards.RemoveOnOverWhileFlippedListeners();
 		}
 		TooltipPanelManager.Get().HideKeywordHelp();
 	}
@@ -635,7 +653,7 @@ public class PackOpeningDirector : MonoBehaviour
 	private void OnCardRevealed(object userData, EventArgs eventArgs)
 	{
 		PackOpeningCard packOpeningCard = (PackOpeningCard)userData;
-		if (packOpeningCard.GetEntityDef().GetRarity() == TAG_RARITY.LEGENDARY && packOpeningCard.GetActor() != null)
+		if (!GameUtils.IsFakePackOpeningEnabled() && packOpeningCard.GetEntityDef().GetRarity() == TAG_RARITY.LEGENDARY && packOpeningCard.GetActor() != null)
 		{
 			if (packOpeningCard.GetActor().GetPremium() == TAG_PREMIUM.GOLDEN)
 			{
@@ -646,6 +664,11 @@ public class PackOpeningDirector : MonoBehaviour
 				BnetPresenceMgr.Get().SetGameField(4u, packOpeningCard.GetCardId() + ",0");
 			}
 		}
+
+		// a11y
+		AccessibilityOnRevealedCard(packOpeningCard);
+		// a11y
+
 		m_cardsPendingReveal--;
 		if (m_cardsPendingReveal > 0)
 		{
@@ -656,6 +679,8 @@ public class PackOpeningDirector : MonoBehaviour
 			if (m_massPackOpeningHighlights != null && m_massPackOpeningHiddenCards.AreAllCardsRevealed())
 			{
 				m_massPackOpeningHighlights.ShowContinueButton(show: true);
+
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM));
 			}
 		}
 		else
@@ -714,6 +739,8 @@ public class PackOpeningDirector : MonoBehaviour
 		m_cardsPendingReveal = 5;
 		m_massPackOpeningHiddenCards.SetInputEnabled(enable: true);
 		m_massPackOpeningHiddenCards.EnableReveal();
+
+		ReadCards();
 	}
 
 	public void TriggerCardFlyIn()
@@ -780,6 +807,7 @@ public class PackOpeningDirector : MonoBehaviour
 	{
 		TooltipPanelManager.Get().HideTooltipPanels();
 		m_massPackOpeningHiddenCards.ResetCards();
+		m_massPackOpeningHiddenCards.OnCardRevealedEvent -= OnCardRevealed;
 		ShowNextSetOfMassPackOpeningHighlights();
 	}
 
@@ -812,6 +840,7 @@ public class PackOpeningDirector : MonoBehaviour
 				m_massPackOpeningSummaryWidget.BindDataModel(dataModel);
 			}
 			m_massPackOpeningSummaryWidget.Show();
+			m_massPackOpeningSummary.ReadSummary();
 		}
 	}
 
@@ -882,6 +911,7 @@ public class PackOpeningDirector : MonoBehaviour
 		else
 		{
 			m_massPackOpeningSummaryWidget.Hide();
+			AccessibilityMgr.HideUI(m_massPackOpeningSummary);
 			FinishMassPackOpen();
 		}
 	}
@@ -1037,6 +1067,8 @@ public class PackOpeningDirector : MonoBehaviour
 				ApplySettingsToRenderers(m_catchupPackPileWidgetComponent.TitleBanner.transform, GameLayer.Default, m_catchupPackCardPileCustomPass.renderLayerMaskOverride);
 			}
 		}
+
+		ReadCards();
 	}
 
 	private void ApplySettingsToRenderers(Transform objectRoot, GameLayer layer, uint renderingLayerMask)
@@ -1262,6 +1294,7 @@ public class PackOpeningDirector : MonoBehaviour
 
 	public void FinishCatchupPackOpen()
 	{
+		AccessibilityMgr.HideUI(this);
 		if (m_catchupPackCardPileCustomPass != null)
 		{
 			m_catchupPackCardPileCustomPass.Unschedule();
@@ -1298,4 +1331,144 @@ public class PackOpeningDirector : MonoBehaviour
 			m_Carousel = null;
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleListOfItems<AccessiblePackOpeningCard> m_accessiblePackOpeningCards;
+
+	private bool m_hasReadMassOpeningIntro = false;
+
+	private List<NetCache.BoosterCard> m_sortedCatchupCards;
+
+	private void ReadCards()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		var accessiblePackOpeningCards = new List<AccessiblePackOpeningCard>();
+
+		if (m_useCatchupPackOpeningFlow)
+		{
+			foreach (var boosterCard in m_sortedCatchupCards)
+			{
+				accessiblePackOpeningCards.Add(new AccessiblePackOpeningCard(this, boosterCard));
+			}
+		}
+		else
+		{
+			foreach(var card in DeterminAppropriateHiddenCards().m_cards)
+			{
+				accessiblePackOpeningCards.Add(new AccessiblePackOpeningCard(this, card));
+			}
+		}
+
+		m_accessiblePackOpeningCards = new AccessibleListOfItems<AccessiblePackOpeningCard>(this, accessiblePackOpeningCards);
+
+		if (m_useMassPackOpeningFlow && !m_hasReadMassOpeningIntro)
+		{
+			AccessibilityMgr.Output(this, m_massPackOpeningHighlights.m_numPacksOpened.Text);
+			AccessibilityMgr.Output(this, GameStrings.Get("GLUE_MASS_PACK_OPEN_HIGHLIGHTS"));
+			m_hasReadMassOpeningIntro = true;
+		}
+
+		m_accessiblePackOpeningCards.StartReading();
+		AccessibleInputMgr.MoveMouseTo(m_accessiblePackOpeningCards.GetItemBeingRead().GetPackOpeningCard());
+    }
+
+	private HiddenCards DeterminAppropriateHiddenCards()
+	{
+		return m_useMassPackOpeningFlow ? m_massPackOpeningHiddenCards : m_hiddenCards;
+	}
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			if (m_useCatchupPackOpeningFlow)
+			{
+				m_catchupPackPileWidgetComponent.TriggerDoneButtonPressed();
+			}
+			else if (m_doneButtonShown)
+            {
+				m_doneButton.TriggerRelease();
+            }
+			else if (m_massPackOpeningHighlights.IsContinueButtonShowing())
+			{
+				MassPackOpeningContinuePressed();
+			}
+			else
+            {
+                TryRevealCard();
+            }
+        }
+		else if (AccessibleKey.SPACE.IsPressed())
+		{
+			if (m_useMassPackOpeningFlow)
+			{
+				MassPackOpeningRevealAllPressed();
+			}
+			else
+			{
+				ForceRevealRandomCard();
+			}
+		}
+		else if (AccessibleKey.READ_TOOLTIP.IsPressed())
+        {
+            AccessibilityUtils.ReadTooltip(this);
+        }
+		else
+        {
+			if (m_accessiblePackOpeningCards?.HandleAccessibleInput() ?? false)
+            {
+				AccessibleInputMgr.MoveMouseTo(m_accessiblePackOpeningCards.GetItemBeingRead().GetPackOpeningCard());
+            }
+        }
+    }
+
+    private void TryRevealCard()
+    {
+		var curCard = m_accessiblePackOpeningCards.GetItemBeingRead().GetPackOpeningCard();
+
+		if (!curCard.IsRevealed())
+		{
+			curCard.ForceReveal();
+		}
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_useCatchupPackOpeningFlow)
+		{
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_PACK_OPENING_CATCHUP_PACK_OPENING_HELP, AccessibleKey.CONFIRM);
+		}
+		else if (m_doneButtonShown || IsMassPackOpeningHighlightsContinueButtonShowing())
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+		else if (m_useMassPackOpeningFlow)
+		{
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_PACK_OPENING_MASS_PACK_OPENING_HELP, AccessibleKey.CONFIRM, AccessibleKey.SPACE);
+		}
+		else
+        {
+			return LocalizationUtils.Format(LocalizationKey.SCREEN_PACK_OPENING_OPEN_CARDS_HELP, AccessibleKey.CONFIRM);
+        }
+    }
+
+	public List<PackOpeningCard> GetRevealedCards()
+    {
+		return m_hiddenCards.m_cards;
+    }
+
+    private void AccessibilityOnRevealedCard(PackOpeningCard revealedCard)
+    {
+		foreach (var card in m_accessiblePackOpeningCards.Items)
+        {
+			if (card.GetPackOpeningCard() == revealedCard)
+            {
+				card.ReadLine();
+            }
+        }
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/PegUIElement.cs b/Assembly-CSharp/PegUIElement.cs
index 8f0c0e0..1fc4918 100644
--- a/Assembly-CSharp/PegUIElement.cs
+++ b/Assembly-CSharp/PegUIElement.cs
@@ -114,6 +114,8 @@ public class PegUIElement : MonoBehaviour
 
 	public virtual void TriggerOver()
 	{
+		Accessibility.AccessibilityUtils.DebugGameObjectInHierarchy(gameObject);
+		if(!Accessibility.AccessibilityMgr.IsAccessibilityEnabled()&&Accessibility.HearthstoneAccessConstants.DEV_MODE) Accessibility.AccessibilityMgr.Output(null,gameObject.name); // will announce object name while hovering over it.
 		if (m_enabled && !m_focused && IsEnabled(UIEventType.ROLLOVER))
 		{
 			PrintLog("OVER", PegUILogLevel.ALL_EVENTS);
@@ -163,6 +165,7 @@ public class PegUIElement : MonoBehaviour
 
 	public virtual void TriggerRelease()
 	{
+		//Accessibility.AccessibilityUtils.DebugGameObjectInHierarchy(gameObject);
 		if (m_enabled && IsEnabled(UIEventType.RELEASE))
 		{
 			PrintLog("RELEASE", PegUILogLevel.ALL_EVENTS);
diff --git a/Assembly-CSharp/Player.cs b/Assembly-CSharp/Player.cs
index b1ab840..b14cc43 100644
--- a/Assembly-CSharp/Player.cs
+++ b/Assembly-CSharp/Player.cs
@@ -297,8 +297,8 @@ public class Player : Entity
 			num2 += GetTag(GAME_TAG.CURRENT_TEMP_SPELLPOWER_PHYSICAL) * num;
 			break;
 		}
+		int tag = ent == this ? 0 : ent.GetTag(GAME_TAG.CURRENT_SPELLPOWER_BASE);
 		int num3 = GetTag(GAME_TAG.CURRENT_TEMP_SPELLPOWER_BASE) * num;
-		int tag = ent.GetTag(GAME_TAG.CURRENT_SPELLPOWER_BASE);
 		return GetTag(GAME_TAG.CURRENT_SPELLPOWER_BASE) - GetTag(GAME_TAG.CURRENT_NEGATIVE_SPELLPOWER) + num2 + num3 + tag;
 	}
 
@@ -1242,12 +1242,12 @@ public class Player : Entity
 					break;
 				}
 				{
-					foreach (Card card in GetHandZone().GetCards())
-					{
-						card.GetActor().TurnOnCollider();
-					}
-					break;
+				foreach (Card card in GetHandZone().GetCards())
+				{
+					card.GetActor().TurnOnCollider();
 				}
+					break;
+			}
 			}
 			if (change.newValue == 1 && change.oldValue == 5 && MulliganManager.Get() != null)
 			{
@@ -1775,4 +1775,13 @@ public class Player : Entity
 			}
 		}
 	}
+
+	#region Accessibility
+
+	public ZoneBattlegroundHeroBuddy GetHeroBuddyZone()
+	{
+		return ZoneMgr.Get().FindZoneOfType<ZoneBattlegroundHeroBuddy>(GetSide());
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/PlayerLeaderboardCard.cs b/Assembly-CSharp/PlayerLeaderboardCard.cs
index 2e493ed..0df5142 100644
--- a/Assembly-CSharp/PlayerLeaderboardCard.cs
+++ b/Assembly-CSharp/PlayerLeaderboardCard.cs
@@ -17,7 +17,7 @@ public class PlayerLeaderboardCard : HistoryItem
 
 	public GameObject m_portraitOverlay;
 
-	private Entity m_playerHeroEntity;
+	internal Entity m_playerHeroEntity;
 
 	public PlayerLeaderboardTeam m_parent;
 
@@ -242,13 +242,13 @@ public class PlayerLeaderboardCard : HistoryItem
 				m_portraitMesh.GetMaterial(1).mainTexture = m_portraitTexture;
 			}
 			Renderer[] componentsInChildren = m_portraitMesh.GetComponentsInChildren<Renderer>();
-			foreach (Renderer renderer in componentsInChildren)
+		foreach (Renderer renderer in componentsInChildren)
+		{
+			if (!renderer.CompareTag(HistoryItem.RENDERER_TAG))
 			{
-				if (!renderer.CompareTag(HistoryItem.RENDERER_TAG))
-				{
-					renderer.GetMaterial().color = Board.Get().m_HistoryTileColor;
-				}
+				renderer.GetMaterial().color = Board.Get().m_HistoryTileColor;
 			}
+		}
 			m_portraitMesh.GetMaterial(1).color = Board.Get().m_HistoryTileColor;
 		}
 		else
@@ -336,4 +336,12 @@ public class PlayerLeaderboardCard : HistoryItem
 		}
 		return gameObject.transform.localPosition.x;
 	}
+
+	#region Accessibility
+
+	internal static int GetPlayerTriples(Entity playerHero)
+	{
+		return playerHero.GetTag(GAME_TAG.PLAYER_TRIPLES);
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/PlayerLeaderboardManager.cs b/Assembly-CSharp/PlayerLeaderboardManager.cs
index d105f67..2dfe4d7 100644
--- a/Assembly-CSharp/PlayerLeaderboardManager.cs
+++ b/Assembly-CSharp/PlayerLeaderboardManager.cs
@@ -87,7 +87,7 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 
 	private bool m_disabled;
 
-	private List<PlayerLeaderboardTeam> m_teams = new List<PlayerLeaderboardTeam>();
+	internal List<PlayerLeaderboardTeam> m_teams = new List<PlayerLeaderboardTeam>();
 
 	private PlayerLeaderboardCard m_currentlyMousedOverTile;
 
@@ -223,7 +223,7 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 		{
 			return;
 		}
-		m_addedTileForPlayerId.Add(playerHeroId);
+			m_addedTileForPlayerId.Add(playerHeroId);
 		int playerTeamId = 0;
 		string text = "";
 		if (GameMgr.Get().IsBattlegroundDuoGame())
@@ -521,12 +521,12 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 			foreach (PlayerLeaderboardCard member in team.Members)
 			{
 				if (GameState.Get().GetPlayerInfoMap().TryGetValue(member.Entity.GetTag(GAME_TAG.PLAYER_ID), out var value) && value != null)
-				{
-					BnetRecentPlayerMgr.Get().AddRecentPlayer(value.GetBnetPlayer(), BnetRecentPlayerMgr.RecentReason.CURRENT_OPPONENT);
-				}
+			{
+				BnetRecentPlayerMgr.Get().AddRecentPlayer(value.GetBnetPlayer(), BnetRecentPlayerMgr.RecentReason.CURRENT_OPPONENT);
 			}
 		}
 	}
+	}
 
 	private void HideAllSwordsDisplay()
 	{
@@ -609,7 +609,7 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 
 	private void OnTurnChanged(int oldTurn, int newTurn, object userdata)
 	{
-		int num = GameState.Get().GetFriendlySidePlayer().GetTag(GAME_TAG.NEXT_OPPONENT_PLAYER_ID);
+		int num = GetNextOpponentId();
 		if (GameState.Get().GetCurrentPlayer().IsFriendlySide())
 		{
 			SetNextOpponent(num);
@@ -644,12 +644,12 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 	}
 
 	public void UpdateDamageCapFX(int oldValue = -1, int newValue = -1, bool forceUpdate = false)
-	{
-		if (GameState.Get() == null || GameState.Get().GetGameEntity() == null)
 		{
-			Debug.Log("[PlayerLeaderboardManager::UpdateDamageCapFX] - Game State/Game Entity is null");
-			return;
-		}
+			if (GameState.Get() == null || GameState.Get().GetGameEntity() == null)
+			{
+				Debug.Log("[PlayerLeaderboardManager::UpdateDamageCapFX] - Game State/Game Entity is null");
+				return;
+			}
 		bool realtimeBaconDamageCapEnabled = GameState.Get().GetGameEntity().GetRealtimeBaconDamageCapEnabled();
 		Spell leaderboardDamageCapFX = Board.Get().m_leaderboardDamageCapFX;
 		if (!m_isLeaderboardDamageCapFXActive)
@@ -769,7 +769,7 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 			componentsInChildren[i].gameObject.transform.localScale = (GameMgr.Get().IsBattlegroundDuoGame() ? LEADERBOARD_TILE_CARD_SCALE_DUOS : LEADERBOARD_TILE_CARD_SCALE);
 		}
 		if (GameMgr.Get().IsBattlegroundDuoGame())
-		{
+			{
 			component.TeamId = entity.GetTag(GAME_TAG.BACON_DUO_TEAM_ID);
 			if (component.TeamId == 0)
 			{
@@ -809,8 +809,8 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 				if (member != null && member.Entity != null && member.Entity.GetTag(GAME_TAG.PLAYER_ID) == playerId)
 				{
 					return member;
-				}
-			}
+		}
+		}
 		}
 		return null;
 	}
@@ -843,7 +843,7 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 	}
 
 	public void AnimateTeamsToPositions(bool animate)
-	{
+		{
 		float num = (GameMgr.Get().IsBattlegroundDuoGame() ? SPACE_BETWEEN_TILES_DUOS : SPACE_BETWEEN_TILES);
 		float num2 = 0f;
 		float num3 = 0f;
@@ -1086,4 +1086,23 @@ public class PlayerLeaderboardManager : CardTileListDisplay
 		}
 		return GameState.Get().GetGameEntity().GetTag(GAME_TAG.BACON_MAX_LEADERBOARD_ARMOR);
 	}
+
+	#region Accessibility
+
+	private int GetNextOpponentId()
+	{
+		return GameState.Get().GetFriendlySidePlayer().GetTag(GAME_TAG.NEXT_OPPONENT_PLAYER_ID);
+	}
+
+	internal PlayerLeaderboardCard GetNextOpponentTile()
+	{
+		return GetTileForPlayerId(GetNextOpponentId());
+	}
+
+	internal PlayerLeaderboardCard GetMyTile()
+	{
+		return GetTileForPlayerId(GameState.Get().GetFriendlyPlayerId());
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/PlayerLeaderboardPlayerOverlay.cs b/Assembly-CSharp/PlayerLeaderboardPlayerOverlay.cs
index fa20d15..712133c 100644
--- a/Assembly-CSharp/PlayerLeaderboardPlayerOverlay.cs
+++ b/Assembly-CSharp/PlayerLeaderboardPlayerOverlay.cs
@@ -72,7 +72,7 @@ public class PlayerLeaderboardPlayerOverlay : MonoBehaviour
 
 	private VisualController m_recentCombatsPanelController;
 
-	private PlayerLeaderboardRecentCombatsPanel m_recentCombatsPanel;
+	internal PlayerLeaderboardRecentCombatsPanel m_recentCombatsPanel;
 
 	private List<PlayerLeaderboardInformationPanel> m_additionalInfoPanels;
 
diff --git a/Assembly-CSharp/PlayerLeaderboardRecentCombatsPanel.cs b/Assembly-CSharp/PlayerLeaderboardRecentCombatsPanel.cs
index 760e004..6d4778a 100644
--- a/Assembly-CSharp/PlayerLeaderboardRecentCombatsPanel.cs
+++ b/Assembly-CSharp/PlayerLeaderboardRecentCombatsPanel.cs
@@ -2,6 +2,7 @@ using System;
 using System.Collections.Generic;
 using Blizzard.T5.Core;
 using UnityEngine;
+using Accessibility;
 
 public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationPanel
 {
@@ -38,7 +39,7 @@ public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationP
 		public bool opponentIsOddManOut;
 	}
 
-	public uint m_maxDisplayItems = 2u;
+	public uint m_maxDisplayItems = MAX_VISIBLE_COMBATS_PER_PANEL;
 
 	public List<GameObject> m_recentActionPlaceholders;
 
@@ -78,6 +79,14 @@ public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationP
 
 	public UberText m_singleTribeWithoutCountName;
 
+	#region Accessibility
+
+	internal static uint MAX_VISIBLE_COMBATS_PER_PANEL = 2u;
+
+	internal string m_accessibleRacesCounter;
+
+	#endregion
+
 	public void Awake()
 	{
 		for (int i = 0; i < m_recentActionPlaceholders.Count; i++)
@@ -249,6 +258,8 @@ public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationP
 			{
 				m_singleTribeWithoutCountWrapper.SetActive(value: true);
 				m_singleTribeWithCountWrapper.SetActive(value: false);
+
+				m_accessibleRacesCounter = GameStrings.Get("GLOBAL_RACE_MIXED_BATTLEGROUNDS");
 			}
 		}
 		else
@@ -257,6 +268,8 @@ public class PlayerLeaderboardRecentCombatsPanel : PlayerLeaderboardInformationP
 			m_singleTribeWithCountWrapper.SetActive(value: true);
 			m_singleTribeWithCountNumber.Text = num2.ToString();
 			m_singleTribeWithCountName.Text = GameStrings.GetRaceNameBattlegrounds(tAG_RACE);
+
+			m_accessibleRacesCounter = AccessibleSpeechUtils.CombineWordsWithColon(m_singleTribeWithCountName.Text, m_singleTribeWithCountNumber.Text);
 		}
 		return true;
 	}
diff --git a/Assembly-CSharp/PopupDisplayManager.cs b/Assembly-CSharp/PopupDisplayManager.cs
index ace3fa2..0177ead 100644
--- a/Assembly-CSharp/PopupDisplayManager.cs
+++ b/Assembly-CSharp/PopupDisplayManager.cs
@@ -10,6 +10,7 @@ using Hearthstone.Login;
 using Hearthstone.Progression;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class PopupDisplayManager : IHasUpdate, IService
 {
@@ -216,7 +217,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 		}
 		if (!SuppressPopupsTemporarily)
 		{
-			s_questPopups.ShowQuestProgressToasts(s_achievementPopups.ProgressedAchieves);
+		s_questPopups.ShowQuestProgressToasts(s_achievementPopups.ProgressedAchieves);
 		}
 		if (GameUtils.IsAnyTransitionActive() || IsShowing)
 		{
@@ -246,7 +247,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 			s_isShowing = true;
 			return;
 		}
-		if (DraftManager.Get() != null && DraftManager.Get().ShowNextArenaPopup(m_popClosedCallback))
+		if (!AccessibilityMgr.IsAccessibilityEnabled() && DraftManager.Get() != null && DraftManager.Get().ShowNextArenaPopup(m_popClosedCallback)) // To be reviewed if we implement arena
 		{
 			this.OnPopupShown();
 			s_isShowing = true;
@@ -446,7 +447,7 @@ public class PopupDisplayManager : IHasUpdate, IService
 		{
 			return false;
 		}
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextRankedIntro"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextRankedIntro"))
 		{
 			return false;
 		}
diff --git a/Assembly-CSharp/PowerProcessor.cs b/Assembly-CSharp/PowerProcessor.cs
index dde1078..5aa4105 100644
--- a/Assembly-CSharp/PowerProcessor.cs
+++ b/Assembly-CSharp/PowerProcessor.cs
@@ -145,11 +145,11 @@ public class PowerProcessor
 				HistoryBlock.Type blockType = m_currentTaskList.GetBlockType();
 				if (sourceEntity != null && sourceEntity.HasTag(GAME_TAG.FAST_BATTLECRY) && blockType == HistoryBlock.Type.POWER)
 				{
-					HistoryManager.Get().CreateFastBigCardFromMetaData(entity);
+					HistoryManager.Get().CreateFastBigCardFromMetaData(m_currentTaskList, entity);
 					return;
 				}
 				int displayTimeMS = ((metaData.Info.Count > 1) ? metaData.Info[1] : 0);
-				HistoryManager.Get().CreatePlayedBigCard(entity, OnBigCardStarted, OnBigCardFinished, fromMetaData: true, countered: false, displayTimeMS);
+				HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, entity, OnBigCardStarted, OnBigCardFinished, fromMetaData: true, countered: false, displayTimeMS);
 			}
 		}
 		else if (metaData.MetaType == HistoryMeta.Type.BEGIN_LISTENING_FOR_TURN_EVENTS)
@@ -1209,7 +1209,7 @@ public class PowerProcessor
 		GameState gameState = GameState.Get();
 		if (gameState == null || gameState.GameScenarioAllowsPowerPrinting())
 		{
-			Log.Power.Print("PowerProcessor.PrepareHistoryForCurrentTaskList() - m_currentTaskList={0}", m_currentTaskList.GetId());
+		Log.Power.Print("PowerProcessor.PrepareHistoryForCurrentTaskList() - m_currentTaskList={0}", m_currentTaskList.GetId());
 		}
 		Network.HistBlockStart blockStart = m_currentTaskList.GetBlockStart();
 		if (blockStart == null)
@@ -1277,14 +1277,14 @@ public class PowerProcessor
 					SetHistoryBlockingTaskList();
 					if (sourceEntity3.IsTitan() && entity6 != null)
 					{
-						HistoryManager.Get().CreatePlayedBigCard(entity6, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
+						HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, entity6, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
 					}
 					else
 					{
-						HistoryManager.Get().CreatePlayedBigCard(sourceEntity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
-					}
+						HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, sourceEntity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered, 0);
 				}
 			}
+			}
 			m_currentTaskList.NotifyHistoryOfAdditionalTargets();
 			break;
 		}
@@ -1329,7 +1329,7 @@ public class PowerProcessor
 				if (ShouldShowPlayedBigCard(sourceEntity2, blockStart))
 				{
 					SetHistoryBlockingTaskList();
-					HistoryManager.Get().CreatePlayedBigCard(sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered: false, 0);
+					HistoryManager.Get().CreatePlayedBigCard(m_currentTaskList, sourceEntity2, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, countered: false, 0);
 				}
 			}
 			m_currentTaskList.NotifyHistoryOfAdditionalTargets();
@@ -1349,7 +1349,7 @@ public class PowerProcessor
 					HistoryManager.Get().CreateTriggerTile(sourceEntity);
 					m_currentTaskList.SetWillCompleteHistoryEntry(set: true);
 					SetHistoryBlockingTaskList();
-					HistoryManager.Get().CreateTriggeredBigCard(sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: true);
+					HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: true);
 				}
 				m_currentTaskList.NotifyHistoryOfAdditionalTargets();
 				break;
@@ -1368,7 +1368,7 @@ public class PowerProcessor
 					if (sourceEntity.GetController() != GameState.Get().GetFriendlySidePlayer() || !sourceEntity.HasTag(GAME_TAG.HISTORY_PROXY_NO_BIG_CARD))
 					{
 						SetHistoryBlockingTaskList();
-						HistoryManager.Get().CreateTriggeredBigCard(entity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
+						HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, entity3, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
 					}
 				}
 				else
@@ -1376,7 +1376,7 @@ public class PowerProcessor
 					if (ShouldShowTriggeredBigCard(sourceEntity))
 					{
 						SetHistoryBlockingTaskList();
-						HistoryManager.Get().CreateTriggeredBigCard(sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
+						HistoryManager.Get().CreateTriggeredBigCard(m_currentTaskList, sourceEntity, OnBigCardStarted, OnBigCardFinished, fromMetaData: false, isSecret: false);
 					}
 					HistoryManager.Get().CreateTriggerTile(sourceEntity);
 				}
@@ -1427,7 +1427,7 @@ public class PowerProcessor
 		m_historyBlocking = false;
 	}
 
-	private bool ShouldShowPlayedBigCard(Entity sourceEntity, Network.HistBlockStart blockStart)
+	internal static bool ShouldShowPlayedBigCard(Entity sourceEntity, Network.HistBlockStart blockStart)
 	{
 		if (!GameState.Get().GetBooleanGameOption(GameEntityOption.USES_BIG_CARDS))
 		{
@@ -1452,7 +1452,7 @@ public class PowerProcessor
 		return false;
 	}
 
-	private bool ShouldShowTriggeredBigCard(Entity sourceEntity)
+	internal static bool ShouldShowTriggeredBigCard(Entity sourceEntity)
 	{
 		if (sourceEntity.GetZone() != TAG_ZONE.HAND)
 		{
@@ -1576,7 +1576,7 @@ public class PowerProcessor
 		m_currentTaskList.DoAllTasks(delegate
 		{
 			EndCurrentTaskList();
-		});
+        });
 	}
 
 	private void EndCurrentTaskList()
@@ -1584,7 +1584,7 @@ public class PowerProcessor
 		GameState gameState = GameState.Get();
 		if (gameState == null || gameState.GameScenarioAllowsPowerPrinting())
 		{
-			Log.Power.Print("PowerProcessor.EndCurrentTaskList() - m_currentTaskList={0}", (m_currentTaskList == null) ? "null" : m_currentTaskList.GetId().ToString());
+		Log.Power.Print("PowerProcessor.EndCurrentTaskList() - m_currentTaskList={0}", (m_currentTaskList == null) ? "null" : m_currentTaskList.GetId().ToString());
 		}
 		if (m_currentTaskList == null)
 		{
diff --git a/Assembly-CSharp/PowerSpellController.cs b/Assembly-CSharp/PowerSpellController.cs
index 38a1d28..77730f6 100644
--- a/Assembly-CSharp/PowerSpellController.cs
+++ b/Assembly-CSharp/PowerSpellController.cs
@@ -2,6 +2,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class PowerSpellController : SpellController
 {
diff --git a/Assembly-CSharp/PowerTask.cs b/Assembly-CSharp/PowerTask.cs
index 361d824..96fdd38 100644
--- a/Assembly-CSharp/PowerTask.cs
+++ b/Assembly-CSharp/PowerTask.cs
@@ -1,8 +1,11 @@
+using System;
 using System.Collections.Generic;
 using PegasusGame;
 
 public class PowerTask
 {
+	public delegate void TaskStartCallback(PowerTask task);
+
 	public delegate void TaskCompleteCallback();
 
 	private Network.PowerHistory m_power;
@@ -11,6 +14,8 @@ public class PowerTask
 
 	private TaskCompleteCallback m_onCompleted;
 
+	private TaskStartCallback m_onStarted;
+
 	public Network.PowerHistory GetPower()
 	{
 		return m_power;
@@ -40,6 +45,11 @@ public class PowerTask
 		m_onCompleted = onComplete;
 	}
 
+	public void SetTaskStartCallback(TaskStartCallback onStart)
+	{
+		m_onStarted = onStart;
+	}
+
 	private bool IsZoneTransition(TAG_ZONE fromZone, TAG_ZONE toZone)
 	{
 		if (IsCompleted())
@@ -95,7 +105,8 @@ public class PowerTask
 
 	public void DoRealTimeTask(List<Network.PowerHistory> powerList, int index)
 	{
-		GameState gameState = GameState.Get();
+        m_onStarted(this);
+        GameState gameState = GameState.Get();
 		switch (m_power.Type)
 		{
 		case Network.PowerType.CREATE_GAME:
@@ -150,10 +161,11 @@ public class PowerTask
 		}
 	}
 
-	public void DoTask()
+    public void DoTask()
 	{
 		if (!m_completed)
 		{
+			m_onStarted(this);
 			GameState gameState = GameState.Get();
 			switch (m_power.Type)
 			{
@@ -234,6 +246,7 @@ public class PowerTask
 	{
 		if (!m_completed)
 		{
+			m_onStarted(this);
 			GameState gameState = GameState.Get();
 			switch (m_power.Type)
 			{
@@ -357,4 +370,61 @@ public class PowerTask
 		}
 		return $"[id={netEntity.ID} cardId={netEntity.CardID} name={entityLogName}]";
 	}
+
+	#region Accessibility
+
+	public bool IsCardTrade(int entityId)
+    {
+		Network.PowerHistory power = GetPower();
+
+		if (power.Type == Network.PowerType.TAG_CHANGE)
+		{
+			Network.HistTagChange histTagChange = (Network.HistTagChange)power;
+			if (histTagChange.Tag == (int)GAME_TAG.IS_USING_TRADE_OPTION && histTagChange.Value == 1)
+			{
+				return true;
+			}
+		}
+		else if (power.Type == Network.PowerType.SHOW_ENTITY)
+        {
+			Network.HistShowEntity histShowEntity = (Network.HistShowEntity)power;
+			var entity = histShowEntity.Entity;
+
+			if (entity != null && entity.ID == entityId)
+            {
+				foreach (var tag in entity.Tags)
+                {
+					if (tag.Name == (int)GAME_TAG.IS_USING_TRADE_OPTION && tag.Value == 1)
+                    {
+						return true;
+                    }
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public bool IsShowStartOfGameCard()
+    {
+		Network.PowerHistory power = GetPower();
+
+		if (power.Type == Network.PowerType.SHOW_ENTITY)
+        {
+			Network.HistShowEntity histShowEntity = (Network.HistShowEntity)power;
+			var entity = histShowEntity.Entity;
+
+            foreach (var tag in entity.Tags)
+            {
+                if (tag.Name == (int)GAME_TAG.START_OF_GAME_KEYWORD && tag.Value == 1)
+                {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/PowerTaskList.cs b/Assembly-CSharp/PowerTaskList.cs
index 2b9a377..dedda90 100644
--- a/Assembly-CSharp/PowerTaskList.cs
+++ b/Assembly-CSharp/PowerTaskList.cs
@@ -4,12 +4,13 @@ using Cysharp.Threading.Tasks;
 using PegasusGame;
 using Unity.Profiling;
 using UnityEngine;
+using Accessibility;
 
 public class PowerTaskList
 {
 	public delegate void CompleteCallback(PowerTaskList taskList, int startIndex, int count, object userData);
 
-	public class DamageInfo
+    public class DamageInfo
 	{
 		public Entity m_entity;
 
@@ -493,6 +494,7 @@ public class PowerTaskList
 		PowerTask powerTask = new PowerTask();
 		powerTask.SetPower(netPower);
 		powerTask.SetTaskCompleteCallback(OnTaskCompleted);
+		powerTask.SetTaskStartCallback(OnTaskStarted);
 		m_tasks.Add(powerTask);
 		return powerTask;
 	}
@@ -550,29 +552,29 @@ public class PowerTaskList
 	{
 		using (s_getSourceEntitiesMarker.Auto())
 		{
-			Network.HistBlockStart blockStart = GetBlockStart();
-			if (blockStart == null)
-			{
-				return null;
-			}
+		Network.HistBlockStart blockStart = GetBlockStart();
+		if (blockStart == null)
+		{
+			return null;
+		}
 			if (!m_sourceEntitiesAreDirty)
 			{
 				return m_sourceEntities;
 			}
 			m_sourceEntities.Clear();
-			List<int> entities = blockStart.Entities;
+		List<int> entities = blockStart.Entities;
 			m_sourceEntities.Capacity = entities.Count;
-			foreach (int item in entities)
+		foreach (int item in entities)
+		{
+			Entity entity = GameState.Get().GetEntity(item);
+			if (entity == null && warnIfNull && !GameState.Get().EntityRemovedFromGame(item))
 			{
-				Entity entity = GameState.Get().GetEntity(item);
-				if (entity == null && warnIfNull && !GameState.Get().EntityRemovedFromGame(item))
-				{
-					string format = $"PowerProcessor.GetSourceEntity() - task list {m_id} has a source entity with id {item} but there is no entity with that id";
-					Log.Power.PrintWarning(format);
-					return null;
-				}
-				m_sourceEntities.Add(entity);
+				string format = $"PowerProcessor.GetSourceEntity() - task list {m_id} has a source entity with id {item} but there is no entity with that id";
+				Log.Power.PrintWarning(format);
+				return null;
 			}
+				m_sourceEntities.Add(entity);
+		}
 			m_sourceEntitiesAreDirty = false;
 			return m_sourceEntities;
 		}
@@ -1533,8 +1535,8 @@ public class PowerTaskList
 		GameState gameState = GameState.Get();
 		if (gameState == null || gameState.GameScenarioAllowsPowerPrinting())
 		{
-			DebugDump(Log.Power);
-		}
+		DebugDump(Log.Power);
+	}
 	}
 
 	public void DebugDump(Logger logger)
@@ -1616,7 +1618,7 @@ public class PowerTaskList
 		callback?.Invoke(this, startIndex, count, userData);
 	}
 
-	private void DoTasks(int incompleteStartIndex, int endIndex, int startIndex, int count, CompleteCallback callback, object userData)
+    private void DoTasks(int incompleteStartIndex, int endIndex, int startIndex, int count, CompleteCallback callback, object userData)
 	{
 		for (int i = incompleteStartIndex; i <= endIndex; i++)
 		{
@@ -1885,4 +1887,38 @@ public class PowerTaskList
 			}
 		}
 	}
+
+    #region Accessibility
+
+	public delegate void GlobalCompleteCallback(PowerTaskList taskList);
+
+	private GlobalCompleteCallback m_globalCompleteCallback;
+
+    private bool m_startedTasks = false;
+
+    private void OnTaskStarted(PowerTask task)
+    {
+        if (!m_startedTasks)
+        {
+            m_startedTasks = true;
+            AccessiblePowerTaskListDescriber.Get().OnPowerTaskListStart(this);
+        }
+    }
+
+    internal void SetGlobalCompleteCallback(GlobalCompleteCallback callback)
+    {
+		m_globalCompleteCallback = callback;
+    }
+
+	public void FireCompleteEvent()
+    {
+        m_globalCompleteCallback?.Invoke(this);
+    }
+
+	public bool IsTradeBlock()
+	{
+		return IsBlockType(HistoryBlock.Type.DECK_ACTION);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/PracticePickerTrayDisplay.cs b/Assembly-CSharp/PracticePickerTrayDisplay.cs
index 09c314b..d22998d 100644
--- a/Assembly-CSharp/PracticePickerTrayDisplay.cs
+++ b/Assembly-CSharp/PracticePickerTrayDisplay.cs
@@ -4,6 +4,8 @@ using System.Collections.Generic;
 using Blizzard.T5.Core;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
+using Assets;
 
 [CustomEditClass]
 public class PracticePickerTrayDisplay : MonoBehaviour
@@ -43,8 +45,6 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 
 	private List<PracticeAIButton> m_practiceAIButtons = new List<PracticeAIButton>();
 
-	private List<Achievement> m_lockedHeroes = new List<Achievement>();
-
 	private PracticeAIButton m_selectedPracticeAIButton;
 
 	private Map<string, DefLoader.DisposableFullDef> m_heroDefs = new Map<string, DefLoader.DisposableFullDef>();
@@ -111,7 +111,7 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 	{
 		if (GameMgr.Get() != null)
 		{
-			GameMgr.Get().UnregisterFindGameEvent(OnFindGameEvent);
+		GameMgr.Get().UnregisterFindGameEvent(OnFindGameEvent);
 		}
 		m_heroDefs.DisposeValuesAndClear();
 		s_instance = null;
@@ -175,6 +175,8 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			m_playButton.Enable();
 		}
 		Navigation.Push(OnNavigateBack);
+
+		AccessibleAdventureScene.Get().OnPracticePickerTrayDisplayShown(m_practiceAIButtons);
 	}
 
 	public void Hide()
@@ -334,21 +336,21 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 				Debug.LogError("Trying to play practice game with deck ID 0!");
 				return;
 			}
-			GameMgr.Get().FindGame(GameType.GT_VS_AI, FormatType.FT_WILD, m_selectedPracticeAIButton.GetMissionID(), 0, selectedDeckID, null, null, restoreSavedGameState: false, null, null, 0L);
+				GameMgr.Get().FindGame(GameType.GT_VS_AI, FormatType.FT_WILD, m_selectedPracticeAIButton.GetMissionID(), 0, selectedDeckID, null, null, restoreSavedGameState: false, null, null, 0L);
+		}
+			Navigation.RemoveHandler(OnNavigateBack);
+			PracticeDisplay.Get().DismissTrays();
 		}
-		Navigation.RemoveHandler(OnNavigateBack);
-		PracticeDisplay.Get().DismissTrays();
-	}
 
 	private void AIButtonPressed(UIEvent e)
 	{
 		PracticeAIButton practiceAIButton = (PracticeAIButton)e.GetElement();
 		if (!(m_selectedPracticeAIButton == practiceAIButton))
 		{
-			m_playButton.Enable();
+		m_playButton.Enable();
 			SetSelectedButton(practiceAIButton);
-			practiceAIButton.Select();
-		}
+		practiceAIButton.Select();
+	}
 	}
 
 	private void UpdateAIButtons()
@@ -386,14 +388,14 @@ public class PracticePickerTrayDisplay : MonoBehaviour
 			PracticeAIButton practiceAIButton = m_practiceAIButtons[i];
 			practiceAIButton.SetInfo(text, @class, disposableFullDef.DisposableCardDef, iD, flip: false);
 			bool shown = false;
-			foreach (Achievement lockedHero in m_lockedHeroes)
+
+			// "Undefeated" flags are broken on the official game so I had to tweak this
+			NetCache.HeroLevel heroLevel = GameUtils.GetHeroLevel(@class);
+			if (heroLevel == null || heroLevel.CurrentLevel.Level == 0)
 			{
-				if (lockedHero.ClassReward.Value == @class)
-				{
-					shown = true;
-					break;
-				}
+				shown = true;
 			}
+
 			practiceAIButton.ShowQuestBang(shown);
 			if (practiceAIButton == m_selectedPracticeAIButton)
 			{
diff --git a/Assembly-CSharp/PresenceMgr.cs b/Assembly-CSharp/PresenceMgr.cs
index fcb4f41..36865d3 100644
--- a/Assembly-CSharp/PresenceMgr.cs
+++ b/Assembly-CSharp/PresenceMgr.cs
@@ -2744,6 +2744,12 @@ public class PresenceMgr
 
 	public string GetStatusText(BnetPlayer player)
 	{
+		if (player != null && player.IsCheatPlayer && "Nearby Player".Equals(player.GetBestName()))
+		{
+			// Default used to be "Hearthstone" but is now null since 21.4. Could just use the fake WoW player to test but this is fine
+			return "Doing something cool";
+		}
+
 		List<string> list = new List<string>();
 		string statusKey = null;
 		if (GetStatus_Internal(player, ref statusKey, list) == Global.PresenceStatus.UNKNOWN || !BnetPresenceMgr.Get().IsSubscribedToPlayer(player.GetHearthstoneGameAccountId()))
@@ -2848,28 +2854,28 @@ public class PresenceMgr
 		using (MemoryStream memoryStream = new MemoryStream(bytes))
 		{
 			using BinaryReader reader = new BinaryReader(memoryStream);
-			if (!DecodeStatusVal(reader, ref enumVal, ref statusKey))
-			{
+				if (!DecodeStatusVal(reader, ref enumVal, ref statusKey))
+				{
 				return presenceStatus;
-			}
+				}
 			presenceStatus = (Global.PresenceStatus)(int)(object)enumVal;
 			enumVals?.Add(presenceStatus);
-			if (stringArgs != null || enumVals != null)
-			{
-				while (memoryStream.Position < bytes.Length)
+				if (stringArgs != null || enumVals != null)
 				{
-					string key = null;
-					if (!DecodeStatusVal(reader, ref enumVal, ref key))
+					while (memoryStream.Position < bytes.Length)
 					{
+						string key = null;
+						if (!DecodeStatusVal(reader, ref enumVal, ref key))
+						{
 						return presenceStatus;
+						}
+						enumVals?.Add(enumVal);
+						if (stringArgs != null)
+						{
+							string item = GameStrings.Get(key);
+							stringArgs.Add(item);
+						}
 					}
-					enumVals?.Add(enumVal);
-					if (stringArgs != null)
-					{
-						string item = GameStrings.Get(key);
-						stringArgs.Add(item);
-					}
-				}
 			}
 		}
 		return presenceStatus;
@@ -3016,20 +3022,20 @@ public class PresenceMgr
 	{
 		using MemoryStream memoryStream = new MemoryStream();
 		using BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
-		for (int i = 0; i < status.Length; i++)
-		{
-			if (!EncodeStatusVal(status, i, out var id, out var intVal))
-			{
-				return false;
+				for (int i = 0; i < status.Length; i++)
+				{
+					if (!EncodeStatusVal(status, i, out var id, out var intVal))
+					{
+						return false;
+					}
+					binaryWriter.Write(id);
+					binaryWriter.Write(intVal);
+				}
+				byte[] buffer = memoryStream.GetBuffer();
+				byte[] array = new byte[memoryStream.Position];
+				Array.Copy(buffer, array, array.Length);
+				return BnetPresenceMgr.Get().SetGameField(17u, array);
 			}
-			binaryWriter.Write(id);
-			binaryWriter.Write(intVal);
-		}
-		byte[] buffer = memoryStream.GetBuffer();
-		byte[] array = new byte[memoryStream.Position];
-		Array.Copy(buffer, array, array.Length);
-		return BnetPresenceMgr.Get().SetGameField(17u, array);
-	}
 
 	private bool EncodeStatusVal(Enum[] status, int index, out byte id, out int intVal)
 	{
diff --git a/Assembly-CSharp/PrivacyFeatures.cs b/Assembly-CSharp/PrivacyFeatures.cs
index 1849b64..80c19cd 100644
--- a/Assembly-CSharp/PrivacyFeatures.cs
+++ b/Assembly-CSharp/PrivacyFeatures.cs
@@ -5,5 +5,6 @@ public enum PrivacyFeatures
 	PERSONALIZED_STORE_ITEMS = 3,
 	PUSH_NOTIFICATIONS = 4,
 	ANALYTICS = 5,
-	NEARBY_FRIENDS = 6
+	NEARBY_FRIENDS = 6,
+	EOE = 7
 }
diff --git a/Assembly-CSharp/PrivacyFeaturesPopup.cs b/Assembly-CSharp/PrivacyFeaturesPopup.cs
index 8092b7a..b21d501 100644
--- a/Assembly-CSharp/PrivacyFeaturesPopup.cs
+++ b/Assembly-CSharp/PrivacyFeaturesPopup.cs
@@ -1,229 +1,275 @@
 using System;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class PrivacyFeaturesPopup : DialogBase
 {
-	private enum DialogState
-	{
-		START = 1,
-		SEARCH,
-		SUCCESS
-	}
+    private enum DialogState
+    {
+        START = 1,
+        SEARCH,
+        SUCCESS
+    }
 
-	[Serializable]
-	private class FeatureUISettings
-	{
-		public PrivacyFeatures privacyFeature = PrivacyFeatures.INVALID;
+    [Serializable]
+    private class FeatureUISettings
+    {
+        public PrivacyFeatures privacyFeature = PrivacyFeatures.INVALID;
 
-		public GameObject enablePanel;
+        public GameObject enablePanel;
 
-		public GameObject disablePanel;
+        public GameObject disablePanel;
 
-		public string titleText;
+        public string titleText;
 
-		public string searchText;
+        public string searchText;
 
-		public string successText;
-	}
+        public string successText;
+    }
 
-	[SerializeField]
-	private UIBButton m_continueButton;
+    [SerializeField]
+    private UIBButton m_continueButton;
 
-	[SerializeField]
-	private UIBButton m_choiceOneButton;
+    [SerializeField]
+    private UIBButton m_choiceOneButton;
 
-	[SerializeField]
-	private UIBButton m_choiceTwoButton;
+    [SerializeField]
+    private UIBButton m_choiceTwoButton;
 
-	[SerializeField]
-	private GameObject m_continueButtonContainer;
+    [SerializeField]
+    private GameObject m_continueButtonContainer;
 
-	[SerializeField]
-	private GameObject m_choiceButtonContainer;
+    [SerializeField]
+    private GameObject m_choiceButtonContainer;
 
-	[SerializeField]
-	private GameObject m_searchPanel;
+    [SerializeField]
+    private GameObject m_searchPanel;
 
-	[SerializeField]
-	private GameObject m_successPanel;
+    [SerializeField]
+    private GameObject m_successPanel;
 
-	[SerializeField]
-	private UberText m_titleText;
+    [SerializeField]
+    private UberText m_titleText;
 
-	[SerializeField]
-	private UberText m_searchText;
+    [SerializeField]
+    private UberText m_searchText;
 
-	[SerializeField]
-	private UberText m_successText;
+    [SerializeField]
+    private UberText m_successText;
 
-	[SerializeField]
-	private List<FeatureUISettings> m_featureUISettings = new List<FeatureUISettings>();
+    [SerializeField]
+    private List<FeatureUISettings> m_featureUISettings = new List<FeatureUISettings>();
 
-	private FeatureUISettings m_currentFeatureUISettings;
+    private FeatureUISettings m_currentFeatureUISettings;
 
-	private GameObject m_activePanel;
+    private GameObject m_activePanel;
 
-	private DialogState m_activeState;
+    private DialogState m_activeState;
 
-	private Action m_onAcceptCallback;
+    private Action m_onAcceptCallback;
 
-	private Action m_onSuccessCallback;
+    private Action m_onSuccessCallback;
 
-	private Action m_onCancelCallback;
+    private Action m_onCancelCallback;
 
-	private Vector3 NORMAL_SCALE;
+    private Vector3 NORMAL_SCALE;
 
-	private Vector3 HIDDEN_SCALE;
+    private Vector3 HIDDEN_SCALE;
 
-	private PegUIElement m_inputBlocker;
+    private PegUIElement m_inputBlocker;
 
-	private const float BLUR_TIME = 0.1f;
+    private const float BLUR_TIME = 0.1f;
 
-	private const float BUTTON_BLOCK_TIME = 0.5f;
+    private const float BUTTON_BLOCK_TIME = 0.5f;
 
-	private float m_buttonBlockTimer;
+    private float m_buttonBlockTimer;
 
-	private bool m_buttonBlocked = true;
+    private bool m_buttonBlocked = true;
 
-	protected override void Awake()
-	{
-		base.Awake();
-		NORMAL_SCALE = base.transform.localScale;
-		HIDDEN_SCALE = 0.01f * NORMAL_SCALE;
-	}
+    protected override void Awake()
+    {
+        base.Awake();
+        NORMAL_SCALE = base.transform.localScale;
+        HIDDEN_SCALE = 0.01f * NORMAL_SCALE;
+    }
 
-	private void Update()
-	{
-		if (m_buttonBlockTimer >= 0f)
-		{
-			m_buttonBlockTimer -= Time.deltaTime;
-			if (m_buttonBlockTimer < 0f)
-			{
-				m_buttonBlocked = false;
-			}
-		}
-	}
+    private void Update()
+    {
+        if (m_buttonBlockTimer >= 0f)
+        {
+            m_buttonBlockTimer -= Time.deltaTime;
+            if (m_buttonBlockTimer < 0f)
+            {
+                m_buttonBlocked = false;
+            }
+        }
+    }
 
-	private void OnEnable()
-	{
-		m_continueButton.AddEventListener(UIEventType.RELEASE, OnContinueButton);
-		m_choiceOneButton.AddEventListener(UIEventType.RELEASE, OnChoiceOneButton);
-		m_choiceTwoButton.AddEventListener(UIEventType.RELEASE, OnChoiceTwoButton);
-	}
+    private void OnEnable()
+    {
+        m_continueButton.AddEventListener(UIEventType.RELEASE, OnContinueButton);
+        m_choiceOneButton.AddEventListener(UIEventType.RELEASE, OnChoiceOneButton);
+        m_choiceTwoButton.AddEventListener(UIEventType.RELEASE, OnChoiceTwoButton);
+    }
 
-	private void OnDisable()
-	{
-		m_continueButton.RemoveEventListener(UIEventType.RELEASE, OnContinueButton);
-		m_choiceOneButton.RemoveEventListener(UIEventType.RELEASE, OnChoiceOneButton);
-		m_choiceTwoButton.RemoveEventListener(UIEventType.RELEASE, OnChoiceTwoButton);
-	}
+    private void OnDisable()
+    {
+        m_continueButton.RemoveEventListener(UIEventType.RELEASE, OnContinueButton);
+        m_choiceOneButton.RemoveEventListener(UIEventType.RELEASE, OnChoiceOneButton);
+        m_choiceTwoButton.RemoveEventListener(UIEventType.RELEASE, OnChoiceTwoButton);
+    }
 
-	private void CreateInputBlocker()
-	{
-		GameObject gameObject = CameraUtils.CreateInputBlocker(CameraUtils.FindFirstByLayer(base.gameObject.layer), "PrivacyFeaturesInputBlocker");
-		gameObject.transform.parent = base.gameObject.transform;
-		m_inputBlocker = gameObject.AddComponent<PegUIElement>();
-		m_inputBlocker.AddEventListener(UIEventType.RELEASE, delegate
-		{
-		});
-		TransformUtil.SetPosY(m_inputBlocker, base.gameObject.transform.position.y - 0.1f);
-	}
+    private void CreateInputBlocker()
+    {
+        GameObject gameObject = CameraUtils.CreateInputBlocker(CameraUtils.FindFirstByLayer(base.gameObject.layer), "PrivacyFeaturesInputBlocker");
+        gameObject.transform.parent = base.gameObject.transform;
+        m_inputBlocker = gameObject.AddComponent<PegUIElement>();
+        m_inputBlocker.AddEventListener(UIEventType.RELEASE, delegate
+        {
+        });
+        TransformUtil.SetPosY(m_inputBlocker, base.gameObject.transform.position.y - 0.1f);
+    }
 
-	private void OnChoiceOneButton(UIEvent e)
-	{
-		if (!m_buttonBlocked && m_activeState == DialogState.START)
-		{
-			m_onCancelCallback?.Invoke();
-		}
-	}
+    private void OnChoiceOneButton(UIEvent e)
+    {
+        if (!m_buttonBlocked && m_activeState == DialogState.START)
+        {
+            m_onCancelCallback?.Invoke();
+        }
+    }
 
-	private void OnChoiceTwoButton(UIEvent e)
-	{
-		if (!m_buttonBlocked && m_activeState == DialogState.START)
-		{
-			m_onAcceptCallback?.Invoke();
+    private void OnChoiceTwoButton(UIEvent e)
+    {
+        if (!m_buttonBlocked && m_activeState == DialogState.START)
+        {
+            m_onAcceptCallback?.Invoke();
 			m_onSuccessCallback?.Invoke();
-		}
-	}
-
-	private void OnContinueButton(UIEvent e)
-	{
-		if (!m_buttonBlocked)
-		{
-			if (m_activeState == DialogState.SEARCH)
-			{
-				m_onCancelCallback?.Invoke();
-			}
-			else if (m_activeState == DialogState.SUCCESS)
-			{
-				m_onSuccessCallback?.Invoke();
-			}
-		}
-	}
-
-	private void OnStartState(bool isEnabled)
-	{
-		m_activePanel = (isEnabled ? m_currentFeatureUISettings.disablePanel : m_currentFeatureUISettings.enablePanel);
-		m_activeState = DialogState.START;
-		m_choiceOneButton.SetText(GameStrings.Get("GLOBAL_CANCEL"));
+        }
+    }
+
+    private void OnContinueButton(UIEvent e)
+    {
+        if (!m_buttonBlocked)
+        {
+            if (m_activeState == DialogState.SEARCH)
+            {
+                m_onCancelCallback?.Invoke();
+            }
+            else if (m_activeState == DialogState.SUCCESS)
+            {
+                m_onSuccessCallback?.Invoke();
+            }
+        }
+    }
+
+    private void OnStartState(bool isEnabled)
+    {
+        m_activePanel = (isEnabled ? m_currentFeatureUISettings.disablePanel : m_currentFeatureUISettings.enablePanel);
+        m_activeState = DialogState.START;
+        m_choiceOneButton.SetText(GameStrings.Get("GLOBAL_CANCEL"));
 		m_choiceTwoButton.SetText(isEnabled ? "GLOBAL_AADC_FRIENDSETTINGS_TURN_OFF_BUTTON" : "GLOBAL_AADC_FRIENDSETTINGS_TURN_ON_BUTTON");
-		m_continueButtonContainer.SetActive(value: false);
-		m_choiceButtonContainer.SetActive(value: true);
-		SetActivePanel();
-	}
-
-	private bool SetCurrentSettings(PrivacyFeatures privacyFeature)
-	{
-		FeatureUISettings featureUISettings = m_featureUISettings.Find((FeatureUISettings x) => x.privacyFeature == privacyFeature);
-		if (featureUISettings == null)
-		{
-			Log.Privacy.PrintError("Privacy feature not supported in UI: " + privacyFeature);
-			return false;
-		}
-		m_titleText.Text = featureUISettings.titleText;
-		m_searchText.Text = featureUISettings.searchText;
-		m_successText.Text = featureUISettings.successText;
-		m_currentFeatureUISettings = featureUISettings;
-		return true;
-	}
-
-	private void SetActivePanel()
-	{
-		m_currentFeatureUISettings.enablePanel.SetActive(m_currentFeatureUISettings.enablePanel == m_activePanel);
-		m_currentFeatureUISettings.disablePanel.SetActive(m_currentFeatureUISettings.disablePanel == m_activePanel);
-		m_searchPanel.SetActive(m_searchPanel == m_activePanel);
-		m_successPanel.SetActive(m_successPanel == m_activePanel);
-	}
-
-	public void Set(PrivacyFeatures privacyFeature, bool isEnabled, Action acceptCallback, Action successCallback, Action cancelCallback)
-	{
-		if (!SetCurrentSettings(privacyFeature))
-		{
-			cancelCallback?.Invoke();
-			return;
-		}
-		m_onAcceptCallback = acceptCallback;
-		m_onSuccessCallback = successCallback;
-		m_onCancelCallback = cancelCallback;
-		OnStartState(isEnabled);
-	}
-
-	public override void Show()
-	{
-		base.Show();
-		m_buttonBlockTimer = 0.5f;
-		m_buttonBlocked = true;
-		CreateInputBlocker();
-		AnimationUtil.ShowWithPunch(base.gameObject, HIDDEN_SCALE, 1.1f * NORMAL_SCALE, NORMAL_SCALE, null, noFade: true);
-		ScreenEffectParameters blurVignetteDesaturatePerspective = ScreenEffectParameters.BlurVignetteDesaturatePerspective;
-		blurVignetteDesaturatePerspective.Time = 0.1f;
-		DialogBase.m_screenEffectsHandle.StartEffect(blurVignetteDesaturatePerspective);
-	}
-
-	public override void Hide()
-	{
-		DialogBase.m_screenEffectsHandle.StopEffect();
-		base.Hide();
-	}
+        m_continueButtonContainer.SetActive(value: false);
+        m_choiceButtonContainer.SetActive(value: true);
+        SetActivePanel();
+    }
+
+    private bool SetCurrentSettings(PrivacyFeatures privacyFeature)
+    {
+        FeatureUISettings featureUISettings = m_featureUISettings.Find((FeatureUISettings x) => x.privacyFeature == privacyFeature);
+        if (featureUISettings == null)
+        {
+            Log.Privacy.PrintError("Privacy feature not supported in UI: " + privacyFeature);
+            return false;
+        }
+        m_titleText.Text = featureUISettings.titleText;
+        m_searchText.Text = featureUISettings.searchText;
+        m_successText.Text = featureUISettings.successText;
+        m_currentFeatureUISettings = featureUISettings;
+        return true;
+    }
+
+    private void SetActivePanel()
+    {
+        m_currentFeatureUISettings.enablePanel.SetActive(m_currentFeatureUISettings.enablePanel == m_activePanel);
+        m_currentFeatureUISettings.disablePanel.SetActive(m_currentFeatureUISettings.disablePanel == m_activePanel);
+        m_searchPanel.SetActive(m_searchPanel == m_activePanel);
+        m_successPanel.SetActive(m_successPanel == m_activePanel);
+    }
+
+    public void Set(PrivacyFeatures privacyFeature, bool isEnabled, Action acceptCallback, Action successCallback, Action cancelCallback)
+    {
+        if (!SetCurrentSettings(privacyFeature))
+        {
+            cancelCallback?.Invoke();
+            return;
+        }
+        m_onAcceptCallback = acceptCallback;
+        m_onSuccessCallback = successCallback;
+        m_onCancelCallback = cancelCallback;
+        OnStartState(isEnabled);
+    }
+
+    public override void Show()
+    {
+        base.Show();
+        m_buttonBlockTimer = 0.5f;
+        m_buttonBlocked = true;
+        CreateInputBlocker();
+        AnimationUtil.ShowWithPunch(base.gameObject, HIDDEN_SCALE, 1.1f * NORMAL_SCALE, NORMAL_SCALE, null, noFade: true);
+        ReadPopup();
+        ScreenEffectParameters blurVignetteDesaturatePerspective = ScreenEffectParameters.BlurVignetteDesaturatePerspective;
+        blurVignetteDesaturatePerspective.Time = 0.1f;
+        DialogBase.m_screenEffectsHandle.StartEffect(blurVignetteDesaturatePerspective);
+    }
+
+    public override void Hide()
+    {
+        DialogBase.m_screenEffectsHandle.StopEffect();
+        base.Hide();
+    }
+
+    #region Accessibility
+
+    private AccessibleMenu m_accessibleMenu;
+
+    protected void ReadPopup()
+    {
+        m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null, true);
+
+        if (m_choiceOneButton != null && m_choiceOneButton.isActiveAndEnabled)
+        {
+            m_accessibleMenu.AddOption(m_choiceOneButton.GetText(), () => m_choiceOneButton.TriggerRelease());
+        }
+
+        if (m_choiceTwoButton != null && m_choiceTwoButton.isActiveAndEnabled)
+        {
+            m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+        if (m_continueButton != null && m_continueButton.isActiveAndEnabled)
+        {
+            m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, GameStrings.Get(m_titleText.Text));
+        AccessibilityMgr.Output(this, GameStrings.Get(m_searchText.Text));
+        AccessibilityMgr.Output(this, GameStrings.Get(m_successText.Text));
+
+        m_accessibleMenu.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+        return m_accessibleMenu?.GetHelp();
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/PrivacyGate.cs b/Assembly-CSharp/PrivacyGate.cs
index 71f0d88..4fe8fd4 100644
--- a/Assembly-CSharp/PrivacyGate.cs
+++ b/Assembly-CSharp/PrivacyGate.cs
@@ -43,6 +43,12 @@ public class PrivacyGate : IService
 
 	public bool FeatureEnabled(PrivacyFeatures privacyFeature)
 	{
+		// Accessibility
+		if (privacyFeature == PrivacyFeatures.CHAT)
+        {
+			return true;
+        }
+
 		if (featuresData.ContainsKey(privacyFeature))
 		{
 			return featuresData[privacyFeature];
diff --git a/Assembly-CSharp/PrivacyPolicyPopup.cs b/Assembly-CSharp/PrivacyPolicyPopup.cs
index 50f42ce..1c5cb52 100644
--- a/Assembly-CSharp/PrivacyPolicyPopup.cs
+++ b/Assembly-CSharp/PrivacyPolicyPopup.cs
@@ -1,10 +1,11 @@
+using Accessibility;
 using System.Collections.Generic;
 using Blizzard.T5.Core.Utils;
 using Hearthstone;
 using Hearthstone.UI;
 using UnityEngine;
 
-public class PrivacyPolicyPopup : DialogBase
+public class PrivacyPolicyPopup : InaccessibleDialogBase
 {
 	public delegate void ResponseCallback(bool confirmedPrivacyPolicy);
 
diff --git a/Assembly-CSharp/ProductCatalog.cs b/Assembly-CSharp/ProductCatalog.cs
index bb8fae7..dead2d6 100644
--- a/Assembly-CSharp/ProductCatalog.cs
+++ b/Assembly-CSharp/ProductCatalog.cs
@@ -125,14 +125,14 @@ public class ProductCatalog
 	public void PopulateWithNetData(List<ProductInfo> netBundles, List<Network.GoldCostBooster> netGoldBoosters, CatalogNetworkPages networkPages)
 	{
 		HasData = true;
-		m_products.Capacity = Math.Max(m_products.Capacity, netBundles.Count() + netGoldBoosters.Count());
-		AddNetGoldBoosterProducts(netGoldBoosters);
-		AddNetBundleProducts(netBundles);
-		UpdateProductStatus();
-		PopulateTiers(networkPages);
-		PopulateProductVariants();
-		HealupProductTiers();
-	}
+			m_products.Capacity = Math.Max(m_products.Capacity, netBundles.Count() + netGoldBoosters.Count());
+			AddNetGoldBoosterProducts(netGoldBoosters);
+			AddNetBundleProducts(netBundles);
+			UpdateProductStatus();
+			PopulateTiers(networkPages);
+			PopulateProductVariants();
+			HealupProductTiers();
+		}
 
 	public ProductDataModel GetProductByPmtId(ProductId productId)
 	{
@@ -155,30 +155,30 @@ public class ProductCatalog
 	public List<ProductTierDataModel> GetTiers_Tab(string tabId)
 	{
 		return m_catalogTabs.GetTiers(tabId);
-	}
+		}
 
 	public List<ProductTierDataModel> GetTiers_SubTab(string parentTabId, string subTabId)
-	{
+		{
 		return m_catalogTabs.GetTiers(parentTabId, subTabId);
-	}
+		}
 
 	public List<ShopTabData> GetTabs_All()
-	{
+		{
 		return m_catalogTabs.GetAllTabData();
-	}
+					}
 
 	public bool TryGetTab(string tabId, out ShopTabData tabData)
-	{
+			{
 		return m_catalogTabs.TryGetTabData(tabId, out tabData);
-	}
+						}
 
 	public bool TryGetSubTabs_All(string parentTabId, out List<ShopTabData> subTabs)
-	{
+						{
 		return m_catalogTabs.TryGetAllSubTabData(parentTabId, out subTabs);
-	}
+						}
 
 	public bool TryGetSubTab(string parentTabId, string subTabId, out ShopTabData tabData)
-	{
+				{
 		return m_catalogTabs.TryGetSubTabData(parentTabId, subTabId, out tabData);
 	}
 
@@ -203,10 +203,10 @@ public class ProductCatalog
 			{
 				product2.Availability = ProductAvailability.UNDEFINED;
 				if (product2.Prices.Count == 1 && product2.GetBuyProductArgs(product2.Prices[0], 1) is BuyNoGTAPPEventArgs buyNoGTAPPEventArgs && m_storeManager.GetGoldCostNoGTAPP(buyNoGTAPPEventArgs.transactionData, out var _))
-				{
-					product2.Availability = ProductAvailability.CAN_PURCHASE;
+					{
+						product2.Availability = ProductAvailability.CAN_PURCHASE;
+					}
 				}
-			}
 			else
 			{
 				if (m_productDataStorageService.TryGetProduct(product2.GetProductId(), out var product))
@@ -319,10 +319,10 @@ public class ProductCatalog
 			{
 				error = $"Product {pmtProductId} not received from server.";
 				return null;
-			}
+		}
 			error = $"Product {pmtProductId} failed client validation. See Store log.";
 			return null;
-		}
+			}
 		PopulateVariantsForProduct(productByPmtId, miniSetProducts);
 		error = string.Empty;
 		return productByPmtId;
@@ -375,10 +375,10 @@ public class ProductCatalog
 		{
 			if (!m_goldBoosterProductIds.Contains(netGoldBooster.ID))
 			{
-				ProductDataModel productDataModel = CatalogUtils.NetGoldCostBoosterToProduct(netGoldBooster);
-				if (productDataModel != null)
-				{
-					m_products.Add(productDataModel);
+			ProductDataModel productDataModel = CatalogUtils.NetGoldCostBoosterToProduct(netGoldBooster);
+			if (productDataModel != null)
+			{
+				m_products.Add(productDataModel);
 					m_goldBoosterProductIds.Add(netGoldBooster.ID);
 				}
 			}
@@ -428,7 +428,7 @@ public class ProductCatalog
 					{
 						Log.Store.PrintError("Cannot handle tab section - " + item3.InternalName + " - Null/Empty tab ID");
 						continue;
-					}
+				}
 					text = value;
 					m_catalogTabs.AddTab(GetShopTabData(value, item3));
 					continue;
@@ -470,7 +470,7 @@ public class ProductCatalog
 				{
 					if (value5 != "true")
 					{
-						list2 = value5.Split(",").ToList();
+						list2 = value5.Split(',').ToList();
 					}
 					flag2 = value5 == "true" || list2.Count > 0;
 				}
@@ -609,7 +609,7 @@ public class ProductCatalog
 				}
 				if (item3.Attributes.GetValue("layout_size").TryGetValue(out var value8))
 				{
-					string[] array = value8.Split("x");
+					string[] array = value8.Split('x');
 					if (array.Length == 2 && int.TryParse(array[0], out var result2) && int.TryParse(array[1], out var result3))
 					{
 						layoutWidth = result2;
@@ -636,15 +636,15 @@ public class ProductCatalog
 				}
 				if (item3.Attributes.GetValue("divider_options").TryGetValue(out var value10))
 				{
-					list4 = value10.Split(",").ToList();
+					list4 = value10.Split(',').ToList();
 				}
 				if (item3.Attributes.GetValue("tier_options").TryGetValue(out var value11))
 				{
-					list5 = value11.Split(",").ToList();
+					list5 = value11.Split(',').ToList();
 				}
 				if (item3.Attributes.GetValue("additional_options").TryGetValue(out var value12))
 				{
-					list6.AddRange(value12.Split(",").ToList());
+					list6.AddRange(value12.Split(',').ToList());
 				}
 				DataModelList<string> dataModelList = item3.Attributes.GetTags().Tags.ToDataModelList();
 				if (result)
@@ -729,12 +729,12 @@ public class ProductCatalog
 				{
 					DataModelList<string> tags = displayProduct.Tags;
 					if (tags != null && tags.Contains("sellable_deck"))
-					{
-						SortItemsOfProductAndVariants(displayProduct);
-					}
+				{
+					SortItemsOfProductAndVariants(displayProduct);
 				}
 			}
 		}
+		}
 		m_virtualCurrencyProduct = null;
 		m_boosterCurrencyProduct = null;
 		if (!ShopUtils.IsVirtualCurrencyEnabled())
diff --git a/Assembly-CSharp/ProductExtensions.cs b/Assembly-CSharp/ProductExtensions.cs
index 51ba570..bfef22c 100644
--- a/Assembly-CSharp/ProductExtensions.cs
+++ b/Assembly-CSharp/ProductExtensions.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Text.RegularExpressions;
 using Blizzard.Commerce;
 using Blizzard.T5.Services;
 using Hearthstone.Commerce;
@@ -159,7 +160,7 @@ public static class ProductExtensions
 		}
 		else
 		{
-			string[] array = product.Description.Split("~~~");
+			string[] array = Regex.Split(product.Description, "~~~");
 			string description;
 			string fullDescription;
 			if (array.Length < 2 || string.IsNullOrWhiteSpace(array[1]))
@@ -584,7 +585,7 @@ public static class ProductExtensions
 			if (item.ItemType == RewardItemType.CARD)
 			{
 				num++;
-			}
+		}
 			else if (item.ItemType == RewardItemType.MINI_SET)
 			{
 				MiniSetDbfRecord record = GameDbf.MiniSet.GetRecord(item.ItemId);
diff --git a/Assembly-CSharp/ProductFactory.cs b/Assembly-CSharp/ProductFactory.cs
index 1bd1a59..84cd329 100644
--- a/Assembly-CSharp/ProductFactory.cs
+++ b/Assembly-CSharp/ProductFactory.cs
@@ -78,7 +78,7 @@ public static class ProductFactory
 			Queue<CurrencyType> queue = new Queue<CurrencyType>();
 			if (tags.TryGetData("promote_price", out var data))
 			{
-				string[] array = data.Split("-");
+				string[] array = data.Split('-');
 				foreach (string text in array)
 				{
 					if (text.ToLower() == "gold")
@@ -170,15 +170,15 @@ public static class ProductFactory
 			{
 				MiniSetDbfRecord record = GameDbf.MiniSet.GetRecord(item2.ProductData);
 				if (record != null && record.HideOnClient)
+			{
+				if (netBundle.Items.Count == 1)
 				{
-					if (netBundle.Items.Count == 1)
-					{
-						flag = true;
-						ProductIssues.LogError(productDataModel, $"Hidden Mini-Set Cannot be the only item in a product!! ProductId={productDataModel.PmtId}");
-						break;
-					}
-					continue;
+					flag = true;
+					ProductIssues.LogError(productDataModel, $"Hidden Mini-Set Cannot be the only item in a product!! ProductId={productDataModel.PmtId}");
+					break;
 				}
+				continue;
+			}
 			}
 			bool isValidItem;
 			RewardItemDataModel rewardItemDataModel = RewardFactory.CreateShopRewardItemDataModel(netBundle, item2, out isValidItem);
diff --git a/Assembly-CSharp/ProductPage.cs b/Assembly-CSharp/ProductPage.cs
index aeb9add..f69ac76 100644
--- a/Assembly-CSharp/ProductPage.cs
+++ b/Assembly-CSharp/ProductPage.cs
@@ -7,6 +7,7 @@ using Blizzard.T5.Services;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class ProductPage : MonoBehaviour
 {
@@ -30,6 +31,10 @@ public class ProductPage : MonoBehaviour
 
 	protected AlertPopup.PopupInfo m_preBuyPopupInfo;
 
+	#region Accessibility
+	private bool m_isAccessible;
+	#endregion
+
 	private Coroutine m_openWhenReadyCoroutine;
 
 	public Widget WidgetComponent => m_widget;
@@ -158,6 +163,14 @@ public class ProductPage : MonoBehaviour
 		m_parentShop.ProductPageController.OpenQuantityPrompt(m_productSelection.MaxQuantity, delegate(int quantity)
 		{
 			SetVariantQuantityAndUpdateDataModel(variant, quantity);
+
+			SetupVariantMenuOptions();
+			m_readingVariantMenu.StartReading(false);
+		}, delegate
+		{
+
+			SetupVariantMenuOptions();
+			m_readingVariantMenu.StartReading(false);
 		});
 		return true;
 	}
@@ -229,8 +242,15 @@ public class ProductPage : MonoBehaviour
 		}
 	}
 
-	public virtual void Open()
+	public virtual void Reopen()
+	{
+		Open(m_isAccessible);
+	}
+
+	public virtual void Open(bool isAccessible)
 	{
+		m_isAccessible = isAccessible;
+
 		if (!IsOpen)
 		{
 			IsOpen = true;
@@ -380,11 +400,11 @@ public class ProductPage : MonoBehaviour
 			flag = true;
 		}
 		if (flag)
-		{
-			m_productMutable = m_productImmutable.CloneDataModel();
-			m_productMutable.Variants = new DataModelList<ProductDataModel>();
-			m_productMutable.Variants.AddRange(m_productImmutable.Variants.Select((ProductDataModel v) => CreateMutableVariant(v)));
-			m_variantQuantities.Clear();
+	{
+		m_productMutable = m_productImmutable.CloneDataModel();
+		m_productMutable.Variants = new DataModelList<ProductDataModel>();
+		m_productMutable.Variants.AddRange(m_productImmutable.Variants.Select((ProductDataModel v) => CreateMutableVariant(v)));
+		m_variantQuantities.Clear();
 			return true;
 		}
 		return false;
@@ -560,4 +580,265 @@ public class ProductPage : MonoBehaviour
 			m_openWhenReadyCoroutine = null;
 		}
 	}
+
+	#region Accessibility
+
+	protected enum State
+	{
+		LOADING,
+		CHOOSING_VARIANT,
+		READING_VARIANT_MENU,
+		READING_VARIANT_DESCRIPTION,
+
+		// Mini-set
+		READING_CARDS,
+	}
+
+	protected State m_curState;
+
+	private AccessibleMenu m_accessibleMenu;
+
+	protected AccessibleMenu m_readingVariantMenu;
+
+	private AccessibleMultilineText m_variantDescription;
+
+	protected void BuyVariant(PriceDataModel price)
+	{
+		var hasEnough = AccessibleShopUtils.HasEnoughToBuyVariant(price);
+
+		if (price.Currency == CurrencyType.GOLD)
+		{
+			if (!hasEnough)
+			{
+				AccessibilityMgr.Output(m_container, GameStrings.Get("GAMEPLAY_PlayErrors_REQ_ENOUGH_COIN"));
+			}
+			else
+			{
+				TryBuy(GetSelectedVariant().Prices.IndexOf(price));
+			}
+		}
+		else if (price.Currency == CurrencyType.ROW_RUNESTONES)
+		{
+			if (!hasEnough)
+			{
+				AccessibilityMgr.Output(m_container, LocalizationUtils.Get(LocalizationKey.UI_SHOP_NOT_ENOUGH_RUNESTONES));
+			}
+			else
+			{
+				TryBuy(GetSelectedVariant().Prices.IndexOf(price));
+			}
+		}
+	}
+
+	public virtual void ReadProductPage()
+	{
+		if (!m_isAccessible)
+		{
+			return;
+		}
+
+		m_curState = State.LOADING; // Make products with no gold variants stay "loading" forever so we don't read them
+
+		var product = m_container.Product;
+
+		if (product.Variants.Count > 1)
+		{
+			ReadProductPageWithVariants(product);
+			return;
+		}
+
+		if (AccessibleShopUtils.IsAvailable(product) && AccessibleShopUtils.CanVariantBeBoughtAccessibly(product))
+		{
+			ChooseVariant(product, false);
+		}
+	}
+
+	private void ReadProductPageWithVariants(ProductDataModel product)
+	{
+		var availableVariants = AccessibleShopUtils.GetVariantsWhichCanBeBoughtAccessibly(product);
+
+		if (availableVariants.Count == 0)
+		{
+			return;
+		}
+
+		var productName = product.Name;
+		m_accessibleMenu = new AccessibleMenu(m_container, productName, () => m_container.Close());
+
+		foreach (var variant in availableVariants)
+		{
+			m_accessibleMenu.AddOption(variant.VariantName, () => ChooseVariant(variant));
+		}
+
+		ReadChoosingVariantMenu();
+	}
+
+	private void ReadChoosingVariantMenu()
+	{
+		m_accessibleMenu.StartReading();
+		m_curState = State.CHOOSING_VARIANT;
+	}
+
+	private void ChooseVariant(ProductDataModel variant, bool hasOtherVariants=true)
+	{
+		SelectVariant(variant);
+
+		SetupVariantMenu(hasOtherVariants);
+
+		ReadVariantMenu();
+	}
+
+	private void SetupVariantMenu(bool hasOtherVariants)
+	{
+		var variant = GetSelectedVariant();
+		if (hasOtherVariants)
+		{
+			m_readingVariantMenu = new AccessibleMenu(m_container, "", ReadChoosingVariantMenu);
+		}
+		else
+		{
+			m_readingVariantMenu = new AccessibleMenu(m_container, variant.Name, () => m_container.Close());
+		}
+
+		SetupVariantMenuOptions();
+	}
+
+	protected virtual void SetupVariantMenuOptions()
+	{
+		var variant = GetSelectedVariant();
+
+		m_readingVariantMenu.Clear();
+		m_readingVariantMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_ITEM_READ_DESCRIPTION), () => ReadVariantDescription(variant));
+		SetupPriceMenuOptions(variant);
+
+		if (variant.ProductSupportsQuantitySelect())
+		{
+			m_readingVariantMenu.AddOption(GameStrings.Get("GLUE_STORE_QUANTITY_HEADLINE"), () => ShowQuantityPromptForVariant(m_productSelection.VariantIndex));
+		}
+	}
+
+	protected void SetupPriceMenuOptions(ProductDataModel variant)
+	{
+		foreach (var price in variant.Prices)
+		{
+			if (AccessibleShopUtils.IsAccessibleCurrency(price.Currency))
+			{
+				m_readingVariantMenu.AddOption(AccessibleShopUtils.GetBuyText(price), () => BuyVariant(price));
+				if (price.Amount == 0f)
+				{
+					break;
+				}
+			}
+		}
+	}
+
+	protected void ReadVariantMenu()
+	{
+		m_readingVariantMenu.StartReading();
+		m_curState = State.READING_VARIANT_MENU;
+	}
+
+	protected void ReadVariantDescription(ProductDataModel variant)
+	{
+		var descriptionLines = AccessibleShopUtils.CreateMultilineDescriptionForVariant(variant);
+
+		m_variantDescription = new AccessibleMultilineText(m_container, descriptionLines);
+		m_variantDescription.ReadAllLines();
+		m_curState = State.READING_VARIANT_DESCRIPTION;
+	}
+
+	internal virtual void OnStorePurchaseAuthClosed(bool purchaseSuccess)
+	{
+		if (!m_isAccessible)
+		{
+			return;
+		}
+
+		if (purchaseSuccess)
+		{
+			ReadRemainingGold();
+			ReadRemainingRunestones();
+		}
+
+		if (m_curState == State.READING_VARIANT_MENU)
+		{
+			if (!CanBuy())
+			{
+				// Close container if we bought a product that we can only buy once
+				m_container.Close(true);
+			}
+			else
+			{
+				ReadVariantMenu();
+			}
+		}
+	}
+
+	protected bool CanBuy()
+	{
+		return AccessibleShopUtils.IsAvailable(m_container.Product);
+	}
+
+	public virtual void HandleAccessibleInput()
+	{
+		if (!m_isAccessible)
+		{
+			return;
+		}
+
+		if (m_curState == State.CHOOSING_VARIANT)
+		{
+			m_accessibleMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_VARIANT_MENU)
+		{
+			m_readingVariantMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_VARIANT_DESCRIPTION)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadVariantMenu();
+			}
+			else
+			{
+				m_variantDescription?.HandleAccessibleInput();
+			}
+		}
+	}
+
+	public virtual string GetAccessibleHelp()
+	{
+		if (!m_isAccessible)
+		{
+			return "";
+		}
+
+		if (m_curState == State.CHOOSING_VARIANT)
+		{
+			return m_accessibleMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_VARIANT_MENU)
+		{
+			return m_readingVariantMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_VARIANT_DESCRIPTION)
+		{
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+		}
+
+		return "";
+	}
+
+	protected void ReadRemainingGold()
+	{
+		AccessibleShopUtils.ReadRemainingGold(m_container);
+	}
+
+	protected void ReadRemainingRunestones()
+	{
+		AccessibleShopUtils.ReadRemainingRunestones(m_container);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/ProductPageContainer.cs b/Assembly-CSharp/ProductPageContainer.cs
index 478d3a9..413a633 100644
--- a/Assembly-CSharp/ProductPageContainer.cs
+++ b/Assembly-CSharp/ProductPageContainer.cs
@@ -7,8 +7,9 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using Hearthstone.UI.Core;
 using UnityEngine;
+using Accessibility;
 
-public class ProductPageContainer : MonoBehaviour
+public class ProductPageContainer : MonoBehaviour, AccessibleUI
 {
 	[SerializeField]
 	private GameObject m_pageRoot;
@@ -151,6 +152,8 @@ public class ProductPageContainer : MonoBehaviour
 		}
 		m_pages.Clear();
 		m_tempInstances = null;
+
+		HideThis();
 	}
 
 	public void Open()
@@ -180,6 +183,7 @@ public class ProductPageContainer : MonoBehaviour
 		m_pageRoot.SetActive(value: true);
 		IsOpen = true;
 		SetProduct(product, variant);
+    OnOpenProductPage();
 		if (m_musicOverride != 0)
 		{
 			OverrideMusic(m_musicOverride);
@@ -187,8 +191,10 @@ public class ProductPageContainer : MonoBehaviour
 		StartCoroutine(OpenProductPageCoroutine());
 	}
 
-	public void Close()
+	public void Close(bool regenerateMenu=false)
 	{
+		HideThis(regenerateMenu);
+
 		if (!IsOpen)
 		{
 			return;
@@ -315,6 +321,7 @@ public class ProductPageContainer : MonoBehaviour
 		}
 		PopupDisplayManager.Get().RedundantNDERerollPopups.SuppressNDEPopups = true;
 		m_currentProductPage = currentProductPage;
+		ReadProductPage();
 	}
 
 	protected void HandleProductPageClosed(object sender, EventArgs e)
@@ -377,6 +384,8 @@ public class ProductPageContainer : MonoBehaviour
 			i.Unload();
 		});
 		m_pages.Clear();
+
+		HideThis();
 	}
 
 	protected IEnumerator OpenProductPageCoroutine()
@@ -409,7 +418,7 @@ public class ProductPageContainer : MonoBehaviour
 			Close();
 			yield break;
 		}
-		activePage.Open();
+		activePage.Open(true);
 		while (activePage.WidgetComponent.IsChangingStates && IsOpen)
 		{
 			yield return null;
@@ -422,4 +431,44 @@ public class ProductPageContainer : MonoBehaviour
 			this.OnOpened?.Invoke(this, EventArgs.Empty);
 		}
 	}
+
+	#region Accessibility
+
+	private void OnOpenProductPage()
+	{
+		if (!AccessibilityUtils.CanSeeShop())
+		{
+			return;
+		}
+
+		AccessibilityMgr.ShowUI(this);
+	}
+
+	private void HideThis(bool regenerateMenu=false)
+	{
+		if (!AccessibilityUtils.CanSeeShop())
+		{
+			return;
+		}
+
+		AccessibilityMgr.HideUI(this);
+		Shop.Get()?.OnProductPageClosed(regenerateMenu);
+	}
+
+	private void ReadProductPage()
+	{
+		m_currentProductPage.ReadProductPage();
+	}
+
+	public void HandleAccessibleInput()
+	{
+		m_currentProductPage?.HandleAccessibleInput();
+	}
+
+	public string GetAccessibleHelp()
+	{
+		return m_currentProductPage?.GetAccessibleHelp();
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/ProductTierExtensions.cs b/Assembly-CSharp/ProductTierExtensions.cs
index 3465d20..d901e43 100644
--- a/Assembly-CSharp/ProductTierExtensions.cs
+++ b/Assembly-CSharp/ProductTierExtensions.cs
@@ -17,7 +17,7 @@ public static class ProductTierExtensions
 			}
 			if (productTierDataModel.LayoutMap != null)
 			{
-				text2 = string.Join(',', productTierDataModel.LayoutMap);
+				text2 = string.Join(",", productTierDataModel.LayoutMap);
 			}
 		}
 		return $"Section: {text}, Size: {productTierDataModel.LayoutWidth}x{productTierDataModel.LayoutHeight}, Map: {text2}";
@@ -34,7 +34,7 @@ public static class ProductTierExtensions
 		List<Tuple<int, int>> list = new List<Tuple<int, int>>();
 		foreach (string item in productTierDataModel.LayoutMap)
 		{
-			string[] array = item.ToLower().Split("x");
+			string[] array = item.ToLower().Split('x');
 			if (array.Length != 2)
 			{
 				Log.Store.PrintError("Cannot parse shop slot layout " + item + " in tier " + debugName);
diff --git a/Assembly-CSharp/Properties/launchSettings.json b/Assembly-CSharp/Properties/launchSettings.json
new file mode 100644
index 0000000..6ffe51a
--- /dev/null
+++ b/Assembly-CSharp/Properties/launchSettings.json
@@ -0,0 +1,7 @@
+{
+  "profiles": {
+    "Assembly-CSharp": {
+      "commandName": "Project"
+    }
+  }
+}
\ No newline at end of file
diff --git a/Assembly-CSharp/PurchaseManager.cs b/Assembly-CSharp/PurchaseManager.cs
index 0a59603..626a3c5 100644
--- a/Assembly-CSharp/PurchaseManager.cs
+++ b/Assembly-CSharp/PurchaseManager.cs
@@ -107,9 +107,6 @@ public class PurchaseManager : IService
 		}
 	}
 
-	[CompilerGenerated]
-	private bool <IsPurchasing>k__BackingField;
-
 	private Stack<PurchaseOrder> m_autoPurchaseStack = new Stack<PurchaseOrder>();
 
 	private PurchaseManagerOptions m_currentPurchaseOptions;
@@ -120,14 +117,7 @@ public class PurchaseManager : IService
 
 	private Action m_onPurchaseEnded;
 
-	private bool IsPurchasing
-	{
-		[CompilerGenerated]
-		set
-		{
-			<IsPurchasing>k__BackingField = value;
-		}
-	}
+	private bool IsPurchasing {get; set;}
 
 	Type[] IService.GetDependencies()
 	{
diff --git a/Assembly-CSharp/PvPDungeonRunDisplay.cs b/Assembly-CSharp/PvPDungeonRunDisplay.cs
index e4ded39..de30bf4 100644
--- a/Assembly-CSharp/PvPDungeonRunDisplay.cs
+++ b/Assembly-CSharp/PvPDungeonRunDisplay.cs
@@ -461,4 +461,5 @@ public class PvPDungeonRunDisplay : MonoBehaviour
 			});
 		}
 	}
+
 }
diff --git a/Assembly-CSharp/PvPDungeonRunScene.cs b/Assembly-CSharp/PvPDungeonRunScene.cs
index 2d53978..860b7b3 100644
--- a/Assembly-CSharp/PvPDungeonRunScene.cs
+++ b/Assembly-CSharp/PvPDungeonRunScene.cs
@@ -1,13 +1,15 @@
 using System;
 using System.Collections;
+using System.Collections.Generic;
 using Assets;
+using Accessibility;
 using Hearthstone.DataModels;
 using Hearthstone.DungeonCrawl;
 using PegasusUtil;
 using UnityEngine;
 
 [CustomEditClass]
-public class PvPDungeonRunScene : PegasusScene
+public class PvPDungeonRunScene : PegasusScene, AccessibleScreen
 {
 	[CustomEditField(T = EditType.GAME_OBJECT)]
 	public String_MobileOverride m_screenPrefab;
@@ -236,6 +238,7 @@ public class PvPDungeonRunScene : PegasusScene
 				collectionManagerDisplay.OnDoneEditingDeck();
 			}
 		}
+		ReadScreen();
 		return true;
 	}
 
@@ -263,6 +266,7 @@ public class PvPDungeonRunScene : PegasusScene
 		m_displayRoot.SetActive(value: true);
 		m_displayRoot.transform.localPosition = Vector3.up;
 		m_display.EnableButtons(enabled: false);
+		ReadScreen();
 	}
 
 	public void SetAdventureData()
@@ -549,6 +553,10 @@ public class PvPDungeonRunScene : PegasusScene
 				yield return null;
 			}
 		}
+		else
+		{
+			ReadScreen();
+		}
 		while (!m_collectionManagerPrefabLoaded)
 		{
 			yield return null;
@@ -584,4 +592,124 @@ public class PvPDungeonRunScene : PegasusScene
 			popupManager.ShowNotice(header, message, rating, callback);
 		}
 	}
+
+	#region Accessibility
+
+	private enum State { LOADING, MAIN_MENU, READING_STATS, READING_DUELS_PLAY_MENU };
+
+	private State m_curState = State.LOADING;
+	private AccessibleMenu m_currMenu;
+	private AccessibleMultilineText m_accessibleStats;
+	private AccessibleMenu m_AccessibleDuelsPlayMenu;
+	public static Boolean IsRetired;
+	public static Boolean ReadMenu = true;
+
+	private void ReadScreen()
+	{
+		if (IsRetired)
+		{
+			m_display.m_playButton.m_newPlayButtonText.SetText("GLOBAL_PLAY");
+			m_instance.m_PopupManager.Hide();
+		}
+		else
+		{
+		}
+
+		AccessibilityMgr.SetScreen(this);
+		m_currMenu = new AccessibleMenu(this, GameStrings.Get("GLUE_PVPDR"), OnGoBackToHub);
+		m_currMenu.AddOption(GameStrings.Get(m_display.m_playButton.m_newPlayButtonText.Text), OnClickPlay); // todo after retiring button should read GLOBAL_PLAY
+		m_currMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SCREEN_DUELS_READ_STATS), OnReadStats);
+		m_currMenu.AddOption(LocalizedText.SCREEN_GO_BACK, OnGoBackToHub);
+		ReadMainMenu();
+	}
+
+	public void ReadMainMenu()
+	{
+		m_curState = State.MAIN_MENU;
+		try
+		{
+			m_currMenu.StartReading();
+		}
+		catch  (Exception e)
+		{
+			AccessibilityUtils.LogFatalError(e);
+			ReadScreen();
+		}
+	}
+
+	private void OnReadStats()
+	{
+		var PVPDRLobbyDataModel = m_display.GetPVPDRLobbyDataModel();
+		var casualRatingCount = PVPDRLobbyDataModel.Rating;
+		var heroicRatingCount = PVPDRLobbyDataModel.PaidRating;
+		var totalRatingCount = PVPDRLobbyDataModel.HighWatermark;
+		var seasonEndInfo = PVPDRLobbyDataModel.TimeRemainingString;
+		var lines = new List<string>();
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_PVPDR_RATING_LABEL_NORMAL"), $"{casualRatingCount}"));
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_PVPDR_RATING_LABEL_HEROIC"), $"{heroicRatingCount}"));
+		lines.Add(AccessibleSpeechUtils.CombineWordsWithColon(GameStrings.Get("GLUE_PVPDR_HIGH_WATERMARK_LABEL"), $"{totalRatingCount}"));
+		lines.Add(seasonEndInfo);
+		m_accessibleStats = new AccessibleMultilineText(this, lines);
+		m_accessibleStats.ReadAllLines();
+		m_curState = State.READING_STATS;
+	}
+	private void OnClickPlay()
+	{
+		var btn = m_display.m_playButton;
+		if(!btn.enabled) {
+			AccessibilityMgr.Output(this,GameStrings.Get(btn.m_newPlayButtonText.Text));
+			return;
+		}
+		m_curState = State.LOADING;
+		btn.TriggerRelease();
+	}
+	private void OnGoBackToHub()
+	{
+		m_curState = State.LOADING;
+		m_display.m_backButton.TriggerRelease();
+	}
+	public void HandleInput()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_currMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_STATS)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadMainMenu();
+			}
+			else
+			{
+				m_accessibleStats?.HandleAccessibleInput();
+			}
+		}
+	}
+	public string GetHelp()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			return m_currMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_STATS)
+		{
+			return AccessibleSpeech.PRESS_BACK_TO_GO_BACK;
+		}
+		return "";
+	}
+	public void OnGainedFocus()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_currMenu?.StartReading();
+		}
+		else if (m_curState == State.READING_STATS)
+		{
+			m_accessibleStats.ReadAllLines();
+		}
+	}
+
+	#endregion
+
 }
diff --git a/Assembly-CSharp/QuestLog.cs b/Assembly-CSharp/QuestLog.cs
index b8ebb9f..dde6cae 100644
--- a/Assembly-CSharp/QuestLog.cs
+++ b/Assembly-CSharp/QuestLog.cs
@@ -403,7 +403,7 @@ public class QuestLog : UIBPopup
 			if (AchieveManager.Get().HasUnlockedFeature(Achieve.Unlocks.DAILY))
 			{
 				m_noQuestText.Text = GameStrings.Get("GLUE_QUEST_LOG_NO_QUESTS_DAILIES_UNLOCKED");
-				if (!Options.Get().GetBool(Option.HAS_RUN_OUT_OF_QUESTS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("QuestLog.UpdateActiveQuests:" + Option.HAS_RUN_OUT_OF_QUESTS))
+				if (!Options.Get().GetBool(Option.HAS_RUN_OUT_OF_QUESTS, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(true, "QuestLog.UpdateActiveQuests:" + Option.HAS_RUN_OUT_OF_QUESTS))
 				{
 					NotificationManager.Get().CreateInnkeeperQuote(UserAttentionBlocker.NONE, new Vector3(155.3f, 0f, 34.5f), GameStrings.Get("VO_INNKEEPER_OUT_OF_QUESTS"), "VO_INNKEEPER_OUT_OF_QUESTS.prefab:b0073c56bf38c664dab532ad92f3baf9");
 					Options.Get().SetBool(Option.HAS_RUN_OUT_OF_QUESTS, val: true);
diff --git a/Assembly-CSharp/QuestPopups.cs b/Assembly-CSharp/QuestPopups.cs
index b0abda1..a87219e 100644
--- a/Assembly-CSharp/QuestPopups.cs
+++ b/Assembly-CSharp/QuestPopups.cs
@@ -1,5 +1,6 @@
 using System;
 using System.Collections.Generic;
+using Accessibility;
 using Assets;
 using Hearthstone.Progression;
 using UnityEngine;
@@ -74,6 +75,14 @@ public class QuestPopups : IDisposable
 		}
 		if (AssetLoader.Get() != null && !string.IsNullOrEmpty(completedAchieve.CustomVisualWidget))
 		{
+			// These would require a custom accessibility implementation for each possible widget. At the time of writing there are just three of these.
+			// TODO: since there aren't that many, maybe we can do it. New ones should be suppressed by default though.
+			Log.Accessibility.PrintWarning("Suppressing the showing of a custom reward widget for achievement with id {0}. Object prefab is {1}", completedAchieve.ID, completedAchieve.CustomVisualWidget);
+			completedAchieves.Remove(completedAchieve);
+			completedAchieve.AckCurrentProgressAndRewardNotices();
+			SetIsShowing?.Invoke(false);
+			return true;
+
 			AssetLoader.Get().InstantiatePrefab(completedAchieve.CustomVisualWidget, ONAssetLoad);
 		}
 		else if (!completedAchieve.UseGenericRewardVisual)
@@ -124,7 +133,7 @@ public class QuestPopups : IDisposable
 
 	public void ShowQuestProgressToasts(List<Achievement> progressedAchieves)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber("ShowQuestProgressToasts") && (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE || !UniversalInputManager.UsePhoneUI))
+		if (UserAttentionManager.CanShowAttentionGrabber(true, "ShowQuestProgressToasts") && (SceneMgr.Get().GetMode() != SceneMgr.Mode.ADVENTURE || !UniversalInputManager.UsePhoneUI))
 		{
 			if (QuestManager.Get() != null && QuestToastManager.Get() != null)
 			{
diff --git a/Assembly-CSharp/QuestProgressToast.cs b/Assembly-CSharp/QuestProgressToast.cs
index 4f5e937..1057d6d 100644
--- a/Assembly-CSharp/QuestProgressToast.cs
+++ b/Assembly-CSharp/QuestProgressToast.cs
@@ -1,5 +1,6 @@
 using Blizzard.T5.MaterialService.Extensions;
 using UnityEngine;
+using Accessibility;
 
 public class QuestProgressToast : GameToast
 {
@@ -32,5 +33,18 @@ public class QuestProgressToast : GameToast
 		}
 		m_questTitle.Text = title;
 		m_questDescription.Text = description;
-	}
+
+		// Accessibility
+		if (maxProgress > 1)
+        {
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_TITLE));
+			AccessibilityMgr.OutputNotification(m_questTitle.Text);
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Format(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_PROGRESS, progress, maxProgress));
+        }
+		else
+        {
+			AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_PROGRESS_TOAST_TITLE));
+			AccessibilityMgr.OutputNotification(m_questTitle.Text);
+        }
+    }
 }
diff --git a/Assembly-CSharp/QuestTile.cs b/Assembly-CSharp/QuestTile.cs
index 2814939..09b08a3 100644
--- a/Assembly-CSharp/QuestTile.cs
+++ b/Assembly-CSharp/QuestTile.cs
@@ -74,7 +74,7 @@ public class QuestTile : MonoBehaviour
 	[CustomEditField(Sections = "Special Event FX")]
 	public List<SpecialEventFxEntry> m_specialEventFx = new List<SpecialEventFxEntry>();
 
-	private Achievement m_quest;
+	internal Achievement m_quest;
 
 	private bool m_canShowCancelButton;
 
diff --git a/Assembly-CSharp/QuestToast.cs b/Assembly-CSharp/QuestToast.cs
index a0c2314..1ad743c 100644
--- a/Assembly-CSharp/QuestToast.cs
+++ b/Assembly-CSharp/QuestToast.cs
@@ -3,6 +3,7 @@ using Blizzard.T5.Services;
 using Hearthstone.UI;
 using Hearthstone.UI.Core;
 using UnityEngine;
+using Accessibility;
 
 public class QuestToast : MonoBehaviour
 {
@@ -133,7 +134,7 @@ public class QuestToast : MonoBehaviour
 
 	public static void ShowQuestToast(UserAttentionBlocker blocker, DelOnCloseQuestToast onClosedCallback, object callbackUserData, bool updateCacheValues, Achievement quest, bool fullscreenEffects)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "ShowQuestToast:" + ((quest == null) ? "null" : quest.ID.ToString())))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "ShowQuestToast:" + ((quest == null) ? "null" : quest.ID.ToString())))
 		{
 			onClosedCallback?.Invoke(callbackUserData);
 			return;
@@ -176,7 +177,7 @@ public class QuestToast : MonoBehaviour
 
 	public static void ShowQuestToastPopup(UserAttentionBlocker blocker, DelOnCloseQuestToast onClosedCallback, object callbackUserData, RewardData rewardData, string name, string description, bool fullscreenEffects, bool updateCacheValues, Achievement quest)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "ShowQuestToastPopup:" + ((rewardData == null) ? "null" : (rewardData.Origin.ToString() + ":" + rewardData.OriginData + ":" + rewardData.RewardType))))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "ShowQuestToastPopup:" + ((rewardData == null) ? "null" : (rewardData.Origin.ToString() + ":" + rewardData.OriginData + ":" + rewardData.RewardType))))
 		{
 			onClosedCallback?.Invoke(callbackUserData);
 			return;
@@ -273,6 +274,10 @@ public class QuestToast : MonoBehaviour
 		m_clickCatcher.AddEventListener(UIEventType.RELEASE, CloseQuestToast);
 		m_questName.Text = m_toastName;
 		m_requirement.Text = m_toastDescription;
+		AccessibilityMgr.OutputNotification(LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.TOAST_QUEST_TOAST_TITLE));
+		AccessibilityMgr.OutputNotification(m_questName.Text);
+		AccessibilityMgr.OutputNotification(m_requirement.Text);
 		if (m_toastReward != null)
 		{
 			if (EventTimingManager.Get().IsEventActive(EventTimingType.SPECIAL_EVENT_GOLD_DOUBLED) && m_quest != null && m_quest.IsAffectedByDoubleGold && m_toastReward is GoldRewardData)
diff --git a/Assembly-CSharp/QuestlineController.cs b/Assembly-CSharp/QuestlineController.cs
index b7e5695..a1b3ba8 100644
--- a/Assembly-CSharp/QuestlineController.cs
+++ b/Assembly-CSharp/QuestlineController.cs
@@ -27,7 +27,7 @@ public class QuestlineController : MonoBehaviour
 
 	private Entity m_entity;
 
-	private QuestlineProgressUI m_QuestlineProgressUI;
+	internal QuestlineProgressUI m_QuestlineProgressUI;
 
 	private bool m_questCompleted;
 
diff --git a/Assembly-CSharp/QuickChatFrame.cs b/Assembly-CSharp/QuickChatFrame.cs
index 94d1ce1..c1177c7 100644
--- a/Assembly-CSharp/QuickChatFrame.cs
+++ b/Assembly-CSharp/QuickChatFrame.cs
@@ -5,6 +5,7 @@ using Blizzard.T5.Core;
 using Blizzard.T5.Fonts;
 using Blizzard.T5.Services;
 using UnityEngine;
+using Accessibility;
 
 public class QuickChatFrame : MonoBehaviour
 {
@@ -423,10 +424,15 @@ public class QuickChatFrame : MonoBehaviour
 			m_text = pendingMessage
 		};
 		UniversalInputManager.Get().UseTextInput(parms);
+		AccessibilityMgr.OutputNotification(LocalizationUtils.Get(LocalizationKey.UI_SOCIAL_CHAT_TYPE_MESSAGE_PROMPT));
+		AccessibilityMgr.AllowTextInput();
 	}
 
 	private bool OnInputPreprocess()
 	{
+		// Doesn't make a lot of sense for a11y.
+
+		return false;
 		if (m_recentPlayers.Count < 2)
 		{
 			return false;
diff --git a/Assembly-CSharp/RankChangeTwoScoop_NEW.cs b/Assembly-CSharp/RankChangeTwoScoop_NEW.cs
index de064e5..9fa122b 100644
--- a/Assembly-CSharp/RankChangeTwoScoop_NEW.cs
+++ b/Assembly-CSharp/RankChangeTwoScoop_NEW.cs
@@ -6,702 +6,882 @@ using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
+using System.Collections.Generic;
 
 [CustomEditClass]
 public class RankChangeTwoScoop_NEW : MonoBehaviour
 {
-	[CustomEditField(Sections = "Playmaker Test Data")]
-	public League.LeagueType m_testLeagueType = League.LeagueType.NORMAL;
+    [CustomEditField(Sections = "Playmaker Test Data")]
+    public League.LeagueType m_testLeagueType = League.LeagueType.NORMAL;
 
-	[CustomEditField(Sections = "Playmaker Test Data")]
-	public int m_testStarLevel = 1;
+    [CustomEditField(Sections = "Playmaker Test Data")]
+    public int m_testStarLevel = 1;
 
-	[CustomEditField(Sections = "Playmaker Test Data")]
-	public int m_testStars;
+    [CustomEditField(Sections = "Playmaker Test Data")]
+    public int m_testStars;
 
-	[CustomEditField(Sections = "Playmaker Test Data")]
-	public int m_testStarMultiplier = 1;
+    [CustomEditField(Sections = "Playmaker Test Data")]
+    public int m_testStarMultiplier = 1;
 
-	[CustomEditField(Sections = "Playmaker Test Data")]
-	public bool m_testWinStreak;
+    [CustomEditField(Sections = "Playmaker Test Data")]
+    public bool m_testWinStreak;
 
-	[CustomEditField(Sections = "Playmaker Test Data")]
-	public bool m_testLegend;
+    [CustomEditField(Sections = "Playmaker Test Data")]
+    public bool m_testLegend;
 
-	[CustomEditField(Sections = "Playmaker Test Data")]
-	public bool m_testWild;
+    [CustomEditField(Sections = "Playmaker Test Data")]
+    public bool m_testWild;
 
-	[CustomEditField(Sections = "Playmaker Test Data")]
-	public bool m_testCanLoseStars;
+    [CustomEditField(Sections = "Playmaker Test Data")]
+    public bool m_testCanLoseStars;
 
-	[CustomEditField(Sections = "Playmaker Test Data")]
-	public bool m_testCanLoseLevel;
+    [CustomEditField(Sections = "Playmaker Test Data")]
+    public bool m_testCanLoseLevel;
 
-	[CustomEditField(Sections = "Animate In")]
-	public Vector3_MobileOverride m_startScale;
+    [CustomEditField(Sections = "Animate In")]
+    public Vector3_MobileOverride m_startScale;
 
-	[CustomEditField(Sections = "Animate In")]
-	public Vector3_MobileOverride m_punchScale;
+    [CustomEditField(Sections = "Animate In")]
+    public Vector3_MobileOverride m_punchScale;
 
-	[CustomEditField(Sections = "Animate In")]
-	public Vector3_MobileOverride m_afterPunchScale;
+    [CustomEditField(Sections = "Animate In")]
+    public Vector3_MobileOverride m_afterPunchScale;
 
-	[CustomEditField(Sections = "Banner")]
-	public Float_MobileOverride m_bannerTextWidthMult;
+    [CustomEditField(Sections = "Banner")]
+    public Float_MobileOverride m_bannerTextWidthMult;
 
-	[CustomEditField(Sections = "Click Blocker")]
-	public float m_maxAnimTimeBeforeClickToContinue = 3f;
+    [CustomEditField(Sections = "Click Blocker")]
+    public float m_maxAnimTimeBeforeClickToContinue = 3f;
 
-	public AsyncReference m_prevRankedMedalWidgetReference;
+    public AsyncReference m_prevRankedMedalWidgetReference;
 
-	public AsyncReference m_currRankedMedalWidgetReference;
+    public AsyncReference m_currRankedMedalWidgetReference;
 
-	public AsyncReference m_currRankedMedalLegendTextReference;
+    public AsyncReference m_currRankedMedalLegendTextReference;
 
-	public RankedStarArray m_prevMedalStars;
+    public RankedStarArray m_prevMedalStars;
 
-	public RankedStarArray m_currMedalStars;
+    public RankedStarArray m_currMedalStars;
 
-	public RankedStarArray m_newlyEarnedStars;
+    public RankedStarArray m_newlyEarnedStars;
 
-	public RankedStarArray m_newlyEarnedStarsForRankUpRow1;
+    public RankedStarArray m_newlyEarnedStarsForRankUpRow1;
 
-	public RankedStarArray m_newlyEarnedStarsForRankUpRow2;
+    public RankedStarArray m_newlyEarnedStarsForRankUpRow2;
 
-	public GameObject m_medalGodRays;
+    public GameObject m_medalGodRays;
 
-	public GameObject m_banner;
+    public GameObject m_banner;
 
-	public UberText m_prevBannerText;
+    public UberText m_prevBannerText;
 
-	public UberText m_currBannerText;
+    public UberText m_currBannerText;
 
-	public PlayMakerFSM m_mainFSM;
+    public PlayMakerFSM m_mainFSM;
 
-	public PlayMakerFSM m_starLossFSM;
+    public PlayMakerFSM m_starLossFSM;
 
-	public PlayMakerFSM m_starGainSingleFSM;
+    public PlayMakerFSM m_starGainSingleFSM;
 
-	public PlayMakerFSM m_starGainMultiFSM;
+    public PlayMakerFSM m_starGainMultiFSM;
 
-	public PlayMakerFSM m_rankUpFSM;
+    public PlayMakerFSM m_rankUpFSM;
 
-	public PlayMakerFSM m_rankDownFSM;
+    public PlayMakerFSM m_rankDownFSM;
 
-	public UberText m_winStreakText;
+    public UberText m_winStreakText;
 
-	public UberText m_starMultiplierText;
+    public UberText m_starMultiplierText;
 
-	public UberText m_cannotLoseStarText;
+    public UberText m_cannotLoseStarText;
 
-	public UberText m_cannotLoseLevelText;
+    public UberText m_cannotLoseLevelText;
 
-	public PegUIElement m_debugClickCatcher;
+    public PegUIElement m_debugClickCatcher;
 
-	private MedalInfoTranslator m_medalInfoTranslator;
+    private MedalInfoTranslator m_medalInfoTranslator;
 
-	private FormatType m_formatType = FormatType.FT_STANDARD;
+    private FormatType m_formatType = FormatType.FT_STANDARD;
 
-	private TranslatedMedalInfo m_currMedalInfo;
+    private TranslatedMedalInfo m_currMedalInfo;
 
-	private TranslatedMedalInfo m_prevMedalInfo;
+    private TranslatedMedalInfo m_prevMedalInfo;
 
-	private RankedPlayDataModel m_currMedalDataModel;
+    private RankedPlayDataModel m_currMedalDataModel;
 
-	private RankedPlayDataModel m_prevMedalDataModel;
+    private RankedPlayDataModel m_prevMedalDataModel;
 
-	private RankedMedal m_currRankedMedal;
+    private RankedMedal m_currRankedMedal;
 
-	private RankedMedal m_prevRankedMedal;
+    private RankedMedal m_prevRankedMedal;
 
-	private Widget m_currRankedMedalWidget;
+    private Widget m_currRankedMedalWidget;
 
-	private Widget m_prevRankedMedalWidget;
+    private Widget m_prevRankedMedalWidget;
 
-	private UberText m_currRankedMedalLegendText;
+    private UberText m_currRankedMedalLegendText;
 
-	private bool m_isRankChanging;
+    private bool m_isRankChanging;
 
-	private bool m_isOnWinStreak;
+    private bool m_isOnWinStreak;
 
-	private Action m_closedCallback;
+    private Action m_closedCallback;
 
-	private bool m_isRankChangeCheat;
+    private bool m_isRankChangeCheat;
 
-	private Coroutine m_clickToContinueCoroutine;
+    private Coroutine m_clickToContinueCoroutine;
 
-	private bool m_isPlayingAnimWithCancelPoint;
+    private bool m_isPlayingAnimWithCancelPoint;
 
-	private ScreenEffectsHandle m_screenEffectsHandle;
+    private ScreenEffectsHandle m_screenEffectsHandle;
 
-	private bool IsReady
-	{
-		get
-		{
-			if (m_medalInfoTranslator == null)
-			{
-				return false;
-			}
-			if (m_prevRankedMedal == null || m_currRankedMedal == null)
-			{
-				return false;
-			}
-			if (m_currRankedMedalWidget.IsChangingStates)
-			{
-				return false;
-			}
-			if (m_isRankChanging && m_prevRankedMedalWidget.IsChangingStates)
-			{
-				return false;
-			}
-			if (m_newlyEarnedStars.IsLoading() || m_newlyEarnedStarsForRankUpRow1.IsLoading() || m_newlyEarnedStarsForRankUpRow2.IsLoading())
-			{
-				return false;
-			}
-			return true;
-		}
-	}
-
-	private void Awake()
-	{
-		m_prevBannerText.Width *= m_bannerTextWidthMult;
-		m_currBannerText.Width *= m_bannerTextWidthMult;
-		m_screenEffectsHandle = new ScreenEffectsHandle(this);
-		Reset();
-	}
-
-	private void Start()
-	{
-		m_prevRankedMedalWidgetReference.RegisterReadyListener<Widget>(OnPrevRankedMedalWidgetReady);
-		m_currRankedMedalWidgetReference.RegisterReadyListener<Widget>(OnCurrRankedMedalWidgetReady);
-		m_currRankedMedalLegendTextReference.RegisterReadyListener<UberText>(OnCurrRankedMedalLegendTextReady);
-	}
-
-	private void OnDestroy()
-	{
-		if (EndGameScreen.Get() != null)
-		{
-			EndGameScreen.Get().m_hitbox.RemoveEventListener(UIEventType.RELEASE, OnClick);
-		}
-	}
-
-	public void Initialize(MedalInfoTranslator medalInfoTranslator, FormatType formatType, Action callback)
-	{
-		if (medalInfoTranslator != null)
-		{
-			m_closedCallback = callback;
-			m_medalInfoTranslator = medalInfoTranslator;
-			m_formatType = formatType;
-			m_currMedalInfo = m_medalInfoTranslator.GetCurrentMedal(m_formatType);
-			m_prevMedalInfo = m_medalInfoTranslator.GetPreviousMedal(m_formatType);
-			RankChangeType changeType = m_medalInfoTranslator.GetChangeType(m_formatType);
-			m_isRankChanging = changeType == RankChangeType.RANK_UP || changeType == RankChangeType.RANK_DOWN;
-			m_isOnWinStreak = m_prevMedalInfo.RankConfig.WinStreakThreshold > 0 && m_currMedalInfo.winStreak >= m_prevMedalInfo.RankConfig.WinStreakThreshold;
-		}
-	}
-
-	private void InitializeFromDataModels()
-	{
-		int maxStars = m_prevMedalDataModel.MaxStars;
-		int starCountDarkened = maxStars - m_prevMedalDataModel.Stars;
-		m_prevMedalStars.Init(maxStars, starCountDarkened);
-		if (m_isRankChanging)
-		{
-			int maxStars2 = m_currMedalDataModel.MaxStars;
-			int starCountDarkened2 = maxStars2 - m_currMedalDataModel.Stars;
-			m_currMedalStars.Init(maxStars2, starCountDarkened2);
-		}
-		if (m_isRankChanging)
-		{
-			if (m_prevMedalDataModel.StarMultiplier == 1 && m_isOnWinStreak)
-			{
-				m_newlyEarnedStarsForRankUpRow1.Init(2, 0);
-			}
-			else
-			{
-				m_newlyEarnedStarsForRankUpRow1.Init(m_prevMedalDataModel.StarMultiplier, 0);
-				if (m_isOnWinStreak)
-				{
-					m_newlyEarnedStarsForRankUpRow2.Init(m_prevMedalDataModel.StarMultiplier, 0);
-				}
-			}
-		}
-		else
-		{
-			int num = m_currMedalDataModel.Stars - m_prevMedalDataModel.Stars;
-			if (num > 1)
-			{
-				m_newlyEarnedStars.Init(num, 0);
-			}
-		}
-		if (m_prevMedalDataModel.StarMultiplier > 1)
-		{
-			m_starMultiplierText.Text = GameStrings.Format("GLOBAL_RANK_STAR_MULT", m_prevMedalDataModel.StarMultiplier);
-		}
-		m_prevBannerText.Text = m_prevMedalDataModel.RankName;
-		m_currBannerText.Text = m_currMedalDataModel.RankName;
-	}
-
-	[ContextMenu("Reset")]
-	private void Reset()
-	{
-		m_banner.SetActive(value: false);
-		m_winStreakText.gameObject.SetActive(value: false);
-		m_starMultiplierText.gameObject.SetActive(value: false);
-		m_cannotLoseStarText.gameObject.SetActive(value: false);
-		m_cannotLoseLevelText.gameObject.SetActive(value: false);
-		m_medalGodRays.SetActive(value: false);
-		m_debugClickCatcher.gameObject.SetActive(value: false);
-		m_prevMedalStars.Hide();
-		m_currMedalStars.Hide();
-		m_newlyEarnedStars.Hide();
-		m_newlyEarnedStarsForRankUpRow1.Hide();
-		m_newlyEarnedStarsForRankUpRow2.Hide();
-		if (m_currRankedMedalWidget != null)
-		{
-			m_currRankedMedalWidget.Hide();
-		}
-		if (m_prevRankedMedalWidget != null)
-		{
-			m_prevRankedMedalWidget.Hide();
-		}
-		if (m_currRankedMedalLegendText != null)
-		{
-			m_currRankedMedalLegendText.Hide();
-		}
-		m_mainFSM.SendEvent("Reset");
-		m_starLossFSM.SendEvent("Reset");
-		m_starGainSingleFSM.SendEvent("Reset");
-		m_starGainMultiFSM.SendEvent("Reset");
-		m_rankUpFSM.SendEvent("Reset");
-		m_rankDownFSM.SendEvent("Reset");
-		m_isPlayingAnimWithCancelPoint = false;
-	}
-
-	public void Show()
-	{
-		Action<object> showFunc = delegate
-		{
-			AnimationUtil.ShowWithPunch(base.gameObject, m_startScale, m_punchScale, m_afterPunchScale, "OnShown", noFade: true);
-			m_mainFSM.SendEvent("Birth");
-		};
-		StartCoroutine(ShowWhenReady(showFunc));
-	}
-
-	private void OnPrevRankedMedalWidgetReady(Widget widget)
-	{
-		m_prevRankedMedal = widget.GetComponentInChildren<RankedMedal>();
-		m_prevRankedMedalWidget = widget;
-		m_prevRankedMedalWidget.Hide();
-	}
-
-	private void OnCurrRankedMedalWidgetReady(Widget widget)
-	{
-		m_currRankedMedal = widget.GetComponentInChildren<RankedMedal>();
-		m_currRankedMedalWidget = widget;
-		m_currRankedMedalWidget.Hide();
-	}
-
-	private void OnCurrRankedMedalLegendTextReady(UberText text)
-	{
-		m_currRankedMedalLegendText = text;
-	}
-
-	private IEnumerator ShowWhenReady(Action<object> showFunc)
-	{
-		while (m_prevRankedMedalWidget == null || m_currRankedMedalWidget == null)
-		{
-			yield return null;
-		}
-		m_prevMedalDataModel = m_prevMedalInfo.CreateDataModel(RankedMedal.DisplayMode.Default);
-		m_prevRankedMedalWidget.BindDataModel(m_prevMedalDataModel);
-		m_currMedalDataModel = m_currMedalInfo.CreateDataModel(RankedMedal.DisplayMode.Default);
-		m_currRankedMedalWidget.BindDataModel(m_currMedalDataModel);
-		InitializeFromDataModels();
-		while (!IsReady)
-		{
-			yield return null;
-		}
-		m_banner.SetActive(value: true);
-		m_prevBannerText.gameObject.SetActive(value: true);
-		m_currBannerText.gameObject.SetActive(value: false);
-		m_medalGodRays.SetActive(value: true);
-		m_prevMedalStars.Show();
-		if (m_isRankChanging)
-		{
-			m_prevRankedMedalWidget.Show();
-		}
-		else
-		{
-			m_currRankedMedalWidget.Show();
-			m_currRankedMedalLegendText.Hide();
-		}
-		showFunc(this);
-	}
-
-	private void OnShown()
-	{
-		m_clickToContinueCoroutine = StartCoroutine(EnableClickToContinueAfterDelay(m_maxAnimTimeBeforeClickToContinue));
-		switch (m_medalInfoTranslator.GetChangeType(m_formatType))
-		{
-		case RankChangeType.RANK_UP:
-			PlayRankUp();
-			break;
-		case RankChangeType.RANK_DOWN:
-			PlayRankDown();
-			break;
-		case RankChangeType.RANK_SAME:
-			PlayStarChange(m_prevMedalInfo.CanLoseStars(), m_prevMedalInfo.CanLoseLevel());
-			break;
-		case RankChangeType.NO_GAME_PLAYED:
-			HandleMissingRankChange();
-			break;
-		default:
-			EnableClickToContinue();
-			break;
-		}
-	}
-
-	private IEnumerator EnableClickToContinueAfterDelay(float delay)
-	{
-		yield return new WaitForSeconds(delay);
-		EnableClickToContinue();
-	}
-
-	private void EnableClickToContinue()
-	{
-		if (EndGameScreen.Get() != null)
-		{
-			EndGameScreen.Get().m_hitbox.AddEventListener(UIEventType.RELEASE, OnClick);
-		}
-		if (m_isRankChangeCheat)
-		{
-			m_debugClickCatcher.AddEventListener(UIEventType.RELEASE, OnClick);
-		}
-	}
-
-	private void OnPlayMakerCancelPointPassed()
-	{
-		m_isPlayingAnimWithCancelPoint = false;
-	}
-
-	private void OnPlayMakerFinished()
-	{
-		m_isPlayingAnimWithCancelPoint = false;
-		EnableClickToContinue();
-		if (m_medalInfoTranslator.GetChangeType(m_formatType) == RankChangeType.RANK_UP && Gameplay.Get() != null)
-		{
-			Gameplay.Get().UpdateFriendlySideMedalChange(m_medalInfoTranslator);
-		}
-	}
-
-	private void OnClick(UIEvent e)
-	{
-		if (m_isPlayingAnimWithCancelPoint)
-		{
-			m_isPlayingAnimWithCancelPoint = false;
-			switch (m_medalInfoTranslator.GetChangeType(m_formatType))
-			{
-			case RankChangeType.RANK_UP:
-				m_rankUpFSM.SendEvent("Cancel");
-				break;
-			case RankChangeType.RANK_DOWN:
-				m_rankDownFSM.SendEvent("Cancel");
-				break;
-			}
-		}
-		else
-		{
-			Hide();
-		}
-	}
-
-	private void Hide()
-	{
-		m_mainFSM.SendEvent("Death");
-		if (m_clickToContinueCoroutine != null)
-		{
-			StopCoroutine(m_clickToContinueCoroutine);
-		}
-		if (EndGameScreen.Get() != null)
-		{
-			EndGameScreen.Get().m_hitbox.RemoveEventListener(UIEventType.RELEASE, OnClick);
-		}
-		if (base.gameObject != null)
-		{
-			AnimationUtil.ScaleFade(base.gameObject, new Vector3(0.1f, 0.1f, 0.1f), "DestroyRankChange");
-		}
-		if (m_isRankChangeCheat)
-		{
-			m_screenEffectsHandle.StopEffect();
-		}
-	}
-
-	private void DestroyRankChange()
-	{
-		if (m_closedCallback != null)
-		{
-			m_closedCallback();
-		}
-		UnityEngine.Object.Destroy(base.gameObject);
-	}
-
-	private void PlayRankUp()
-	{
-		PopuplateBasicFsmVars(m_rankUpFSM);
-		m_currMedalStars.PopulateFsmArrayWithStars(m_rankUpFSM, "NewlyEarnedMedalStars", 0, m_currMedalDataModel.Stars);
-		m_newlyEarnedStarsForRankUpRow1.PopulateFsmArrayWithStars(m_rankUpFSM, "NewlyEarnedStarsRow1");
-		if (m_isOnWinStreak)
-		{
-			m_newlyEarnedStarsForRankUpRow2.PopulateFsmArrayWithStars(m_rankUpFSM, "NewlyEarnedStarsRow2");
-		}
-		FsmGameObject fsmGameObject = m_rankUpFSM.FsmVariables.GetFsmGameObject("LegendRankText");
-		if (fsmGameObject != null)
-		{
-			fsmGameObject.Value = m_currRankedMedalLegendText.gameObject;
-		}
-		m_isPlayingAnimWithCancelPoint = true;
-		m_rankUpFSM.SendEvent("StartAnim");
-	}
-
-	private void PlayRankDown()
-	{
-		m_isPlayingAnimWithCancelPoint = true;
-		m_rankDownFSM.SendEvent("StartAnim");
-	}
-
-	private void PlayStarChange(bool canLoseStars, bool canLoseLevel)
-	{
-		int num = m_currMedalDataModel.Stars - m_prevMedalDataModel.Stars;
-		if (num < 0)
-		{
-			int startIndex = m_prevMedalDataModel.Stars - 1;
-			int count = Mathf.Abs(num);
-			m_prevMedalStars.PopulateFsmArrayWithStars(m_starLossFSM, "LostMedalStars", startIndex, count);
-			m_starLossFSM.SendEvent("StartAnim");
-			return;
-		}
-		switch (num)
-		{
-		case 0:
-			if (m_currMedalDataModel.IsLegend)
-			{
-				m_currRankedMedalLegendText.Show();
-			}
-			else if (!m_currMedalDataModel.IsNewPlayer)
-			{
-				if (!canLoseStars)
-				{
-					m_cannotLoseStarText.gameObject.SetActive(value: true);
-				}
-				else if (!canLoseLevel)
-				{
-					m_cannotLoseLevelText.gameObject.SetActive(value: true);
-				}
-			}
-			EnableClickToContinue();
-			break;
-		case 1:
-			if (m_prevMedalDataModel.Stars > 0)
-			{
-				m_prevMedalStars.PopulateFsmArrayWithStars(m_starGainSingleFSM, "AlreadyEarnedMedalStars", 0, m_prevMedalDataModel.Stars);
-			}
-			m_prevMedalStars.PopulateFsmArrayWithStars(m_starGainSingleFSM, "NewlyEarnedMedalStars", m_prevMedalDataModel.Stars, num);
-			m_starGainSingleFSM.SendEvent("StartAnim");
-			break;
-		default:
-			PopuplateBasicFsmVars(m_starGainMultiFSM);
-			m_prevMedalStars.PopulateFsmArrayWithStars(m_starGainMultiFSM, "UnearnedMedalStars", m_prevMedalDataModel.Stars, num);
-			m_newlyEarnedStars.PopulateFsmArrayWithStars(m_starGainMultiFSM, "NewlyEarnedStars");
-			m_starGainMultiFSM.SendEvent("StartAnim");
-			break;
-		}
-	}
-
-	private void PopuplateBasicFsmVars(PlayMakerFSM fsm)
-	{
-		FsmBool fsmBool = fsm.FsmVariables.GetFsmBool("IsWinStreak");
-		if (fsmBool != null)
-		{
-			fsmBool.Value = m_isOnWinStreak;
-		}
-		FsmInt fsmInt = fsm.FsmVariables.GetFsmInt("StarMultiplier");
-		if (fsmInt != null)
-		{
-			fsmInt.Value = m_prevMedalDataModel.StarMultiplier;
-		}
-		FsmBool fsmBool2 = fsm.FsmVariables.GetFsmBool("IsLegend");
-		if (fsmBool2 != null)
-		{
-			fsmBool2.Value = m_currMedalDataModel.IsLegend;
-		}
-	}
-
-	private void HandleMissingRankChange()
-	{
-		EnableClickToContinue();
-	}
-
-	public static void DebugShowFake(int leagueId, int starLevel, int stars, int starsPerWin, FormatType formatType, bool isWinStreak, bool showWin)
-	{
-		DebugShowHelper(MedalInfoTranslator.DebugCreateMedalInfo(leagueId, starLevel, stars, starsPerWin, formatType, isWinStreak, showWin), formatType);
-	}
-
-	public static void DebugShowHelper(MedalInfoTranslator medalInfoTranslator, FormatType formatType)
-	{
-		PrefabCallback<GameObject> callback = delegate(AssetReference assetRef, GameObject go, object callbackData)
-		{
-			RankChangeTwoScoop_NEW component = go.GetComponent<RankChangeTwoScoop_NEW>();
-			if ((bool)UniversalInputManager.UsePhoneUI)
-			{
-				component.transform.localPosition = new Vector3(0f, 156.5f, 1.34f);
-			}
-			else
-			{
-				component.transform.localPosition = new Vector3(0f, 292f, -9f);
-			}
-			component.ActivateDebugEquivalentsOfEndGameScreen();
-			component.Initialize(medalInfoTranslator, formatType, null);
-			component.Show();
-		};
-		AssetLoader.Get().InstantiatePrefab(RankMgr.RANK_CHANGE_TWO_SCOOP_PREFAB_NEW, callback);
-	}
-
-	private void ActivateDebugEquivalentsOfEndGameScreen()
-	{
-		m_isRankChangeCheat = true;
-		m_screenEffectsHandle.StartEffect(ScreenEffectParameters.BlurVignetteDesaturatePerspective);
-		m_debugClickCatcher.gameObject.SetActive(value: true);
-	}
-
-	[ContextMenu("Test StarLoss")]
-	private void TestStarLoss()
-	{
-		m_isRankChanging = false;
-		m_prevMedalDataModel = PrepareFakeDataModel();
-		m_currMedalDataModel = PrepareFakeDataModel();
-		if (m_currMedalDataModel.Stars == 0)
-		{
-			m_prevMedalDataModel.Stars = 1;
-		}
-		else
-		{
-			m_currMedalDataModel.Stars--;
-		}
-		TestShow(delegate
-		{
-			PlayStarChange(m_testCanLoseStars, m_testCanLoseLevel);
-		});
-	}
-
-	[ContextMenu("Test StarGainSingle")]
-	private void TestStarGainSingle()
-	{
-		m_isRankChanging = false;
-		m_isOnWinStreak = m_testWinStreak;
-		m_prevMedalDataModel = PrepareFakeDataModel();
-		m_currMedalDataModel = PrepareFakeDataModel();
-		m_currMedalDataModel.Stars++;
-		m_currMedalDataModel.Stars = Mathf.Max(3, m_currMedalDataModel.Stars);
-		TestShow(delegate
-		{
-			PlayStarChange(m_testCanLoseStars, m_testCanLoseLevel);
-		});
-	}
-
-	[ContextMenu("Test StarGainMulti")]
-	private void TestStarGainMulti()
-	{
-		m_isRankChanging = false;
-		m_isOnWinStreak = m_testWinStreak;
-		m_prevMedalDataModel = PrepareFakeDataModel();
-		m_currMedalDataModel = PrepareFakeDataModel();
-		int num = m_testStarMultiplier;
-		if (m_testWinStreak)
-		{
-			num *= 2;
-		}
-		m_currMedalDataModel.Stars += num;
-		m_currMedalDataModel.Stars = Mathf.Max(3, m_currMedalDataModel.Stars);
-		TestShow(delegate
-		{
-			PlayStarChange(m_testCanLoseStars, m_testCanLoseLevel);
-		});
-	}
-
-	[ContextMenu("Test RankUp")]
-	private void TestRankUp()
-	{
-		m_isRankChanging = true;
-		m_isOnWinStreak = m_testWinStreak;
-		m_prevMedalDataModel = PrepareFakeDataModel();
-		m_currMedalDataModel = PrepareFakeDataModel();
-		int num = m_testStarMultiplier;
-		if (m_testWinStreak)
-		{
-			num *= 2;
-		}
-		num -= m_currMedalDataModel.MaxStars - m_currMedalDataModel.Stars;
-		num = Mathf.Max(1, num);
-		int num2 = num / 3;
-		int stars = num % 3;
-		m_currMedalDataModel.StarLevel += num2;
-		m_currMedalDataModel.Stars = stars;
-		TestShow(delegate
-		{
-			PlayRankUp();
-		});
-	}
-
-	[ContextMenu("Test RankDown")]
-	private void TestRankDown()
-	{
-		m_isRankChanging = true;
-		m_prevMedalDataModel = PrepareFakeDataModel();
-		m_currMedalDataModel = PrepareFakeDataModel();
-		m_currMedalDataModel.StarLevel--;
-		m_currMedalDataModel.StarLevel = Mathf.Max(1, m_currMedalDataModel.StarLevel);
-		m_currMedalDataModel.Stars = 2;
-		TestShow(delegate
-		{
-			PlayRankDown();
-		});
-	}
-
-	private bool TestShow(Action<object> showFunc)
-	{
-		if (m_medalInfoTranslator == null)
-		{
-			m_medalInfoTranslator = new MedalInfoTranslator();
-		}
-		Reset();
-		if (m_prevRankedMedalWidget != null)
-		{
-			m_prevRankedMedalWidget.BindDataModel(m_prevMedalDataModel);
-		}
-		if (m_isRankChanging && m_currRankedMedalWidget != null)
-		{
-			m_currRankedMedalWidget.BindDataModel(m_currMedalDataModel);
-		}
-		InitializeFromDataModels();
-		StartCoroutine(ShowWhenReady(showFunc));
-		return true;
-	}
-
-	private RankedPlayDataModel PrepareFakeDataModel()
-	{
-		return new RankedPlayDataModel
-		{
-			Stars = m_testStars,
-			MaxStars = 3,
-			StarMultiplier = m_testStarMultiplier,
-			StarLevel = m_testStarLevel,
-			MedalText = m_testStarLevel.ToString(),
-			RankName = m_testStarLevel.ToString(),
-			IsNewPlayer = (m_testLeagueType == League.LeagueType.NEW_PLAYER),
-			IsLegend = m_testLegend,
-			LegendRank = 1337,
-			FormatType = m_formatType
-		};
-	}
+    private bool IsReady
+    {
+        get
+        {
+            if (m_medalInfoTranslator == null)
+            {
+                return false;
+            }
+            if (m_prevRankedMedal == null || m_currRankedMedal == null)
+            {
+                return false;
+            }
+            if (m_currRankedMedalWidget.IsChangingStates)
+            {
+                return false;
+            }
+            if (m_isRankChanging && m_prevRankedMedalWidget.IsChangingStates)
+            {
+                return false;
+            }
+            if (m_newlyEarnedStars.IsLoading() || m_newlyEarnedStarsForRankUpRow1.IsLoading() || m_newlyEarnedStarsForRankUpRow2.IsLoading())
+            {
+                return false;
+            }
+            return true;
+        }
+    }
+
+    private void Awake()
+    {
+        m_prevBannerText.Width *= m_bannerTextWidthMult;
+        m_currBannerText.Width *= m_bannerTextWidthMult;
+        m_screenEffectsHandle = new ScreenEffectsHandle(this);
+        Reset();
+    }
+
+    private void Start()
+    {
+        m_prevRankedMedalWidgetReference.RegisterReadyListener<Widget>(OnPrevRankedMedalWidgetReady);
+        m_currRankedMedalWidgetReference.RegisterReadyListener<Widget>(OnCurrRankedMedalWidgetReady);
+        m_currRankedMedalLegendTextReference.RegisterReadyListener<UberText>(OnCurrRankedMedalLegendTextReady);
+    }
+
+    private void OnDestroy()
+    {
+        if (EndGameScreen.Get() != null)
+        {
+            EndGameScreen.Get().m_hitbox.RemoveEventListener(UIEventType.RELEASE, OnClick);
+        }
+    }
+
+    public void Initialize(MedalInfoTranslator medalInfoTranslator, FormatType formatType, Action callback)
+    {
+        if (medalInfoTranslator != null)
+        {
+            m_closedCallback = callback;
+            m_medalInfoTranslator = medalInfoTranslator;
+            m_formatType = formatType;
+            m_currMedalInfo = m_medalInfoTranslator.GetCurrentMedal(m_formatType);
+            m_prevMedalInfo = m_medalInfoTranslator.GetPreviousMedal(m_formatType);
+            RankChangeType changeType = m_medalInfoTranslator.GetChangeType(m_formatType);
+            m_isRankChanging = changeType == RankChangeType.RANK_UP || changeType == RankChangeType.RANK_DOWN;
+            m_isOnWinStreak = m_prevMedalInfo.RankConfig.WinStreakThreshold > 0 && m_currMedalInfo.winStreak >= m_prevMedalInfo.RankConfig.WinStreakThreshold;
+        }
+    }
+
+    private void InitializeFromDataModels()
+    {
+        int maxStars = m_prevMedalDataModel.MaxStars;
+        int starCountDarkened = maxStars - m_prevMedalDataModel.Stars;
+        m_prevMedalStars.Init(maxStars, starCountDarkened);
+        if (m_isRankChanging)
+        {
+            int maxStars2 = m_currMedalDataModel.MaxStars;
+            int starCountDarkened2 = maxStars2 - m_currMedalDataModel.Stars;
+            m_currMedalStars.Init(maxStars2, starCountDarkened2);
+        }
+        if (m_isRankChanging)
+        {
+            if (m_prevMedalDataModel.StarMultiplier == 1 && m_isOnWinStreak)
+            {
+                m_newlyEarnedStarsForRankUpRow1.Init(2, 0);
+            }
+            else
+            {
+                m_newlyEarnedStarsForRankUpRow1.Init(m_prevMedalDataModel.StarMultiplier, 0);
+                if (m_isOnWinStreak)
+                {
+                    m_newlyEarnedStarsForRankUpRow2.Init(m_prevMedalDataModel.StarMultiplier, 0);
+                }
+            }
+        }
+        else
+        {
+            int num = m_currMedalDataModel.Stars - m_prevMedalDataModel.Stars;
+            if (num > 1)
+            {
+                m_newlyEarnedStars.Init(num, 0);
+            }
+        }
+        if (m_prevMedalDataModel.StarMultiplier > 1)
+        {
+            m_starMultiplierText.Text = GameStrings.Format("GLOBAL_RANK_STAR_MULT", m_prevMedalDataModel.StarMultiplier);
+        }
+        m_prevBannerText.Text = m_prevMedalDataModel.RankName;
+        m_currBannerText.Text = m_currMedalDataModel.RankName;
+    }
+
+    [ContextMenu("Reset")]
+    private void Reset()
+    {
+        m_banner.SetActive(value: false);
+        m_winStreakText.gameObject.SetActive(value: false);
+        m_starMultiplierText.gameObject.SetActive(value: false);
+        m_cannotLoseStarText.gameObject.SetActive(value: false);
+        m_cannotLoseLevelText.gameObject.SetActive(value: false);
+        m_medalGodRays.SetActive(value: false);
+        m_debugClickCatcher.gameObject.SetActive(value: false);
+        m_prevMedalStars.Hide();
+        m_currMedalStars.Hide();
+        m_newlyEarnedStars.Hide();
+        m_newlyEarnedStarsForRankUpRow1.Hide();
+        m_newlyEarnedStarsForRankUpRow2.Hide();
+        if (m_currRankedMedalWidget != null)
+        {
+            m_currRankedMedalWidget.Hide();
+        }
+        if (m_prevRankedMedalWidget != null)
+        {
+            m_prevRankedMedalWidget.Hide();
+        }
+        if (m_currRankedMedalLegendText != null)
+        {
+            m_currRankedMedalLegendText.Hide();
+        }
+        m_mainFSM.SendEvent("Reset");
+        m_starLossFSM.SendEvent("Reset");
+        m_starGainSingleFSM.SendEvent("Reset");
+        m_starGainMultiFSM.SendEvent("Reset");
+        m_rankUpFSM.SendEvent("Reset");
+        m_rankDownFSM.SendEvent("Reset");
+        m_isPlayingAnimWithCancelPoint = false;
+    }
+
+    public void Show()
+    {
+        Action<object> showFunc = delegate
+        {
+            AnimationUtil.ShowWithPunch(base.gameObject, m_startScale, m_punchScale, m_afterPunchScale, "OnShown", noFade: true);
+            m_mainFSM.SendEvent("Birth");
+        };
+        StartCoroutine(ShowWhenReady(showFunc));
+    }
+
+    private void OnPrevRankedMedalWidgetReady(Widget widget)
+    {
+        m_prevRankedMedal = widget.GetComponentInChildren<RankedMedal>();
+        m_prevRankedMedalWidget = widget;
+        m_prevRankedMedalWidget.Hide();
+    }
+
+    private void OnCurrRankedMedalWidgetReady(Widget widget)
+    {
+        m_currRankedMedal = widget.GetComponentInChildren<RankedMedal>();
+        m_currRankedMedalWidget = widget;
+        m_currRankedMedalWidget.Hide();
+    }
+
+    private void OnCurrRankedMedalLegendTextReady(UberText text)
+    {
+        m_currRankedMedalLegendText = text;
+    }
+
+    private IEnumerator ShowWhenReady(Action<object> showFunc)
+    {
+        while (m_prevRankedMedalWidget == null || m_currRankedMedalWidget == null)
+        {
+            yield return null;
+        }
+        m_prevMedalDataModel = m_prevMedalInfo.CreateDataModel(RankedMedal.DisplayMode.Default);
+        m_prevRankedMedalWidget.BindDataModel(m_prevMedalDataModel);
+        m_currMedalDataModel = m_currMedalInfo.CreateDataModel(RankedMedal.DisplayMode.Default);
+        m_currRankedMedalWidget.BindDataModel(m_currMedalDataModel);
+        InitializeFromDataModels();
+        while (!IsReady)
+        {
+            yield return null;
+        }
+        m_banner.SetActive(value: true);
+        m_prevBannerText.gameObject.SetActive(value: true);
+        m_currBannerText.gameObject.SetActive(value: false);
+        m_medalGodRays.SetActive(value: true);
+        m_prevMedalStars.Show();
+        if (m_isRankChanging)
+        {
+            m_prevRankedMedalWidget.Show();
+        }
+        else
+        {
+            m_currRankedMedalWidget.Show();
+            m_currRankedMedalLegendText.Hide();
+        }
+        showFunc(this);
+    }
+
+    private void OnShown()
+    {
+        m_clickToContinueCoroutine = StartCoroutine(EnableClickToContinueAfterDelay(m_maxAnimTimeBeforeClickToContinue));
+        switch (m_medalInfoTranslator.GetChangeType(m_formatType))
+        {
+            case RankChangeType.RANK_UP:
+                PlayRankUp();
+                break;
+            case RankChangeType.RANK_DOWN:
+                PlayRankDown();
+                break;
+            case RankChangeType.RANK_SAME:
+                PlayStarChange(m_prevMedalInfo.CanLoseStars(), m_prevMedalInfo.CanLoseLevel());
+                break;
+            case RankChangeType.NO_GAME_PLAYED:
+                HandleMissingRankChange();
+                break;
+            default:
+                EnableClickToContinue();
+                break;
+        }
+    }
+
+    private IEnumerator EnableClickToContinueAfterDelay(float delay)
+    {
+        yield return new WaitForSeconds(delay);
+        EnableClickToContinue();
+    }
+
+    private void EnableClickToContinue()
+    {
+        if (EndGameScreen.Get() != null)
+        {
+            EndGameScreen.Get().m_hitbox.AddEventListener(UIEventType.RELEASE, OnClick);
+        }
+        if (m_isRankChangeCheat)
+        {
+            m_debugClickCatcher.AddEventListener(UIEventType.RELEASE, OnClick);
+        }
+    }
+
+    private void OnPlayMakerCancelPointPassed()
+    {
+        m_isPlayingAnimWithCancelPoint = false;
+    }
+
+    private void OnPlayMakerFinished()
+    {
+        ReadCurrentRank();
+        m_isPlayingAnimWithCancelPoint = false;
+        EnableClickToContinue();
+        if (m_medalInfoTranslator.GetChangeType(m_formatType) == RankChangeType.RANK_UP && Gameplay.Get() != null)
+        {
+            Gameplay.Get().UpdateFriendlySideMedalChange(m_medalInfoTranslator);
+        }
+    }
+
+    private void OnClick(UIEvent e)
+    {
+        if (m_isPlayingAnimWithCancelPoint)
+        {
+            m_isPlayingAnimWithCancelPoint = false;
+            switch (m_medalInfoTranslator.GetChangeType(m_formatType))
+            {
+                case RankChangeType.RANK_UP:
+                    m_rankUpFSM.SendEvent("Cancel");
+                    break;
+                case RankChangeType.RANK_DOWN:
+                    m_rankDownFSM.SendEvent("Cancel");
+                    break;
+            }
+        }
+        else
+        {
+            Hide();
+        }
+    }
+
+    private void Hide()
+    {
+        AccessibleEndGameScreen.Get().ClearLines();
+
+        m_mainFSM.SendEvent("Death");
+        if (m_clickToContinueCoroutine != null)
+        {
+            StopCoroutine(m_clickToContinueCoroutine);
+        }
+        if (EndGameScreen.Get() != null)
+        {
+            EndGameScreen.Get().m_hitbox.RemoveEventListener(UIEventType.RELEASE, OnClick);
+        }
+        if (base.gameObject != null)
+        {
+            AnimationUtil.ScaleFade(base.gameObject, new Vector3(0.1f, 0.1f, 0.1f), "DestroyRankChange");
+        }
+        if (m_isRankChangeCheat)
+        {
+            AccessibleEndGameScreen.Get().OnDebugEndGameScreenHide();
+            m_screenEffectsHandle.StopEffect();
+        }
+    }
+
+    private void DestroyRankChange()
+    {
+        if (m_closedCallback != null)
+        {
+            m_closedCallback();
+        }
+        UnityEngine.Object.Destroy(base.gameObject);
+    }
+
+    private void PlayRankUp()
+    {
+        ReadRankUp();
+        PopuplateBasicFsmVars(m_rankUpFSM);
+        m_currMedalStars.PopulateFsmArrayWithStars(m_rankUpFSM, "NewlyEarnedMedalStars", 0, m_currMedalDataModel.Stars);
+        m_newlyEarnedStarsForRankUpRow1.PopulateFsmArrayWithStars(m_rankUpFSM, "NewlyEarnedStarsRow1");
+        if (m_isOnWinStreak)
+        {
+            m_newlyEarnedStarsForRankUpRow2.PopulateFsmArrayWithStars(m_rankUpFSM, "NewlyEarnedStarsRow2");
+        }
+        FsmGameObject fsmGameObject = m_rankUpFSM.FsmVariables.GetFsmGameObject("LegendRankText");
+        if (fsmGameObject != null)
+        {
+            fsmGameObject.Value = m_currRankedMedalLegendText.gameObject;
+        }
+        m_isPlayingAnimWithCancelPoint = true;
+        m_rankUpFSM.SendEvent("StartAnim");
+    }
+
+    private void PlayRankDown()
+    {
+        ReadRankDown();
+        m_isPlayingAnimWithCancelPoint = true;
+        m_rankDownFSM.SendEvent("StartAnim");
+    }
+
+    private void PlayStarChange(bool canLoseStars, bool canLoseLevel)
+    {
+        ReadStarChange(canLoseStars, canLoseLevel);
+
+        int num = m_currMedalDataModel.Stars - m_prevMedalDataModel.Stars;
+        if (num < 0)
+        {
+            int startIndex = m_prevMedalDataModel.Stars - 1;
+            int count = Mathf.Abs(num);
+            m_prevMedalStars.PopulateFsmArrayWithStars(m_starLossFSM, "LostMedalStars", startIndex, count);
+            m_starLossFSM.SendEvent("StartAnim");
+            return;
+        }
+        switch (num)
+        {
+            case 0:
+                if (m_currMedalDataModel.IsLegend)
+                {
+                    m_currRankedMedalLegendText.Show();
+                }
+                else if (!m_currMedalDataModel.IsNewPlayer)
+                {
+                    if (!canLoseStars)
+                    {
+                        m_cannotLoseStarText.gameObject.SetActive(value: true);
+                    }
+                    else if (!canLoseLevel)
+                    {
+                        m_cannotLoseLevelText.gameObject.SetActive(value: true);
+                    }
+                }
+                ReadCurrentRank();
+                EnableClickToContinue();
+                break;
+            case 1:
+                if (m_prevMedalDataModel.Stars > 0)
+                {
+                    m_prevMedalStars.PopulateFsmArrayWithStars(m_starGainSingleFSM, "AlreadyEarnedMedalStars", 0, m_prevMedalDataModel.Stars);
+                }
+                m_prevMedalStars.PopulateFsmArrayWithStars(m_starGainSingleFSM, "NewlyEarnedMedalStars", m_prevMedalDataModel.Stars, num);
+                m_starGainSingleFSM.SendEvent("StartAnim");
+                break;
+            default:
+                PopuplateBasicFsmVars(m_starGainMultiFSM);
+                m_prevMedalStars.PopulateFsmArrayWithStars(m_starGainMultiFSM, "UnearnedMedalStars", m_prevMedalDataModel.Stars, num);
+                m_newlyEarnedStars.PopulateFsmArrayWithStars(m_starGainMultiFSM, "NewlyEarnedStars");
+                m_starGainMultiFSM.SendEvent("StartAnim");
+                break;
+        }
+    }
+
+    private void PopuplateBasicFsmVars(PlayMakerFSM fsm)
+    {
+        FsmBool fsmBool = fsm.FsmVariables.GetFsmBool("IsWinStreak");
+        if (fsmBool != null)
+        {
+            fsmBool.Value = m_isOnWinStreak;
+        }
+        FsmInt fsmInt = fsm.FsmVariables.GetFsmInt("StarMultiplier");
+        if (fsmInt != null)
+        {
+            fsmInt.Value = m_prevMedalDataModel.StarMultiplier;
+        }
+        FsmBool fsmBool2 = fsm.FsmVariables.GetFsmBool("IsLegend");
+        if (fsmBool2 != null)
+        {
+            fsmBool2.Value = m_currMedalDataModel.IsLegend;
+        }
+    }
+
+    private void HandleMissingRankChange()
+    {
+        EnableClickToContinue();
+    }
+
+    public static void DebugShowFake(int leagueId, int starLevel, int stars, int starsPerWin, FormatType formatType, bool isWinStreak, bool showWin)
+    {
+        DebugShowHelper(MedalInfoTranslator.DebugCreateMedalInfo(leagueId, starLevel, stars, starsPerWin, formatType, isWinStreak, showWin), formatType);
+    }
+
+    public static void DebugShowHelper(MedalInfoTranslator medalInfoTranslator, FormatType formatType)
+    {
+        PrefabCallback<GameObject> callback = delegate (AssetReference assetRef, GameObject go, object callbackData)
+        {
+            RankChangeTwoScoop_NEW component = go.GetComponent<RankChangeTwoScoop_NEW>();
+            if ((bool)UniversalInputManager.UsePhoneUI)
+            {
+                component.transform.localPosition = new Vector3(0f, 156.5f, 1.34f);
+            }
+            else
+            {
+                component.transform.localPosition = new Vector3(0f, 292f, -9f);
+            }
+            component.ActivateDebugEquivalentsOfEndGameScreen();
+            component.Initialize(medalInfoTranslator, formatType, null);
+            component.Show();
+        };
+        AssetLoader.Get().InstantiatePrefab(RankMgr.RANK_CHANGE_TWO_SCOOP_PREFAB_NEW, callback);
+    }
+
+    private void ActivateDebugEquivalentsOfEndGameScreen()
+    {
+        m_isRankChangeCheat = true;
+        m_screenEffectsHandle.StartEffect(ScreenEffectParameters.BlurVignetteDesaturatePerspective);
+        m_debugClickCatcher.gameObject.SetActive(value: true);
+        AccessibleEndGameScreen.Get().OnDebugEndGameScreen(m_debugClickCatcher);
+    }
+
+    [ContextMenu("Test StarLoss")]
+    private void TestStarLoss()
+    {
+        m_isRankChanging = false;
+        m_prevMedalDataModel = PrepareFakeDataModel();
+        m_currMedalDataModel = PrepareFakeDataModel();
+        if (m_currMedalDataModel.Stars == 0)
+        {
+            m_prevMedalDataModel.Stars = 1;
+        }
+        else
+        {
+            m_currMedalDataModel.Stars--;
+        }
+        TestShow(delegate
+        {
+            PlayStarChange(m_testCanLoseStars, m_testCanLoseLevel);
+        });
+    }
+
+    [ContextMenu("Test StarGainSingle")]
+    private void TestStarGainSingle()
+    {
+        m_isRankChanging = false;
+        m_isOnWinStreak = m_testWinStreak;
+        m_prevMedalDataModel = PrepareFakeDataModel();
+        m_currMedalDataModel = PrepareFakeDataModel();
+        m_currMedalDataModel.Stars++;
+        m_currMedalDataModel.Stars = Mathf.Max(3, m_currMedalDataModel.Stars);
+        TestShow(delegate
+        {
+            PlayStarChange(m_testCanLoseStars, m_testCanLoseLevel);
+        });
+    }
+
+    [ContextMenu("Test StarGainMulti")]
+    private void TestStarGainMulti()
+    {
+        m_isRankChanging = false;
+        m_isOnWinStreak = m_testWinStreak;
+        m_prevMedalDataModel = PrepareFakeDataModel();
+        m_currMedalDataModel = PrepareFakeDataModel();
+        int num = m_testStarMultiplier;
+        if (m_testWinStreak)
+        {
+            num *= 2;
+        }
+        m_currMedalDataModel.Stars += num;
+        m_currMedalDataModel.Stars = Mathf.Max(3, m_currMedalDataModel.Stars);
+        TestShow(delegate
+        {
+            PlayStarChange(m_testCanLoseStars, m_testCanLoseLevel);
+        });
+    }
+
+    [ContextMenu("Test RankUp")]
+    private void TestRankUp()
+    {
+        m_isRankChanging = true;
+        m_isOnWinStreak = m_testWinStreak;
+        m_prevMedalDataModel = PrepareFakeDataModel();
+        m_currMedalDataModel = PrepareFakeDataModel();
+        int num = m_testStarMultiplier;
+        if (m_testWinStreak)
+        {
+            num *= 2;
+        }
+        num -= m_currMedalDataModel.MaxStars - m_currMedalDataModel.Stars;
+        num = Mathf.Max(1, num);
+        int num2 = num / 3;
+        int stars = num % 3;
+        m_currMedalDataModel.StarLevel += num2;
+        m_currMedalDataModel.Stars = stars;
+        TestShow(delegate
+        {
+            PlayRankUp();
+        });
+    }
+
+    [ContextMenu("Test RankDown")]
+    private void TestRankDown()
+    {
+        m_isRankChanging = true;
+        m_prevMedalDataModel = PrepareFakeDataModel();
+        m_currMedalDataModel = PrepareFakeDataModel();
+        m_currMedalDataModel.StarLevel--;
+        m_currMedalDataModel.StarLevel = Mathf.Max(1, m_currMedalDataModel.StarLevel);
+        m_currMedalDataModel.Stars = 2;
+        TestShow(delegate
+        {
+            PlayRankDown();
+        });
+    }
+
+    private bool TestShow(Action<object> showFunc)
+    {
+        if (m_medalInfoTranslator == null)
+        {
+            m_medalInfoTranslator = new MedalInfoTranslator();
+        }
+        Reset();
+        if (m_prevRankedMedalWidget != null)
+        {
+            m_prevRankedMedalWidget.BindDataModel(m_prevMedalDataModel);
+        }
+        if (m_isRankChanging && m_currRankedMedalWidget != null)
+        {
+            m_currRankedMedalWidget.BindDataModel(m_currMedalDataModel);
+        }
+        InitializeFromDataModels();
+        StartCoroutine(ShowWhenReady(showFunc));
+        return true;
+    }
+
+    private RankedPlayDataModel PrepareFakeDataModel()
+    {
+        return new RankedPlayDataModel
+        {
+            Stars = m_testStars,
+            MaxStars = 3,
+            StarMultiplier = m_testStarMultiplier,
+            StarLevel = m_testStarLevel,
+            MedalText = m_testStarLevel.ToString(),
+            RankName = m_testStarLevel.ToString(),
+            IsNewPlayer = (m_testLeagueType == League.LeagueType.NEW_PLAYER),
+            IsLegend = m_testLegend,
+            LegendRank = 1337,
+            FormatType = m_formatType
+        };
+    }
+
+    #region Accessibility
+
+    private static int WIN_STREAK_MULT = 2;
+
+    private List<string> m_outputLines = new List<string>();
+
+    private void Output(string text)
+    {
+        AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), text);
+        m_outputLines.Add(text);
+    }
+
+    private void ReadCannotLoseStars()
+    {
+        Output(GameStrings.Get("GLOBAL_RANK_SCRUB_RANK_DESC"));
+    }
+
+    private void ReadCannotLoseLevel()
+    {
+        Output(GameStrings.Get("GLOBAL_RANK_CANT_LOSE_LEVEL"));
+    }
+
+    private void ReadCurrentRank()
+    {
+        var prevRank = AccessibleRankedUtils.GetRankText(m_prevMedalInfo);
+        var curRank = AccessibleRankedUtils.GetRankText(m_currMedalInfo);
+
+        var rankChanged = !prevRank.Equals(curRank);
+
+        if (rankChanged)
+        {
+            Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_NEW_RANK, curRank));
+        }
+        else
+        {
+            Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_CURRENT_RANK, curRank));
+        }
+
+        if (!m_currMedalInfo.IsLegendRank())
+        {
+            var earnedStars = m_currMedalInfo.earnedStars;
+            var maxStars = m_currMedalInfo.RankConfig.Stars;
+
+            Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_CURRENT_STARS, earnedStars, maxStars));
+        }
+
+        // Setup accessible item so players can reread
+        AccessibleEndGameScreen.Get().SetupLines(m_outputLines);
+    }
+
+    private void ReadRankUp()
+    {
+        ReadEarnedOrLostStars();
+    }
+
+    private void ReadRankDown()
+    {
+        ReadEarnedOrLostStars();
+    }
+
+    private void ReadEarnedOrLostStars()
+    {
+        if (m_currMedalInfo.IsLegendRank())
+        {
+            if (!m_prevMedalInfo.IsLegendRank())
+            {
+                // We've just reached legend!
+                ReadEarnedStars();
+            }
+
+            return;
+        }
+
+        var curStarLevel = m_currMedalDataModel.StarLevel;
+        var prevStarLevel = m_prevMedalDataModel.StarLevel;
+        var curStars = m_currMedalDataModel.Stars;
+        var prevStars = m_prevMedalDataModel.Stars;
+
+        if (curStarLevel == prevStarLevel && curStars == prevStars)
+        {
+            // Nothing changed
+            return;
+        }
+
+        // Huge mess but there's a few bugs with star level on the previous medal which would mess everything up
+        if (prevStarLevel == curStarLevel)
+        {
+            if (prevStars < curStars)
+            {
+                ReadEarnedStars();
+            }
+            else if (prevStars > curStars)
+            {
+                ReadLostStars();
+            }
+        }
+        else if (prevStarLevel < curStarLevel)
+        {
+            ReadEarnedStars();
+        }
+        else if (prevStarLevel > curStarLevel)
+        {
+            ReadLostStars();
+        }
+    }
+
+    private void ReadLostStars()
+    {
+        Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_LOST_STARS, 1));
+    }
+
+    private void ReadEarnedStars()
+    {
+        var starBonus = m_prevMedalDataModel.StarMultiplier;
+        if (starBonus > 1)
+        {
+            Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_STAR_BONUS_MULT, starBonus));
+        }
+
+        if (m_isOnWinStreak)
+        {
+            Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_WIN_STREAK_MULT, WIN_STREAK_MULT));
+        }
+
+        var earnedStars = m_prevMedalInfo.starsPerWin;
+        if (m_isOnWinStreak)
+        {
+            earnedStars *= WIN_STREAK_MULT;
+        }
+        Output(LocalizationUtils.Format(LocalizationKey.UI_RANK_CHANGE_UI_EARNED_STARS, earnedStars));
+    }
+
+    private void ReadStarChange(bool canLoseStars, bool canLoseLevel)
+    {
+        if (m_currMedalDataModel.IsLegend)
+        {
+            return;
+        }
+        else
+        {
+            var curStarLevel = m_currMedalDataModel.StarLevel;
+            var prevStarLevel = m_prevMedalDataModel.StarLevel;
+            var curStars = m_currMedalDataModel.Stars;
+            var prevStars = m_prevMedalDataModel.Stars;
+
+            if (curStarLevel == prevStarLevel && curStars == prevStars)
+            {
+                if (!m_currMedalDataModel.IsNewPlayer)
+                {
+                    if (!canLoseStars)
+                    {
+                        ReadCannotLoseStars();
+                    }
+                    else if (!canLoseLevel)
+                    {
+                        ReadCannotLoseLevel();
+                    }
+                }
+            }
+            else
+            {
+                ReadEarnedOrLostStars();
+            }
+        }
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/RankMgr.cs b/Assembly-CSharp/RankMgr.cs
index c23b41b..0187c06 100644
--- a/Assembly-CSharp/RankMgr.cs
+++ b/Assembly-CSharp/RankMgr.cs
@@ -10,6 +10,7 @@ using PegasusClient;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class RankMgr
 {
@@ -262,6 +263,11 @@ public class RankMgr
 
 	public bool IsNewPlayer()
 	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			return CollectionManager.Cheat_IsNewPlayer();
+		}
+
 		if (!Network.ShouldBeConnectedToAurora())
 		{
 			return false;
@@ -763,14 +769,14 @@ public class RankMgr
 			{
 				ScenarioDbfRecord scenario = currentTwistSeason.GetScenario();
 				if (scenario != null)
-				{
+		{
 					foreach (ClassExclusionsDbfRecord classExclusion in scenario.ClassExclusions)
-					{
-						list.Add((TAG_CLASS)classExclusion.ClassId);
-					}
+				{
+					list.Add((TAG_CLASS)classExclusion.ClassId);
 				}
 			}
 		}
+		}
 		return list;
 	}
 
diff --git a/Assembly-CSharp/RankedBonusStarsPopup.cs b/Assembly-CSharp/RankedBonusStarsPopup.cs
index aeeadb1..5508c12 100644
--- a/Assembly-CSharp/RankedBonusStarsPopup.cs
+++ b/Assembly-CSharp/RankedBonusStarsPopup.cs
@@ -4,6 +4,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RankedBonusStarsPopup : BasicPopup
@@ -11,6 +12,7 @@ public class RankedBonusStarsPopup : BasicPopup
 	public class BonusStarsPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+		public BonusStarsPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	public UberText m_descriptionText;
@@ -29,12 +31,18 @@ public class RankedBonusStarsPopup : BasicPopup
 
 	private WidgetTemplate m_widget;
 
+	#region Accessibility
+	private RankedPlayDataModel m_rankedPlayDataModel;
+
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -74,6 +82,8 @@ public class RankedBonusStarsPopup : BasicPopup
 				m_widget.TriggerEvent("SetUp_Scene_PlayScreen");
 			}
 			m_widget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
+
+			ReadPopup();
 		}
 	}
 
@@ -85,15 +95,18 @@ public class RankedBonusStarsPopup : BasicPopup
 		}
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
 		IncrementBonusStarsPopupSeenCount();
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void OnWidgetReady()
 	{
 		IDataModel model = null;
 		m_widget.GetDataModel(123, out model);
-		if (model is RankedPlayDataModel rankedPlayDataModel && m_descriptionText != null)
+		m_rankedPlayDataModel = model as RankedPlayDataModel;
+		if (m_rankedPlayDataModel != null && m_descriptionText != null)
 		{
-			m_descriptionText.Text = GameStrings.Format("GLUE_RANKED_BONUS_STARS_DESCRIPTION", rankedPlayDataModel.StarMultiplier);
+			m_descriptionText.Text = GameStrings.Format("GLUE_RANKED_BONUS_STARS_DESCRIPTION", m_rankedPlayDataModel.StarMultiplier);
 		}
 	}
 
@@ -112,4 +125,34 @@ public class RankedBonusStarsPopup : BasicPopup
 			GameSaveDataManager.Get().SaveSubkeys(list);
 		}
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		if (m_rankedPlayDataModel == null)
+        {
+			return;
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_RANKED_BONUS_STARS_POPUP, m_rankedPlayDataModel.StarMultiplier));
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/RankedCardBackProgressDisplay.cs b/Assembly-CSharp/RankedCardBackProgressDisplay.cs
index bea9297..f22424b 100644
--- a/Assembly-CSharp/RankedCardBackProgressDisplay.cs
+++ b/Assembly-CSharp/RankedCardBackProgressDisplay.cs
@@ -4,6 +4,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class RankedCardBackProgressDisplay : MonoBehaviour
@@ -148,6 +149,8 @@ public class RankedCardBackProgressDisplay : MonoBehaviour
 			float delay = m_progressBarAnimTime / (float)m_winsNeeded;
 			StartCoroutine(WaitThenTriggerPlayMaker(delay));
 		}
+
+		ReadFooter();
 	}
 
 	private IEnumerator WaitThenTriggerPlayMaker(float delay)
@@ -181,6 +184,11 @@ public class RankedCardBackProgressDisplay : MonoBehaviour
 		{
 			AnimationUtil.ScaleFade(base.gameObject, new Vector3(0.01f, 0.01f, 0.01f), "OnClosed");
 		}
+
+		if (m_isDebugShow)
+		{
+			AccessibleEndGameScreen.Get().OnDebugEndGameScreenHide();
+		}
 	}
 
 	private void OnClosed()
@@ -206,6 +214,7 @@ public class RankedCardBackProgressDisplay : MonoBehaviour
 		m_debugClickCatcher.gameObject.SetActive(value: true);
 		m_debugClickCatcher.AddEventListener(UIEventType.RELEASE, OnClick);
 		m_isDebugShow = true;
+		AccessibleEndGameScreen.Get().OnDebugEndGameScreen(m_debugClickCatcher);
 	}
 
 	private void PositionForDebugShow()
@@ -219,4 +228,25 @@ public class RankedCardBackProgressDisplay : MonoBehaviour
 		m_screenEffectsHandle.StopEffect();
 		UnityEngine.Object.Destroy(base.transform.parent.gameObject);
 	}
+
+	#region Accessibility
+	private void ReadFooter()
+	{
+		if (m_medalInfo.GetSeasonCardBackWinsRemaining() == 0)
+		{
+			// Not incredible but given that this is a card back it's not worth it to keep a translation
+			Output(GameStrings.Get("GLOBAL_REWARD_CARD_BACK_HEADLINE"));
+		}
+		else
+		{
+			Output(m_footerText.Text);
+		}
+	}
+
+	private void Output(string text)
+	{
+		AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), text);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/RankedIntroPopup.cs b/Assembly-CSharp/RankedIntroPopup.cs
index 2e45c62..afda0e8 100644
--- a/Assembly-CSharp/RankedIntroPopup.cs
+++ b/Assembly-CSharp/RankedIntroPopup.cs
@@ -3,6 +3,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RankedIntroPopup : BasicPopup
@@ -10,6 +11,8 @@ public class RankedIntroPopup : BasicPopup
 	public class RankedIntroPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+
+		public RankedIntroPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	public GameObject SeasonIntroPackRoot;
@@ -28,6 +31,10 @@ public class RankedIntroPopup : BasicPopup
 
 	private WidgetTemplate m_widget;
 
+	#region Accessibility
+	private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+	#endregion
+
 	private bool m_starsInfoShowing = true;
 
 	protected override void Awake()
@@ -36,7 +43,7 @@ public class RankedIntroPopup : BasicPopup
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -73,6 +80,8 @@ public class RankedIntroPopup : BasicPopup
 				m_widget.TriggerEvent("SetUp_Scene_PlayScreen");
 			}
 			m_widget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
+
+			ReadPopup();
 		}
 	}
 
@@ -90,6 +99,8 @@ public class RankedIntroPopup : BasicPopup
 		}
 		m_widget.TriggerEvent("CODE_SEASONSMANAGER_HIDE");
 		IncrementRankedIntroPopupSeenCount();
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void IncrementRankedIntroPopupSeenCount()
@@ -126,4 +137,30 @@ public class RankedIntroPopup : BasicPopup
 		};
 		m_widget.BindDataModel(dataModel, SeasonIntroPackRoot);
 	}
+
+	#region Accessibility
+
+	private void ReadPopup()
+	{
+		AccessibilityMgr.ShowUI(this);
+
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RANKED_INTRO_POPUP));
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+	}
+
+	public override void HandleAccessibleInput()
+	{
+		if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+		{
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+		}
+	}
+
+	public override string GetAccessibleHelp()
+	{
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/RankedMedal.cs b/Assembly-CSharp/RankedMedal.cs
index b8bbb4f..67e5bae 100644
--- a/Assembly-CSharp/RankedMedal.cs
+++ b/Assembly-CSharp/RankedMedal.cs
@@ -33,7 +33,7 @@ public class RankedMedal : MonoBehaviour
 		}
 	}
 
-	private RankedPlayDataModel GetRankedPlayDataModel()
+	internal RankedPlayDataModel GetRankedPlayDataModel()
 	{
 		IDataModel model = null;
 		m_widget.GetDataModel(123, out model);
diff --git a/Assembly-CSharp/RankedRewardDisplay.cs b/Assembly-CSharp/RankedRewardDisplay.cs
index 2f5b92c..4f15032 100644
--- a/Assembly-CSharp/RankedRewardDisplay.cs
+++ b/Assembly-CSharp/RankedRewardDisplay.cs
@@ -5,6 +5,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
 public class RankedRewardDisplay : MonoBehaviour
@@ -130,6 +131,8 @@ public class RankedRewardDisplay : MonoBehaviour
 		{
 			EndGameScreen.Get().m_hitbox.AddEventListener(UIEventType.RELEASE, OnClick);
 		}
+
+		ReadRewardDisplay();
 	}
 
 	private void BindNextRewardItemDataModel()
@@ -164,6 +167,12 @@ public class RankedRewardDisplay : MonoBehaviour
 
 	private void OnClick(UIEvent e)
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			SendPlayMakerDeath();
+			return;
+		}
+
 		if (m_numAnimationsRemaining > 0)
 		{
 			if (!m_isAnimating)
@@ -197,6 +206,11 @@ public class RankedRewardDisplay : MonoBehaviour
 		{
 			AnimationUtil.ScaleFade(base.gameObject, new Vector3(0.01f, 0.01f, 0.01f), "OnClosed");
 		}
+
+		if (m_doPositionForDebugShow)
+		{
+			AccessibleEndGameScreen.Get().OnDebugEndGameScreenHide();
+		}
 	}
 
 	private void OnClosed()
@@ -223,6 +237,7 @@ public class RankedRewardDisplay : MonoBehaviour
 		m_debugClickCatcher.gameObject.SetActive(value: true);
 		m_debugClickCatcher.AddEventListener(UIEventType.RELEASE, OnClick);
 		m_doPositionForDebugShow = true;
+		AccessibleEndGameScreen.Get().OnDebugEndGameScreen(m_debugClickCatcher);
 	}
 
 	private void PositionForDebugShow()
@@ -242,4 +257,20 @@ public class RankedRewardDisplay : MonoBehaviour
 		m_screenEffectsHandle.StopEffect();
 		UnityEngine.Object.Destroy(base.transform.parent.gameObject);
 	}
+
+    #region Accessibility
+
+	private void ReadRewardDisplay()
+    {
+		// Note: this is a visual experience so just inform + skip
+		Output(GameStrings.Get("GLUE_RANKED_REWARD_IN_GAME_TITLE"));
+		Output(GameStrings.Get("GLUE_RANKED_REWARD_IN_GAME_FOOTER"));
+    }
+
+	private void Output(string text)
+	{
+		AccessibilityMgr.Output(AccessibleEndGameScreen.Get(), text);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/ReconnectHelperDialog.cs b/Assembly-CSharp/ReconnectHelperDialog.cs
index 634428e..f3cdefc 100644
--- a/Assembly-CSharp/ReconnectHelperDialog.cs
+++ b/Assembly-CSharp/ReconnectHelperDialog.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Blizzard.T5.Core;
 using Hearthstone;
 using UnityEngine;
@@ -24,7 +25,8 @@ public class ReconnectHelperDialog : DialogBase
 		BAD_VERSION_CAN_RESET,
 		BAD_VERSION_USE_LAUNCHER,
 		INACTIVE_TIMEOUT,
-		RESTART_REQUIRED
+		RESTART_REQUIRED,
+		EOE
 	}
 
 	private class Layout
@@ -48,9 +50,13 @@ public class ReconnectHelperDialog : DialogBase
 		public Action m_choiceButtonTwoAction;
 
 		public Action m_onInit;
-	}
 
-	public UIBButton m_continueButton;
+        #region Accessibility
+        public string m_accessibleMenuText = "Connection lost";
+        #endregion
+    }
+
+    public UIBButton m_continueButton;
 
 	public UIBButton m_choiceOneButton;
 
@@ -172,6 +178,7 @@ public class ReconnectHelperDialog : DialogBase
 	{
 		m_stateLayouts[DialogState.PROMPT] = new Layout
 		{
+			m_accessibleMenuText = AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_OFFLINE), LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_REQUIRED)),
 			m_activePanel = m_reconnectPromptPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -188,6 +195,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.FAILURE] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECT_FAILED),
 			m_activePanel = m_reconnectFailurePanel,
 			m_twoButtons = true,
 			m_successRingState = SpellStateType.DEATH,
@@ -198,6 +206,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.WIFI_DISABLED] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_NO_INTERNET),
 			m_activePanel = m_wifiDisabledPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -207,6 +216,10 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.BAD_VERSION_CAN_RESET] = new Layout
 		{
+			m_accessibleMenuText = AccessibleSpeechUtils.CombineSentences(
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER),
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY)
+            ),
 			m_activePanel = m_badVersionCanResetPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_UPDATE"),
@@ -216,6 +229,10 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.BAD_VERSION_USE_LAUNCHER] = new Layout
 		{
+			m_accessibleMenuText = AccessibleSpeechUtils.CombineSentences(
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_HEADER),
+				LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_BAD_VERSION_RESET_BODY)
+            ),
 			m_activePanel = m_badVersionUseLauncherPanel,
 			m_twoButtons = false,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_EXIT_GAME"),
@@ -224,6 +241,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.INACTIVE_TIMEOUT] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_INACTIVE_TIMEOUT),
 			m_activePanel = m_inactiveTimeoutPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get("GLUE_RECONNECT_HELPER_CONFIRM"),
@@ -233,6 +251,7 @@ public class ReconnectHelperDialog : DialogBase
 		};
 		m_stateLayouts[DialogState.RESTART_REQUIRED] = new Layout
 		{
+			m_accessibleMenuText = LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RESTART_REQUIRED),
 			m_activePanel = m_restartRequiredPanel,
 			m_twoButtons = true,
 			m_choiceOneButtonText = GameStrings.Get(HearthstoneApplication.AllowResetFromFatalError ? "GLUE_RECONNECT_HELPER_RESTART_GAME" : "GLUE_RECONNECT_HELPER_EXIT_GAME"),
@@ -273,9 +292,11 @@ public class ReconnectHelperDialog : DialogBase
 		{
 			layout.m_onInit();
 		}
+
+		ReadAccessibleDialog();
 	}
 
-	private void ChangeStateToPromptBasedOnReconnectMgr()
+    private void ChangeStateToPromptBasedOnReconnectMgr()
 	{
 		if (ReconnectMgr.Get().FullResetRequired)
 		{
@@ -356,6 +377,7 @@ public class ReconnectHelperDialog : DialogBase
 	private void OnReconnectSuccess()
 	{
 		ReconnectMgr.Get().SetNextReLoginCallback(m_reconnectSuccessCallback);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_RECONNECTED);
 		Hide();
 	}
 
@@ -404,4 +426,62 @@ public class ReconnectHelperDialog : DialogBase
 			ChangeState_FullResetRequired();
 		}
 	}
+
+    #region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+    private void ReadAccessibleDialog()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECTING));
+			return;
+        }
+
+		Layout layout = m_stateLayouts[m_state];
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null, true);
+
+		if (m_continueButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_continueButton.GetText(), () => m_continueButton.TriggerRelease());
+        }
+
+		if (m_choiceOneButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_choiceOneButton.GetText(), () => m_choiceOneButton.TriggerRelease());
+        }
+
+		if (m_choiceTwoButton.gameObject.activeInHierarchy)
+        {
+			m_accessibleMenu.AddOption(m_choiceTwoButton.GetText(), () => m_choiceTwoButton.TriggerRelease());
+        }
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_TITLE), true);
+		AccessibilityMgr.Output(this, layout?.m_accessibleMenuText);
+		m_accessibleMenu.StartReading();
+    }
+
+    public override void HandleAccessibleInput()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			return;
+        }
+
+        m_accessibleMenu?.HandleAccessibleInput();
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		if (m_state == DialogState.IN_PROGRESS)
+        {
+			return AccessibleSpeechUtils.CombineSentences(LocalizationUtils.Get(LocalizationKey.UI_RECONNECT_HELPER_DIALOG_RECONNECTING), LocalizedText.GLOBAL_PLEASE_WAIT);
+        }
+
+		return m_accessibleMenu?.GetHelp();
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/ReconnectMgr.cs b/Assembly-CSharp/ReconnectMgr.cs
index ea4f5e7..97babaa 100644
--- a/Assembly-CSharp/ReconnectMgr.cs
+++ b/Assembly-CSharp/ReconnectMgr.cs
@@ -15,6 +15,7 @@ using Hearthstone.Streaming;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class ReconnectMgr : IService, IHasUpdate
 {
@@ -243,12 +244,12 @@ public class ReconnectMgr : IService, IHasUpdate
 		{
 			return false;
 		}
-		if (SceneMgr.Get().GetNextMode() == SceneMgr.Mode.GAMEPLAY)
-		{
-			return true;
-		}
+			if (SceneMgr.Get().GetNextMode() == SceneMgr.Mode.GAMEPLAY)
+			{
+				return true;
+			}
 		if (SceneMgr.Get().GetMode() == SceneMgr.Mode.GAMEPLAY)
-		{
+			{
 			return !SceneMgr.Get().IsSceneLoaded();
 		}
 		return false;
@@ -647,12 +648,12 @@ public class ReconnectMgr : IService, IHasUpdate
 			}
 			else
 			{
-				m_gameRetryStartTimestamp = realtimeSinceStartup;
+			m_gameRetryStartTimestamp = realtimeSinceStartup;
 				GameNetLogger.Log(Blizzard.T5.Core.LogLevel.Debug, "ReconnectMgr.CheckGameplayReconnectRetry() - calling StartGame_Internal");
-				StartGame_Internal();
-			}
+			StartGame_Internal();
 		}
 	}
+	}
 
 	private void OnGameReconnectTimeout()
 	{
@@ -926,6 +927,8 @@ public class ReconnectMgr : IService, IHasUpdate
 
 	private void ChangeGameplayDialogToReconnected()
 	{
+		AccessibleGameplay.Get().OnReconnected();
+
 		if (!(m_gameplayReconnectDialog == null))
 		{
 			AlertPopup.PopupInfo popupInfo = new AlertPopup.PopupInfo();
diff --git a/Assembly-CSharp/RedundantNDEPopup.cs b/Assembly-CSharp/RedundantNDEPopup.cs
index cb279cd..5eaccf6 100644
--- a/Assembly-CSharp/RedundantNDEPopup.cs
+++ b/Assembly-CSharp/RedundantNDEPopup.cs
@@ -1,9 +1,11 @@
 using System;
 using System.Collections;
+using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
-public class RedundantNDEPopup : MonoBehaviour
+public class RedundantNDEPopup : MonoBehaviour, AccessibleUI
 {
 	public UIBButton m_rerollButton;
 
@@ -18,6 +20,7 @@ public class RedundantNDEPopup : MonoBehaviour
 	public event Action RefuseSelected;
 
 	public event Action OnDismissAnimationComplete;
+	private NDERerollPopupDataModel m_dataModel;
 
 	private void Awake()
 	{
@@ -52,9 +55,11 @@ public class RedundantNDEPopup : MonoBehaviour
 		this.RefuseSelected?.Invoke();
 	}
 
-	public void Show()
+	public void Show(NDERerollPopupDataModel dataModel)
 	{
+		m_dataModel = dataModel;
 		UIContext.GetRoot().ShowPopup(m_owner);
+		ReadPopup();
 	}
 
 	public IEnumerator Hide()
@@ -63,5 +68,35 @@ public class RedundantNDEPopup : MonoBehaviour
 		yield return new WaitForSeconds(0.4f);
 		UnityEngine.Object.Destroy(m_owner);
 		this.OnDismissAnimationComplete?.Invoke();
+		AccessibilityMgr.HideUI(this);
 	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private void ReadPopup()
+	{
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, m_dataModel.HeaderText);
+		AccessibilityMgr.Output(this, m_dataModel.BodyText);
+
+		m_accessibleMenu = new AccessibleMenu(this, LocalizedText.GLOBAL_OPTIONS, null);
+		m_accessibleMenu.AddOption(GameStrings.Get("GLOBAL_REDUNDANT_NDE_BUTTON_REROLL"), m_rerollButton.TriggerRelease);
+		m_accessibleMenu.AddOption(GameStrings.Get("GLOBAL_REDUNDANT_NDE_BUTTON_DECLINE"), m_refuseButton.TriggerRelease);
+		m_accessibleMenu.StartReading();
+	}
+
+	public void HandleAccessibleInput()
+	{
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public string GetAccessibleHelp()
+	{
+		return m_accessibleMenu.GetHelp();
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/RedundantNDERerollPopups.cs b/Assembly-CSharp/RedundantNDERerollPopups.cs
index fc6d28a..facabb3 100644
--- a/Assembly-CSharp/RedundantNDERerollPopups.cs
+++ b/Assembly-CSharp/RedundantNDERerollPopups.cs
@@ -174,17 +174,7 @@ public class RedundantNDERerollPopups : IDisposable
 			m_currentPopupInfo.m_cardId = card2.CardDbId;
 			OnPopupShown?.Invoke();
 			SetIsShowing?.Invoke(obj: true);
-			m_currentPopup = WidgetInstance.Create(POPUP_PREFAB);
-			m_currentPopup.RegisterReadyListener(delegate
-			{
-				m_currentPopupComponent = m_currentPopup.GetComponentInChildren<RedundantNDEPopup>();
-				if (m_currentPopupComponent != null)
-				{
-					m_currentPopupComponent.Show();
-					m_currentPopupComponent.RerollSelected += OnRerollSelected;
-					m_currentPopupComponent.RefuseSelected += OnRefuseSelected;
-				}
-			});
+
 			TAG_PREMIUM tAG_PREMIUM = TAG_PREMIUM.NORMAL;
 			TAG_PREMIUM tAG_PREMIUM2 = TAG_PREMIUM.NORMAL;
 			tAG_PREMIUM = ((golden > 0 && card.IsEverCraftable) ? TAG_PREMIUM.GOLDEN : TAG_PREMIUM.NORMAL);
@@ -237,6 +227,17 @@ public class RedundantNDERerollPopups : IDisposable
 				m_currentPopupInfo.m_premiumsToReroll.Add((int)tAG_PREMIUM);
 				m_currentPopupInfo.m_premiumsToReroll.Add((int)tAG_PREMIUM2);
 			}
+			m_currentPopup = WidgetInstance.Create(POPUP_PREFAB);
+			m_currentPopup.RegisterReadyListener(delegate
+			{
+				m_currentPopupComponent = m_currentPopup.GetComponentInChildren<RedundantNDEPopup>();
+				if (m_currentPopupComponent != null)
+				{
+					m_currentPopupComponent.Show(nDERerollPopupDataModel);
+					m_currentPopupComponent.RerollSelected += OnRerollSelected;
+					m_currentPopupComponent.RefuseSelected += OnRefuseSelected;
+				}
+			});
 			m_currentPopup.BindDataModel(nDERerollPopupDataModel);
 			return true;
 		}
diff --git a/Assembly-CSharp/RenderToTextureUtils.cs b/Assembly-CSharp/RenderToTextureUtils.cs
index 4af7acd..b7e09d4 100644
--- a/Assembly-CSharp/RenderToTextureUtils.cs
+++ b/Assembly-CSharp/RenderToTextureUtils.cs
@@ -122,12 +122,12 @@ public class RenderToTextureUtils
 				DrawCommandReplacement(cmd, camera.cullingMask, opaqueRenderCommand, material, replacementTag, tag);
 			}
 			{
-				foreach (RenderCommand transparentRenderCommand in renderCommands.TransparentRenderCommands)
-				{
-					DrawCommandReplacement(cmd, camera.cullingMask, transparentRenderCommand, material, replacementTag, tag);
-				}
-				return;
+			foreach (RenderCommand transparentRenderCommand in renderCommands.TransparentRenderCommands)
+			{
+				DrawCommandReplacement(cmd, camera.cullingMask, transparentRenderCommand, material, replacementTag, tag);
 			}
+			return;
+		}
 		}
 		foreach (RenderCommand opaqueRenderCommand2 in renderCommands.OpaqueRenderCommands)
 		{
diff --git a/Assembly-CSharp/ReportingPopup.cs b/Assembly-CSharp/ReportingPopup.cs
index 7d8ab29..8a99ba4 100644
--- a/Assembly-CSharp/ReportingPopup.cs
+++ b/Assembly-CSharp/ReportingPopup.cs
@@ -26,7 +26,7 @@ public class ReportingPopup : MonoBehaviour
 
 	public const string ReportDetailsSubmitReleasedEvent = "SELECT_DETAILS_SUBMIT_BUTTON_CLICKED";
 
-	private static Dictionary<ReportType.ComplaintType, List<ReportType.SubcomplaintType>> ReportReasons = new Dictionary<ReportType.ComplaintType, List<ReportType.SubcomplaintType>>
+	internal static Dictionary<ReportType.ComplaintType, List<ReportType.SubcomplaintType>> ReportReasons = new Dictionary<ReportType.ComplaintType, List<ReportType.SubcomplaintType>>
 	{
 		{
 			ReportType.ComplaintType.INAPPROPRIATE_NAME,
@@ -52,7 +52,7 @@ public class ReportingPopup : MonoBehaviour
 		}
 	};
 
-	private static Dictionary<ReportType.ComplaintType, string> ComplaintTypeLabels = new Dictionary<ReportType.ComplaintType, string>
+	internal static Dictionary<ReportType.ComplaintType, string> ComplaintTypeLabels = new Dictionary<ReportType.ComplaintType, string>
 	{
 		{
 			ReportType.ComplaintType.INAPPROPRIATE_NAME,
@@ -68,7 +68,7 @@ public class ReportingPopup : MonoBehaviour
 		}
 	};
 
-	private static Dictionary<ReportType.SubcomplaintType, string> SubcomplaintTypeLabels = new Dictionary<ReportType.SubcomplaintType, string>
+	internal static Dictionary<ReportType.SubcomplaintType, string> SubcomplaintTypeLabels = new Dictionary<ReportType.SubcomplaintType, string>
 	{
 		{
 			ReportType.SubcomplaintType.BATTLETAG,
diff --git a/Assembly-CSharp/Reward.cs b/Assembly-CSharp/Reward.cs
index 69ec147..7185ea9 100644
--- a/Assembly-CSharp/Reward.cs
+++ b/Assembly-CSharp/Reward.cs
@@ -1,8 +1,9 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
-public abstract class Reward : MonoBehaviour
+public abstract class Reward : MonoBehaviour, AccessibleUI
 {
 	public enum Type
 	{
@@ -11,34 +12,35 @@ public abstract class Reward : MonoBehaviour
 		BOOSTER_PACK,
 		CARD,
 		CARD_BACK,
-		CRAFTABLE_CARD,
-		FORGE_TICKET,
+		CRAFTABLE_CARD, // Not implemented
+		FORGE_TICKET, // Not implemented
 		GOLD,
 		MOUNT,
-		CLASS_CHALLENGE,
-		EVENT,
-		RANDOM_CARD,
-		BONUS_CHALLENGE,
-		ADVENTURE_DECK,
-		ADVENTURE_HERO_POWER,
+		CLASS_CHALLENGE, // Not implemented
+		EVENT, // Not implemented
+		RANDOM_CARD, // Not implemented
+		BONUS_CHALLENGE, // Not implemented
+		ADVENTURE_DECK, // Not implemented
+		ADVENTURE_HERO_POWER, // Not implemented
 		ARCANE_ORBS,
 		DECK,
 		MINI_SET,
-		MERCENARY_COIN,
-		MERCENARY_EXP,
-		MERCENARY_ABILITY_UNLOCK,
-		MERCENARY_EQUIPMENT,
-		REWARD_ITEM,
-		MERCENARY_BOOSTER,
-		MERCENARY_MERCENARY,
-		MERCENARY_RANDOM_MERCENARY,
-		MERCENARY_KNOCKOUT,
-		BATTLEGROUNDS_GUIDE_SKIN,
-		BATTLEGROUNDS_HERO_SKIN,
-		BATTLEGROUNDS_FINISHER,
-		BATTLEGROUNDS_BOARD_SKIN,
-		BATTLEGROUNDS_EMOTE,
-		MERCENARY_RENOWN
+		MERCENARY_COIN, // TODO
+		MERCENARY_EXP, // TODO
+		MERCENARY_ABILITY_UNLOCK, // TODO
+		MERCENARY_EQUIPMENT, // TODO
+		REWARD_ITEM, // TODO
+		MERCENARY_BOOSTER, // TODO
+		MERCENARY_MERCENARY, // TODO
+		MERCENARY_RANDOM_MERCENARY, // TODO
+		MERCENARY_KNOCKOUT, // TODO
+		BATTLEGROUNDS_GUIDE_SKIN, // TODO
+		BATTLEGROUNDS_HERO_SKIN, // TODO
+		BATTLEGROUNDS_FINISHER, // TODO
+		BATTLEGROUNDS_BOARD_SKIN, // TODO
+		BATTLEGROUNDS_EMOTE, // TODO
+		MERCENARY_RENOWN, // TODO
+		EOE
 	}
 
 	public delegate void DelOnRewardLoaded(Reward reward, object callbackData);
@@ -131,9 +133,10 @@ public abstract class Reward : MonoBehaviour
 
 	protected virtual void OnDestroy()
 	{
-	}
+        AccessibilityMgr.HideUI(this);
+    }
 
-	public void Show(bool updateCacheValues)
+    public void Show(bool updateCacheValues)
 	{
 		Data.AcknowledgeNotices();
 		if (m_MeshRoot != null)
@@ -161,6 +164,8 @@ public abstract class Reward : MonoBehaviour
 		}
 		ShowReward(updateCacheValues);
 		m_shown = true;
+
+		ReadReward();
 	}
 
 	protected virtual void PlayShowSounds()
@@ -187,10 +192,13 @@ public abstract class Reward : MonoBehaviour
 			}
 		}
 		iTween.FadeTo(base.gameObject, 0f, RewardUtils.RewardHideTime);
+		AccessibilityMgr.HideUI(this);
 	}
 
 	public virtual void Hide(bool animate = false)
 	{
+		AccessibilityMgr.HideUI(this);
+
 		if (!animate)
 		{
 			OnHideAnimateComplete();
@@ -347,11 +355,15 @@ public abstract class Reward : MonoBehaviour
 
 	private void OnHide()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		OnHideListener[] array = m_hideListeners.ToArray();
 		for (int i = 0; i < array.Length; i++)
 		{
 			array[i].Fire();
 		}
+
+		AccessibleJournal.Get().OnTrackRewardAckd(0, 0, false);
 	}
 
 	protected void UpdateBannerObject()
@@ -376,4 +388,48 @@ public abstract class Reward : MonoBehaviour
 			}
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleRewardData m_accessibleReward;
+
+	private void ReadReward()
+    {
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleReward = new AccessibleRewardData(this, m_data);
+
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_REWARD_TITLE));
+		m_accessibleReward.ReadAllLines();
+    }
+
+	public void HandleAccessibleInput()
+	{
+		if (AccessibleKey.CONFIRM.IsPressed())
+		{
+			var endGameScreen = GetComponentInParent<EndGameScreen>();
+			if (endGameScreen != null)
+			{
+				endGameScreen.m_hitbox.TriggerRelease();
+			}
+			else
+			{
+				AccessibleInputMgr.ClickCenterOfScreen(); // TODO: Refactor tests to make this the endgame screen (even if a dummy one like in rank changes)
+			}
+		}
+		else
+		{
+			m_accessibleReward.HandleAccessibleInput();
+		}
+	}
+
+    public string GetAccessibleHelp()
+    {
+		var helpText = LocalizationUtils.Get(LocalizationKey.UI_REWARD_HELP);
+		var continueHelp = AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+
+		return AccessibleSpeechUtils.CombineSentences(helpText, continueHelp);
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/RewardBoxesDisplay.cs b/Assembly-CSharp/RewardBoxesDisplay.cs
index 7bb9198..0d6d75f 100644
--- a/Assembly-CSharp/RewardBoxesDisplay.cs
+++ b/Assembly-CSharp/RewardBoxesDisplay.cs
@@ -3,9 +3,10 @@ using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class RewardBoxesDisplay : MonoBehaviour
+public class RewardBoxesDisplay : MonoBehaviour, AccessibleUI
 {
 	[Serializable]
 	public class RewardPackageData
@@ -134,6 +135,11 @@ public class RewardBoxesDisplay : MonoBehaviour
 		}
 	}
 
+	#region Accessibility
+	private List<RewardBoxData> m_rewardsBoxData = new List<RewardBoxData>();
+	private int m_pendingAnimations;
+	#endregion
+
 	public bool IsClosing { get; private set; }
 
 	private void Awake()
@@ -173,23 +179,23 @@ public class RewardBoxesDisplay : MonoBehaviour
 		if (rewards != null)
 		{
 			using List<RewardData>.Enumerator enumerator = rewards.GetEnumerator();
-			while (enumerator.MoveNext())
-			{
-				switch (enumerator.Current.RewardType)
+				while (enumerator.MoveNext())
 				{
-				case Reward.Type.MERCENARY_COIN:
-				case Reward.Type.MERCENARY_EXP:
-				case Reward.Type.MERCENARY_ABILITY_UNLOCK:
-				case Reward.Type.MERCENARY_EQUIPMENT:
-				case Reward.Type.MERCENARY_BOOSTER:
-				case Reward.Type.MERCENARY_MERCENARY:
-				case Reward.Type.MERCENARY_RANDOM_MERCENARY:
-				case Reward.Type.MERCENARY_KNOCKOUT:
-				case Reward.Type.MERCENARY_RENOWN:
-					return "RewardBoxes_Mercenary.prefab:3c55d213147b7bb4fbcf50b9145857eb";
+					switch (enumerator.Current.RewardType)
+					{
+					case Reward.Type.MERCENARY_COIN:
+					case Reward.Type.MERCENARY_EXP:
+					case Reward.Type.MERCENARY_ABILITY_UNLOCK:
+					case Reward.Type.MERCENARY_EQUIPMENT:
+					case Reward.Type.MERCENARY_BOOSTER:
+					case Reward.Type.MERCENARY_MERCENARY:
+					case Reward.Type.MERCENARY_RANDOM_MERCENARY:
+					case Reward.Type.MERCENARY_KNOCKOUT:
+					case Reward.Type.MERCENARY_RENOWN:
+						return "RewardBoxes_Mercenary.prefab:3c55d213147b7bb4fbcf50b9145857eb";
+					}
 				}
 			}
-		}
 		return "RewardBoxes.prefab:f136fead3d6a148c6801f1e3bd2e8267";
 	}
 
@@ -278,6 +284,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 
 	public void AnimateRewards()
 	{
+		AccessibilityMgr.ShowUI(this);
+
 		List<RewardData> currentPageRewards = CurrentPageRewards;
 		int count = currentPageRewards.Count;
 		m_RewardPackages = GetPackageData(count);
@@ -347,6 +355,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 			}
 		}
 		m_rewardPackageInstances.Clear();
+		m_rewardsBoxData.Clear(); // Accessibility
+		m_pendingAnimations = 0;
 		for (int i = 0; i < m_RewardPackages.Count; i++)
 		{
 			RewardPackageData rewardPackageData = m_RewardPackages[i];
@@ -382,6 +392,8 @@ public class RewardBoxesDisplay : MonoBehaviour
 			rewardBoxData.m_RewardPackage = component2;
 			rewardBoxData.m_FSM = component;
 			rewardBoxData.m_Index = i;
+			m_rewardsBoxData.Add(rewardBoxData);
+			m_pendingAnimations++;
 			iTween.MoveTo(gameObject, iTween.Hash("position", rewardPackageData.m_TargetBone.transform.position, "time", m_RewardSet.m_AnimationTime, "delay", rewardPackageData.m_StartDelay, "easetype", iTween.EaseType.linear, "onstarttarget", base.gameObject, "onstart", "RewardPackageOnStart", "onstartparams", rewardBoxData, "oncompletetarget", base.gameObject, "oncomplete", "RewardPackageOnComplete", "oncompleteparams", rewardBoxData));
 		}
 	}
@@ -401,9 +413,10 @@ public class RewardBoxesDisplay : MonoBehaviour
 		yield return new WaitForSeconds(0.5f);
 		RenderUtils.EnableColliders(boxData.m_GameObject, enable: true);
 		boxData.m_RewardPackage.AddEventListener(UIEventType.PRESS, RewardPackagePressed);
+		OnRewardPackageActivated();
 	}
 
-	private void RewardPackagePressed(UIEvent e)
+    private void RewardPackagePressed(UIEvent e)
 	{
 		Log.RewardBox.Print("box clicked!");
 	}
@@ -634,6 +647,7 @@ public class RewardBoxesDisplay : MonoBehaviour
 		{
 			FadeFullscreenEffectsOut();
 			Navigation.GoBack();
+			AccessibilityMgr.HideUI(this);
 			return;
 		}
 		m_currentPageNum++;
@@ -825,4 +839,109 @@ public class RewardBoxesDisplay : MonoBehaviour
 			Debug.Log($"  reward {i}={arg}");
 		}
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleRewardPackage> m_accessibleRewardPackages;
+
+    private void OnRewardPackageActivated()
+    {
+		m_pendingAnimations--;
+
+		if (m_pendingAnimations == 0)
+        {
+			List<AccessibleRewardPackage> rewardPackages = new List<AccessibleRewardPackage>(m_rewardsBoxData.Count);
+			m_rewardsBoxData.ForEach(r => rewardPackages.Add(new AccessibleRewardPackage(this, r, CurrentPageRewards[r.m_RewardPackage.m_RewardIndex])));
+			m_accessibleRewardPackages = new AccessibleListOfItems<AccessibleRewardPackage>(this, rewardPackages);
+
+			var numRewardPackages = m_rewardsBoxData.Count;
+
+			AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_REWARD_BOXES_DISPLAY_TITLE, numRewardPackages));
+            m_accessibleRewardPackages.StartReading();
+        }
+    }
+
+    public void HandleAccessibleInput()
+    {
+		if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			if (AllPackagesOpened())
+            {
+                m_DoneButton.TriggerRelease();
+            }
+			else
+            {
+                var focusedPackage = m_accessibleRewardPackages.GetItemBeingRead();
+
+                if (!focusedPackage.Open)
+                {
+                    focusedPackage.RewardBoxData.m_RewardPackage.TriggerPress();
+                    focusedPackage.Open = true;
+                    focusedPackage.ReadAllLines();
+
+                    OnRewardPackageOpened();
+                }
+            }
+        }
+		else
+        {
+			m_accessibleRewardPackages?.HandleAccessibleInput();
+        }
+    }
+
+    private void OnRewardPackageOpened()
+    {
+		if (AllPackagesOpened())
+        {
+            AccessibilityMgr.Output(this, GetAccessibleHelp());
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_pendingAnimations > 0)
+        {
+			return LocalizedText.GLOBAL_PLEASE_WAIT;
+        }
+		else if (AllPackagesOpened())
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+        else
+        {
+			return LocalizationUtils.Format(LocalizationKey.UI_REWARD_BOXES_DISPLAY_HELP, AccessibleKey.CONFIRM);
+        }
+    }
+
+	private bool AllPackagesOpened()
+    {
+		if (m_pendingAnimations > 0)
+        {
+			return false;
+        }
+
+		return GetNumOpenPackages() == m_rewardsBoxData.Count;
+    }
+
+    private int GetNumOpenPackages()
+    {
+        if (m_accessibleRewardPackages == null)
+        {
+			return 0;
+        }
+		else
+        {
+			var ret = 0;
+			foreach (var package in m_accessibleRewardPackages.Items)
+            {
+				if (package.Open)
+                {
+					ret++;
+                }
+            }
+
+			return ret;
+        }
+    }
+
+    #endregion
 }
diff --git a/Assembly-CSharp/RewardItemType.cs b/Assembly-CSharp/RewardItemType.cs
index 7ae9f25..54d8bf9 100644
--- a/Assembly-CSharp/RewardItemType.cs
+++ b/Assembly-CSharp/RewardItemType.cs
@@ -1,34 +1,36 @@
 public enum RewardItemType
 {
-	UNDEFINED = 0,
-	BOOSTER = 1,
-	DUST = 2,
-	HERO_SKIN = 3,
-	CARD_BACK = 4,
-	ADVENTURE_WING = 5,
-	ARENA_TICKET = 6,
-	RANDOM_CARD = 7,
-	CN_RUNESTONES = 8,
-	CN_ARCANE_ORBS = 9,
-	ADVENTURE = 10,
-	CARD = 11,
-	BATTLEGROUNDS_BONUS = 12,
-	TAVERN_BRAWL_TICKET = 13,
-	GOLD = 14,
+    UNDEFINED = 0,
+    BOOSTER = 1,
+    DUST = 2,
+    HERO_SKIN = 3,
+    CARD_BACK = 4,
+    ADVENTURE_WING = 5,
+    ARENA_TICKET = 6,
+    RANDOM_CARD = 7,
+    CN_RUNESTONES = 8,
+    CN_ARCANE_ORBS = 9,
+    ADVENTURE = 10,
+    CARD = 11,
+    BATTLEGROUNDS_BONUS = 12,
+    TAVERN_BRAWL_TICKET = 13,
+    GOLD = 14,
 	CUSTOM_COIN = 15,
 	PROGRESSION_BONUS = 16,
-	REWARD_TRACK_XP_BOOST = 17,
-	MINI_SET = 18,
-	CARD_SUBSET = 19,
-	SELLABLE_DECK = 20,
-	MERCENARY_COIN = 21,
-	MERCENARY = 22,
-	MERCENARY_XP = 23,
-	MERCENARY_EQUIPMENT = 24,
-	MERCENARY_EQUIPMENT_ICON = 25,
-	MERCENARY_BOOSTER = 26,
-	BATTLEGROUNDS_HERO_SKIN = 27,
-	BATTLEGROUNDS_GUIDE_SKIN = 28,
+    REWARD_TRACK_XP_BOOST = 17,
+    MINI_SET = 18,
+    CARD_SUBSET = 19,
+    SELLABLE_DECK = 20,
+    // TODO ALL FROM HERE vvv
+    MERCENARY_COIN = 21,
+    MERCENARY = 22,
+    MERCENARY_XP = 23,
+    MERCENARY_EQUIPMENT = 24,
+    MERCENARY_EQUIPMENT_ICON = 25,
+    MERCENARY_BOOSTER = 26,
+    // TODO ALL UNTIL HERE
+    BATTLEGROUNDS_HERO_SKIN = 27,
+    BATTLEGROUNDS_GUIDE_SKIN = 28,
 	MERCENARY_RANDOM_MERCENARY = 29,
 	MERCENARY_KNOCKOUT_SPECIFIC = 30,
 	MERCENARY_KNOCKOUT_RANDOM = 31,
@@ -45,5 +47,6 @@ public enum RewardItemType
 	HERO_CLASS = 44,
 	GAME_MODE = 45,
 	DECK = 46,
-	LOANER_DECKS = 47
+	LOANER_DECKS = 47,
+    EOE
 }
diff --git a/Assembly-CSharp/RewardPopups.cs b/Assembly-CSharp/RewardPopups.cs
index b5f77e5..42c7cda 100644
--- a/Assembly-CSharp/RewardPopups.cs
+++ b/Assembly-CSharp/RewardPopups.cs
@@ -10,6 +10,7 @@ using Hearthstone.Progression;
 using PegasusShared;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 public class RewardPopups : IDisposable
 {
@@ -69,7 +70,7 @@ public class RewardPopups : IDisposable
 	{
 		get
 		{
-			if (!UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE))
+			if (!UserAttentionManager.IsBlockedBy(false, UserAttentionBlocker.FATAL_ERROR_SCENE))
 			{
 				return StoreManager.Get().IsPromptShowing;
 			}
@@ -79,7 +80,7 @@ public class RewardPopups : IDisposable
 
 	private PopupDisplayManagerBones ChestBones { get; set; }
 
-	private PopupDisplayManagerBones QuestChestBones { get; set; }
+	internal PopupDisplayManagerBones QuestChestBones { get; set; }
 
 	private event Action<long> OnGenericRewardShown = delegate
 	{
@@ -413,7 +414,13 @@ public class RewardPopups : IDisposable
 
 	private bool ShowNextTavernBrawlReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.UpdateTavernBrawlRewards"))
+    if (AccessibilityMgr.IsAccessibilityEnabled())
+    {
+      // TB is not implemented yet
+      return false;
+    }
+
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.UpdateTavernBrawlRewards"))
 		{
 			return false;
 		}
@@ -462,7 +469,7 @@ public class RewardPopups : IDisposable
 
 	private bool ShowNextLeaguePromotionReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextLeaguePromotionReward"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextLeaguePromotionReward"))
 		{
 			return false;
 		}
@@ -511,7 +518,7 @@ public class RewardPopups : IDisposable
 
 	private bool ShowNextFreeDeckReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextFreeDeckReward"))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextFreeDeckReward"))
 		{
 			return false;
 		}
@@ -541,7 +548,7 @@ public class RewardPopups : IDisposable
 
 	private bool ShowNextSellableDeckReward()
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber("PopupDisplayManager.ShowNextSellableDeckReward") || StoreManager.Get().IsPromptShowing)
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.FATAL_ERROR_SCENE) || !UserAttentionManager.CanShowAttentionGrabber(true, "PopupDisplayManager.ShowNextSellableDeckReward") || StoreManager.Get().IsPromptShowing)
 		{
 			return false;
 		}
@@ -809,7 +816,7 @@ public class RewardPopups : IDisposable
 		}
 		Reward reward = m_purchasedCardRewards[0];
 		UserAttentionBlocker userAttentionBlockerForReward = RewardUtils.GetUserAttentionBlockerForReward(reward.Data.Origin, reward.Data.OriginData);
-		if (!UserAttentionManager.CanShowAttentionGrabber(userAttentionBlockerForReward, "ShowNextUnAckedPurchasedCardReward"))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, userAttentionBlockerForReward, "ShowNextUnAckedPurchasedCardReward"))
 		{
 			return false;
 		}
@@ -873,7 +880,7 @@ public class RewardPopups : IDisposable
 		}
 	}
 
-	private Transform GetChestRewardBoneForScene(PopupDisplayManagerBones boneSet = null)
+	internal Transform GetChestRewardBoneForScene(PopupDisplayManagerBones boneSet = null)
 	{
 		PopupDisplayManagerBones popupDisplayManagerBones = ((boneSet != null) ? boneSet : ChestBones);
 		switch (SceneMgr.Get().GetMode())
diff --git a/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs b/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
index 73b8abd..6d5737f 100644
--- a/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
+++ b/Assembly-CSharp/RewardTrackForgotRewardsPopup.cs
@@ -2,9 +2,10 @@ using Hearthstone.DataModels;
 using Hearthstone.Progression;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
-public class RewardTrackForgotRewardsPopup : MonoBehaviour
+public class RewardTrackForgotRewardsPopup : MonoBehaviour, AccessibleUI
 {
 	public UberText m_headerText;
 
@@ -39,4 +40,49 @@ public class RewardTrackForgotRewardsPopup : MonoBehaviour
 		m_bodyText.Text = GameStrings.Format(key, dataModel.Unclaimed, dataModel.Name);
 		m_widget.Show();
 	}
+
+  public void Hide()
+	{
+		AccessibilityMgr.HideUI(this);
+	}
+
+	#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	public void ReadPopup()
+	{
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_POPUP), true);
+
+		if (m_headerText.gameObject.activeInHierarchy)
+        {
+            AccessibilityMgr.Output(this, m_headerText.Text);
+        }
+
+		if (m_bodyText.gameObject.activeInHierarchy)
+        {
+            AccessibilityMgr.Output(this, m_bodyText.Text);
+        }
+
+		var okButton = AccessibleWidgetUtils.GetPegUIElement(m_widget, "Root/Button_Framed/Button_Framed/ButtonFramed");
+		var okButtonText = AccessibleWidgetUtils.GetUberText(okButton, "Button/ButtonText");
+
+		m_accessibleMenu = new AccessibleMenu(this, "", null);
+		m_accessibleMenu.AddOption(GameStrings.Get(okButtonText.Text), () => AccessibleWidgetUtils.ClickButton(okButton));
+
+		m_accessibleMenu.StartReading();
+	}
+
+    public void HandleAccessibleInput()
+    {
+		m_accessibleMenu.HandleAccessibleInput();
+    }
+
+    public string GetAccessibleHelp()
+    {
+		return m_accessibleMenu.GetHelp();
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/RewardTrackInfographic.cs b/Assembly-CSharp/RewardTrackInfographic.cs
index 27a0018..8a89cd0 100644
--- a/Assembly-CSharp/RewardTrackInfographic.cs
+++ b/Assembly-CSharp/RewardTrackInfographic.cs
@@ -8,6 +8,8 @@ public class RewardTrackInfographic : BasicPopup
 	public class RewardTrackInfographicInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+
+		public RewardTrackInfographicInfo(string accessibleText) : base(accessibleText) {}
 	}
 
 	public static readonly AssetReference PrefabReference = new AssetReference("NPPG_RewardTrackFlow.prefab:950486367395976479668ac78af0d9e7");
@@ -62,7 +64,7 @@ public class RewardTrackInfographic : BasicPopup
 		}
 	}
 
-	private void IncrementPopupSeenFlag()
+	internal static void IncrementPopupSeenFlag()
 	{
 		GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.FTUE_HAS_SEEN_REWARD_TRACK_INFOGRAPHIC, 1L));
 	}
diff --git a/Assembly-CSharp/RewardTrackSeasonRoll.cs b/Assembly-CSharp/RewardTrackSeasonRoll.cs
index be1adbf..b30dd5a 100644
--- a/Assembly-CSharp/RewardTrackSeasonRoll.cs
+++ b/Assembly-CSharp/RewardTrackSeasonRoll.cs
@@ -6,6 +6,7 @@ using Hearthstone.Progression;
 using Hearthstone.UI;
 using PegasusUtil;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class RewardTrackSeasonRoll : MonoBehaviour
@@ -91,8 +92,8 @@ public class RewardTrackSeasonRoll : MonoBehaviour
 		SpecialEventDataModel eventDataModelFromRewardTrack = RewardTrackManager.Get().GetEventDataModelFromRewardTrack(m_rewardTrackDataModel);
 		if (eventDataModelFromRewardTrack != null)
 		{
-			m_currentForgotPopup.BindDataModel(eventDataModelFromRewardTrack);
-		}
+		m_currentForgotPopup.BindDataModel(eventDataModelFromRewardTrack);
+	}
 	}
 
 	public void Show()
@@ -102,10 +103,11 @@ public class RewardTrackSeasonRoll : MonoBehaviour
 		{
 			UIContext.GetRoot().ShowPopup(m_owner);
 			m_currentForgotPopup.GetComponentInChildren<RewardTrackForgotRewardsPopup>().Show();
+      ReadForgotRewardsPopup();
 		}, null, callImmediatelyIfSet: true, doOnce: true);
 	}
 
-	public void ShowChooseOneRewardPickerPopup()
+    public void ShowChooseOneRewardPickerPopup()
 	{
 		if (m_unclaimedRewardTrackNodeDataModels.Count == 0)
 		{
@@ -119,16 +121,20 @@ public class RewardTrackSeasonRoll : MonoBehaviour
 		m_chooseOneItemPopupWidget.RegisterDoneChangingStatesListener(delegate
 		{
 			m_widget.GetComponentInChildren<RewardTrackForgotRewardsPopup>().Show();
+
+            ReadChooseOneRewardPopup();
 		}, null, callImmediatelyIfSet: true, doOnce: true);
 	}
 
 	public void Hide()
 	{
+		HidePopups();
+
 		m_widget.Hide();
 		UnityEngine.Object.Destroy(m_owner);
 	}
 
-	private void OnDestroy()
+    private void OnDestroy()
 	{
 		UIContext.GetRoot().DismissPopup(m_owner);
 		m_callback?.Invoke();
@@ -189,4 +195,27 @@ public class RewardTrackSeasonRoll : MonoBehaviour
 			componentInChildren.Show();
 		});
 	}
+
+	#region Accessibility
+    private void ReadForgotRewardsPopup()
+    {
+		var rewardTrackForgotRewardsPopup = m_currentForgotPopup.GetComponentInChildren<RewardTrackForgotRewardsPopup>();
+		rewardTrackForgotRewardsPopup.ReadPopup();
+    }
+
+    private void ReadChooseOneRewardPopup()
+    {
+		var chooseOneRewardsPopup = m_widget.GetComponentInChildren<RewardTrackChooseOneItemPopup>();
+		chooseOneRewardsPopup.ReadPopup();
+    }
+
+    private void HidePopups()
+    {
+		var rewardTrackForgotRewardsPopup = m_widget.GetComponentInChildren<RewardTrackForgotRewardsPopup>();
+		AccessibilityMgr.HideUI(rewardTrackForgotRewardsPopup);
+
+		var chooseOneRewardsPopup = m_widget.GetComponentInChildren<RewardTrackChooseOneItemPopup>();
+		AccessibilityMgr.HideUI(chooseOneRewardsPopup);
+    }
+	#endregion
 }
diff --git a/Assembly-CSharp/RewardUtils.cs b/Assembly-CSharp/RewardUtils.cs
index 5c6f7da..d9a671d 100644
--- a/Assembly-CSharp/RewardUtils.cs
+++ b/Assembly-CSharp/RewardUtils.cs
@@ -1640,7 +1640,7 @@ public class RewardUtils
 		{
 			return false;
 		}
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "RewardUtils.ShowReward:" + ((reward == null || reward.Data == null) ? "null" : (reward.Data.Origin.ToString() + ":" + reward.Data.OriginData + ":" + reward.Data.RewardType))))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "RewardUtils.ShowReward:" + ((reward == null || reward.Data == null) ? "null" : (reward.Data.Origin.ToString() + ":" + reward.Data.OriginData + ":" + reward.Data.RewardType))))
 		{
 			return false;
 		}
@@ -2222,8 +2222,8 @@ public class RewardUtils
 		case RewardItemType.CUSTOM_COIN:
 		{
 			CosmeticCoinDbfRecord record7 = GameDbf.CosmeticCoin.GetRecord(item.ItemId);
-			if (record7 != null)
-			{
+				if (record7 != null)
+				{
 				CardDbfRecord record8 = GameDbf.Card.GetRecord(record7.CardId);
 				if (record8 != null)
 				{
diff --git a/Assembly-CSharp/RitualSpellConfig.cs b/Assembly-CSharp/RitualSpellConfig.cs
index cce42fb..50c6b3c 100644
--- a/Assembly-CSharp/RitualSpellConfig.cs
+++ b/Assembly-CSharp/RitualSpellConfig.cs
@@ -3,7 +3,7 @@ using System.Collections.Generic;
 using PegasusGame;
 using UnityEngine;
 
-[CreateAssetMenu(fileName = "Data", menuName = "ScriptableObjects/RitualSpellConfig", order = 1)]
+// [CreateAssetMenu(fileName = "Data", menuName = "ScriptableObjects/RitualSpellConfig", order = 1)]
 public class RitualSpellConfig : ScriptableObject
 {
 	[Serializable]
diff --git a/Assembly-CSharp/ScenarioDbId.cs b/Assembly-CSharp/ScenarioDbId.cs
index 4f468b5..40b0470 100644
--- a/Assembly-CSharp/ScenarioDbId.cs
+++ b/Assembly-CSharp/ScenarioDbId.cs
@@ -655,5 +655,6 @@ public enum ScenarioDbId
 	ARENA_DUAL_CLASS_27_6 = 5352,
 	HM_Puzzle_01 = 5393,
 	HM_Puzzle_02 = 5394,
-	HM_Puzzle_04 = 5396
+	HM_Puzzle_04 = 5396,
+	EOE
 }
diff --git a/Assembly-CSharp/SceneMgr.cs b/Assembly-CSharp/SceneMgr.cs
index b17829d..4447ec8 100644
--- a/Assembly-CSharp/SceneMgr.cs
+++ b/Assembly-CSharp/SceneMgr.cs
@@ -1011,7 +1011,7 @@ public class SceneMgr : IService, IHasUpdate
 
 	private void OnFatalError(FatalErrorMessage message, object userData)
 	{
-		if (UserAttentionManager.IsBlockedBy(UserAttentionBlocker.SET_ROTATION_INTRO))
+		if (UserAttentionManager.IsBlockedBy(true, UserAttentionBlocker.SET_ROTATION_INTRO))
 		{
 			Log.Offline.Print("SceneMgr.OnFatalError: Error blocked by set rotation.");
 			SetNextMode(Mode.FATAL_ERROR);
@@ -1097,7 +1097,7 @@ public class SceneMgr : IService, IHasUpdate
 		SetNextMode(Mode.HUB);
 	}
 
-	private void GoToFatalErrorScreen(FatalErrorMessage message)
+	internal void GoToFatalErrorScreen(FatalErrorMessage message)
 	{
 		if (HearthstoneApplication.Get().ResetOnErrorIfNecessary())
 		{
diff --git a/Assembly-CSharp/ScrollbarControl.cs b/Assembly-CSharp/ScrollbarControl.cs
index 3770e48..38102ce 100644
--- a/Assembly-CSharp/ScrollbarControl.cs
+++ b/Assembly-CSharp/ScrollbarControl.cs
@@ -158,7 +158,7 @@ public class ScrollbarControl : MonoBehaviour
 		FireFinishEvent();
 	}
 
-	private void FireUpdateEvent()
+	internal void FireUpdateEvent()
 	{
 		if (m_updateHandler != null)
 		{
@@ -166,7 +166,7 @@ public class ScrollbarControl : MonoBehaviour
 		}
 	}
 
-	private void FireFinishEvent()
+	internal void FireFinishEvent()
 	{
 		if (m_finishHandler != null)
 		{
diff --git a/Assembly-CSharp/SeasonEndDialog.cs b/Assembly-CSharp/SeasonEndDialog.cs
index d113226..3696a4c 100644
--- a/Assembly-CSharp/SeasonEndDialog.cs
+++ b/Assembly-CSharp/SeasonEndDialog.cs
@@ -8,6 +8,7 @@ using Hearthstone.UI;
 using HutongGames.PlayMaker;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class SeasonEndDialog : DialogBase
 {
@@ -40,7 +41,8 @@ public class SeasonEndDialog : DialogBase
 		REDUCED_WELCOME,
 		REMINDER_CHEST,
 		STAR_MULTIPLIER,
-		REMINDER_CARDBACK
+		REMINDER_CARDBACK,
+		EOE
 	}
 
 	public GameObject m_root;
@@ -179,6 +181,8 @@ public class SeasonEndDialog : DialogBase
 
 	private const string REWARD_CHEST_EARNED_STRING_FORMAT = "GLOBAL_REWARD_CHEST_TIER{0}_EARNED";
 
+	private const string REWARD_CHEST_WIDGET_OPEN_EVENT_NAME = "CLICKED";
+
 	protected override void Awake()
 	{
 		base.Awake();
@@ -344,8 +348,9 @@ public class SeasonEndDialog : DialogBase
 			m_currentMode = MODE.CHEST_EARNED;
 			m_medalPlayMaker.SendEvent("RevealRewardChest");
 			iTween.FadeTo(m_rankAchieved.gameObject, 0f, 0.5f);
-		}
-		else
+			HandleAccessibility();
+        }
+        else
 		{
 			GotoBonusStarsOrWelcome();
 		}
@@ -393,11 +398,13 @@ public class SeasonEndDialog : DialogBase
 
 	public void GoToStarMultiplier()
 	{
-		m_currentMode = MODE.STAR_MULTIPLIER;
+        m_currentMode = MODE.STAR_MULTIPLIER;
 		m_welcomeItems.SetActive(value: false);
+        HandleAccessibility();
+
 		if (m_skipRankedIntroPopup)
 		{
-			StartCoroutine(DoPageTear());
+            StartCoroutine(DoPageTear());
 			return;
 		}
 		HideRewardChestPage();
@@ -407,9 +414,9 @@ public class SeasonEndDialog : DialogBase
 		StartCoroutine(FadeWidgetIn(m_starMultiplierWidget, 0f));
 		iTween.FadeTo(m_bonusStarItems, 1f, 0f);
 		EnableOkayButton();
-	}
+    }
 
-	public void GotoReducedMedal()
+    public void GotoReducedMedal()
 	{
 		m_currentMode = MODE.REDUCED_WELCOME;
 		StartCoroutine(DoPageTear());
@@ -420,9 +427,10 @@ public class SeasonEndDialog : DialogBase
 		m_bonusStarLabel.Text = m_currentMedalInfo.GetRankName();
 		m_bonusStarTitle.Text = GameStrings.Get("GLOBAL_SEASON_END_BONUS_STAR_TITLE");
 		UpdateBonusStarFinePrint();
-	}
+        HandleAccessibility();
+    }
 
-	public void GotoChestReminder()
+    public void GotoChestReminder()
 	{
 		m_currentMode = MODE.REMINDER_CHEST;
 		HideRewardChestPage();
@@ -430,19 +438,21 @@ public class SeasonEndDialog : DialogBase
 		m_bonusStarItems.SetActive(value: false);
 		StartCoroutine(DoPageTear());
 		int seasonRollRewardMinWins = RankMgr.Get().GetLeagueRecord(m_seasonEndInfo.m_leagueId).SeasonRollRewardMinWins;
-		m_progressBar.SetLabel(GameStrings.Format("GLOBAL_REWARD_PROGRESS", 0, seasonRollRewardMinWins));
-	}
+        m_progressBar.SetLabel(GameStrings.Format("GLOBAL_REWARD_PROGRESS", 0, seasonRollRewardMinWins));
+        HandleAccessibility();
+    }
 
-	public void GoToCardBackReminder()
+    public void GoToCardBackReminder()
 	{
 		m_currentMode = MODE.REMINDER_CARDBACK;
 		HideRewardChestPage();
 		m_welcomeItems.SetActive(value: false);
 		m_bonusStarItems.SetActive(value: false);
 		StartCoroutine(DoPageTear());
-	}
+        HandleAccessibility();
+    }
 
-	public void GoToRankedIntroPopUp()
+    public void GoToRankedIntroPopUp()
 	{
 		iTween.ScaleTo(m_root, new Vector3(0f, 0f, 0f), 0.5f);
 		m_rankedIntroPopUpWidget.TriggerEvent("CODE_DIALOGMANAGER_SHOW");
@@ -461,9 +471,10 @@ public class SeasonEndDialog : DialogBase
 		HideRewardChestPage();
 		m_bonusStarItems.SetActive(value: false);
 		m_welcomeDetails.Text = GameStrings.Format("GLOBAL_SEASON_END_NEW_SEASON", newSeasonName);
-	}
+		HandleAccessibility();
+    }
 
-	public IEnumerator DoPageTear()
+    public IEnumerator DoPageTear()
 	{
 		m_medalPlayMaker.SendEvent("PageTear");
 		yield return new WaitForSeconds(0.69f);
@@ -540,6 +551,7 @@ public class SeasonEndDialog : DialogBase
 		DoShowAnimation();
 		UniversalInputManager.Get().SetGameDialogActive(active: true);
 		PlayShowSound();
+		HandleAccessibility();
 	}
 
 	public override void Hide()
@@ -783,7 +795,7 @@ public class SeasonEndDialog : DialogBase
 
 	private void RankedChestEventListener(string eventName)
 	{
-		if (eventName.Equals("CLICKED") && !m_chestOpened)
+		if (eventName.Equals(REWARD_CHEST_WIDGET_OPEN_EVENT_NAME) && !m_chestOpened)
 		{
 			m_chestOpened = true;
 			PlayMakerFSM componentInChildren = m_rankedRewardChestWidget.GetComponentInChildren<PlayMakerFSM>();
@@ -895,4 +907,111 @@ public class SeasonEndDialog : DialogBase
 		m_showAnimState = ShowAnimState.IN_PROGRESS;
 		AnimationUtil.ShowWithPunch(base.gameObject, START_SCALE, Vector3.Scale(PUNCH_SCALE, m_originalScale), m_originalScale, "OnShowAnimFinished", noFade: true);
 	}
+
+	private void HandleAccessibility()
+    {
+        switch (m_currentMode)
+        {
+            case MODE.RANK_EARNED:
+				AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				var seasonName = GameUtils.GetRankedSeasonName(m_seasonEndInfo.m_seasonID);
+				var rankName = m_seasonBestMedalInfo.GetRankName();
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_RANK_EARNED, seasonName, rankName));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.CHEST_EARNED:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SEASON_END_DIALOG_CHEST_EARNED));
+                AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_CHEST_EARNED_HELP, AccessibleKey.CONFIRM));
+                break;
+            case MODE.SEASON_WELCOME:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				var seasonName2 = GameUtils.GetRankedSeasonName(m_rewardProgress.Season);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_SEASON_WELCOME, seasonName2));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REDUCED_WELCOME:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SEASON_END_DIALOG_REDUCED_WELCOME));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REMINDER_CHEST:
+                int seasonRollRewardMinWins = RankMgr.Get().GetLeagueRecord(m_seasonEndInfo.m_leagueId).SeasonRollRewardMinWins;
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_REMINDER_CHEST, seasonRollRewardMinWins));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.STAR_MULTIPLIER:
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_RANKED_BONUS_STARS_POPUP, m_currentMedalInfo.starsPerWin));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            case MODE.REMINDER_CARDBACK:
+                int seasonCardBackMinWins = RankMgr.Get().GetLocalPlayerMedalInfo().GetSeasonCardBackMinWins();
+                AccessibilityMgr.ShowUI(this);
+                AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+				AccessibilityMgr.Output(this, LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_REMINDER_CARDBACK, seasonCardBackMinWins));
+				AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+                break;
+            default:
+                break;
+        }
+    }
+
+	private PegUIElement GetNextChest()
+    {
+		if (m_rewardChestLegacy != null)
+		{
+			return m_rewardChestLegacy;
+		}
+
+		foreach (var chest in m_rewardChests)
+		{
+			if (chest.gameObject.activeInHierarchy)
+            {
+				return chest;
+            }
+		}
+
+		return m_okayButton;
+    }
+
+	public override void HandleAccessibleInput()
+    {
+		if (m_currentMode == MODE.CHEST_EARNED && AccessibleKey.CONFIRM.IsPressed())
+		{
+			if (m_rewardChestLegacy != null)
+            {
+				m_rewardChestLegacy.TriggerRelease();
+				return;
+            }
+
+			if (!m_chestOpened)
+            {
+                m_rankedRewardChestWidget.TriggerEvent(REWARD_CHEST_WIDGET_OPEN_EVENT_NAME);
+            }
+        }
+        else if (AccessibleKey.CONFIRM.IsPressed())
+		{
+            m_okayButton.TriggerRelease();
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+        if (m_currentMode == MODE.CHEST_EARNED)
+        {
+			return LocalizationUtils.Format(LocalizationKey.UI_SEASON_END_DIALOG_CHEST_EARNED_HELP, AccessibleKey.CONFIRM);
+        }
+		else
+        {
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+        }
+    }
 }
diff --git a/Assembly-CSharp/SellableDeckProductPage.cs b/Assembly-CSharp/SellableDeckProductPage.cs
index 238403b..b466de9 100644
--- a/Assembly-CSharp/SellableDeckProductPage.cs
+++ b/Assembly-CSharp/SellableDeckProductPage.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using Accessibility;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using Hearthstone.UI.Core;
@@ -117,15 +118,15 @@ public class SellableDeckProductPage : ProductPage, IPopupRendering
 	{
 		base.OnProductSet();
 		SetItems();
-	}
+		}
 
 	public void EnablePopupRendering(IPopupRoot popupRoot)
-	{
+		{
 		m_popupRoot = popupRoot;
 	}
 
 	public void DisablePopupRendering()
-	{
+			{
 		if (m_popupRoot != null)
 		{
 			if (m_popupRenderingComponents != null)
@@ -133,18 +134,18 @@ public class SellableDeckProductPage : ProductPage, IPopupRendering
 				m_popupRoot.CleanupPopupRendering(m_popupRenderingComponents);
 			}
 			m_popupRoot = null;
+			}
 		}
-	}
 
 	public bool HandlesChildPropagation()
 	{
 		return false;
 	}
 
-	public override void Open()
+	public override void Open(bool isAccessible)
 	{
 		m_cardList = new ShopCardList(m_widget, m_scrollbar);
-		base.Open();
+		base.Open(true);
 		base.OnOpened += InitInput;
 		if (m_variantStyle == VariantStyles.Class)
 		{
@@ -294,8 +295,8 @@ public class SellableDeckProductPage : ProductPage, IPopupRendering
 		}
 		else
 		{
-			m_cardListListable.RegisterDoneChangingStatesListener(OnCardListListableDoneChangingState, null, callImmediatelyIfSet: false, doOnce: true);
-		}
+		m_cardListListable.RegisterDoneChangingStatesListener(OnCardListListableDoneChangingState, null, callImmediatelyIfSet: false, doOnce: true);
+	}
 	}
 
 	private void ApplyPopupRendering()
@@ -685,4 +686,79 @@ public class SellableDeckProductPage : ProductPage, IPopupRendering
 		m_useMultiDeckInterface = num > 1;
 		return num;
 	}
+
+	#region Accessibility
+
+	private AccessibleListOfItems<AccessibleCollectibleCard> m_accessibleCards;
+
+	protected override void SetupVariantMenuOptions()
+	{
+		var variant = m_productSelection.Variant;
+
+		m_readingVariantMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_ITEM_READ_DESCRIPTION), () => ReadVariantDescription(variant));
+		m_readingVariantMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_READ_CARDS), () => ReadCards());
+		SetupPriceMenuOptions(variant);
+	}
+
+	private void ReadCards()
+	{
+		var cardTiles = m_cardList.m_dataModel.CardTiles;
+
+		var accessibleCards = new List<AccessibleCollectibleCard>(cardTiles.Count);
+
+		foreach (var card in cardTiles)
+        {
+			var cardId = card.CardId;
+			var cardQty = card.Count;
+			var entityDef = DefLoader.Get().GetEntityDef(cardId);
+			var cardRecord = GameUtils.GetCardRecord(cardId);
+			var collectibleCard = new CollectibleCard(cardRecord, entityDef, TAG_PREMIUM.NORMAL);
+			collectibleCard.OwnedCount = cardQty;
+			var accessibleCollectibleCard = new AccessibleCollectibleCard(m_container, collectibleCard, true, true);
+
+			accessibleCards.Add(accessibleCollectibleCard);
+        }
+
+		m_accessibleCards = new AccessibleListOfItems<AccessibleCollectibleCard>(m_container, accessibleCards);
+		m_accessibleCards.StartReading();
+		m_curState = State.READING_CARDS;
+	}
+
+	public override void HandleAccessibleInput()
+	{
+		if (m_curState == State.READING_CARDS)
+		{
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadVariantMenu();
+			}
+			else
+			{
+				var curTile = m_scrollbar.m_scrollableItems[m_accessibleCards.GetItemBeingReadIndex()];
+				if (m_accessibleCards.HandleAccessibleInput())
+				{
+					AccessibilityUtils.CenterScrollbarAroundObject(m_scrollbar, curTile.gameObject);
+				}
+				AccessibleInputMgr.MoveMouseTo(curTile);
+			}
+		}
+		else
+		{
+			base.HandleAccessibleInput();
+		}
+	}
+
+	public override string GetAccessibleHelp()
+	{
+		if (m_curState == State.READING_CARDS)
+		{
+			return LocalizationUtils.Get(LocalizationKey.UI_SHOP_READ_CARDS_HELP);
+		}
+		else
+		{
+			return base.GetAccessibleHelp();
+		}
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/SetFilterTray.cs b/Assembly-CSharp/SetFilterTray.cs
index 164d1f8..93ccc0b 100644
--- a/Assembly-CSharp/SetFilterTray.cs
+++ b/Assembly-CSharp/SetFilterTray.cs
@@ -5,8 +5,9 @@ using Blizzard.T5.AssetManager;
 using Blizzard.T5.Services;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
-public class SetFilterTray : MonoBehaviour
+public class SetFilterTray : MonoBehaviour, AccessibleUI
 {
 	public UIBScrollable m_scroller;
 
@@ -48,7 +49,7 @@ public class SetFilterTray : MonoBehaviour
 
 	private HashSet<TAG_CARD_SET> m_setsWithOwnedCards = new HashSet<TAG_CARD_SET>();
 
-	private SetFilterItem m_selected;
+	internal SetFilterItem m_selected;
 
 	private SetFilterItem m_lastSelected;
 
@@ -317,6 +318,8 @@ public class SetFilterTray : MonoBehaviour
 		{
 			collectionManagerDisplay.HideSetFilterTutorial();
 		}
+
+		ReadFilterTray();
 	}
 
 	public bool IsShown()
@@ -482,7 +485,7 @@ public class SetFilterTray : MonoBehaviour
 		m_items.Clear();
 	}
 
-	private void OnEditedDeckChanged(CollectionDeck newDeck, CollectionDeck oldDeck, object callbackData)
+		private void OnEditedDeckChanged(CollectionDeck newDeck, CollectionDeck oldDeck, object callbackData)
 	{
 		EvaluateOwnership(force: true);
 	}
@@ -491,4 +494,188 @@ public class SetFilterTray : MonoBehaviour
 	{
 		CollectionManager.Get().RemoveEditedDeckChanged(OnEditedDeckChanged);
 	}
+
+	#region Accessibility
+
+	private enum State
+	{
+		LOADING,
+		MAIN_MENU,
+		READING_GROUP_ITEMS
+	}
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private AccessibleMenu m_groupedItemsMenu;
+
+	private State m_curState;
+
+	private void ReadFilterTray()
+	{
+		if (!m_shown)
+		{
+			AccessibilityMgr.HideUI(this);
+			return;
+		}
+
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleMenu = new AccessibleMenu(this, "", m_hideArea.TriggerPress);
+
+		var rootItems = GetRootItems();
+		var groupedItems = GetGroupedItems();
+
+		// Root items (standard, wild, classic) first
+		foreach (var item in rootItems)
+		{
+			AddItemToMenu(m_accessibleMenu, item);
+		}
+
+		// Grouped items second
+		foreach (var group in groupedItems)
+		{
+			var groupName = group.Key;
+			var groupItems = group.Value;
+
+			m_accessibleMenu.AddOption(groupName, () => ReadGroupItems(groupItems));
+		}
+
+		ReadMainMenu();
+	}
+
+	private void AddItemToMenu(AccessibleMenu menu, SetFilterItem item)
+	{
+		menu.AddOption(item.Text, () => SelectItem(item), () => ReadItem(item));
+	}
+
+	private void ReadItem(SetFilterItem item)
+	{
+		AccessibilityUtils.CenterScrollbarAroundObject(m_scroller, item.gameObject);
+	}
+
+	private void SelectItem(SetFilterItem item)
+	{
+		item.TriggerRelease();
+		AccessibleCollectionManager.Get().OnSelectFilterItem();
+		m_hideArea.TriggerPress();
+	}
+
+	private void ReadMainMenu()
+	{
+		m_accessibleMenu.StartReading();
+		m_curState = State.MAIN_MENU;
+	}
+
+	private void ReadGroupItems(List<SetFilterItem> groupItems)
+	{
+		m_groupedItemsMenu = new AccessibleMenu(this, "", ReadMainMenu);
+
+		foreach (var item in groupItems)
+		{
+			AddItemToMenu(m_groupedItemsMenu, item);
+		}
+
+		m_groupedItemsMenu.StartReading();
+		m_curState = State.READING_GROUP_ITEMS;
+	}
+
+	private List<SetFilterItem> GetRootItems()
+	{
+		var ret = new List<SetFilterItem>();
+
+		foreach (var item in m_items)
+		{
+			if (item.IsHeader)
+			{
+				return ret;
+			}
+			else if (!IsActiveSetFilterItem(item))
+			{
+				continue;
+			}
+
+			ret.Add(item);
+		}
+
+		return ret;
+	}
+
+	private Dictionary<string, List<SetFilterItem>> GetGroupedItems()
+	{
+		var ret = new Dictionary<string, List<SetFilterItem>>();
+
+		string curGroupName = null;
+		var curGroupItems = new List<SetFilterItem>();
+
+		foreach (var item in m_items)
+		{
+			if (!IsActiveSetFilterItem(item))
+			{
+				continue;
+			}
+
+			if (item.IsHeader)
+			{
+				// Skip root items
+				if (curGroupItems.Count > 0 && curGroupName != null)
+				{
+					ret.Add(curGroupName, curGroupItems);
+				}
+
+				curGroupItems = new List<SetFilterItem>();
+				curGroupName = item.Text;
+			}
+			else
+			{
+				curGroupItems.Add(item);
+			}
+		}
+
+		if (curGroupItems.Count > 0 && curGroupName != null)
+		{
+			ret.Add(curGroupName, curGroupItems);
+		}
+
+		return ret;
+	}
+
+	private bool IsActiveSetFilterItem(SetFilterItem item)
+	{
+		UIBScrollableItem component = item.GetComponent<UIBScrollableItem>();
+		if (component == null || component.m_active == UIBScrollableItem.ActiveState.Inactive ||
+			(component.m_active == UIBScrollableItem.ActiveState.UseHierarchy && !item.gameObject.activeInHierarchy))
+		{
+			return false;
+		}
+
+		return true;
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			m_accessibleMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == State.READING_GROUP_ITEMS)
+		{
+			m_groupedItemsMenu?.HandleAccessibleInput();
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_curState == State.MAIN_MENU)
+		{
+			return m_accessibleMenu?.GetHelp();
+		}
+		else if (m_curState == State.READING_GROUP_ITEMS)
+		{
+			return m_groupedItemsMenu?.GetHelp();
+		}
+
+		return "";
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/SetRotationManager.cs b/Assembly-CSharp/SetRotationManager.cs
index eb6f5d6..30cdf1f 100644
--- a/Assembly-CSharp/SetRotationManager.cs
+++ b/Assembly-CSharp/SetRotationManager.cs
@@ -7,6 +7,7 @@ using Hearthstone;
 using Hearthstone.Core;
 using Hearthstone.Streaming;
 using UnityEngine;
+using Accessibility;
 
 public class SetRotationManager : IService
 {
@@ -46,6 +47,8 @@ public class SetRotationManager : IService
 
 	public static bool HasSeenStandardModeTutorial()
 	{
+		// This is an entirely visual tutorial and players using OCR were having trouble
+		return true;
 		return Options.Get().GetBool(Option.HAS_SEEN_STANDARD_MODE_TUTORIAL, defaultVal: false);
 	}
 
@@ -63,7 +66,8 @@ public class SetRotationManager : IService
 		{
 			return false;
 		}
-		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo();
+		var popupText = GameStrings.Get("GLUE_NEW_PLAYER_SET_ROTATION_POPUP_BODY");
+		BasicPopup.PopupInfo popupInfo = new BasicPopup.PopupInfo(popupText);
 		popupInfo.m_prefabAssetRefs.Add("SetRotationNewPlayerPopup.prefab:ed707c931e185924eab67aa36770f8ec");
 		popupInfo.m_blurWhenShown = true;
 		popupInfo.m_responseCallback = delegate
@@ -76,6 +80,15 @@ public class SetRotationManager : IService
 
 	public bool ShouldShowSetRotationIntro()
 	{
+		// This is an entirely visual tutorial and players using OCR were having trouble
+		return false;
+
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			// Not implemented yet - making the clock accessible would be quite tricky
+            return false;
+        }
+
 		if (IsShowingSetRotationRelogPopup)
 		{
 			return false;
diff --git a/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs b/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
index e554a57..0c501e7 100644
--- a/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
+++ b/Assembly-CSharp/SetRotationRotatedBoostersPopup.cs
@@ -4,6 +4,7 @@ using System.Collections.Generic;
 using Hearthstone.DataModels;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [RequireComponent(typeof(WidgetTemplate))]
 public class SetRotationRotatedBoostersPopup : BasicPopup
@@ -11,6 +12,8 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 	public class SetRotationRotatedBoostersPopupInfo : PopupInfo
 	{
 		public Action m_onHiddenCallback;
+
+		public SetRotationRotatedBoostersPopupInfo(string accessibleText) : base(accessibleText) { }
 	}
 
 	private Widget m_widget;
@@ -25,12 +28,18 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 
 	private SetRotationRotatedBoostersPopupInfo m_info;
 
+    #region Accessibility
+    private const string CLICK_BUTTON_EVENT_NAME = "Button_Framed_Clicked";
+
+	private PackListDataModel m_packListDataModel;
+	#endregion
+
 	protected override void Awake()
 	{
 		m_widget = GetComponent<WidgetTemplate>();
 		m_widget.RegisterEventListener(delegate(string eventName)
 		{
-			if (eventName == "Button_Framed_Clicked")
+			if (eventName == CLICK_BUTTON_EVENT_NAME)
 			{
 				Hide();
 			}
@@ -62,6 +71,7 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 			{
 				SoundManager.Get().LoadAndPlay(m_showAnimationSound);
 			}
+			ReadPopup();
 			Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
 			tweenHashTable.Add("scale", localScale);
 			tweenHashTable.Add("time", 0.3f);
@@ -73,6 +83,8 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 	public override void Hide()
 	{
 		m_widget.TriggerEvent("CODE_DIALOGMANAGER_HIDE");
+
+		AccessibilityMgr.HideUI(this);
 	}
 
 	private void BindRankedPackListDataModel()
@@ -88,13 +100,53 @@ public class SetRotationRotatedBoostersPopup : BasicPopup
 				PackDataModel packDataModel = new PackDataModel();
 				packDataModel.Type = (BoosterDbId)item.ID;
 				packDataModel.BoosterName = item.Name;
-				packListDataModel.Packs.Insert(0, packDataModel);
-				if (packListDataModel.Packs.Count >= 3)
+				m_packListDataModel.Packs.Insert(0, packDataModel);
+				if (m_packListDataModel.Packs.Count >= 3)
 				{
 					break;
 				}
 			}
 		}
-		m_widget.BindDataModel(packListDataModel);
+		m_widget.BindDataModel(m_packListDataModel);
 	}
+
+    #region Accessibility
+
+	private void ReadPopup()
+    {
+		if (m_widget == null || m_packListDataModel == null)
+        {
+			return;
+        }
+
+		var packNames = new List<string>();
+
+		foreach (var pack in m_packListDataModel.Packs)
+		{
+			packNames.Add(pack.BoosterName);
+		}
+
+		var packNamesList = AccessibleSpeechUtils.HumanizeList(packNames);
+
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+		AccessibilityMgr.Output(this, LocalizationUtils.Get(LocalizationKey.UI_SET_ROTATION_ROTATED_BOOSTERS_POPUP_TITLE));
+		AccessibilityMgr.Output(this, packNamesList);
+		AccessibilityMgr.Output(this, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+    }
+
+    public override void HandleAccessibleInput()
+    {
+        if (m_widget != null && AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_widget.TriggerEvent(CLICK_BUTTON_EVENT_NAME);
+        }
+    }
+
+    public override string GetAccessibleHelp()
+    {
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/ShareableDeck.cs b/Assembly-CSharp/ShareableDeck.cs
index 40d2bac..c224e31 100644
--- a/Assembly-CSharp/ShareableDeck.cs
+++ b/Assembly-CSharp/ShareableDeck.cs
@@ -14,10 +14,6 @@ public class ShareableDeck
 	public const int VersionNumberOne = 1;
 
 	public const int VersionNumberCurrent = 1;
-
-	[CompilerGenerated]
-	private int <VersionNumber>k__BackingField;
-
 	public const string CommentLinePrefix = "# ";
 
 	public const string DeckNameLinePrefix = "###";
@@ -26,14 +22,7 @@ public class ShareableDeck
 
 	public static readonly string DeckCodeWithNameFormat = "### {0}\n{1}";
 
-	private int VersionNumber
-	{
-		[CompilerGenerated]
-		set
-		{
-			<VersionNumber>k__BackingField = value;
-		}
-	}
+	private int VersionNumber { get; set; }
 
 	public string DeckName { get; set; }
 
@@ -88,15 +77,15 @@ public class ShareableDeck
 			}
 			shareableDeck.DeckName = deckName;
 			using MemoryStream stream = new MemoryStream(Convert.FromBase64String(text));
-			if (!IsValidEncodedDeckHeader(stream))
-			{
-				return null;
-			}
-			if (!DeserializeFromVersion((int)ProtocolParser.ReadUInt64(stream), shareableDeck, stream, ref deckHasWildCards))
-			{
-				return null;
+				if (!IsValidEncodedDeckHeader(stream))
+				{
+					return null;
+				}
+				if (!DeserializeFromVersion((int)ProtocolParser.ReadUInt64(stream), shareableDeck, stream, ref deckHasWildCards))
+				{
+					return null;
+				}
 			}
-		}
 		catch (Exception)
 		{
 			return null;
@@ -105,8 +94,8 @@ public class ShareableDeck
 		{
 			if (shareableDeck.FormatType == FormatType.FT_STANDARD)
 			{
-				shareableDeck.FormatType = FormatType.FT_WILD;
-			}
+			shareableDeck.FormatType = FormatType.FT_WILD;
+		}
 		}
 		else if (!CollectionManager.Get().ShouldAccountSeeStandardWild())
 		{
diff --git a/Assembly-CSharp/ShareableMercenariesTeam.cs b/Assembly-CSharp/ShareableMercenariesTeam.cs
index 68b720a..fac8653 100644
--- a/Assembly-CSharp/ShareableMercenariesTeam.cs
+++ b/Assembly-CSharp/ShareableMercenariesTeam.cs
@@ -5,17 +5,7 @@ using PegasusLettuce;
 
 public class ShareableMercenariesTeam : ShareableDeck
 {
-	[CompilerGenerated]
-	private int <VersionNumber>k__BackingField;
-
-	private int VersionNumber
-	{
-		[CompilerGenerated]
-		set
-		{
-			<VersionNumber>k__BackingField = value;
-		}
-	}
+	private int VersionNumber { get; set; }
 
 	public LettuceTeam Team { get; set; }
 
diff --git a/Assembly-CSharp/Shop.cs b/Assembly-CSharp/Shop.cs
index 91b5532..51257dc 100644
--- a/Assembly-CSharp/Shop.cs
+++ b/Assembly-CSharp/Shop.cs
@@ -9,14 +9,15 @@ using Hearthstone.DataModels;
 using Hearthstone.Store;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
-public class Shop : MonoBehaviour, IStore
+public class Shop : MonoBehaviour, IStore, AccessibleUI
 {
 	[SerializeField]
 	private Widget m_widget;
 
 	[SerializeField]
-	private UIBScrollable m_browserScroller;
+	internal UIBScrollable m_browserScroller;
 
 	[SerializeField]
 	private VisualController m_shopStateController;
@@ -34,7 +35,7 @@ public class Shop : MonoBehaviour, IStore
 
 	private ShopDataModel m_shopData;
 
-	private ShopBrowser m_browser;
+	internal ShopBrowser m_browser;
 
 	private WidgetTemplate m_browserWidgetTemplate;
 
@@ -76,7 +77,7 @@ public class Shop : MonoBehaviour, IStore
 		get
 		{
 			if (m_browser != null)
-			{
+		{
 				return m_browser.IsReady();
 			}
 			return false;
@@ -150,11 +151,15 @@ public class Shop : MonoBehaviour, IStore
 				UpdateScrollerEnabled();
 				m_shopTabController.RegisterTabChangedListener(OnTabChanged);
 				m_shopTabController.ResetTabKnowledge();
+				m_curTabIdx = 0;
+				m_curSubTabIdx = 0;
 				m_shopTabController.SelectTab(0, 0, instant: true, sendTelemetry: false);
 				StartCoroutine(SendShopVisitTelemetryCoroutine());
 			}
 			m_productPageController.HandleShopOpen();
 			this.OnOpened?.Invoke();
+
+			StartCoroutine(OnShopOpened());
 		}
 	}
 
@@ -197,8 +202,10 @@ public class Shop : MonoBehaviour, IStore
 			DontFullyOpenShop = false;
 			UpdateScrollerEnabled();
 			this.OnClosed?.Invoke(new StoreClosedArgs());
+
+			AccessibilityMgr.HideUI(this);
+			}
 		}
-	}
 
 	public void BlockInterface(bool blocked)
 	{
@@ -359,18 +366,18 @@ public class Shop : MonoBehaviour, IStore
 			{
 				StopCoroutine(m_moveToProductCoroutine);
 				m_moveToProductCoroutine = null;
-			}
+		}
 			m_moveToProductCoroutine = StartCoroutine(MoveToProductCoroutine(product));
 		}
-	}
+		}
 
 	public void Debug_FillBrowser(IEnumerable<ProductTierDataModel> tiers)
-	{
+		{
 		m_browser.SetData(tiers);
-	}
+		}
 
 	public bool TryGetCurrentTabIds(out string mainTabId, out string subTabId)
-	{
+		{
 		mainTabId = string.Empty;
 		subTabId = string.Empty;
 		if (m_shopData != null && m_shopData.CurrentTab != null)
@@ -379,8 +386,8 @@ public class Shop : MonoBehaviour, IStore
 			if (m_shopData.CurrentSubTab != null)
 			{
 				subTabId = m_shopData.CurrentSubTab.Id;
-				return true;
-			}
+		return true;
+	}
 		}
 		return false;
 	}
@@ -506,7 +513,7 @@ public class Shop : MonoBehaviour, IStore
 	{
 		OverlayUI overlayUI = OverlayUI.Get();
 		if ((bool)overlayUI && (bool)m_widget && !overlayUI.HasObject(m_widget.gameObject))
-		{
+	{
 			overlayUI.AddGameObject(m_widget.gameObject);
 		}
 	}
@@ -516,11 +523,11 @@ public class Shop : MonoBehaviour, IStore
 		if (ServiceManager.TryGet<CurrencyManager>(out var service))
 		{
 			if (ShopUtils.TryGetMainVirtualCurrencyType(out var currencyType))
-			{
+		{
 				m_shopData.VirtualCurrencyBalance = service.GetPriceDataModel(currencyType);
-			}
-			else
-			{
+		}
+		else
+		{
 				m_shopData.VirtualCurrencyBalance = service.GetPriceDataModel(CurrencyType.NONE);
 			}
 			if (ShopUtils.TryGetBoosterVirtualCurrencyType(out var currencyType2))
@@ -528,11 +535,11 @@ public class Shop : MonoBehaviour, IStore
 				m_shopData.BoosterCurrencyBalance = service.GetPriceDataModel(currencyType2);
 			}
 			else
-			{
+				{
 				m_shopData.BoosterCurrencyBalance = service.GetPriceDataModel(CurrencyType.NONE);
+				}
 			}
 		}
-	}
 
 	private void OnPageOpening(ProductPage page)
 	{
@@ -543,6 +550,8 @@ public class Shop : MonoBehaviour, IStore
 	private void OnPageOpened(ProductPage page)
 	{
 		UpdateScrollerEnabled();
+
+		m_productPageOpened = true;
 	}
 
 	private void OnPageClosed(ProductPage page)
@@ -558,6 +567,8 @@ public class Shop : MonoBehaviour, IStore
 	private void OnTabChanged(int tabIndex, int subTabIndex)
 	{
 		RefreshContent(tabIndex, subTabIndex);
+
+		StartCoroutine(A11yOnTabChanged(tabIndex, subTabIndex));
 	}
 
 	private bool OnNavigateBack()
@@ -577,10 +588,10 @@ public class Shop : MonoBehaviour, IStore
 		this.OnOpenCompleted?.Invoke();
 		UpdateScrollerEnabled();
 		MusicManager.Get().StartPlaylist(MusicPlaylistType.UI_Store);
-	}
+		}
 
 	private void CompleteClose()
-	{
+		{
 		m_isAnimatingOpenOrClose = false;
 		this.OnCloseCompleted?.Invoke();
 		UpdateScrollerEnabled();
@@ -601,10 +612,10 @@ public class Shop : MonoBehaviour, IStore
 		if (ServiceManager.TryGet<IProductDataService>(out var service) && service.TryGetSubTabFromProductId(product.PmtId, out var parentTab, out var subTab))
 		{
 			if (!parentTab.Enabled || parentTab.Locked || !subTab.Enabled || subTab.Locked)
-			{
+		{
 				Log.Store.PrintWarning($"Attempted to open product {product.PmtId} but Tab({parentTab.Id})/SubTab({subTab.Id}) is unavailable! Skipping...");
-				yield break;
-			}
+			yield break;
+		}
 			m_shopTabController.SelectTab(parentTab.Id, subTab.Id, instant: true);
 		}
 		ShopSlot shopSlot = null;
@@ -615,11 +626,11 @@ public class Shop : MonoBehaviour, IStore
 				if (activeSlot.HasProduct(product))
 				{
 					shopSlot = activeSlot;
-					break;
-				}
+				break;
 			}
+		}
 			if (shopSlot != null)
-			{
+		{
 				break;
 			}
 		}
@@ -660,4 +671,219 @@ public class Shop : MonoBehaviour, IStore
 		timer.StopRecording();
 		TelemetryManager.Client().SendShopVisit(m_browser.GetShopCardTelemetry(), StoreManager.Get().CurrentShopType.ToString(), currentTab, currentSubTab, timer.TimeTaken);
 	}
+
+	#region Accessibility
+	private enum AccessibleState
+	{
+		LOADING,
+		MAIN_MENU,
+		SUB_TAB_MENU,
+		PRODUCT_MENU
+	}
+
+	private AccessibleState m_curState;
+	private AccessibleMenu m_mainMenu;
+	private AccessibleMenu m_subTabMenu;
+	private AccessibleMenu m_productMenu;
+
+	private int m_curTabIdx, m_curSubTabIdx;
+	private bool m_productPageOpened;
+
+	private IEnumerator OnShopOpened()
+	{
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_LOADING);
+		AccessibilityMgr.Output(this, LocalizedText.GLOBAL_PLEASE_WAIT);
+		m_curState = AccessibleState.LOADING;
+		yield return WaitForBrowser();
+
+		ReadShop();
+	}
+
+	private IEnumerator WaitForBrowser()
+	{
+		while (!m_browser.IsReady() || m_browser.IsDirty())
+		{
+			yield return null;
+		}
+	}
+
+	private void ReadShop()
+    {
+        m_mainMenu = new AccessibleMenu(this, "", () => Close(true));
+        m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_READ_GOLD), () => AccessibleShopUtils.ReadGold(this));
+        m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_READ_RUNESTONES), () => AccessibleShopUtils.ReadRunestones(this));
+
+        foreach (var tab in m_shopTabController.m_tabs)
+        {
+            if (tab.CurrentData.Id != ShopTabController.GetVcTabId())
+            {
+                m_mainMenu.AddOption(GameStrings.Get(tab.CurrentData.Name), () => TryActivateTab(tab));
+            }
+        }
+
+        ReadMainMenu();
+    }
+
+    private void ReadMainMenu()
+    {
+        m_curState = AccessibleState.MAIN_MENU;
+        m_mainMenu.StartReading();
+    }
+
+    private void TryActivateTab(ShopTab tab)
+	{
+		if (tab.CurrentData.Id == m_shopData.CurrentTab.Id)
+		{
+			ReadCurrentTab();
+		}
+		else if (tab.CurrentData.Locked)
+		{
+			tab.GetBlockedReasonText(out var title, out var body);
+			AccessibilityMgr.Output(this, body);
+		}
+		else
+        {
+            ActivateTab(tab);
+        }
+    }
+
+	private void TryActivateSubTab(ShopSubTab tab)
+	{
+		if (tab.CurrentData.Id == m_shopData.CurrentSubTab.Id)
+		{
+			ReadProducts();
+		}
+		else
+		{
+			ActivateTab(tab);
+		}
+	}
+
+    private static void ActivateTab(ShopTabBase tab)
+    {
+        Clickable clickable = tab.GetComponentInChildren<Clickable>();
+        clickable.GetPegUIElement().TriggerPress();
+        clickable.GetPegUIElement().TriggerRelease();
+    }
+
+    private void ReadCurrentTab()
+	{
+		if (m_shopTabController.GetNumberOfActiveSubTabs() > 1)
+		{
+			ReadSubTabs();
+		}
+		else
+		{
+			ReadProducts();
+		}
+	}
+
+	private void ReadSubTabs()
+    {
+        m_subTabMenu = new AccessibleMenu(this, "", ReadMainMenu);
+        for (int i = 0; i < m_shopTabController.GetNumberOfActiveSubTabs(); i++)
+        {
+            var tab = m_shopTabController.m_subTabs[i];
+            m_subTabMenu.AddOption(tab.CurrentData.Name, () => TryActivateSubTab(tab));
+        }
+        ReadSubTabMenu();
+    }
+
+    private void ReadSubTabMenu()
+    {
+        m_curState = AccessibleState.SUB_TAB_MENU;
+        m_subTabMenu.StartReading();
+    }
+
+	private void ReadProducts()
+	{
+		var slots = new List<ShopSlot>();
+		foreach (var section in m_browser.GetActiveSections())
+		{
+			slots.AddRange(section.GetActiveSlots());
+		}
+		slots = AccessibleShopUtils.FilterSlotsWhichCanBeBoughtAccessibly(slots);
+
+		m_productMenu = new AccessibleMenu(this, "", BackFromProductMenu);
+		foreach (var slot in slots)
+		{
+			m_productMenu.AddOption(slot.BrowserButtonDataModel.DisplayText, slot.ClickOpen);
+		}
+		m_curState = AccessibleState.PRODUCT_MENU;
+		m_productMenu.StartReading();
+	}
+
+	private void BackFromProductMenu()
+	{
+		if (m_shopTabController.GetNumberOfActiveSubTabs() <= 1)
+		{
+			ReadMainMenu();
+		}
+		else
+		{
+			ReadSubTabMenu();
+		}
+	}
+
+	private IEnumerator A11yOnTabChanged(int tabIdx, int subTabIdx)
+	{
+		if (!AccessibilityMgr.IsCurrentlyFocused(this))
+		{
+			yield break;
+		}
+		m_curState = AccessibleState.LOADING;
+		yield return WaitForBrowser();
+		if (m_curTabIdx != tabIdx)
+		{
+			ReadCurrentTab();
+		}
+		else if (m_curSubTabIdx != subTabIdx)
+		{
+			ReadProducts();
+		}
+		m_curTabIdx = tabIdx;
+		m_curSubTabIdx = subTabIdx;
+	}
+
+	internal void OnProductPageClosed(bool regenerateMenu)
+	{
+		if (!m_productPageOpened)
+		{
+			return;
+		}
+		m_productPageOpened = false;
+		if (regenerateMenu)
+		{
+			ReadProducts();
+		}
+		else
+		{
+			m_productMenu.StartReading();
+		}
+	}
+
+    public void HandleAccessibleInput()
+    {
+        switch (m_curState)
+		{
+			case AccessibleState.MAIN_MENU:
+			m_mainMenu.HandleAccessibleInput();
+			break;
+			case AccessibleState.SUB_TAB_MENU:
+			m_subTabMenu.HandleAccessibleInput();
+			break;
+			case AccessibleState.PRODUCT_MENU:
+			m_productMenu.HandleAccessibleInput();
+			break;
+			default:
+			return;
+		}
+    }
+
+    public string GetAccessibleHelp()
+    {
+        throw new NotImplementedException();
+    }
+	#endregion
 }
diff --git a/Assembly-CSharp/ShopBrowser.cs b/Assembly-CSharp/ShopBrowser.cs
index 72792ee..a8dadca 100644
--- a/Assembly-CSharp/ShopBrowser.cs
+++ b/Assembly-CSharp/ShopBrowser.cs
@@ -9,6 +9,7 @@ using Hearthstone.UI;
 using Hearthstone.UI.Core;
 using UnityEngine;
 using UnityEngine.Serialization;
+using Accessibility;
 
 public class ShopBrowser : MonoBehaviour, IPopupRendering
 {
@@ -153,11 +154,11 @@ public class ShopBrowser : MonoBehaviour, IPopupRendering
 		if (ShopInstance != null && ShopInstance.IsOpen())
 		{
 			if (DataService != null && DataService.TryRefreshStaleProductAvailability())
-			{
-				m_dataDirty = true;
-			}
+		{
+			m_dataDirty = true;
+		}
 			if (m_dataDirty && !m_isLoadingSuppressed)
-			{
+		{
 				StartSectionLoading();
 			}
 		}
@@ -201,7 +202,7 @@ public class ShopBrowser : MonoBehaviour, IPopupRendering
 			m_currentTiers.Clear();
 			m_currentTiers.AddRange(tiers);
 			m_dataDirty = true;
-		}
+			}
 	}
 
 	public void ClearData()
@@ -268,7 +269,7 @@ public class ShopBrowser : MonoBehaviour, IPopupRendering
 			instance.gameObject.SetActive(value: false);
 		}
 		foreach (WidgetInstance dividerInstance in m_dividerInstances)
-		{
+			{
 			dividerInstance.gameObject.SetActive(value: false);
 		}
 		foreach (ShopSection section in m_sections)
@@ -289,7 +290,7 @@ public class ShopBrowser : MonoBehaviour, IPopupRendering
 			m_dataDirty = false;
 			ClearInstances();
 			RefreshBrowserData();
-		}
+			}
 		else
 		{
 			m_loadingCoroutine = StartCoroutine(LoadSectionsCoroutine());
@@ -396,7 +397,7 @@ public class ShopBrowser : MonoBehaviour, IPopupRendering
 				hasStoppedLoadingVis = true;
 			}
 			while (queue.Count > 0)
-			{
+				{
 				BufferedSection bufferedSection = queue.Dequeue();
 				if (bufferedSection.Section.IsElementEnabled)
 				{
@@ -404,14 +405,14 @@ public class ShopBrowser : MonoBehaviour, IPopupRendering
 					{
 						PositionElement(bufferedSection.Divider, previousElement, m_dividerMargins);
 						previousElement = bufferedSection.Divider;
-					}
+				}
 					PositionElement(bufferedSection.Section, previousElement, m_sectionMargins);
 					bufferedSection.Section.SetScrollableState(isActive: true);
 					bufferedSection.Section.Widget.TriggerEvent("TIER_POSITIONED", TriggerEventParameters.Standard);
 					previousElement = bufferedSection.Section;
-				}
 			}
 		}
+		}
 		RefreshBrowserData();
 		SafeStopCoroutine(ref m_loadingSpinnerDelayCoroutine);
 		m_loadingCoroutine = null;
@@ -425,10 +426,10 @@ public class ShopBrowser : MonoBehaviour, IPopupRendering
 		if (m_timeBeforeSpinnerShowsSeconds > 0f)
 		{
 			yield return new WaitForSeconds(m_timeBeforeSpinnerShowsSeconds);
-		}
+				}
 		m_loadingSpinnerDelayCoroutine = null;
 		if (m_suppressUntilLoadedCount > 0 && m_loadingCoroutine != null)
-		{
+	{
 			m_timeWhenSpinnerWasRequested = Time.realtimeSinceStartup;
 			SendEventUpwardStateAction.SendEventUpward(base.gameObject, "START_LOADING_VISUALS");
 		}
diff --git a/Assembly-CSharp/ShopCardList.cs b/Assembly-CSharp/ShopCardList.cs
index f34bedd..dde66f2 100644
--- a/Assembly-CSharp/ShopCardList.cs
+++ b/Assembly-CSharp/ShopCardList.cs
@@ -7,7 +7,7 @@ public class ShopCardList
 {
 	private UIBScrollable m_scrollbar;
 
-	private MiniSetDetailsDataModel m_dataModel;
+	internal MiniSetDetailsDataModel m_dataModel;
 
 	private CardTileDataModel m_clickedTile;
 
diff --git a/Assembly-CSharp/ShopProductData.cs b/Assembly-CSharp/ShopProductData.cs
index ea491b9..7144d84 100644
--- a/Assembly-CSharp/ShopProductData.cs
+++ b/Assembly-CSharp/ShopProductData.cs
@@ -1,7 +1,7 @@
 using System;
 using UnityEngine;
 
-[CreateAssetMenu(fileName = "NewShopProductData", menuName = "ShopProductData", order = 59)]
+// [CreateAssetMenu(fileName = "NewShopProductData", menuName = "ShopProductData", order = 59)]
 public class ShopProductData : ScriptableObject
 {
 	[Serializable]
diff --git a/Assembly-CSharp/ShopSlot.cs b/Assembly-CSharp/ShopSlot.cs
index 4f33c9d..e115071 100644
--- a/Assembly-CSharp/ShopSlot.cs
+++ b/Assembly-CSharp/ShopSlot.cs
@@ -54,7 +54,7 @@ public class ShopSlot : ShopBrowserElement
 	}
 
 	private void OnDestroy()
-	{
+		{
 		if (m_disableColliderCoroutine != null)
 		{
 			StopCoroutine(m_disableColliderCoroutine);
@@ -78,19 +78,19 @@ public class ShopSlot : ShopBrowserElement
 	public void SetParent(ShopSection shopSection)
 	{
 		m_parentSection = shopSection;
-	}
+			}
 
 	public void SetBlocked(bool isBlocked)
 	{
 		m_isBlocked = isBlocked;
 		RefreshInput();
-	}
+		}
 
 	public void RefreshData()
-	{
+		{
 		BrowserButtonDataModel = base.Widget.GetDataModel<ShopBrowserButtonDataModel>();
 		if (BrowserButtonDataModel != null)
-		{
+			{
 			ProductDataModel productDataModel = BrowserButtonDataModel.DisplayProduct;
 			bool flag = productDataModel.IsEmpty();
 			IGamemodeAvailabilityService.Status status;
@@ -129,8 +129,8 @@ public class ShopSlot : ShopBrowserElement
 		{
 			SetEnabled(isEnabled: false);
 		}
-		UpdateShopCardTelemetry();
-	}
+				UpdateShopCardTelemetry();
+			}
 
 	public void SetData(ShopBrowserButtonDataModel browserButtonDataModel)
 	{
@@ -166,8 +166,8 @@ public class ShopSlot : ShopBrowserElement
 			else
 			{
 				base.Widget.UnbindDataModel(15);
-			}
 		}
+	}
 		m_disableColliderCoroutine = StartCoroutine(DisableChildCollidersCoroutine());
 		RefreshInput();
 	}
@@ -241,7 +241,7 @@ public class ShopSlot : ShopBrowserElement
 		if (displayProduct == null)
 		{
 			return;
-		}
+			}
 		if (displayProduct.Tags.Contains("vc") && displayProduct.Variants.Count > 1)
 		{
 			ProductDataModel vcVariant = displayProduct;
@@ -423,4 +423,12 @@ public class ShopSlot : ShopBrowserElement
 		m_marketingImageFitter.SetTexture(imgConfig);
 		displayProduct.ShowMarketingImage = true;
 	}
+
+	#region Accessibility
+	internal void ClickOpen()
+	{
+		Clickable component = GetComponent<Clickable>();
+		component.GetPegUIElement()?.TriggerRelease();
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/ShopTab.cs b/Assembly-CSharp/ShopTab.cs
index 6881c8f..67f287e 100644
--- a/Assembly-CSharp/ShopTab.cs
+++ b/Assembly-CSharp/ShopTab.cs
@@ -23,13 +23,7 @@ public class ShopTab : ShopTabBase
 
 	protected override void GetTooltipData(out string title, out string body)
 	{
-		title = string.Empty;
-		body = string.Empty;
-		if (base.CurrentData != null && base.CurrentData.Locked && (base.CurrentData.LockedReason != 0 || base.CurrentData.LockedReason != IGamemodeAvailabilityService.Status.READY))
-		{
-			title = GameStrings.Get("GLUE_STORE_UNAVAILABLE_REASON_TITLE_LOCKED");
-			body = GameStrings.Format(GetLocStrFromGamemodeStatus(base.CurrentData.LockedReason), GetDisplayableStringForGamemodeName(base.CurrentData.LockedMode));
-		}
+		GetBlockedReasonText(out title, out body);
 	}
 
 	private static string GetDisplayableStringForGamemodeName(IGamemodeAvailabilityService.Gamemode mode)
@@ -57,4 +51,17 @@ public class ShopTab : ShopTabBase
 			return "GLUE_STORE_UNAVAILABLE_REASON_UNKNOWN";
 		}
 	}
+
+	#region Accessibility
+	internal void GetBlockedReasonText(out string title, out string body)
+	{
+		title = string.Empty;
+		body = string.Empty;
+		if (base.CurrentData != null && base.CurrentData.Locked && (base.CurrentData.LockedReason != 0 || base.CurrentData.LockedReason != IGamemodeAvailabilityService.Status.READY))
+		{
+			title = GameStrings.Get("GLUE_STORE_UNAVAILABLE_REASON_TITLE_LOCKED");
+			body = GameStrings.Format(GetLocStrFromGamemodeStatus(base.CurrentData.LockedReason), GetDisplayableStringForGamemodeName(base.CurrentData.LockedMode));
+		}
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/ShopTabController.cs b/Assembly-CSharp/ShopTabController.cs
index 827f64c..42586a4 100644
--- a/Assembly-CSharp/ShopTabController.cs
+++ b/Assembly-CSharp/ShopTabController.cs
@@ -23,12 +23,12 @@ public class ShopTabController : MonoBehaviour
 	[SerializeField]
 	private List<AsyncReference> m_tabRefs;
 
-	private List<ShopTab> m_tabs = new List<ShopTab>();
+	internal List<ShopTab> m_tabs = new List<ShopTab>();
 
 	[SerializeField]
 	private List<AsyncReference> m_subTabRefs;
 
-	private List<ShopSubTab> m_subTabs = new List<ShopSubTab>();
+	internal List<ShopSubTab> m_subTabs = new List<ShopSubTab>();
 
 	private List<TabData> m_tabDataModels = new List<TabData>();
 
@@ -231,7 +231,7 @@ public class ShopTabController : MonoBehaviour
 		{
 			return;
 		}
-		if (m_tabs[tabIndex].CurrentData.Id == "runestones")
+		if (m_tabs[tabIndex].CurrentData.Id == GetVcTabId())
 		{
 			m_vcPageTabIndex = tabIndex;
 			Shop.Get().ProductPageController.OpenVirtualCurrencyPurchase();
@@ -553,4 +553,11 @@ public class ShopTabController : MonoBehaviour
 			shop.SendShopTabTelemetry();
 		}
 	}
+
+	#region Accessibility
+	internal static string GetVcTabId()
+	{
+		return "runestones";
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/ShopUtils.cs b/Assembly-CSharp/ShopUtils.cs
index 06b5a33..01de453 100644
--- a/Assembly-CSharp/ShopUtils.cs
+++ b/Assembly-CSharp/ShopUtils.cs
@@ -8,6 +8,7 @@ using Hearthstone.DataModels;
 using Hearthstone.Store;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public static class ShopUtils
 {
@@ -45,8 +46,8 @@ public static class ShopUtils
 		{
 			if (service.TierHasShowIfAllOwnedTag(tier))
 			{
-				return true;
-			}
+			return true;
+		}
 			foreach (ShopBrowserButtonDataModel browserButton in tier.BrowserButtons)
 			{
 				if (ShouldDisplayButton(browserButton))
diff --git a/Assembly-CSharp/SocialToastMgr.cs b/Assembly-CSharp/SocialToastMgr.cs
index cdf03e5..fa73506 100644
--- a/Assembly-CSharp/SocialToastMgr.cs
+++ b/Assembly-CSharp/SocialToastMgr.cs
@@ -10,6 +10,7 @@ using Hearthstone.Progression;
 using PegasusClient;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class SocialToastMgr : MonoBehaviour
 {
@@ -163,7 +164,7 @@ public class SocialToastMgr : MonoBehaviour
 
 	public void AddToast(UserAttentionBlocker blocker, string textArg, TOAST_TYPE toastType, float displayTime, bool playSound)
 	{
-		if (UserAttentionManager.CanShowAttentionGrabber(blocker, "SocialToastMgr.AddToast:" + toastType))
+		if (UserAttentionManager.CanShowAttentionGrabber(false, blocker, "SocialToastMgr.AddToast:" + toastType))
 		{
 			string message = toastType switch
 			{
@@ -244,13 +245,14 @@ public class SocialToastMgr : MonoBehaviour
 		RenderUtils.SetAlpha(m_currentToast.gameObject, 1f);
 		if (toastArgs.m_playSound)
 		{
-			PlayToastSound();
+			PlayToastSound(toastArgs.m_message);
 		}
 	}
 
-	public void PlayToastSound()
+	public void PlayToastSound(string message)
 	{
 		SoundManager.Get().LoadAndPlay("UI_BnetToast.prefab:b869739323d1fc241984f9f480fff8ef");
+		AccessibilityMgr.OutputNotification(message);
 	}
 
 	private void FadeOutToast(float displayTime)
diff --git a/Assembly-CSharp/SoundManager.cs b/Assembly-CSharp/SoundManager.cs
index fa84448..3899899 100644
--- a/Assembly-CSharp/SoundManager.cs
+++ b/Assembly-CSharp/SoundManager.cs
@@ -11,6 +11,7 @@ using Blizzard.T5.Services;
 using Hearthstone;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 {
@@ -686,8 +687,8 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			SoundLoadContext soundLoadContext = new SoundLoadContext();
 			soundLoadContext.Init(parent, volume, callback, callbackData);
 			SoundLoader.LoadSound(assetRef, OnLoadAndPlaySoundLoaded, soundLoadContext, GetPlaceholderSound());
-		}
-	}
+        }
+    }
 
 	public void PlayPreloaded(AudioSource source)
 	{
@@ -719,7 +720,7 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 		InitSourceTransform(source, parentObject);
 		m_generatedSources.Add(source);
 		Play(source);
-	}
+    }
 
 	public AudioSource PlayClip(SoundPlayClipArgs args, bool createNewSource = true, SoundOptions options = null)
 	{
@@ -824,7 +825,7 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			return;
 		}
 		RegisterSourceBundle(assetRef, component);
-		component.volume = 0f;
+        component.volume = 0f;
 		component.Play();
 		component.Stop();
 		UnregisterSourceBundle(assetRef.ToString(), component);
@@ -1002,7 +1003,7 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 		NukeMusicAndAmbiencePlaylists();
 		FinishAllFadingTracks();
 		FinishMusicAndAmbiance();
-	}
+		}
 
 	private void FinishMusicAndAmbiance()
 	{
@@ -2184,11 +2185,18 @@ public class SoundManager : IService, IHasFixedUpdate, IHasUpdate
 			}
 			HearthstoneApplication.Get().StartCoroutine(EnableInstanceLimitedSound(source.gameObject.name, num2));
 		}
+
+		if (HearthstoneAccessConstants.DEBUG_SOUND)
+        {
+            AccessibilityUtils.LogDebug($"Playing sound: {source.name}");
+			AccessibilityUtils.LogDebug(Environment.StackTrace);
+        }
+
 		if (additionalSettings != null && additionalSettings.RandomStartTime && source?.clip != null)
 		{
 			source.time = UnityEngine.Random.value * source.clip.length;
 		}
-		source.Play();
+        source.Play();
 		return source;
 	}
 
diff --git a/Assembly-CSharp/SoundOptionsMenu.cs b/Assembly-CSharp/SoundOptionsMenu.cs
index 8d6beda..d9aa77d 100644
--- a/Assembly-CSharp/SoundOptionsMenu.cs
+++ b/Assembly-CSharp/SoundOptionsMenu.cs
@@ -1,6 +1,7 @@
 using UnityEngine;
+using Accessibility;
 
-public class SoundOptionsMenu : MonoBehaviour
+public class SoundOptionsMenu : MonoBehaviour, AccessibleUI
 {
 	[SerializeField]
 	[Header("Sound")]
@@ -113,10 +114,12 @@ public class SoundOptionsMenu : MonoBehaviour
 	{
 		ShowOrHide(showOrHide: true);
 		AnimationUtil.ShowWithPunch(base.gameObject, m_hiddenScale, 1.1f * m_normalScale, m_normalScale, null, noFade: true);
+		ReadMenu();
 	}
 
 	public void Hide()
 	{
+		AccessibilityMgr.HideUI(this);
 		ShowOrHide(showOrHide: false);
 	}
 
@@ -183,4 +186,101 @@ public class SoundOptionsMenu : MonoBehaviour
 			optionCheckbox.SetChecked(Options.Get().GetBool(option));
 		}
 	}
+
+#region Accessibility
+
+	private AccessibleMenu m_accessibleMenu;
+
+	private AccessibleScrollbarControl m_curAccessibleScrollbar;
+
+	private enum AccessibleMenuState { MAIN_MENU, ADJUSTING_SLIDER };
+
+	private AccessibleMenuState m_curState;
+
+	private AccessibleCheckBox m_accessibleSoundInBackground;
+
+	private AccessibleCheckBox m_accessibleSoundMono;
+
+	private AccessibleScrollbarControl m_accessibleMasterVolume;
+
+	private AccessibleScrollbarControl m_accessibleMusicVolume;
+
+	private AccessibleScrollbarControl m_accessibleAmbienceVolume;
+
+	private AccessibleScrollbarControl m_accessibleDialogVolume;
+
+	private AccessibleScrollbarControl m_accessibleSoundEffectVolume;
+
+	private void ReadMenu()
+	{
+		AccessibilityMgr.ShowUI(this);
+
+		m_accessibleSoundInBackground = new AccessibleCheckBox(this, LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_SOUND_IN_BACKGROUND_OPTION), m_backgroundSound);
+		m_accessibleSoundMono = new AccessibleCheckBox(this, LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_SOUND_MONO_OPTION), m_monoSound);
+		m_accessibleMasterVolume = new AccessibleScrollbarControl(this, LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_MASTER_VOLUME_OPTION), m_masterVolume, BackToMainMenu);
+		m_accessibleMusicVolume = new AccessibleScrollbarControl(this, LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_MUSIC_VOLUME_OPTION), m_musicVolume, BackToMainMenu);
+		m_accessibleDialogVolume = new AccessibleScrollbarControl(this, LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_DIALOG_VOLUME_OPTION), m_dialogVolume, BackToMainMenu);
+		m_accessibleSoundEffectVolume = new AccessibleScrollbarControl(this, LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_SOUND_EFFECT_VOLUME_OPTION), m_soundEffectVolume, BackToMainMenu);
+		m_accessibleAmbienceVolume = new AccessibleScrollbarControl(this, LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_AMBIENT_SOUNDS_VOLUME_OPTION), m_ambienceVolume, BackToMainMenu);
+
+		SetupMainMenu();
+	}
+
+	private void SetupMainMenu()
+	{
+		m_curState = AccessibleMenuState.MAIN_MENU;
+		m_accessibleMenu = new AccessibleMenu(this, LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_TITLE), m_backButton.TriggerRelease, true);
+
+		m_accessibleMenu.AddOption(m_accessibleMasterVolume.GetText, () => AdjustSlider(m_accessibleMasterVolume));
+		m_accessibleMenu.AddOption(m_accessibleMusicVolume.GetText, () => AdjustSlider(m_accessibleMusicVolume));
+		m_accessibleMenu.AddOption(m_accessibleDialogVolume.GetText, () => AdjustSlider(m_accessibleDialogVolume));
+		m_accessibleMenu.AddOption(m_accessibleAmbienceVolume.GetText, () => AdjustSlider(m_accessibleAmbienceVolume));
+		m_accessibleMenu.AddOption(m_accessibleSoundEffectVolume.GetText, () => AdjustSlider(m_accessibleSoundEffectVolume));
+		m_accessibleMenu.AddOption(m_accessibleSoundInBackground.GetText, m_accessibleSoundInBackground.Toggle);
+		m_accessibleMenu.AddOption(m_accessibleSoundMono.GetText, m_accessibleSoundMono.Toggle);
+		m_accessibleMenu.AddOption(LocalizationUtils.Get(LocalizationKey.SOUND_OPTIONS_MENU_RESET_DEFAULTS_OPTION), m_resetDefaultsButton.TriggerRelease);
+
+		m_accessibleMenu.StartReading();
+	}
+
+	private void BackToMainMenu()
+	{
+		m_curState = AccessibleMenuState.MAIN_MENU;
+		m_accessibleMenu.ReadCurrentOption();
+	}
+
+	private void AdjustSlider(AccessibleScrollbarControl slider)
+	{
+		m_curAccessibleScrollbar = slider;
+		m_curState = AccessibleMenuState.ADJUSTING_SLIDER;
+		AccessibilityMgr.Output(this, LocalizedText.OPTIONS_MENU_ADJUST_VOLUME);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (m_curState == AccessibleMenuState.MAIN_MENU)
+		{
+			m_accessibleMenu?.HandleAccessibleInput();
+		}
+		else if (m_curState == AccessibleMenuState.ADJUSTING_SLIDER)
+		{
+			m_curAccessibleScrollbar?.HandleInput();
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_curState == AccessibleMenuState.MAIN_MENU)
+		{
+			return m_accessibleMenu?.GetHelp();
+		}
+		else if (m_curState == AccessibleMenuState.ADJUSTING_SLIDER)
+		{
+			return LocalizationUtils.Get(LocalizationKey.OPTIONS_MENU_ADJUST_VOLUME);
+		}
+
+		return "";
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/SpectatorManager.cs b/Assembly-CSharp/SpectatorManager.cs
index 0a66df5..d2f0cbc 100644
--- a/Assembly-CSharp/SpectatorManager.cs
+++ b/Assembly-CSharp/SpectatorManager.cs
@@ -865,35 +865,35 @@ public class SpectatorManager
 			}
 			else
 			{
-				if (m_spectateeFriendlySide == gameAccountId)
-				{
-					LogInfoParty("SpectatePlayer: already spectating player {0}", gameAccountId);
-					if (receivedInviteFrom != null)
-					{
-						BnetParty.AcceptReceivedInvite(receivedInviteFrom.InviteId);
-					}
-					return;
-				}
-				LogInfoPower("================== Begin Spectating 2nd player ==================");
-				m_spectateeOpposingSide = gameAccountId;
+			if (m_spectateeFriendlySide == gameAccountId)
+			{
+				LogInfoParty("SpectatePlayer: already spectating player {0}", gameAccountId);
 				if (receivedInviteFrom != null)
 				{
 					BnetParty.AcceptReceivedInvite(receivedInviteFrom.InviteId);
 				}
-				else if (joinInfo.HasPartyId)
-				{
-					BnetPartyId partyId2 = BnetUtils.CreatePartyId(joinInfo.PartyId);
-					m_requestedInvite = new IntendedSpectateeParty(gameAccountId, partyId2);
-					BnetGameAccountId myGameAccountId2 = BnetPresenceMgr.Get().GetMyGameAccountId();
-					BnetParty.RequestInvite(partyId2, gameAccountId, myGameAccountId2, PartyType.SPECTATOR_PARTY);
-					Processor.ScheduleCallback(5f, realTime: true, SpectatePlayer_RequestInvite_OpposingSide_Timeout);
-				}
-				else
-				{
-					SpectateSecondPlayer_Network(joinInfo);
-				}
+				return;
+			}
+			LogInfoPower("================== Begin Spectating 2nd player ==================");
+			m_spectateeOpposingSide = gameAccountId;
+			if (receivedInviteFrom != null)
+			{
+				BnetParty.AcceptReceivedInvite(receivedInviteFrom.InviteId);
+			}
+			else if (joinInfo.HasPartyId)
+			{
+				BnetPartyId partyId2 = BnetUtils.CreatePartyId(joinInfo.PartyId);
+				m_requestedInvite = new IntendedSpectateeParty(gameAccountId, partyId2);
+				BnetGameAccountId myGameAccountId2 = BnetPresenceMgr.Get().GetMyGameAccountId();
+				BnetParty.RequestInvite(partyId2, gameAccountId, myGameAccountId2, PartyType.SPECTATOR_PARTY);
+				Processor.ScheduleCallback(5f, realTime: true, SpectatePlayer_RequestInvite_OpposingSide_Timeout);
+			}
+			else
+			{
+				SpectateSecondPlayer_Network(joinInfo);
 			}
 		}
+		}
 		else
 		{
 			if (m_spectateeFriendlySide == gameAccountId || m_spectateeOpposingSide == gameAccountId)
@@ -2192,7 +2192,7 @@ public class SpectatorManager
 					Processor.CancelScheduledCallback(SpectatePlayer_RequestInvite_OpposingSide_Timeout);
 				}
 			}
-			else if (!UserAttentionManager.CanShowAttentionGrabber("SpectatorManager.BnetParty_OnReceivedInvite:" + evt))
+			else if (!UserAttentionManager.CanShowAttentionGrabber(false, "SpectatorManager.BnetParty_OnReceivedInvite:" + evt))
 			{
 				flag3 = true;
 				text = "user_attention_blocked";
@@ -2376,8 +2376,8 @@ public class SpectatorManager
 		GameState gameState = GameState.Get();
 		if (gameState == null || gameState.GameScenarioAllowsPowerPrinting())
 		{
-			Log.Power.Print(format, args);
-		}
+		Log.Power.Print(format, args);
+	}
 	}
 
 	private bool IsPlayerInGame(BnetGameAccountId gameAccountId)
diff --git a/Assembly-CSharp/Store.cs b/Assembly-CSharp/Store.cs
index 2b1e7b0..65680c7 100644
--- a/Assembly-CSharp/Store.cs
+++ b/Assembly-CSharp/Store.cs
@@ -9,9 +9,10 @@ using Hearthstone.DataModels;
 using Hearthstone.Store;
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public abstract class Store : UIBPopup, IStore
+public abstract class Store : UIBPopup, IStore, AccessibleUI
 {
 	protected enum BuyButtonState
 	{
@@ -61,7 +62,7 @@ public abstract class Store : UIBPopup, IStore
 			{
 				m_state = value;
 				Refresh();
-			}
+		}
 		}
 
 		public bool ForceDisabled
@@ -147,7 +148,7 @@ public abstract class Store : UIBPopup, IStore
 			m_tooltipZone.HideTooltip();
 		}
 
-		private string GetBuyButtonTooltipMessage(BuyButtonState state)
+		internal string GetBuyButtonTooltipMessage(BuyButtonState state)
 		{
 			switch (state)
 			{
@@ -445,12 +446,12 @@ public abstract class Store : UIBPopup, IStore
 			}
 		}
 		m_useOverlayUI = useOverlayUI;
-		StartCoroutine(ShowWhenReady(isTotallyFake));
+		StartCoroutine(ShowWhenReady(isTotallyFake,(ProductDataModel)dataModel));
 	}
 
 	public void Open()
 	{
-		StartCoroutine(ShowWhenReady(isTotallyFake: false));
+		StartCoroutine(ShowWhenReady(isTotallyFake:false, new ProductDataModel()));
 	}
 
 	public bool IsOpen()
@@ -658,7 +659,7 @@ public abstract class Store : UIBPopup, IStore
 		return m_vcButtonInternal.State;
 	}
 
-	private IEnumerator ShowWhenReady(bool isTotallyFake)
+	private IEnumerator ShowWhenReady(bool isTotallyFake, ProductDataModel dataModel)
 	{
 		VisualController visualController = GetComponent<VisualController>();
 		while (visualController != null && visualController.IsChangingStates)
@@ -666,6 +667,11 @@ public abstract class Store : UIBPopup, IStore
 			yield return null;
 		}
 		ShowImpl(isTotallyFake);
+
+		if (!DialogManager.Get().ShowingDialog())
+		{
+			ReadStore(dataModel);
+		}
 	}
 
 	private void ForceDisableBuyButtons(bool forceDisable)
@@ -813,17 +819,17 @@ public abstract class Store : UIBPopup, IStore
 	}
 
 	private void OnShopProductPageOpened(ProductPage page)
-	{
-		m_restoreWhenShopHides = true;
-		Hide();
-	}
+		{
+			m_restoreWhenShopHides = true;
+			Hide();
+		}
 
 	private void OnShopProductPageClosed(ProductPage page)
 	{
 		if (this != null && m_restoreWhenShopHides)
 		{
 			m_restoreWhenShopHides = false;
-			StartCoroutine(ShowWhenReady(isTotallyFake: false));
+			StartCoroutine(ShowWhenReady(isTotallyFake: false, new ProductDataModel()));
 		}
 	}
 
@@ -836,4 +842,50 @@ public abstract class Store : UIBPopup, IStore
 		}
 		return hashSet;
 	}
+
+	#region accessibility
+	private AccessibleMenu m_accessibleMenu;
+	public void ReadStore(ProductDataModel dataMode) {
+		AccessibilityMgr.ShowUI(this);
+		WidgetTemplate componentOnSelfOrParent = GameObjectUtils.GetComponentOnSelfOrParent<WidgetTemplate>(base.transform);
+		ProductDataModel dataModel=componentOnSelfOrParent.GetDataModel<ProductDataModel>();
+		if(dataModel!=null) {
+			AccessibilityMgr.Output(null,dataModel.DescriptionHeader);
+		AccessibilityMgr.Output(null,dataModel.FlavorText);
+	}
+		m_accessibleMenu=new AccessibleMenu(null,"", () => Navigation.GoBack());
+		foreach (BuyButtonInternal buyButton in m_buyButtons) {
+			if(buyButton.State!=BuyButtonState.ENABLED) {
+continue;
+			}
+			 m_accessibleMenu.AddOption(GameStrings.Get(buyButton.m_toolTipHeadlineStringId)+" "+buyButton.m_button.m_ButtonText.Text,() => ClickBuyButton(buyButton));
+		}
+		m_accessibleMenu.StartReading();
+	}
+
+	private void ClickBuyButton(BuyButtonInternal btn) {
+			if(btn.State!=BuyButtonState.ENABLED) {
+				AccessibilityMgr.Output(this,btn.GetBuyButtonTooltipMessage(btn.State));
+				return;
+			}
+			btn.m_button.TriggerRelease();
+	}
+	public void HandleAccessibleInput() {
+		m_accessibleMenu?.HandleAccessibleInput();
+	}
+
+	public string GetAccessibleHelp() {
+		return m_accessibleMenu.GetHelp();
+
+	}
+
+	public void OnGainedFocus() {
+
+	}
+	public override void Hide() {
+		base.Hide();
+		AccessibilityMgr.HideUI(this);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/StoreManager.cs b/Assembly-CSharp/StoreManager.cs
index 4182503..865aa71 100644
--- a/Assembly-CSharp/StoreManager.cs
+++ b/Assembly-CSharp/StoreManager.cs
@@ -454,7 +454,7 @@ public class StoreManager : IProductAvailabilityApi
 		return false;
 	}
 
-	private void SetCanTapOutConfirmationUI(bool closeConfirmationUI)
+	internal void SetCanTapOutConfirmationUI(bool closeConfirmationUI)
 	{
 		m_canCloseConfirmation = closeConfirmationUI;
 	}
@@ -1041,7 +1041,7 @@ public class StoreManager : IProductAvailabilityApi
 		}
 		else
 		{
-			cultureInfo.NumberFormat.CurrencySymbol = " " + m_currency.Symbol + " ";
+		cultureInfo.NumberFormat.CurrencySymbol = " " + m_currency.Symbol + " ";
 		}
 		return string.Format(cultureInfo, format, costDisplay).Replace("  ", " ").Trim();
 	}
@@ -1423,12 +1423,12 @@ public class StoreManager : IProductAvailabilityApi
 		case ShopType.GENERAL_STORE:
 			if (!IsOpen())
 			{
-				Log.Store.PrintWarning("StoreManager.ShowStore(): Cannot show general store.. Store is not open");
-				if (m_showStoreData.exitCallback != null)
-				{
-					m_showStoreData.exitCallback(authorizationBackButtonPressed: false, m_showStoreData.exitCallbackUserData);
-				}
-				flag = false;
+			Log.Store.PrintWarning("StoreManager.ShowStore(): Cannot show general store.. Store is not open");
+			if (m_showStoreData.exitCallback != null)
+			{
+				m_showStoreData.exitCallback(authorizationBackButtonPressed: false, m_showStoreData.exitCallbackUserData);
+			}
+			flag = false;
 			}
 			break;
 		case ShopType.ADVENTURE_STORE:
@@ -1488,25 +1488,25 @@ public class StoreManager : IProductAvailabilityApi
 			{
 				currentStore.Open();
 				if (m_currentShopType == ShopType.GENERAL_STORE && currentStore is Shop shop)
-				{
-					if (ServiceManager.TryGet<IProductDataService>(out var service) && service.TryFindTabWithId(m_showStoreData.TargetTabId, out var parentTab, out var subTab))
 					{
-						if ((parentTab != null && !parentTab.Enabled) || parentTab.Locked || (subTab != null && !subTab.Enabled) || (subTab != null && subTab.Locked))
+						if (ServiceManager.TryGet<IProductDataService>(out var service) && service.TryFindTabWithId(m_showStoreData.TargetTabId, out var parentTab, out var subTab))
 						{
-							Log.Store.PrintWarning("StoreManager.ShowStore(): Attempted to open locked " + m_showStoreData.TargetTabId + "...");
+							if ((parentTab != null && !parentTab.Enabled) || parentTab.Locked || (subTab != null && !subTab.Enabled) || (subTab != null && subTab.Locked))
+							{
+								Log.Store.PrintWarning("StoreManager.ShowStore(): Attempted to open locked " + m_showStoreData.TargetTabId + "...");
+							}
+							else
+							{
+								shop.MoveToTab(parentTab, subTab, isImmediate: true);
+							}
 						}
 						else
 						{
-							shop.MoveToTab(parentTab, subTab, isImmediate: true);
+							Log.Store.PrintWarning("StoreManager.ShowStore(): Cannot show tab " + m_showStoreData.TargetTabId + ".. opening to default...");
 						}
 					}
-					else
-					{
-						Log.Store.PrintWarning("StoreManager.ShowStore(): Cannot show tab " + m_showStoreData.TargetTabId + ".. opening to default...");
-					}
 				}
 			}
-		}
 		currentStore?.BlockInterface(blocked);
 		Log.Store.Print("{0} took {1}s to load", m_currentShopType, Time.realtimeSinceStartup - m_showStoreStart);
 		m_waitingToShowStore = false;
@@ -2177,9 +2177,9 @@ public class StoreManager : IProductAvailabilityApi
 		if ((!ServiceManager.TryGet<IProductDataService>(out var service) || !service.HasProductsAvailable()) && (m_goldCostBooster == null || m_goldCostBooster.Count <= 0))
 		{
 			if (m_goldCostArena.HasValue)
-			{
-				return m_goldCostArena.HasValue;
-			}
+		{
+			return m_goldCostArena.HasValue;
+		}
 			return false;
 		}
 		return true;
@@ -2657,44 +2657,44 @@ public class StoreManager : IProductAvailabilityApi
 		{
 			return;
 		}
-		if (source == PurchaseErrorSource.FROM_PREVIOUS_PURCHASE)
-		{
-			BlockStoreInterface();
-			m_view.PurchaseAuth.ShowPreviousPurchaseSuccess(moneyOrGTAPPTransaction, GetPurchaseAuthButtonStyle(m_currentShopType));
+			if (source == PurchaseErrorSource.FROM_PREVIOUS_PURCHASE)
+			{
+				BlockStoreInterface();
+				m_view.PurchaseAuth.ShowPreviousPurchaseSuccess(moneyOrGTAPPTransaction, GetPurchaseAuthButtonStyle(m_currentShopType));
 			return;
-		}
+			}
 		if (ServiceManager.TryGet<CurrencyManager>(out var service))
+	{
+		switch (paymentMethod)
 		{
-			switch (paymentMethod)
-			{
-			case PaymentMethod.GOLD_GTAPP:
-			case PaymentMethod.GOLD_NO_GTAPP:
+		case PaymentMethod.GOLD_GTAPP:
+		case PaymentMethod.GOLD_NO_GTAPP:
 				service.MarkCurrencyDirty(CurrencyType.GOLD);
-				break;
-			case PaymentMethod.VIRTUAL_CURRENCY:
+			break;
+		case PaymentMethod.VIRTUAL_CURRENCY:
 				if (productInfo != null)
-				{
+			{
 					CurrencyType firstVirtualCurrencyPriceType = productInfo.GetFirstVirtualCurrencyPriceType();
-					if (firstVirtualCurrencyPriceType != 0)
-					{
+				if (firstVirtualCurrencyPriceType != 0)
+				{
 						service.MarkCurrencyDirty(firstVirtualCurrencyPriceType);
-					}
 				}
-				break;
 			}
+			break;
+		}
 			if (productInfo != null)
-			{
+		{
 				foreach (Network.BundleItem item in productInfo.Items)
 				{
 					if (item.ItemType == ProductType.PRODUCT_TYPE_CURRENCY)
-					{
-						CurrencyType currencyTypeFromProto = ShopUtils.GetCurrencyTypeFromProto((PegasusShared.CurrencyType)item.ProductData);
-						if (currencyTypeFromProto != 0)
-						{
+		{
+			CurrencyType currencyTypeFromProto = ShopUtils.GetCurrencyTypeFromProto((PegasusShared.CurrencyType)item.ProductData);
+			if (currencyTypeFromProto != 0)
+			{
 							service.MarkCurrencyDirty(currencyTypeFromProto);
-						}
-					}
-				}
+			}
+		}
+	}
 			}
 		}
 		RemovePurchaseAuthCancelButton();
@@ -2710,14 +2710,14 @@ public class StoreManager : IProductAvailabilityApi
 		{
 			bool willAutoPurchase = service.HasAutoPurchase();
 			while (Status != TransactionStatus.READY || willAutoPurchase || (string.IsNullOrEmpty(currencyError) && currencyManager.IsAnyCurrencyCacheRefreshing()))
-			{
-				elapsedSeconds = DateTime.Now.Subtract(startTime).TotalSeconds;
+		{
+			elapsedSeconds = DateTime.Now.Subtract(startTime).TotalSeconds;
 				if (string.IsNullOrEmpty(currencyError) && elapsedSeconds > CURRENCY_TRANSACTION_TIMEOUT_SECONDS)
-				{
+			{
 					currencyError = $"Gave up on waiting for currency balance after {elapsedSeconds} seconds";
-				}
-				yield return null;
 			}
+			yield return null;
+		}
 		}
 		else
 		{
@@ -3244,20 +3244,20 @@ public class StoreManager : IProductAvailabilityApi
 		Network.BattlePayConfig battlePayConfigResponse = Network.Get().GetBattlePayConfigResponse();
 		if (battlePayConfigResponse.Available)
 		{
-			m_secsBeforeAutoCancel = battlePayConfigResponse.SecondsBeforeAutoCancel;
+		m_secsBeforeAutoCancel = battlePayConfigResponse.SecondsBeforeAutoCancel;
 			m_ignoreProductTiming = battlePayConfigResponse.IgnoreProductTiming;
 			m_currency = battlePayConfigResponse.Currency;
-			m_goldCostBooster.Clear();
-			foreach (Network.GoldCostBooster goldCostBooster in battlePayConfigResponse.GoldCostBoosters)
-			{
-				m_goldCostBooster.Add(goldCostBooster.ID, goldCostBooster);
-			}
-			m_goldCostArena = battlePayConfigResponse.GoldCostArena;
-			m_sales.Clear();
-			foreach (Network.ShopSale sale in battlePayConfigResponse.SaleList)
-			{
-				m_sales[sale.SaleId] = sale;
-			}
+		m_goldCostBooster.Clear();
+		foreach (Network.GoldCostBooster goldCostBooster in battlePayConfigResponse.GoldCostBoosters)
+		{
+			m_goldCostBooster.Add(goldCostBooster.ID, goldCostBooster);
+		}
+		m_goldCostArena = battlePayConfigResponse.GoldCostArena;
+		m_sales.Clear();
+		foreach (Network.ShopSale sale in battlePayConfigResponse.SaleList)
+		{
+			m_sales[sale.SaleId] = sale;
+		}
 			Log.Store.Print("Server responds that store is available.");
 			BattlePayAvailable = true;
 		}
@@ -3484,15 +3484,15 @@ public class StoreManager : IProductAvailabilityApi
 		if (store != null)
 		{
 			store.OnProductPurchaseAttempt += StartStoreBuy;
-			store.OnOpened += OnStoreOpen;
-			store.OnClosed += delegate(StoreClosedArgs e)
-			{
-				OnStoreExit(e.authorizationBackButtonPressed.GetValueOrDefault(false), null);
-			};
-			store.OnReady += StoreViewReady;
-			(store as Store)?.RegisterInfoListener(OnStoreInfo);
-			StoreViewReady();
-		}
+		store.OnOpened += OnStoreOpen;
+		store.OnClosed += delegate(StoreClosedArgs e)
+		{
+			OnStoreExit(e.authorizationBackButtonPressed.GetValueOrDefault(false), null);
+		};
+		store.OnReady += StoreViewReady;
+		(store as Store)?.RegisterInfoListener(OnStoreInfo);
+		StoreViewReady();
+	}
 	}
 
 	private void OnSceneUnloaded(SceneMgr.Mode prevMode, PegasusScene prevScene, object userData)
@@ -3578,10 +3578,10 @@ public class StoreManager : IProductAvailabilityApi
 		Status = TransactionStatus.READY;
 		if (data != null)
 		{
-			Network.Get().ReportBlizzardCheckoutStatus(BlizzardCheckoutStatus.BLIZZARD_CHECKOUT_STATUS_COMPLETED_FAILED, data);
-			TelemetryManager.Client().SendBlizzardCheckoutPurchaseCompletedFailure(data.TransactionID, data.ProductID.ToString(), data.CurrencyCode, new List<string> { data.ErrorCodes ?? string.Empty });
-			Log.Store.PrintError("Checkout Order Failure: TransactionID={0}, ProductID={1}, CurrencyCode={2}, ErrorCodes={3}", data.TransactionID, data.ProductID, data.CurrencyCode, data.ErrorCodes);
-		}
+		Network.Get().ReportBlizzardCheckoutStatus(BlizzardCheckoutStatus.BLIZZARD_CHECKOUT_STATUS_COMPLETED_FAILED, data);
+		TelemetryManager.Client().SendBlizzardCheckoutPurchaseCompletedFailure(data.TransactionID, data.ProductID.ToString(), data.CurrencyCode, new List<string> { data.ErrorCodes ?? string.Empty });
+		Log.Store.PrintError("Checkout Order Failure: TransactionID={0}, ProductID={1}, CurrencyCode={2}, ErrorCodes={3}", data.TransactionID, data.ProductID, data.CurrencyCode, data.ErrorCodes);
+	}
 	}
 
 	public void HandleCommerceSubmitFailure()
@@ -3699,6 +3699,6 @@ public class StoreManager : IProductAvailabilityApi
 
 	public bool WillStoreDisplayNotice(NetCache.ProfileNotice.NoticeOrigin noticeOrigin, NetCache.ProfileNotice.NoticeType noticeType, long noticeOriginData)
 	{
-		return false;
-	}
+			return false;
+		}
 }
diff --git a/Assembly-CSharp/StorePackId.cs b/Assembly-CSharp/StorePackId.cs
index 6eb9268..2897a04 100644
--- a/Assembly-CSharp/StorePackId.cs
+++ b/Assembly-CSharp/StorePackId.cs
@@ -6,6 +6,20 @@ public struct StorePackId
 
 	public int Id;
 
+	public static bool operator ==(StorePackId a, StorePackId b)
+	{
+		if (a.Type == b.Type)
+		{
+			return a.Id == b.Id;
+		}
+		return false;
+	}
+
+	public static bool operator !=(StorePackId a, StorePackId b)
+	{
+		return !(a == b);
+	}
+
 	public override bool Equals(object obj)
 	{
 		if (((StorePackId)obj).Type == Type)
@@ -30,6 +44,6 @@ public struct StorePackId
 			}
 			return ProductType.PRODUCT_TYPE_HIDDEN_LICENSE;
 		}
-		return ProductType.PRODUCT_TYPE_UNKNOWN;
+			return ProductType.PRODUCT_TYPE_UNKNOWN;
+		}
 	}
-}
diff --git a/Assembly-CSharp/StorePurchaseAuth.cs b/Assembly-CSharp/StorePurchaseAuth.cs
index fda74e7..41bf340 100644
--- a/Assembly-CSharp/StorePurchaseAuth.cs
+++ b/Assembly-CSharp/StorePurchaseAuth.cs
@@ -6,9 +6,11 @@ using Blizzard.T5.Services;
 using Hearthstone.Store;
 using PegasusShared;
 using PegasusUtil;
+using Accessibility;
+using System;
 
 [CustomEditClass]
-public class StorePurchaseAuth : UIBPopup
+public class StorePurchaseAuth : UIBPopup, AccessibleUI
 {
 	public delegate void AckPurchaseResultListener(bool success, MoneyOrGTAPPTransaction moneyOrGTAPPTransaction);
 
@@ -98,6 +100,7 @@ public class StorePurchaseAuth : UIBPopup
 			}
 			Navigation.PushBlockBackingOut();
 			DoShowAnimation();
+			ReadPopup();
 		}
 	}
 
@@ -163,6 +166,8 @@ public class StorePurchaseAuth : UIBPopup
 
 	public override void Hide()
 	{
+		HideThis();
+
 		if (m_shown)
 		{
 			m_shown = false;
@@ -403,6 +408,8 @@ public class StorePurchaseAuth : UIBPopup
 		m_failHeadlineText.gameObject.SetActive(value: false);
 		m_failDetailsText.gameObject.SetActive(value: false);
 		m_spell.ActivateState(SpellStateType.ACTION);
+
+		ReadPurchaseSuccess();
 	}
 
 	private void ShowPurchaseFailure(MoneyOrGTAPPTransaction moneyOrGTAPPTransaction, string failDetails, bool showMiniSummary, Network.PurchaseErrorInfo.ErrorType error)
@@ -427,6 +434,8 @@ public class StorePurchaseAuth : UIBPopup
 		m_failHeadlineText.gameObject.SetActive(value: true);
 		m_failDetailsText.gameObject.SetActive(value: true);
 		m_spell.ActivateState(SpellStateType.DEATH);
+
+		ReadPurchaseFailure();
 	}
 
 	private void ShowMiniSummary()
@@ -439,4 +448,102 @@ public class StorePurchaseAuth : UIBPopup
 			m_root.UpdateSlices();
 		}
 	}
+
+	#region Accessibility
+
+	private enum State
+	{
+		LOADING,
+		TEXT_ONLY,
+		TEXT_AND_OK_BUTTON
+	};
+
+	private State m_curState;
+
+	private AccessibleMultilineText m_accessibleText;
+
+	private void ReadPopup()
+	{
+		if (!AccessibilityUtils.CanSeeShop())
+		{
+			return;
+		}
+
+		AccessibilityMgr.ShowUI(this);
+		m_accessibleText = new AccessibleMultilineText(this, m_waitingForAuthText.Text);
+		m_accessibleText.ReadAllLines();
+
+		m_curState = State.TEXT_ONLY;
+	}
+
+	private void ReadPurchaseSuccess()
+	{
+		m_accessibleText = new AccessibleMultilineText(this, m_successHeadlineText.Text, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+		m_accessibleText.ReadAllLines();
+
+		m_curState = State.TEXT_AND_OK_BUTTON;
+	}
+
+	private void ReadPurchaseFailure()
+	{
+		m_accessibleText = new AccessibleMultilineText(this, m_failHeadlineText.Text, m_failDetailsText.Text, AccessibleSpeech.PRESS_ENTER_TO_CONTINUE);
+		m_accessibleText.ReadAllLines();
+
+		m_curState = State.TEXT_AND_OK_BUTTON;
+	}
+
+	private void HideThis()
+	{
+		if (!AccessibilityUtils.CanSeeShop())
+		{
+			return;
+		}
+
+		AccessibilityMgr.HideUI(this);
+		Shop.Get()?.ProductPageController?.CurrentProductPage?.OnStorePurchaseAuthClosed(m_showingSuccess);
+
+		// Unblock interface since we're shortcutting a lot of stuff
+		StoreManager.Get()?.SetCanTapOutConfirmationUI(closeConfirmationUI: true);
+		StoreManager.Get()?.UnblockStoreInterface();
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (HearthstoneAccessConstants.DEV_MODE)
+		{
+			if (AccessibleKey.DEV_1.IsPressed())
+			{
+				ShowPurchaseSuccess(null, false);
+			}
+			else if (AccessibleKey.DEV_2.IsPressed())
+			{
+				ShowPurchaseFailure(null, "Failed for some reason", false, Network.PurchaseErrorInfo.ErrorType.UNKNOWN);
+			}
+		}
+
+		if (m_curState == State.TEXT_ONLY || m_curState == State.TEXT_AND_OK_BUTTON)
+		{
+			m_accessibleText?.HandleAccessibleInput();
+		}
+
+		if (m_curState == State.TEXT_AND_OK_BUTTON)
+		{
+			if (AccessibleKey.CONFIRM.IsPressed())
+			{
+				m_okButton.TriggerRelease();
+			}
+		}
+	}
+
+	public string GetAccessibleHelp()
+	{
+		if (m_curState == State.TEXT_AND_OK_BUTTON)
+		{
+			return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+		}
+
+		return "";
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/StoreQuantityPrompt.cs b/Assembly-CSharp/StoreQuantityPrompt.cs
index b364634..1f37699 100644
--- a/Assembly-CSharp/StoreQuantityPrompt.cs
+++ b/Assembly-CSharp/StoreQuantityPrompt.cs
@@ -1,5 +1,6 @@
 using Hearthstone.UI;
 using UnityEngine;
+using Accessibility;
 
 public class StoreQuantityPrompt : UIBPopup
 {
@@ -100,8 +101,8 @@ public class StoreQuantityPrompt : UIBPopup
 			UIStatus.Get().AddError(GameStrings.Get("GLUE_STORE_PACK_QUANTITY_WARN_MAX"));
 			break;
 		}
-		FireCancelEvent();
-	}
+			FireCancelEvent();
+		}
 
 	public void Cancel()
 	{
@@ -151,6 +152,9 @@ public class StoreQuantityPrompt : UIBPopup
 			m_touchScreenKeyboardType = 0
 		};
 		UniversalInputManager.Get().UseTextInput(parms);
+
+		AccessibilityMgr.AllowTextInput();
+		AccessibilityMgr.Output(null, m_instructionText.Text);
 	}
 
 	private void HideInput()
@@ -161,6 +165,9 @@ public class StoreQuantityPrompt : UIBPopup
 	private void OnInputUpdated(string input)
 	{
 		UpdateQuantityText(input);
+
+		// Quick hack while the input field is not accessible.
+		AccessibilityMgr.Output(null, input);
 	}
 
 	private void OnInputComplete(string input)
diff --git a/Assembly-CSharp/StringUtils.cs b/Assembly-CSharp/StringUtils.cs
index 39d4505..947739c 100644
--- a/Assembly-CSharp/StringUtils.cs
+++ b/Assembly-CSharp/StringUtils.cs
@@ -21,4 +21,14 @@ public static class StringUtils
 	{
 		return string.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;
 	}
+
+	public static bool Contains(this string str, string val, StringComparison comparison)
+	{
+		return str.IndexOf(val, comparison) >= 0;
+	}
+
+	public static bool Contains(this string s, char c)
+	{
+		return s.IndexOf(c) >= 0;
+	}
 }
diff --git a/Assembly-CSharp/TAG_CARDTYPE.cs b/Assembly-CSharp/TAG_CARDTYPE.cs
index d8fbf46..aaffd62 100644
--- a/Assembly-CSharp/TAG_CARDTYPE.cs
+++ b/Assembly-CSharp/TAG_CARDTYPE.cs
@@ -19,5 +19,6 @@ public enum TAG_CARDTYPE
 	LOCATION = 39,
 	BATTLEGROUND_QUEST_REWARD = 40,
 	BATTLEGROUND_ANOMALY = 43,
-	BATTLEGROUND_SPELL = 42
+	BATTLEGROUND_SPELL = 42,
+	EOE
 }
diff --git a/Assembly-CSharp/TAG_CLASS.cs b/Assembly-CSharp/TAG_CLASS.cs
index 25a920d..093b6c4 100644
--- a/Assembly-CSharp/TAG_CLASS.cs
+++ b/Assembly-CSharp/TAG_CLASS.cs
@@ -14,5 +14,6 @@ public enum TAG_CLASS
 	DREAM,
 	NEUTRAL,
 	WHIZBANG,
-	DEMONHUNTER
+	DEMONHUNTER,
+	EOE
 }
diff --git a/Assembly-CSharp/TAG_FACTION.cs b/Assembly-CSharp/TAG_FACTION.cs
index 95167c3..4d0a453 100644
--- a/Assembly-CSharp/TAG_FACTION.cs
+++ b/Assembly-CSharp/TAG_FACTION.cs
@@ -3,5 +3,6 @@ public enum TAG_FACTION
 	INVALID,
 	HORDE,
 	ALLIANCE,
-	NEUTRAL
+	NEUTRAL,
+	EOE // There are comparisons throughout the code which assume HORDE == 1 and ALLIANCE == 2 (see HonorManager.IsValdidQuestForAction / AccessibleCard.AddAvLinesForPlayer)
 }
diff --git a/Assembly-CSharp/TAG_PREMIUM.cs b/Assembly-CSharp/TAG_PREMIUM.cs
index 5d0b1a4..b290309 100644
--- a/Assembly-CSharp/TAG_PREMIUM.cs
+++ b/Assembly-CSharp/TAG_PREMIUM.cs
@@ -1,8 +1,10 @@
 public enum TAG_PREMIUM
 {
-	NORMAL,
-	GOLDEN,
-	DIAMOND,
-	SIGNATURE,
-	MAX
+    NORMAL,
+    GOLDEN,
+    DIAMOND,
+    SIGNATURE,
+    MAX,
+
+    EOE // AccessibleCollectibleCard depends on this for reading premium
 }
diff --git a/Assembly-CSharp/TAG_RARITY.cs b/Assembly-CSharp/TAG_RARITY.cs
index ab28cdd..ab9360c 100644
--- a/Assembly-CSharp/TAG_RARITY.cs
+++ b/Assembly-CSharp/TAG_RARITY.cs
@@ -5,5 +5,6 @@ public enum TAG_RARITY
 	FREE,
 	RARE,
 	EPIC,
-	LEGENDARY
+	LEGENDARY,
+	EOE
 }
diff --git a/Assembly-CSharp/TAG_STEP.cs b/Assembly-CSharp/TAG_STEP.cs
index f8fe27a..465dfb8 100644
--- a/Assembly-CSharp/TAG_STEP.cs
+++ b/Assembly-CSharp/TAG_STEP.cs
@@ -20,5 +20,6 @@ public enum TAG_STEP
 	MAIN_START_TRIGGERS,
 	MAIN_SET_ACTION_STEP_TYPE,
 	MAIN_PRE_ACTION,
-	MAIN_POST_ACTION
+	MAIN_POST_ACTION,
+	EOE
 }
diff --git a/Assembly-CSharp/TAG_ZONE.cs b/Assembly-CSharp/TAG_ZONE.cs
index 412e709..6f1d091 100644
--- a/Assembly-CSharp/TAG_ZONE.cs
+++ b/Assembly-CSharp/TAG_ZONE.cs
@@ -8,5 +8,6 @@ public enum TAG_ZONE
 	REMOVEDFROMGAME,
 	SETASIDE,
 	SECRET,
-	LETTUCE_ABILITY
+	LETTUCE_ABILITY,
+	EOE
 }
diff --git a/Assembly-CSharp/TB_BaconShop.cs b/Assembly-CSharp/TB_BaconShop.cs
index cc809e4..ca91cf3 100644
--- a/Assembly-CSharp/TB_BaconShop.cs
+++ b/Assembly-CSharp/TB_BaconShop.cs
@@ -10,6 +10,7 @@ using Blizzard.T5.Game.Spells.SuperSpells;
 using Hearthstone.Progression;
 using PegasusGame;
 using UnityEngine;
+using Accessibility;
 
 public class TB_BaconShop : MissionEntity
 {
@@ -230,12 +231,20 @@ public class TB_BaconShop : MissionEntity
 		};
 	}
 
+	#region Accessibility
+
+	internal static int GAME_PHASE_SHOP = 1;
+
+	internal static int GAME_PHASE_COMBAT = 2;
+
+	#endregion
+
 	public TB_BaconShop()
 	{
 		m_gameOptions.AddOptions(s_booleanOptions, s_stringOptions);
 		HistoryManager.Get().DisableHistory();
 		PlayerLeaderboardManager.Get().SetEnabled(enabled: true);
-		PlayerLeaderboardManager.Get().SetAllowFakePlayers(enabled: true);
+			PlayerLeaderboardManager.Get().SetAllowFakePlayers(enabled: true);
 		EndTurnButton.Get().SetDisabled(disabled: true);
 		SceneMgr.Get().RegisterSceneLoadedEvent(OnGameplaySceneLoaded);
 		InitializePhasePopup();
@@ -330,11 +339,11 @@ public class TB_BaconShop : MissionEntity
 		case 0:
 		{
 			List<TAG_RACE> availableRacesInBattlegroundsExcludingAmalgam = GameState.Get().GetAvailableRacesInBattlegroundsExcludingAmalgam();
-			headline = GameStrings.Get("GAMEPLAY_TOOLTIP_BACON_AVAILABLE_RACES_HEADLINE");
+				headline = GameStrings.Get("GAMEPLAY_TOOLTIP_BACON_AVAILABLE_RACES_HEADLINE");
 			string separator = GameStrings.Get("GAMEPLAY_SEPARATOR") + " ";
 			description = string.Join(separator, availableRacesInBattlegroundsExcludingAmalgam.ConvertAll((TAG_RACE race) => GameStrings.GetRaceNameBattlegrounds(race)));
-			return true;
-		}
+				return true;
+			}
 		case 1:
 		{
 			List<TAG_RACE> missingRacesInBattlegrounds = GameState.Get().GetMissingRacesInBattlegrounds();
@@ -369,8 +378,8 @@ public class TB_BaconShop : MissionEntity
 			{
 				return GetFriendlyDeckTooltipContent(ref headline, ref description, index - 3);
 			}
-			return false;
-		}
+		return false;
+	}
 	}
 
 	protected bool GetFriendlyDeckTooltipContent(ref string headline, ref string description, int index)
@@ -385,7 +394,7 @@ public class TB_BaconShop : MissionEntity
 			}
 			else
 			{
-				headline = GameStrings.Format("GAMEPLAY_TOOLTIP_BACON_TURN_HEADLINE", num);
+			headline = GameStrings.Format("GAMEPLAY_TOOLTIP_BACON_TURN_HEADLINE", num);
 			}
 			description = "";
 			return true;
@@ -429,32 +438,7 @@ public class TB_BaconShop : MissionEntity
 
 	public override string GetMulliganDetailText()
 	{
-		List<TAG_RACE> availableRacesInBattlegroundsExcludingAmalgam = GameState.Get().GetAvailableRacesInBattlegroundsExcludingAmalgam();
-		if (availableRacesInBattlegroundsExcludingAmalgam.Count == 0)
-		{
-			return null;
-		}
-		availableRacesInBattlegroundsExcludingAmalgam.Sort((TAG_RACE a, TAG_RACE b) => string.Compare(GameStrings.GetRaceNameBattlegrounds(a), GameStrings.GetRaceNameBattlegrounds(b), StringComparison.Ordinal));
-		_ = GameStrings.Get("GAMEPLAY_SEPARATOR") + " ";
-		string text = "";
-		int num = text.Length;
-		for (int i = 0; i < availableRacesInBattlegroundsExcludingAmalgam.Count; i++)
-		{
-			TAG_RACE tag = availableRacesInBattlegroundsExcludingAmalgam[i];
-			if (num > 20)
-			{
-				text += "\n";
-				num = 0;
-			}
-			string text2 = GameStrings.GetRaceNameBattlegrounds(tag);
-			if (i < availableRacesInBattlegroundsExcludingAmalgam.Count - 1)
-			{
-				text2 += ", ";
-			}
-			text += text2;
-			num += text2.Length;
-		}
-		return text;
+		return GetAvailableRacesText();
 	}
 
 	public override Vector3 NameBannerPosition(Player.Side side)
@@ -608,8 +592,8 @@ public class TB_BaconShop : MissionEntity
 	{
 		if (!GameState.Get().IsMulliganPhase() || CountPlayersFinishedMulligan() == CountPlayersInGame())
 		{
-			return true;
-		}
+		return true;
+	}
 		return false;
 	}
 
@@ -701,7 +685,7 @@ public class TB_BaconShop : MissionEntity
 		return null;
 	}
 
-	private int CountPlayersFinishedMulligan()
+	internal int CountPlayersFinishedMulligan()
 	{
 		int num = 0;
 		foreach (SharedPlayerInfo value in GameState.Get().GetPlayerInfoMap().Values)
@@ -714,7 +698,7 @@ public class TB_BaconShop : MissionEntity
 		return num;
 	}
 
-	private int CountPlayersInGame()
+	internal int CountPlayersInGame()
 	{
 		return GameState.Get().GetPlayerInfoMap().Values.Count;
 	}
@@ -927,21 +911,23 @@ public class TB_BaconShop : MissionEntity
 	{
 		if (missionEvent == 1)
 		{
-			m_gamePhase = 1;
+			m_gamePhase = GAME_PHASE_SHOP;
 			yield return OnShopPhase(expectStateChangeCallback: true);
 		}
 		if (missionEvent == 5)
 		{
-			m_gamePhase = 1;
+			m_gamePhase = GAME_PHASE_SHOP;
 			yield return OnShopPhase(expectStateChangeCallback: false);
 		}
 		if (missionEvent == 2)
 		{
-			m_gamePhase = 2;
+			m_gamePhase = GAME_PHASE_COMBAT;
 			yield return OnCombatPhase();
 		}
 		if (missionEvent == 3)
 		{
+			AccessibleGameplay.Get().OnFreezeOrUnfreezeEvent();
+
 			int tag = GetFreezeButtonCard().GetEntity().GetTag(GAME_TAG.TAG_SCRIPT_DATA_NUM_1);
 			int tag2 = GetFreezeButtonCard().GetEntity().GetTag(GAME_TAG.TAG_SCRIPT_DATA_NUM_2);
 			tag2--;
@@ -1286,7 +1272,7 @@ public class TB_BaconShop : MissionEntity
 		}
 		TimeScaleMgr.Get().SetGameTimeScale(1f);
 		AchievementManager.Get().UnpauseToastNotifications();
-		yield return ShowPopup("Shop", expectStateChangeCallback);
+		yield return ShowShopPopup(expectStateChangeCallback);
 		PlayerLeaderboardManager.Get().UpdateLayout();
 		UpdateNameDisplay();
 		ShowTechLevelDisplay(shown: true);
@@ -1340,7 +1326,7 @@ public class TB_BaconShop : MissionEntity
 			TeammatePingWheelManager.Get().SetPingWheelDisabled(disabled: true);
 		}
 		StopAllDuosTutorialPopups();
-		yield return ShowPopup("Combat", expectStateChangeCallback: true);
+		yield return ShowCombatPopup(expectStateChangeCallback: true);
 		GameEntity.Coroutines.StartCoroutine(WaitAndHideActiveSpeechBubble());
 		ShowTechLevelDisplay(shown: false);
 		UpdateNameDisplay();
@@ -1554,13 +1540,13 @@ public class TB_BaconShop : MissionEntity
 
 	public override string GetVictoryScreenBannerText()
 	{
-		int realTimePlayerLeaderboardPlace = GameState.Get().GetFriendlySidePlayer().GetHero()
-			.GetRealTimePlayerLeaderboardPlace();
+		int realTimePlayerLeaderboardPlace = GetPlace();
 		if (realTimePlayerLeaderboardPlace == 0)
 		{
 			return string.Empty;
 		}
-		return GameStrings.Get("GAMEPLAY_END_OF_GAME_PLACE_" + realTimePlayerLeaderboardPlace);
+
+		return GetPlaceString(realTimePlayerLeaderboardPlace);
 	}
 
 	public override string GetBestNameForPlayer(int playerId)
@@ -2533,4 +2519,91 @@ public class TB_BaconShop : MissionEntity
 			}
 		}
 	}
+
+	#region Accessibility
+
+	protected IEnumerator ShowShopPopup(bool expectStateChangeCallback)
+	{
+		var ret = ShowPopup("Shop", expectStateChangeCallback: expectStateChangeCallback);
+
+		if (ret != null)
+		{
+			AccessibleGameplay.Get().OnBattlegroundsShopPhasePopupShown();
+		}
+
+		return ret;
+	}
+
+	protected IEnumerator ShowCombatPopup(bool expectStateChangeCallback)
+	{
+		var ret = ShowPopup("Combat", expectStateChangeCallback: expectStateChangeCallback);
+
+		if (ret != null)
+		{
+			AccessibleGameplay.Get().OnBattlegroundsCombatPhasePopupShown();
+		}
+
+		return ret;
+	}
+
+	internal int GetCurPhase()
+	{
+		return m_gamePhase;
+	}
+
+	private int GetPlace()
+	{
+		return GameState.Get().GetFriendlySidePlayer().GetHero().GetRealTimePlayerLeaderboardPlace();
+	}
+
+	internal static string GetPlaceString(int place)
+	{
+		if (place == 0)
+		{
+			return "";
+		}
+
+		return GameStrings.Get("GAMEPLAY_END_OF_GAME_PLACE_" + place);
+	}
+
+	internal static string GetAvailableRacesText()
+	{
+		List<TAG_RACE> availableRacesInBattlegroundsExcludingAmalgam = GameState.Get().GetAvailableRacesInBattlegroundsExcludingAmalgam();
+		if (availableRacesInBattlegroundsExcludingAmalgam.Count == 0)
+		{
+			return null;
+		}
+		availableRacesInBattlegroundsExcludingAmalgam.Sort((TAG_RACE a, TAG_RACE b) => string.Compare(GameStrings.GetRaceNameBattlegrounds(a), GameStrings.GetRaceNameBattlegrounds(b), StringComparison.Ordinal));
+		_ = GameStrings.Get("GAMEPLAY_SEPARATOR") + " ";
+		string text = "";
+		int num = text.Length;
+		for (int i = 0; i < availableRacesInBattlegroundsExcludingAmalgam.Count; i++)
+		{
+			TAG_RACE tag = availableRacesInBattlegroundsExcludingAmalgam[i];
+			if (num > 20)
+			{
+				text += "\n";
+				num = 0;
+			}
+			string text2 = GameStrings.GetRaceNameBattlegrounds(tag);
+			if (i < availableRacesInBattlegroundsExcludingAmalgam.Count - 1)
+			{
+				text2 += ", ";
+			}
+			text += text2;
+			num += text2.Length;
+		}
+		return text;
+	}
+
+	#endregion
+
+	#region HSA Tutorial
+
+	protected string FormatBuyMinionsMessage()
+	{
+		return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGBUY_TUTORIAL_OVERRIDE, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/TB_BaconShop_Tutorial.cs b/Assembly-CSharp/TB_BaconShop_Tutorial.cs
index 20f0b12..3f25ce0 100644
--- a/Assembly-CSharp/TB_BaconShop_Tutorial.cs
+++ b/Assembly-CSharp/TB_BaconShop_Tutorial.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
@@ -206,7 +207,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 
 	protected override IEnumerator OnShopPhase(bool expectStateChangeCallback)
 	{
-		yield return ShowPopup("Shop", expectStateChangeCallback: false);
+		yield return ShowShopPopup(expectStateChangeCallback: false);
 		PlayerLeaderboardManager.Get().UpdateLayout();
 		GameState.Get().GetOpposingSidePlayer().UpdateDisplayInfo();
 		UpdateNameBanner();
@@ -220,7 +221,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 	{
 		HideShopTutorials();
 		BaconBoard.Get().OnBoardSkinChosen(1);
-		yield return ShowPopup("Combat", expectStateChangeCallback: false);
+		yield return ShowCombatPopup(expectStateChangeCallback: false);
 		ShowTechLevelDisplay(shown: false);
 		GameState.Get().GetOpposingSidePlayer().UpdateDisplayInfo();
 		UpdateNameBanner();
@@ -287,6 +288,8 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		switch (missionEvent)
 		{
 		case 3:
+			AccessibleGameplay.Get().OnFreezeOrUnfreezeEvent();
+
 			if (GameState.Get().GetGameEntity().GetTag(GAME_TAG.TURN) != 9)
 			{
 				SetInputEnableForFrozenButton(isEnabled: false);
@@ -309,7 +312,8 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			break;
 		case 11:
 			GameState.Get().SetBusy(busy: true);
-			CreateTutorialDialog(DRAGBUY_DIALOG_TUTORIAL_PREFAB, "GAMEPLAY_BACON_DRAGBUY_TITLE_TUTORIAL", "GAMEPLAY_BACON_DRAGBUY_BODY_TUTORIAL", "GAMEPLAY_BACON_CONFIRM_BUTTON_TUTORIAL", UserPressedDragBuyTutorial, new Vector2(0.5f, 0.5f));
+				var dragBuyBodyTutorialOverride = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGBUY_BODY_TUTORIAL_OVERRIDE, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM);
+			CreateTutorialDialog(DRAGBUY_DIALOG_TUTORIAL_PREFAB, "GAMEPLAY_BACON_DRAGBUY_TITLE_TUTORIAL", dragBuyBodyTutorialOverride, "GAMEPLAY_BACON_CONFIRM_BUTTON_TUTORIAL", UserPressedDragBuyTutorial, new Vector2(0.5f, 0.5f));
 			break;
 		case 12:
 			yield return new WaitForSeconds(1f);
@@ -325,8 +329,9 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			Card cardInOpposingPlay = GetCardInOpposingPlay("BG_CS2_065");
 			if (cardInOpposingPlay != null)
 			{
-				ShowDragBuyTutorial(cardInOpposingPlay, "GAMEPLAY_BACON_DRAGBUY_TUTORIAL");
-				GameEntity.Coroutines.StartCoroutine(ShowOrHideDragBuyTutorial("GAMEPLAY_BACON_DRAGBUY_TUTORIAL"));
+						var dragbuyTutorialOverride = FormatBuyMinionsMessage();
+				ShowDragBuyTutorial(cardInOpposingPlay, dragbuyTutorialOverride);
+				GameEntity.Coroutines.StartCoroutine(ShowOrHideDragBuyTutorial(dragbuyTutorialOverride));
 			}
 			break;
 		}
@@ -509,7 +514,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			yield return PlayBobLine(VO_DALA_BOSS_99h_Male_Human_AfterShopUpgrade_04);
 			yield return new WaitForSeconds(0.5f);
 			GameState.Get().SetBusy(busy: false);
-			ShowRefreshButtonTutorial("GAMEPLAY_BACON_REFRESH_UPGRADE_TUTORIAL");
+			ShowRefreshButtonTutorial();
 			SetInputEnableForRefreshButton(isEnabled: true);
 			break;
 		case 53:
@@ -551,7 +556,8 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			SetInputEnableForAllButtons(isEnabled: false);
 			SetInputEnableForFriendlyHandCards(isEnabled: false);
 			GameState.Get().SetBusy(busy: true);
-			CreateTutorialDialog(DRAGSELL_DIALOG_TUTORIAL_PREFAB, "GAMEPLAY_BACON_DRAGSELL_TITLE_TUTORIAL", "GAMEPLAY_BACON_DRAGSELL_BODY_TUTORIAL", "GAMEPLAY_BACON_CONFIRM_BUTTON_TUTORIAL", UserPressedDragSellTutorial, new Vector2(0f, 0.5f));
+				var dragsellBodyTutorialOverride = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGSELL_BODY_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM);
+			CreateTutorialDialog(DRAGSELL_DIALOG_TUTORIAL_PREFAB, "GAMEPLAY_BACON_DRAGSELL_TITLE_TUTORIAL", dragsellBodyTutorialOverride, "GAMEPLAY_BACON_CONFIRM_BUTTON_TUTORIAL", UserPressedDragSellTutorial, new Vector2(0f, 0.5f));
 			break;
 		case 63:
 			GameState.Get().SetBusy(busy: false);
@@ -595,6 +601,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			break;
 		case 70:
 			HideHandBounceArrow();
+				OutputReadTimeHelpNotification();
 			yield return PlayBobLine(VO_DALA_BOSS_99h_Male_Human_CombatWin_03);
 			break;
 		case 79:
@@ -780,6 +787,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		notification.artOverlay.GetMaterial().mainTextureOffset = materialOffset;
 		notification.m_ButtonStart.AddEventListener(UIEventType.RELEASE, delegate(UIEvent e)
 		{
+			notification.Hide();
 			if (buttonHandler != null)
 			{
 				buttonHandler(e);
@@ -789,6 +797,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		});
 		m_popupTutorialNotification.PlayBirth();
 		UniversalInputManager.Get().SetGameDialogActive(active: true);
+		notification.Show();
 		return notification;
 	}
 
@@ -805,6 +814,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 				NotificationManager.Get().DestroyNotification(notification, 0f);
 			}
 		}
+
+		// Accessibility F1
+		if (notification == m_curDisplayedNotification)
+		{
+			m_curDisplayedNotification = null;
+		}
 	}
 
 	protected void ShowDragBuyTutorial(Card card, string textID = "GAMEPLAY_BACON_PLAY_MINION_TUTORIAL", bool hideImmediately = false)
@@ -827,6 +842,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			m_dragBuyTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(textID));
 			m_dragBuyTutorialNotification.ShowPopUpArrow(direction);
 			m_dragBuyTutorialNotification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_dragBuyTutorialNotification;
 		}
 	}
 
@@ -873,6 +889,7 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			m_dragBuyTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(textID));
 			m_dragBuyTutorialNotification.ShowPopUpArrow(direction);
 			m_dragBuyTutorialNotification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_dragBuyTutorialNotification;
 		}
 	}
 
@@ -906,14 +923,16 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			Vector3 position = GameState.Get().GetOpposingSidePlayer().GetBattlefieldZone()
 				.transform.position;
 			position += new Vector3(0f, 0f, 2.25f);
-			string key = "GAMEPLAY_BACON_RECRUIT_REMINDER_TUTORIAL";
-			m_recruitReminderTutorialNofification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+			// string key = "GAMEPLAY_BACON_RECRUIT_REMINDER_TUTORIAL";
+			var msg = FormatBuyMinionsMessage();
+			m_recruitReminderTutorialNofification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), msg);
 			m_recruitReminderTutorialNofification.ShowPopUpArrow(Notification.PopUpArrowDirection.BottomThree);
 			m_recruitReminderTutorialNofification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_recruitReminderTutorialNofification;
 		}
 	}
 
-	protected void ShowRefreshButtonTutorial(string textID = "GAMEPLAY_BACON_REFRESH_TUTORIAL", bool hideImmediately = false)
+	protected void ShowRefreshButtonTutorial(bool hideImmediately = false)
 	{
 		List<Zone> list = ZoneMgr.Get().FindZonesForSide(Player.Side.FRIENDLY);
 		Zone zone = null;
@@ -924,11 +943,14 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 				zone = item;
 			}
 		}
+		var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_REFRESH_TUTORIAL_OVERRIDE, AccessibleKey.REFRESH_TAVERN, AccessibleKey.CONFIRM);
+
 		Vector3 position = zone.transform.position;
 		Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z - 2.25f) : new Vector3(position.x, position.y, position.z - 2.5f));
-		m_refreshButtonTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(textID));
+		m_refreshButtonTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 		m_refreshButtonTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Up);
 		m_refreshButtonTutorialNotification.PulseReminderEveryXSeconds(2f);
+		m_curDisplayedNotification = m_refreshButtonTutorialNotification;
 	}
 
 	protected void ShowTavernUpgradeButtonTutorial(bool hideImmediately = false)
@@ -944,10 +966,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		}
 		Vector3 position = zone.transform.position;
 		Vector3 position2 = new Vector3(position.x, position.y, position.z - 2.25f);
-		string key = "GAMEPLAY_BACON_MINION_UPGRADE_TAVERN_TUTORIAL";
-		m_upgradeTavernTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+		// string key = "GAMEPLAY_BACON_MINION_UPGRADE_TAVERN_TUTORIAL";
+		var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_MINION_UPGRADE_TAVERN_TUTORIAL_OVERRIDE, AccessibleKey.UPGRADE_TAVERN, AccessibleKey.CONFIRM);
+		m_upgradeTavernTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 		m_upgradeTavernTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Up);
 		m_upgradeTavernTutorialNotification.PulseReminderEveryXSeconds(2f);
+		m_curDisplayedNotification = m_upgradeTavernTutorialNotification;
 	}
 
 	protected void ShowMinionMoveTutorial()
@@ -957,10 +981,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		{
 			Vector3 position = leftMostMinionInFriendlyPlay.transform.position;
 			Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z + 2.5f) : new Vector3(position.x + 0.05f, position.y, position.z + 2.6f));
-			string key = "GAMEPLAY_BACON_MINION_MOVE_TUTORIAL";
-			m_minionMoveTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+			//string key = "GAMEPLAY_BACON_MINION_MOVE_TUTORIAL";
+			var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_MINION_MOVE_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.SPACE);
+			m_minionMoveTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 			m_minionMoveTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Down);
 			m_minionMoveTutorialNotification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_minionMoveTutorialNotification;
 		}
 	}
 
@@ -991,10 +1017,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			card.GetActor().SetActorState(ActorStateType.CARD_SELECTABLE);
 			Vector3 position = card.transform.position;
 			Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x - 3.2f, position.y, position.z) : new Vector3(position.x - 3.3f, position.y, position.z - 0f));
-			string key = "GAMEPLAY_BACON_DRAGSELL_TUTORIAL";
-			m_dragSellTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+			// string key = "GAMEPLAY_BACON_DRAGSELL_TUTORIAL";
+			var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_DRAGSELL_TUTORIAL_OVERRIDE, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM);
+			m_dragSellTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 			m_dragSellTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
 			m_dragSellTutorialNotification.PulseReminderEveryXSeconds(2f);
+			m_curDisplayedNotification = m_dragSellTutorialNotification;
 		}
 	}
 
@@ -1011,10 +1039,12 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		}
 		Vector3 position = zone.transform.position;
 		Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z - 2.1f) : new Vector3(position.x, position.y, position.z - 2.5f));
-		string key = "GAMEPLAY_BACON_FREEZE_TUTORIAL";
-		m_freezeTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get(key));
+		// string key = "GAMEPLAY_BACON_FREEZE_TUTORIAL";
+		var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_FREEZE_TUTORIAL_OVERRIDE, AccessibleKey.FREEZE_TAVERN, AccessibleKey.CONFIRM);
+		m_freezeTutorialNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), msg);
 		m_freezeTutorialNotification.ShowPopUpArrow(Notification.PopUpArrowDirection.Up);
 		m_freezeTutorialNotification.PulseReminderEveryXSeconds(2f);
+		m_curDisplayedNotification = m_freezeTutorialNotification;
 	}
 
 	protected IEnumerator ShowManaArrowWithText(string textID)
@@ -1034,7 +1064,9 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		}
 		m_manaNotifier = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), GameStrings.Get(textID));
 		m_manaNotifier.ShowPopUpArrow(direction);
+		m_curDisplayedNotification = m_manaNotifier;
 		yield return new WaitForSeconds(2.5f);
+		m_curDisplayedNotification = null;
 		if (m_manaNotifier != null)
 		{
 			iTween.PunchScale(m_manaNotifier.gameObject, iTween.Hash("amount", new Vector3(1f, 1f, 1f), "time", 1f));
@@ -1057,14 +1089,14 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 			Card mousedOverCard = InputManager.Get().GetMousedOverCard();
 			if (!(mousedOverCard != null) || mousedOverCard.GetEntity().GetZone() != TAG_ZONE.HAND)
 			{
-				Card card = cards[cards.Count - 1];
-				Vector3 position = card.transform.position;
-				Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z + 2f) : new Vector3(position.x - 0.08f, position.y + 0.2f, position.z + 1.2f));
-				m_handBounceArrow = NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, 0f, 0f));
-				m_handBounceArrow.transform.parent = card.transform;
-			}
+			Card card = cards[cards.Count - 1];
+			Vector3 position = card.transform.position;
+			Vector3 position2 = ((!UniversalInputManager.UsePhoneUI) ? new Vector3(position.x, position.y, position.z + 2f) : new Vector3(position.x - 0.08f, position.y + 0.2f, position.z + 1.2f));
+			m_handBounceArrow = NotificationManager.Get().CreateBouncingArrow(UserAttentionBlocker.NONE, position2, new Vector3(0f, 0f, 0f));
+			m_handBounceArrow.transform.parent = card.transform;
 		}
 	}
+	}
 
 	public override void NotifyOfCardMousedOver(Entity mousedOverEntity)
 	{
@@ -1132,4 +1164,30 @@ public class TB_BaconShop_Tutorial : TB_BaconShop
 		}
 		return null;
 	}
+
+	#region Accessibility
+
+	private Notification m_curDisplayedNotification;
+
+	private void OutputReadTimeHelpNotification()
+	{
+		var msg = LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_READ_TIME_REMAINING, AccessibleKey.END_TURN);
+		AccessibilityMgr.OutputNotification(msg);
+	}
+
+	internal string GetHelp()
+	{
+		if (m_curDisplayedNotification != null)
+		{
+			return m_curDisplayedNotification.speechUberText.Text;
+		}
+		else if (m_shouldShowHandBounceArrow)
+		{
+			return LocalizationUtils.Format(LocalizationKey.BATTLEGROUNDS_TUTORIAL_SUMMON_MINION_HELP, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.CONFIRM);
+		}
+
+		return "";
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/TavernBrawlDisplay.cs b/Assembly-CSharp/TavernBrawlDisplay.cs
index 9ee3675..c00068e 100644
--- a/Assembly-CSharp/TavernBrawlDisplay.cs
+++ b/Assembly-CSharp/TavernBrawlDisplay.cs
@@ -7,9 +7,10 @@ using Blizzard.T5.MaterialService.Extensions;
 using Hearthstone.DungeonCrawl;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 [CustomEditClass]
-public class TavernBrawlDisplay : MonoBehaviour
+public class TavernBrawlDisplay : MonoBehaviour, AccessibleScreen
 {
 	[CustomEditField(Sections = "Buttons")]
 	public UIBButton m_createDeckButton;
@@ -261,6 +262,8 @@ public class TavernBrawlDisplay : MonoBehaviour
 		}
 		RefreshStateBasedUI(animate: false);
 		RefreshDataBasedUI(m_wipeAnimStartDelay);
+
+		AccessibilityMgr.SetScreen(this);
 	}
 
 	private void OnDestroy()
@@ -299,7 +302,7 @@ public class TavernBrawlDisplay : MonoBehaviour
 			return;
 		}
 		UpdateRecordUI();
-		if (m_currentMission.brawlMode == TavernBrawlMode.TB_MODE_HEROIC && !m_firstTimeIntroductionPopupShowing && !Options.Get().GetBool(Option.HAS_SEEN_HEROIC_BRAWL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber("TavernBrawlDisplay.RefreshDataBasedUI:" + Option.HAS_SEEN_HEROIC_BRAWL))
+		if (m_currentMission.brawlMode == TavernBrawlMode.TB_MODE_HEROIC && !m_firstTimeIntroductionPopupShowing && !Options.Get().GetBool(Option.HAS_SEEN_HEROIC_BRAWL, defaultVal: false) && UserAttentionManager.CanShowAttentionGrabber(false, "TavernBrawlDisplay.RefreshDataBasedUI:" + Option.HAS_SEEN_HEROIC_BRAWL))
 		{
 			m_firstTimeIntroductionPopupShowing = true;
 			StartCoroutine(DoFirstTimeHeroicIntro());
@@ -458,9 +461,9 @@ public class TavernBrawlDisplay : MonoBehaviour
 			if (TavernBrawlManager.Get().HasValidDeckForCurrent())
 			{
 				if (TavernBrawlManager.Get().PlayerStatus == TavernBrawlStatus.TB_STATUS_ACTIVE && m_playButton != null)
-				{
-					m_playButton.Enable();
-				}
+					{
+						m_playButton.Enable();
+					}
 				if (m_editDeckHighlight != null)
 				{
 					m_editDeckHighlight.ChangeState(ActorStateType.HIGHLIGHT_OFF);
@@ -701,20 +704,20 @@ public class TavernBrawlDisplay : MonoBehaviour
 			{
 				AssetReference assetReference = new AssetReference(record.ScriptObject);
 				using AssetHandle<ScenarioData> assetHandle = AssetLoader.Get().LoadAsset<ScenarioData>(assetReference);
-				if (assetHandle == null)
-				{
-					Debug.LogErrorFormat("Pointing to {0} but unable to load.  Rebuilding RAD will fix.", assetReference.ToString());
-				}
-				else if (PlatformSettings.Screen == ScreenCategory.Phone)
-				{
-					text = assetHandle.Asset.m_Texture_Phone;
-					value.y = assetHandle.Asset.m_Texture_Phone_offsetY;
-				}
-				else
-				{
-					text = assetHandle.Asset.m_Texture;
+					if (assetHandle == null)
+					{
+						Debug.LogErrorFormat("Pointing to {0} but unable to load.  Rebuilding RAD will fix.", assetReference.ToString());
+					}
+					else if (PlatformSettings.Screen == ScreenCategory.Phone)
+					{
+						text = assetHandle.Asset.m_Texture_Phone;
+						value.y = assetHandle.Asset.m_Texture_Phone_offsetY;
+					}
+					else
+					{
+						text = assetHandle.Asset.m_Texture;
+					}
 				}
-			}
 			if (string.IsNullOrEmpty(text))
 			{
 				text = record.TbTexture;
@@ -753,17 +756,17 @@ public class TavernBrawlDisplay : MonoBehaviour
 	{
 		if (!DemoMgr.Get().IsExpoDemo())
 		{
-			string endingTimeText = TavernBrawlManager.Get().EndingTimeText;
-			if (endingTimeText == null)
-			{
-				CancelInvoke("UpdateTimeText");
-			}
-			else
-			{
-				m_chalkboardEndInfo.Text = endingTimeText;
-			}
+		string endingTimeText = TavernBrawlManager.Get().EndingTimeText;
+		if (endingTimeText == null)
+		{
+			CancelInvoke("UpdateTimeText");
+		}
+		else
+		{
+			m_chalkboardEndInfo.Text = endingTimeText;
 		}
 	}
+	}
 
 	private void UpdateRecordUI()
 	{
@@ -866,7 +869,7 @@ public class TavernBrawlDisplay : MonoBehaviour
 		{
 			return;
 		}
-		bool flag = UserAttentionManager.CanShowAttentionGrabber("TavernBrawlDisplay.Show");
+		bool flag = UserAttentionManager.CanShowAttentionGrabber(false, "TavernBrawlDisplay.Show");
 		int latestSeenTavernBrawlChalkboard = TavernBrawlManager.Get().LatestSeenTavernBrawlChalkboard;
 		if (latestSeenTavernBrawlChalkboard == 0)
 		{
@@ -1067,8 +1070,8 @@ public class TavernBrawlDisplay : MonoBehaviour
 		}
 		EnableBackButton(enable: false);
 		StoreManager.Get().HideStore(ShopType.TAVERN_BRAWL_STORE);
-		SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
-	}
+			SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
+		}
 
 	private void UpdateDeckUI(bool animate)
 	{
@@ -1275,6 +1278,8 @@ public class TavernBrawlDisplay : MonoBehaviour
 
 	private void CreateDeck()
 	{
+		m_isTransitioning = true;
+
 		PresenceMgr.Get().SetStatus(Global.PresenceStatus.TAVERN_BRAWL_DECKEDITOR);
 		CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
 		if (collectionManagerDisplay != null)
@@ -1483,20 +1488,20 @@ public class TavernBrawlDisplay : MonoBehaviour
 			{
 				num = ((HeroPickerDisplay.Get() != null) ? 1 : 0);
 				if (num == 0)
+			{
+				flag = AssetLoader.Get().InstantiatePrefab(GetHeroPickerAssetStr(m_currentMission.missionId), delegate(AssetReference name, GameObject go, object data)
 				{
-					flag = AssetLoader.Get().InstantiatePrefab(GetHeroPickerAssetStr(m_currentMission.missionId), delegate(AssetReference name, GameObject go, object data)
+					if (go == null)
 					{
-						if (go == null)
-						{
-							Debug.LogError("Failed to load hero picker.");
-						}
-						else
-						{
-							PresenceMgr.Get().SetStatus(Global.PresenceStatus.TAVERN_BRAWL_DECKEDITOR);
-							HideChalkboardFX();
-						}
-					});
-				}
+						Debug.LogError("Failed to load hero picker.");
+					}
+					else
+					{
+						PresenceMgr.Get().SetStatus(Global.PresenceStatus.TAVERN_BRAWL_DECKEDITOR);
+						HideChalkboardFX();
+					}
+				});
+			}
 			}
 			else
 			{
@@ -1604,6 +1609,8 @@ public class TavernBrawlDisplay : MonoBehaviour
 	{
 		if (response != AlertPopup.Response.CANCEL)
 		{
+			m_isTransitioning = true;
+
 			CollectionDeckTray.Get().DeleteEditingDeck();
 			CollectionManagerDisplay collectionManagerDisplay = CollectionManager.Get().GetCollectibleDisplay() as CollectionManagerDisplay;
 			if (collectionManagerDisplay != null)
@@ -1611,6 +1618,10 @@ public class TavernBrawlDisplay : MonoBehaviour
 				collectionManagerDisplay.OnDoneEditingDeck();
 			}
 		}
+		else
+		{
+			AccessibleCollectionManager.Get().OnDeleteDeckCanceled();
+		}
 	}
 
 	private void OnDeckCreated(long deckID, string name)
@@ -1619,6 +1630,8 @@ public class TavernBrawlDisplay : MonoBehaviour
 		if (collectionDeck != null && deckID == collectionDeck.ID)
 		{
 			SwitchToEditDeckMode(collectionDeck, isNewDeck: true);
+
+			m_isTransitioning = false;
 		}
 	}
 
@@ -1940,4 +1953,80 @@ public class TavernBrawlDisplay : MonoBehaviour
 	{
 		m_chalkboardFX.SetActive(value: false);
 	}
+
+	#region Accessibility
+
+	private enum State {MAIN_MENU, READING_DESCRIPTION}
+
+	private State m_curState;
+
+	private AccessibleMenu m_mainMenu;
+	private AccessibleMultilineText m_accessibleDescription;
+	private bool m_isTransitioning;
+
+	private void ReadScreen()
+	{
+		if (m_isTransitioning)
+		{
+			return;
+		}
+
+		m_accessibleDescription = new AccessibleMultilineText(this, m_chalkboardHeader.Text, m_chalkboardInfo.Text);
+		m_mainMenu = new AccessibleMenu(this, m_chalkboardHeader.Text, ExitScene);
+		m_mainMenu.AddOption(LocalizationUtils.Get(LocalizationKey.UI_SHOP_ITEM_READ_DESCRIPTION), ReadInfo);
+		if (m_playButton != null && m_playButton.isActiveAndEnabled && m_playButton.IsEnabled()) 
+		{
+			m_mainMenu.AddOption(m_playButton.m_newPlayButtonText.Text, m_playButton.TriggerRelease);
+		}
+		if (m_createDeckButton != null && m_createDeckButton.isActiveAndEnabled && m_createDeckButton.IsEnabled())
+		{
+			m_mainMenu.AddOption(m_createDeckButton.GetText(), m_createDeckButton.TriggerRelease);
+		}
+		if (m_editDeckButton != null && m_editDeckButton.isActiveAndEnabled && m_editDeckButton.IsEnabled())
+		{
+			m_mainMenu.AddOption(m_editDeckButton.GetText(), m_editDeckButton.TriggerRelease);
+		}
+
+		m_mainMenu.StartReading();
+		m_curState = State.MAIN_MENU;
+	}
+
+	private void ReadInfo()
+	{
+		m_accessibleDescription.ReadAllLines();
+		m_curState = State.READING_DESCRIPTION;
+	}
+
+
+	public void HandleInput()
+	{
+		switch (m_curState)
+		{
+			case State.MAIN_MENU:
+			m_mainMenu.HandleAccessibleInput();
+			break;
+			case State.READING_DESCRIPTION:
+			if (AccessibleKey.BACK.IsPressed())
+			{
+				ReadScreen();
+			}
+			else
+			{
+				m_accessibleDescription.HandleAccessibleInput();
+			}
+			break;
+		}
+
+	}
+
+	public string GetHelp()
+	{
+		throw new NotImplementedException();
+	}
+
+	public void OnGainedFocus()
+	{
+		ReadScreen();
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/TavernGuideInnerTray.cs b/Assembly-CSharp/TavernGuideInnerTray.cs
index 78d5a0b..471fadf 100644
--- a/Assembly-CSharp/TavernGuideInnerTray.cs
+++ b/Assembly-CSharp/TavernGuideInnerTray.cs
@@ -57,15 +57,7 @@ public class TavernGuideInnerTray : MonoBehaviour
 		}
 		else if (m_widget.GetDataModel<EventDataModel>()?.Payload is TavernGuideQuestSetDataModel tavernGuideQuestSetDataModel)
 		{
-			StartClaimSequence(TavernGuideManager.Get().GetRewardAchievementFromTavernGuideQuestId(tavernGuideQuestSetDataModel.ID));
-		}
-	}
-
-	private void StartClaimSequence(int achievementId)
-	{
-		if (achievementId != 0)
-		{
-			AchievementManager.Get().ClaimAchievementReward(achievementId);
+			TavernGuideTabDisplay.ClaimQuestSetReward(TavernGuideManager.Get().GetRewardAchievementFromTavernGuideQuestId(tavernGuideQuestSetDataModel.ID));
 		}
 	}
 
@@ -73,12 +65,7 @@ public class TavernGuideInnerTray : MonoBehaviour
 	{
 		if (m_widget.GetDataModel<EventDataModel>()?.Payload is TavernGuideQuestDataModel tavernGuideQuestDataModel)
 		{
-			string deepLink = tavernGuideQuestDataModel.Quest.DeepLink;
-			if (!string.IsNullOrEmpty(deepLink))
-			{
-				DeepLinkManager.ExecuteDeepLink(deepLink.Substring("hearthstone://".Length).Split('/').ToList()
-					.ToArray(), DeepLinkManager.DeepLinkSource.TAVERN_GUIDE, tavernGuideQuestDataModel.ID);
-			}
+			TavernGuideTabDisplay.ExecuteDeeplink(tavernGuideQuestDataModel);
 		}
 	}
 
diff --git a/Assembly-CSharp/TextUtils.cs b/Assembly-CSharp/TextUtils.cs
index b52640a..5097316 100644
--- a/Assembly-CSharp/TextUtils.cs
+++ b/Assembly-CSharp/TextUtils.cs
@@ -211,7 +211,7 @@ public static class TextUtils
 			{
 				continue;
 			}
-			int num7 = int.Parse(powersText.AsSpan(i, j - i));
+			int num7 = int.Parse(powersText.AsSpan(i, j - i).ToString());
 			switch (c)
 			{
 			case '$':
diff --git a/Assembly-CSharp/TooltipPanelManager.cs b/Assembly-CSharp/TooltipPanelManager.cs
index 996c180..3d79e8c 100644
--- a/Assembly-CSharp/TooltipPanelManager.cs
+++ b/Assembly-CSharp/TooltipPanelManager.cs
@@ -151,23 +151,23 @@ public class TooltipPanelManager : MonoBehaviour
 		{
 			return;
 		}
-		bool inHand = card.GetZone() is ZoneHand;
-		bool isHeroPower = card.GetEntity() != null && card.GetEntity().IsHeroPower();
-		bool isCoinBasedHeroBuddy = card.GetEntity() != null && card.GetEntity().IsCoinBasedHeroBuddy();
-		bool isLettuceAbility = card.GetEntity().IsLettuceAbility();
-		bool isMercenary = card.GetEntity().HasTag(GAME_TAG.LETTUCE_MERCENARY);
-		TooltipPanelCreationArgs args = new TooltipPanelCreationArgs
-		{
-			actorMeshRoot = actor.GetMeshRenderer().gameObject,
-			actorRoot = actor.gameObject,
-			card = card,
+			bool inHand = card.GetZone() is ZoneHand;
+			bool isHeroPower = card.GetEntity() != null && card.GetEntity().IsHeroPower();
+			bool isCoinBasedHeroBuddy = card.GetEntity() != null && card.GetEntity().IsCoinBasedHeroBuddy();
+			bool isLettuceAbility = card.GetEntity().IsLettuceAbility();
+			bool isMercenary = card.GetEntity().HasTag(GAME_TAG.LETTUCE_MERCENARY);
+			TooltipPanelCreationArgs args = new TooltipPanelCreationArgs
+			{
+				actorMeshRoot = actor.GetMeshRenderer().gameObject,
+				actorRoot = actor.gameObject,
+				card = card,
 			boneSource = boneSource,
-			inHand = inHand,
-			isHeroPower = isHeroPower,
-			isCoinBasedHeroBuddy = isCoinBasedHeroBuddy,
-			isLettuceAbility = isLettuceAbility,
-			isMercenary = isMercenary
-		};
+				inHand = inHand,
+				isHeroPower = isHeroPower,
+				isCoinBasedHeroBuddy = isCoinBasedHeroBuddy,
+				isLettuceAbility = isLettuceAbility,
+				isMercenary = isMercenary
+			};
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
@@ -181,8 +181,8 @@ public class TooltipPanelManager : MonoBehaviour
 				return;
 			}
 		}
-		PrintUnableToDisplayTooltipError("gameplay");
-	}
+			PrintUnableToDisplayTooltipError("gameplay");
+		}
 
 	public void UpdateKeywordHelp(Card card, Actor actor, TooltipBoneSource boneSource = TooltipBoneSource.TOP_RIGHT, float? overrideScale = null, Vector3? overrideOffset = null)
 	{
@@ -283,9 +283,9 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
-			}
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "gameplay_hand");
@@ -404,145 +404,145 @@ public class TooltipPanelManager : MonoBehaviour
 		case TooltipBoneSource.BOTTOM_RIGHT:
 		case TooltipBoneSource.BOTTOM_LEFT:
 		{
-			TooltipBoneLayout boneLayout = componentInChildren.GetRigForCurrentPlatform();
-			if (boneLayout == null || !boneLayout.HasAllBones())
-			{
+		TooltipBoneLayout boneLayout = componentInChildren.GetRigForCurrentPlatform();
+		if (boneLayout == null || !boneLayout.HasAllBones())
+		{
 				break;
-			}
+		}
 			bool showOnRight = args.boneSource == TooltipBoneSource.TOP_RIGHT || args.boneSource == TooltipBoneSource.BOTTOM_RIGHT;
-			GameObject topRowBone;
-			GameObject bottomRowBone;
+		GameObject topRowBone;
+		GameObject bottomRowBone;
 			if (showOnRight)
-			{
-				topRowBone = boneLayout.m_topRightTooltipBone;
-				bottomRowBone = boneLayout.m_bottomRightTooltipBone;
-			}
-			else
-			{
-				topRowBone = boneLayout.m_topLeftTooltipBone;
-				bottomRowBone = boneLayout.m_bottomLeftTooltipBone;
-			}
+		{
+			topRowBone = boneLayout.m_topRightTooltipBone;
+			bottomRowBone = boneLayout.m_bottomRightTooltipBone;
+		}
+		else
+		{
+			topRowBone = boneLayout.m_topLeftTooltipBone;
+			bottomRowBone = boneLayout.m_bottomLeftTooltipBone;
+		}
 			TooltipPanel curPanel = m_tooltipPanels[0];
 			while (curPanel != null && !curPanel.Destroyed && !curPanel.IsTextRendered())
-			{
-				await UniTask.Yield(PlayerLoopTiming.Update, token);
-			}
+		{
+			await UniTask.Yield(PlayerLoopTiming.Update, token);
+		}
 			if (curPanel == null || curPanel.gameObject == null || args.actorMeshRoot == null || curPanel.Destroyed)
-			{
+		{
 				break;
-			}
+		}
 			Vector3 selfUnitAnchor = new Vector3((!showOnRight) ? 1 : 0, 0f, 0f);
-			if (args.overrideOffset.HasValue)
-			{
+		if (args.overrideOffset.HasValue)
+		{
 				TransformUtil.SetPoint(curPanel, selfUnitAnchor, topRowBone, Vector3.zero, args.overrideOffset.Value);
-			}
-			else
-			{
+		}
+		else
+		{
 				TransformUtil.SetPoint(curPanel, selfUnitAnchor, topRowBone, Vector3.zero, Vector3.zero);
-			}
+		}
 			TooltipPanel lastTopRowPanel = curPanel;
-			if (m_tooltipPanels.Count < 2)
-			{
+		if (m_tooltipPanels.Count < 2)
+		{
 				break;
-			}
+		}
 			curPanel = m_tooltipPanels[1];
 			while (curPanel != null && !curPanel.Destroyed && !curPanel.IsTextRendered())
-			{
-				await UniTask.Yield(PlayerLoopTiming.Update, token);
-			}
+		{
+			await UniTask.Yield(PlayerLoopTiming.Update, token);
+		}
 			if (curPanel == null || curPanel.gameObject == null || args.actorMeshRoot == null || curPanel.Destroyed)
-			{
+		{
 				break;
-			}
+		}
 			Vector3 selfUnitAnchor2 = new Vector3((!showOnRight) ? 1 : 0, 0f, 1f);
-			if (args.overrideOffset.HasValue)
-			{
+		if (args.overrideOffset.HasValue)
+		{
 				TransformUtil.SetPoint(curPanel, selfUnitAnchor2, bottomRowBone, Vector3.zero, args.overrideOffset.Value);
-			}
-			else
-			{
+		}
+		else
+		{
 				TransformUtil.SetPoint(curPanel, selfUnitAnchor2, bottomRowBone, Vector3.zero, Vector3.zero);
-			}
+		}
 			TooltipPanel lastBottomRowPanel = curPanel;
 			TooltipPanel prevPanel = curPanel;
-			int panelsPerColumn = TooltipBones_ComputePanelsPerColumn_LettuceAbility();
-			if (panelsPerColumn <= 0)
+		int panelsPerColumn = TooltipBones_ComputePanelsPerColumn_LettuceAbility();
+		if (panelsPerColumn <= 0)
+		{
+			panelsPerColumn = 2;
+		}
+		int i = 2;
+		while (i < m_tooltipPanels.Count)
+		{
+				curPanel = m_tooltipPanels[i];
+				while (curPanel != null && !curPanel.Destroyed && !curPanel.IsTextRendered())
+			{
+				await UniTask.Yield(PlayerLoopTiming.Update, token);
+			}
+				if (curPanel == null || curPanel.gameObject == null || args.actorMeshRoot == null || curPanel.Destroyed)
 			{
-				panelsPerColumn = 2;
+				break;
 			}
-			int i = 2;
-			while (i < m_tooltipPanels.Count)
+			switch (i % panelsPerColumn)
 			{
-				curPanel = m_tooltipPanels[i];
-				while (curPanel != null && !curPanel.Destroyed && !curPanel.IsTextRendered())
+			case 0:
+			{
+				float x2 = prevPanel.gameObject.transform.localScale.x;
+				Vector3 zero2 = Vector3.zero;
+				Vector3 selfUnitAnchor5;
+				Vector3 relativeUnitAnchor3;
+					if (showOnRight)
 				{
-					await UniTask.Yield(PlayerLoopTiming.Update, token);
+					selfUnitAnchor5 = new Vector3(0f, 0f, 0f);
+					relativeUnitAnchor3 = new Vector3(1f, 0f, 0f);
+					zero2.x += boneLayout.m_manualHorizontalAdjustment * x2;
 				}
-				if (curPanel == null || curPanel.gameObject == null || args.actorMeshRoot == null || curPanel.Destroyed)
+				else
 				{
-					break;
+					selfUnitAnchor5 = new Vector3(1f, 0f, 0f);
+					relativeUnitAnchor3 = new Vector3(0f, 0f, 0f);
+					zero2.x -= boneLayout.m_manualHorizontalAdjustment * x2;
 				}
-				switch (i % panelsPerColumn)
-				{
-				case 0:
-				{
-					float x2 = prevPanel.gameObject.transform.localScale.x;
-					Vector3 zero2 = Vector3.zero;
-					Vector3 selfUnitAnchor5;
-					Vector3 relativeUnitAnchor3;
-					if (showOnRight)
-					{
-						selfUnitAnchor5 = new Vector3(0f, 0f, 0f);
-						relativeUnitAnchor3 = new Vector3(1f, 0f, 0f);
-						zero2.x += boneLayout.m_manualHorizontalAdjustment * x2;
-					}
-					else
-					{
-						selfUnitAnchor5 = new Vector3(1f, 0f, 0f);
-						relativeUnitAnchor3 = new Vector3(0f, 0f, 0f);
-						zero2.x -= boneLayout.m_manualHorizontalAdjustment * x2;
-					}
 					TransformUtil.SetPoint(curPanel, selfUnitAnchor5, lastTopRowPanel, relativeUnitAnchor3, zero2);
 					lastTopRowPanel = curPanel;
-					break;
+				break;
+			}
+			case 1:
+			{
+				float x = prevPanel.gameObject.transform.localScale.x;
+				Vector3 zero = Vector3.zero;
+				Vector3 selfUnitAnchor4;
+				Vector3 relativeUnitAnchor2;
+					if (showOnRight)
+				{
+					selfUnitAnchor4 = new Vector3(0f, 0f, 1f);
+					relativeUnitAnchor2 = new Vector3(1f, 0f, 1f);
+					zero.x += boneLayout.m_manualHorizontalAdjustment * x;
 				}
-				case 1:
+				else
 				{
-					float x = prevPanel.gameObject.transform.localScale.x;
-					Vector3 zero = Vector3.zero;
-					Vector3 selfUnitAnchor4;
-					Vector3 relativeUnitAnchor2;
-					if (showOnRight)
-					{
-						selfUnitAnchor4 = new Vector3(0f, 0f, 1f);
-						relativeUnitAnchor2 = new Vector3(1f, 0f, 1f);
-						zero.x += boneLayout.m_manualHorizontalAdjustment * x;
-					}
-					else
-					{
-						selfUnitAnchor4 = new Vector3(1f, 0f, 1f);
-						relativeUnitAnchor2 = new Vector3(0f, 0f, 1f);
-						zero.x -= boneLayout.m_manualHorizontalAdjustment * x;
-					}
+					selfUnitAnchor4 = new Vector3(1f, 0f, 1f);
+					relativeUnitAnchor2 = new Vector3(0f, 0f, 1f);
+					zero.x -= boneLayout.m_manualHorizontalAdjustment * x;
+				}
 					TransformUtil.SetPoint(curPanel, selfUnitAnchor4, lastBottomRowPanel, relativeUnitAnchor2, zero);
 					lastBottomRowPanel = curPanel;
-					break;
-				}
-				default:
-				{
-					float z = prevPanel.gameObject.transform.localScale.z;
-					Vector3 selfUnitAnchor3 = new Vector3(0f, 0f, 1f);
-					Vector3 relativeUnitAnchor = new Vector3(0f, 0f, 0f);
-					float num = boneLayout.m_manualVerticalAdjustment * z;
-					Vector3 offset = new Vector3(0f, 0f, 0f - num);
+				break;
+			}
+			default:
+			{
+				float z = prevPanel.gameObject.transform.localScale.z;
+				Vector3 selfUnitAnchor3 = new Vector3(0f, 0f, 1f);
+				Vector3 relativeUnitAnchor = new Vector3(0f, 0f, 0f);
+				float num = boneLayout.m_manualVerticalAdjustment * z;
+				Vector3 offset = new Vector3(0f, 0f, 0f - num);
 					TransformUtil.SetPoint(curPanel, selfUnitAnchor3, prevPanel, relativeUnitAnchor, offset);
-					break;
-				}
-				}
-				prevPanel = curPanel;
-				int num2 = i + 1;
-				i = num2;
+				break;
+			}
 			}
+				prevPanel = curPanel;
+			int num2 = i + 1;
+			i = num2;
+		}
 			break;
 		}
 		}
@@ -562,7 +562,7 @@ public class TooltipPanelManager : MonoBehaviour
 		if (boneSource == TooltipBoneSource.BOTTOM_MIDDLE_GOING_LEFT || boneSource == TooltipBoneSource.BOTTOM_MIDDLE_GOING_RIGHT)
 		{
 			num--;
-		}
+			}
 		return num;
 	}
 
@@ -587,12 +587,12 @@ public class TooltipPanelManager : MonoBehaviour
 		switch (args.boneSource)
 		{
 		case TooltipBoneSource.BOTTOM_RIGHT:
-			bone = boneLayout.m_bottomRightTooltipBone;
-			currPanelCorner = new Vector3(0f, 0f, 0f);
+				bone = boneLayout.m_bottomRightTooltipBone;
+				currPanelCorner = new Vector3(0f, 0f, 0f);
 			break;
 		case TooltipBoneSource.BOTTOM_LEFT:
-			bone = boneLayout.m_bottomLeftTooltipBone;
-			currPanelCorner = new Vector3(1f, 0f, 0f);
+				bone = boneLayout.m_bottomLeftTooltipBone;
+				currPanelCorner = new Vector3(1f, 0f, 0f);
 			break;
 		case TooltipBoneSource.TOP_RIGHT:
 			bone = boneLayout.m_topRightTooltipBone;
@@ -657,14 +657,14 @@ public class TooltipPanelManager : MonoBehaviour
 				switch (args.boneSource)
 				{
 				case TooltipBoneSource.BOTTOM_RIGHT:
-					currPanelCorner = new Vector3(0f, 0f, 0f);
-					relativeUnitAnchor = new Vector3(1f, 0f, 0f);
-					zero.x += boneLayout.m_manualHorizontalAdjustment * x;
+						currPanelCorner = new Vector3(0f, 0f, 0f);
+						relativeUnitAnchor = new Vector3(1f, 0f, 0f);
+						zero.x += boneLayout.m_manualHorizontalAdjustment * x;
 					break;
 				case TooltipBoneSource.BOTTOM_LEFT:
-					currPanelCorner = new Vector3(1f, 0f, 0f);
-					relativeUnitAnchor = new Vector3(0f, 0f, 0f);
-					zero.x -= boneLayout.m_manualHorizontalAdjustment * x;
+						currPanelCorner = new Vector3(1f, 0f, 0f);
+						relativeUnitAnchor = new Vector3(0f, 0f, 0f);
+						zero.x -= boneLayout.m_manualHorizontalAdjustment * x;
 					break;
 				case TooltipBoneSource.TOP_RIGHT:
 				case TooltipBoneSource.BOTTOM_MIDDLE_GOING_RIGHT:
@@ -696,7 +696,7 @@ public class TooltipPanelManager : MonoBehaviour
 				else
 				{
 					TransformUtil.SetPoint(curPanel.gameObject, new Vector3(0f, 0f, 1f), prevPanel.gameObject, Vector3.zero, zero);
-				}
+			}
 			}
 			prevPanel = curPanel;
 			int num = i + 1;
@@ -751,17 +751,17 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "history");
 				return;
 			}
 		}
-		PrintUnableToDisplayTooltipError("history");
+			PrintUnableToDisplayTooltipError("history");
 	}
 
 	private async UniTaskVoid PositionPanelsForHistory(Actor actor, UberText createdByText, CancellationToken token)
@@ -849,17 +849,17 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "collection manager");
 				return;
 			}
 		}
-		PrintUnableToDisplayTooltipError("collection manager");
+			PrintUnableToDisplayTooltipError("collection manager");
 	}
 
 	public void UpdateTooltipForBigCard(EntityDef entityDef, Actor actor, Orientation orientation)
@@ -890,17 +890,17 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "signature");
 				return;
 			}
 		}
-		PrintUnableToDisplayTooltipError("signature");
+			PrintUnableToDisplayTooltipError("signature");
 	}
 
 	public void UpdateSignatureTooltipAtCustomTransform(EntityDef entityDef, Actor actor, Transform customTransform)
@@ -964,8 +964,8 @@ public class TooltipPanelManager : MonoBehaviour
 			}
 			else if (GameUtils.IsCardGameplayEventEverActive(entityDef))
 			{
-				headline = GameStrings.Get("GLUE_GHOST_CARD_NOT_VALID_TITLE");
-				description = GameStrings.Get("GLUE_GHOST_CARD_NOT_VALID_DESCRIPTION" + text);
+			headline = GameStrings.Get("GLUE_GHOST_CARD_NOT_VALID_TITLE");
+			description = GameStrings.Get("GLUE_GHOST_CARD_NOT_VALID_DESCRIPTION" + text);
 			}
 			else
 			{
@@ -993,17 +993,17 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "collection manager");
 				return;
 			}
 		}
-		PrintUnableToDisplayTooltipError("collection manager");
+			PrintUnableToDisplayTooltipError("collection manager");
 	}
 
 	public void UpdateKeywordHelpForDeckHelper(EntityDef entityDef, Actor actor, int cardChoice = 0)
@@ -1020,18 +1020,18 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "deck helper");
 				return;
 			}
 		}
-		PrintUnableToDisplayTooltipError("deck helper");
-	}
+			PrintUnableToDisplayTooltipError("deck helper");
+		}
 
 	public void UpdateKeywordHelpForAdventure(EntityDef entityDef, Actor actor)
 	{
@@ -1047,17 +1047,17 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "adventure");
 				return;
 			}
 		}
-		PrintUnableToDisplayTooltipError("adventure");
+			PrintUnableToDisplayTooltipError("adventure");
 	}
 
 	public void UpdateKeywordHelpForForge(EntityDef entityDef, Actor actor, TooltipBoneSource tooltipBoneSource)
@@ -1074,18 +1074,18 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "arena");
 				return;
 			}
 		}
-		PrintUnableToDisplayTooltipError("arena");
-	}
+			PrintUnableToDisplayTooltipError("arena");
+		}
 
 	public void UpdateKeywordHelpForPackOpening(EntityDef entityDef, Actor actor, TooltipBoneSource tooltipBoneSource, bool useMassPackOpeningPhoneScale = false)
 	{
@@ -1101,18 +1101,18 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
-			{
+		{
 				PrintUncaughtTooltipException(e, "pack opening");
 				return;
-			}
-		}
-		PrintUnableToDisplayTooltipError("pack opening");
 	}
+	}
+			PrintUnableToDisplayTooltipError("pack opening");
+		}
 
 	public void UpdateKeywordHelpForDiscover(Entity entity, Actor actor, TooltipBoneSource boneSource)
 	{
@@ -1143,18 +1143,18 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "discover");
 				return;
 			}
 		}
-		PrintUnableToDisplayTooltipError("discover");
-	}
+			PrintUnableToDisplayTooltipError("discover");
+		}
 
 	public void UpdateKeywordHelpForSubOptions(Entity entity, Actor actor, TooltipBoneSource boneSource)
 	{
@@ -1171,11 +1171,11 @@ public class TooltipPanelManager : MonoBehaviour
 		PrepareToUpdateKeywordHelp(actor);
 		if (GameState.Get() != null && GameState.Get().GetGameEntity() != null)
 		{
-			string[] array = GameState.Get().GetGameEntity().NotifyOfKeywordHelpPanelDisplay(entity);
+		string[] array = GameState.Get().GetGameEntity().NotifyOfKeywordHelpPanelDisplay(entity);
 			if (array != null && array.Length >= 2 && array[0] != null && array[1] != null)
-			{
-				SetupTooltipPanel(array[0], array[1]);
-			}
+		{
+			SetupTooltipPanel(array[0], array[1]);
+		}
 		}
 		GetDesiredEntityBaseForEntity(entity, isHistoryTile: false, out var _, out var _);
 		if (entity.HasTag(GAME_TAG.LITERALLY_UNPLAYABLE))
@@ -1199,18 +1199,18 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
 			{
 				PrintUncaughtTooltipException(e, "suboptions");
 				return;
-			}
-		}
-		PrintUnableToDisplayTooltipError("suboptions");
 	}
+	}
+			PrintUnableToDisplayTooltipError("suboptions");
+		}
 
 	private MulliganDisplay_RelativeHandPosition Mulligan_GetRelativePositionOfCardInHand(Entity ent)
 	{
@@ -1273,18 +1273,18 @@ public class TooltipPanelManager : MonoBehaviour
 		if (CanUseBonesForPlacingTooltips(args))
 		{
 			try
-			{
-				PositionPanelsWithBones(args, m_panelTokenSource.Token);
+		{
+			PositionPanelsWithBones(args, m_panelTokenSource.Token);
 				return;
-			}
+		}
 			catch (Exception e)
-			{
+		{
 				PrintUncaughtTooltipException(e, "mulligan");
 				return;
-			}
-		}
-		PrintUnableToDisplayTooltipError("mulligan");
 	}
+	}
+			PrintUnableToDisplayTooltipError("mulligan");
+		}
 
 	private void PrepareToUpdateKeywordHelp(Actor actor)
 	{
@@ -1441,14 +1441,14 @@ public class TooltipPanelManager : MonoBehaviour
 			switch (gAME_TAG)
 			{
 			case GAME_TAG.SECRET:
-				if (mainEntityBaseForKeyword.GetZone() != TAG_ZONE.SECRET || !mainEntityBaseForKeyword.IsSecret())
-				{
+		if (mainEntityBaseForKeyword.GetZone() != TAG_ZONE.SECRET || !mainEntityBaseForKeyword.IsSecret())
+		{
 					SetupKeywordPanelIfNecessary(entityInfo, gAME_TAG);
-				}
+		}
 				break;
 			case GAME_TAG.AI_MUST_PLAY:
-				if (mainEntityBaseForKeyword.IsHeroPower())
-				{
+		if (mainEntityBaseForKeyword.IsHeroPower())
+		{
 					SetupKeywordPanelIfNecessary(entityInfo, gAME_TAG);
 				}
 				break;
@@ -1458,9 +1458,9 @@ public class TooltipPanelManager : MonoBehaviour
 					return;
 				}
 				break;
-			}
 		}
 	}
+	}
 
 	private void GetEntityTagValuesForKeywordPanel(EntityBase entityInfo, GAME_TAG tag, out int tagValue, out int referenceTagValue)
 	{
@@ -1570,38 +1570,38 @@ public class TooltipPanelManager : MonoBehaviour
 			switch (mode)
 			{
 			case SceneMgr.Mode.GAMEPLAY:
+		{
+			int entityId = entityBase.GetEntityId();
+			Entity entity = GameState.Get().GetEntity(entityId);
+			if (entity == null)
 			{
-				int entityId = entityBase.GetEntityId();
-				Entity entity = GameState.Get().GetEntity(entityId);
-				if (entity == null)
-				{
-					SetupKeywordPanel(tag);
-					return false;
-				}
-				entity.GetCard();
-				List<int> subCardIDs = entity.GetSubCardIDs();
-				Entity[] array = new Entity[subCardIDs.Count];
-				for (int i = 0; i < subCardIDs.Count; i++)
-				{
-					array[i] = GameState.Get().GetEntity(subCardIDs[i]);
-				}
-				Entity[] array2 = array;
-				foreach (Entity entity2 in array2)
-				{
-					string headline = entity2.GetName();
-					string description = UberText.RemoveMarkupAndCollapseWhitespaces(entity2.GetCardTextInHand(), replaceCarriageReturnWithBreakHint: true, preserveBreakHint: true);
-					SetupTooltipPanel(headline, description).SetLockVisibility(entity2.HasTag(GAME_TAG.LITERALLY_UNPLAYABLE));
-				}
 				SetupKeywordPanel(tag);
-				return true;
+				return false;
+			}
+				entity.GetCard();
+			List<int> subCardIDs = entity.GetSubCardIDs();
+			Entity[] array = new Entity[subCardIDs.Count];
+			for (int i = 0; i < subCardIDs.Count; i++)
+			{
+				array[i] = GameState.Get().GetEntity(subCardIDs[i]);
+			}
+			Entity[] array2 = array;
+			foreach (Entity entity2 in array2)
+			{
+				string headline = entity2.GetName();
+				string description = UberText.RemoveMarkupAndCollapseWhitespaces(entity2.GetCardTextInHand(), replaceCarriageReturnWithBreakHint: true, preserveBreakHint: true);
+				SetupTooltipPanel(headline, description).SetLockVisibility(entity2.HasTag(GAME_TAG.LITERALLY_UNPLAYABLE));
 			}
+			SetupKeywordPanel(tag);
+			return true;
+		}
 			case SceneMgr.Mode.COLLECTIONMANAGER:
 			case SceneMgr.Mode.PACKOPENING:
 			case SceneMgr.Mode.DRAFT:
-				SetupTooltipPanelForTitansFromRelatedCards(entityBase);
-				SetupKeywordPanel(tag);
-				return true;
-			}
+			SetupTooltipPanelForTitansFromRelatedCards(entityBase);
+			SetupKeywordPanel(tag);
+			return true;
+		}
 		}
 		if (tagValue != 0 && tag == GAME_TAG.EXCAVATE && mode == SceneMgr.Mode.GAMEPLAY)
 		{
@@ -1635,73 +1635,73 @@ public class TooltipPanelManager : MonoBehaviour
 			if (flag)
 			{
 				if (tag == GAME_TAG.EMPOWER)
+			{
+				if (entityBase.GetClass() != TAG_CLASS.NEUTRAL)
 				{
-					if (entityBase.GetClass() != TAG_CLASS.NEUTRAL)
-					{
-						tag = GetEmpowerTagByClass(entityBase.GetClass());
-					}
-					if (CollectionManager.Get().IsInEditMode())
+					tag = GetEmpowerTagByClass(entityBase.GetClass());
+				}
+				if (CollectionManager.Get().IsInEditMode())
+				{
+					CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
+					string galakrondCardIdByClass = GameUtils.GetGalakrondCardIdByClass(editedDeck.GetClass());
+					if (editedDeck.GetCardIdCount(galakrondCardIdByClass) > 0)
 					{
-						CollectionDeck editedDeck = CollectionManager.Get().GetEditedDeck();
-						string galakrondCardIdByClass = GameUtils.GetGalakrondCardIdByClass(editedDeck.GetClass());
-						if (editedDeck.GetCardIdCount(galakrondCardIdByClass) > 0)
-						{
-							tag = GetEmpowerTagByClass(editedDeck.GetClass());
-						}
+						tag = GetEmpowerTagByClass(editedDeck.GetClass());
 					}
 				}
-				SetupCollectionKeywordPanel(tag);
-				return true;
 			}
-			if (tagValue != 0 && GameStrings.HasKeywordText(tag))
-			{
+			SetupCollectionKeywordPanel(tag);
+			return true;
+		}
+		if (tagValue != 0 && GameStrings.HasKeywordText(tag))
+		{
 				GAME_TAG[] array3 = spellpowerTags;
 				foreach (GAME_TAG gAME_TAG in array3)
+			{
+				if (tag == gAME_TAG)
 				{
-					if (tag == gAME_TAG)
-					{
 						int num6 = entityBase.GetTag(tag);
-						string empty = string.Empty;
+					string empty = string.Empty;
 						empty = ((num6 <= 0) ? GameStrings.Get(GameStrings.GetRefKeywordTextKey(tag)) : GameStrings.Format(GameStrings.GetKeywordTextKey(tag), num6));
 						string keywordName3 = GameStrings.GetKeywordName(tag);
 						SetupTooltipPanel(keywordName3, empty);
-						return true;
-					}
-				}
-				if (tag == GAME_TAG.WINDFURY && tagValue > 1)
-				{
-					return false;
+					return true;
 				}
-				if (GameMgr.Get() != null && GameMgr.Get().IsBattlegrounds())
-				{
+			}
+			if (tag == GAME_TAG.WINDFURY && tagValue > 1)
+			{
+				return false;
+			}
+			if (GameMgr.Get() != null && GameMgr.Get().IsBattlegrounds())
+			{
 					if (tag == GAME_TAG.FROZEN)
-					{
-						SetupKeywordPanel(GAME_TAG.BACON_FREEZE_TOOLTIP);
-						return true;
+				{
+					SetupKeywordPanel(GAME_TAG.BACON_FREEZE_TOOLTIP);
+					return true;
 					}
 					if (tag == GAME_TAG.STEALTH)
 					{
-						SetupKeywordPanel(GAME_TAG.BACON_STEALTH_TOOLTIP);
-						return true;
+					SetupKeywordPanel(GAME_TAG.BACON_STEALTH_TOOLTIP);
+					return true;
 					}
 					if (tag == GAME_TAG.QUEST)
 					{
-						SetupKeywordPanel(GAME_TAG.BACON_QUEST_TOOLTIP);
-						return true;
+					SetupKeywordPanel(GAME_TAG.BACON_QUEST_TOOLTIP);
+					return true;
 					}
 					if (tag == GAME_TAG.REBORN)
 					{
-						SetupKeywordPanel(GAME_TAG.BACON_REBORN_TOOLTIP);
-						return true;
-					}
+					SetupKeywordPanel(GAME_TAG.BACON_REBORN_TOOLTIP);
+					return true;
 				}
+			}
 				if (tag == GAME_TAG.SHIFTING_MINION || tag == GAME_TAG.SHIFTING_WEAPON || tag == GAME_TAG.SHIFTING_SPELL || tag == GAME_TAG.SHIFTING)
-				{
+			{
 					int num7 = entityBase.GetTag(GAME_TAG.TRANSFORMED_FROM_CARD);
 					if (num7 == 0)
-					{
-						return false;
-					}
+				{
+					return false;
+				}
 					EntityDef entityDef = DefLoader.Get().GetEntityDef(num7);
 					string text7 = GameStrings.Get(GameStrings.GetKeywordTextKey(tag));
 					if (num7 == 102614)
@@ -1717,8 +1717,8 @@ public class TooltipPanelManager : MonoBehaviour
 						text7 = text7 + " " + GameStrings.Get("GLOBAL_KEYWORD_SHIFTING_ADDS_POISONOUS_TEXT");
 					}
 					SetupTooltipPanel(entityDef.GetName(), text7);
-					return true;
-				}
+				return true;
+			}
 				if (tag == GAME_TAG.AI_MUST_PLAY && SceneMgr.Get().GetMode() == SceneMgr.Mode.GAMEPLAY)
 				{
 					int controllerId3 = entityBase.GetControllerId();
@@ -1728,28 +1728,28 @@ public class TooltipPanelManager : MonoBehaviour
 						return false;
 					}
 				}
-				if (tag == GAME_TAG.EMPOWER && SceneMgr.Get().GetMode() == SceneMgr.Mode.GAMEPLAY)
-				{
+			if (tag == GAME_TAG.EMPOWER && SceneMgr.Get().GetMode() == SceneMgr.Mode.GAMEPLAY)
+			{
 					int controllerId4 = entityBase.GetControllerId();
 					Player player4 = GameState.Get().GetPlayer(controllerId4);
 					if (player4 != null && player4.HasTag(GAME_TAG.PROXY_GALAKROND))
-					{
+				{
 						Entity entity3 = GameState.Get().GetEntity(player4.GetTag(GAME_TAG.PROXY_GALAKROND));
 						tag = GetEmpowerTagByClass(entity3.GetClass());
-					}
 				}
+			}
 				if (record.IsCollectionOnly)
 				{
 					return true;
 				}
-				SetupKeywordPanel(tag);
-				return true;
-			}
-			if (referenceTagValue != 0 && GameStrings.HasRefKeywordText(tag))
-			{
-				SetupKeywordRefPanel(tag);
-				return true;
-			}
+			SetupKeywordPanel(tag);
+			return true;
+		}
+		if (referenceTagValue != 0 && GameStrings.HasRefKeywordText(tag))
+		{
+			SetupKeywordRefPanel(tag);
+			return true;
+		}
 			SetupKeywordPanel(tag);
 			return true;
 		}
@@ -1783,7 +1783,7 @@ public class TooltipPanelManager : MonoBehaviour
 	}
 
 	private TooltipPanel SetupTooltipPanel(string headline, string description, TooltipPanel panel)
-	{
+		{
 		return SetupTooltipPanel(headline, description, panel, 0.4f);
 	}
 
@@ -1793,11 +1793,11 @@ public class TooltipPanelManager : MonoBehaviour
 		{
 			return panel;
 		}
-		panel.Reset();
-		panel.Initialize(headline, description);
-		panel.SetScale(m_scaleToUse);
-		m_tooltipPanels.Add(panel);
-		FadeInPanel(panel, delayAmount);
+			panel.Reset();
+			panel.Initialize(headline, description);
+			panel.SetScale(m_scaleToUse);
+			m_tooltipPanels.Add(panel);
+			FadeInPanel(panel, delayAmount);
 		return panel;
 	}
 
@@ -1826,10 +1826,10 @@ public class TooltipPanelManager : MonoBehaviour
 		{
 			if (!(tooltipPanel is SignatureTooltipPanel))
 			{
-				RenderUtils.SetAlpha(tooltipPanel.gameObject, newValue, includeInactive: true);
-			}
+			RenderUtils.SetAlpha(tooltipPanel.gameObject, newValue, includeInactive: true);
 		}
 	}
+	}
 
 	public void ShowKeywordHelp()
 	{
@@ -1861,11 +1861,11 @@ public class TooltipPanelManager : MonoBehaviour
 				tooltipPanel.gameObject.SetActive(value: false);
 				if (!(tooltipPanel is SignatureTooltipPanel))
 				{
-					m_tooltipPanelPool.Release(tooltipPanel);
-				}
+				m_tooltipPanelPool.Release(tooltipPanel);
 			}
 		}
 	}
+	}
 
 	public Card GetCard()
 	{
@@ -1931,4 +1931,13 @@ public class TooltipPanelManager : MonoBehaviour
 		}
 		return result;
 	}
+
+	#region Accessibility
+
+	internal List<TooltipPanel> GetTooltipPanels()
+    {
+		return m_tooltipPanels;
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/TouchList.cs b/Assembly-CSharp/TouchList.cs
index 84042f4..783c8d4 100644
--- a/Assembly-CSharp/TouchList.cs
+++ b/Assembly-CSharp/TouchList.cs
@@ -1251,28 +1251,9 @@ public class TouchList : PegUIElement
 
 	private void ScrollToItem_Internal(ITouchListItem item)
 	{
-		Bounds bounds = CalculateLocalClipBounds();
 		ItemInfo itemInfo = itemInfos[item];
-		float num = itemInfo.Max[layoutDimension1] - bounds.max[layoutDimension1];
-		if (num > 0f)
-		{
-			Vector3 zero = Vector3.zero;
-			zero[layoutDimension1] = num;
-			content.transform.Translate(zero);
-			lastContentPosition = content.transform.localPosition[layoutDimension1];
-			PreBufferLongListItems(scrolledAhead: true);
-			OnScrolled();
-		}
-		float num2 = bounds.min[layoutDimension1] - itemInfo.Min[layoutDimension1];
-		if (num2 > 0f)
-		{
-			Vector3 zero2 = Vector3.zero;
-			zero2[layoutDimension1] = 0f - num2;
-			content.transform.Translate(zero2);
-			lastContentPosition = content.transform.localPosition[layoutDimension1];
-			PreBufferLongListItems(scrolledAhead: false);
-			OnScrolled();
-		}
+		ScrollValue = (float)itemInfo.LongListIndex / (float)longListBehavior.AllItemsCount;
+
 	}
 
 	private void OnScrolled()
diff --git a/Assembly-CSharp/TournamentDisplay.cs b/Assembly-CSharp/TournamentDisplay.cs
index a49212c..f576898 100644
--- a/Assembly-CSharp/TournamentDisplay.cs
+++ b/Assembly-CSharp/TournamentDisplay.cs
@@ -48,7 +48,7 @@ public class TournamentDisplay : MonoBehaviour
 	private void OnDestroy()
 	{
 		s_instance = null;
-		UserAttentionManager.StopBlocking(UserAttentionBlocker.SET_ROTATION_INTRO);
+		UserAttentionManager.StopBlocking(false, UserAttentionBlocker.SET_ROTATION_INTRO);
 		UnregisterListeners();
 	}
 
diff --git a/Assembly-CSharp/TransitionPopup.cs b/Assembly-CSharp/TransitionPopup.cs
index 51ce917..f71d1a7 100644
--- a/Assembly-CSharp/TransitionPopup.cs
+++ b/Assembly-CSharp/TransitionPopup.cs
@@ -3,6 +3,7 @@ using System.Collections;
 using System.Collections.Generic;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public abstract class TransitionPopup : MonoBehaviour
 {
@@ -407,4 +408,29 @@ public abstract class TransitionPopup : MonoBehaviour
 	}
 
 	protected abstract void OnGameplaySceneLoaded();
+
+	protected void HandleCancelButtonInput()
+	{
+		if (AccessibleKey.BACK.IsPressed() && m_cancelButton != null && m_cancelButton.isActiveAndEnabled)
+		{
+			m_cancelButton.TriggerRelease();
+		}
+	}
+
+	protected string HandleCancelButtonHelp()
+	{
+		var lines = new List<string>();
+		lines.Add(m_title.Text);
+
+		if (m_cancelButton != null && m_cancelButton.isActiveAndEnabled)
+		{
+			lines.Add(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_CANCEL_HELP, AccessibleKey.BACK));
+		}
+		else
+		{
+			lines.Add(LocalizedText.GLOBAL_PLEASE_WAIT);
+		}
+
+		return AccessibleSpeechUtils.CombineLines(lines);
+	}
 }
diff --git a/Assembly-CSharp/TurnStartManager.cs b/Assembly-CSharp/TurnStartManager.cs
index 7abe8d4..a9b61fc 100644
--- a/Assembly-CSharp/TurnStartManager.cs
+++ b/Assembly-CSharp/TurnStartManager.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -212,10 +213,10 @@ public class TurnStartManager : MonoBehaviour
 				extraTurnSpell = extraTurnSpellTable.GetSpell(isFriendly);
 				if (extraTurnSpell != null)
 				{
-					extraTurnSpell.Activate();
-				}
+				extraTurnSpell.Activate();
 			}
 		}
+		}
 		else if (extraTurnSpell != null)
 		{
 			extraTurnSpell.ActivateState(SpellStateType.DEATH);
@@ -323,6 +324,7 @@ public class TurnStartManager : MonoBehaviour
 				m_turnStartInstance.SetReminderText(GameState.Get().GetGameEntity().GetTurnStartReminderText());
 				m_turnStartInstance.Show();
 				SoundManager.Get().LoadAndPlay("ALERT_YourTurn_0v2.prefab:201bcb34d33384e48ab226f7e797771f");
+				AccessibleGameplay.Get().OnTurnStart();
 			}
 		}
 	}
diff --git a/Assembly-CSharp/TurnTimer.cs b/Assembly-CSharp/TurnTimer.cs
index 5ea1082..86f7d14 100644
--- a/Assembly-CSharp/TurnTimer.cs
+++ b/Assembly-CSharp/TurnTimer.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using Blizzard.T5.MaterialService.Extensions;
 using UnityEngine;
+using Accessibility;
 
 public class TurnTimer : MonoBehaviour
 {
@@ -94,6 +95,7 @@ public class TurnTimer : MonoBehaviour
 	private void Update()
 	{
 		UpdateCountdownText();
+		UpdateAccessibleTimer();
 	}
 
 	public static TurnTimer Get()
@@ -501,4 +503,25 @@ public class TurnTimer : MonoBehaviour
 			}
 		}
 	}
+
+	#region Accessibility
+	private int m_prevSeconds;
+
+	private void UpdateAccessibleTimer()
+	{
+		var curSeconds = GetSecondsRemaining();
+
+		AccessibilityUtils.OutputTimerIfNecessary(curSeconds, m_prevSeconds);
+
+		m_prevSeconds = curSeconds;
+	}
+
+	internal int GetSecondsRemaining()
+	{
+		float curSecondsF = ComputeCountdownRemainingSec();
+
+		return Mathf.RoundToInt(curSecondsF);
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/TutorialKeywordManager.cs b/Assembly-CSharp/TutorialKeywordManager.cs
index 512c063..da825d4 100644
--- a/Assembly-CSharp/TutorialKeywordManager.cs
+++ b/Assembly-CSharp/TutorialKeywordManager.cs
@@ -190,4 +190,13 @@ public class TutorialKeywordManager : MonoBehaviour
 		}
 		return m_keywordPanels[0].transform.position;
 	}
+
+	#region Accessibility
+
+	internal List<TutorialKeywordTooltip> GetPanels()
+    {
+		return m_keywordPanels;
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/TutorialNotification.cs b/Assembly-CSharp/TutorialNotification.cs
index ed0ce11..e23f1d4 100644
--- a/Assembly-CSharp/TutorialNotification.cs
+++ b/Assembly-CSharp/TutorialNotification.cs
@@ -1,4 +1,7 @@
-public class TutorialNotification : Notification
+using Accessibility;
+using System;
+
+public class TutorialNotification : Notification, AccessibleUI
 {
 	public UIBButton m_ButtonStart;
 
@@ -23,4 +26,44 @@ public class TutorialNotification : Notification
 			m_WantedText.gameObject.SetActive(value: true);
 		}
 	}
+
+	#region Accessibility
+
+	private AccessibleMultilineText m_accessibleNotification;
+
+	public string GetAccessibleHelp()
+	{
+		return LocalizationUtils.Format(LocalizationKey.PRESS_KEY_TO_CONTINUE, AccessibleKey.CONFIRM);
+	}
+
+	public void HandleAccessibleInput()
+	{
+		if (AccessibleKey.CONFIRM.IsPressed())
+		{
+			m_ButtonStart.TriggerRelease();
+		}
+		else
+		{
+			m_accessibleNotification.HandleAccessibleInput();
+		}
+	}
+
+	internal void Hide()
+	{
+		AccessibilityMgr.HideUI(this);
+	}
+
+	internal void Show()
+	{
+		AccessibilityMgr.ShowUI(this);
+		AccessibilityMgr.Output(this, LocalizedText.UI_POPUP);
+
+		var headline = headlineUberText.Text;
+		var body = speechUberText.Text;
+
+		m_accessibleNotification = new AccessibleMultilineText(this, headline, body, GetAccessibleHelp());
+		m_accessibleNotification.ReadAllLines();
+	}
+
+	#endregion
 }
diff --git a/Assembly-CSharp/TutorialProgressScreen.cs b/Assembly-CSharp/TutorialProgressScreen.cs
index 1e0bf27..9b2a191 100644
--- a/Assembly-CSharp/TutorialProgressScreen.cs
+++ b/Assembly-CSharp/TutorialProgressScreen.cs
@@ -1,3 +1,4 @@
+using Accessibility;
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -253,7 +254,7 @@ public class TutorialProgressScreen : MonoBehaviour
 		m_widgetReady = true;
 	}
 
-	private void OnPlayButton(UIEvent e)
+	internal void OnPlayButton(UIEvent e)
 	{
 		if (m_playButtonVisualController != null && m_playButtonVisualController.HasState("CODE_PLAY_PRESSED"))
 		{
@@ -267,7 +268,7 @@ public class TutorialProgressScreen : MonoBehaviour
 		}
 	}
 
-	private void OnRewardChest(UIEvent e)
+	internal void OnRewardChest(UIEvent e)
 	{
 		if (NetCache.Get().GetNetObject<NetCache.NetCacheProfileProgress>().CampaignProgress != TutorialProgress.LICH_KING_COMPLETE)
 		{
@@ -293,15 +294,8 @@ public class TutorialProgressScreen : MonoBehaviour
 				}
 			}
 		};
-		Widget rewardWidget = RewardScroll.ShowFakeRewardWidget(dataModel);
-		rewardWidget.RegisterReadyListener(delegate
-		{
-			Clickable componentInChildren = rewardWidget.GetComponentInChildren<Clickable>();
-			if (componentInChildren != null)
-			{
-				componentInChildren.AddEventListener(UIEventType.RELEASE, OnRewardDismissed);
-			}
-		});
+		Widget rewardWidget = RewardScroll.ShowFakeRewardWidget(dataModel, () => OnRewardDismissed(null));
+
 		SetHasEverOpenedRewardChest();
 		if (m_rewardChestVisualController != null && m_rewardChestClickable != null)
 		{
@@ -386,10 +380,10 @@ public class TutorialProgressScreen : MonoBehaviour
 			{
 				AssetReference assetReference = AssetReference.CreateFromAssetString(m_coinMaterials[i]);
 				if (assetReference == null)
-				{
+			{
 					Debug.LogError("Failed to load asset reference");
 					return;
-				}
+			}
 				Material portraitMaterial = AssetLoader.Get().LoadAsset<Material>(assetReference);
 				adventureBossCoin.SetPortraitMaterial(portraitMaterial);
 				adventureBossCoin.gameObject.SetActive(value: true);
@@ -561,15 +555,18 @@ public class TutorialProgressScreen : MonoBehaviour
 	{
 		bool flag = SceneMgr.Get().GetMode() == SceneMgr.Mode.GAMEPLAY;
 		int num = 1;
+		TutorialProgress progress;
 		if (IS_TESTING)
 		{
 			m_nextScenarioId = m_progressToNextMissionIdMap[TutorialProgress.REXXAR_COMPLETE];
+			progress = TutorialProgress.REXXAR_COMPLETE;
 		}
 		else
 		{
 			NetCache.NetCacheProfileProgress netObject = NetCache.Get().GetNetObject<NetCache.NetCacheProfileProgress>();
+			progress = netObject.CampaignProgress;
 			if (m_progressToNextMissionIdMap.ContainsKey(netObject.CampaignProgress))
-			{
+		{
 				m_nextScenarioId = m_progressToNextMissionIdMap[netObject.CampaignProgress];
 				num = (int)netObject.CampaignProgress;
 			}
@@ -616,6 +613,8 @@ public class TutorialProgressScreen : MonoBehaviour
 				}
 			}
 		}
+
+		AccessibleTutorialProgressScreen.Get().OnUpdateProgress(progress);
 	}
 
 	public static bool HasEverOpenedRewardChest()
@@ -630,9 +629,9 @@ public class TutorialProgressScreen : MonoBehaviour
 	public static void SetHasEverOpenedRewardChest()
 	{
 		GameSaveDataManager.Get().SaveSubkey(new GameSaveDataManager.SubkeySaveRequest(GameSaveKeyId.PLAYER_FLAGS, GameSaveKeySubkeyId.PLAYER_FLAGS_HAS_OPENED_TRADITIONAL_TUTORIAL_REWARD_CHEST, 1L));
-	}
+    }
 
-	private void ExitButtonPress(UIEvent e)
+    private void ExitButtonPress(UIEvent e)
 	{
 		SceneMgr.Get().SetNextMode(SceneMgr.Mode.HUB);
 		m_screenEffectsHandle.StopEffect(0.5f, iTween.EaseType.easeInOutQuad);
diff --git a/Assembly-CSharp/Tutorial_Dungeon.cs b/Assembly-CSharp/Tutorial_Dungeon.cs
index 60bb0e0..96b7a73 100644
--- a/Assembly-CSharp/Tutorial_Dungeon.cs
+++ b/Assembly-CSharp/Tutorial_Dungeon.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using UnityEngine;
+using Accessibility;
 
 public class Tutorial_Dungeon : Tutorial_MissionEntity
 {
@@ -327,4 +328,37 @@ public class Tutorial_Dungeon : Tutorial_MissionEntity
 			break;
 		}
 	}
+
+	#region Accessibility
+	protected void Speak(LocalizationKey key)
+	{
+        string text = LocalizationUtils.Get(key);
+        Speak(text);
+	}
+
+	protected void Speak(LocalizationKey key, params object[] args)
+	{
+        string text = LocalizationUtils.Format(key, args);
+        Speak(text);
+	}
+
+	protected void Speak(string text)
+	{
+		AccessibilityMgr.Output(AccessibleGameplay.Get(), text);
+	}
+
+	protected void SpeakAndSetHelp(LocalizationKey key)
+	{
+		string text = LocalizationUtils.Get(key);
+		Speak(text);
+		AccessibilityMgr.OverrideHelpSpeech(text);
+	}
+
+	protected void SpeakAndSetHelp(LocalizationKey key, params object[] args)
+	{
+		string text = LocalizationUtils.Format(key, args);
+		Speak(text);
+		AccessibilityMgr.OverrideHelpSpeech(text);
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/Tutorial_Fight_001.cs b/Assembly-CSharp/Tutorial_Fight_001.cs
index e30e73a..a6f656c 100644
--- a/Assembly-CSharp/Tutorial_Fight_001.cs
+++ b/Assembly-CSharp/Tutorial_Fight_001.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Blizzard.T5.AssetManager;
 using UnityEngine;
 
@@ -131,6 +132,13 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 
 	private bool m_hasSuspendedHelpNotification;
 
+	#region Accessibility
+	private bool m_waitingForCardRead = false;
+	private bool m_waitingForMinionSummoned = false;
+	private bool m_waitingForMinionKilled = false;
+	private bool m_waitingForOpponentHeroAttacked = false;
+	#endregion
+
 	public override void PreloadAssets()
 	{
 		base.PreloadAssets();
@@ -319,6 +327,8 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 
 	public override void NotifyOfMinionPlayed(Entity minion)
 	{
+		m_waitingForMinionSummoned = false;
+
 		if ((minion.GetCardId() == "TUTR_DAL_092t2" || minion.GetCardId() == "TUTR_NEW1_012t2") && m_createdTutorialNotification)
 		{
 			HideTutorialNotification();
@@ -333,10 +343,10 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 				{
 					Entity entity = item.GetEntity();
 					if (entity.GetCardId() == "TUTR_NEW1_012t2")
-					{
-						ChangeAnimationStateForTutorial(entity, entity.GetCardId(), GetTag(GAME_TAG.TURN), entity.GetZone(), SpellStateType.BIRTH);
-					}
-				}
+			{
+				ChangeAnimationStateForTutorial(entity, entity.GetCardId(), GetTag(GAME_TAG.TURN), entity.GetZone(), SpellStateType.BIRTH);
+			}
+		}
 			}
 		}
 		HideAttackAndHealthLabel();
@@ -360,6 +370,8 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 	public override void NotifyOfMulliganInitialized()
 	{
 		base.NotifyOfMulliganInitialized();
+
+		AccessibleGameplay.Get().DisableManaCounters();
 	}
 
 	public override bool NotifyOfEndTurnButtonPushed()
@@ -370,6 +382,8 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 			NotificationManager.Get().DestroyAllNotificationsNowWithNoAnim();
 			NotificationManager.Get().DestroyAllArrows();
 			HideTutorialNotification();
+
+			AccessibilityMgr.ResetHelpSpeech();
 			return true;
 		}
 		return false;
@@ -449,6 +463,8 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 		{
 			ChangeAnimationStateForTutorial(attacker, attacker.GetCardId(), GetTag(GAME_TAG.TURN), attacker.GetZone(), SpellStateType.IDLE);
 		}
+
+		m_waitingForOpponentHeroAttacked = false;
 	}
 
 	private void OnEndTurnButtonStateChange(ActorStateType state)
@@ -780,6 +796,12 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 
 	private void ShowTutorialNotification(Vector3 tooltipPosition, Vector3 tooltipPostionMobile, string gameStringKey, NotificationManager.TutorialPopupType type = NotificationManager.TutorialPopupType.IMPORTANT)
 	{
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+		{
+			// Visual tutorials. We have speech for the important ones.
+			return;
+		}
+
 		NotificationManager notificationManager = NotificationManager.Get();
 		if (notificationManager == null)
 		{
@@ -927,6 +949,8 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 			break;
 		case 652:
 			ShowTutorialNotification(m_tutorialConfig.m_MinionTradeTooltipPositionOffset, m_tutorialConfig.m_MinionTradeTooltipPositionOffsetMobile, "TUTR_HELPER_Fight_01_MinionsDestroyed", NotificationManager.TutorialPopupType.GRAPHIC);
+
+			Speak(GameStrings.Get("TUTR_HELPER_Fight_01_MinionsDestroyed"));
 			break;
 		case 653:
 		{
@@ -935,13 +959,16 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 				.GetFirstCard();
 			Vector3 position = m_friendlyCardWyrm.transform.position;
 			Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
-			if (UniversalInputManager.Get().IsTouchMode())
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
 			{
-				m_wyrmHover = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_PlayMinion_Mobile"));
-			}
-			else
-			{
-				m_wyrmHover = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_PlayMinion"));
+				if (UniversalInputManager.Get().IsTouchMode())
+				{
+					m_wyrmHover = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_PlayMinion_Mobile"));
+				}
+				else
+				{
+					m_wyrmHover = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_PlayMinion"));
+				}
 			}
 			m_wyrmHover.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
 			break;
@@ -977,6 +1004,8 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 
 	protected override IEnumerator HandleStartOfTurnWithTiming(int turn)
 	{
+		AccessibilityMgr.ResetHelpSpeech();
+
 		while (m_enemySpeaking)
 		{
 			yield return null;
@@ -1011,12 +1040,132 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 			yield return new WaitForSeconds(m_tutorialConfig.m_PlayerTurn1Delay);
 			ShowPlayMinionTooltip();
 			gameState.SetBusy(busy: false);
+
+			Speak(LocalizationKey.TUTORIAL_HOGGER_2_0);	// When a turn starts, you always begin by drawing a card from your deck. Let's see the one we just drew
+			SpeakAndSetHelp(LocalizationKey.TUTORIAL_HOGGER_2_1, AccessibleKey.SEE_PLAYER_HAND);	// Press C to look at the cards in your hand
+
+			var ManaWyrm = GameState.Get().GetFriendlySidePlayer().GetHandZone().GetFirstCard();
+			AccessibleCard accessibleManaWyrm = null;
+			bool waitingForCardSelected = true;
+
+			AccessibleGameplay.Get().RegisterCardSelectedListener(ManaWyrm, delegate (AccessibleCard ac) {
+				accessibleManaWyrm = ac;
+				waitingForCardSelected = false;
+			});
+			yield return new WaitWhile(() => waitingForCardSelected);
+			yield return new WaitForSeconds(3f);
+
+			SpeakAndSetHelp(LocalizationKey.GAMEPLAY_READ_CARD_HELP);	// Use the up and down arrow keys to read this card
+			m_waitingForCardRead = true;
+			accessibleManaWyrm.RegisterFinishReadListener(delegate {
+				m_waitingForCardRead = false;
+			});
+			yield return new WaitWhile(() => m_waitingForCardRead);
+			yield return new WaitForSeconds(1f);
+
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_2_2);	// Ok, so... This card is a minion named Mana Wyrm
+			Speak(LocalizationKey.TUTORIAL_HOGGER_2_2B);	// Minions are creatures that you can summon onto the battlefield to fight for your Hero
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_2_2D);	// This one has 1 attack and 2 health
+			Speak(LocalizationKey.TUTORIAL_HOGGER_2_3);	// Let's start by summoning this minion
+			Speak(LocalizationKey.TUTORIAL_HOGGER_2_4, AccessibleKey.CONFIRM);	// Press Enter to do so
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PRESS_ENTER_TO_SUMMON_THIS_MINION, AccessibleKey.CONFIRM));
+
+			bool waitingForStartSummon = true;
+			AccessibleGameplay.Get().RegisterSummoningCardListener(ManaWyrm, delegate {
+				waitingForStartSummon = false;
+			});
+			yield return new WaitWhile(() => waitingForStartSummon);
+			yield return new WaitForSeconds(1f);
+
+			SpeakAndSetHelp(LocalizationKey.TUTORIAL_HOGGER_2_5, AccessibleKey.CONFIRM, AccessibleKey.BACK);	// Press Enter to confirm or Backspace to cancel
+			m_waitingForMinionSummoned = true;
+			yield return new WaitWhile(() => m_waitingForMinionSummoned);
+			yield return new WaitForSeconds(1f);
+			Speak(LocalizationKey.TUTORIAL_HOGGER_2_6);	// Minions must wait a turn to attack once they're summoned, so we have nothing left to do
+			SpeakAndSetHelp(LocalizationKey.GAMEPLAY_END_TURN_HELP, AccessibleKey.END_TURN);	// Press E to end your turn
+
 			break;
 		}
 		case 3:
 			yield return new WaitForSeconds(m_tutorialConfig.m_PlayerTurn2Delay);
 			yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_HELPER_SPELL_01);
 			ShowTutorialNotification(m_tutorialConfig.m_DamageSpellTutorialPosition, m_tutorialConfig.m_DamageSpellTutorialPositionMobile, "TUTR_HELPER_Fight_01_PlaySpell");
+
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_4_0);	// You've got another card! Can you find out what it does?
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_SEE_PLAYER_HAND_HELP, AccessibleKey.CONFIRM));
+			bool waitingForArcaneBoltRead = true;
+			AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetHandZone().GetFirstCard(), delegate(AccessibleCard ac) {
+				AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_READ_CARD_HELP));
+				ac.RegisterFinishReadListener(delegate {
+					waitingForArcaneBoltRead = false;
+				});
+			});
+			yield return new WaitWhile(() => waitingForArcaneBoltRead);
+			yield return new WaitForSeconds(1f);
+
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_4_1, AccessibleKey.CONFIRM);	// This spell is perfect for dealing with Huffer! Press enter to play it
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_PLAY_CARD_HELP, AccessibleKey.CONFIRM));
+			yield return new WaitUntil(GameState.Get().IsInTargetMode);
+			yield return new WaitForSeconds(1f);
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_4_2, AccessibleKey.CONFIRM);	// Select the enemy minion and press enter to target it
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.NEW_TUTORIAL_REXXAR_4_2_HELP, AccessibleKey.SEE_OPPONENT_MINIONS, AccessibleKey.CONFIRM));
+			m_waitingForMinionKilled = true;
+			yield return new WaitWhile(() => m_waitingForMinionKilled);
+			AccessibilityMgr.ResetHelpSpeech();
+			yield return new WaitForSeconds(3f);
+
+			Speak(LocalizationKey.TUTORIAL_NICE_JOB);
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_4_3);	// Now, let's learn how to check your health
+			SpeakAndSetHelp(LocalizationKey.GAMEPLAY_SEE_PLAYER_HERO_HELP, AccessibleKey.SEE_PLAYER_HERO);
+			bool waitingForFriendlyHeroSelected = true;
+			bool waitingForFriendlyHeroRead = true;
+			AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetHeroCard(), delegate(AccessibleCard ac) {
+				waitingForFriendlyHeroSelected = false;
+				ac.RegisterFinishReadListener(delegate {
+					waitingForFriendlyHeroRead = false;
+				});
+			});
+			yield return new WaitWhile(() => waitingForFriendlyHeroSelected);
+			yield return new WaitForSeconds(1f);
+
+			SpeakAndSetHelp(LocalizationKey.TUTORIAL_HOGGER_3_2);	// Use the up and down arrow keys to read your hero card
+			yield return new WaitWhile(() => waitingForFriendlyHeroRead);
+			yield return new WaitForSeconds(1f);
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_4_5);	// If your Hero runs out of health, you lose
+			Speak(LocalizationKey.TUTORIAL_HOGGER_3_4, AccessibleKey.SEE_OPPONENT_HERO);	// Let's look at your opponent's hero now. Press F
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_SEE_OPPONENT_HERO_HELP, AccessibleKey.SEE_OPPONENT_HERO));
+			bool waitingForOpponentHeroSelected = true;
+			bool waitingForOpponentHeroRead = true;
+			AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetOpposingSidePlayer().GetHeroCard(), delegate(AccessibleCard ac) {
+				waitingForOpponentHeroSelected = false;
+				ac.RegisterFinishReadListener(delegate {
+					waitingForOpponentHeroRead = false;
+				});
+			});
+			yield return new WaitWhile(() => waitingForOpponentHeroSelected);
+			yield return new WaitForSeconds(1f);
+
+			Speak(LocalizationKey.TUTORIAL_HOGGER_3_5);	// Can you find how much health he has?
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Get(LocalizationKey.TUTORIAL_HOGGER_3_5_HELP));
+			yield return new WaitWhile(() => waitingForOpponentHeroRead);
+			yield return new WaitForSeconds(1f);
+			Speak(LocalizationKey.TUTORIAL_HOGGER_3_6);	// Once your opponent's Hero runs out of health, you win
+			AccessibilityMgr.ResetHelpSpeech();
+			yield return new WaitForSeconds(3f);
+
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_4_9, AccessibleKey.CONFIRM);	// Your mana wyrm is now ready to attack. Select it and press enter.
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.TUTORIAL_HOGGER_4_11_HELP, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM));
+			yield return new WaitUntil(GameState.Get().IsInTargetMode);
+			yield return new WaitForSeconds(1f);
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_4_10);	// Can you attack your opponent's hero?
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.NEW_TUTORIAL_REXXAR_4_10_HELP, AccessibleKey.SEE_OPPONENT_HERO, AccessibleKey.CONFIRM));
+			m_waitingForOpponentHeroAttacked = true;
+			yield return new WaitWhile(() => m_waitingForOpponentHeroAttacked);
+			yield return new WaitForSeconds(3f);
+			Speak(LocalizationKey.TUTORIAL_NICE_ONE);
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_4_11);	// Remember how to end your turn?
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.GAMEPLAY_END_TURN_HELP, AccessibleKey.END_TURN));
+
 			break;
 		case 5:
 		{
@@ -1025,8 +1174,11 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 			{
 				position2 = m_tutorialConfig.m_WinContionTooltipPositionOffsetMobile;
 			}
-			m_winHelp = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_WinCondition"), convertLegacyPosition: false);
-			m_winHelp.ShowPopUpArrow(Notification.PopUpArrowDirection.LeftUp);
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+			{
+				m_winHelp = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_WinCondition"), convertLegacyPosition: false);
+				m_winHelp.ShowPopUpArrow(Notification.PopUpArrowDirection.LeftUp);
+			}
 			yield return new WaitForSeconds(m_tutorialConfig.m_PlayerTurn3Delay);
 			Card firstCard2 = GameState.Get().GetFriendlySidePlayer().GetHandZone()
 				.GetFirstCard();
@@ -1035,6 +1187,58 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 				Entity entity2 = (m_entityDrawnFromDeck = firstCard2.GetEntity());
 				ChangeAnimationStateForTutorial(entity2, entity2.GetCardId(), GetTag(GAME_TAG.TURN), entity2.GetZone(), SpellStateType.BIRTH);
 			}
+
+			Speak(LocalizationKey.TUTORIAL_HOGGER_6_1);	// Looks like you got another minion
+			Speak(LocalizationKey.TUTORIAL_HOGGER_6_2);	// This means you have two possible options right now
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_6_3);	// You can either summon the minion you just got, or use the one you already have on the batlefield to launch an attack
+			Speak(LocalizationKey.TUTORIAL_HOGGER_6_4, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.SEE_PLAYER_MINIONS);	// One way to do this would be using keys such as C to look at your hand or B to look at your summoned minions
+			Speak(LocalizationKey.TUTORIAL_HOGGER_6_5);	// However, there's an easier way to do it
+			SpeakAndSetHelp(LocalizationKey.TUTORIAL_HOGGER_6_6, AccessibleKey.READ_NEXT_VALID_ITEM);	// Press tab
+
+			bool waitingForArcaneServantSelected = true;
+			Card arcaneServant = GameState.Get().GetFriendlySidePlayer().GetHandZone().GetFirstCard();
+			AccessibleGameplay.Get().RegisterCardSelectedListener(arcaneServant, delegate(AccessibleCard ac) {
+				waitingForArcaneServantSelected = false;
+			});
+			yield return new WaitWhile(() => waitingForArcaneServantSelected);
+			yield return new WaitForSeconds(3f);
+
+			Speak(LocalizationKey.TUTORIAL_HOGGER_6_7);	// You're now looking at your first option, which would be to summon the minion you just got
+			Speak(LocalizationKey.TUTORIAL_HOGGER_6_8, AccessibleKey.READ_NEXT_VALID_ITEM);	// Try pressing tab again
+			bool waitingForManaWyrmSelected = true;
+			AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetFirstCard(), delegate(AccessibleCard ac) {
+				waitingForManaWyrmSelected = false;
+			});
+			yield return new WaitWhile(() => waitingForManaWyrmSelected);
+			yield return new WaitForSeconds(3f);
+
+			Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_6_9);	// You're now looking at your second option, which would be to attack with the minion you have on the battlefield
+			Speak(LocalizationKey.TUTORIAL_HOGGER_6_10, AccessibleKey.READ_NEXT_VALID_ITEM);	// You can always use tab to go through your valid options, so make sure to remember this key!
+			AccessibilityMgr.ResetHelpSpeech();
+			yield return new WaitForSeconds(3f);
+
+			Speak(LocalizationKey.TUTORIAL_HOGGER_6_12);	// Alright. Let's begin by summoning the minion we just got
+			bool waitingForSummoningMinion = true;
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.TUTORIAL_HOGGER_6_12_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_PLAYER_HAND, AccessibleKey.CONFIRM));
+			AccessibleGameplay.Get().RegisterSummoningCardListener(arcaneServant, delegate {
+				waitingForSummoningMinion = false;
+				AccessibilityMgr.ResetHelpSpeech();
+			});
+			yield return new WaitWhile(() => waitingForSummoningMinion);
+			yield return new WaitForSeconds(1f);
+			Speak(LocalizationKey.TUTORIAL_HOGGER_4_2);	// When you already have minions on the battlefield, you can use the left and right arrow keys to select where the new minion will be placed
+			m_waitingForMinionSummoned = true;
+			yield return new WaitWhile(() => m_waitingForMinionSummoned);
+			yield return new WaitForSeconds(3f);
+
+			Speak(LocalizationKey.TUTORIAL_HOGGER_6_13);	// Let's try to attack with our other minion now
+			AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.TUTORIAL_HOGGER_6_13_HELP, AccessibleKey.READ_NEXT_VALID_ITEM, AccessibleKey.SEE_PLAYER_MINIONS, AccessibleKey.CONFIRM));
+			m_waitingForOpponentHeroAttacked = true;
+			yield return new WaitWhile(() => m_waitingForOpponentHeroAttacked);
+			AccessibilityMgr.ResetHelpSpeech();
+			yield return new WaitForSeconds(3f);
+
+			Speak(LocalizationKey.TUTORIAL_HOGGER_8_1);	// I'll let you continue playing by yourself. Just let me know if you need anything
 			break;
 		}
 		case 7:
@@ -1054,9 +1258,12 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 			{
 				position = m_tutorialConfig.m_historyHelpNotificationPositionMobile;
 			}
-			m_historyHelp = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_HistoryTiles"), convertLegacyPosition: false);
-			m_historyHelp.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
-			NotificationManager.Get().DestroyNotification(m_historyHelp, 4f);
+			if (!AccessibilityMgr.IsAccessibilityEnabled())
+			{
+				m_historyHelp = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_HistoryTiles"), convertLegacyPosition: false);
+				m_historyHelp.ShowPopUpArrow(Notification.PopUpArrowDirection.Left);
+				NotificationManager.Get().DestroyNotification(m_historyHelp, 4f);
+			}
 			break;
 		}
 		case 9:
@@ -1065,4 +1272,83 @@ public class Tutorial_Fight_001 : Tutorial_Dungeon
 			break;
 		}
 	}
+
+	#region Accessibility
+	private bool m_hasSeenChargeHint = false;
+
+	protected override IEnumerator RespondToPlayedCardWithTiming(Entity entity)
+	{
+		yield return new WaitWhile(() => entity.GetCardType() == TAG_CARDTYPE.INVALID);
+		yield return WaitForEntitySoundToFinish(entity);
+
+		if (entity.GetCardId() == "TUTR_NEW1_034")
+		{
+			yield return DoBattlefieldTutorial(entity.GetCard());
+		}
+		else if (entity.GetCardId() == "TUTR_CS2_171t2" && !m_hasSeenChargeHint)
+		{
+			yield return DoChargeHint();
+		}
+	}
+
+	private IEnumerator DoBattlefieldTutorial(Card huffer)
+	{
+		GameState.Get().SetBusy(busy: true);
+		yield return new WaitForSeconds(1f);
+		Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_3_0);	// Your opponent has summoned a minion of his own
+		Speak(LocalizationKey.TUTORIAL_HOGGER_4_5);	// Let's learn how to navigate the battlefield
+		Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_3_2, AccessibleKey.SEE_OPPONENT_MINIONS);	// Press G to look at your opponent's minions
+		AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.NEW_TUTORIAL_REXXAR_3_2, AccessibleKey.SEE_OPPONENT_MINIONS));
+		bool waitingForHufferSelected = true;
+		AccessibleCard accessibleHuffer = null;
+		AccessibleGameplay.Get()	.RegisterCardSelectedListener(huffer, delegate(AccessibleCard ac) {
+			waitingForHufferSelected = false;
+			accessibleHuffer = ac;
+		});
+		yield return new WaitWhile(() => waitingForHufferSelected);
+		AccessibilityMgr.ResetHelpSpeech();
+		yield return new WaitForSeconds(3f);
+
+		Speak(LocalizationKey.TUTORIAL_HOGGER_4_9);	// Can you read this minion by yourself?
+		AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Get(LocalizationKey.GAMEPLAY_READ_CARD_HELP));
+		bool waitingForCardRead = true;
+		accessibleHuffer.RegisterFinishReadListener(delegate {
+			waitingForCardRead = false;
+		});
+		yield return new WaitWhile(() => waitingForCardRead);
+		AccessibilityMgr.ResetHelpSpeech();
+		yield return new WaitForSeconds(1f);
+
+		Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_3_4, AccessibleKey.SEE_PLAYER_MINIONS);	// Now let's look at your minions. Press B to do so
+		AccessibilityMgr.OverrideHelpSpeech(LocalizationUtils.Format(LocalizationKey.NEW_TUTORIAL_REXXAR_3_4, AccessibleKey.SEE_PLAYER_MINIONS));
+		bool waitingForManaWyrmSelected = true;
+		AccessibleGameplay.Get().RegisterCardSelectedListener(GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone().GetFirstCard(), delegate(AccessibleCard ac) {
+			waitingForManaWyrmSelected = false;
+		});
+		yield return new WaitWhile(() => waitingForManaWyrmSelected);
+		AccessibilityMgr.ResetHelpSpeech();
+		yield return new WaitForSeconds(3f);
+		Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_3_5);	// When there is more than one minion, you can use the left and right arrow keys to move between them
+		yield return new WaitForSeconds(3f);
+		Speak(LocalizationKey.TUTORIAL_HOGGER_3_7);	// Let's carry on
+		GameState.Get().SetBusy(busy: false);
+	}
+
+	private IEnumerator DoChargeHint()
+	{
+		GameState.Get().SetBusy(busy: true);
+		yield return new WaitForSeconds(1f);
+		Speak(LocalizationKey.NEW_TUTORIAL_REXXAR_7_0);
+		yield return new WaitForSeconds(3f);
+		m_hasSeenChargeHint = true;
+		GameState.Get().SetBusy(busy: false);
+	}
+
+    public override void NotifyOfMinionDied(Entity minion)
+    {
+        base.NotifyOfMinionDied(minion);
+		m_waitingForMinionKilled = false;
+    }
+    #endregion
+
 }
diff --git a/Assembly-CSharp/Tutorial_Fight_002.cs b/Assembly-CSharp/Tutorial_Fight_002.cs
index b2a5d9b..b1d85ba 100644
--- a/Assembly-CSharp/Tutorial_Fight_002.cs
+++ b/Assembly-CSharp/Tutorial_Fight_002.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Blizzard.T5.AssetManager;
 using UnityEngine;
 
@@ -240,16 +241,16 @@ public class Tutorial_Fight_002 : Tutorial_Dungeon
 		}
 		switch (GetTag(GAME_TAG.TURN))
 		{
-		case 2:
-			return true;
-		case 4:
-			if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
-				.GetCards()
-				.Count == 0)
-			{
+			case 2:
 				return true;
-			}
-			break;
+			case 4:
+				if (GameState.Get().GetFriendlySidePlayer().GetBattlefieldZone()
+					.GetCards()
+					.Count == 0)
+				{
+					return true;
+				}
+				break;
 		}
 		return false;
 	}
@@ -476,60 +477,67 @@ public class Tutorial_Fight_002 : Tutorial_Dungeon
 			.GetActor();
 		switch (missionEvent)
 		{
-		case 514:
-			yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_Introduction_04);
-			yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Introduction_01);
-			break;
-		case 650:
-		{
-			GameState.Get().SetBusy(busy: true);
-			Vector3 position = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
-				.transform.position;
-			Vector3 position2 = new Vector3(position.x - 1.55f, position.y, position.z - 2.721f);
-			Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_PlayWeapon"));
-			notification.ShowPopUpArrow(Notification.PopUpArrowDirection.Up);
-			NotificationManager.Get().DestroyNotification(notification, 3.5f);
-			yield return new WaitForSeconds(3.5f);
-			GameState.Get().SetBusy(busy: false);
-			break;
-		}
-		case 651:
-		{
-			ShowTutorialNotification(m_tutorialConfig.m_HeroPowerTutorialPositionOffset, m_tutorialConfig.m_HeroPowerTutorialPositionOffsetMobile, "TUTR_HELPER_Fight_01_HeroPower", Notification.PopUpArrowDirection.LeftDown);
-			Entity heroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPower();
-			ChangeAnimationStateForTutorial(heroPower, heroPower.GetCardId(), GetTag(GAME_TAG.TURN), heroPower.GetZone(), SpellStateType.BIRTH);
-			break;
-		}
-		case 654:
-			yield return new WaitForSeconds(2.5f);
-			yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_OnDrawAOESpell_01);
-			yield return new WaitForSeconds(0.5f);
-			break;
-		case 655:
-		{
-			HideTutorialNotification();
-			Entity heroPower2 = GameState.Get().GetFriendlySidePlayer().GetHeroPower();
-			ChangeAnimationStateForTutorial(heroPower2, heroPower2.GetCardId(), GetTag(GAME_TAG.TURN), heroPower2.GetZone(), SpellStateType.IDLE);
-			break;
-		}
-		case 658:
-			ShowTutorialNotification(m_tutorialConfig.m_SpellIgnoreTauntTutorialPosition, m_tutorialConfig.m_SpellIgnoreTauntTutorialPositionMobile, "TUTR_HELPER_Fight_01_SpellIgnoresTaunt");
-			break;
-		case 659:
-			m_hasManaWyrmBeenPlayed = true;
-			break;
-		case 750:
-			yield return MissionPlaySound(VO_TUTR_Garrosh_Death_01);
-			break;
-		case 751:
-		{
-			string stringOption = GetGameOptions().GetStringOption(GameEntityOption.VICTORY_AUDIO_PATH);
-			if (!string.IsNullOrEmpty(stringOption))
-			{
-				SoundManager.Get().LoadAndPlay(stringOption);
-			}
-			break;
-		}
+			case 514:
+				yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_Introduction_04);
+				yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Introduction_01);
+				break;
+			case 650:
+				{
+					GameState.Get().SetBusy(busy: true);
+					Vector3 position = GameState.Get().GetOpposingSidePlayer().GetHeroCard()
+							.transform.position;
+					Vector3 position2 = new Vector3(position.x - 1.55f, position.y, position.z - 2.721f);
+					Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_PlayWeapon"));
+					notification.ShowPopUpArrow(Notification.PopUpArrowDirection.Up);
+					NotificationManager.Get().DestroyNotification(notification, 3.5f);
+					yield return new WaitForSeconds(3.5f);
+					GameState.Get().SetBusy(busy: false);
+					break;
+				}
+			case 651:
+				{
+					if (!AccessibilityMgr.IsAccessibilityEnabled())
+					{
+						ShowTutorialNotification(m_tutorialConfig.m_HeroPowerTutorialPositionOffset, m_tutorialConfig.m_HeroPowerTutorialPositionOffsetMobile, "TUTR_HELPER_Fight_01_HeroPower", Notification.PopUpArrowDirection.LeftDown);
+						Entity heroPower = GameState.Get().GetFriendlySidePlayer().GetHeroPower();
+						ChangeAnimationStateForTutorial(heroPower, heroPower.GetCardId(), GetTag(GAME_TAG.TURN), heroPower.GetZone(), SpellStateType.BIRTH);
+					}
+
+					Speak(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP);  // From now on, your Hero and your opponent's Hero will normally have a Hero Power
+					Speak(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP_B);    // Every Hero has its own Hero Power and you can use it once per turn
+					Speak(LocalizationKey.TUTORIAL_HEMET_HERO_POWER_HELP_C, AccessibleKey.SEE_PLAYER_HERO_POWER, AccessibleKey.SEE_OPPONENT_HERO_POWER);
+					break;
+				}
+			case 654:
+				yield return new WaitForSeconds(2.5f);
+				yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_OnDrawAOESpell_01);
+				yield return new WaitForSeconds(0.5f);
+				break;
+			case 655:
+				{
+					HideTutorialNotification();
+					Entity heroPower2 = GameState.Get().GetFriendlySidePlayer().GetHeroPower();
+					ChangeAnimationStateForTutorial(heroPower2, heroPower2.GetCardId(), GetTag(GAME_TAG.TURN), heroPower2.GetZone(), SpellStateType.IDLE);
+					break;
+				}
+			case 658:
+				ShowTutorialNotification(m_tutorialConfig.m_SpellIgnoreTauntTutorialPosition, m_tutorialConfig.m_SpellIgnoreTauntTutorialPositionMobile, "TUTR_HELPER_Fight_01_SpellIgnoresTaunt");
+				break;
+			case 659:
+				m_hasManaWyrmBeenPlayed = true;
+				break;
+			case 750:
+				yield return MissionPlaySound(VO_TUTR_Garrosh_Death_01);
+				break;
+			case 751:
+				{
+					string stringOption = GetGameOptions().GetStringOption(GameEntityOption.VICTORY_AUDIO_PATH);
+					if (!string.IsNullOrEmpty(stringOption))
+					{
+						SoundManager.Get().LoadAndPlay(stringOption);
+					}
+					break;
+				}
 		}
 	}
 
@@ -559,32 +567,41 @@ public class Tutorial_Fight_002 : Tutorial_Dungeon
 			.GetActor();
 		switch (cardId)
 		{
-		case "TUTR_NEW1_012":
-			if (!m_hasManaWyrmBeenPlayed)
-			{
-				m_hasManaWyrmBeenPlayed = true;
-			}
-			break;
-		case "TUTR_OG_218":
-			if (!m_hasFrostwolfBeenPlayed)
-			{
-				m_hasFrostwolfBeenPlayed = true;
-				GameState.Get().SetBusy(busy: true);
-				Vector3 position = entity.GetCard().transform.position;
-				Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
-				Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_PlayTaunt"));
-				notification.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
-				NotificationManager.Get().DestroyNotification(notification, 5f);
-				GameState.Get().SetBusy(busy: false);
-			}
-			break;
-		case "TUTR_CS2_027":
-			if (!m_hasTauntBeenPlayed)
-			{
-				yield return MissionPlayVO(actor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_Turn_08);
-				m_hasTauntBeenPlayed = true;
-			}
-			break;
+			case "TUTR_NEW1_012":
+				if (!m_hasManaWyrmBeenPlayed)
+				{
+					m_hasManaWyrmBeenPlayed = true;
+				}
+				break;
+			case "TUTR_OG_218":
+				if (!m_hasFrostwolfBeenPlayed)
+				{
+					m_hasFrostwolfBeenPlayed = true;
+					GameState.Get().SetBusy(busy: true);
+					Vector3 position = entity.GetCard().transform.position;
+					Vector3 position2 = new Vector3(position.x - 3f, position.y, position.z);
+					if (!AccessibilityMgr.IsAccessibilityEnabled())
+					{
+						Notification notification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_PlayTaunt"));
+						notification.ShowPopUpArrow(Notification.PopUpArrowDirection.Right);
+						NotificationManager.Get().DestroyNotification(notification, 5f);
+					}
+
+					yield return new WaitForSeconds(3f);
+					Speak(LocalizationKey.NEW_TUTORIAL_GARROSH_TAUNT_HELP); // This frostwolf warmaster your opponent just summoned has an ability named Taunt
+					Speak(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP_B); // Minions with Taunt must always be killed before you can attack anyone else
+					Speak(LocalizationKey.TUTORIAL_MUKLA_TAUNT_HELP_C); // Taunt is an important ability as it can be used to protect your Hero
+					yield return new WaitForSeconds(7f);
+					GameState.Get().SetBusy(busy: false);
+				}
+				break;
+			case "TUTR_CS2_027":
+				if (!m_hasTauntBeenPlayed)
+				{
+					yield return MissionPlayVO(actor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_Turn_08);
+					m_hasTauntBeenPlayed = true;
+				}
+				break;
 		}
 	}
 
@@ -607,89 +624,91 @@ public class Tutorial_Fight_002 : Tutorial_Dungeon
 			.GetActor();
 		switch (turn)
 		{
-		case 1:
-		{
-			Vector3 manaCrystalSpawnPosition2 = ManaCrystalMgr.Get().GetManaCrystalSpawnPosition();
-			Vector3 position2;
-			Notification.PopUpArrowDirection direction2;
-			if ((bool)UniversalInputManager.UsePhoneUI)
-			{
-				position2 = new Vector3(manaCrystalSpawnPosition2.x - 0.7f, manaCrystalSpawnPosition2.y + 1.14f, manaCrystalSpawnPosition2.z + 4.33f);
-				direction2 = Notification.PopUpArrowDirection.RightDown;
-			}
-			else
-			{
-				position2 = new Vector3(manaCrystalSpawnPosition2.x - 0.02f, manaCrystalSpawnPosition2.y + 0.2f, manaCrystalSpawnPosition2.z + 1.8f);
-				direction2 = Notification.PopUpArrowDirection.Down;
-			}
-			m_manaNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_Mana"));
-			m_manaNotification.ShowPopUpArrow(direction2);
-			break;
-		}
-		case 3:
-		{
-			Vector3 manaCrystalSpawnPosition = ManaCrystalMgr.Get().GetManaCrystalSpawnPosition();
-			Vector3 position;
-			Notification.PopUpArrowDirection direction;
-			if ((bool)UniversalInputManager.UsePhoneUI)
-			{
-				position = new Vector3(manaCrystalSpawnPosition.x - 0.7f, manaCrystalSpawnPosition.y + 1.14f, manaCrystalSpawnPosition.z + 4.33f);
-				direction = Notification.PopUpArrowDirection.RightDown;
-			}
-			else
-			{
-				position = new Vector3(manaCrystalSpawnPosition.x - 0.02f, manaCrystalSpawnPosition.y + 0.2f, manaCrystalSpawnPosition.z + 1.8f);
-				direction = Notification.PopUpArrowDirection.Down;
-			}
-			m_manaRefreshNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_Mana_02"));
-			m_manaRefreshNotification.ShowPopUpArrow(direction);
-			break;
-		}
-		case 6:
-			GameState.Get().SetBusy(busy: true);
-			yield return new WaitForSeconds(1.5f);
-			yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Turn_04);
-			GameState.Get().SetBusy(busy: false);
-			break;
-		case 7:
-			GameState.Get().SetBusy(busy: true);
-			yield return new WaitForSeconds(1.5f);
-			yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_OnDrawFireball_01);
-			GameState.Get().SetBusy(busy: false);
-			break;
-		case 8:
-			GameState.Get().SetBusy(busy: true);
-			yield return new WaitForSeconds(1.5f);
-			yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Turn_01);
-			GameState.Get().SetBusy(busy: false);
-			break;
-		case 9:
-			GameState.Get().SetBusy(busy: true);
-			yield return new WaitForSeconds(1.5f);
-			yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_HELPER_ENEMY_SPECIALMINION_01);
-			GameState.Get().SetBusy(busy: false);
-			break;
-		case 10:
-			GameState.Get().SetBusy(busy: true);
-			yield return new WaitForSeconds(1.5f);
-			yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Turn_03);
-			GameState.Get().SetBusy(busy: false);
-			break;
-		case 11:
-			GameState.Get().SetBusy(busy: true);
-			yield return new WaitForSeconds(1.5f);
-			yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_HELPER_EMPTYBOARD2_01);
-			GameState.Get().SetBusy(busy: false);
-			break;
-		case 12:
-			yield return new WaitForSeconds(1.5f);
-			yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Turn_05);
-			break;
-		case 13:
-			yield return new WaitForSeconds(1.5f);
-			HideTutorialNotification();
-			yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_Turn_07);
-			break;
+			case 1:
+				{
+					Vector3 manaCrystalSpawnPosition2 = ManaCrystalMgr.Get().GetManaCrystalSpawnPosition();
+					Vector3 position2;
+					Notification.PopUpArrowDirection direction2;
+					if ((bool)UniversalInputManager.UsePhoneUI)
+					{
+						position2 = new Vector3(manaCrystalSpawnPosition2.x - 0.7f, manaCrystalSpawnPosition2.y + 1.14f, manaCrystalSpawnPosition2.z + 4.33f);
+						direction2 = Notification.PopUpArrowDirection.RightDown;
+					}
+					else
+					{
+						position2 = new Vector3(manaCrystalSpawnPosition2.x - 0.02f, manaCrystalSpawnPosition2.y + 0.2f, manaCrystalSpawnPosition2.z + 1.8f);
+						direction2 = Notification.PopUpArrowDirection.Down;
+					}
+					m_manaNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position2, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_Mana"));
+					m_manaNotification.ShowPopUpArrow(direction2);
+
+					Speak(LocalizationKey.TUTORIAL_MILLHOUSE_SEE_MANA_HELP, AccessibleKey.SEE_PLAYER_MANA);
+					break;
+				}
+			case 3:
+				{
+					Vector3 manaCrystalSpawnPosition = ManaCrystalMgr.Get().GetManaCrystalSpawnPosition();
+					Vector3 position;
+					Notification.PopUpArrowDirection direction;
+					if ((bool)UniversalInputManager.UsePhoneUI)
+					{
+						position = new Vector3(manaCrystalSpawnPosition.x - 0.7f, manaCrystalSpawnPosition.y + 1.14f, manaCrystalSpawnPosition.z + 4.33f);
+						direction = Notification.PopUpArrowDirection.RightDown;
+					}
+					else
+					{
+						position = new Vector3(manaCrystalSpawnPosition.x - 0.02f, manaCrystalSpawnPosition.y + 0.2f, manaCrystalSpawnPosition.z + 1.8f);
+						direction = Notification.PopUpArrowDirection.Down;
+					}
+					m_manaRefreshNotification = NotificationManager.Get().CreatePopupText(UserAttentionBlocker.NONE, position, TutorialEntity.GetTextScale(), GameStrings.Get("TUTR_HELPER_Fight_01_Mana_02"));
+					m_manaRefreshNotification.ShowPopUpArrow(direction);
+					break;
+				}
+			case 6:
+				GameState.Get().SetBusy(busy: true);
+				yield return new WaitForSeconds(1.5f);
+				yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Turn_04);
+				GameState.Get().SetBusy(busy: false);
+				break;
+			case 7:
+				GameState.Get().SetBusy(busy: true);
+				yield return new WaitForSeconds(1.5f);
+				yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_OnDrawFireball_01);
+				GameState.Get().SetBusy(busy: false);
+				break;
+			case 8:
+				GameState.Get().SetBusy(busy: true);
+				yield return new WaitForSeconds(1.5f);
+				yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Turn_01);
+				GameState.Get().SetBusy(busy: false);
+				break;
+			case 9:
+				GameState.Get().SetBusy(busy: true);
+				yield return new WaitForSeconds(1.5f);
+				yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_HELPER_ENEMY_SPECIALMINION_01);
+				GameState.Get().SetBusy(busy: false);
+				break;
+			case 10:
+				GameState.Get().SetBusy(busy: true);
+				yield return new WaitForSeconds(1.5f);
+				yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Turn_03);
+				GameState.Get().SetBusy(busy: false);
+				break;
+			case 11:
+				GameState.Get().SetBusy(busy: true);
+				yield return new WaitForSeconds(1.5f);
+				yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_HELPER_EMPTYBOARD2_01);
+				GameState.Get().SetBusy(busy: false);
+				break;
+			case 12:
+				yield return new WaitForSeconds(1.5f);
+				yield return MissionPlayVO(enemyActor, VO_TUTR_Garrosh_GarroshHellscream_Orc_InGame_Turn_05);
+				break;
+			case 13:
+				yield return new WaitForSeconds(1.5f);
+				HideTutorialNotification();
+				yield return MissionPlayVO(friendlyActor, VO_TUTR_Jaina_JainaProudmoore_Human_InGame_Turn_07);
+				break;
 		}
 	}
 
@@ -698,16 +717,16 @@ public class Tutorial_Fight_002 : Tutorial_Dungeon
 		EndTurnButton endTurnButton = EndTurnButton.Get();
 		switch (state)
 		{
-		case ActorStateType.ENDTURN_NO_MORE_PLAYS:
-			endTurnButton.ShowEndTurnBouncingArrowButtonAfterWait(m_waitTimesForEndTurnBounceArrow[m_timerIndex], m_tutorialConfig.m_EndTurnButtonArrowOffset);
-			if (m_timerIndex < m_waitTimesForEndTurnBounceArrow.Length - 1)
-			{
-				m_timerIndex++;
-			}
-			break;
-		case ActorStateType.ENDTURN_NMP_2_WAITING:
-			endTurnButton.HideEndTurnBouncingArrow();
-			break;
+			case ActorStateType.ENDTURN_NO_MORE_PLAYS:
+				endTurnButton.ShowEndTurnBouncingArrowButtonAfterWait(m_waitTimesForEndTurnBounceArrow[m_timerIndex], m_tutorialConfig.m_EndTurnButtonArrowOffset);
+				if (m_timerIndex < m_waitTimesForEndTurnBounceArrow.Length - 1)
+				{
+					m_timerIndex++;
+				}
+				break;
+			case ActorStateType.ENDTURN_NMP_2_WAITING:
+				endTurnButton.HideEndTurnBouncingArrow();
+				break;
 		}
 	}
 
@@ -737,4 +756,28 @@ public class Tutorial_Fight_002 : Tutorial_Dungeon
 			ChangeAnimationStateForTutorial(m_entityinTargetMode, m_entityinTargetMode.GetCardId(), tag, m_entityinTargetMode.GetZone(), SpellStateType.BIRTH);
 		}
 	}
+
+	#region Accessibility
+	public override void NotifyOfMulliganInitialized()
+	{
+		base.NotifyOfMulliganInitialized();
+		GameEntity.Coroutines.StartCoroutine(DoGarroshIntro());
+	}
+
+	private IEnumerator DoGarroshIntro()
+	{
+		GameState.Get().SetBusy(busy: true);
+		yield return new WaitForSeconds(10f);
+		Speak(LocalizationKey.TUTORIAL_MUKLA_START);    // In this game, you'll see some cards with abilities you haven't seen before
+		Speak(LocalizationKey.TUTORIAL_MUKLA_START_B, AccessibleKey.READ_TOOLTIP);  // If you run into something you don't understand when reading a card such as Charge or Taunt, press {0} to get more information
+		Speak(LocalizationKey.TUTORIAL_MUKLA_START_C, AccessibleKey.CONFIRM);   // Press enter whenever you're ready to start
+		bool waitingForEnter = true;
+		AccessibilityMgr.WaitForForcedKey(AccessibleKey.CONFIRM, delegate
+		{
+			waitingForEnter = false;
+		});
+		yield return new WaitWhile(() => waitingForEnter);
+		GameState.Get().SetBusy(busy: false);
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/Tutorial_Fight_003.cs b/Assembly-CSharp/Tutorial_Fight_003.cs
index 4c71f83..53dbd4a 100644
--- a/Assembly-CSharp/Tutorial_Fight_003.cs
+++ b/Assembly-CSharp/Tutorial_Fight_003.cs
@@ -1,5 +1,6 @@
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Blizzard.T5.AssetManager;
 using UnityEngine;
 
@@ -124,6 +125,8 @@ public class Tutorial_Fight_003 : Tutorial_Dungeon
 				componentsInChildren[i].gameObject.SetActive(value: false);
 			}
 		}
+
+		AccessibleGameplay.Get().DisableCorpseCounters();
 	}
 
 	public override bool NotifyOfEndTurnButtonPushed()
@@ -372,4 +375,38 @@ public class Tutorial_Fight_003 : Tutorial_Dungeon
 			break;
 		}
 	}
+
+	#region Accessibility
+	protected override IEnumerator RespondToPlayedCardWithTiming(Entity entity)
+	{
+		while (m_enemySpeaking)
+		{
+			yield return null;
+		}
+		while (entity.GetCardType() == TAG_CARDTYPE.INVALID)
+		{
+			yield return null;
+		}
+
+		yield return base.RespondToPlayedCardWithTiming(entity);
+		yield return WaitForEntitySoundToFinish(entity);
+
+		if (entity.GetCardType() == TAG_CARDTYPE.WEAPON)
+		{
+			GameState.Get().SetBusy(busy: true);
+			yield return new WaitForSeconds(3f);
+			Speak(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP);	// It looks like your opponent equipped a weapon
+			Speak(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_B);	// Weapons are special cards which can be equipped by heroes
+			Speak(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_C);	// Each weapon has some attack and some durability
+			Speak(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_D);	// Once equipped, heroes can attack other characters during their turn
+			Speak(LocalizationKey.NEW_TUTORIAL_LICH_KING_WEAPON_EQUIPPED_HELP_E);	// Your opponent equipped Frostmourne, a weapon with 3 attack and 5 durability
+			Speak(LocalizationKey.NEW_TUTORIAL_LICH_KING_WEAPON_EQUIPPED_HELP_F);	// This means your opponent's Hero will have 3 attack during his turn, and will be able to attack any of your characters
+			Speak(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_G);	// Mages don't often use weapons, but you'll be able to play with some later on once you've unlocked other classes
+			Speak(LocalizationKey.TUTORIAL_ILLIDAN_WEAPON_EQUIPPED_HELP_H, AccessibleKey.SEE_PLAYER_WEAPON, AccessibleKey.SEE_OPPONENT_WEAPON);	// You can press W at any time to see your weapon or Shift+W to see your opponent's one
+			yield return new WaitForSeconds(17f);
+			GameState.Get().SetBusy(busy: false);
+		}
+
+	}
+	#endregion
 }
diff --git a/Assembly-CSharp/TwistDetailsDisplayManager.cs b/Assembly-CSharp/TwistDetailsDisplayManager.cs
index cc5cb69..edd7651 100644
--- a/Assembly-CSharp/TwistDetailsDisplayManager.cs
+++ b/Assembly-CSharp/TwistDetailsDisplayManager.cs
@@ -5,6 +5,7 @@ using Hearthstone.DataModels;
 using Hearthstone.UI;
 using PegasusShared;
 using UnityEngine;
+using Accessibility;
 
 public class TwistDetailsDisplayManager : MonoBehaviour
 {
@@ -93,33 +94,33 @@ public class TwistDetailsDisplayManager : MonoBehaviour
 		m_twistPageHeaderWidget = widget;
 		if (m_twistRankedPlaySeason != null)
 		{
-			widget.BindDataModel(TwistSeasonInfoModel);
+		widget.BindDataModel(TwistSeasonInfoModel);
 			if (m_twistRankedPlaySeason.SeasonDesc != null)
-			{
+		{
 				TwistSeasonInfoModel.SeasonDescription = GameStrings.Get(m_twistRankedPlaySeason.SeasonDesc);
-			}
-			else
-			{
+		}
+		else
+		{
 				Debug.LogError("Season record has no Desc, please update the SeasonDesc for season id" + m_twistRankedPlaySeason.ID);
-			}
+		}
 			if (m_twistRankedPlaySeason.SeasonTitle != null)
-			{
+		{
 				TwistSeasonInfoModel.SeasonTitle = GameStrings.Get(m_twistRankedPlaySeason.SeasonTitle);
-			}
-			else
-			{
+		}
+		else
+		{
 				Debug.LogError("Season record has no Title, please update the SeasonTitle for season id" + m_twistRankedPlaySeason.ID);
-			}
+		}
 			List<TAG_CARD_SET> twistSetsWithFilter = GameUtils.GetTwistSetsWithFilter(m_twistRankedPlaySeason.HiddenCardSets);
 			GameUtils.FillTwistDataModelWithValidSets(TwistSeasonInfoModel, twistSetsWithFilter);
 			m_seasonTimeLeft = RankMgr.GetTimeLeftInCurrentSeason();
-			TwistSeasonInfoModel.RemainingSeasonTime = TimeUtils.GetCountdownTimerString(m_seasonTimeLeft, getFinalSeconds: true);
-			if (m_seasonTimeLeft.TotalSeconds > 1.0)
-			{
-				TwistSeasonInfoModel.IsTwistSeasonEnabled = true;
-			}
-			StartCoroutine(TickTwistSeasonTimer());
+		TwistSeasonInfoModel.RemainingSeasonTime = TimeUtils.GetCountdownTimerString(m_seasonTimeLeft, getFinalSeconds: true);
+		if (m_seasonTimeLeft.TotalSeconds > 1.0)
+		{
+			TwistSeasonInfoModel.IsTwistSeasonEnabled = true;
 		}
+		StartCoroutine(TickTwistSeasonTimer());
+	}
 	}
 
 	private void OnTwistIntroPopupWidgetReady(Widget widget)
@@ -134,7 +135,7 @@ public class TwistDetailsDisplayManager : MonoBehaviour
 			flag = collectionManager.AccountHasUnlockedWild();
 		}
 		TwistSeasonInfoModel.ShouldShowTwistLoginPopup = false;
-		if (SceneMgr.Get().GetMode() == SceneMgr.Mode.TOURNAMENT && value == 0 && flag && CanShowingTwistPopups())
+		if (SceneMgr.Get().GetMode() == SceneMgr.Mode.TOURNAMENT && value == 0 && flag && CanShowingTwistPopups() && !AccessibilityMgr.IsAccessibilityEnabled())
 		{
 			TwistSeasonInfoModel.ShouldShowTwistLoginPopup = true;
 		}
diff --git a/Assembly-CSharp/UIBScrollable.cs b/Assembly-CSharp/UIBScrollable.cs
index eebbd77..901c6d8 100644
--- a/Assembly-CSharp/UIBScrollable.cs
+++ b/Assembly-CSharp/UIBScrollable.cs
@@ -233,7 +233,7 @@ public class UIBScrollable : PegUICustomBehavior
 
 	private bool m_ForceShowVisibleAffectedObjects;
 
-	private List<UIBScrollableItem> m_scrollableItems = new List<UIBScrollableItem>();
+	internal List<UIBScrollableItem> m_scrollableItems = new List<UIBScrollableItem>();
 
 	private int m_currentHierarchyCount;
 
@@ -300,10 +300,10 @@ public class UIBScrollable : PegUICustomBehavior
 		{
 			if (m_ScrollBounds != null)
 			{
-				m_ScrollBounds.center = value;
-			}
+			m_ScrollBounds.center = value;
 		}
 	}
+	}
 
 	[Overridable]
 	public Vector3 ScrollBoundsSize
@@ -320,10 +320,10 @@ public class UIBScrollable : PegUICustomBehavior
 		{
 			if (m_ScrollBounds != null)
 			{
-				m_ScrollBounds.size = value;
-			}
+			m_ScrollBounds.size = value;
 		}
 	}
+	}
 
 	public GameObject ScrollObject
 	{
diff --git a/Assembly-CSharp/UIBScrollableItem.cs b/Assembly-CSharp/UIBScrollableItem.cs
index ae84690..7e5c733 100644
--- a/Assembly-CSharp/UIBScrollableItem.cs
+++ b/Assembly-CSharp/UIBScrollableItem.cs
@@ -9,7 +9,8 @@ public class UIBScrollableItem : MonoBehaviour
 	{
 		Active,
 		Inactive,
-		UseHierarchy
+		UseHierarchy,
+		EOE
 	}
 
 	public enum BoundsMode
diff --git a/Assembly-CSharp/UIStatus.cs b/Assembly-CSharp/UIStatus.cs
index ee5c018..efaa248 100644
--- a/Assembly-CSharp/UIStatus.cs
+++ b/Assembly-CSharp/UIStatus.cs
@@ -1,6 +1,7 @@
 using System.Collections;
 using Hearthstone.Core;
 using UnityEngine;
+using Accessibility;
 
 public class UIStatus : MonoBehaviour
 {
@@ -141,6 +142,8 @@ public class UIStatus : MonoBehaviour
 			{
 				delay = m_FadeDelaySec;
 			}
+
+      AccessibilityMgr.Output(null, message);
 			Hashtable tweenHashTable = iTweenManager.Get().GetTweenHashTable();
 			tweenHashTable.Add("amount", 0f);
 			tweenHashTable.Add("delay", delay);
diff --git a/Assembly-CSharp/UIVoiceLinesTrigger.cs b/Assembly-CSharp/UIVoiceLinesTrigger.cs
index bcdf945..7827ac9 100644
--- a/Assembly-CSharp/UIVoiceLinesTrigger.cs
+++ b/Assembly-CSharp/UIVoiceLinesTrigger.cs
@@ -1,6 +1,6 @@
 using UnityEngine;
 
-[CreateAssetMenu(fileName = "Trigger", menuName = "UIVoiceLinesTool/UIVoiceLinesTrigger", order = 2)]
+// [CreateAssetMenu(fileName = "Trigger", menuName = "UIVoiceLinesTool/UIVoiceLinesTrigger", order = 2)]
 public class UIVoiceLinesTrigger : ScriptableObject
 {
 	public UIVoiceLinesManager.TriggerType m_TriggerType;
diff --git a/Assembly-CSharp/UnityEngine/UI/HSInputField.cs b/Assembly-CSharp/UnityEngine/UI/HSInputField.cs
index c96a252..dc8e556 100644
--- a/Assembly-CSharp/UnityEngine/UI/HSInputField.cs
+++ b/Assembly-CSharp/UnityEngine/UI/HSInputField.cs
@@ -1421,11 +1421,11 @@ namespace UnityEngine.UI
 				}
 				EventType type = m_ProcessingEvent.type;
 				if ((uint)(type - 13) <= 1u && m_ProcessingEvent.commandName == "SelectAll")
-				{
-					SelectAll();
-					flag = true;
+					{
+						SelectAll();
+						flag = true;
+					}
 				}
-			}
 			if (flag)
 			{
 				UpdateLabel();
@@ -2026,22 +2026,22 @@ namespace UnityEngine.UI
 		private void OnFillVBO(Mesh vbo)
 		{
 			using VertexHelper vertexHelper = new VertexHelper();
-			if (!isFocused)
-			{
+				if (!isFocused)
+				{
+					vertexHelper.FillMesh(vbo);
+					return;
+				}
+				Vector2 roundingOffset = m_TextComponent.PixelAdjustPoint(Vector2.zero);
+				if (!hasSelection)
+				{
+					GenerateCaret(vertexHelper, roundingOffset);
+				}
+				else
+				{
+					GenerateHighlight(vertexHelper, roundingOffset);
+				}
 				vertexHelper.FillMesh(vbo);
-				return;
-			}
-			Vector2 roundingOffset = m_TextComponent.PixelAdjustPoint(Vector2.zero);
-			if (!hasSelection)
-			{
-				GenerateCaret(vertexHelper, roundingOffset);
 			}
-			else
-			{
-				GenerateHighlight(vertexHelper, roundingOffset);
-			}
-			vertexHelper.FillMesh(vbo);
-		}
 
 		private void GenerateCaret(VertexHelper vbo, Vector2 roundingOffset)
 		{
@@ -2488,10 +2488,6 @@ namespace UnityEngine.UI
 		{
 		}
 
-		[SpecialName]
-		Transform ICanvasElement.get_transform()
-		{
-			return base.transform;
-		}
+
 	}
 }
diff --git a/Assembly-CSharp/UniversalInputManager.cs b/Assembly-CSharp/UniversalInputManager.cs
index e7d2b39..79718f6 100644
--- a/Assembly-CSharp/UniversalInputManager.cs
+++ b/Assembly-CSharp/UniversalInputManager.cs
@@ -6,6 +6,7 @@ using Blizzard.T5.Jobs;
 using Blizzard.T5.Services;
 using Hearthstone;
 using UnityEngine;
+using Accessibility;
 
 public class UniversalInputManager : IHasUpdate, IService
 {
@@ -974,6 +975,13 @@ public class UniversalInputManager : IHasUpdate, IService
 		{
 			return;
 		}
+
+		if (AccessibilityMgr.IsAccessibilityEnabled())
+        {
+			AccessibilityMgr.HandleKeyboardInput();
+			return;
+        }
+
 		InputManager inputManager = InputManager.Get();
 		if ((inputManager != null && inputManager.HandleKeyboardInput()) || HearthstoneCheckoutBlocksInput())
 		{
@@ -1121,6 +1129,8 @@ public class UniversalInputManager : IHasUpdate, IService
 		m_inputCanceledCallback = null;
 		m_inputUnfocusedCallback = null;
 		_ = Application.isEditor;
+
+		AccessibilityMgr.DisallowTextInput();
 	}
 
 	private bool IgnoreGUIInput()
diff --git a/Assembly-CSharp/UserAttentionManager.cs b/Assembly-CSharp/UserAttentionManager.cs
index 57555ae..eadc6b1 100644
--- a/Assembly-CSharp/UserAttentionManager.cs
+++ b/Assembly-CSharp/UserAttentionManager.cs
@@ -21,7 +21,7 @@ public static class UserAttentionManager
 		get
 		{
 			IEnumerable<string> source = (from UserAttentionBlocker r in Enum.GetValues(typeof(UserAttentionBlocker))
-				where IsBlockedBy(r)
+				where IsBlockedBy(true, r)
 				select r).Select(delegate(UserAttentionBlocker r)
 			{
 				UserAttentionBlocker userAttentionBlocker = r;
@@ -31,7 +31,12 @@ public static class UserAttentionManager
 		}
 	}
 
-	public static bool IsBlockedBy(UserAttentionBlocker attentionCategory)
+	public static bool IsBlockedBy(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		return IsBlockedBy(attentionCategory);
+    }
+
+	private static bool IsBlockedBy(UserAttentionBlocker attentionCategory)
 	{
 		if (attentionCategory != 0)
 		{
@@ -40,12 +45,22 @@ public static class UserAttentionManager
 		return false;
 	}
 
-	public static bool CanShowAttentionGrabber(string callerName)
+	public static bool CanShowAttentionGrabber(bool markedForAccessibility, string callerName)
+    {
+		return CanShowAttentionGrabber(callerName);
+    }
+
+	private static bool CanShowAttentionGrabber(string callerName)
 	{
-		return CanShowAttentionGrabber(UserAttentionBlocker.NONE, callerName);
+		return CanShowAttentionGrabber(true, UserAttentionBlocker.NONE, callerName);
 	}
 
-	public static bool CanShowAttentionGrabber(UserAttentionBlocker attentionCategory, string callerName)
+	public static bool CanShowAttentionGrabber(bool markedForAccessibility, UserAttentionBlocker attentionCategory, string callerName)
+    {
+		return CanShowAttentionGrabber(attentionCategory, callerName);
+    }
+
+	private static bool CanShowAttentionGrabber(UserAttentionBlocker attentionCategory, string callerName)
 	{
 		if ((s_blockedReasons & ~attentionCategory) != 0)
 		{
@@ -54,9 +69,14 @@ public static class UserAttentionManager
 		return true;
 	}
 
-	public static void StartBlocking(UserAttentionBlocker attentionCategory)
+	public static void StartBlocking(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		StartBlocking(attentionCategory);
+    }
+
+	private static void StartBlocking(UserAttentionBlocker attentionCategory)
 	{
-		if (!IsBlockedBy(attentionCategory))
+		if (!IsBlockedBy(true, attentionCategory))
 		{
 			bool isBlocked = IsBlocked;
 			if (isBlocked)
@@ -73,7 +93,12 @@ public static class UserAttentionManager
 		}
 	}
 
-	public static void StopBlocking(UserAttentionBlocker attentionCategory)
+	public static void StopBlocking(bool markedForAccessibility, UserAttentionBlocker attentionCategory)
+    {
+		StopBlocking(attentionCategory);
+    }
+
+	private static void StopBlocking(UserAttentionBlocker attentionCategory)
 	{
 		bool isBlocked = IsBlocked;
 		s_blockedReasons &= ~attentionCategory;
@@ -95,7 +120,12 @@ public static class UserAttentionManager
 		}
 	}
 
-	public static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool isFriendlyChallenge)
+	public static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool markedForAccessibility, bool isFriendlyChallenge)
+    {
+		return GetAvailabilityBlockerReason(isFriendlyChallenge);
+    }
+
+	private static AvailabilityBlockerReasons GetAvailabilityBlockerReason(bool isFriendlyChallenge)
 	{
 		if (SpectatorManager.Get().IsInSpectatorMode())
 		{
diff --git a/Assembly-CSharp/VictoryScreenICCFinale.cs b/Assembly-CSharp/VictoryScreenICCFinale.cs
index 7e3bc0c..22b6871 100644
--- a/Assembly-CSharp/VictoryScreenICCFinale.cs
+++ b/Assembly-CSharp/VictoryScreenICCFinale.cs
@@ -287,6 +287,9 @@ public class VictoryScreenICCFinale : VictoryScreen
 			m_continueText.gameObject.SetActive(value: true);
 		}
 		m_hitbox.AddEventListener(UIEventType.RELEASE, ContinueButtonPress_HideTwoScoop);
+		#region accessibility
+		m_hitbox.TriggerRelease();
+		#endregion
 		while (!m_dismissedTwoScoops)
 		{
 			yield return null;
diff --git a/Assembly-CSharp/VirtualCurrencyPurchasePage.cs b/Assembly-CSharp/VirtualCurrencyPurchasePage.cs
index 273eb0d..8c353ad 100644
--- a/Assembly-CSharp/VirtualCurrencyPurchasePage.cs
+++ b/Assembly-CSharp/VirtualCurrencyPurchasePage.cs
@@ -38,7 +38,7 @@ public class VirtualCurrencyPurchasePage : ProductPage
 
 	public void OpenToSKU(ProductDataModel vcVariant, bool closeOnPurchase = false)
 	{
-		base.Open();
+		base.Open(false);
 		m_closeOnPurchase = closeOnPurchase;
 		if (vcVariant == null)
 		{
diff --git a/Assembly-CSharp/W8Touch.cs b/Assembly-CSharp/W8Touch.cs
index 8b6e2ca..ad3791e 100644
--- a/Assembly-CSharp/W8Touch.cs
+++ b/Assembly-CSharp/W8Touch.cs
@@ -9,7 +9,7 @@ using UnityEngine;
 
 public class W8Touch : ITouchScreenService, IService, IHasUpdate
 {
-	[StructLayout(0, Pack = 1)]
+	[StructLayout((short)0, Pack = 1)]
 	public class tTouchData
 	{
 		public int m_x;
diff --git a/Assembly-CSharp/WelcomeQuests.cs b/Assembly-CSharp/WelcomeQuests.cs
index 71db7d5..11cfb5a 100644
--- a/Assembly-CSharp/WelcomeQuests.cs
+++ b/Assembly-CSharp/WelcomeQuests.cs
@@ -1,8 +1,9 @@
 using System.Collections.Generic;
 using Assets;
 using UnityEngine;
+using Accessibility;
 
-public class WelcomeQuests : MonoBehaviour
+public class WelcomeQuests : MonoBehaviour, AccessibleUI
 {
 	public delegate void DelOnWelcomeQuestsClosed();
 
@@ -72,7 +73,7 @@ public class WelcomeQuests : MonoBehaviour
 
 	public static bool Show(UserAttentionBlocker blocker, bool fromLogin, DelOnWelcomeQuestsClosed onCloseCallback = null, bool keepRichPresence = false)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "WelcomeQuests.Show:" + fromLogin))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "WelcomeQuests.Show:" + fromLogin))
 		{
 			onCloseCallback?.Invoke();
 			return false;
@@ -97,7 +98,7 @@ public class WelcomeQuests : MonoBehaviour
 
 	public static void ShowSpecialQuest(UserAttentionBlocker blocker, Achievement achievement, DelOnWelcomeQuestsClosed onCloseCallback = null, bool keepRichPresence = false)
 	{
-		if (!UserAttentionManager.CanShowAttentionGrabber(blocker, "WelcomeQuests.ShowSpecialQuest:" + ((achievement == null) ? "null" : achievement.ID.ToString())))
+		if (!UserAttentionManager.CanShowAttentionGrabber(true, blocker, "WelcomeQuests.ShowSpecialQuest:" + ((achievement == null) ? "null" : achievement.ID.ToString())))
 		{
 			onCloseCallback?.Invoke();
 			return;
@@ -176,6 +177,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void OnDestroy()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		FadeEffectsOut();
 		if (s_instance != null)
 		{
@@ -274,6 +277,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void ReinitAndShow(ShowRequestData showRequestData)
 	{
+		AccessibilityMgr.HideUI(this); // Seems like an error condition but not really sure - best effort
+
 		FadeEffectsOut();
 		UnlockBnetButtons();
 		InitAndShow(showRequestData);
@@ -409,6 +414,8 @@ public class WelcomeQuests : MonoBehaviour
 			m_loginQuestShownTime = Time.realtimeSinceStartup;
 			m_clickCatcher.AddEventListener(UIEventType.RELEASE, SendTelemetry);
 		}
+
+		ReadQuests();
 	}
 
 	private void CheckShowInnkeepersSpecial()
@@ -478,6 +485,8 @@ public class WelcomeQuests : MonoBehaviour
 
 	private void Close()
 	{
+		AccessibilityMgr.HideUI(this);
+
 		CleanUpEventListeners();
 		UnlockBnetButtons();
 		s_instance = null;
@@ -576,4 +585,89 @@ public class WelcomeQuests : MonoBehaviour
 			m_bnetButtonsLocked = false;
 		}
 	}
+
+	#region Accessibility
+	private AccessibleListOfItems<AccessibleQuestTile> m_accessibleQuests;
+
+	private AccessibleQuestTile m_accessibleQuestTile;
+
+	private void ReadQuests()
+    {
+		m_accessibleQuestTile = null;
+		m_accessibleQuests = null;
+
+        AccessibilityMgr.ShowUI(this);
+        AccessibilityMgr.Output(this, LocalizedText.UI_POPUP, true);
+        AccessibilityMgr.Output(this, m_headlineBanner.m_headline.Text);
+
+		if (m_currentQuests.Count == 1)
+        {
+			m_accessibleQuestTile = new AccessibleQuestTile(this, m_currentQuests[0]);
+			m_accessibleQuestTile.ReadAllLines();
+        }
+		else
+        {
+            var accessibleQuests = new List<AccessibleQuestTile>();
+            foreach (var quest in m_currentQuests)
+            {
+                accessibleQuests.Add(new AccessibleQuestTile(this, quest));
+            }
+
+            m_accessibleQuests = new AccessibleListOfItems<AccessibleQuestTile>(this, accessibleQuests);
+            m_accessibleQuests.StartReading();
+        }
+    }
+
+    public void HandleAccessibleInput()
+    {
+        if (AccessibleKey.CONFIRM.IsPressed())
+        {
+			m_clickCatcher.TriggerRelease();
+        }
+        else
+        {
+			m_accessibleQuestTile?.HandleAccessibleInput();
+            m_accessibleQuests?.HandleAccessibleInput();
+        }
+    }
+
+    public string GetAccessibleHelp()
+    {
+		if (m_accessibleQuests != null)
+        {
+            GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
+            {
+                new GameStrings.PluralNumber
+                {
+                    m_index = 0,
+                    m_number = 2 // Doesn't really matter as long as it's not 1
+                }
+            };
+
+			var text = LocalizationUtils.FormatPlurals(LocalizationKey.UI_WELCOME_QUESTS_HELP, pluralNumbers);
+			var confirmText = AccessibleSpeech.PRESS_CONFIRM_ONCE_DONE;
+
+			return AccessibleSpeechUtils.CombineSentences(text, confirmText);
+        }
+		else if (m_accessibleQuestTile != null)
+        {
+            GameStrings.PluralNumber[] pluralNumbers = new GameStrings.PluralNumber[1]
+            {
+                new GameStrings.PluralNumber
+                {
+                    m_index = 0,
+                    m_number = 1
+                }
+            };
+
+			var text = LocalizationUtils.FormatPlurals(LocalizationKey.UI_WELCOME_QUESTS_HELP, pluralNumbers);
+			var confirmText = AccessibleSpeech.PRESS_CONFIRM_ONCE_DONE;
+
+			return AccessibleSpeechUtils.CombineSentences(text, confirmText);
+        }
+
+		return AccessibleSpeech.PRESS_ENTER_TO_CONTINUE;
+    }
+
+	#endregion
 }
diff --git a/Assembly-CSharp/ZilliaxDeckSideboardTray.cs b/Assembly-CSharp/ZilliaxDeckSideboardTray.cs
index cb7ce2f..ceacf22 100644
--- a/Assembly-CSharp/ZilliaxDeckSideboardTray.cs
+++ b/Assembly-CSharp/ZilliaxDeckSideboardTray.cs
@@ -1,6 +1,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Accessibility;
 using Assets;
 using Blizzard.T5.Core;
 using Hearthstone.UI;
@@ -174,42 +175,42 @@ public class ZilliaxDeckSideboardTray : DeckSideboardTray
 			BuildSavedZilliaxVersions();
 		}
 		GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.HAS_SEEN_ZILLIAX_CUSTOMIZABLE_FTUE, out long value);
-		m_hasSeenFTUE = value > 0;
+		m_hasSeenFTUE = AccessibilityMgr.IsAccessibilityEnabled() || value > 0;
 		CollectionDeck mainDeck = m_zilliaxSideboardDeck.MainDeck;
 		if (mainDeck.CreatedFromShareableDeck == null && !mainDeck.IsCreatedWithDeckComplete)
 		{
-			if (!m_hasSeenFTUE)
+		if (!m_hasSeenFTUE)
+		{
+			if (!m_isFTUEInitialized)
 			{
-				if (!m_isFTUEInitialized)
-				{
-					SetupFTUEStep(FTUEStep.MODULE, m_modulesTooltip);
-					SetupFTUEStep(FTUEStep.PREVIEW, m_previewTooltip);
-					SetupFTUEStep(FTUEStep.PORTRAIT, m_portraitTooltip);
-					SetupFTUEStep(FTUEStep.SAVED, m_savedTooltip);
-					m_isFTUEInitialized = true;
-				}
-				if (m_previewButton != null)
-				{
-					m_previewButton.AddEventListener(UIEventType.PRESS, OnButtonPressed);
-					m_previewButton.AddEventListener(UIEventType.ROLLOVER, OnPreviewButtonOver);
-				}
-				SetCurrentFTUEStep(FTUEStep.MODULE);
+				SetupFTUEStep(FTUEStep.MODULE, m_modulesTooltip);
+				SetupFTUEStep(FTUEStep.PREVIEW, m_previewTooltip);
+				SetupFTUEStep(FTUEStep.PORTRAIT, m_portraitTooltip);
+				SetupFTUEStep(FTUEStep.SAVED, m_savedTooltip);
+				m_isFTUEInitialized = true;
+			}
+			if (m_previewButton != null)
+			{
+				m_previewButton.AddEventListener(UIEventType.PRESS, OnButtonPressed);
+				m_previewButton.AddEventListener(UIEventType.ROLLOVER, OnPreviewButtonOver);
+			}
+			SetCurrentFTUEStep(FTUEStep.MODULE);
+		}
+		else
+		{
+			GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.HAS_SEEN_ZILLIAX_CUSTOMIZABLE_SAVED_VERSIONS_FTUE, out long value2);
+			if (AccessibilityMgr.IsAccessibilityEnabled() || value2 > 0)
+			{
+				SetCurrentFTUEStep(FTUEStep.COMPLETE);
 			}
 			else
 			{
-				GameSaveDataManager.Get().GetSubkeyValue(GameSaveKeyId.FTUE, GameSaveKeySubkeyId.HAS_SEEN_ZILLIAX_CUSTOMIZABLE_SAVED_VERSIONS_FTUE, out long value2);
-				if (value2 > 0)
-				{
-					SetCurrentFTUEStep(FTUEStep.COMPLETE);
-				}
-				else
-				{
-					SetupFTUEStep(FTUEStep.SAVED, m_savedTooltip);
-					m_isFTUEInitialized = true;
-					SetCurrentFTUEStep(FTUEStep.SAVED);
-				}
+				SetupFTUEStep(FTUEStep.SAVED, m_savedTooltip);
+				m_isFTUEInitialized = true;
+				SetCurrentFTUEStep(FTUEStep.SAVED);
 			}
 		}
+		}
 		else
 		{
 			SetCurrentFTUEStep(FTUEStep.COMPLETE);
@@ -763,6 +764,11 @@ public class ZilliaxDeckSideboardTray : DeckSideboardTray
 		}
 		m_isAnimating = false;
 		m_constructionAnimationCoroutine = null;
+
+		// Just close the tray immediately, no point in the extra clicks for blind players.
+		yield return new WaitForSeconds(2);
+		Navigation.GoBack();
+		CollectionDeckTray.Get().OnSideboardDoneButtonPressed();
 	}
 
 	public void LoadNewActorAndConstructIt()
